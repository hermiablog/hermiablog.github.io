<!DOCTYPE HTML>
<html lang="zh-CN">


<head>
    <meta charset="utf-8">
    <meta name="keywords" content="JS核心知识点（二十三）, 技术博客">
    <meta name="description" content="个人技术博客">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <meta name="renderer" content="webkit|ie-stand|ie-comp">
    <meta name="mobile-web-app-capable" content="yes">
    <meta name="format-detection" content="telephone=no">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <!-- Global site tag (gtag.js) - Google Analytics -->


    <title>JS核心知识点（二十三） | hermia&#39;s blog</title>
    <link rel="icon" type="image/png" href="/favicon.png">

    <link rel="stylesheet" type="text/css" href="/libs/awesome/css/all.css">
    <link rel="stylesheet" type="text/css" href="/libs/materialize/materialize.min.css">
    <link rel="stylesheet" type="text/css" href="/libs/aos/aos.css">
    <link rel="stylesheet" type="text/css" href="/libs/animate/animate.min.css">
    <link rel="stylesheet" type="text/css" href="/libs/lightGallery/css/lightgallery.min.css">
    <link rel="stylesheet" type="text/css" href="/css/matery.css">
    <link rel="stylesheet" type="text/css" href="/css/my.css">

    <script src="/libs/jquery/jquery.min.js"></script>

<meta name="generator" content="Hexo 6.3.0"><link rel="stylesheet" href="/css/prism-tomorrow.css" type="text/css"></head>



   <style>
    body{
       background-image: url(https://cdn.pixabay.com/photo/2012/04/14/16/37/sky-34536_1280.png);
       background-repeat:no-repeat;
       background-size:cover;
       background-attachment:fixed;
    }
</style>



<body>
    <header class="navbar-fixed">
    <nav id="headNav" class="bg-color nav-transparent">
        <div id="navContainer" class="nav-wrapper container">
            <div class="brand-logo">
                <a href="/" class="waves-effect waves-light">
                    
                    <img src="/medias/logo.png" class="logo-img" alt="LOGO">
                    
                    <span class="logo-span">hermia&#39;s blog</span>
                </a>
            </div>
            

<a href="#" data-target="mobile-nav" class="sidenav-trigger button-collapse"><i class="fas fa-bars"></i></a>
<ul class="right nav-menu">
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/" class="waves-effect waves-light">
      
      <i class="fas fa-home" style="zoom: 0.6;"></i>
      
      <span>首页</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/tags" class="waves-effect waves-light">
      
      <i class="fas fa-tags" style="zoom: 0.6;"></i>
      
      <span>标签</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/categories" class="waves-effect waves-light">
      
      <i class="fas fa-bookmark" style="zoom: 0.6;"></i>
      
      <span>分类</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/archives" class="waves-effect waves-light">
      
      <i class="fas fa-archive" style="zoom: 0.6;"></i>
      
      <span>归档</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/about" class="waves-effect waves-light">
      
      <i class="fas fa-user-circle" style="zoom: 0.6;"></i>
      
      <span>关于</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/friends" class="waves-effect waves-light">
      
      <i class="fas fa-address-book" style="zoom: 0.6;"></i>
      
      <span>友情链接</span>
    </a>
    
  </li>
  
  <li>
    <a href="#searchModal" class="modal-trigger waves-effect waves-light">
      <i id="searchIcon" class="fas fa-search" title="搜索" style="zoom: 0.85;"></i>
    </a>
  </li>
</ul>


<div id="mobile-nav" class="side-nav sidenav">

    <div class="mobile-head bg-color">
        
        <img src="/medias/logo.png" class="logo-img circle responsive-img">
        
        <div class="logo-name">hermia&#39;s blog</div>
        <div class="logo-desc">
            
            个人技术博客
            
        </div>
    </div>

    

    <ul class="menu-list mobile-menu-list">
        
        <li class="m-nav-item">
	  
		<a href="/" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-home"></i>
			
			首页
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/tags" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-tags"></i>
			
			标签
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/categories" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-bookmark"></i>
			
			分类
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/archives" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-archive"></i>
			
			归档
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/about" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-user-circle"></i>
			
			关于
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/friends" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-address-book"></i>
			
			友情链接
		</a>
          
        </li>
        
        
    </ul>
</div>


        </div>

        
    </nav>

</header>

    



<div class="bg-cover pd-header post-cover" style="background-image: url('/medias/featureimages/35.jpg')">
    <div class="container" style="right: 0px;left: 0px;">
        <div class="row">
            <div class="col s12 m12 l12">
                <div class="brand">
                    <h1 class="description center-align post-title">JS核心知识点（二十三）</h1>
                </div>
            </div>
        </div>
    </div>
</div>




<main class="post-container content">

    
    <link
  rel="stylesheet"
  href="/libs/tocbot/tocbot.css"
/>
<style>
  #articleContent h1::before,
  #articleContent h2::before,
  #articleContent h3::before,
  #articleContent h4::before,
  #articleContent h5::before,
  #articleContent h6::before {
    display: block;
    content: " ";
    height: 100px;
    margin-top: -100px;
    visibility: hidden;
  }

  #articleContent :focus {
    outline: none;
  }

  .toc-fixed {
    position: fixed;
    top: 64px;
  }

  /* .toc-widget {
        width: 345px;
        padding-left: 20px;
    } */
  .toc-widget {
    width: 345px;
    padding-left: 20px;
    background-color: rgb(255, 255, 255, 0.7);
    border-radius: 10px;
    box-shadow: 0 10px 35px 2px rgba(0, 0, 0, 0.15),
      0 5px 15px rgba(0, 0, 0, 0.07), 0 2px 5px -5px rgba(0, 0, 0, 0.1) !important;
  }

  .toc-widget .toc-title {
    padding: 35px 0 15px 17px;
    font-size: 1.5rem;
    font-weight: bold;
    line-height: 1.5rem;
  }

  .toc-widget ol {
    padding: 0;
    list-style: none;
  }

  #toc-content {
    padding-bottom: 30px;
    overflow: auto;
  }

  #toc-content ol {
    padding-left: 10px;
  }

  #toc-content ol li {
    padding-left: 10px;
  }

  #toc-content .toc-link:hover {
    color: #a3ddf0;
    font-weight: 700;
    text-decoration: underline;
  }

  #toc-content .toc-link::before {
    background-color: transparent;
    max-height: 25px;

    position: absolute;
    right: 23.5vw;
    display: block;
  }

  #toc-content .is-active-link {
    color: #a3ddf0;
  }

  #floating-toc-btn {
    position: fixed;
    right: 15px;
    bottom: 76px;
    padding-top: 15px;
    margin-bottom: 0;
    z-index: 998;
  }

  #floating-toc-btn .btn-floating {
    width: 48px;
    height: 48px;
  }

  #floating-toc-btn .btn-floating i {
    line-height: 48px;
    font-size: 1.4rem;
  }
</style>
<div class="row">
  <div id="main-content" class="col s12 m12 l9">
    <!-- 文章内容详情 -->
<div id="artDetail">
    <div class="card">
        <div class="card-content article-info">
            <div class="row tag-cate">
                <div class="col s7">
                    
                    <div class="article-tag">
                        
                            <a href="/tags/JS/">
                                <span class="chip bg-color">JS</span>
                            </a>
                        
                    </div>
                    
                </div>
                <div class="col s5 right-align">
                    
                    <div class="post-cate">
                        <i class="fas fa-bookmark fa-fw icon-category"></i>
                        
                            <a href="/categories/%E6%8A%80%E6%9C%AF/" class="post-category">
                                技术
                            </a>
                        
                    </div>
                    
                </div>
            </div>

            <div class="post-info">
                
                <div class="post-date info-break-policy">
                    <i class="far fa-calendar-minus fa-fw"></i>发布日期:&nbsp;&nbsp;
                    2023-12-12
                </div>
                

                
                <div class="post-date info-break-policy">
                    <i class="far fa-calendar-check fa-fw"></i>更新日期:&nbsp;&nbsp;
                    2023-12-18
                </div>
                

                
                <div class="info-break-policy">
                    <i class="far fa-file-word fa-fw"></i>文章字数:&nbsp;&nbsp;
                    22.5k
                </div>
                

                

                
            </div>
        </div>
        <hr class="clearfix">

        

        

        <div class="card-content article-card-content">
            <div id="articleContent">
                <span id="more"></span>
<h2 id="Generator-函数的实践与实践应用"><a href="#Generator-函数的实践与实践应用" class="headerlink" title="Generator 函数的实践与实践应用"></a>Generator 函数的实践与实践应用</h2><h3 id="一、Generator函数基础语法"><a href="#一、Generator函数基础语法" class="headerlink" title="一、Generator函数基础语法"></a>一、<code>Generator</code>函数基础语法</h3><blockquote>
<p><code>Generator</code>函数是<code>ES6</code>提供的一种<strong>异步编程解决方案</strong>，在学习他的异步应用之前，我们先来学习他的基本语法。<br><code>Generator</code>函数可以理解为是一个遍历器（迭代器）对象的生成函数。</p>
<ul>
<li>即：调用<code>Generator</code>可以生成一个遍历器对象。</li>
</ul>
</blockquote>
<ol>
<li>Generator 函数写法<blockquote>
<p>与普通函数相比，<code>Generator</code>函数的写法有如下两个特征：</p>
<ul>
<li>function 命令与函数名之间有一个 <code>*</code>星号</li>
<li>函数体内部可以使用<code>yield</code>语句定义不同的状态。（yield的英文意思是“产出”）</li>
</ul>
</blockquote>
</li>
</ol>
<pre><code>// 定义一个Generator函数
function* gen() &#123;
    yield 1;
    yield 2;
    yield 3;
&#125;
&gt;
// 普通函数内部，不能使用 yield语句，使用会报错
function gen() &#123;
    yield 1; // 报错
&#125;
</code></pre>
<blockquote>
<p>ES6 中并没有规定function关键字与函数名之间的<code>*</code>星号应该写在哪个位置，因此以下写法都是可行的</p>
</blockquote>
<pre><code>function* gen() &#123;&#125; // 一般会选择这种写法
function * gen() &#123;&#125;
function *gen() &#123;&#125;
// 由于Generator函数仍是普通的函数，所以一般会用第1种写法，星号紧跟在function关键字后面
</code></pre>
<ol start="2">
<li>Generator 函数的基本用法<blockquote>
<p><code>Generator</code>函数可以理解为是一个遍历器（迭代器）对象的生成函数。</p>
<ul>
<li>即：调用<code>Generator</code>可以生成一个遍历器对象。</li>
</ul>
</blockquote>
</li>
</ol>
<pre><code>// 定义Generator函数
function* gen() &#123;
  yield 1;
  yield 2;
  yield 3;
&#125;
&gt;
// 调用gen()函数，会返回一个遍历器对象
const iterator = gen();
// 调用遍历器的next方法，手动迭代下一个元素
console.log(iterator.next()); // &#123;value: 1, done: false&#125;
console.log(iterator.next()); // &#123;value: 2, done: false&#125;
console.log(iterator.next()); // &#123;value: 3, done: false&#125;
console.log(iterator.next()); // &#123;value: undefined, done: true&#125;
</code></pre>
<blockquote>
<blockquote>
<p>注：</p>
</blockquote>
<ul>
<li>上面定义的<code>gen</code>函数就是一个<code>Generator</code>函数，其内部用到了<code>yield</code>语句来维持 3 个状态。<code>yield</code>语句<strong>后面的值</strong>就是gen函数生成的遍历器对象的<code>next()</code>方法返回的对象的<code>value</code>属性值。</li>
<li>因为<code>Generator</code>函数的返回值是一个遍历器对象，所以我们可以用<code>for...of</code>来遍历这个对象</li>
</ul>
</blockquote>
<pre><code>// 定义Generator函数
function* gen() &#123;
  yield 1;
  yield 2;
  yield 3;
&#125;
&gt;
// 调用gen()函数，会返回一个遍历器对象
const iterator = gen();
// for...of循环遍历遍历器对象
for (let v of iterator) &#123;
  console.log(v);
&#125;
// for..of循遍历结果： 1 2 3
</code></pre>
<blockquote>
<ul>
<li>直到<code>next</code>方法返回值对象的<code>done</code>属性值为<code>true</code>时，才停止遍历</li>
</ul>
</blockquote>
<ul>
<li>调用<code>Generator</code>函数，并不会执行函数体中的任何代码，只是返回一个遍历器对象。<blockquote>
<ul>
<li>只有调用遍历器对象的<code>next()</code>方法后，才会开始执行函数体内的代码。</li>
</ul>
</blockquote>
</li>
</ul>
<pre><code>function* gen() &#123;
  console.log(&quot;第一次调用next&quot;);
  yield 1;
  console.log(&quot;第2次调用next&quot;);
  yield 2;
  yield 3;
&#125;
const it = gen(); // gen()函数体中的代码并不会执行
it.next(); // 第一次调用next
it.next(); // 第2次调用next
</code></pre>
<blockquote>
<ul>
<li>上面代码执行到<code>it=gen()</code>时，并不会执行 <code>gen</code> 函数体中的代码，只是生成了一个遍历器对象，所以并不会在控制台输出 “第一次调用 next” 语句。</li>
<li>当执行<code>it.next()</code>，开始执行执行<code>gen</code>函数体中的代码,并在控制台输出 “第一次调用 next”。但并不会输出 “第 2 次调用 next”，只有当执行到<code>it.next()</code>时才会在控制台输出 “第 2 次调用 next”。</li>
</ul>
</blockquote>
<ol start="3">
<li>yield 表达式<blockquote>
<ul>
<li><code>yield</code>语句相当于一个<strong>暂停标志</strong></li>
<li>当调用 <code>Generator</code> 函数时并不会执行函数体中的代码，而是生成一个遍历器对象。<strong>只有调用遍历器对象的next方法时，才会开始执行函数体中的代码</strong>。</li>
</ul>
</blockquote>
</li>
</ol>
<blockquote>
<p>遍历器对象的<code>next</code>方法<strong>运行逻辑</strong>如下：</p>
<ul>
<li>第一次调用<code>next</code>方法，开始执行函数体中的代码，执行遇到<code>yield</code>语句会<strong>暂停执行</strong>后面操作。并将紧跟在<code>yield</code>语句后面的表达式的值作为<code>next</code>方法返回对象的<code>value</code>属性值,<code>done</code>属性值为<code>false</code>。</li>
<li>再次调用<code>next</code>方法，会恢复执行，从上一次结束位置开始向下执行，如果遇到下一条 <code>yield</code> 语句，则重复上面的操作。如果没有再遇到新的<code>yield</code>语句，会一直运行到函数结束，直到遇到<code>return</code>语句为止。并将<code>return</code>后面表达式的值作为<code>next</code>返回对象的<code>value</code>属性值，<code>done</code>属性值为<code>true</code>。</li>
<li>如果该函数没有<code>return</code>语句，则返回对象的<code>value</code>属性为<code>undefined</code>，<code>done</code> 属性值为<code>true</code><blockquote>
<p>注意：在<code>for...of</code>循环时，<code>return</code>后面的表达式不会被遍历出来，因为此时<code>done</code>已经为<code>true</code>了；</p>
</blockquote>
</li>
</ul>
</blockquote>
<pre><code>function* gen() &#123;
  console.log(&quot;第一次调用next&quot;);
  yield 1;
  console.log(&quot;第2次调用next&quot;);
  yield 2;
  console.log(&quot;第3次调用next&quot;);
  return 3;
&#125;
const it = gen(); // gen()函数体中的代码并不会执行
console.log(it.next()); // 第1次调用next &#123;value: 1, done: false&#125;
console.log(it.next()); // 第2次调用next &#123;value: 2, done: false&#125;
console.log(it.next()); // 第3次调用next &#123;value: 3, done: true&#125;
console.log(it.next()); // &#123;value: undefined, done: true&#125;
</code></pre>
<pre><code>function* gen() &#123;
  console.log(&quot;第一次调用next&quot;);
  yield 1;
  console.log(&quot;第2次调用next&quot;);
  yield 2;
  console.log(&quot;第3次调用next&quot;);
&#125;
const it = gen(); // gen()函数体中的代码并不会执行
console.log(it.next()); // 第1次调用next &#123;value: 1, done: false&#125;
console.log(it.next()); // 第2次调用next &#123;value: 2, done: false&#125;
console.log(it.next()); // 第3次调用next &#123;value: undefined, done: true&#125;
</code></pre>
<blockquote>
<blockquote>
<p>注意：<code>yield</code>语句后面的表达式，只有当代码执行到当前这个<code>yield</code>语句时，后面的表达式才会求值。</p>
</blockquote>
</blockquote>
<ol start="4">
<li>区分 <code>yield</code> 与 <code>return</code><blockquote>
<ul>
<li><code>yield</code>相当于是一个<strong>暂停</strong>标志，一个 <code>Generator</code> 函数中可以有多个<code>yield</code>语句。每次执行遇到 <code>yield</code> 语句，就会暂停执行，将<code>yield</code>后面表达式的值为返回对象的<code>value</code>属性值，<code>done</code>属性值为<code>false</code>。只能再次调用 <code>next</code> 方法，才会继续向下执行。</li>
<li><code>return</code> 相当于<strong>终止</strong>遍历器，当代码执行到<code>return</code>语句后，其后所有的代码都不会执行了。<code>return</code>后面表达式的值为返回对象的<code>value</code>属性值，<code>done</code>属性值为<code>true</code>表示遍历器迭代完成（终止）<blockquote>
<p><code>for...of</code> 遍历时，并不会遍历 <code>return</code> 语句后面的值</p>
</blockquote>
</li>
</ul>
</blockquote>
</li>
</ol>
<pre><code>function* gen() &#123;
  yield 1;
  yield 2;
  return 3; // for...of 循环不会遍历到该值
&#125;
&gt;
const it = gen();
console.log(it.next()); //&#123;value: 1, done: false&#125;
console.log(it.next()); //&#123;value: 2, done: false&#125;
console.log(it.next()); //&#123;value: 3, done: true&#125;
console.log(it.next()); //&#123;value: undefined, done: false&#125;
&gt;
for (let v of gen()) &#123;
  console.log(v); // 1 2
&#125;
</code></pre>
<ol start="5">
<li>yield 注意事项</li>
</ol>
<ul>
<li><code>yield</code>只能直接在<code>Generator</code>函数里面用，在<code>Generator</code>函数体中的普通函数中用也会报错</li>
</ul>
<pre><code>// 普通函数中使用抛出错误
function fn()&#123;
    yield 1 ; // 抛错
&#125;
&gt;
// Generator函数内的普通函数中用，抛出错误
function* gen()&#123;
    function fn()&#123;
        yield 3;
    &#125;
&#125;
&gt;
// Generator函数内的普通函数中用，抛出错误
function* gen()&#123;
    [1,2,3].forEach((v)=&gt;&#123;
        yield v
    &#125;)
&#125;
</code></pre>
<ul>
<li>yield 可以只作为暂停标志，后面啥也不写</li>
</ul>
<pre><code>function* gen() &#123;
  yield;
  yield 2;
&#125;
const it = gen();
console.log(it.next());//&#123;value: undefined, done: false&#125;
console.log(it.next());//&#123;value: 2, done: false&#125;
console.log(it.next());&#123;value: undefined, done: true&#125;
</code></pre>
<ul>
<li>yield 表达式如果在另一个表达式之中，必须放在圆括号里面</li>
</ul>
<pre><code>// 错误写法
function* gen() &#123;
    let str = &quot;hello&quot; + yield 3; // 抛错
    console.log(&quot;hello&quot; + yield 5); // 抛错
&#125;
&gt;
// 正确写法
function* gen() &#123;
    let str = &quot;hello&quot; + (yield 3);
    console.log(&quot;hello&quot; + (yield 5));
&#125;
</code></pre>
<ul>
<li><code>yield</code>表达式用作<strong>函数参数</strong>或放在<strong>赋值表达式的右边</strong>，可以不用加括号</li>
</ul>
<pre><code>function* gen() &#123;
  function Foo(foo) &#123;
    console.log(&quot;执行完参数中两个yield语句，才执行我&quot;);
  &#125;
  Foo(yield &quot;a&quot;, yield &quot;b&quot;);
  let num = yield 4 + (yield 5);
&#125;
const it = gen(); // 遍历器对象
console.log(it.next()); // &#123;value: &#39;a&#39;, done: false&#125;
console.log(it.next()); // &#123;value: &#39;b&#39;, done: false&#125;
console.log(it.next()); // 执行完参数中两个yield语句，才执行我  &#123;value: 5, done: false&#125;
console.log(it.next()); // &#123;value: NaN, done: false&#125;
console.log(it.next()); // &#123;value: undefined, done: true&#125;
</code></pre>
<blockquote>
<ul>
<li>第一步，计算<code>Foo</code>函数中的<code>yield &quot;a&quot;</code>，返回对象的<code>value</code>值为<code>a</code></li>
<li>第二步，计算<code>Foo</code>函数中的<code>yield &quot;b&quot;</code>，返回对象的<code>value</code>值为<code>b</code></li>
<li>第三步，执行函数<code>Foo</code>，打印语句；计算<code>(yield 5)</code>，返回对象的<code>value</code>值为<code>5</code>；但<code>yield 5</code>本身是没有返回值的，所以它等于<code>undefined</code></li>
<li>第四步，计算<code>yield 4+undefined</code>，所以<code>yield=NaN</code>，返回对象的<code>value</code>值为<code>NaN</code><blockquote>
<p>注意：</p>
</blockquote>
</li>
<li>先计算参数，再执行函数</li>
<li>紧挨着赋值表达式的右边才不用括号，而且括号会提升优先级；原本是从左往右执行，如果有括号，就先执行括号里面的内容</li>
<li><code>yield</code><strong>后面表达式的值</strong>为返回对象的<code>value</code>属性值，当括号里的值计算完了，会成为它前面<code>yield</code>的表达式的一部分</li>
</ul>
</blockquote>
<ol start="6">
<li>next 方法的参数<blockquote>
<p><code>yield</code>语句本身没有返回值，或者说总是返回<code>undefined</code></p>
<ul>
<li><code>next</code>方法可以带一个参数，该参数会被当作<strong>上一条</strong><code>yield</code>语句的返回值。</li>
</ul>
</blockquote>
</li>
</ol>
<pre><code>function* gen() &#123;
  let a = yield 1; // yield语句默认没有返回值，或理解为返回值为undefined
  console.log(a);
  let b = a + 2; // NaN + 2
  console.log(b);
&#125;
const it = gen();
it.next();
it.next(); // undefined NaN
</code></pre>
<pre><code>function* gen() &#123;
  let a = yield 1;
  console.log(a);
  let b = a + 2; // NaN + 2
  console.log(b);
&#125;
const it = gen();
it.next();
it.next(10); // 10 12
// 相当于给函数体中的 a=10，则b=a+2=12
</code></pre>
<blockquote>
<blockquote>
<p>注：</p>
</blockquote>
<ul>
<li>首次调用 <code>next</code> 方法，传不传参数本质上是没有什么区别的，因为其参数表示上一条<code>yield</code>语句的返回值，首次调用时没有上一条<code>yield</code>语句。</li>
<li>即使传参，JS 引擎也会忽略此次传参。</li>
</ul>
</blockquote>
<ol start="7">
<li>带参的 next 方法应用<blockquote>
<p><code>next</code>方法可以带一个参数，并且这个参数用来表示上一条<code>yield</code>语句的返回值，所以我们可以利用这个特点向 <code>Generator</code>函数体的变量注入值。</p>
<ul>
<li>其中最典型的应用，就是用来处理异步交互</li>
</ul>
</blockquote>
</li>
</ol>
<pre><code>function* main() &#123;
  let result = yield request(&quot;http://www.xxx.com&quot;);
  result = JSON.parse(result); // 将返回的字符串解析成对象
  for (let key in result) &#123;
    console.log(result[key]);
  &#125;
&#125;
// 模拟ajax发送数据
function request(url) &#123;
  // 发送ajax请求,5秒后拿到返回的数据
  setTimeout(function () &#123;
    let result = &#39;&#123; &quot;name&quot;: &quot;清心&quot;, &quot;age&quot;: 33 &#125;&#39;;
    it.next(result); // 执行下一次迭代
  &#125;, 5000);
&#125;
&gt;
const it = main();
it.next(); // 清心  33
</code></pre>
<ol start="8">
<li><code>yield*</code> 表达式<blockquote>
<p><code>yield*</code> 表达式用于在一个<code>Generator</code>函数中执行另一个 <code>Generator</code>函数。</p>
<ul>
<li>因为直接在一个 <code>Generator</code> 函数中调用另一个 <code>Generator</code> 函数默认情况下是没有效果的。</li>
</ul>
</blockquote>
</li>
</ol>
<ul>
<li>直接调用</li>
</ul>
<pre><code>function* foo() &#123;
  yield 1;
  // 直接调用Generator函数 无任何效果
  bar();
  yield 5;
&#125;
function* bar() &#123;
  yield 2;
  yield 3;
&#125;
const it = foo();
for (let v of it) &#123;
  console.log(v); // 1 5
&#125;
</code></pre>
<blockquote>
<ul>
<li>在 foo 函数中调用了另一个 Generator 函数 bar，相当于没有调用一样，直接被忽略。 所以最后结果为 1 5</li>
</ul>
</blockquote>
<ul>
<li>用<code>yield</code>调用</li>
</ul>
<pre><code>function* foo() &#123;
  yield 1;
  // 在yield后面调用Generator函数，相当于next的返回对象的value值是一个迭代器对象
  yield bar();
  yield 5;
&#125;
function* bar() &#123;
  yield 2;
  yield 3;
&#125;
const it = foo();
console.log(it.next()); // &#123;value: 1, done: false&#125;
console.log(it.next()); // &#123;value: bar, done: false&#125;
console.log(it.next()); // &#123;value: 5, done: false&#125;
console.log(it.next()); // &#123;value: undefined, done: true&#125;
&gt;
for (let v of foo()) &#123;
  console.log(v); // 1 bar&#123;&#125;  5
&#125;
</code></pre>
<blockquote>
<p>在<code>yield</code>后面调用<code>Generator</code>函数，相当于<code>next</code>方法返回的对象中的<code>value</code>的属性值是一个<strong>迭代器对象</strong></p>
</blockquote>
<ul>
<li>用<code>yield*</code>调用</li>
</ul>
<pre><code>function* foo() &#123;
  yield 1;
  yield* bar();
  yield 5;
&#125;
function* bar() &#123;
  yield 2;
  yield 3;
&#125;
const it = foo();
// 其内部迭代过程
console.log(it.next()); // &#123;value: 1, done: false&#125;
console.log(it.next()); // &#123;value: 2, done: false&#125;
console.log(it.next()); // &#123;value: 3, done: false&#125;
console.log(it.next()); // &#123;value: 5, done: false&#125;
console.log(it.next()); // &#123;value: undefined, done: true&#125;
&gt;
for (let v of foo()) &#123;
  console.log(v); // 1 2 3  5
&#125;
</code></pre>
<blockquote>
<ul>
<li>利用<code>yield*</code>表达式在一个<code>Generator</code>函数中调用另一个<code>Genrator</code>函数。相当于使用一个遍历器遍历<strong>多个</strong> <code>Generator</code>函数，有<strong>递归</strong>的效果。<blockquote>
<p>上面代码中的 foo 函数，相当于下面两种写法</p>
</blockquote>
</li>
</ul>
</blockquote>
<pre><code>// 写法1
function* foo() &#123;
  yield 1;
  yield 2;
  yield 3;
  yield 5;
&#125;
// 写法2
function* foo() &#123;
  yield 1;
  for (let v of bar()) &#123;
    yield v;
  &#125;
  yield 5;
&#125;
</code></pre>
<ul>
<li><code>yield*</code>表达式后面通常跟一个迭代器对象或可迭代对象。</li>
</ul>
<pre><code>function* gen() &#123;
  yield &quot;hello&quot;;
  yield* &quot;hello&quot;;
  yield [1, 2, 3];
  yield* [1, 2, 3];
&#125;
for (let v of gen()) &#123;
  console.log(v);//hello h e l l ...
&#125;
//
function* gen() &#123;
  yield &quot;hello&quot;;
  // yield* &quot;hello&quot;;相当于：
  yield &quot;h&quot;;
  yield &quot;e&quot;;
  yield &quot;l&quot;;
  yield &quot;l&quot;;
  yield &quot;o&quot;;
&#125;
const it = gen();
console.log(it.next()); //&#123;value: &#39;hello&#39;, done: false&#125;
console.log(it.next()); //&#123;value: &#39;h&#39;, done: false&#125;
</code></pre>
<ol start="9">
<li>遍历器的 throw 方法<blockquote>
<p><code>Generator</code>函数返回的遍历器对象有一个<code>throw</code>方法，可以在函数体外抛出错误，并在函数体内被<code>try...catch</code>捕获。</p>
<ul>
<li>使用遍历对象的<code>throw</code>方法，在<code>Generator</code>函数体外抛出错误时，会有以下三种处理情况</li>
</ul>
</blockquote>
</li>
</ol>
<table>
<thead>
<tr>
<th>三种不同情况</th>
<th>描述</th>
<th>遍历器状态</th>
</tr>
</thead>
<tbody><tr>
<td>第一种情况</td>
<td>Generator 函数体内和外都没有用try…catch捕获该错误，则报错后，遍历器终止</td>
<td>终止</td>
</tr>
<tr>
<td>第二种情况</td>
<td>Generator 函数体内没有捕获该错误，被函数体外用try…catch捕获了该错误，则会终止遍历器</td>
<td>终止</td>
</tr>
<tr>
<td>第三种情况</td>
<td>Generator 函数体内有捕获到该错误，则外部的try…catch就没有办法捕获该错误，同时捕获错误后会自动执行一次next。</td>
<td>不影响</td>
</tr>
</tbody></table>
<ul>
<li>第一种情况<blockquote>
<ul>
<li><code>Generator</code> 函数<strong>体内和体外</strong>都没有用 <code>try...catch</code> 捕获该错误</li>
</ul>
</blockquote>
</li>
</ul>
<pre><code>function* gen() &#123;
  yield 1;
  yield 2;
  yield 3;
  yield 4;
  yield 5;
&#125;
&gt;
const it = gen();
console.log(it.next());//&#123;value:1,done:false&#125;
it.throw(&quot;a&quot;); // 往后代码都不执行了
console.log(it.next());
</code></pre>
<ul>
<li>第二种情况<blockquote>
<ul>
<li><code>Generator</code> 函数<strong>体内</strong>没有捕获该错误，在函数<strong>体外</strong>用<code>try...catch</code>捕获了该错误，则<code>throw</code>语句后，遍历器终止</li>
</ul>
</blockquote>
</li>
</ul>
<pre><code>function* gen() &#123;
  yield 1;
  yield 2;
  yield 3;
  yield 4;
  yield 5;
&#125;
&gt;
const it = gen();
console.log(it.next());//&#123;value:1,done:false&#125;
try &#123;
  it.throw(&quot;a&quot;);
&#125; catch (e) &#123;
  console.log(&quot;错误&quot;, e);//错误 a
&#125;
console.log(it.next());//&#123;value:undefined,done:true&#125;
</code></pre>
<ul>
<li>第三种情况<blockquote>
<ul>
<li><code>Generator</code> 函数<strong>体内</strong>有捕获该错误，则<strong>外部</strong>的<code>try...catch</code>就没有办法捕获该错误。</li>
<li>同时不会影响遍历器的下一次遍历。内部捕获了该错误后<strong>会自动执行下一次</strong> <code>next</code> 方法，所以<code>it.throw()</code>返回值为下一次<code>it.next()</code>的返回值</li>
</ul>
</blockquote>
</li>
</ul>
<pre><code>function* gen() &#123;
  yield 1;
  try &#123;
    yield 2;
  &#125; catch (e) &#123;
    console.log(&quot;内部&quot;, e);
  &#125;
  yield 3;
  yield 4;
  yield 5;
&#125;
&gt;
const it = gen();
console.log(it.next()); // &#123;value: 1, done: false&#125;
console.log(it.next()); // &#123;value: 2, done: false&#125;
try &#123;
  // 注意，throw的结果为 内部 a  &#123;value: 3, done: false&#125;
  console.log(it.throw(&quot;a&quot;));
&#125; catch (e) &#123;
  console.log(&quot;错误&quot;, e);
&#125;
console.log(it.next()); // &#123;value: 4, done: false&#125;
console.log(it.next()); // &#123;value: 5, done: false&#125;
console.log(it.next()); // &#123;value: undefined, done: true&#125;
</code></pre>
<blockquote>
<ul>
<li>上面的<code>it.thorw(&#39;a&#39;)</code>错误被<code>Generator</code>函数内部捕获，捕获后会<strong>自动执行一次</strong><code>next</code>方法，所以打印<code>it.throw()</code>的返回值为<code>&#123;value: 3, done: false&#125;</code>。</li>
<li>因为错误被<code>Generator</code>函数内部捕获，所以外部的<code>try...catch</code>句不会再捕获到错误，同时也<strong>不会影响</strong>遍历器的下一次遍历</li>
<li>注意：错误是在<code>yield 2</code>之后抛出的，<code>try...</code>里面要写<code>yield 2</code></li>
</ul>
</blockquote>
<blockquote>
<ul>
<li>我们再来分析下面这段代码</li>
</ul>
</blockquote>
<pre><code>function* gen() &#123;
  yield 1;
  try &#123;
    yield 2;
  &#125; catch (e) &#123;
    console.log(&quot;内部&quot;, e);
  &#125;
  yield 3;
  yield 4;
  yield 5;
&#125;
&gt;
const it = gen();
console.log(it.next()); // &#123;value: 1, done: false&#125;
console.log(it.next()); // &#123;value: 2, done: false&#125;
try &#123;
  // 注意，throw的结果为  内部 a   &#123;value: 3, done: false&#125;
  console.log(it.throw(&quot;a&quot;));
  console.log(it.throw(&quot;b&quot;)); // 错误 b
&#125; catch (e) &#123;
  console.log(&quot;错误&quot;, e);
&#125;
console.log(it.next()); // &#123;value: undefined, done: true&#125;
console.log(it.next()); // &#123;value: undefined, done: true&#125;
console.log(it.next()); // &#123;value: undefined, done: true&#125;
</code></pre>
<blockquote>
<ul>
<li>上面的第一个错误<code>it.throw(&#39;a&#39;)</code>被<code>Generator</code>函数内部捕获，由于<code>Generator</code>函数内部的<code>try...catch</code>语句已经执行了，所以<strong>第二个错误</strong><code>it.throw(&#39;b&#39;)</code>被外部的<code>try...catch</code>语句捕获。错误被外部捕获，则遍历器终止。</li>
</ul>
</blockquote>
<blockquote>
<blockquote>
<p>总结：</p>
</blockquote>
<ul>
<li>遍历器调用<code>throw</code>方法抛出的错误如果没有捕获处理，其后代码就没办法执行。</li>
<li>遍历器调用<code>throw</code>方法抛出的错误如果<strong>没有</strong>在 <code>Generator </code>函数<strong>内部</strong>捕获处理，就会造成遍历器终止。</li>
<li>遍历器调用<code>throw</code>方法抛出的错误如果在<code>Generator</code>函数<strong>内部捕获</strong>处理，其处理后，还会<strong>自动执行</strong><code>next</code>方法</li>
</ul>
</blockquote>
<ol start="10">
<li>遍历器的 <code>throw</code> 方法和全局 <code>throw</code> 命令<blockquote>
<ul>
<li><strong>全局</strong> <code>throw</code> 命令在 <code>Generator</code> <strong>体外</strong>抛出错误，并不能被 <code>Generator</code> 函数内部捕获，只能被外部的<code>try..catch</code>捕获</li>
</ul>
</blockquote>
</li>
</ol>
<ul>
<li><strong>全局</strong><code>throw</code>命令在<code>Generator</code><strong>体外</strong>抛出错误，内部捕获不到该错误，如果在外部捕获，则不影响遍历器的运行</li>
</ul>
<pre><code>function* gen() &#123;
  yield 1;
  try &#123;
    yield 2;
  &#125; catch (e) &#123;
    console.log(&quot;内部&quot;, e);
  &#125;
&gt;
  yield 3;
  yield 4;
  yield 5;
&#125;
&gt;
const it = gen();
console.log(it.next()); // &#123;value: 1, done: false&#125;
console.log(it.next()); // &#123;value: 2, done: false&#125;
try &#123;
  throw new Error(&quot;全局throw抛错&quot;);
&#125; catch (e) &#123;
  console.log(e); // Error: 全局throw抛错
&#125;
&gt;
console.log(it.next()); // &#123;value: 3, done: false&#125;
console.log(it.next()); // &#123;value: 4, done: false&#125;
</code></pre>
<ul>
<li><strong>全局</strong><code>throw</code>命令在 <code>Generator</code><strong>体内</strong>抛出错误，内部<strong>没有捕获</strong>该错误，在外部捕获，则遍历器终止</li>
</ul>
<pre><code>function* gen() &#123;
  yield 1;
  throw new Error(&quot;全局throw抛错&quot;);
  yield 2;
  yield 3;
  yield 4;
  yield 5;
&#125;
&gt;
const it = gen();
console.log(it.next()); // &#123;value: 1, done: false&#125;
try &#123;
  console.log(it.next());
&#125; catch (e) &#123;
  console.log(e); // Error: 全局throw抛错
&#125;
&gt;
console.log(it.next()); // &#123;value: undefined, done: true&#125;
console.log(it.next()); // &#123;value: undefined, done: true&#125;
</code></pre>
<blockquote>
<ul>
<li>抛错后，遍历器终止，<code>yield 2</code>及以后的代码都不会执行</li>
</ul>
</blockquote>
<ul>
<li><strong>全局</strong><code>throw</code>命令在<code>Generator</code><strong>体内</strong>抛出错误，内部<strong>有捕获</strong>该错误，则不影响遍历器的下一次遍历</li>
</ul>
<pre><code>function* gen() &#123;
  yield 1;
  try &#123;
    throw new Error(&quot;全局throw抛错&quot;);
    yield 2;
  &#125; catch (e) &#123;
    console.log(e);
  &#125;
  yield 3;
  yield 4;
  yield 5;
&#125;
&gt;
const it = gen();
console.log(it.next()); // &#123;value: 1, done: false&#125;
console.log(it.next()); // Error: 全局 throw 抛错 &#123;value: 3, done: false&#125;
console.log(it.next()); // &#123;value: 4, done: false&#125;
console.log(it.next()); // &#123;value: 5, done: false&#125;
</code></pre>
<blockquote>
<ul>
<li><code>try..catch</code>语句抛出错误后，就不会执行<code>yield 2</code>，直接处理错误。</li>
<li>但是遍历器调用throw方法抛出的错误如果在 <code>Generator</code> 函数<strong>内部</strong>捕获处理，其处理后，还会<strong>自动执行</strong> <code>next</code> 方法</li>
<li>所以执行第二个<code>console.log(it.next());</code>时，既会打印出错误，也会自动执行执行<code>yield 3</code></li>
</ul>
</blockquote>
<ul>
<li>全局 throw 命令在 Generator 体内抛出错误，<strong>内部没有</strong>捕获该错误，则遍历器终止</li>
</ul>
<pre><code>function* gen() &#123;
  let result = yield 1;
  yield result();
  yield 3;
  yield 4;
&#125;
&gt;
const it = gen();
console.log(it.next()); // &#123;value: 1, done: false&#125;
try &#123;
  console.log(
    it.next(function () &#123;
      throw new Error(&quot;a&quot;);
    &#125;)
  );
&#125; catch (e) &#123;
  console.log(&quot;错误&quot;, e); // 错误 Error: a
&#125;
&gt;
console.log(it.next()); // &#123;value: undefined, done: true&#125;
console.log(it.next()); // &#123;value: undefined, done: true&#125;
</code></pre>
<blockquote>
<ul>
<li>第一个<code>console.log(it.next());</code>，执行<code>yield 1</code>,<code>result=undefined</code></li>
<li>第二个<code>console.log(it.next(function () &#123;throw new Error(&quot;a&quot;);&#125;));</code>，先计算表达式：<code>result()：</code>函数作为上一次<code>yield</code>的返回值被调用，相当于在<code>Generator</code>函数体内抛出错误，但函数体内没有捕获错误，所以，遍历器终止</li>
</ul>
</blockquote>
<ol start="11">
<li>throw 方法总结<blockquote>
<p>注意：</p>
<ul>
<li><strong>遍历器的</strong><code>throw</code>方法在<code>Generator</code>函数<strong>体外</strong>抛出的错误，可以在<code>Generator</code>函数<strong>体内</strong>捕获处理</li>
<li><strong>全局</strong><code>throw</code>在<code>Generator</code>函数<strong>体外</strong>抛出的错误<strong>不能</strong>在<code>Generator</code>函数<strong>体内</strong>捕获</li>
</ul>
</blockquote>
</li>
</ol>
<ul>
<li>三种情况抛出错误的处理方式的区别</li>
</ul>
<table>
<thead>
<tr>
<th>三种情况</th>
<th>不处理</th>
<th>Generator 函数体内处理</th>
<th>Generator 函数体外处理</th>
</tr>
</thead>
<tbody><tr>
<td><code>Generator</code>函数体内抛出的错(不管是全局还是遍历器)</td>
<td>后续代码都没有办法执行</td>
<td>不会影响遍历器的下一次遍历</td>
<td>遍历器终止</td>
</tr>
<tr>
<td>遍历器的 <code>throw</code> 方法在 <code>Generator</code> 函数体外抛错</td>
<td>后续代码都没有办法执行</td>
<td>不会影响遍历器的下一次遍历</td>
<td>遍历器终止</td>
</tr>
<tr>
<td>全局的 <code>throw</code> 方法在 <code>Generator</code> 函数体外抛错</td>
<td>后续代码都没有办法执行</td>
<td>做不到</td>
<td>不会影响遍历器的下一次遍历</td>
</tr>
</tbody></table>
<blockquote>
<blockquote>
<p>注意以下两种情况，会自动执行一次<code>next</code></p>
</blockquote>
</blockquote>
<ul>
<li>情况一：遍历器调用<code>throw</code>方法抛出错误，在函数体内被捕捉处理后，会自动执行一次<code>next</code></li>
</ul>
<pre><code>function* gen() &#123;
  yield 1;
  try &#123;
    yield 2;
  &#125; catch (e) &#123;
    console.log(&quot;内部&quot;, e);
  &#125;
  yield 3;
  yield 4;
  yield 5;
&#125;
&gt;
const it = gen();
console.log(it.next()); // &#123;value: 1, done: false&#125;
console.log(it.next()); // &#123;value: 2, done: false&#125;
try &#123;
  // 注意，throw的结果为  内部 a   &#123;value: 3, done: false&#125;
  console.log(it.throw(&quot;a&quot;));
&#125; catch (e) &#123;
  console.log(&quot;错误&quot;, e);
&#125;
console.log(it.next()); // &#123;value: 4, done: false&#125;
console.log(it.next()); // &#123;value: 5, done: false&#125;
console.log(it.next()); // &#123;value: undefined, done: true&#125;
</code></pre>
<ul>
<li>情况二：在函数体内抛出全局错误，并在函数体内捕捉处理后会自动执行一次<code>next</code></li>
</ul>
<pre><code>function* gen() &#123;
  yield 1;
  try &#123;
    throw new Error(&quot;全局throw抛错&quot;);
    yield 2;
  &#125; catch (e) &#123;
    console.log(e);
  &#125;
  yield 3;
  yield 4;
  yield 5;
&#125;
&gt;
const it = gen();
console.log(it.next()); // &#123;value: 1, done: false&#125;
console.log(it.next()); // Error: 全局 throw 抛错 &#123;value: 3, done: false&#125;
console.log(it.next()); // &#123;value: 4, done: false&#125;
console.log(it.next()); // &#123;value: 5, done: false&#125;
</code></pre>
<blockquote>
<p><strong>测试题</strong></p>
</blockquote>
<ul>
<li>以下代码运行结果是：</li>
</ul>
<pre><code>function* gen() &#123;
  yield 1;
  try &#123;
    throw new Error(&quot;a&quot;);
    yield 2;
  &#125; catch (e) &#123;
    console.log(&quot;内部&quot;, e);
  &#125;
  yield 3;
  yield 4;
&#125;
&gt;
const it = gen();
console.log(it.next());//&#123;value: 1, done: false&#125;
try &#123;
  it.next();//内部 Error: a
  //console.log(it.next());//&#123;value: 3, done: false&#125;
  it.throw(&quot;b&quot;);//外部 b
&#125; catch (e) &#123;
  console.log(&quot;外部&quot;, e);
&#125;
console.log(it.next());
console.log(it.next());
</code></pre>
<blockquote>
<ul>
<li>第一个<code>it.next()</code>执行<code>yield 1</code>：<code>&#123;value: 1, done: false&#125;</code></li>
<li>第二个<code>it.next()</code>：函数体内抛出错误，捕获错误，并自动执行一次<code>next</code>方法，<code>yield 2</code>不会执行；如果打印它，就会得到<code>&#123;value: 3, done: false&#125;</code></li>
<li>下一步：<code>it.throw(&quot;b&quot;);</code>在函数体外抛出遍历器错误，但函数没有捕获，由外部捕获，所以遍历器终止</li>
</ul>
</blockquote>
<ul>
<li>以下代码运行结果是：</li>
</ul>
<pre><code>function* gen() &#123;
  yield 1;
  try &#123;
    throw new Error(&quot;a&quot;);
    yield 2;
  &#125; catch (e) &#123;
    console.log(&quot;内部&quot;, e);
  &#125;
  yield 3;
  yield 4;
&#125;
&gt;
const it = gen();
console.log(it.next());
try &#123;
  console.log(it.next());
  throw new Error(&quot;b&quot;);
&#125; catch (e) &#123;
  console.log(&quot;外部&quot;, e);
&#125;
console.log(it.next());
console.log(it.next());
</code></pre>
<blockquote>
<ul>
<li>第一个<code>it.next()</code>，执行<code>yield 1</code>：<code>&#123;value: 1, done: false&#125;</code></li>
<li>第二个<code>console.log(it.next());</code>：函数体内抛出全局错误，并被捕获，所以自动执行一次<code>next，</code>yield 2;<code>不会被执行，打印出:</code>内部 a<code>、</code>{value: 3, done: false}&#96;</li>
<li>下一步：函数体外抛出全局错误，并在外部捕获，打印出：<code>外部 b</code>；遍历器继续运行</li>
</ul>
</blockquote>
<ul>
<li>以下代码运行结果：</li>
</ul>
<pre><code>function* gen() &#123;
  let result = yield 1;
  try &#123;
    yield result() + 2;
  &#125; catch (e) &#123;
    console.log(e, &quot;内部捕获&quot;);
  &#125;
  yield 3;
  yield 4;
  yield 5;
&#125;
&gt;
const it = gen();
console.log(it.next()); // &#123;value: 1, done: false&#125;
try &#123;
  console.log(
    it.next(function () &#123;
      throw new Error(&quot;错误被&quot;);
    &#125;)
  );
&#125; catch (e) &#123;
  console.log(e, &quot;外部捕获&quot;);
&#125;
console.log(it.next()); // &#123;value: 4, done: false&#125;
console.log(it.next()); // &#123;value: 5, done: false&#125;
</code></pre>
<blockquote>
<ul>
<li>第一个<code>it.next()</code>，执行<code>yield 1</code>，打印出<code>&#123;value: 1, done: false&#125;</code>；result&#x3D;<code>undefined</code></li>
<li>第二个<code>it.next()</code>，函数作为上一次<code>yield</code>的返回值被传入，使<code>result</code>等于该函数；<ul>
<li>先计算表达式：调用<code>result</code>，在函数体内抛出错误，注意：<code>try...</code>里面的代码<code>yield result() + 2;</code>不会被执行，只会处理错误，打印出<code>错误被内部捕获</code></li>
<li>由于错误在函数体内抛出并捕获，所以<code>it.next()</code>照常执行，打印出<code>&#123;value: 3, done: false&#125;</code></li>
</ul>
</li>
<li>遍历器继续执行</li>
</ul>
</blockquote>
<ol start="12">
<li>Generator 函数的 return 方法<blockquote>
<p><code>Generator</code>函数返回的遍历器对象有一个<code>return</code>方法，可以返回给定的值，并终结<code>Generator</code>的遍历。</p>
</blockquote>
</li>
</ol>
<pre><code>function* gen() &#123;
  yield 1;
  yield 2;
  yield 3;
&#125;
&gt;
const it = gen();
console.log(it.next()); // &#123;value: 1, done: false&#125;
console.log(it.return(&quot;停止&quot;)); // &#123;value: &#39;停止&#39;, done: true&#125;
console.log(it.next()); // &#123;value: undefined, done: true&#125;
</code></pre>
<blockquote>
<blockquote>
<p>上面代码中</p>
</blockquote>
<ul>
<li>遍历器对象<code>it</code>调用<code>return</code>方法后，其返回对象的<code>value</code>属性值为<code>return</code>方法的参数 “停止”，<code>done</code>属性值为<code>true</code>，表示遍历器对象终止遍历。之后再调用<code>next</code>方法，返回对象始终为<code>&#123;value: undefined, done: true&#125;</code></li>
<li>如果<code>Generator</code>函数内部有<code>try...finally</code>代码块，那么<code>return</code>方法会推迟到<code>finally</code>代码块执行完后再执行。</li>
</ul>
</blockquote>
<blockquote>
<p><strong>注意区分以下情况</strong></p>
</blockquote>
<ul>
<li>如果代码还没有执行到<code>try</code>语句，就调用了<code>return</code>方法，则后面所有代码都不会执行，遍历器终止</li>
</ul>
<pre><code>function* gen() &#123;
  yield 1;
  try &#123;
    yield 2;
    throw new Error(&quot;a&quot;);
  &#125; catch (e) &#123;
    console.log(&quot;内部&quot;, e);
  &#125; finally &#123;
    yield 4;
    yield 5;
  &#125;
&#125;
&gt;
const it = gen();
console.log(it.next());//&#123;value:1, done: false&#125;
console.log(it.return(&quot;bc&quot;)); // 还没有执行到try...相关代码，就终止 &#123;value: &#39;bc&#39;, done: true&#125;
console.log(it.next());//&#123;value: undefined, done: true&#125;
console.log(it.next());//&#123;value: undefined, done: true&#125;
console.log(it.next());//&#123;value: undefined, done: true&#125;
</code></pre>
<ul>
<li>执行到<code>try</code>语句中，然后再<code>return</code>，则会先把<code>finally</code>中的代码执行完，再执行<code>return</code>方法，终止遍历器</li>
</ul>
<pre><code>const it = gen();
console.log(it.next()); // &#123;value: 1, done: false&#125;
console.log(it.next()); // &#123;value: 2, done: false&#125;
console.log(it.return(&quot;bc&quot;)); // &#123;value: 4, done: false&#125;
console.log(it.next()); // &#123;value: 5, done: false&#125;
console.log(it.next()); // &#123;value: &#39;bc&#39;, done: true&#125;
console.log(it.next()); // &#123;value: undefined, done: true&#125;
</code></pre>
<ul>
<li>代码执行到<code>try&#123;&#125;</code>后，再调用<code>return</code>方法，则终止遍历器</li>
</ul>
<pre><code>function* gen() &#123;
  yield 1;
  try &#123;
    yield 2;
    throw new Error(&quot;a&quot;);
  &#125; catch (e) &#123;
    console.log(&quot;内部&quot;, e);
  &#125; finally &#123;
    yield 4;
    yield 5;
  &#125;
  yield 6;
&#125;
&gt;
const it = gen();
console.log(it.next()); // &#123;value: 1, done: false&#125;
console.log(it.next()); // &#123;value: 2, done: false&#125;
console.log(it.next()); // 内部 Error: a &#123;value: 4, done: false&#125;
console.log(it.return(&quot;bc&quot;)); // &#123;value: &#39;bc&#39;, done: true&#125;
console.log(it.next()); // &#123;value: undefined, done: true&#125;
</code></pre>
<blockquote>
<ul>
<li>注意：由于是执行了<code>finally</code>里面的一部分，再<code>return</code>的，所以，<code>finally</code>没执行完的代码就不会被执行了</li>
</ul>
</blockquote>
<ol start="12">
<li>作为对象属性的 Generator 函数<blockquote>
<p>如果一个对象的属性是 <code>Generator</code> 函数</p>
<ul>
<li>那么可以简写成以下形式</li>
</ul>
</blockquote>
</li>
</ol>
<pre><code>const obj = &#123;
  gen: function* () &#123;&#125;,
&#125;;
&gt;
// 简写形式
const obj = &#123;
  *gen() &#123;&#125;,
&#125;;
</code></pre>
<ul>
<li>调用方式<blockquote>
<ul>
<li>调用<code>Generator</code>函数，并不会执行函数体中的任何代码，只是返回一个遍历器对象。只有调用遍历器对象的<code>next()</code>方法后，才会开始执行函数体内的代码。</li>
<li>或者使用<code>for..of</code>遍历</li>
</ul>
</blockquote>
</li>
</ul>
<pre><code>const obj = &#123;
  // 对象属性为Generator函数
  *gen() &#123;
    yield 1;
    yield 2;
    yield 3;
  &#125;,
  num() &#123;
    console.log(&quot;我是普通函数&quot;);
  &#125;,
&#125;;
obj.num(); //我是普通函数
obj.gen(); //不会执行函数里面的代码
// for...of遍历
for (let v of obj.gen()) &#123;
  console.log(v); // 1 2 3
&#125;
const it = obj.gen();//返回迭代器对象
console.log(it.next()); //&#123;value: 1, done: false&#125;
console.log(it.next()); //&#123;value: 2, done: false&#125;
console.log(it.next()); //&#123;value: 3, done: false&#125;
</code></pre>
<ol start="13">
<li>Generator 函数的实例</li>
</ol>
<ul>
<li><code>Generator</code> 函数不能用作构造函数，所以不能用 <code>new</code> 关键字来调用</li>
</ul>
<pre><code>function* Gen(a, b) &#123;
  this.a = a;
  this.b = b;
&#125;
const gen = new Gen(1, 2); //报错 Gen is not a constructor
</code></pre>
<ul>
<li><code>Generator</code>函数和普通函数一样<blockquote>
<ul>
<li>直接调用<code>Generator</code>函数，其内部的<code>this</code>指向<code>window</code></li>
<li>作为对象的方法被调用，<code>this</code>为调用该方法的对象</li>
</ul>
</blockquote>
</li>
</ul>
<pre><code>function* gen() &#123;
  console.log(this);
&#125;
const it = gen();
it.next(); // window
&gt;
const obj = &#123;
  // 对象属性为Generator函数
  *gen() &#123;
    console.log(this);
  &#125;,
&#125;;
const it = obj.gen();
console.log(it.next());
//&#123;gen: ƒ&#125;
//&#123;value: undefined, done: true&#125;
</code></pre>
<ul>
<li>使<code>Generator</code>函数，返回的迭代器对象，既可以作为迭代器对象使用，又可以当成函数内部的<code>this</code>指向</li>
</ul>
<pre><code>function* gen() &#123;
  this.a = 1;
  this.b = 2;
  yield 1;
&#125;
//一般情况下
const it = gen();
console.log(it.next()); //&#123;value: 1, done: false&#125;
console.log(it.a); //undefined
&gt;
//用call方法
const it = gen.call(gen.prototype);
console.log(it.next()); //&#123;value: 1, done: false&#125;
console.log(it.a); //1
console.log(it.b); //2
&gt;
const it = gen.call(gen.prototype);
console.log(it.a); //undefined
console.log(it.b); //undefined
console.log(it.next()); //&#123;value: 1, done: false&#125;
</code></pre>
<blockquote>
<ul>
<li>注意：必须先调用<code>it.next()</code>，才会执行函数体内的代码</li>
</ul>
</blockquote>
<ul>
<li><code>Generator</code> 函数的返回值是一个遍历器。<blockquote>
<ul>
<li><code>ES6</code>规定这个遍历器是<code>Generator</code>函数的实例，它也继承了<code>Generator</code>函数的<code>prototype</code>对象上的方法。</li>
</ul>
</blockquote>
</li>
</ul>
<pre><code>function* gen() &#123;
  yield 1;
&#125;
&gt;
gen.prototype.sayHello = function () &#123;
  console.log(&quot;大家好，我是Generator函数原型上的方法&quot;);
&#125;;
&gt;
const it = gen();
console.log(it instanceof gen); // true
it.sayHello(); // 大家好，我是Generator函数原型上的方法
</code></pre>
<h3 id="二、Generator-函数应用"><a href="#二、Generator-函数应用" class="headerlink" title="二、Generator 函数应用"></a>二、Generator 函数应用</h3><blockquote>
<p>深入浅出 Generator 函数的实践和应用</p>
</blockquote>
<ol>
<li>Generator 函数实现 Iterator 接口<blockquote>
<p>在学习<code>Iterator</code>迭代器（遍历器）时，我们知道，一个对象要想成为可迭代对象，能够被<code>for..of</code>遍历，必须满足：<strong>“可迭代协议” 和 “迭代器协议”</strong></p>
<ul>
<li>“可迭代协议” 是指对象身上必需要有<code>[Symbol.iterator]</code>，其返回值为一个迭代器对象</li>
<li>“迭代器协议” 是指迭代器对象必需要有<code>next</code>方法，<code>next</code>方法的返回值必需是一个具有<code>value</code>和<code>done</code>两个属性的对象。<code>vaule</code>属性的值为每次迭代的成员，<code>done</code>的值为布尔值，用来标识所有成员是否全部迭代完成。</li>
</ul>
</blockquote>
</li>
</ol>
<blockquote>
<p>手动实现一个迭代器对象非常麻烦，而 Generator 函数可以轻松帮我们实现。</p>
<ul>
<li><code>Generator</code> 函数，本质就是一个<strong>生成器函数</strong>，用来生成遍历器对象。所以我们可以把对象的<code>[Symbol.iterator]</code>属性值设置为一个<code>Generator</code>函数</li>
</ul>
</blockquote>
<ul>
<li>用<code>yield</code></li>
</ul>
<pre><code>const obj = &#123;
  data: [1, 2, 3, 4, 5],
  // [Symbol.iterator]:function* ()&#123;&#125;
  *[Symbol.iterator]() &#123;
    for (let i = 0; i &lt; this.data.length; i++) &#123;
      yield this.data[i];
    &#125;
  &#125;,
&#125;;
&gt;
for (let v of obj) &#123;
  console.log(v); // 1 2 3 4 5
&#125;
</code></pre>
<ul>
<li>简化版：用<code>yield*</code></li>
</ul>
<pre><code>const obj = &#123;
  data: [1, 2, 3, 4, 5],
  // 生成器函数，生成一个迭代器（遍历器）对象
  *[Symbol.iterator]() &#123;
    yield* this.data;
  &#125;,
&#125;;
&gt;
for (let v of obj) &#123;
  console.log(v); // 1 2 3 4 5
&#125;
</code></pre>
<ol start="2">
<li>将数组按深度扁平化</li>
</ol>
<ul>
<li>不指定深度</li>
</ul>
<pre><code>function* gen(arr) &#123;
  if (Array.isArray(arr)) &#123;
    //是个数组
    for (let i = 0; i &lt; arr.length; i++) &#123;
      yield* gen(arr[i]);
    &#125;
  &#125; else &#123;
    //不是数组
    yield arr;
  &#125;
&#125;
let arr = [1, [2, 3], 4, [5, [6], 7], [8], [9], 10];
for (let v of gen(arr)) &#123;
  console.log(v);//1 2 3 4 5 6 7 8 9 10
&#125;
</code></pre>
<ul>
<li>指定深度</li>
</ul>
<pre><code>// 将数组展平
function flat(arr, depth) &#123;
  // Generator函数，将数组中所有嵌套元素展平列出
  function* gen(arr, n = 0) &#123;
    if (Array.isArray(arr)) &#123;
      n--;
      if (n &lt; -1) &#123;
        yield arr;
      &#125; else &#123;
        for (let i = 0; i &lt; arr.length; i++) &#123;
          yield* flat(arr[i], n);
        &#125;
      &#125;
    &#125; else &#123;
      yield arr;
    &#125;
  &#125;
&gt;
  // 结果数组
  const arr2 = [];
  for (let v of gen(arr, depth)) &#123;
    arr2.push(v);
  &#125;
  return arr2;
&#125;
&gt;
let arr = [1, [2, 3], 4, [5, [6], 7], [8], [9], 10];
console.log(flat(arr, 1));//[1, 2, 3, 4, 5, Array(1), 7, 8, 9, 10]
</code></pre>
<ol start="3">
<li>深度优先遍历 DOM 树<blockquote>
<ul>
<li>深度优先：先深度，再广度</li>
</ul>
</blockquote>
</li>
</ol>
<pre><code>&gt;&lt;div id=&quot;container&quot;&gt;
&gt;  &lt;ul&gt;
&gt;    &lt;li&gt;
&gt;      &lt;h3&gt;标题&lt;/h3&gt;
&gt;      &lt;div class=&quot;box2&quot;&gt;
&gt;        &lt;img src=&quot;&quot; alt=&quot;图片&quot; /&gt;
&gt;        &lt;p&gt;描述&lt;/p&gt;
&gt;        &lt;p&gt;&lt;span&gt;价格:&lt;/span&gt;&lt;i&gt;50&lt;/i&gt;&lt;/p&gt;
&gt;      &lt;/div&gt;
&gt;    &lt;/li&gt;
&gt;  &lt;/ul&gt;
&gt;&lt;/div&gt;
&gt;
&gt;&lt;script&gt;
  function* getDomTree(node) &#123;
    yield node.tagName;//DIV
    if (node.children.length &gt; 0) &#123;
      for (let i = 0; i &lt; node.children.length; i++) &#123;
        yield* getDomTree(node.children[i]);
      &#125;
    &#125;
  &#125;
  const node = document.getElementById(&quot;container&quot;);
  for (let el of getDomTree(node)) &#123;
    console.log(el);
  &#125;
&gt;&lt;/script&gt;
</code></pre>
<ul>
<li>带 <code>--</code> 前缀的</li>
</ul>
<pre><code>&gt;&lt;script&gt;
  // node表示DOM节点  n用来控制标签前面--填充的个数
  function* getDomTree(node, n = 0) &#123;
    yield &quot;-&quot;.repeat(n) + node.tagName;
    if (node.children.length &gt; 0) &#123;
      n += 2; // 下一级--加2
      for (let i = 0; i &lt; node.children.length; i++) &#123;
        yield* getDomTree(node.children[i], n);
      &#125;
    &#125;
  &#125;
  const node = document.getElementById(&quot;container&quot;);
  for (let el of getDomTree(node)) &#123;
    console.log(el);
  &#125;
&gt;&lt;/script&gt;
</code></pre>
<h2 id="Promise-用法、实例方法、原理与异步编程的实践应用"><a href="#Promise-用法、实例方法、原理与异步编程的实践应用" class="headerlink" title="Promise 用法、实例方法、原理与异步编程的实践应用"></a>Promise 用法、实例方法、原理与异步编程的实践应用</h2><blockquote>
<p>本节内容我们开始学习 <code>ES6</code> 中的 <code>Promise</code> 异步编程的解决方案。比传统的解决方案：回调函数和事件，更合理和更强大。<br>它由社区最早提出和实现，<code>ES6</code> 将其写进了语言标准，统一了用法，原生提供了<code>Promise</code>对象。</p>
</blockquote>
<h3 id="一、认识-Promise"><a href="#一、认识-Promise" class="headerlink" title="一、认识 Promise"></a>一、认识 Promise</h3><ol>
<li>什么是 Promise<blockquote>
<p><code>Promise</code>是异步编程的一种<strong>解决方案</strong>，关于异步编程的解决方案，在之前我们学习过，<strong>回调函数</strong>是解决异步操作的一种解决方案，但是他存在一些缺陷，而这些缺陷 <code>Promise</code> 可以完美解决。</p>
<ul>
<li>接下来我们通过一个案例来讲解，Promise 和回调函数相比他的优势在哪里<br><strong>异步加载一张图片</strong>——回调函数</li>
<li>通常在一张图片加载完成后，我们需要做相关的操作，这时候我们可以把相关的操作写入到回调函数中，等图片加载完成后，就会执行回调函数中的代码，做相关的操作</li>
</ul>
</blockquote>
</li>
</ol>
<ul>
<li>预加载一张图片，图片加载成功后，需要处理的事情在回调函数中处理</li>
</ul>
<pre><code>function preloadImage(url, resolve, reject) &#123;
  let img = new Image();
  img.onload = function () &#123;
    resolve(img); // 加载成功，调用回调函数执行下一步操作
  &#125;;
  img.onerror = function () &#123;
    reject(new Error(&quot;图片加载失败&quot;));
  &#125;;
  img.src = url;
&#125;
&gt;
const url =
  &quot;https://sce7a2b9c9d95a-sb-qn.qiqiuyun.net/files/course/2019/10-29/011138ab5ee2314108.png&quot;;
// 预加载一张图片
preloadImage(url, (data) =&gt; &#123;
  document.body.appendChild(data);
&#125;);
</code></pre>
<ul>
<li>逐步加载 5 张图片，并插入到页面中<blockquote>
<ul>
<li>在一张图片加载成功后，插入到页面，然后再加载下一张，共加载 5 张</li>
</ul>
</blockquote>
</li>
</ul>
<pre><code>// 预加载一张图片，图片加载成功后，需要处理的事情在回调函数中处理
function preloadImage(url, resolve, reject) &#123;
  let img = new Image();
  img.onload = function () &#123;
    resolve(img); // 加载成功，调用回调函数执行下一步操作
  &#125;;
  img.onerror = function () &#123;
    reject(new Error(&quot;图片加载失败&quot;));
  &#125;;
  img.src = url;
&#125;
&gt;
const urls = [
  &quot;https://sce7a2b9c9d95a-sb-qn.qiqiuyun.net/files/course/2022/08-29/210311f40bcf290736.jpg&quot;,
  &quot;https://sce7a2b9c9d95a-sb-qn.qiqiuyun.net/files/course/2019/11-06/134028c28eb5212376.jpg&quot;,
  &quot;https://sce7a2b9c9d95a-sb-qn.qiqiuyun.net/files/course/2020/02-08/145955bc3b00504448.jpg&quot;,
  &quot;https://sce7a2b9c9d95a-sb-qn.qiqiuyun.net/files/course/2022/03-19/174949d70767470556.jpg&quot;,
  &quot;https://sce7a2b9c9d95a-sb-qn.qiqiuyun.net/files/course/2022/02-19/16465934b475255075.jpg&quot;,
];
preloadImage(urls[0], (data) =&gt; &#123;
  document.body.appendChild(data);
  preloadImage(urls[1], (data) =&gt; &#123;
    document.body.appendChild(data);
    preloadImage(urls[2], (data) =&gt; &#123;
      document.body.appendChild(data);
      preloadImage(urls[3], (data) =&gt; &#123;
        document.body.appendChild(data);
        preloadImage(urls[4], (data) =&gt; &#123;
          document.body.appendChild(data);
        &#125;);
      &#125;);
    &#125;);
  &#125;);
&#125;);
</code></pre>
<blockquote>
<blockquote>
<p>总结</p>
</blockquote>
<ul>
<li>通过上面的案例我们可以看到，如果只是加载 1 张图片，那回调函数的方式能很方便的帮我们实现。如果需要<strong>加载多张</strong>，就会出现层层嵌套的回调函数（<strong>回调地狱</strong><code>callback hell</code>）的问题也就出来。</li>
<li>如果需要加载的图片再多一些，那嵌套的级别会更深，不利于后期代码的维护，同时这种层层嵌套的写法也不符合正常代码的书写逻辑，而<code>Promise</code>就可以解决这个问题。</li>
</ul>
</blockquote>
<ol start="2">
<li>什么时候使用 Promise<blockquote>
<p><code>Promise</code> 一般<strong>用来解决层层嵌套的回调函数</strong>（回调地狱 <code>callback hell</code>）的问题</p>
<ul>
<li>我们用 Promise 来改造下上面的回调函数的写法，代码如下</li>
</ul>
</blockquote>
</li>
</ol>
<pre><code>// 预加载一张图片，图片加载成功后，需要处理的事情在回调函数中处理
function preloadImage(url) &#123;
  return new Promise((resolve, reject) =&gt; &#123;
    let img = new Image();
    img.onload = function () &#123;
      resolve(img); // 加载成功，调用回调函数执行下一步操作
    &#125;;
    img.onerror = function () &#123;
      reject(new Error(&quot;图片加载失败&quot;));
    &#125;;
    img.src = url;
  &#125;);
&#125;
&gt;
const urls = [
  &quot;https://sce7a2b9c9d95a-sb-qn.qiqiuyun.net/files/course/2022/08-29/210311f40bcf290736.jpg&quot;,
  &quot;https://sce7a2b9c9d95a-sb-qn.qiqiuyun.net/files/course/2019/11-06/134028c28eb5212376.jpg&quot;,
  &quot;https://sce7a2b9c9d95a-sb-qn.qiqiuyun.net/files/course/2020/02-08/145955bc3b00504448.jpg&quot;,
  &quot;https://sce7a2b9c9d95a-sb-qn.qiqiuyun.net/files/course/2022/03-19/174949d70767470556.jpg&quot;,
  &quot;https://sce7a2b9c9d95a-sb-qn.qiqiuyun.net/files/course/2022/02-19/16465934b475255075.jpg&quot;,
];
&gt;
preloadImage(urls[0])
  .then((data) =&gt; &#123;
    document.body.appendChild(data);
    return preloadImage(urls[1]);
  &#125;)
  .then((data) =&gt; &#123;
    document.body.appendChild(data);
    return preloadImage(urls[2]);
  &#125;)
  .then((data) =&gt; &#123;
    document.body.appendChild(data);
    return preloadImage(urls[3]);
  &#125;)
  .then((data) =&gt; &#123;
    document.body.appendChild(data);
    return preloadImage(urls[4]);
  &#125;)
  .then((data) =&gt; &#123;
    document.body.appendChild(data);
  &#125;);
</code></pre>
<blockquote>
<p>注：</p>
<ul>
<li>Promise 改造后的代码是按正常的代码书写逻辑，从上往下来书写，解决了“回调地狱 callback hell”问题。他使得异步操作能<strong>以同步操作的流程</strong>表达出来。</li>
</ul>
</blockquote>
<h3 id="二、Promise-的基本用法"><a href="#二、Promise-的基本用法" class="headerlink" title="二、Promise 的基本用法"></a>二、Promise 的基本用法</h3><ol>
<li>创建 Promise 实例<blockquote>
<p><code>ES6</code> 规定，<code>Promise</code>对象是一个<strong>构造函数</strong>，用来生成 <code>Promise</code>实例。</p>
</blockquote>
</li>
</ol>
<ul>
<li>构造函数接受一个函数作为参数，该函数有两个参数，分别是<code>resolve</code>和<code>reject</code></li>
</ul>
<pre><code>const promise = new Promise(function (resolve, reject) &#123;&#125;);
// 参数resolve和reject是两个形参，名字可自定义，为了更符合语义，建议使用resolve和reject来命名
</code></pre>
<ul>
<li><code>Promise</code>对象一旦创建，就会<strong>立即执行</strong>构造函数参数中的函数（我们称此函数为执行器 <code>executor</code> 函数）</li>
</ul>
<pre><code>const promise = new Promise(function (resolve, reject) &#123;
  console.log(&quot;立马执行&quot;);
&#125;);
// 输入结果： 立马执行
</code></pre>
<ul>
<li><code>resolve</code>和<code>reject</code>参数分别为两个函数，异步操作成功时调用<code>resolve</code>，失败时调用<code>reject</code></li>
</ul>
<pre><code>const p1 = new Promise(function (resolve, reject) &#123;
  // 创建图片对象
  let img = new Image();
  // 图片加载成功触发onload事件
  img.onload = function () &#123;
    resolve(img); // 图片加载成功，就把图片作为参数传出去,对外如何接收数据并操作，后面讲
  &#125;;
  // 图片加载失败，触发onerror事件
  img.onerror = function () &#123;
    reject(new Error(&quot;图片加载失败&quot;)); // 图片加载失败，把错误对象传出去
  &#125;;
  // 给图片添加地址，就会发送http请求下载图片
  img.src = &quot;http://www.xxx.com&quot;;
&#125;);
</code></pre>
<blockquote>
<blockquote>
<p>注：</p>
</blockquote>
<ul>
<li>异步操作成功时，我们通常需要把成功的结果传出去，再做后需操作</li>
<li>异步操作失败时，我们通常需要把错误对象传递出去，知道问题出在哪里。</li>
<li>至于对外如何拿到成功或失败后传递的数据，后面会讲到 <code>promise</code> 的 <code>then</code> 方法，<code>then</code> 方法可以处理</li>
</ul>
</blockquote>
<ol start="2">
<li>Promise 的三种状态<blockquote>
<p><code>Promise</code>代表一种异步操作，他有三种状态，分别代表异步操作的三种状态</p>
<ul>
<li>待定（pending）：初始状态，既没有被兑现，也没有被拒绝。</li>
<li>已兑现（fulfilled）：意味着操作成功完成。</li>
<li>已拒绝（rejected）：意味着操作失败。<blockquote>
<p>通过查看 <code>Promise</code> 对象身上的<code>[[PromiseState]]</code>属性，可以了解 <code>Promise</code> 的状态</p>
</blockquote>
</li>
</ul>
</blockquote>
</li>
</ol>
<ul>
<li>刚创建一个 <code>Promise</code> 对象，他的的状态为 <code>pending</code> 待定或正在进行中。</li>
</ul>
<pre><code>const promise = new Promise(function (resolve, reject) &#123;&#125;);
console.log(promise);
</code></pre>
<blockquote>
<img src="pending.png">
</blockquote>
<ul>
<li>调用<code>resolve</code>函数，<code>Promise</code>的状态由<code>pending</code> （待定）变为<code>fulfilled</code>（成功）</li>
</ul>
<pre><code>const promise = new Promise(function (resolve, reject) &#123;
  resolve(); // 调用resolve，promise状态由pending变为fulfilled
&#125;);
console.log(promise);
</code></pre>
<blockquote>
<img src="fulfilled.png">
</blockquote>
<ul>
<li>调用<code>reject</code>函数，<code>Promise</code> 的状态由<code>pending</code>（待定）变为 <code>rejected</code>（失败）</li>
</ul>
<pre><code>const promise = new Promise(function (resolve, reject) &#123;
  reject(); // 调用resolve，promise状态由pending变为rejected
&#125;);
console.log(promise);
</code></pre>
<blockquote>
<img src="rejected.png">
</blockquote>
<ol start="3">
<li>注意事项</li>
</ol>
<ul>
<li><p><code>Promise</code> 的状态一旦由 <code>pending</code>变为<code>rejected</code>或<code>fulfilled</code>，就<strong>不可能再发生改变</strong>了。</p>
</li>
<li><p><code>Promise</code><strong>内部抛出错误</strong>，<code>promise</code> 的状态也会由<code>pending</code>变为<code>rejected</code></p>
</li>
</ul>
<ol start="4">
<li>then 方法的简单应用<blockquote>
<p><code>then</code>方法的作用是为<code>Promise</code>实例添加<strong>状态改变时</strong>的回调函数。<code>then</code>方法中有两个参数，这两个参数分别为两个回调函数。</p>
<ul>
<li>第一个回调函数在<code>Promise</code>的状态变为<code>fulfilled</code>的时调用，表示成功的回调。</li>
<li>第二个回调函数在<code>Promise</code>的状态变为<code>rejected</code>的时候调用，表示失败的回调。</li>
</ul>
</blockquote>
</li>
</ol>
<pre><code>const promise = new Promise(function (resolve, reject) &#123;
  resolve(); // Promise状态由pending--&gt;fulfilled ,调用then方法的第一个回调函数
&#125;);
&gt;
promise.then(
  // promise状态变为fulfilled时，调第一个回调
  (data) =&gt; &#123;
    console.log(&quot;成功的回调&quot;);
  &#125;,
  // promise状态变为rejected时，调第二个回调
  (data) =&gt; &#123;
    console.log(&quot;失败的回调&quot;);
  &#125;
);
// 打印结果： 成功的回调
</code></pre>
<pre><code>const promise = new Promise(function (resolve, reject) &#123;
  reject(); // Promise状态由pending--&gt;rejected 调用then方法的第二个回调函数
&#125;);
&gt;
promise.then(
  (data) =&gt; &#123;
    console.log(&quot;成功的回调&quot;);
  &#125;,
  (data) =&gt; &#123;
    console.log(&quot;失败的回调&quot;);
  &#125;
);
// 打印结果： 失败的回调
</code></pre>
<ol start="5">
<li>resolve 和 reject 参数<blockquote>
<p><code>resolve</code>和<code>reject</code>参数分别为两个函数，这两个函数的作用分别用来在异步操作成功和失败时调用。</p>
</blockquote>
</li>
</ol>
<table>
<thead>
<tr>
<th>参数</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td><code>resolve</code>函数</td>
<td>当异步操作成功时调用<code>resolve</code>函数，他可以将<code>Promise</code>的状态由<code>pending</code>变为<code>fulfilled</code>，同时将异步操作的结果作为<code>resolve</code>函数的参数传递出去。<code>resolve</code>函数通常带一个参数，其参数会被传递到<code>then</code>方法的第一个回调函数的参数</td>
</tr>
<tr>
<td><code>reject</code>函数</td>
<td>当异步操作失败时调用<code>reject</code>函数，他可以将 <code>Promise</code>的状态由<code>pending</code>变为<code>reject</code>，同时将异步操作的结果作为<code>reject</code>函数的参数传递出去。<code>reject</code>函数通常带一个参数，其参数会被传递到<code>then</code>方法的第二个回调函数的参数</td>
</tr>
</tbody></table>
<ul>
<li><code>resolve</code>函数</li>
</ul>
<pre><code>const promise = new Promise(function (resolve, reject) &#123;
  resolve(1); // 1被传递给then方法的第一个回调函数的参数data.
&#125;);
promise.then(
  (data) =&gt; &#123;
    console.log(&quot;成功&quot;, data); // 成功 1
  &#125;,
  (data) =&gt; &#123;
    console.log(&quot;失败&quot;, data);
  &#125;
);
// 打印结果：成功 1
</code></pre>
<ul>
<li><code>reject</code>函数</li>
</ul>
<pre><code>const promise = new Promise(function (resolve, reject) &#123;
  reject(0); // 0被传递给then方法的第二个回调函数的参数data.
  // reject(new Error(&#39;操作失败&#39;))
&#125;);
promise.then(
  (data) =&gt; &#123;
    console.log(&quot;成功&quot;, data); // 成功 1
  &#125;,
  (data) =&gt; &#123;
    console.log(&quot;失败&quot;, data);
  &#125;
);
// 打印结果： 失败 0
// 打印结果： 失败 Error: 操作失败
</code></pre>
<blockquote>
<blockquote>
<p>温馨提示：</p>
</blockquote>
<ul>
<li><code>reject</code>主要是用来在异步操作失败时调用，所以他的参数通常是一个<strong>错误对象</strong></li>
<li><code>reject</code> 和 <code>resolve</code> 函数的参数，保存在<code>promise</code>对象的<code>[[PromiseResult]]</code>属性中，我们称为<code>promise</code>实例对象的<strong>返回值</strong></li>
</ul>
</blockquote>
<pre><code>const promise = new Promise((resolve, reject) =&gt; &#123;
  resolve(&quot;hello&quot;);
&#125;);
console.log(promise);
</code></pre>
<blockquote>
<img src="promiseResult.png">
</blockquote>
<ol start="6">
<li>resolve 和 reject 函数的参数<blockquote>
<p><code>resolve</code>函数的<strong>参数为不同类型时</strong>，其传递给<code>then</code>方法的值会有所不同</p>
<blockquote>
<p>注意：</p>
</blockquote>
<ul>
<li><code>Promise</code>函数里的<code>resolve</code>和<code>reject</code>函数，在调用时，如果括号内有参数，就会传递给<code>then</code>方法；</li>
<li><code>then</code>方法的<code>return</code>和<code>resolve</code>&#x2F;<code>reject</code>函数的参数，使用原理是一样的</li>
<li>主要分以下四种情况<table>
<thead>
<tr>
<th>参数类型</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>不带任何参数</td>
<td><code>then</code>方法第一个回调函数接受到的参数值为<code>undefined</code></td>
</tr>
<tr>
<td>一般类型（非<code>thenable</code>对象和<code>Promise</code>对象）</td>
<td><code>then</code>方法第一个回调函数接收到的参数值为这个参数</td>
</tr>
<tr>
<td><code>Promise</code>实例</td>
<td>该参数的状态和返回值决定了后面<code>then</code>的回调函数和参数值</td>
</tr>
<tr>
<td><code>thenable</code>对象</td>
<td>先将<code>thenable</code>对象转换为<code>Promise</code>对象，然后立即执行<code>thenable</code>对象的<code>then</code>方法，改变<code>Promise</code>的状态。该<code>Promise</code>的状态决定了后面<code>then</code>方法的回调和参数值</td>
</tr>
</tbody></table>
</li>
</ul>
</blockquote>
</li>
</ol>
<ul>
<li>不带任何参数</li>
</ul>
<pre><code>const p = new Promise((resolve, reject) =&gt; &#123;
  resolve();
&#125;);
p.then((data) =&gt; &#123;
  console.log(data); // undefined
&#125;);
</code></pre>
<ul>
<li>参数为一般类型</li>
</ul>
<pre><code>const p = new Promise((resolve, reject) =&gt; &#123;
  resolve(&quot;hello&quot;);
&#125;);
p.then((data) =&gt; &#123;
  console.log(data); // hello
&#125;);
</code></pre>
<ul>
<li>参数是一个 Promise 对象</li>
</ul>
<pre><code>const p1 = new Promise(function (resolve, reject) &#123;
  setTimeout(function () &#123;
    reject(2);
  &#125;, 3000);
&#125;);
const p2 = new Promise(function (resolve, reject) &#123;
  resolve(p1);
&#125;);
&gt;
p2.then(
  (data) =&gt; &#123;
    console.log(&quot;成功&quot;, data);
  &#125;,
  (data) =&gt; &#123;
    console.log(&quot;失败&quot;, data);
  &#125;
);
// 打印结果： 失败 2
</code></pre>
<blockquote>
<p><strong>代码解析：</strong></p>
<ul>
<li>上面代码中，p1 和 p2 都是<code>promise</code>对象，但 p2 的 <code>resolve</code>方法将 p1 作为参数，此时 p2 的状态和返回结果都由 p1 来决定。</li>
<li>在 3s 后 p1 的状态改变，此时才会执行下面 then 方法中的回调，由于 p1 中调用的是<code>reject(2)</code>，其状态为失败，所以最后调 then 的第二个回调，其参数<code>data=2</code>。最后在控制台输出 ：“失败 2”</li>
</ul>
</blockquote>
<ul>
<li>thenable 对象<blockquote>
<ul>
<li>所谓的 <code>thenable</code> 对象是指：具有 <code>then</code> 方法的对象，如下面这个对象</li>
</ul>
</blockquote>
</li>
</ul>
<pre><code>let thenable = &#123;
  name: &quot;icoding&quot;,
  b: 2,
  then(resolve, reject) &#123;
    resolve(this.name);
  &#125;,
&#125;;
</code></pre>
<blockquote>
<ul>
<li>如果<code>then</code>回调函数中的返回的值为<code>thenable</code>对象，会先将<code>thenable</code>对象转换为<code>Promise</code>对象，然后<strong>立即执行</strong><code>thenable</code>对象的<code>then</code>方法，改变<code>Promise</code>的状态。该 <code>Promise</code>的状态决定了后面<code>then</code>方法的回调和参数值</li>
</ul>
</blockquote>
<pre><code>let thenable = &#123;
  name: &quot;icoding&quot;,
  b: 2,
  then(resolve, reject) &#123;
    resolve(this.name);
  &#125;,
&#125;;
const p = new Promise((resolve, reject) =&gt; &#123;
  resolve(thenable);
  //相当于：new Promise((resolve,reject)=&gt;&#123;
  //thenable.then(resolve,reject)&#123;
  //   resolve(&quot;icoding&quot;);//改变p的状态，将&quot;icoding&quot;作为参数传给下一个then
  //  &#125;
  //&#125;)
&#125;);
&gt;
p.then((data) =&gt; &#123;
  console.log(data); // icoding
&#125;);
</code></pre>
<blockquote>
<ul>
<li><code>Promise</code>函数里的<code>resolve</code>给第一个<code>then</code>方法传递出的是<code>thenable</code></li>
<li>但<code>thenable</code>是一个对象，所以，这个对象会自动调用自己的<code>then</code>方法，将<code>resolve</code>的参数<code>icoding</code>传给第一个<code>then</code>方法</li>
</ul>
</blockquote>
<blockquote>
<ul>
<li>resolve 方法的参数为 thenable 对象时，其内部实现大致如下</li>
</ul>
</blockquote>
<pre><code>// 模拟Promise的resolve方法，其参数为thenable对象时
function resolve(obj) &#123;
  return new Promise((resolve, reject) =&gt; &#123;
    obj.then(resolve, reject);
  &#125;);
&#125;
</code></pre>
<h3 id="三、Promise-的实例方法"><a href="#三、Promise-的实例方法" class="headerlink" title="三、Promise 的实例方法"></a>三、Promise 的实例方法</h3><blockquote>
<p>深入浅出<code>Promise</code>实例的方法：<code>then()</code> ，<code>catch()</code>，<code>finally()</code>方法</p>
</blockquote>
<table>
<thead>
<tr>
<th>实例方法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>then</td>
<td>为 promise 添加被兑现和被拒绝状态的回调函数，并返回一个新的 promise 对象</td>
</tr>
<tr>
<td>catch</td>
<td>为 promise 添加一个被拒绝状态的回调函数，并返回一个新的 promise</td>
</tr>
<tr>
<td>finally</td>
<td>为 promise 添加一个回调函数，不管 promise 状态是兑现还是拒绝，都会凋用这个回调函数，并返回一个新的 promise</td>
</tr>
</tbody></table>
<h4 id="then-方法"><a href="#then-方法" class="headerlink" title="then 方法"></a>then 方法</h4><blockquote>
<p>then 方法的作用是为 promise 添加被兑现和被拒绝状态的回调函数，并返回一个新的 promise 对象<br>接下来，我们从以下几个方面深入学习 then 方法</p>
<ul>
<li>什么时候执行</li>
<li>then 方法的简写</li>
<li>then 方法执行后的返回值</li>
<li>then 方法向后传值</li>
</ul>
</blockquote>
<ol>
<li><code>then</code> 方法什么时候执行<blockquote>
<p><code>then</code>方法相当于一个<strong>异步方法</strong>（是一个<strong>微任务</strong>），内部的回调函数并不会立即执行，只有 <code>Promise</code> 的状态<strong>改变之后</strong>，<strong>没有同步代码</strong>需要执行时，才会执行。</p>
<ul>
<li>不过它会优先于<code>setTimeOut</code>（<strong>宏任务</strong>）方法前执行</li>
<li><code>Promise</code> 状态由 <code>pending -&gt; fulfilled</code>（成功） 时，执行 <code>then</code> 的第一个回调函数</li>
<li><code>Promise</code> 状态由 <code>pending -&gt; rejected</code>（失败） 时，执行 <code>then</code> 的第二个回调函数<blockquote>
<p>代码执行顺序：</p>
</blockquote>
</li>
<li>自上而下执行，遇到异步方法就添加到队列中去，在等待队列中有两种，一种是微任务，一种是宏任务，微任务优先于宏任务</li>
<li>顺序：自上而下执行同步代码—&gt;(同步代码执行完成后)执行异步任务中的微任务—&gt;异步任务中的宏任务</li>
</ul>
</blockquote>
</li>
</ol>
<ul>
<li>例1</li>
</ul>
<pre><code>setTimeout(function () &#123;
  console.log(1);
&#125;, 0);
&gt;
const promise = new Promise(function (resolve, reject) &#123;
  console.log(3);
  resolve(); // 调用then方法的第一个回调函数
&#125;);
&gt;
promise.then(
  (data) =&gt; &#123;
    console.log(&quot;成功的回调&quot;);
  &#125;,
  (data) =&gt; &#123;
    console.log(&quot;失败的回调&quot;);
  &#125;
);
&gt;
console.log(2);
//代码执行顺序：
//3 2 成功的回调 1
</code></pre>
<blockquote>
<ul>
<li>第一步，执行同步代码：打印出 3 2；<blockquote>
<p>注意：<code>Promise</code>对象一旦创建，就会立即执行构造函数参数中的函数， 创建<code>Promise</code>实例是同步任务，<code>then</code>方法是异步任务</p>
</blockquote>
</li>
<li>第二步，执行微任务，调用<code>resolve()</code>，打印出”成功的回调”</li>
<li>第三步，执行宏任务——定时器，打印出 1</li>
</ul>
</blockquote>
<ul>
<li>例2</li>
</ul>
<pre><code>setTimeout(function () &#123;
  console.log(1);
&#125;, 0);
&gt;
const promise = new Promise(function (resolve, reject) &#123;
  console.log(3);
  setTimeout(function () &#123;
    resolve(); // 3秒后调用then方法的第一个回调函数
  &#125;, 3000);
&#125;);
&gt;
promise.then(
  (data) =&gt; &#123;
    console.log(&quot;成功的回调&quot;);
  &#125;,
  (data) =&gt; &#123;
    console.log(&quot;失败的回调&quot;);
  &#125;
);
&gt;
console.log(2);
//代码执行顺序：
//3 2 1 成功的回调 
</code></pre>
<blockquote>
<ul>
<li>第一步，将定时器加入异步队列</li>
<li>第二步，创建<code>Promise</code>对象，立即打印出 3，将定时器加入异步队列</li>
<li>执行<code>console.log(2);</code>，打印出 2</li>
<li>同步代码都执行完成，异步队列中有两个定时器，第一个定时器延迟时间为0，所以先执行它，打印出 1</li>
<li>三秒后，调用<code>resolve()</code>函数，<code>Promise</code>状态改变，<code>then</code>的第一个回调函数被添加到异步队列中，等同步代码执行完之后才会执行，所以此时打印出”成功的回调”</li>
</ul>
</blockquote>
<ol start="2">
<li>then 方法的简写<blockquote>
<p><code>then</code> 方法的两个回调函数并不一定都要写</p>
<ul>
<li>如果只需要处理<strong>成功</strong>的回调，那只写一个回调就好</li>
</ul>
</blockquote>
</li>
</ol>
<pre><code>const p1 = new Promise(function (resolve, reject) &#123;
  resolve(1);
&#125;);
&gt;
// 只需要处理成功的回调
p1.then((data) =&gt; &#123;
  console.log(&quot;成功&quot;, data);
&#125;);
</code></pre>
<blockquote>
<ul>
<li>如果只需要处理<strong>失败</strong>的回调，第一个回调函数可以用 <code>null</code>代替</li>
</ul>
</blockquote>
<pre><code>const p1 = new Promise(function (resolve, reject) &#123;
  reject(1);
&#125;);
// 只需要处理失败的回调
p1.then(null, (data) =&gt; &#123;
  console.log(&quot;失败&quot;, data);
&#125;);
</code></pre>
<ol start="3">
<li><code>then</code> 方法返回值</li>
</ol>
<ul>
<li><code>then</code>方法的返回值为一个新的<code>Promise</code>对象，所以<code>then</code>方法支持<strong>链式调用</strong></li>
</ul>
<pre><code>const p1 = new Promise(function (resolve, reject) &#123;
  resolve(1);
&#125;);
&gt;
p1.then().then().then();
</code></pre>
<ul>
<li>then方法的返回值默认为一个<strong>新的成功的</strong><code>Promise</code>对象。</li>
</ul>
<pre><code>const p1 = new Promise(function (resolve, reject) &#123;
  reject(1); // 状态为失败
&#125;);
&gt;
p1.then(null, () =&gt; &#123;
  console.log(&quot;a&quot;); // 返回一个新的成功状态的Promise
&#125;)
  .then(() =&gt; &#123;
    console.log(2); // 返回一个新的成功状态的Promise
  &#125;)
  .then(() =&gt; &#123;
    console.log(3); // 返回一个新的成功状态的Promise
  &#125;);
</code></pre>
<blockquote>
<blockquote>
<p>如何才能返回一个失败状态的 Promise 对象呢 ？后边会给出答案</p>
</blockquote>
</blockquote>
<ol start="4">
<li>then 方法向后传值<blockquote>
<p><code>then</code>方法回调函数的<strong>返回值</strong>，会用<code>return</code>来传递给下一个<code>then</code>方法的回调函数的<strong>参数</strong>。不过参数的类型不同，其结果会有所不同。</p>
<ul>
<li>then 方法向后传值，分以下四种情况<table>
<thead>
<tr>
<th>return 返回值</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>不带任何参数</td>
<td><code>then</code>方法第一个回调函数接受到的参数值为 <code>undefined</code></td>
</tr>
<tr>
<td>一般类型（非<code>thenable</code>对象和<code>Promise</code>对象）</td>
<td>then方法第一个回调函数接收到的参数值为这个参数</td>
</tr>
<tr>
<td><code>Promise</code> 实例</td>
<td>该参数的状态和返回值决定了后面 then 的回调函数和参数值</td>
</tr>
<tr>
<td><code>thenable</code>对象</td>
<td>先将 thenable 对象转换为 Promise 对象，然后立即执行 thenable 对象的 then 方法，改变 Promise 的状态。该 Promise 的状态决定了后面 then 方法的回调和参数值</td>
</tr>
</tbody></table>
</li>
</ul>
</blockquote>
</li>
</ol>
<ul>
<li>不带任何参数</li>
</ul>
<pre><code>const p = new Promise(function (resolve, reject) &#123;
  resolve(3);
&#125;);
p.then((data) =&gt; &#123;
  console.log(data); // 3
&#125;).then((data) =&gt; &#123;
  console.log(data); // undefined
&#125;);
</code></pre>
<ul>
<li>一般类型<blockquote>
<ul>
<li>then 方法回调函数的返回值，值会传递给下一个 then 方法的回调函数的参数</li>
</ul>
</blockquote>
</li>
</ul>
<pre><code>const p1 = new Promise(function (resolve, reject) &#123;
  reject(1);
&#125;);
&gt;
p1.then(null, (data) =&gt; &#123;
  console.log(data); // 1
  // 相当于返回 new Promise((resolve,reject)=&gt;resolve(new Error(&quot;错误&quot;)))
  return new Error(&quot;错误&quot;);
&#125;)
  .then((data) =&gt; &#123;
    console.log(data); // Error: 错误
    // 相当于返回 new Promise((resolve,reject)=&gt;resolve(3))
    return 3;
  &#125;)
  .then((data) =&gt; &#123;
    console.log(data); // 3
    // 相当于返回 new Promise((resolve,reject)=&gt;resolve(&#123; a: 1 &#125;))
    return &#123; a: 1 &#125;;
  &#125;)
  .then((data) =&gt; &#123;
    console.log(data); // &#123; a: 1 &#125;
    // 相当于返回 new Promise((resolve,reject)=&gt;resolve(undefined))
  &#125;)
  .then((data) =&gt; &#123;
    console.log(data); // undefined
  &#125;);
</code></pre>
<ul>
<li>Promise 对象<blockquote>
<ul>
<li>如果 then 的回调函数的返回值为 Promise 对象，则后面的 then 的回调和参数的值是由这个 Promise 对象的<strong>状态和返回值</strong>决定。</li>
<li>如果这个 Promise 对象的状态为<strong>成功</strong>的，则执行后面 then 的<strong>第一个</strong>回调，回调中的参数为这个 Promise 的返回值</li>
<li>如果这个 Promise 对象的状态为<strong>失败</strong>的，则执行后面 then 的第<strong>二个</strong>回调，回调中的参数为这个 Promise 的返回值</li>
</ul>
</blockquote>
</li>
</ul>
<pre><code>const p1 = new Promise(function (resolve, reject) &#123;
  resolve(1);
&#125;);
&gt;
const p2 = new Promise(function (resolve, reject) &#123;
  reject(2);
&#125;);
&gt;
const p3 = new Promise(function (resolve, reject) &#123;
  resolve(3);
&#125;);
&gt;
p1.then((data) =&gt; &#123;
  console.log(&quot;第一个then&quot;, data); // 第一个then 1
  return p2;
&#125;)
  .then(
    (data) =&gt; &#123;
      console.log(&quot;第二个then&quot;, data);
    &#125;,
    (err) =&gt; &#123;
      console.log(&quot;第二个then错误&quot;, err); // 第二个then错误 2
      return p3;
    &#125;
  )
  .then((data) =&gt; &#123;
    console.log(&quot;第三个then&quot;, data); // 第三个then 3
  &#125;);
</code></pre>
<blockquote>
<p><strong>代码解析</strong></p>
<ul>
<li>上面 p1 的状态为成功状态，则执行 then 的第一个回调，输出：“第一个 then 1”，其返回值为 p2。</li>
<li>p2 的状态决定了下一个 then 的回调，p2 的状态为失败，则执行 then 的第二个回调，输出：“第二个 then 2”，其返回值为 p3</li>
<li>p3 的状态决定了他的下一个 then、p3 的状态为成功，则执行 then 的第一个回调，输出：“第三个 then 3”</li>
</ul>
</blockquote>
<ul>
<li><code>thenable</code> 对象<blockquote>
<ul>
<li>先将<code>thenable</code>对象转换为<code>Promise</code>对象，然后立即执行 <code>thenable</code>对象的<code>then</code>方法，改变<code>Promise</code>的状态。该 <code>Promise</code>的状态决定了后面<code>then</code>方法的回调和参数值</li>
</ul>
</blockquote>
</li>
</ul>
<pre><code>const p = new Promise(function (resolve, reject) &#123;
  resolve(3);
&#125;);
p.then((data) =&gt; &#123;
  console.log(data); // 3
  // 返回值为thenable对象
  return &#123;
    then(resolve, reject) &#123;
      resolve(&quot;清心&quot;);
    &#125;,
  &#125;;
&#125;).then((data) =&gt; &#123;
  console.log(data); // 清心
&#125;);
</code></pre>
<ol start="5">
<li><code>then</code>返回失败的<code>Promise</code><blockquote>
<p>如果<code>then</code>需要返回一个<strong>失败的</strong><code>Promise</code>对象，有以下三种实现方式：</p>
<ul>
<li><code>then</code>方法回调函数的返回值为一个<strong>失败的</strong><code>Promise</code>对象</li>
<li><code>then</code>方法的回调函数中<strong>主动抛出错误</strong></li>
<li><code>then</code>方法的回调函数返回一个<code>thenable</code>对象,且<code>thenable</code>对象的的<code>then</code>中调用的是<code>reject</code>方法<blockquote>
<p>提示： 除了以上三种情况下，其它情况下<code>then</code>的返回的都是<strong>成功的</strong><code>Promise</code>对象</p>
</blockquote>
</li>
</ul>
</blockquote>
</li>
</ol>
<pre><code>const p1 = new Promise(function (resolve, reject) &#123;
  resolve(1);
&#125;);
p1.then(() =&gt; &#123;
  throw new Error(1); // 抛出错误
  // return new Promise((resolve,reject)=&gt;reject(1))  返回一个失败的Promise对象
  // return &#123;then(resolve,reject)&#123;reject(1)&#125;&#125;  // 返回一个thenable对象，对象的then方法中调用的是reject方法
&#125;).then(
  (data) =&gt; &#123;
    console.log(&quot;成功&quot;, data);
  &#125;,
  (err) =&gt; &#123;
    console.log(&quot;失败&quot;, err);
  &#125;
);
// 打印结果：失败 Error: 1
</code></pre>
<ol start="6">
<li>测试题</li>
</ol>
<pre><code>const p = new Promise((resolve, reject) =&gt; &#123;
  resolve(1); 
  // Promise状态由 pending---&gt;fulfilled
&#125;);
&gt;
p.then((data) =&gt; &#123;
  console.log(data); // 1
  // 没有返回值 相当于then返回了一个成功的Promise,Promise的返回值为 undefined
  // new Promise((resolve,reject)=&gt;&#123;resolve()&#125;)
&#125;)
  .then((data) =&gt; &#123;
    console.log(data); // undefined
    return 3;
    // 相当于then返回了一个成功的Promise，Promise的返回值是3
    // new Promise((resolve,reject)=&gt;resolve(3))
  &#125;)
  .then((data) =&gt; &#123;
    console.log(data); // 3
    return new Promise((resolve, reject) =&gt; reject(4));
    // then返回了一个失败的Promise，Promise的返回值是4
  &#125;)
  .then(null, (err) =&gt; &#123;
    console.log(err); // 4
    return &#123;
      then(resolve, reject) &#123;
        resolve(&quot;清心&quot;);
      &#125;,
    &#125;;
    // new Promise((resolve,reject)=&gt; resolve(&quot;清心&quot;);)
  &#125;)
  .then((data) =&gt; &#123;
    console.log(data); // 清心
  &#125;);
</code></pre>
<h4 id="catch-方法"><a href="#catch-方法" class="headerlink" title="catch 方法"></a>catch 方法</h4><blockquote>
<p>重点了解：<code>catch()</code> 方法的好处和基本用法。</p>
<ul>
<li><code>Promise.prototype.catch()</code>方法是<code>.then(null, rejection)</code>或<code>.then(undefined, rejection)</code>的别名，用于指定<strong>发生错误（失败）时的回调函数</strong>。</li>
</ul>
</blockquote>
<pre><code>const p1 = new Promise(function (resolve, reject) &#123;
  reject(1);
&#125;);
p1.then(null, (err) =&gt; &#123;
  console.log(err);
&#125;);
&gt;
// 上面写法，改成catch方法如下
p1.catch((err) =&gt; &#123;
  console.log(err);
&#125;);
</code></pre>
<ol>
<li>如果 catch 方法前没有错误，就不会执行 catch 方法，其会自动被忽略</li>
</ol>
<pre><code>const p1 = new Promise(function (resolve, reject) &#123;
  resolve(1); // 成功回调
&#125;);
p1.then((data) =&gt; &#123;
  console.log(data); // 1
  return 3;
&#125;) 
  .catch((err) =&gt; &#123;
// 前面代码没有抛出错误，则此处的catch会被忽略，并不会执行
    console.log(&quot;错误&quot;);
    return 4;
  &#125;)
  .then((data) =&gt; &#123;
    // 此处的data为第一个then方法中的返回值
    console.log(data); // 3
  &#125;);
</code></pre>
<ol start="2">
<li>catch 方法的返回值和向后传值原理与 then 方法<strong>完全一样</strong>。<blockquote>
<ul>
<li>catch 方法<strong>默认</strong>返回一个<strong>成功的</strong> Promise 对象，其回调函的返回值会向下传递给下一个 then 或 catch 方法的回调函数的参数</li>
</ul>
</blockquote>
</li>
</ol>
<pre><code>const p1 = new Promise(function (resolve, reject) &#123;
  resolve(1);
&#125;);
p1.then((data) =&gt; &#123;
  console.log(data); // 1
  return new Promise((resolve, reject) =&gt; reject(4)); // 返回一个失败状态的Promise
&#125;)
  .catch((err) =&gt; &#123;
    console.log(err); // 4
    return 3;
  &#125;)
  .then((data) =&gt; &#123;
    console.log(data); //3
    throw new Error(&quot;2&quot;); // 主动抛出错误
  &#125;)
  .catch((err) =&gt; &#123;
    console.log(err); // Error:2
  &#125;);
</code></pre>
<ol start="3">
<li>如果 Promise 的失败状态在 then 方法中没有调用回调函数处理，则<strong>错误会向下传递</strong>，直到遇到 then 的第二个回调或 catch 方法才会被处理，如果一直没有处理，则最后会将错误抛出来<blockquote>
<ul>
<li><code>reject()</code>函数，相当于抛出错误</li>
</ul>
</blockquote>
</li>
</ol>
<pre><code>const p1 = new Promise(function (resolve, reject) &#123;
  reject(1);
&#125;);
// p1状态为失败,then中没有处理,则向下传递
p1.then((data) =&gt; &#123;
  console.log(&quot;成功的回调&quot;, data);
&#125;) // then中没有处理,向下传递
  .then((data) =&gt; &#123;
    console.log(&quot;不会执行2&quot;, data);
  &#125;) // then中没有处理,向下传递
  .then((data) =&gt; &#123;
    console.log(&quot;不会执行2&quot;, data);
  &#125;) // 遇到catch被处理
  .catch((err) =&gt; &#123;
    console.log(&quot;失败的回调&quot;, err);
  &#125;);
// 打印结果：失败的回调 1
</code></pre>
<blockquote>
<blockquote>
<p>代码解析：</p>
</blockquote>
<ul>
<li>代码从上往下执行，p1 的状态为失败（相当于抛出一个错误），第一个 then 中没有书写第二个回调来处理这个错误，所以错误会向下传递，往后的第二个，三个 then 方法中都没有书写第二个回调来处理错误</li>
<li>所以错误继续向下传递，遇到 catch 后，被处理，然后打印输出结果：”失败的回调 1”</li>
</ul>
</blockquote>
<blockquote>
<blockquote>
<p>注意</p>
</blockquote>
<ul>
<li>在错误被抛出后和错误被处理之间的多个<code>then</code>方法中的第一个回调会被忽略，因为then方法的第一个回调函数只处理成功的回调</li>
</ul>
</blockquote>
<ol start="4">
<li>catch 方法有什么好处<blockquote>
<ul>
<li>如果<strong>只需要处理失败（错误）的回调</strong>，则可以用只调用 catch 方法就好，不用调用 then 方法。</li>
<li>如果成功与失败的回调都要处理，则可以采用<strong>链式调用</strong>写法，相当更直观，简洁。</li>
</ul>
</blockquote>
</li>
</ol>
<pre><code>const p1 = new Promise(function (resolve, reject) &#123;
  // resolve(1);
  reject(2);
&#125;);
&gt;
p1.then((data) =&gt; &#123;
  console.log(&quot;成功的回调&quot;, data);
&#125;).catch((err) =&gt; &#123;
  console.log(&quot;失败的回调&quot;, err);
&#125;);
// 打印结果： 失败的回调 2
</code></pre>
<ol start="5">
<li>总结<blockquote>
<ul>
<li><code>catch()</code> 方法主要用来捕获它前面的错误<br>在实际开发中，一般总是建议，Promise 对象后面要跟 <code>catch()</code>方法（一个或多个 catch 方法），这样可以处理 Promise 内部发生的错误。</li>
</ul>
</blockquote>
</li>
</ol>
<blockquote>
<blockquote>
<p>注：</p>
</blockquote>
<ul>
<li>catch 方法主要是用来捕获它前面的错误，promise 抛出一个错误，就被catch()方法指定的回调函数捕获，如果没有错误，就不会执行 catch 方法。</li>
</ul>
</blockquote>
<h4 id="finally方法"><a href="#finally方法" class="headerlink" title="finally方法"></a>finally方法</h4><blockquote>
<p>需要重点了解：finally()方法什么时候执行，本质是什么 ?</p>
<ul>
<li>finally()方法用于指定不管 Promise 对象最后状态如何，都会执行的操作。该方法是 ES2018 引入标准的。在实际开发中用得不多，仅做了解。</li>
</ul>
</blockquote>
<pre><code>const p1 = new Promise(function (resolve, reject) &#123;
  // resolve(&quot;成功&quot;);
  reject(&quot;失败&quot;);
&#125;);
&gt;
p1.finally((data) =&gt; &#123;
  console.log(&quot;执行了&quot;);
  console.log(data);
&#125;);
</code></pre>
<blockquote>
<blockquote>
<p>注：</p>
</blockquote>
<ul>
<li>finally 方法并不会接受任何参数，也不处理错误，只是用来执行 finally 方法回调函数中的代码。他常用来处理不关异步操作成功还是失败，最后都要做的操作。</li>
<li>比如：常见的数据库操作，不关最后操作成功还是失败，都需要关闭数据库。</li>
</ul>
</blockquote>
<h3 id="四、Promise-的实践和应用"><a href="#四、Promise-的实践和应用" class="headerlink" title="四、Promise 的实践和应用"></a>四、Promise 的实践和应用</h3><blockquote>
<p>异步任务的执行分为并发和继发<br><strong>继发</strong></p>
<ul>
<li>定义：指等上一个异步操作结束之后，才开始执行下一个异步任务</li>
<li>应用：一般在执行异步任务时需要上一个异步操作的结果，只有等上一个异步任务得到结果后，才能执行下一个异步任务，就需要采用继发模式。<br><strong>并发</strong></li>
<li>定义：多个异步任务同时触发执行</li>
<li>应用：如果多个异步任务之间没有依赖关系，各自可以独立进行的时候，应该让他们同时触发，就需要采用并发模式</li>
</ul>
</blockquote>
<ol>
<li>Promise 实现<strong>继发</strong>加载 5 张图片</li>
</ol>
<pre><code>function preloadImage(url) &#123;
  return new Promise((resolve, reject) =&gt; &#123;
    let img = new Image();
    img.style.cssText = &quot;width:200px&quot;;
    img.onload = function () &#123;
      resolve(img);
    &#125;;
    img.onerror = function () &#123;
      // reject(new Error(&quot;图片地址错误&quot;));
      reject(null);
    &#125;;
    img.src = url;
  &#125;);
&#125;
&gt;
let urls = [
  &quot;https://sce7a2b9c9d95a-sb-qn.qiqiuyun.net/files/course/2020/04-23/1339186404a1276893.jpg&quot;,
  &quot;https://sce7a2b9c9d95a-sb-qn.qiqiuyun.net/files/course/2019/10-29/011138ab5ee2314108.png&quot;,
  &quot;https://sce7a2b9c9d95a-sb-qn.qiqiuyun.net/files/course/2019/11-06/134028c28eb5212376.jpg&quot;,
  &quot;https://sce7a2b9c9d95a-sb-qn.qiqiuyun.net/files/course/2022/08-29/210311f40bcf290736.jpg&quot;,
  &quot;https://sce7a2b9c9d95a-sb-qn.qiqiuyun.net/files/course/2022/03-19/174949d70767470556.jpg&quot;,
];
preloadImage(urls[0])
  .then((data) =&gt; &#123;
    if (data) document.body.appendChild(data);
    // 加载第二张
    return preloadImage(urls[1]);
  &#125;)
  .catch(() =&gt; &#123;&#125;)
  .then((data) =&gt; &#123;
    if (data) document.body.appendChild(data);
    // 加载第三张
    return preloadImage(urls[2]);
  &#125;)
  .catch(() =&gt; &#123;&#125;)
  .then((data) =&gt; &#123;
    if (data) document.body.appendChild(data);
    // 加载第四张
    return preloadImage(urls[3]);
  &#125;)
  .catch(() =&gt; &#123;&#125;)
  .then((data) =&gt; &#123;
    if (data) document.body.appendChild(data);
    // 加载第五张
    return preloadImage(urls[4]);
  &#125;)
  .catch(() =&gt; &#123;&#125;)
  .then((data) =&gt; &#123;
    if (data) document.body.appendChild(data);
  &#125;);
</code></pre>
<blockquote>
<blockquote>
<p>注：</p>
</blockquote>
<ul>
<li>上面代码中每个<code>then</code>方法后面都跟了一个<code>catch</code>，主要是为了防止图片加载失败后，其错误没有处理而造成后面的<code>then</code> 方法直接被忽略，从而造成后面的图片都没有办法加载。</li>
</ul>
</blockquote>
<ol start="2">
<li>Promise 实现<strong>并发</strong>加载 5 张图片</li>
</ol>
<pre><code>function preloadImage(url) &#123;
  return new Promise((resolve, reject) =&gt; &#123;
    let img = new Image();
    img.style.cssText = &quot;width:200px&quot;;
    img.onload = function () &#123;
      resolve(img);
    &#125;;
    img.onerror = function () &#123;
      // reject(new Error(&quot;图片地址错误&quot;));
      reject(null);
    &#125;;
    img.src = url;
  &#125;);
&#125;
&gt;
let urls = [
  &quot;https://sce7a2b9c9d95a-sb-qn.qiqiuyun.net/files/course/2020/04-23/1339186404a1276893.jpg&quot;,
  &quot;https://sce7a2b9c9d95a-sb-qn.qiqiuyun.net/files/course/2019/10-29/011138ab5ee2314108.png&quot;,
  &quot;https://sce7a2b9c9d95a-sb-qn.qiqiuyun.net/files/course/2019/11-06/134028c28eb5212376.jpg&quot;,
  &quot;https://sce7a2b9c9d95a-sb-qn.qiqiuyun.net/files/course/2022/08-29/210311f40bcf290736.jpg&quot;,
  &quot;https://sce7a2b9c9d95a-sb-qn.qiqiuyun.net/files/course/2022/03-19/174949d70767470556.jpg&quot;,
];
preloadImage(urls[0])
  .then((data) =&gt; &#123;
    document.body.appendChild(data);
  &#125;)
  .catch(() =&gt; &#123;&#125;);
preloadImage(urls[1])
  .then((data) =&gt; &#123;
    document.body.appendChild(data);
  &#125;)
  .catch(() =&gt; &#123;&#125;);
preloadImage(urls[2])
  .then((data) =&gt; &#123;
    document.body.appendChild(data);
  &#125;)
  .catch(() =&gt; &#123;&#125;);
preloadImage(urls[3])
  .then((data) =&gt; &#123;
    document.body.appendChild(data);
  &#125;)
  .catch(() =&gt; &#123;&#125;);
preloadImage(urls[4])
  .then((data) =&gt; &#123;
    document.body.appendChild(data);
  &#125;)
  .catch(() =&gt; &#123;&#125;);
</code></pre>
<ol start="3">
<li>Generator 函数实现继发加载 5 张图片<blockquote>
<p>实现的基本思想</p>
<ul>
<li>通过<code>Generator</code>函数生成的遍历器对象的<code>next</code>方法的参数，把外部的值传到<code>Generator</code>函数内部来，然后做相关操作，最后再接着执行下一步的异步操作。</li>
</ul>
</blockquote>
</li>
</ol>
<ul>
<li>基础版</li>
</ul>
<pre><code>// 预加载一张图片，图片加载成功后，需要处理的事情在回调函数中处理
function preloadImage(url) &#123;
  let img = new Image();
  img.style.cssText = &quot;width:200px;margin:10px&quot;;
  img.onload = function () &#123;
    it.next(img);
  &#125;;
  img.onerror = function () &#123;
    it.next(null);
  &#125;;
&gt;
  img.src = url;
&#125;
&gt;
const urls = [
  &quot;https://sce7a2b9c9d95a-sb-qn.qiqiuyun.net/files/course/2022/08-29/210311f40bcf290736.jpg&quot;,
  &quot;https://sce7a2b9c9d95a-sb-qn.qiqiuyun.net/files/course/2019/11-06/134028c28eb5212376.jpg&quot;,
  &quot;https://sce7a2b9c9d95a-sb-qn.qiqiuyun.net/files/course/2020/02-08/145955bc3b00504448.jpg&quot;,
  &quot;https://sce7a2b9c9d95a-sb-qn.qiqiuyun.net/files/course/2022/03-19/174949d70767470556.jpg&quot;,
  &quot;https://sce7a2b9c9d95a-sb-qn.qiqiuyun.net/files/course/2022/02-19/16465934b475255075.jpg&quot;,
];
/*
function* gen() &#123;
    let img = yield preloadImage(urls[0]);
    if (img) document.body.appendChild(img);
    img = yield preloadImage(urls[1]);
    if (img) document.body.appendChild(img);
    img = yield preloadImage(urls[2]);
    if (img) document.body.appendChild(img);
    img = yield preloadImage(urls[3]);
    if (img) document.body.appendChild(img);
    img = yield preloadImage(urls[4]);
    if (img) document.body.appendChild(img);
&#125;
*/
/* 上面Generator函数可以简写成下面形式 */
function* gen() &#123;
  let img;
  for (let v of urls) &#123;
    img = yield preloadImage(v);
    if (img) document.body.appendChild(img);
  &#125;
&#125;
// 生成遍历器
const it = gen();
it.next(); // 开始执行代码
</code></pre>
<ul>
<li>优化版<blockquote>
<ul>
<li>以下形式的写法，前提是，每一次加载图片成功后，操作的内容是一样的</li>
</ul>
</blockquote>
</li>
</ul>
<pre><code>// 预加载一张图片，图片加载成功后，需要处理的事情在回调函数中处理
function preloadImage(url) &#123;
  let img = new Image();
  img.style.cssText = &quot;width:200px;margin:10px&quot;;
  img.onload = function () &#123;
    document.body.appendChild(img);
  &#125;;
  img.onerror = function () &#123;&#125;;
  img.src = url;
&#125;
&gt;
const urls = [
  &quot;https://sce7a2b9c9d95a-sb-qn.qiqiuyun.net/files/course/2022/08-29/210311f40bcf290736.jpg&quot;,
  &quot;https://sce7a2b9c9d95a-sb-qn.qiqiuyun.net/files/course/2019/11-06/134028c28eb5212376.jpg&quot;,
  &quot;https://sce7a2b9c9d95a-sb-qn.qiqiuyun.net/files/course/2020/02-08/145955bc3b00504448.jpg&quot;,
  &quot;https://sce7a2b9c9d95a-sb-qn.qiqiuyun.net/files/course/2022/03-19/174949d70767470556.jpg&quot;,
  &quot;https://sce7a2b9c9d95a-sb-qn.qiqiuyun.net/files/course/2022/02-19/16465934b475255075.jpg&quot;,
];
&gt;
function* gen() &#123;
  yield preloadImage(urls[0]);
  yield preloadImage(urls[1]);
  yield preloadImage(urls[2]);
  yield preloadImage(urls[3]);
  yield preloadImage(urls[4]);
&#125;
&gt;
// 生成遍历器
const it = gen();
it.next(); // 加载第1张图片
it.next(); // 加载第2张图片
it.next(); // 加载第3张图片
it.next(); // 加载第4张图片
it.next(); // 加载第5张图片
</code></pre>
<ul>
<li>Generator 函数与自动化管理</li>
</ul>
<pre><code>// 预加载一张图片，图片加载成功后，需要处理的事情在回调函数中处理
function preloadImage(url) &#123;
  return function thunk(resolve, reject) &#123;
    let img = new Image();
    img.style.cssText = &quot;width:200px;margin:10px&quot;;
    img.onload = function () &#123;
      resolve(img);
    &#125;;
    img.onerror = function () &#123;
      reject(null);
    &#125;;
    img.src = url;
  &#125;;
&#125;
&gt;
const urls = [
  &quot;https://sce7a2b9c9d95a-sb-qn.qiqiuyun.net/files/course/2022/08-29/210311f40bcf290736.jpg&quot;,
  &quot;https://sce7a2b9c9d95a-sb-qn.qiqiuyun.net/files/course/2019/11-06/134028c28eb5212376.jpg&quot;,
  &quot;https://sce7a2b9c9d95a-sb-qn.qiqiuyun.net/files/course/2020/02-08/145955bc3b00504448.jpg&quot;,
  &quot;https://sce7a2b9c9d95a-sb-qn.qiqiuyun.net/files/course/2022/03-19/174949d70767470556.jpg&quot;,
  &quot;https://sce7a2b9c9d95a-sb-qn.qiqiuyun.net/files/course/2022/02-19/16465934b475255075.jpg&quot;,
];
&gt;
//   const it = gen();
//   it.next().value(function (data) &#123;
//     document.body.appendChild(data);
//     it.next().value(function (data) &#123;
//       document.body.appendChild(data);
//       it.next().value(function (data) &#123;
//         document.body.appendChild(data);
//         it.next().value(function (data) &#123;
//           document.body.appendChild(data);
//         &#125;);
//       &#125;);
//     &#125;);
//   &#125;);
&gt;
function* gen() &#123;
  yield preloadImage(urls[0]);
  yield preloadImage(urls[1]);
  yield preloadImage(urls[2]);
  yield preloadImage(urls[3]);
  yield preloadImage(urls[4]);
&#125;
&gt;
// 采取自动化管理
function run(gen) &#123;
  let it = gen();
  function next() &#123;
    let result = it.next();
    if (result.done) return;
    result.value(function (data) &#123;
      document.body.appendChild(data);
      // next(); // 写在这里是继发
    &#125;);
    next(); // 写在这里是并发
  &#125;
  next();
&#125;
&gt;
run(gen);
</code></pre>
<h3 id="五、Promise-的构造函数方法"><a href="#五、Promise-的构造函数方法" class="headerlink" title="五、Promise 的构造函数方法"></a>五、Promise 的构造函数方法</h3><blockquote>
<p>深入浅出<code>Promise</code>的构造函数方法，<code>Promise.resolve()</code>和<code>Promise.reject()</code>、<code>Promise.all()</code>、<code>Promise.race()</code>和<code>Promise.allSettled()</code>、<code>Promise.any()</code></p>
<ul>
<li>重点学习<code>Promise.resolve()</code>和<code>Promise.reject()</code>这个两个方法的：本质，参数 和 在 then 方法中的应用</li>
</ul>
</blockquote>
<ol>
<li><code>Promise.resolve()</code>方法<blockquote>
<p>有时需要将一个对象转为成功的 <code>Promise</code> 对象，<code>Promise.resolve</code>方法就可以起到这个作用。</p>
<ul>
<li><code>Promise.resolve()</code>方法是<strong>成功状态</strong><code>Promise</code>的一种简写形式</li>
</ul>
</blockquote>
</li>
</ol>
<pre><code>Promise.resolve(&quot;hello&quot;);
// 等价于
new Promise((resolve, reject) =&gt; &#123;
  resolve(&quot;hello&quot;);
&#125;);
</code></pre>
<p><strong>基本用法</strong></p>
<ul>
<li>创建一个成功的 Promise 对象</li>
</ul>
<pre><code>// 创建一个成功的Promise对象
Promise.resolve(&quot;hello&quot;).then((data) =&gt; &#123;
  console.log(data); // hello
&#125;);
</code></pre>
<ul>
<li>then 的回调函数中返回一个成功的 Promise 对象</li>
</ul>
<pre><code>const p = new Promise((resolve, reject) =&gt; &#123;
  resolve(22);
&#125;);
p.then((data) =&gt; &#123;
  return Promise.resolve(&quot;icoding&quot;); // 返回一个成功的Promise
&#125;).then((data) =&gt; &#123;
  console.log(data); // icoding
&#125;);
</code></pre>
<p><strong>resolve方法的参数</strong></p>
<blockquote>
<ul>
<li>resolve 方法的参数分以下 4 种情况展开讲解</li>
</ul>
</blockquote>
<table>
<thead>
<tr>
<th>参数类型</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>不带任何参数</td>
<td>直接返回一个成功状态的 Promise 对象</td>
</tr>
<tr>
<td>一般类型（非 thenable 对象和 Promise 对象））</td>
<td>直接返回一个成功状态的 Promise 对象</td>
</tr>
<tr>
<td>Promise 实例</td>
<td>直接返回这个 Promise 实例</td>
</tr>
<tr>
<td>thenable 对象</td>
<td>先将 thenable 对象转换为 Promise 对象，然后立即执行 thenable 对象的 then 方法，改变 Promise 的状态。</td>
</tr>
</tbody></table>
<ul>
<li>不带任何参数</li>
</ul>
<pre><code>Promise.resolve();
// 等价于
new Promise((resolve, reject) =&gt; resolve());
</code></pre>
<ul>
<li>参数为一般类型</li>
</ul>
<pre><code>Promise.resolve(&quot;hello&quot;);
// 等价于
new Promise((resolve, reject) =&gt; &#123;
  resolve(&quot;hello&quot;);
&#125;);
</code></pre>
<ul>
<li>参数为 Promise 实例</li>
</ul>
<pre><code>const p1 = new Promise((resolve, rejcet) =&gt; resolve(&quot;hello&quot;));
const p3 = Promise.resolve(p1);
console.log(p3 === p1); // true
&gt;
// 与下面代码做区分
const p1 = new Promise((resolve, rejcet) =&gt; resolve(&quot;hello&quot;));
const p2 = new Promise((resolve, rejcet) =&gt; resolve(p1));
console.log(p1 === p2); // false
</code></pre>
<blockquote>
<blockquote>
<p>注意区分：</p>
</blockquote>
<ul>
<li><code>Promise.resolve()</code>方法是直接返回<code>Promise实例</code>，所以参数实例和接收到的实例是同一个</li>
</ul>
</blockquote>
<ul>
<li>参数为 thenable 对象<blockquote>
<ul>
<li>将 thenable 对象作为 <code>Promise.resolve</code> 的参数，则会先将 thenable 对象转换为 Promise 对象，然后立即执行 thenable 对象的 then 方法，从而改变 Promise 的状态。</li>
</ul>
</blockquote>
</li>
</ul>
<pre><code>let thenable = &#123;
  name: &quot;icoding&quot;,
  b: 2,
  then(resolve, reject) &#123;
    resolve(this.name);
  &#125;,
&#125;;
&gt;
Promise.resolve(thenable).then((data) =&gt; &#123;
  console.log(data);
&#125;);
// 打印结果： icoding
</code></pre>
<ol start="2">
<li>Promise.reject() 方法<blockquote>
<p>有时需要将一个对象转为<strong>失败的</strong> Promise 对象，Promise.reject方法就可以起到这个作用。</p>
<ul>
<li>Promise.reject() 是失败状态 Promise 的一种简写形式</li>
</ul>
</blockquote>
</li>
</ol>
<pre><code>Promise.reject(new Error(&quot;错误&quot;));
// 等价于
new Promise((resolve, reject) =&gt; reject(&quot;错误&quot;));
</code></pre>
<p><strong>基本用法</strong></p>
<blockquote>
<ul>
<li>当我们需要在 then 方法中返回一个失败的 Promise 时，就可以用 Promise.reject 方法</li>
</ul>
</blockquote>
<pre><code>Promise.reject(new Error(&quot;地址错误&quot;))
  .catch((err) =&gt; &#123;
    console.log(err); // Error: 地址错误
    return 3;
  &#125;)
  .then((data) =&gt; &#123;
    console.log(data); // 3
    // 抛出错误的Promise
    return Promise.reject(new Error(&quot;内部错误&quot;));
  &#125;)
  .catch((err) =&gt; &#123;
    console.log(err); // Error: 内部错误
  &#125;);
</code></pre>
<p><strong>参数问题</strong></p>
<blockquote>
<ul>
<li>Promise.reject()的参数不管是什么类型都会<strong>原封不动</strong>传递给新创建的 Promise 回调函数的 reject 参数的参数。这一点与<code>Promise.resolve()</code>方法<strong>不一样</strong>喽</li>
<li>参数为thenable对象</li>
</ul>
</blockquote>
<pre><code>obj = &#123;
  then(resolve, reject) &#123;
    resolve(22);
  &#125;,
&#125;;
&gt;
Promise.reject(obj).catch((data) =&gt; console.log(data));
// 打印结果：&#123;then:f&#125;
</code></pre>
<blockquote>
<ul>
<li>如果是<code>Promise.resolve()</code>方法，则会打印出22</li>
</ul>
</blockquote>
<blockquote>
<ul>
<li>参数为 Promise 实例</li>
</ul>
</blockquote>
<pre><code>const p1 = new Promise((resolve, reject) =&gt; resolve(&quot;hello&quot;));
&gt;
const p2 = Promise.reject(p1);
console.log(p1 === p2); // false
p2.catch((data) =&gt; &#123;
  console.log(data); // p1
&#125;);
</code></pre>
<blockquote>
<blockquote>
<p>与<code>resolve()</code>方法对比</p>
</blockquote>
</blockquote>
<pre><code>const p1 = new Promise((resolve, reject) =&gt; resolve(&quot;hello&quot;));
&gt;
const p2 = Promise.resolve(p1);
console.log(p1 === p2); // false
p2.then((data) =&gt; &#123;
  console.log(data); // hello
&#125;);
</code></pre>
<ol start="3">
<li>Promise.all() 方法<blockquote>
<p><code>Promise.all()</code>方法用于关注多个<code>Promise</code>对象的状态变化。其参数只要是一个迭代器对象或可遍历对象就可以。迭代的每个成员如果不是 Promise 对象，则会先将其转换为 Promise 对象，再做处理。<br><strong>语法</strong></p>
</blockquote>
</li>
</ol>
<pre><code>const p = Promise.all(iterable);
</code></pre>
<p><strong>基本用法</strong></p>
<pre><code>const p = Promise.all([p1,p2,p3,...]) ; // p1 p2 p3都是promise对象
</code></pre>
<blockquote>
<blockquote>
<p>注：<br>上面代码中，<code>Promise.all</code>接受一个数组作为参数，数组的成员都是<code>Promise</code>对象，如果其成员不是<code>Promise</code>对象，会将其转换为成功的<code>Promise</code>对象，再进一步处理。<br>返回值 p 为一个新的 Promise 对象，其状态由 p1,p2,p3 决定，<strong>分两种情况</strong></p>
</blockquote>
<ul>
<li>只有 p1,p2,p3 的状态<strong>都是<code>fulfilled</code><strong>，p 的状态才会变成<code>fulfilled</code>, 此时 p1,p2,p3 的返回值（<code>[[PromiseResult]]</code>属性值）组成一个</strong>数组</strong>，传递给到<code>p.then</code>的回调函数</li>
<li>只要 p1,p2,p3 中<strong>有一个</strong>的状态是 <code>rejected</code>，p 的状态就会变成 <code>rejected</code>，此时**第一个状态变为 <code>rejected</code>**的promise实例的返回值（<code>[[PromiseResult]]</code>属性值）传递给 <code>p.then</code> 的回调函数</li>
</ul>
</blockquote>
<ul>
<li>代码演示一：<blockquote>
<ul>
<li><code>Promise.all()</code>方法参数中的所有<code>Promise</code>对象状态都变为<code>fulfilled</code>的情况</li>
</ul>
</blockquote>
</li>
</ul>
<pre><code>const p1 = new Promise((resolve, reject) =&gt; &#123;
  setTimeout(() =&gt; &#123;
    resolve(1);
  &#125;, 1000);
&#125;);
p1.then(() =&gt; &#123;
  console.log(&quot;p1成功&quot;);
&#125;);
&gt;
const p2 = new Promise((resolve, reject) =&gt; &#123;
  setTimeout(() =&gt; &#123;
    resolve(2);
  &#125;, 2000);
&#125;);
p2.then((data) =&gt; &#123;
  console.log(&quot;p2成功&quot;);
&#125;);
&gt;
const p3 = new Promise((resolve, reject) =&gt; &#123;
  setTimeout(() =&gt; &#123;
    resolve(3);
  &#125;, 3000);
&#125;);
p3.then((data) =&gt; &#123;
  console.log(&quot;p3成功&quot;);
&#125;);
&gt;
const p = Promise.all([p1, p2, p3]);
p.then((data) =&gt; &#123;
  console.log(&quot;成功&quot;, data);
&#125;).catch((err) =&gt; &#123;
  console.log(&quot;失败&quot;, err);
&#125;);
&gt;
// p1,p2,p3状态都为fulfilled时,p的状态改变fulfilled,然后执行他的then方法
</code></pre>
<blockquote>
<blockquote>
<p>代码解释：</p>
</blockquote>
<ul>
<li>1s 后 p1 的状态变为 fulfiled，打印出：”p1 成功”</li>
<li>2s 后 p2 的状态变为 fulfilled，打印出：”p2 成功”</li>
<li>3s 后 p3 的状态变为 fulfilled,打印出：”p3 成功”</li>
<li>当 p1,p2,p3 的状态都变为 fulfilled 时， p 的状态变为 fulfilled，然后调用 then 方法的第一个回调，打印出：”成功 [1,2 ,3]”</li>
</ul>
</blockquote>
<ul>
<li>代码演示二：<blockquote>
<p>-<code> Promise.all()</code>方法参数中的 Promise 对象状态有一个变为 rejected 的情况</p>
</blockquote>
</li>
</ul>
<pre><code>const p1 = new Promise((resolve, reject) =&gt; &#123;
  setTimeout(() =&gt; &#123;
    resolve(1);
  &#125;, 1000);
&#125;);
p1.then(() =&gt; &#123;
  console.log(&quot;p1成功&quot;);
&#125;);
&gt;
const p2 = new Promise((resolve, reject) =&gt; &#123;
  setTimeout(() =&gt; &#123;
    reject(2);
  &#125;, 2000);
&#125;);
p2.catch((err) =&gt; &#123;
  console.log(&quot;p2失败&quot;);
&#125;);
&gt;
const p3 = new Promise((resolve, reject) =&gt; &#123;
  setTimeout(() =&gt; &#123;
    resolve(3);
  &#125;, 3000);
&#125;);
p3.then((data) =&gt; &#123;
  console.log(&quot;p3成功&quot;);
&#125;);
&gt;
const p = Promise.all([p1, p2, p3]);
p.then((data) =&gt; &#123;
  console.log(&quot;成功&quot;, data);
&#125;).catch((err) =&gt; &#123;
  console.log(&quot;失败&quot;, err);
&#125;);
&gt;
// 当p2状态为reject时，p的状态也变为rejected,同时执行catch方法
</code></pre>
<blockquote>
<blockquote>
<p>代码解释：</p>
</blockquote>
<ul>
<li>1s 后 p1 的状态变为 fulfiled，打印出：”p1 成功”</li>
<li>2s 后 p2 的状态变为 rejected，打印出：”p2 失败”。</li>
<li>此时 p 的状态变为 rejected，然后调用 catch 方法，打印出：“失败 2”</li>
<li>3s 后 p3 的状态变为 fulfilled，打印出”p3 成功”。<br><strong>总结：</strong></li>
<li>只要 p1,p2,p3 中有一个的状态率先变为 rejected 的，则 p 的状态就会变为 rejected 的。但并不会因为 p 的状态变为 rejected 的，其后没有执行完的 Promise 就不执行了，后面的 Promise<strong>该如何执行还得如何执行完</strong>。</li>
</ul>
</blockquote>
<ul>
<li>Promise.all() 最常用的场景<blockquote>
<ul>
<li>通过 Ajax 或其他方式从前端向后端获取数据的时候会用到<br>如：同时获取多个数据，所有数据都获取到了，都显示出来。如果没获取到再次处理 ，类似应用用的到比较多的地方。</li>
<li>目前只需要知道即可</li>
</ul>
</blockquote>
</li>
</ul>
<ol start="4">
<li>Promise.race() 方法<blockquote>
<p>Promise.race 方法（race 翻译过来为“竞赛”）用来关注多个 Promise 的状态，<strong>看哪个 Promise 的状态先改变</strong>，然后返回一个新的 Promise 对象，新的 Promise 的状态和返回值与最先改变的那个 Promise 对象一致。</p>
</blockquote>
</li>
</ol>
<p><strong>语法</strong></p>
<pre><code>const p = Promise.race(iterable);
</code></pre>
<blockquote>
<p><strong>参数：</strong><code>iterable</code></p>
<ul>
<li>表示一个迭代器对象或可遍历对象就可以。不过迭代的每个成员如果不是 Promise 对象，则会先将其转换为 Promise 对象，再做处理。</li>
</ul>
</blockquote>
<p><strong>基本用法</strong></p>
<pre><code>const p = Promise.race([p1, p2, p3,...]);
</code></pre>
<blockquote>
<p><strong>上面代码中</strong></p>
<ul>
<li>p,p1,p2,p3 为 Promise 对象，p 的状态由 p1,p2,p3 的状态决定。</li>
<li>只要 p1,p2,p3 中有一个先改变状态，p 的状态就跟着改变。p 的状态和返回值与第一个先改变状态的 Promise 对象的状态和返回值是一致的。</li>
</ul>
</blockquote>
<ul>
<li>代码演示</li>
</ul>
<pre><code>const p1 = new Promise((resolve, reject) =&gt; &#123;
  setTimeout(() =&gt; &#123;
    resolve(1);
  &#125;, 1000);
&#125;);
p1.then(() =&gt; &#123;
  console.log(&quot;p1成功&quot;);
&#125;);
&gt;
const p2 = new Promise((resolve, reject) =&gt; &#123;
  setTimeout(() =&gt; &#123;
    reject(new Error(&quot;地址出错了&quot;));
  &#125;, 2000);
&#125;);
p2.catch(() =&gt; &#123;
  console.log(&quot;p2失败&quot;);
&#125;);
&gt;
const p3 = new Promise((resolve, reject) =&gt; &#123;
  setTimeout(() =&gt; &#123;
    resolve(3);
  &#125;, 3000);
&#125;);
p3.then(() =&gt; &#123;
  console.log(&quot;p3成功&quot;);
&#125;);
&gt;
const p = Promise.race([p1, p2, p3]);
p.then((data) =&gt; &#123;
  console.log(&quot;p成功&quot;, data);
&#125;).catch((err) =&gt; &#123;
  console.log(&quot;p失败&quot;, err);
&#125;);
</code></pre>
<blockquote>
<p><strong>代码解析：</strong></p>
<ul>
<li>1s 后 p1 的状态改变，变为fulfilled，然后调用 then 方法，打印： “p1 成功”</li>
<li>因为 p1 状态改变fulfilled，则 p 的状态也变为fulfilled，然后调用 then 方法，打印： “p 成功 1”</li>
<li>2s 后 p2 的状态改变，变为“rejected”，然后调用 catch 方法，打印：”p2 失败“</li>
<li>2s 后 p3 的状态改变，变为 “fulfilled”，然后调用 then 方法，打印：”p3 成功“<br><strong>提示：</strong></li>
<li>不管第一个改变状态的 Promise，其状态是成功或还是失败，p 的状态都会在第一个状态改变的 Promise 之后马上改变。</li>
<li>但对其它没有操作完成的 Promise 没有影响。</li>
</ul>
</blockquote>
<ul>
<li>Promise.race() 应用<blockquote>
<p>我们经常会有这样的需求，如果某个异步请求在 3s 内还没有响应结果，则把 Promise 的状态改变为 rejected 的，再次发送请求。</p>
<ul>
<li>如果 3s 内的响应为失败，也重新发送一次请求。</li>
</ul>
</blockquote>
</li>
</ul>
<pre><code>// 预加载图片
function preloadImage(url) &#123;
  return new Promise((resolve, reject) =&gt; &#123;
    const img = new Image();
    img.onload = function () &#123;
      resolve(img);
    &#125;;
    img.onerror = function () &#123;
      reject(new Error(&quot;图片加载失改&quot;));
    &#125;;
    img.src = url;
  &#125;);
&#125;
&gt;
const p2 = new Promise((resolve, reject) =&gt; &#123;
  setTimeout(() =&gt; &#123;
    reject(&quot;超时,重新发送&quot;);
  &#125;, 3000);
&#125;);
&gt;
const url =
  &quot;https://sce7a2b9c9d95a-sb-qn.qiqiuyun.net/files/system/2019/09-25/22132557f330499313.png?version=22.3.7&quot;;
const p = Promise.race([preloadImage(url), p2]);
p.then((data) =&gt; &#123;
  console.log(&quot;一次成功&quot;);
  document.body.appendChild(data);
&#125;)
  .catch((err) =&gt; &#123;
    console.log(err);
    return preloadImage(url);//再次请求
  &#125;)
  .then((data) =&gt; &#123;
    if (data) document.body.appendChild(data);
  &#125;);
</code></pre>
<blockquote>
<blockquote>
<p>代码解析：</p>
</blockquote>
<ul>
<li>如果 preloadImage 方法中返回的 Promise 对象在 3 秒内状态改变</li>
<li>如果状态为成功，则 p 的状态为成功，执行 p 的 then 方法，把图片插入到页面中。下一个 then 方法的参数值为 undefined，则不会执行插入 dom 操作。</li>
<li>如果状态为失败，则 p 的状态为失败，执行 p 的 catch 方法，重新发送一次请求，请求成功将图片，插入页面，请求失败，抛出错误。</li>
<li>如果 preloadImage 方法返回的 Promise 对象在 3s 秒后状态才改变，则先改变状态的是 p2，p2 为失败的 Promise 对象，p 的状态为失败，执行 catch 方法，重新发送一次请求，请求成功将图片，插入页面，请求失败，抛出错误。</li>
</ul>
</blockquote>
<ol start="5">
<li>Promise.allSettled() 方法<blockquote>
<p>Promise.allSettled 方法用来记录多个 Promise 的状态，他只忠于记录各个 Promise 的状态，<strong>其自身状态永远不受其他 Promise 状态的影响</strong>，返回的新的 Promise 实例<strong>永远为成功</strong>状态。</p>
</blockquote>
</li>
</ol>
<p><strong>语法</strong></p>
<pre><code>const p = Promise.allSettled(iterable);
</code></pre>
<p><strong>基本用法</strong></p>
<pre><code>const p = Promise.allSettled([p1, p2, p3]);
</code></pre>
<blockquote>
<blockquote>
<p>以上代码中</p>
</blockquote>
<ul>
<li>p,p1,p2,p3 都是 Promise 对象，当 p1,p2,p3 的状态都改变后，p 的状态才变为fulfilled</li>
<li>其 p 的返回值是一个数组，数组的每个成员都是一个对象，用来记录每个 promise 的状态，其对象顺序与传入的参数的顺序一样。</li>
</ul>
</blockquote>
<blockquote>
<blockquote>
<p>对象都有以下属性</p>
</blockquote>
<ul>
<li>status 表示对应 promise 的状态，要么是 “fulfilled”，要么是 “rejected”</li>
<li>value 仅当 status 为 “fulfilled”，才存在，表示 promise 成功时才有的值</li>
<li>reason 仅当 status 为 “rejected”，才存在，在 promsie 失败时才有 reason</li>
</ul>
</blockquote>
<pre><code>const p1 = new Promise((resolve, reject) =&gt; &#123;
  setTimeout(() =&gt; &#123;
    resolve(1);
  &#125;, 1000);
&#125;);
p1.then(() =&gt; &#123;
  console.log(&quot;p1状态改变&quot;);
&#125;);
&gt;
const p2 = new Promise((resolve, reject) =&gt; &#123;
  setTimeout(() =&gt; &#123;
    reject(2);
  &#125;, 2000);
&#125;);
&gt;
p2.catch((err) =&gt; &#123;
  console.log(&quot;p2状态改变&quot;);
&#125;);
&gt;
const p3 = new Promise((resolve, reject) =&gt; &#123;
  setTimeout(() =&gt; &#123;
    resolve(3);
  &#125;, 3000);
&#125;);
&gt;
p3.then((err) =&gt; &#123;
  console.log(&quot;p3状态改变&quot;);
&#125;);
&gt;
const p = Promise.allSettled([p1, p2, p3]);
&gt;
p.then((data) =&gt; &#123;
  console.log(data);
&#125;);
</code></pre>
<blockquote>
<img src="Promise.allSettled方法.png">
</blockquote>
<ol start="6">
<li>Promise.any() 方法<blockquote>
<p>Promise.any 用于关注多个 Promise 对象状态的改变</p>
<ul>
<li>只要<strong>其中有一个</strong> Promise 的状态变为 fulfilled，则这个方法返回的 Promise 对象的状态就变立马变为 fulfilled，其返回值为首个状态变为 fulfilledPromise 的返回值。</li>
<li>如果<strong>所有</strong> Promise 的状态都变为了 rejected,则这个方法返回的 Promise 对象的状态变为 rejected 的。其返回值为 <code>AggregateError</code> 实例，这是<code>Error</code>的子类，用于把单一的错误集合在一起。<blockquote>
<p>他主要用于多个 Promise 中最先成功的那一个。不过 <code>Promise.any</code> 方法还是一个实验性，<strong>并不被所有浏览器支持</strong>。</p>
</blockquote>
</li>
</ul>
</blockquote>
</li>
</ol>
<ul>
<li>代码演示一</li>
</ul>
<pre><code>const p1 = new Promise((resolve, reject) =&gt; &#123;
  setTimeout(() =&gt; &#123;
    reject(1);
  &#125;, 1000);
&#125;);
p1.catch(() =&gt; &#123;
  console.log(&quot;p1失败&quot;);
&#125;);
&gt;
const p2 = new Promise((resolve, reject) =&gt; &#123;
  setTimeout(() =&gt; &#123;
    resolve(2);
  &#125;, 2000);
&#125;);
&gt;
p2.then((data) =&gt; &#123;
  console.log(&quot;p2成功&quot;);
&#125;);
&gt;
const p3 = new Promise((resolve, reject) =&gt; &#123;
  setTimeout(() =&gt; &#123;
    resolve(3);
  &#125;, 3000);
&#125;);
&gt;
p3.then((data) =&gt; &#123;
  console.log(&quot;p3成功&quot;);
&#125;);
&gt;
const p = Promise.any([p1, p2, p3]);
p.then((data) =&gt; &#123;
  console.log(&quot;p成功&quot;, data);
&#125;).catch((err) =&gt; &#123;
  console.log(&quot;p失败&quot;, err);
&#125;);
</code></pre>
<blockquote>
<blockquote>
<p>代码解析：</p>
</blockquote>
<ul>
<li>1s 后 p1 的状态变为失败，调用 catch 方法，打印：”p1 失败“</li>
<li>2s 后 p2 的状态变为成功，调用 then 方法，打印：”p2 成功“</li>
<li>因为 p2 状态为成功，所以 p 的状态马上变为成功，并调用 then 方法，打印：”p 成功 2“</li>
<li>3s 后 p3 的状态变为成功，调用 then 方法，打印：”p3 成功“<br><strong>注意：</strong></li>
<li>只要 p1,p2,p3 中有一个成功，则 p 的状态就变为成功，同时他的状态并不影其它 Promis 的正常执行。</li>
</ul>
</blockquote>
<ul>
<li>代码演示二：</li>
</ul>
<pre><code>const p1 = new Promise((resolve, reject) =&gt; &#123;
  setTimeout(() =&gt; &#123;
    reject(1);
  &#125;, 1000);
&#125;);
p1.catch((err) =&gt; &#123;
  console.log(&quot;p1失败&quot;);
&#125;);
&gt;
const p2 = new Promise((resolve, reject) =&gt; &#123;
  setTimeout(() =&gt; &#123;
    reject(2);
  &#125;, 2000);
&#125;);
&gt;
p2.catch((err) =&gt; &#123;
  console.log(&quot;p2失败&quot;);
&#125;);
&gt;
const p3 = new Promise((resolve, reject) =&gt; &#123;
  setTimeout(() =&gt; &#123;
    reject(3);
  &#125;, 3000);
&#125;);
&gt;
p3.catch((err) =&gt; &#123;
  console.log(&quot;p3失败&quot;);
&#125;);
&gt;
const p = Promise.any([p1, p2, p3]);
console.log(p);
p.then((data) =&gt; &#123;
  console.log(&quot;p成功&quot;, data);
&#125;).catch((err) =&gt; &#123;
  console.log(&quot;p失败&quot;, err);
&#125;);
</code></pre>
<blockquote>
<ul>
<li>因为 p1,p2,p3 都为失败，所以 p 为失败<img src="Promise.any方法.png"></li>
</ul>
</blockquote>
<blockquote>
<blockquote>
<p>注意：当传入的对象为空时</p>
</blockquote>
<ul>
<li>all、allSettled的状态是<code>fullfilled</code>会返回空数组</li>
<li>any的状态是<code>rejected</code>，会返回AggregateError实例，它的子类里面是<code>[]</code></li>
<li>race的状态是<code>pendding</code>，不会返回任何值</li>
</ul>
</blockquote>
<pre><code>const p = Promise.race([]);
p.then((data) =&gt; &#123;
  console.log(&quot;p成功&quot;, data);
&#125;).catch((err) =&gt; &#123;
  console.log(&quot;p失败&quot;, err);
&#125;);
//any方法：p失败 AggregateError: All promises were rejected
//all方法：p成功 []
//allSettled：p成功 []
//race方法：空
</code></pre>
<ol start="7">
<li>经典面试题<blockquote>
<p>定义一个方法，方法传入一个参数，参数的类型只要是 <code>iterable</code>就行，这个方法用来</p>
<ul>
<li>①、返回物理上第一个成功的<code>promise</code>的结果</li>
<li>②、若全部为失败，则返回物理上最后一个<code>promise</code>的结果</li>
</ul>
</blockquote>
</li>
</ol>
<blockquote>
<p><strong>解题思路</strong></p>
<ul>
<li>定义的方法返回一个<code>promise</code>对象，然后在<code>promise</code>中遍历传入的<code>iterable</code>对象，如果其成员中有一个是成功的，就改变<code>promise</code>的状态，状态一旦改变就不可逆。</li>
<li>如果成员是失败的就记录失败的个数，当失败的个数与<code>iterable</code>成员个数相同时，则这个失败的成员就是最后一个失败的成员，调用<code>reject()</code>方法，改变<code>promise</code>对象的状态，然后将最后一个失败的<code>promise</code>返回值传入。</li>
</ul>
</blockquote>
<blockquote>
<p><strong>具体实现细节：</strong></p>
</blockquote>
<ul>
<li><p>定义两个变量<code>rejectTimes</code>和<code>length</code></p>
<blockquote>
<ul>
<li><code>rejectTimes</code>变量：用来记录失败的<code>promise</code>个数</li>
<li><code>length</code>变量：用来记录参数<code>iterable</code>的迭代成员个数</li>
</ul>
</blockquote>
</li>
<li><p>判断参数类型</p>
<blockquote>
<ul>
<li>如果参数<code>iterable</code>为空、null、undefined，就调用<code>reject</code>报错：<code>iterable==null</code>，注意是两个等号</li>
<li>如果参数<code>iterable</code>不是迭代器对象或可迭代对象，就调用<code>reject</code>报错<blockquote>
<p>怎么判断是否为迭代器对象或可迭代对象</p>
</blockquote>
</li>
<li>用鸭子类型检测(长得像)，并不严格满足迭代器协议和可迭代协议</li>
<li><code> typeof iterable.next !== &quot;function&quot; &amp;&amp;typeof iterable[Symbol.iterator] !== &quot;function&quot;</code></li>
</ul>
</blockquote>
</li>
<li><p>利用<code>for...of</code>来遍历<code>iterable</code>，</p>
<blockquote>
<ul>
<li>遍历过程中 <code>length++</code>，用来记录参数<code>iterable</code>的迭代成员个数</li>
<li>遍历中要判断遍历的成员类型，如果不是<code>promise</code>对象，则直接调用<code>resolve</code>,并将成员作为<code>resolve</code>的参数<ul>
<li>判断是否为<code>promise</code>对象：<code>p instanceof Promise</code></li>
</ul>
</li>
<li>如果是<code>promise</code>对象，则给遍历成员添加 <code>then</code> 和 <code>catch</code> 方法，<code>then</code> 中直接调用<code>resolve(data)</code>。<code>catch</code> 方法中将遍历 <code>rejectTimes++</code>，然后判断，如果<code>if(rejectTimes === length)</code>说明所有的<code>promise</code>都是失败的，则将最后一次的失败的<code>promise</code>返回值传入<code>reject()</code>中<blockquote>
<p><code>length++</code>在<code>for...of</code>里面，它属于同步代码，而<code>then</code>方法属于异步代码；所以在<code>rejectTimes++</code>前，他就能得到所有成员个数；只有异步代码全部执行完，才可能满足<code>length === rejectTimes</code></p>
</blockquote>
</li>
<li>注意特殊情况，就是<code>iterable</code>中没有一个成员，如果 <code>length === 0</code>，就说明<code>iterable</code>中没有一个成员，则调用<code>reject()</code>方法。</li>
</ul>
</blockquote>
</li>
</ul>
<pre><code>Promise._any = function (iterable) &#123;
  let rejectTimes = 0; // 用来记录失败的个数
  let length = 0; // 有来记录迭代器成员个数
  return new Promise((resolve, reject) =&gt; &#123;
    // 判断是否传值或传值为null
    if (iterable == null) &#123;
      return reject(new TypeError(`$&#123;iterable&#125; is not iterable`));
    &#125;
    // 判断传的成员是否是迭代器对象或可迭代成员，不是，则调用reject
    if (
      typeof iterable.next !== &quot;function&quot; &amp;&amp;
      typeof iterable[Symbol.iterator] !== &quot;function&quot;
    ) &#123;
      return reject(new TypeError(`$&#123;iterable&#125; is not iterable`));
    &#125;
&gt;
    // 对iterable进行for遍历
    for (let v of iterable) &#123;
      length++; // 同步代码
      // 判断其类型是否为Promise
      if (v instanceof Promise) &#123;
        v.then((data) =&gt; &#123;
          resolve(data);
        &#125;).catch((err) =&gt; &#123;
          rejectTimes++; // 异步中代码
          // 如果 length===rejectTimes，说明所有Promise都失败了
          if (length === rejectTimes) &#123;
            reject(err);
          &#125;
        &#125;);
      &#125; else &#123;
        resolve(v);//一般类型都是成功态
      &#125;
    &#125;
    // 判断传过的迭代对象中成员是否为空，如果为空，直接reject
    if (length === 0) &#123;
      reject(new Error(&quot;AggregateError: All promises were rejected&quot;));
    &#125;
  &#125;);
&#125;;
&gt;
// 应用
Promise._any([1, 2])
  .then((data) =&gt; &#123;
    console.log(data); // 1
  &#125;)
  .catch((err) =&gt; &#123;
    console.log(err);
  &#125;);
&gt;
Promise._any([Promise.reject(33), 2])
  .then((data) =&gt; &#123;
    console.log(data); // 2
  &#125;)
  .catch((err) =&gt; &#123;
    console.log(err);
  &#125;);
&gt;
Promise._any([Promise.reject(33), Promise.reject(44)])
  .then((data) =&gt; &#123;
    console.log(data);
  &#125;)
  .catch((err) =&gt; &#123;
    console.log(err); // 44
  &#125;);
</code></pre>
<h3 id="六、总结"><a href="#六、总结" class="headerlink" title="六、总结"></a>六、总结</h3><ol>
<li><p>认识 Promise</p>
<blockquote>
<p>Promise 是什么 ？</p>
<ul>
<li>Promise 是异步操作的一种解决方案</li>
<li>Promise 一般用来解决层层嵌套的回调函数的问题（回调地狱）</li>
<li>Promise 解决的不是回调函数，而是回调地狱</li>
</ul>
</blockquote>
</li>
<li><p>Promise 3 种状态</p>
<blockquote>
<ul>
<li>pending （未完成）</li>
<li>resolved&#x2F;fulfilled（已成功）</li>
<li>rejected（已失败）<br><strong>状态转换</strong></li>
<li>只有从 pending（未完成）转到 resolved&#x2F;fulfilled（已成功）</li>
<li>或 pending（未完成）转到 rejected（已失败）<blockquote>
<p>Promise 状态一旦变化，就不会再改变了。</p>
</blockquote>
</li>
</ul>
</blockquote>
</li>
<li><p>Promise 的基本用法</p>
</li>
</ol>
<pre><code>const p = new Promise((resolve, reject) =&gt; &#123;
  return resolve(&quot;成功 ！&quot;);
  return reject(new Error(&quot;失败&quot;));
&#125;).then(
  (data) =&gt; &#123;&#125;,
  (err) =&gt; &#123;&#125;
);
</code></pre>
<blockquote>
<p><strong>以上代码解读</strong>：</p>
<ul>
<li>使用 Promise 时，用的不是它的构造函数，而是实例化的构造函数生成的 Promise 对象</li>
<li>在实例化的过程中，构造函数中传的是一个回调函数，该回调函数有两个参数，resolve 和 reject</li>
<li>resolve 调用后，状态由 pending（未完成）转为 esolved&#x2F;fulfilled（已成功）状态。状态改变后：成功态，执行 then 的第一个回调函数</li>
<li>reject 调用后，状态由 pending （未完成）转为 rejected（已失败）。状态改变后：失败态，执行 then 的第二个回调函数</li>
</ul>
</blockquote>
<blockquote>
<blockquote>
<p><strong>注：</strong></p>
</blockquote>
<ul>
<li>resolve 和 reject 在调用的时候，是可以传递参数的，这个参数会在 then 方法中接收到。我们建议在调用 resolve 和 reject 时，直接通过 return 返回，这样即使后边还有代码也不会被执行</li>
<li>因此，我们推荐在调用 resolve 和 reject 函数的时候加上 <code>return</code></li>
</ul>
</blockquote>
<ol start="4">
<li>Promise 的实例方法<blockquote>
<p><code>then()</code> 方法</p>
<ul>
<li>pending -&gt; resolved 时，执行 then 的第一个回调函数</li>
<li>pending -&gt; rejected 时，执行 then 的第二个回调函数</li>
<li>状态不改变，then() 的回调函数都不会被执行</li>
<li>then() 执行后返回一个新的 Promise 对象</li>
<li>可以通过 return 语句 改变返回的 Promise 对象的状态，默认情况下都是成功状态</li>
<li>then() 方法是可以向后传值的</li>
</ul>
</blockquote>
</li>
</ol>
<blockquote>
<p><code>catch()</code> 方法</p>
<ul>
<li>catch 专门用来处理 rejected 失败状态</li>
<li>catch 本质上是 <code>then</code> 的<strong>特例</strong></li>
<li>建议 Promise 对象后面要跟 catch 方法，这样可以处理 Promise 内部发生的错误<br><strong>注</strong>：</li>
<li>catch默认返回一个<strong>成功的</strong> Promise 对象，其回调函的返回值会向下传递给下一个 then 或 catch 方法的回调函数的参数</li>
<li>如果 catch 方法前没有错误，就不会执行 catch 方法，其会自动被忽略</li>
<li>catch 是可以捕获错误信息的，当前的错误只要没有被前面的 catch 或 then 的第二个回调所捕获的，错误是一直会传递下去的，不会消失，直到被某一个 catch 或 then 的回调捕获之后，后边就没有错误了。</li>
</ul>
</blockquote>
<blockquote>
<p><code>finally()</code> 方法</p>
<ul>
<li>当 Promise 状态发生变化时，不论如何变化都会执行</li>
<li>finally() 本质上是 then() 的特例</li>
</ul>
</blockquote>
<ol start="5">
<li>Promise 的构造函数方法<blockquote>
<p><code>Promise.resolve()</code> 方法</p>
<ul>
<li>本质是成功状态 Promise 的一种简写形式</li>
<li>它会改变<code>Promise</code>的状态</li>
</ul>
</blockquote>
</li>
</ol>
<pre><code>new Promise((resolve) =&gt; resolve(&quot;成功&quot;));
// 等价于
Promise.resolve(&quot;成功&quot;);
</code></pre>
<blockquote>
<p><code>Promise.resolve()</code> 的参数</p>
<ul>
<li>参数是 Promise 实例对象时，<strong>直接返回这个 Promise 对象</strong></li>
<li>参数是具有 then 方法的对象时，会立即执行它的 then 方法</li>
<li>参数是其他值时，相当于通过 resolve 函数传参</li>
</ul>
</blockquote>
<blockquote>
<p><code>Promise.reject()</code>方法</p>
<ul>
<li>本质是失败状态 Promise 的一种简写形式</li>
<li>它会改变<code>Promise</code>的状态，<strong>并抛错</strong></li>
</ul>
</blockquote>
<pre><code>new Promise((resolve, reject) =&gt; reject(&quot;失败 ！&quot;));
// 等价于
Promise.reject(&quot;失败 ！&quot;);
</code></pre>
<blockquote>
<blockquote>
<p>不管什么参数，都会原封不动的向后传递，作为后续方法的参数</p>
</blockquote>
</blockquote>
<blockquote>
<p><code>Promise.all、race、allSettled()</code>方法</p>
<ul>
<li>只要是可遍历的，都可作为参数</li>
<li>参数的 “集合” 中若有成员不是 Promise 对象，内部会将其转变为 Promise 对象</li>
<li>返回一个新的 Promise 实例对象</li>
</ul>
</blockquote>
<blockquote>
<p><code>Promise.all()</code>方法</p>
<ul>
<li>所有状态都变成 resolved 成功时，最终的状态才会变成 resolved 成功</li>
<li>只要有一个变成 rejected 失败时，最终的状态就会变成 rejected 失败</li>
</ul>
</blockquote>
<blockquote>
<p><code>Promise.race()</code>方法</p>
<ul>
<li>最终的状态取决于第一个完成的 Promise 实例对象</li>
<li>如果第一个完成的成功了，那最终的就成功</li>
</ul>
</blockquote>
<blockquote>
<p><code>Promise.allSettled()</code>方法</p>
<ul>
<li>最终的状态永远都是成功的，与传入的 Promise 对象状态无关</li>
<li>会记录下各个 Promise 的表现</li>
</ul>
</blockquote>

                
            </div>
            <hr/>

            

    <div class="reprint" id="reprint-statement">
        
            <div class="reprint__author">
                <span class="reprint-meta" style="font-weight: bold;">
                    <i class="fas fa-user">
                        文章作者:
                    </i>
                </span>
                <span class="reprint-info">
                    <a href="/about" rel="external nofollow noreferrer">hermia</a>
                </span>
            </div>
            <div class="reprint__type">
                <span class="reprint-meta" style="font-weight: bold;">
                    <i class="fas fa-link">
                        文章链接:
                    </i>
                </span>
                <span class="reprint-info">
                    <a href="https://hermiablog.com/2023/12/12/JS%E6%A0%B8%E5%BF%83%E7%9F%A5%E8%AF%86%E7%82%B9%EF%BC%88%E4%BA%8C%E5%8D%81%E4%B8%89%EF%BC%89/">https://hermiablog.com/2023/12/12/JS%E6%A0%B8%E5%BF%83%E7%9F%A5%E8%AF%86%E7%82%B9%EF%BC%88%E4%BA%8C%E5%8D%81%E4%B8%89%EF%BC%89/</a>
                </span>
            </div>
            <div class="reprint__notice">
                <span class="reprint-meta" style="font-weight: bold;">
                    <i class="fas fa-copyright">
                        版权声明:
                    </i>
                </span>
                <span class="reprint-info">
                    本博客所有文章除特別声明外，均采用
                    <a href="https://creativecommons.org/licenses/by/4.0/deed.zh" rel="external nofollow noreferrer" target="_blank">CC BY 4.0</a>
                    许可协议。转载请注明来源
                    <a href="/about" target="_blank">hermia</a>
                    !
                </span>
            </div>
        
    </div>

    <script async defer>
      document.addEventListener("copy", function (e) {
        let toastHTML = '<span>复制成功，请遵循本文的转载规则</span><button class="btn-flat toast-action" onclick="navToReprintStatement()" style="font-size: smaller">查看</a>';
        M.toast({html: toastHTML})
      });

      function navToReprintStatement() {
        $("html, body").animate({scrollTop: $("#reprint-statement").offset().top - 80}, 800);
      }
    </script>



            <div class="tag_share" style="display: block;">
                <div class="post-meta__tag-list" style="display: inline-block;">
                    
                        <div class="article-tag">
                            
                                <a href="/tags/JS/">
                                    <span class="chip bg-color">JS</span>
                                </a>
                            
                        </div>
                    
                </div>
                <div class="post_share" style="zoom: 80%; width: fit-content; display: inline-block; float: right; margin: -0.15rem 0;">
                    <link rel="stylesheet" type="text/css" href="/libs/share/css/share.min.css">
<div id="article-share">

    
    <div class="social-share" data-sites="qq,qzone,wechat,weibo" data-wechat-qrcode-helper="<p>微信扫一扫即可分享！</p>"></div>
    <script src="/libs/share/js/social-share.min.js"></script>
    

    

</div>

                </div>
            </div>
            
                <style>
    #reward {
        margin: 40px 0;
        text-align: center;
    }

    #reward .reward-link {
        font-size: 1.4rem;
        line-height: 38px;
    }

    #reward .btn-floating:hover {
        box-shadow: 0 6px 12px rgba(0, 0, 0, 0.2), 0 5px 15px rgba(0, 0, 0, 0.2);
    }

    #rewardModal {
        width: 320px;
        height: 350px;
    }

    #rewardModal .reward-title {
        margin: 15px auto;
        padding-bottom: 5px;
    }

    #rewardModal .modal-content {
        padding: 10px;
    }

    #rewardModal .close {
        position: absolute;
        right: 15px;
        top: 15px;
        color: rgba(0, 0, 0, 0.5);
        font-size: 1.3rem;
        line-height: 20px;
        cursor: pointer;
    }

    #rewardModal .close:hover {
        color: #ef5350;
        transform: scale(1.3);
        -moz-transform:scale(1.3);
        -webkit-transform:scale(1.3);
        -o-transform:scale(1.3);
    }

    #rewardModal .reward-tabs {
        margin: 0 auto;
        width: 210px;
    }

    .reward-tabs .tabs {
        height: 38px;
        margin: 10px auto;
        padding-left: 0;
    }

    .reward-content ul {
        padding-left: 0 !important;
    }

    .reward-tabs .tabs .tab {
        height: 38px;
        line-height: 38px;
    }

    .reward-tabs .tab a {
        color: #fff;
        background-color: #ccc;
    }

    .reward-tabs .tab a:hover {
        background-color: #ccc;
        color: #fff;
    }

    .reward-tabs .wechat-tab .active {
        color: #fff !important;
        background-color: #22AB38 !important;
    }

    .reward-tabs .alipay-tab .active {
        color: #fff !important;
        background-color: #019FE8 !important;
    }

    .reward-tabs .reward-img {
        width: 210px;
        height: 210px;
    }
</style>

<div id="reward">
    <a href="#rewardModal" class="reward-link modal-trigger btn-floating btn-medium waves-effect waves-light red">赏</a>

    <!-- Modal Structure -->
    <div id="rewardModal" class="modal">
        <div class="modal-content">
            <a class="close modal-close"><i class="fas fa-times"></i></a>
            <h4 class="reward-title">你的赏识是我前进的动力</h4>
            <div class="reward-content">
                <div class="reward-tabs">
                    <ul class="tabs row">
                        <li class="tab col s6 alipay-tab waves-effect waves-light"><a href="#alipay">支付宝</a></li>
                        <li class="tab col s6 wechat-tab waves-effect waves-light"><a href="#wechat">微 信</a></li>
                    </ul>
                    <div id="alipay">
                        <img src="/medias/reward/alipay.jpg" class="reward-img" alt="支付宝打赏二维码">
                    </div>
                    <div id="wechat">
                        <img src="/medias/reward/wechat.png" class="reward-img" alt="微信打赏二维码">
                    </div>
                </div>
            </div>
        </div>
    </div>
</div>

<script>
    $(function () {
        $('.tabs').tabs();
    });
</script>

            
        </div>
    </div>

    

    

    

    

    

    

    

    

<article id="prenext-posts" class="prev-next articles">
    <div class="row article-row">
        
        <div class="article col s12 m6" data-aos="fade-up">
            <div class="article-badge left-badge text-color">
                <i class="fas fa-chevron-left"></i>&nbsp;上一篇</div>
            <div class="card">
                <a href="/2023/12/14/JS%E6%A0%B8%E5%BF%83%E7%9F%A5%E8%AF%86%E7%82%B9%EF%BC%88%E4%BA%8C%E5%8D%81%E5%9B%9B%EF%BC%89/">
                    <div class="card-image">
                        
                        <img src="/medias/featureimages/36.jpg" class="responsive-img" alt="JS核心知识点（二十四）">
                        
                        <span class="card-title">JS核心知识点（二十四）</span>
                    </div>
                </a>
                <div class="card-content article-content">
                    <div class="summary block-with-text">
                        
                            Module模块系统、ES6Proxy 代理 与 Reflect反射
                        
                    </div>
                    <div class="publish-info">
                        <span class="publish-date">
                            <i class="far fa-clock fa-fw icon-date"></i>2023-12-14
                        </span>
                        <span class="publish-author">
                            
                            <i class="fas fa-bookmark fa-fw icon-category"></i>
                            
                            <a href="/categories/%E6%8A%80%E6%9C%AF/" class="post-category">
                                    技术
                                </a>
                            
                            
                        </span>
                    </div>
                </div>
                
                <div class="card-action article-tags">
                    
                    <a href="/tags/JS/">
                        <span class="chip bg-color">JS</span>
                    </a>
                    
                </div>
                
            </div>
        </div>
        
        
        <div class="article col s12 m6" data-aos="fade-up">
            <div class="article-badge right-badge text-color">
                下一篇&nbsp;<i class="fas fa-chevron-right"></i>
            </div>
            <div class="card">
                <a href="/2023/12/12/JS%E6%A0%B8%E5%BF%83%E7%9F%A5%E8%AF%86%E7%82%B9%EF%BC%88%E4%BA%8C%E5%8D%81%E4%BA%8C%EF%BC%89/">
                    <div class="card-image">
                        
                        <img src="/medias/featureimages/34.jpg" class="responsive-img" alt="JS核心知识点（二十二）">
                        
                        <span class="card-title">JS核心知识点（二十二）</span>
                    </div>
                </a>
                <div class="card-content article-content">
                    <div class="summary block-with-text">
                        
                            迭代器模式、Iterator 遍历器、for...of循环、ES6字符串数组对象新增方法
                        
                    </div>
                    <div class="publish-info">
                            <span class="publish-date">
                                <i class="far fa-clock fa-fw icon-date"></i>2023-12-12
                            </span>
                        <span class="publish-author">
                            
                            <i class="fas fa-bookmark fa-fw icon-category"></i>
                            
                            <a href="/categories/%E6%8A%80%E6%9C%AF/" class="post-category">
                                    技术
                                </a>
                            
                            
                        </span>
                    </div>
                </div>
                
                <div class="card-action article-tags">
                    
                    <a href="/tags/JS/">
                        <span class="chip bg-color">JS</span>
                    </a>
                    
                </div>
                
            </div>
        </div>
        
    </div>
</article>

</div>



<!-- 代码块功能依赖 -->
<script type="text/javascript" src="/libs/codeBlock/codeBlockFuction.js"></script>

<!-- 代码语言 -->

<script type="text/javascript" src="/libs/codeBlock/codeLang.js"></script>


<!-- 代码块复制 -->

<script type="text/javascript" src="/libs/codeBlock/codeCopy.js"></script>


<!-- 代码块收缩 -->

<script type="text/javascript" src="/libs/codeBlock/codeShrink.js"></script>


  </div>
  <div id="toc-aside" class="expanded col l3 hide-on-med-and-down">
    <div class="toc-widget card" style="background-color: white">
      <div class="toc-title">
        <i class="far fa-list-alt"></i>&nbsp;&nbsp;目录
      </div>
      <div id="toc-content"></div>
    </div>
  </div>
</div>

<!-- TOC 悬浮按钮. -->

<div id="floating-toc-btn" class="hide-on-med-and-down">
  <a class="btn-floating btn-large bg-color">
    <i class="fas fa-list-ul"></i>
  </a>
</div>


<script src="/libs/tocbot/tocbot.min.js"></script>
<script>
  $(function () {
      tocbot.init({
          tocSelector: '#toc-content',
          contentSelector: '#articleContent',
          headingsOffset: -($(window).height() * 0.4 - 45),
          collapseDepth: Number('0'),
          headingSelector: 'h2, h3, h4'
      });

      // modify the toc link href to support Chinese.
      let i = 0;
      let tocHeading = 'toc-heading-';
      $('#toc-content a').each(function () {
          $(this).attr('href', '#' + tocHeading + (++i));
      });

      // modify the heading title id to support Chinese.
      i = 0;
      $('#articleContent').children('h2, h3, h4').each(function () {
          $(this).attr('id', tocHeading + (++i));
      });

      // Set scroll toc fixed.
      let tocHeight = parseInt($(window).height() * 0.4 - 64);
      let $tocWidget = $('.toc-widget');
      $(window).scroll(function () {
          let scroll = $(window).scrollTop();
          /* add post toc fixed. */
          if (scroll > tocHeight) {
              $tocWidget.addClass('toc-fixed');
          } else {
              $tocWidget.removeClass('toc-fixed');
          }
      });

      
      /* 修复文章卡片 div 的宽度. */
      let fixPostCardWidth = function (srcId, targetId) {
          let srcDiv = $('#' + srcId);
          if (srcDiv.length === 0) {
              return;
          }

          let w = srcDiv.width();
          if (w >= 450) {
              w = w + 21;
          } else if (w >= 350 && w < 450) {
              w = w + 18;
          } else if (w >= 300 && w < 350) {
              w = w + 16;
          } else {
              w = w + 14;
          }
          $('#' + targetId).width(w);
      };

      // 切换TOC目录展开收缩的相关操作.
      const expandedClass = 'expanded';
      let $tocAside = $('#toc-aside');
      let $mainContent = $('#main-content');
      $('#floating-toc-btn .btn-floating').click(function () {
          if ($tocAside.hasClass(expandedClass)) {
              $tocAside.removeClass(expandedClass).hide();
              $mainContent.removeClass('l9');
          } else {
              $tocAside.addClass(expandedClass).show();
              $mainContent.addClass('l9');
          }
          fixPostCardWidth('artDetail', 'prenext-posts');
      });
      
  });
</script>

    

</main>




    <footer class="page-footer bg-color">
   <link rel="stylesheet" href="/libs/aplayer/APlayer.min.css">
<style>
    .aplayer .aplayer-lrc p {
        
        font-size: 12px;
        font-weight: 700;
        line-height: 16px !important;
    }

    .aplayer .aplayer-lrc p.aplayer-lrc-current {
        
        font-size: 15px;
        color: #a3ddf0;
        /* color: #59cde9; */
    }

    
    .aplayer.aplayer-fixed.aplayer-narrow .aplayer-body {
        left: -66px !important;
    }

    .aplayer.aplayer-fixed.aplayer-narrow .aplayer-body:hover {
        left: 0px !important;
    }

    
</style>
<div class="">
    
    <div class="row">
        <meting-js class="col l8 offset-l2 m10 offset-m1 s12"
                   server="netease"
                   type="playlist"
                   id="2450546498"
                   fixed='true'
                   autoplay='false'
                   theme='#59cde9'
                   loop='all'
                   order='random'
                   preload='auto'
                   volume='0.7'
                   list-folded='true'
        >
        </meting-js>
    </div>
</div>

<script src="/libs/aplayer/APlayer.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/meting@2/dist/Meting.min.js"></script>
 
  <div
    class="container row center-align"
    style="margin-bottom: 15px !important;"
  >
    <div class="col s12 m8 l8 copy-right">
      Copyright&nbsp;&copy; 
      <span id="year"
        >2023-2024</span
      >
      
      <span id="year">2023</span>
      <a href="/about" target="_blank"
        >hermia</a
      >
      |&nbsp;Powered by&nbsp;<a href="https://hexo.io/" target="_blank">Hexo</a>
      |&nbsp;Theme&nbsp;<a
        href="https://github.com/blinkfox/hexo-theme-matery"
        target="_blank"
        >Matery</a
      >
      <br />
           
      <span id="busuanzi_container_site_pv">
        |&nbsp;<i class="far fa-eye"></i>&nbsp;总访问量:&nbsp;<span
          id="busuanzi_value_site_pv"
          class="white-color"
        ></span
        >&nbsp;次
      </span>
       
      <span id="busuanzi_container_site_uv">
        |&nbsp;<i class="fas fa-users"></i>&nbsp;总访问人数:&nbsp;<span
          id="busuanzi_value_site_uv"
          class="white-color"
        ></span
        >&nbsp;人
      </span>
      
      <br />
      
      <span id="sitetime">载入运行时间...</span>
      <script>
        function siteTime() {
          var seconds = 1000;
          var minutes = seconds * 60;
          var hours = minutes * 60;
          var days = hours * 24;
          var years = days * 365;
          var today = new Date();
          var startYear = "2023";
          var startMonth = "11";
          var startDate = "14";
          var startHour = "0";
          var startMinute = "0";
          var startSecond = "0";
          var todayYear = today.getFullYear();
          var todayMonth = today.getMonth() + 1;
          var todayDate = today.getDate();
          var todayHour = today.getHours();
          var todayMinute = today.getMinutes();
          var todaySecond = today.getSeconds();
          var t1 = Date.UTC(
            startYear,
            startMonth,
            startDate,
            startHour,
            startMinute,
            startSecond
          );
          var t2 = Date.UTC(
            todayYear,
            todayMonth,
            todayDate,
            todayHour,
            todayMinute,
            todaySecond
          );
          var diff = t2 - t1;
          var diffYears = Math.floor(diff / years);
          var diffDays = Math.floor(diff / days - diffYears * 365);
          var diffHours = Math.floor(
            (diff - (diffYears * 365 + diffDays) * days) / hours
          );
          var diffMinutes = Math.floor(
            (diff - (diffYears * 365 + diffDays) * days - diffHours * hours) /
              minutes
          );
          var diffSeconds = Math.floor(
            (diff -
              (diffYears * 365 + diffDays) * days -
              diffHours * hours -
              diffMinutes * minutes) /
              seconds
          );
          if (startYear == todayYear) {
            document.getElementById("year").innerHTML = todayYear;
            document.getElementById("sitetime").innerHTML =
              "本站已安全运行 " +
              diffDays +
              " 天 " +
              diffHours +
              " 小时 " +
              diffMinutes +
              " 分钟 " +
              diffSeconds +
              " 秒";
          } else {
            document.getElementById("year").innerHTML =
              startYear + " - " + todayYear;
            document.getElementById("sitetime").innerHTML =
              "本站已安全运行 " +
              diffYears +
              " 年 " +
              diffDays +
              " 天 " +
              diffHours +
              " 小时 " +
              diffMinutes +
              " 分钟 " +
              diffSeconds +
              " 秒";
          }
        }
        setInterval(siteTime, 1000);
      </script>
      
      <br />
      
    </div>
    <div class="col s12 m4 l4 social-link social-statis">
      
<a
  href="https://github.com/hermiablog/hermiablog.github.io"
  class="tooltipped"
  target="_blank"
  data-tooltip="访问我的GitHub"
  data-position="top"
  data-delay="50"
>
  <i class="fab fa-github"></i>
</a>
 
<a
  href="mailto:1587837237@qq.com"
  class="tooltipped"
  target="_blank"
  data-tooltip="邮件联系我"
  data-position="top"
  data-delay="50"
>
  <i class="fas fa-envelope-open"></i>
</a>
<!-- 
   
<a
  href="tencent://AddContact/?fromId=50&fromSubId=1&subcmd=all&uin=1587837237"
  class="tooltipped"
  target="_blank"
  data-tooltip="QQ联系我: 1587837237"
  data-position="top"
  data-delay="50"
>
  <i class="fab fa-qq"></i>
</a>
    -->

    </div>
  </div>
</footer>

<div class="progress-bar"></div>


    <!-- 搜索遮罩框 -->
<div id="searchModal" class="modal">
    <div class="modal-content">
        <div class="search-header">
            <span class="title"><i class="fas fa-search"></i>&nbsp;&nbsp;搜索</span>
            <input type="search" id="searchInput" name="s" placeholder="请输入搜索的关键字"
                   class="search-input">
        </div>
        <div id="searchResult"></div>
    </div>
</div>

<script type="text/javascript">
$(function () {
    var searchFunc = function (path, search_id, content_id) {
        'use strict';
        $.ajax({
            url: path,
            dataType: "xml",
            success: function (xmlResponse) {
                // get the contents from search data
                var datas = $("entry", xmlResponse).map(function () {
                    return {
                        title: $("title", this).text(),
                        content: $("content", this).text(),
                        url: $("url", this).text()
                    };
                }).get();
                var $input = document.getElementById(search_id);
                var $resultContent = document.getElementById(content_id);
                $input.addEventListener('input', function () {
                    var str = '<ul class=\"search-result-list\">';
                    var keywords = this.value.trim().toLowerCase().split(/[\s\-]+/);
                    $resultContent.innerHTML = "";
                    if (this.value.trim().length <= 0) {
                        return;
                    }
                    // perform local searching
                    datas.forEach(function (data) {
                        var isMatch = true;
                        var data_title = data.title.trim().toLowerCase();
                        var data_content = data.content.trim().replace(/<[^>]+>/g, "").toLowerCase();
                        var data_url = data.url;
                        data_url = data_url.indexOf('/') === 0 ? data.url : '/' + data_url;
                        var index_title = -1;
                        var index_content = -1;
                        var first_occur = -1;
                        // only match artiles with not empty titles and contents
                        if (data_title !== '' && data_content !== '') {
                            keywords.forEach(function (keyword, i) {
                                index_title = data_title.indexOf(keyword);
                                index_content = data_content.indexOf(keyword);
                                if (index_title < 0 && index_content < 0) {
                                    isMatch = false;
                                } else {
                                    if (index_content < 0) {
                                        index_content = 0;
                                    }
                                    if (i === 0) {
                                        first_occur = index_content;
                                    }
                                }
                            });
                        }
                        // show search results
                        if (isMatch) {
                            str += "<li><a href='" + data_url + "' class='search-result-title'>" + data_title + "</a>";
                            var content = data.content.trim().replace(/<[^>]+>/g, "");
                            if (first_occur >= 0) {
                                // cut out 100 characters
                                var start = first_occur - 20;
                                var end = first_occur + 80;
                                if (start < 0) {
                                    start = 0;
                                }
                                if (start === 0) {
                                    end = 100;
                                }
                                if (end > content.length) {
                                    end = content.length;
                                }
                                var match_content = content.substr(start, end);
                                // highlight all keywords
                                keywords.forEach(function (keyword) {
                                    var regS = new RegExp(keyword, "gi");
                                    match_content = match_content.replace(regS, "<em class=\"search-keyword\">" + keyword + "</em>");
                                });

                                str += "<p class=\"search-result\">" + match_content + "...</p>"
                            }
                            str += "</li>";
                        }
                    });
                    str += "</ul>";
                    $resultContent.innerHTML = str;
                });
            }
        });
    };

    searchFunc('/search.xml', 'searchInput', 'searchResult');
});
</script>

    <!-- 回到顶部按钮 -->
<div id="backTop" class="top-scroll">
    <a class="btn-floating btn-large waves-effect waves-light" href="#!">
        <i class="fas fa-arrow-up"></i>
    </a>
</div>


    <script src="/libs/materialize/materialize.min.js"></script>
    <script src="/libs/masonry/masonry.pkgd.min.js"></script>
    <script src="/libs/aos/aos.js"></script>
    <script src="/libs/scrollprogress/scrollProgress.min.js"></script>
    <script src="/libs/lightGallery/js/lightgallery-all.min.js"></script>
    <script src="/js/matery.js"></script>

    <!-- Baidu Analytics -->

    <!-- Baidu Push -->

<script>
    (function () {
        var bp = document.createElement('script');
        var curProtocol = window.location.protocol.split(':')[0];
        if (curProtocol === 'https') {
            bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';
        } else {
            bp.src = 'http://push.zhanzhang.baidu.com/push.js';
        }
        var s = document.getElementsByTagName("script")[0];
        s.parentNode.insertBefore(bp, s);
    })();
</script>

    
    <script src="/libs/others/clicklove.js" async="async"></script>
    
    
    <script async src="/libs/others/busuanzi.pure.mini.js"></script>
    

    

    

	
    

    

    

    
    <script src="/libs/instantpage/instantpage.js" type="module"></script>
    

</body>

</html>
