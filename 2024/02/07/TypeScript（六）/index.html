<!DOCTYPE HTML>
<html lang="zh-CN">


<head>
    <meta charset="utf-8">
    <meta name="keywords" content="TypeScript（六）, 技术博客">
    <meta name="description" content="个人技术博客">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <meta name="renderer" content="webkit|ie-stand|ie-comp">
    <meta name="mobile-web-app-capable" content="yes">
    <meta name="format-detection" content="telephone=no">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <!-- Global site tag (gtag.js) - Google Analytics -->


    <title>TypeScript（六） | hermia&#39;s blog</title>
    <link rel="icon" type="image/png" href="/favicon.png">

    <link rel="stylesheet" type="text/css" href="/libs/awesome/css/all.css">
    <link rel="stylesheet" type="text/css" href="/libs/materialize/materialize.min.css">
    <link rel="stylesheet" type="text/css" href="/libs/aos/aos.css">
    <link rel="stylesheet" type="text/css" href="/libs/animate/animate.min.css">
    <link rel="stylesheet" type="text/css" href="/libs/lightGallery/css/lightgallery.min.css">
    <link rel="stylesheet" type="text/css" href="/css/matery.css">
    <link rel="stylesheet" type="text/css" href="/css/my.css">

    <script src="/libs/jquery/jquery.min.js"></script>

<meta name="generator" content="Hexo 6.3.0"><link rel="stylesheet" href="/css/prism-tomorrow.css" type="text/css"></head>



   <style>
    body{
       background-image: url(https://cdn.pixabay.com/photo/2012/04/14/16/37/sky-34536_1280.png);
       background-repeat:no-repeat;
       background-size:cover;
       background-attachment:fixed;
    }
</style>



<body>
    <header class="navbar-fixed">
    <nav id="headNav" class="bg-color nav-transparent">
        <div id="navContainer" class="nav-wrapper container">
            <div class="brand-logo">
                <a href="/" class="waves-effect waves-light">
                    
                    <img src="/medias/logo.png" class="logo-img" alt="LOGO">
                    
                    <span class="logo-span">hermia&#39;s blog</span>
                </a>
            </div>
            

<a href="#" data-target="mobile-nav" class="sidenav-trigger button-collapse"><i class="fas fa-bars"></i></a>
<ul class="right nav-menu">
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/" class="waves-effect waves-light">
      
      <i class="fas fa-home" style="zoom: 0.6;"></i>
      
      <span>首页</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/tags" class="waves-effect waves-light">
      
      <i class="fas fa-tags" style="zoom: 0.6;"></i>
      
      <span>标签</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/categories" class="waves-effect waves-light">
      
      <i class="fas fa-bookmark" style="zoom: 0.6;"></i>
      
      <span>分类</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/archives" class="waves-effect waves-light">
      
      <i class="fas fa-archive" style="zoom: 0.6;"></i>
      
      <span>归档</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/about" class="waves-effect waves-light">
      
      <i class="fas fa-user-circle" style="zoom: 0.6;"></i>
      
      <span>关于</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/friends" class="waves-effect waves-light">
      
      <i class="fas fa-address-book" style="zoom: 0.6;"></i>
      
      <span>友情链接</span>
    </a>
    
  </li>
  
  <li>
    <a href="#searchModal" class="modal-trigger waves-effect waves-light">
      <i id="searchIcon" class="fas fa-search" title="搜索" style="zoom: 0.85;"></i>
    </a>
  </li>
</ul>


<div id="mobile-nav" class="side-nav sidenav">

    <div class="mobile-head bg-color">
        
        <img src="/medias/logo.png" class="logo-img circle responsive-img">
        
        <div class="logo-name">hermia&#39;s blog</div>
        <div class="logo-desc">
            
            个人技术博客
            
        </div>
    </div>

    

    <ul class="menu-list mobile-menu-list">
        
        <li class="m-nav-item">
	  
		<a href="/" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-home"></i>
			
			首页
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/tags" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-tags"></i>
			
			标签
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/categories" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-bookmark"></i>
			
			分类
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/archives" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-archive"></i>
			
			归档
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/about" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-user-circle"></i>
			
			关于
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/friends" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-address-book"></i>
			
			友情链接
		</a>
          
        </li>
        
        
    </ul>
</div>


        </div>

        
    </nav>

</header>

    



<div class="bg-cover pd-header post-cover" style="background-image: url('/medias/featureimages/57.jpg')">
    <div class="container" style="right: 0px;left: 0px;">
        <div class="row">
            <div class="col s12 m12 l12">
                <div class="brand">
                    <h1 class="description center-align post-title">TypeScript（六）</h1>
                </div>
            </div>
        </div>
    </div>
</div>




<main class="post-container content">

    
    <link
  rel="stylesheet"
  href="/libs/tocbot/tocbot.css"
/>
<style>
  #articleContent h1::before,
  #articleContent h2::before,
  #articleContent h3::before,
  #articleContent h4::before,
  #articleContent h5::before,
  #articleContent h6::before {
    display: block;
    content: " ";
    height: 100px;
    margin-top: -100px;
    visibility: hidden;
  }

  #articleContent :focus {
    outline: none;
  }

  .toc-fixed {
    position: fixed;
    top: 64px;
  }

  /* .toc-widget {
        width: 345px;
        padding-left: 20px;
    } */
  .toc-widget {
    width: 345px;
    padding-left: 20px;
    background-color: rgb(255, 255, 255, 0.7);
    border-radius: 10px;
    box-shadow: 0 10px 35px 2px rgba(0, 0, 0, 0.15),
      0 5px 15px rgba(0, 0, 0, 0.07), 0 2px 5px -5px rgba(0, 0, 0, 0.1) !important;
  }

  .toc-widget .toc-title {
    padding: 35px 0 15px 17px;
    font-size: 1.5rem;
    font-weight: bold;
    line-height: 1.5rem;
  }

  .toc-widget ol {
    padding: 0;
    list-style: none;
  }

  #toc-content {
    padding-bottom: 30px;
    overflow: auto;
  }

  #toc-content ol {
    padding-left: 10px;
  }

  #toc-content ol li {
    padding-left: 10px;
  }

  #toc-content .toc-link:hover {
    color: #a3ddf0;
    font-weight: 700;
    text-decoration: underline;
  }

  #toc-content .toc-link::before {
    background-color: transparent;
    max-height: 25px;

    position: absolute;
    right: 23.5vw;
    display: block;
  }

  #toc-content .is-active-link {
    color: #a3ddf0;
  }

  #floating-toc-btn {
    position: fixed;
    right: 15px;
    bottom: 76px;
    padding-top: 15px;
    margin-bottom: 0;
    z-index: 998;
  }

  #floating-toc-btn .btn-floating {
    width: 48px;
    height: 48px;
  }

  #floating-toc-btn .btn-floating i {
    line-height: 48px;
    font-size: 1.4rem;
  }
</style>
<div class="row">
  <div id="main-content" class="col s12 m12 l9">
    <!-- 文章内容详情 -->
<div id="artDetail">
    <div class="card">
        <div class="card-content article-info">
            <div class="row tag-cate">
                <div class="col s7">
                    
                    <div class="article-tag">
                        
                            <a href="/tags/TypesSript/">
                                <span class="chip bg-color">TypesSript</span>
                            </a>
                        
                    </div>
                    
                </div>
                <div class="col s5 right-align">
                    
                    <div class="post-cate">
                        <i class="fas fa-bookmark fa-fw icon-category"></i>
                        
                            <a href="/categories/%E6%8A%80%E6%9C%AF/" class="post-category">
                                技术
                            </a>
                        
                    </div>
                    
                </div>
            </div>

            <div class="post-info">
                
                <div class="post-date info-break-policy">
                    <i class="far fa-calendar-minus fa-fw"></i>发布日期:&nbsp;&nbsp;
                    2024-02-07
                </div>
                

                
                <div class="post-date info-break-policy">
                    <i class="far fa-calendar-check fa-fw"></i>更新日期:&nbsp;&nbsp;
                    2024-02-07
                </div>
                

                
                <div class="info-break-policy">
                    <i class="far fa-file-word fa-fw"></i>文章字数:&nbsp;&nbsp;
                    22k
                </div>
                

                

                
            </div>
        </div>
        <hr class="clearfix">

        

        

        <div class="card-content article-card-content">
            <div id="articleContent">
                <span id="more"></span>
<h3 id="一、模块"><a href="#一、模块" class="headerlink" title="一、模块"></a>一、模块</h3><blockquote>
<p>TypeScript 的模块，常用的两种方案：一种是 ES6 的模块，一种是 CommonJS 的模块</p>
</blockquote>
<h4 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h4><blockquote>
<p>任何包含<code>import</code>或<code>export</code>语句的文件，就是一个模块（module）。相应地，如果文件不包含<code>export</code>语句，就是一个全局的脚本文件。</p>
</blockquote>
<blockquote>
<p>模块本身就是一个作用域，不属于全局作用域。模块内部的变量、函数、类只在内部可见，对于模块外部是不可见的。暴露给外部的接口，必须用<code>export</code>命令声明；如果其他文件要使用模块的接口，必须用<code>import</code>命令来输入</p>
</blockquote>
<blockquote>
<p>如果一个文件不包含 export 语句，但是希望把它当作一个模块（即内部变量对外不可见），可以在脚本头部添加一行语句。</p>
</blockquote>
<pre><code>export &#123;&#125;;
</code></pre>
<ul>
<li>这行语句不产生任何实际作用，但会让当前文件被当作模块处理，所有它的代码都变成了内部代码</li>
</ul>
<blockquote>
<p>TypeScript 模块除了支持所有 ES 模块的语法，特别之处在于允许输出和输入类型。</p>
</blockquote>
<pre><code>export type Bool = true | false;
</code></pre>
<ul>
<li>当前脚本输出一个类型别名 Bool 。这行语句把类型定义和接口输出写在一行，也可以写成两行。</li>
</ul>
<blockquote>
<p>在 <code>/src/a.ts</code> 模块中导出类型别名<code>Bool</code></p>
</blockquote>
<pre><code>type Bool = true | false;

export &#123; Bool &#125;;
</code></pre>
<p>在 <code>/src/b.ts</code> 中使用 <code>import</code> 语句，输入这个类型</p>
<pre><code>import &#123; Bool &#125; from &quot;./a&quot;;

let foo: Bool = true;
</code></pre>
<ul>
<li>import 语句加载的是一个类型</li>
<li>注意，加载文件写成<code>./a</code>，没有写脚本文件的后缀名</li>
<li>TypeScript 允许加载模块时，省略模块文件的后缀名，它会自动定位，将 <code>./a</code> 定位到<code>./a.ts</code></li>
</ul>
<p>编译时，可以两个脚本同时编译。</p>
<pre><code>tsc a.ts b.ts

# 或

tsc

# tsc 命令会将 a.ts 和 b.ts 分别编译成 a.js 和 b.js
</code></pre>
<p>也可以只编译b.ts，因为它是入口脚本，tsc 会自动编译它依赖的所有脚本。</p>
<pre><code>tsc .\src\b.ts
</code></pre>
<ul>
<li>tsc 命令发现 <code>b.ts </code>依赖 <code>a.ts</code>，就会自动寻找 <code>a.ts</code>，也将其同时编译，因此编译产物还是 <code>a.js</code> 和 <code>b.js</code> 两个文件</li>
</ul>
<h4 id="import-type-语句"><a href="#import-type-语句" class="headerlink" title="import type 语句"></a>import type 语句</h4><blockquote>
<p>import 在一条语句中，可以同时输入类型和正常接口。<br>在 <code>/src/a.ts</code> 中</p>
</blockquote>
<pre><code>export interface A &#123;
  foo: string;
&#125;

export let a = 123;
</code></pre>
<p>在 &#x2F;src&#x2F;b.ts 中</p>
<pre><code>import &#123; A, a &#125; from &quot;./a&quot;;
</code></pre>
<p>以上代码中，文件<code>a.ts</code>的 <code>export</code> 语句输出了一个类型<code>A</code>和一个正常接口<code>a</code>，另一个文件<code>b.ts</code>则在同一条语句中输入了类型和正常接口</p>
<ol>
<li>区分类型和正常接口<blockquote>
<p>以上代码的方式很不利于区分类型和正常接口，容易造成混淆。为了解决这个问题，TypeScript 引入了两个解决方法。</p>
</blockquote>
</li>
</ol>
<blockquote>
<p>第一个方法：在<code>import</code>语句输入的类型前面加上<code>type</code>关键字</p>
</blockquote>
<p>在 <code>/src/b.ts</code> 中</p>
<pre><code>import &#123; type A, a &#125; from &quot;./a&quot;;
</code></pre>
<ul>
<li>import 语句输入的类型 A 前面有 type 关键字，表示这是一个类型</li>
</ul>
<blockquote>
<p>第二个方法：使用 <code>import type</code> 语句，这个语句只能输入类型，不能输入正常接口</p>
</blockquote>
<pre><code>// 正确
import type &#123; A &#125; from &quot;./a&quot;;

// 报错
import type &#123; a &#125; from &quot;./a&quot;;

console.log(a); // 报错

// import type 输入类型 A 是正确的，但是输入正常接口 a 就会报错。
</code></pre>
<ol start="2">
<li>默认类型<blockquote>
<p>import type 语句也可以输入默认类型</p>
</blockquote>
</li>
</ol>
<pre><code>import type DefaultType from &quot;moduleA&quot;;
</code></pre>
<blockquote>
<p>import type 在一个名称空间下，输入所有类型的写法如下</p>
</blockquote>
<pre><code>import type * as TypeNS from &quot;moduleA&quot;;
</code></pre>
<h4 id="export-type-语句"><a href="#export-type-语句" class="headerlink" title="export type 语句"></a>export type 语句</h4><blockquote>
<p>同样的，export 语句也有两种方法，表示输出的是类型</p>
</blockquote>
<pre><code>type A = &quot;a&quot;;
type B = &quot;b&quot;;

// 方法一
export &#123; type A, type B &#125;;

// 方法二
export type &#123; A, B &#125;;
</code></pre>
<ul>
<li>方法一：使用<code>type</code>关键字作为前缀，表示输出的是类型</li>
<li>方法二：使用<code>export type</code>语句，表示整行输出的都是类型</li>
</ul>
<blockquote>
<p>将类作为类型输出</p>
<ul>
<li>以下是<code>export type</code>将一个类作为类型输出的应用<br>在<code>/src/module.ts</code>中</li>
</ul>
</blockquote>
<pre><code>class Point &#123;
  x: number;
  y: number;
&#125;

export type &#123; Point &#125;;
</code></pre>
<ul>
<li>以上代码中，由于使用了<code>export type</code>语句，输出的并不是 Point 这个类，而是 Point 代表的<strong>实例类型</strong>。输入时，只能作为类型输入，不能当作正常接口使用</li>
</ul>
<p>在 &#x2F;src&#x2F;index.ts 中</p>
<pre><code>import type &#123; Point &#125; from &quot;./module&quot;;

const p: Point = &#123; x: 1, y: 2 &#125;;

// Point 只能作为类型输入，不能当作正常接口使用
</code></pre>
<h4 id="importsNotUsedAsValues-编译设置"><a href="#importsNotUsedAsValues-编译设置" class="headerlink" title="importsNotUsedAsValues 编译设置"></a>importsNotUsedAsValues 编译设置</h4><blockquote>
<p>TypeScript 特有的输入类型（type）的 import 语句，编译成 JavaScript 时怎么处理呢 ？</p>
<ul>
<li>TypeScript 提供了<code>importsNotUsedAsValues</code>编译设置项，有三个可能的值。</li>
</ul>
</blockquote>
<ul>
<li>①、<code>remove</code>：这是默认值，自动删除输入类型的 <code>import</code> 语句</li>
<li>②、<code>preserve</code>：保留输入类型的 <code>import</code> 语句</li>
<li>③、<code>error</code>：保留输入类型的 <code>import</code> 语句（与<code>preserve</code>相同），但是必须写成<code>import type</code>的形式，否则报错</li>
</ul>
<blockquote>
<p>下面是一个输入类型的 import 语句</p>
</blockquote>
<pre><code>import &#123; TypeA &#125; from &quot;./a&quot;;

// TypeA 是一个类型
</code></pre>
<ul>
<li>remove的编译结果会将该语句删掉</li>
<li>preserve的编译结果会保留该语句，但会删掉其中涉及类型的部分</li>
</ul>
<pre><code>import &quot;./a&quot;;
</code></pre>
<ul>
<li><code>preserve</code>的编译结果，可以看到编译后的 <code>import</code> 语句不从 <code>a.js</code> 输入任何接口（包括类型）</li>
<li>但是会引发 <code>a.js</code> 的执行，因此会保留 <code>a.js</code> 里面的副作用</li>
</ul>
<blockquote>
<p><code>error</code>的编译结果与<code>preserve</code>相同，但在编译过程中会报错，因为它要求输入类型的<code>import</code>语句必须写成<code>import type</code>的形式。原始语句改成下面的形式，就不会报错</p>
</blockquote>
<pre><code>import type &#123; TypeA &#125; from &quot;./a&quot;;
</code></pre>
<h4 id="CommonJS-模块"><a href="#CommonJS-模块" class="headerlink" title="CommonJS 模块"></a>CommonJS 模块</h4><blockquote>
<p>CommonJS 是 <code>Node.js</code> 的专用模块格式，与 ES 模块格式<strong>不兼容</strong></p>
</blockquote>
<ol>
<li>import &#x3D; 语句<blockquote>
<p>TypeScript 使用<code>import =</code>语句输入 <code>CommonJS</code> 模块</p>
</blockquote>
</li>
</ol>
<pre><code>// 导入 node.js 的 fs 模块（提供文件操作相关的API）
import fs = require(&quot;fs&quot;);
// 导入 path 模块（处理文件路径）
import path = require(&quot;path&quot;);

// 将当前文件所在的目录和 a.ts 文件名拼接成完整的文件路径
// __dirname 代表的是当前文件所在的目录
const filePath = path.join(__dirname, &quot;a.ts&quot;);
// 使用 fs.readFileSync方法读取 a.ts 文件的内容
// 并将其存储在 fileContent 变量中
// utf8 参数表示以 UTF-8 编码读取文件内容
const fileContent = fs.readFileSync(filePath, &quot;utf8&quot;);

// 使用 console.log 将 fileContent 变量的值打印到控制台上
console.log(fileContent);

// 使用 import = 语句 和 require() 命令输入了一个 CommonJS 模块
// 模块本身的用法跟 Node.js 是一样的
</code></pre>
<blockquote>
<p><code>@types/node</code> 库</p>
<ul>
<li>在 TypeScript 中使用 <code>Node.js</code> 的核心模块 和 第三方库时，需要用到 <code>@types/node</code> 库，否则会报错</li>
</ul>
</blockquote>
<ul>
<li><code>@types/node</code> 是 TypeScript 的一个声明文件包，用于描述 Node.js 核心模块和常用的第三方库的类型信息。</li>
<li>这些声明文件增加了对 TypeScript 在 Node.js 环境下的支持，并提供了更好的类型安全和编辑器智能提醒</li>
</ul>
<pre><code># 在命令行终端安装 @types/node
npm i -D @types/node
</code></pre>
<blockquote>
<p>除了使用<code>import =</code>语句，TypeScript 还允许使用<code>import * as [接口名] from &quot;模块文件&quot;</code>输入 CommonJS 模块</p>
</blockquote>
<pre><code>import * as fs from &quot;fs&quot;;
// 等同于
import fs = require(&quot;fs&quot;);
</code></pre>
<ol start="2">
<li>export &#x3D; 语句<blockquote>
<p>TypeScript 使用<code>export =</code>语句，输出 CommonJS 模块的对象，等同于 CommonJS 的<code>module.exports</code>对象。</p>
</blockquote>
</li>
</ol>
<p>在 <code>/src/a.ts</code> 中</p>
<pre><code>let obj = &#123; foo: 123 &#125;;

export = obj;
</code></pre>
<ul>
<li><code>export =</code>语句输出的对象，只能使用<code>import =</code>语句加载。</li>
</ul>
<p>在 &#x2F;src&#x2F;b.ts 中</p>
<pre><code>import obj = require(&quot;./a&quot;);

console.log(obj.foo); // 123
</code></pre>
<h4 id="模块定位"><a href="#模块定位" class="headerlink" title="模块定位"></a>模块定位</h4><blockquote>
<p>模块定位（module resolution）指的是一种算法，用来确定 import 语句和 export 语句里面的模块文件位置。</p>
</blockquote>
<pre><code>// 相对模块
import &#123; TypeA &#125; from &quot;./a&quot;;

// 非相对模块
import * as $ from &quot;jquery&quot;;
</code></pre>
<ul>
<li>TypeScript 怎么确定 <code>./a</code> 或 <code>jquery</code> 到底是指哪一个模块，具体位置在哪里，用到的算法就叫做 “模块定位”</li>
</ul>
<blockquote>
<p>编译参数<code>moduleResolution</code>，用来指定具体使用哪一种定位算法。常用的算法有两种：<code>Classic</code>和<code>Node</code></p>
</blockquote>
<blockquote>
<p>如果没有指定<code>moduleResolution</code>，它的默认值与编译参数<code>module</code>有关。</p>
</blockquote>
<ul>
<li><code>module</code>设为<code>commonjs</code>时（项目脚本采用 CommonJS 模块格式），<code>moduleResolution</code>的默认值为<code>Node</code>，即采用 <code>Node.js</code> 的模块定位算法。</li>
<li>其他情况下（<code>module</code>设为 <code>es2015、 esnext、amd, system, umd</code> 等等），就采用<code>Classic</code>定位算法。</li>
</ul>
<ol>
<li>相对模块<blockquote>
<p>加载模块时，目标模块分为相对模块（relative import）和非相对模块两种（non-relative import）。</p>
</blockquote>
</li>
</ol>
<ul>
<li>相对模块指的是路径以<code>/</code>、<code>./</code>、<code>../</code>开头的模块。下面 <code>import</code> 语句加载的模块，都是相对模块。</li>
</ul>
<pre><code>import Entry from &quot;./components/Entry&quot;;
import &#123; DefaultHeaders &#125; from &quot;../constants/http&quot;;
import &quot;/mod&quot;;
</code></pre>
<ul>
<li>相对模块的定位，是根据<strong>当前脚本的位置进</strong>行计算的，一般用于保存在当前项目目录结构中的模块脚本</li>
</ul>
<ol start="2">
<li>非相对模块<blockquote>
<p>非相对模块指的是<strong>不带有路径信息</strong>的模块。下面 import 语句加载的模块，都是非相对模块。</p>
</blockquote>
</li>
</ol>
<pre><code>import * as $ from &quot;jquery&quot;;
import &#123; Component &#125; from &quot;@angular/core&quot;;
</code></pre>
<ul>
<li>非相对模块的定位，是由<code>baseUrl</code>属性或模块映射而确定的，通常用于加载外部模块。</li>
</ul>
<ol start="3">
<li>Classic 方法<blockquote>
<p>Classic 方法以当前脚本的路径作为“基准路径”，计算<strong>相对模块</strong>的位置。</p>
</blockquote>
</li>
</ol>
<ul>
<li>比如，脚本<code>a.ts</code>里面有一行代码<code>import &#123; b &#125; from &quot;./b&quot;</code>，那么 TypeScript 就会在<code>a.ts</code>所在的目录，查找<code>b.ts</code>和<code>b.d.ts</code>。</li>
</ul>
<blockquote>
<p>至于<strong>非相对模块</strong>，也是以当前脚本的路径作为起点，一层层查找上级目录。</p>
</blockquote>
<ul>
<li>比如，脚本<code>a.ts</code>里面有一行代码<code>import &#123; b &#125; from &quot;b&quot;</code>，那么就会依次在每一级上层目录里面，查找<code>b.ts</code>和<code>b.d.ts</code>。</li>
</ul>
<ol start="4">
<li>Node 方法<blockquote>
<p>Node 方法就是模拟 <code>Node.js</code> 的模块加载方法，也就是<code>require()</code>的实现方法。</p>
</blockquote>
</li>
</ol>
<blockquote>
<p>相对模块依然是以当前脚本的路径作为“基准路径”。比如，脚本文件<code>a.ts</code>里面有一行代码<code>let x = require(&quot;./b&quot;);，TypeScript</code>按照以下顺序查找。</p>
</blockquote>
<ul>
<li>①、当前目录是否包含<code>b.ts</code>、<code>b.tsx</code>、<code>b.d.ts</code>。如果不存在就执行下一步。</li>
<li>②、当前目录是否存在子目录<code>b</code>，该子目录里面的<code>package.json</code>文件是否有<code>types</code>字段指定了模块入口文件。如果不存在就执行下一步。</li>
<li>③、当前目录的子目录<code>b</code>是否包含<code>index.ts</code>、<code>index.tsx</code>、<code>index.d.ts</code>。如果不存在就报错。</li>
</ul>
<blockquote>
<p>非相对模块则是以当前脚本的路径作为起点，<strong>逐级向上层目录查找</strong>是否存在子目录<code>node_modules</code>。比如，脚本文件<code>a.js</code>有一行<code>let x = require(&quot;b&quot;);</code>，TypeScript 按照以下顺序进行查找。</p>
</blockquote>
<ul>
<li>①、当前目录的子目录<code>node_modules</code>是否包含<code>b.ts</code>、<code>b.tsx</code>、<code>b.d.ts</code></li>
<li>②、当前目录的子目录<code>node_modules</code>，是否存在文件<code>package.json</code>，该文件的<code>types</code>字段是否指定了入口文件，如果是的就加载该文件</li>
<li>③、当前目录的子目录<code>node_modules</code>里面，是否包含子目录<code>@types</code>，在该目录中查找文件<code>b.d.ts</code>。</li>
<li>④、当前目录的子目录<code>node_modules</code>里面，是否包含子目录<code>b</code>，在该目录中查找<code>index.ts</code>、<code>index.tsx</code>、<code>index.d.ts</code>。<br>⑤、进入上一层目录，重复上面 4 步，直到找到为止。</li>
</ul>
<ol start="5">
<li>路径映射<blockquote>
<p>TypeScript 允许开发者在<code>tsconfig.json</code>文件里面，手动指定脚本模块的路径。</p>
</blockquote>
</li>
</ol>
<blockquote>
<p>baseUrl</p>
<ul>
<li>baseUrl字段可以手动指定脚本模块的基准目录</li>
</ul>
</blockquote>
<pre><code>&#123;
  &quot;compilerOptions&quot;: &#123;
    &quot;baseUrl&quot;: &quot;.&quot;
  &#125;
&#125;
</code></pre>
<ul>
<li>如果baseUrl 是一个点，表示基准目录就是<code>tsconfig.json</code>所在的目录</li>
</ul>
<blockquote>
<p>paths</p>
<ul>
<li>paths字段指定非相对路径的模块与实际脚本的映射</li>
</ul>
</blockquote>
<pre><code>&#123;
  &quot;compilerOptions&quot;: &#123;
    &quot;baseUrl&quot;: &quot;.&quot;,
    &quot;paths&quot;: &#123;
      &quot;jquery&quot;: [&quot;node_modules/jquery/dist/jquery&quot;]
    &#125;
  &#125;
&#125;
</code></pre>
<ul>
<li>加载模块 <code>jquery</code> 时，实际加载的脚本是 <code>node_modules/jquery/dist/jquery</code>，它的位置要根据 <code>baseUrl</code> 字段计算得到</li>
<li>上例的<code>jquery</code>属性的值是一个数组，可以指定多个路径。如果第一个脚本路径不存在，那么就加载第二个路径，以此类推</li>
</ul>
<blockquote>
<p>rootDirs</p>
<ul>
<li><code>rootDirs</code>字段指定模块定位时必须查找的其他目录</li>
</ul>
</blockquote>
<pre><code>&#123;
  &quot;compilerOptions&quot;: &#123;
    &quot;rootDirs&quot;: [&quot;src/zh&quot;, &quot;src/de&quot;, &quot;src/#&#123;locale&#125;&quot;]
  &#125;
&#125;
</code></pre>
<ul>
<li>rootDirs 指定了模块定位时，需要查找的不同的国际化目录</li>
</ul>
<ol start="6">
<li>tsc 的–traceResolution参数<blockquote>
<p>由于模块定位的过程很复杂，tsc 命令有一个<code>--traceResolution</code>参数，能够在编译时在命令行显示模块定位的每一步。</p>
</blockquote>
</li>
</ol>
<pre><code>tsc --traceResolution

# traceResolution 会输出模块定位的判断过程
</code></pre>
<ol start="7">
<li>tsc 的–noResolve参数<blockquote>
<p>tsc 命令的<code>--noResolve</code>参数，表示模块定位时，只考虑在命令行传入的模块</p>
</blockquote>
</li>
</ol>
<ul>
<li>在 index.ts 中</li>
</ul>
<pre><code>import * as A from &quot;moduleA&quot;;
import * as B from &quot;moduleB&quot;;
</code></pre>
<ul>
<li>使用下面的命令进行编译</li>
</ul>
<pre><code>tsc app.ts moduleA.ts --noResolve
</code></pre>
<ul>
<li>上面命令使用<code>--noResolve</code>参数，因此可以定位到<code>moduleA.ts</code>，因为它从命令行传入了；无法定位到<code>moduleB</code>，因为它没有传入，因此会报错</li>
</ul>
<h3 id="二、namespace-命名空间"><a href="#二、namespace-命名空间" class="headerlink" title="二、namespace 命名空间"></a>二、namespace 命名空间</h3><blockquote>
<p><code>namespace</code>是一种将相关代码组织在一起的方式，中文译为 “命名空间”。</p>
</blockquote>
<ul>
<li>它出现在 ES 模块诞生之前，作为 TypeScript 自己的模块格式而发明的。但是，自从有了 ES 模块，官方已经不推荐使用<code>namespace</code> 了。</li>
</ul>
<h4 id="基础用法"><a href="#基础用法" class="headerlink" title="基础用法"></a>基础用法</h4><blockquote>
<p>namespace 用来建立一个容器，内部的所有变量和函数，都必须在这个容器里面使用。</p>
</blockquote>
<pre><code>namespace Utils &#123;
  function isString(value: any) &#123;
    return typeof value === &quot;string&quot;;
  &#125;

  // 正确
  isString(&quot;yes&quot;);
&#125;

Utils.isString(&quot;no&quot;); // 报错
</code></pre>
<ul>
<li>命名空间<code>Utils</code>里面定义了一个函数<code>isString()</code>，它只能在<code>Utils</code>里面使用，如果用于外部就会报错</li>
</ul>
<blockquote>
<p>如果要在命名空间以外使用内部成员，就必须为该成员加上<code>export</code>前缀，表示对外输出该成员</p>
</blockquote>
<pre><code>namespace Message &#123;
  export function log(msg: string) &#123;
    console.log(msg);
  &#125;
  export function error(msg: string) &#123;
    console.error(msg);
  &#125;
&#125;

Message.log(&quot;记得叫我哈 ！&quot;);
Message.error(&quot;我错了 !&quot;);
</code></pre>
<ul>
<li>只要加上 export 前缀，就可以在命名空间外部使用内部成员</li>
</ul>
<blockquote>
<p>编译出来的 JavaScript 代码如下</p>
</blockquote>
<pre><code>&quot;use strict&quot;;
var Message;
(function (Message) &#123;
  function log(msg) &#123;
    console.log(msg);
  &#125;
  Message.log = log;
  function error(msg) &#123;
    console.error(msg);
  &#125;
  Message.error = error;
&#125;)(Message || (Message = &#123;&#125;));
Message.log(&quot;记得叫我哈 ！&quot;);
Message.error(&quot;我错了 !&quot;);
</code></pre>
<ul>
<li>命名空间 <code>Message</code> 变成了 <code>JavaScript</code> 的一个对象，凡是 <code>export</code> 的内部成员，都成了该对象的属性</li>
<li>这就是说，namespace 会变成一个值，保留在编译后的代码中。这一点要小心，它不是纯的类型代码。</li>
</ul>
<blockquote>
<p><code>namespace</code>内部还可以使用<code>import</code>命令输入外部成员，相当于为外部成员起别名。当外部成员的名字比较长时，别名能够简化代码</p>
</blockquote>
<pre><code>namespace Utils &#123;
  export function isString(value: any) &#123;
    return typeof value === &quot;string&quot;;
  &#125;
&#125;

namespace App &#123;
  import isString = Utils.isString;

  isString(&quot;yes&quot;);
  // 等同于
  Utils.isString(&quot;yes&quot;);
&#125;
</code></pre>
<ul>
<li><code>import</code> 命令指定在命名空间 <code>App</code> 里面，外部成员 <code>Utils.isString</code> 的别名为 <code>isString</code></li>
</ul>
<blockquote>
<p><code>import</code>命令也可以在<code>namespace</code>外部，指定别名。</p>
</blockquote>
<pre><code>// 形状
namespace Shapes &#123;
  // 多边形
  export namespace Polygons &#123;
    // 三角形
    export class Triangle &#123;&#125;
    // 正方形
    export class Square &#123;&#125;
  &#125;
&#125;

import polygons = Shapes.Polygons;

// 等同于 new Shapes.Polygons.Square()
let sq = new polygons.Square();

// import 命令在命名空间Shapes的外部，指定Shapes.Polygons 的别名为 polygons
</code></pre>
<blockquote>
<p>namespace 可以嵌套</p>
</blockquote>
<pre><code>namespace Utils &#123;
  export namespace Message &#123;
    export function log(msg: string) &#123;
      console.log(msg);
    &#125;
  &#125;
&#125;

Utils.Message.log(&quot;icoding&quot;); // &quot;icoding&quot;
</code></pre>
<ul>
<li>命名空间 Utils 内部还有一个命名空间 Message</li>
<li>注意，如果要在外部使用 Message，必须在它前面加上 export 命令<blockquote>
<p>使用嵌套的命名空间，必须从最外层开始引用，比如<code>Utils.Message.log()</code></p>
</blockquote>
</li>
</ul>
<blockquote>
<p><code>namespace</code>不仅可以包含实义代码，还可以包括类型代码。</p>
</blockquote>
<pre><code>namespace N &#123;
  export interface MyInterface &#123;&#125;
  export class MyClass &#123;&#125;
&#125;
</code></pre>
<ul>
<li>命令空间 N 不仅对外输出类，还对外输出一个接口，它们都可以用作类型</li>
</ul>
<blockquote>
<p>namespace 与模块的对比</p>
<ul>
<li>相同点<ul>
<li>namespace 与模块的作用是一致的，都是把相关代码组织在一起，对外输出接口。</li>
</ul>
</li>
<li>区别是<ul>
<li>一个文件只能有一个模块，但可以有多个 namespace</li>
<li>由于模块可以取代 namespace，而且是 JavaScript 的标准语法，还不需要编译转换，所以建议总是使用模块，替代 namespace</li>
</ul>
</li>
</ul>
</blockquote>
<blockquote>
<p>如果 namespace 代码放在一个单独的文件里，那么引入这个文件需要使用三斜杠的语法。</p>
</blockquote>
<pre><code>/// &lt;reference path = &quot;SomeFileName.ts&quot; /&gt;
</code></pre>
<h4 id="namespace-的输出"><a href="#namespace-的输出" class="headerlink" title="namespace 的输出"></a>namespace 的输出</h4><blockquote>
<p>namespace 本身也可以使用<code>export</code>命令输出，供其他文件使用</p>
<ul>
<li>在 <code>/src/shapes.ts</code> 中</li>
</ul>
</blockquote>
<pre><code>export namespace Shapes &#123;
  export class Triangle &#123;
    // ...
  &#125;
  export class Square &#123;
    // ...
  &#125;
&#125;
</code></pre>
<ul>
<li>是一个文件<code>shapes.ts</code>，里面使用 <code>export</code> 命令，输出了一个命名空间 <code>Shapes</code></li>
</ul>
<blockquote>
<p>其他脚本文件使用<code>import</code>命令，加载这个命名空间</p>
<ul>
<li>在 <code>/src/index.ts</code> 中</li>
</ul>
</blockquote>
<pre><code>// 写法一
import &#123; Shapes &#125; from &quot;./shapes&quot;;
let t = new Shapes.Triangle();

// 写法二
import * as shapes from &quot;./shapes&quot;;
let t = new shapes.Shapes.Triangle();
</code></pre>
<blockquote>
<p>不过，更好的方法还是建议使用模块，采用模块的输出和输入。</p>
</blockquote>
<ul>
<li>在 <code>/src/shapes.ts</code> 中</li>
</ul>
<pre><code>export class Triangle &#123;
  /* ... */
&#125;
export class Square &#123;
  /* ... */
&#125;
</code></pre>
<ul>
<li>在 <code>/src/shapeConsumer.ts</code> 中</li>
</ul>
<pre><code>import * as shapes from &quot;./shapes&quot;;
let t = new shapes.Triangle();
</code></pre>
<ul>
<li>使用模块的输出和输入，改写了前面的例子</li>
</ul>
<h4 id="namespace-的合并"><a href="#namespace-的合并" class="headerlink" title="namespace 的合并"></a>namespace 的合并</h4><ol>
<li>多个同名的 namespace 会自动合并，这一点跟 interface 一样。</li>
</ol>
<pre><code>namespace Animals &#123;
  export class Cat &#123;&#125;
&#125;
namespace Animals &#123;
  export interface Legged &#123;
    numberOfLegs: number;
  &#125;
  export class Dog &#123;&#125;
&#125;

// 等同于
namespace Animals &#123;
  export interface Legged &#123;
    numberOfLegs: number;
  &#125;
  export class Cat &#123;&#125;
  export class Dog &#123;&#125;
&#125;
</code></pre>
<ul>
<li>这样做的目的是，如果同名的命名空间分布在不同的文件中，TypeScript 最终会将它们合并在一起。这样就比较方便扩展别人的代码。</li>
</ul>
<blockquote>
<p>合并命名空间时，命名空间中的<code>非export</code>的成员不会被合并，但是它们只能在各自的命名空间中使用。</p>
</blockquote>
<pre><code>namespace N &#123;
  const a = 0;

  export function foo() &#123;
    console.log(a); // 正确
  &#125;
&#125;

namespace N &#123;
  export function bar() &#123;
    foo(); // 正确
    console.log(a); // 报错
  &#125;
&#125;
</code></pre>
<ul>
<li>变量 a 是第一个名称空间 N 的非对外成员，它只在第一个名称空间可用</li>
</ul>
<ol start="2">
<li>命名空间还可以跟同名函数合并，但是要求同名函数必须在命名空间之前声明。这样做是为了确保先创建出一个函数对象，然后同名的命名空间就相当于给这个函数对象添加额外的属性。</li>
</ol>
<pre><code>function f() &#123;
  return f.version;
&#125;

namespace f &#123;
  export const version = &quot;1.0&quot;;
&#125;

f(); // &#39;1.0&#39;
f.version; // &#39;1.0&#39;
</code></pre>
<ul>
<li>函数 f() 与命名空间f合并，相当于命名空间为函数对象 f 添加属性</li>
</ul>
<ol start="3">
<li>命名空间也能与同名 class 合并，同样要求 class 必须在命名空间之前声明，原因同上。</li>
</ol>
<pre><code>class C &#123;
  foo = 1;
&#125;

namespace C &#123;
  export const bar = 2;
&#125;

C.bar; // 2
</code></pre>
<ul>
<li>名称空间 C 为类 C 添加了一个静态属性 bar</li>
</ul>
<ol start="4">
<li>命名空间还能与同名 Enum 合并。</li>
</ol>
<pre><code>enum E &#123;
  A,
  B,
  C,
&#125;

namespace E &#123;
  export function foo() &#123;
    console.log(E.C);
  &#125;
&#125;

E.foo(); // 2
</code></pre>
<ul>
<li>命名空间 E 为枚举 E 添加了一个 foo() 方法</li>
</ul>
<blockquote>
<p>注意，Enum 成员与命名空间导出成员不允许同名。</p>
</blockquote>
<pre><code>enum E &#123;
  A, // 报错
  B,
&#125;

namespace E &#123;
  export function A() &#123;&#125; // 报错
&#125;
</code></pre>
<ul>
<li>同名 Enum 与命名空间有同名成员，结果报错</li>
</ul>
<h3 id="三、declare-关键字"><a href="#三、declare-关键字" class="headerlink" title="三、declare 关键字"></a>三、declare 关键字</h3><blockquote>
<p>declare 关键字用来告诉编译器，某个类型是存在的，可以在当前文件中使用</p>
</blockquote>
<blockquote>
<p>它的主要作用，就是让当前文件可以使用其他文件声明的类型。举例来说，自己的脚本使用外部库定义的函数，编译器会因为不知道外部函数的类型定义而报错，这时就可以在自己的脚本里面使用declare关键字，告诉编译器外部函数的类型。这样的话，编译单个脚本就不会因为使用了外部类型而报错。</p>
</blockquote>
<blockquote>
<p>declare 关键字可以描述以下类型：</p>
</blockquote>
<ul>
<li>变量（const、let、var 命令声明）</li>
<li>type 或者 interface 命令声明的类型</li>
<li>class</li>
<li>enum</li>
<li>函数（function）</li>
<li>模块（module）</li>
<li>命名空间（namespace）</li>
</ul>
<blockquote>
<p>declare 关键字的重要特点是，它只是通知编译器某个类型是存在的，不用给出具体实现。比如，只描述函数的类型，不给出函数的实现，如果不使用declare，这是做不到的。</p>
</blockquote>
<blockquote>
<p>declare 只能用来描述已经存在的变量和数据结构，不能用来声明新的变量和数据结构。另外，所有 declare 语句都不会出现在编译后的文件里面。</p>
</blockquote>
<h4 id="declare-variable"><a href="#declare-variable" class="headerlink" title="declare variable"></a>declare variable</h4><blockquote>
<p>declare 关键字可以给出外部变量的类型描述</p>
</blockquote>
<blockquote>
<p>举例来说，当前脚本使用了其他脚本定义的全局变量x</p>
</blockquote>
<pre><code>x = 123; // 报错
</code></pre>
<ul>
<li>变量 x 是其他脚本定义的，当前脚本不知道它的类型，编译器就会报错</li>
</ul>
<p>这时使用 declare 命令给出它的类型，就不会报错了</p>
<pre><code>declare let x: number;
x = 1;
</code></pre>
<p>如果 declare 关键字没有给出变量的具体类型，那么变量类型就是<code>any</code></p>
<pre><code>declare let x;
x = 1;
// 变量 x 的类型为 any
</code></pre>
<blockquote>
<p>下面的例子是脚本使用浏览器全局对象document</p>
</blockquote>
<pre><code>declare var document;
document.title = &quot;Hello&quot;;
</code></pre>
<ul>
<li>declare 告诉编译器，变量 document 的类型是外部定义的（具体定义在 TypeScript 内置文件 lib.d.ts）</li>
<li>如果 TypeScript 没有找到document的外部定义，这里就会假定它的类型是any</li>
</ul>
<blockquote>
<p>declare 关键字只用来给出类型描述，是纯的类型代码，不允许设置变量的初始值，即不能涉及值。</p>
</blockquote>
<pre><code>// 报错
declare let x: number = 1;

// declare 设置了变量的初始值，结果就报错了
</code></pre>
<h4 id="declare-function"><a href="#declare-function" class="headerlink" title="declare function"></a>declare function</h4><blockquote>
<p>declare 关键字可以给出外部函数的类型描述。</p>
</blockquote>
<pre><code>declare function sayHello(username: string): void;

sayHello(&quot;icoding&quot;);

// declare 命令给出了 sayHello() 的类型描述，因此可以直接使用它
</code></pre>
<blockquote>
<p>这种单独的函数类型声明语句，只能用于<code>declare</code>命令后面。</p>
</blockquote>
<ul>
<li>一方面，TypeScript 不支持单独的函数类型声明语句</li>
<li>另一方面，declare 关键字后面也不能带有函数的具体实现</li>
</ul>
<pre><code>// 报错
function sayHello(username: string): void;
function sayHello(username) &#123;
  return &quot;你好，&quot; + username;
&#125;

// 单独写函数的类型声明就会报错
</code></pre>
<h4 id="declare-class"><a href="#declare-class" class="headerlink" title="declare class"></a>declare class</h4><blockquote>
<p>declare 给出 class 类型描述的写法如下</p>
</blockquote>
<pre><code>declare class Animal &#123;
  constructor(name: string);
  eat(): void;
  sleep(): void;
&#125;
</code></pre>
<p>以下复杂的应用</p>
<pre><code>declare class C &#123;
  // 静态成员
  public static s1(): string;
  private static s2: string;

  // 属性
  public a: number;
  private b: number;

  // 构造函数
  constructor(arg: number);

  // 方法
  m(x: number, y: number): number;

  // 存取器
  get c(): number;
  set c(value: number);

  // 索引签名
  [index: string]: any;
&#125;
</code></pre>
<ul>
<li>同样的，declare 后面不能给出 Class 的具体实现或初始值。</li>
</ul>
<h4 id="declare-module，declare-namespace"><a href="#declare-module，declare-namespace" class="headerlink" title="declare module，declare namespace"></a>declare module，declare namespace</h4><blockquote>
<p>如果想把变量、函数、类组织在一起，可以将 declare 与 module 或 namespace 一起使用。</p>
</blockquote>
<pre><code>declare namespace AnimalLib &#123;
  class Animal &#123;
    constructor(name: string);
    eat(): void;
    sleep(): void;
  &#125;

  type Animals = &quot;Fish&quot; | &quot;Dog&quot;;
&#125;

// 或者
declare module AnimalLib &#123;
  class Animal &#123;
    constructor(name: string);
    eat(): void;
    sleep(): void;
  &#125;

  type Animals = &quot;Fish&quot; | &quot;Dog&quot;;
&#125;
</code></pre>
<ul>
<li>以上代码中，declare 关键字给出了 module 或 namespace 的类型描述</li>
</ul>
<blockquote>
<p><code>declare module</code> 和 <code>declare namespace</code> 里面，加不加 export 关键字都可以。</p>
</blockquote>
<pre><code>declare namespace Foo &#123;
  export var a: boolean;
&#125;

declare module &quot;io&quot; &#123;
  export function readFile(filename: string): string;
&#125;
</code></pre>
<ul>
<li>namespace 和 module 里面使用了 export 关键字</li>
</ul>
<blockquote>
<p>下面的例子是当前脚本使用了<code>myLib</code>这个外部库，它有方法<code>makeGreeting()</code>和 属性<code>numberOfGreetings</code></p>
</blockquote>
<pre><code>let result = myLib.makeGreeting(&quot;你好&quot;);
console.log(&quot;欢迎词：&quot; + result);

let count = myLib.numberOfGreetings;
</code></pre>
<ul>
<li>myLib的类型描述就可以这样写</li>
</ul>
<pre><code>declare namespace myLib &#123;
  function makeGreeting(s: string): string;
  let numberOfGreetings: number;
&#125;
</code></pre>
<blockquote>
<p>declare 关键字的另一个用途，是为外部模块添加属性和方法时，给出新增部分的类型描述。</p>
</blockquote>
<pre><code>import &#123; Foo as Bar &#125; from &quot;moduleA&quot;;

declare module &quot;moduleA&quot; &#123;
  interface Bar extends Foo &#123;
    custom: &#123;
      prop1: string;
    &#125;;
  &#125;
&#125;
</code></pre>
<ul>
<li>上面代码中，从模块 <code>moduleA</code> 导入了 <code>Foo</code> 接口，将其重命名为 <code>Bar</code>，并用 <code>declare</code> 关键字为 <code>Bar</code> 增加一个属性 <code>custom</code></li>
</ul>
<ol>
<li>实践应用<blockquote>
<p>以下案例中，一个项目有多个模块，可以在一个模块中，对另一个模块的接口进行类型扩展<br>在 <code>/src/a.ts</code> 中</p>
</blockquote>
</li>
</ol>
<pre><code>export interface A &#123;
  x: number;
&#125;
</code></pre>
<p>在 <code>/src/b.ts</code> 中</p>
<pre><code>import &#123; A &#125; from &quot;./a&quot;;

declare module &quot;./a&quot; &#123;
  interface A &#123;
    y: number;
  &#125;
&#125;

const a: A = &#123; x: 1, y: 2 &#125;;
</code></pre>
<ul>
<li>脚本<code>a.ts</code>定义了一个接口<code>A</code></li>
<li>脚本<code>b.ts</code>为这个接口添加了属性<code>y</code></li>
<li><code>declare module &#39;./a&#39; &#123;&#125;</code>表示对<code>a.ts</code>里面的模块，进行类型声明，而同名 <code>interface</code> 会自动合并，所以等同于扩展类型</li>
</ul>
<blockquote>
<p>使用这种语法进行模块的类型扩展时，有两点需要注意：</p>
</blockquote>
<ul>
<li>①、<code>declare module NAME</code>语法里面的模块名<code>NAME</code>，跟 import 和 export 的模块名规则是一样的，且必须跟当前文件加载该模块的语句写法（上例<code>import &#123; A &#125; from &#39;./a&#39;</code>）保持一致</li>
<li>②、不能创建新的顶层类型。也就是说，只能对<code>a.ts</code>模块中已经存在的类型进行扩展，不允许增加新的顶层类型，比如新定义一个接口<code>B</code></li>
<li>③、不能对默认的<code>default</code>接口进行扩展，只能对 <code>export</code> 命令输出的命名接口进行扩充。这是因为在进行类型扩展时，需要依赖输出的接口名。</li>
</ul>
<blockquote>
<p>某些第三方模块，原始作者没有提供接口类型，这时可以在自己的脚本顶部加上下面一行命令。</p>
</blockquote>
<pre><code>declare module &quot;模块名&quot;;

// 例子
declare module &quot;hot-new-module&quot;;
</code></pre>
<ul>
<li>加上上面的命令以后，外部模块即使没有类型声明，也可以通过编译</li>
<li>但是，从该模块输入的所有接口都将为 any 类型</li>
</ul>
<blockquote>
<p><code>declare module</code>描述的模块名可以使用通配符</p>
</blockquote>
<pre><code>declare module &quot;my-plugin-*&quot; &#123;
  interface PluginOptions &#123;
    enabled: boolean;
    priority: number;
  &#125;

  function initialize(options: PluginOptions): void;
  export = initialize;
&#125;
</code></pre>
<ul>
<li>模块名<code>my-plugin-*</code>表示适配所有以<code>my-plugin-</code> 开头的模块名（比如 <code>my-plugin-logger</code> ）</li>
</ul>
<h4 id="declare-global"><a href="#declare-global" class="headerlink" title="declare global"></a>declare global</h4><blockquote>
<p>如果要为 JavaScript 引擎的原生对象添加属性和方法，可以使用<code>declare global &#123;&#125;</code>语法。</p>
</blockquote>
<pre><code>export &#123;&#125;;

declare global &#123;
  interface String &#123;
    toSmallString(): string;
  &#125;
&#125;

String.prototype.toSmallString = (): string =&gt; &#123;
  // 具体实现
  return &quot;&quot;;
&#125;;
</code></pre>
<ul>
<li>为 JavaScript 原生的 String 对象添加了 <code>toSmallString()</code> 方法</li>
<li><code>declare global</code> 给出这个新增方法的类型描述</li>
<li>第一行的空导出语句<code>export &#123;&#125;</code>，作用是强制编译器将这个脚本当作模块处理。这是因为<code>declare global</code>必须用在模块里面</li>
</ul>
<blockquote>
<p>下面的示例是为<code>window</code>对象添加一个属性<code>myAppConfig</code></p>
</blockquote>
<pre><code>export &#123;&#125;;

declare global &#123;
  interface window &#123;
    myAppConfig: object;
  &#125;
&#125;

const config = window.myAppConfig; // 报错
</code></pre>
<ul>
<li>declare global 只能扩充现有对象的类型描述，不能增加新的顶层类型</li>
</ul>
<h4 id="declare-enum"><a href="#declare-enum" class="headerlink" title="declare enum"></a>declare enum</h4><blockquote>
<p>declare 关键字给出 enum 类型描述的例子如下，下面的写法都是允许的。</p>
</blockquote>
<pre><code>declare enum E1 &#123;
  A,
  B,
&#125;

declare enum E2 &#123;
  A = 0,
  B = 1,
&#125;

declare const enum E3 &#123;
  A,
  B,
&#125;

declare const enum E4 &#123;
  A = 0,
  B = 1,
&#125;
</code></pre>
<h4 id="declare-module-用于类型声明文件"><a href="#declare-module-用于类型声明文件" class="headerlink" title="declare module 用于类型声明文件"></a>declare module 用于类型声明文件</h4><blockquote>
<p>我们可以为每个模块脚本，定义一个<code>.d.ts</code>文件，把该脚本用到的类型定义都放在这个文件里面。</p>
</blockquote>
<blockquote>
<p>但是，更方便的做法是为整个项目，定义一个大的<code>.d.ts</code>文件，在这个文件里面使用<code>declare module</code>定义每个模块脚本的类型。</p>
</blockquote>
<p>在 node.d.ts 中</p>
<pre><code>declare module &quot;url&quot; &#123;
  export interface Url &#123;
    protocol?: string;
    hostname?: string;
    pathname?: string;
  &#125;

  export function parse(
    urlStr: string,
    parseQueryString?,
    slashesDenoteHost?
  ): Url;
&#125;

declare module &quot;path&quot; &#123;
  export function normalize(p: string): string;
  export function join(...paths: any[]): string;
  export var sep: string;
&#125;
</code></pre>
<ul>
<li>url 和 path 都是单独的模块脚本，但是它们的类型都定义在 <code>node.d.ts</code> 这个文件里面</li>
</ul>
<blockquote>
<p>使用时，自己的脚本使用三斜杠命令，加载这个类型声明文件</p>
</blockquote>
<p>在 &#x2F;src&#x2F;index.ts 中</p>
<pre><code>/// &lt;reference path=&quot;node.d.ts&quot;/&gt;
</code></pre>
<ul>
<li>如果没有上面这一行命令，自己的脚本使用外部模块时，就需要在脚本里面使用 <code>declare</code> 命令单独给出外部模块的类型</li>
</ul>
<h3 id="四、d-ts-类型声明文件"><a href="#四、d-ts-类型声明文件" class="headerlink" title="四、d.ts 类型声明文件"></a>四、d.ts 类型声明文件</h3><blockquote>
<p>单独使用的模块，一般会同时提供一个单独的类型声明文件（declaration file），把本模块的外部接口的所有类型都写在这个文件里面，便于模块使用者了解接口，也便于编译器检查使用者的用法是否正确。</p>
</blockquote>
<h4 id="什么是类型声明文件"><a href="#什么是类型声明文件" class="headerlink" title="什么是类型声明文件"></a>什么是类型声明文件</h4><blockquote>
<p>类型声明文件里面只有类型代码，没有具体的代码实现。它的文件名一般为<code>[模块名].d.ts</code>的形式，其中的<code>d</code>表示 <code>declaration</code>（声明）</p>
</blockquote>
<blockquote>
<p>举例来说，有一个模块的代码如下：</p>
</blockquote>
<pre><code>const maxInterval = 123;

function getArrayLength(arr) &#123;
  return arr.length;
&#125;

module.exports = &#123;
  getArrayLength,
  maxInterval,
&#125;;
</code></pre>
<ul>
<li>它的类型声明文件可以写成下面这样</li>
</ul>
<pre><code>export function getArrayLength(arr: any[]): number;
export const maxInterval: 123;
</code></pre>
<blockquote>
<p>类型声明文件也可以使用<code>export =</code>命令，输出对外接口。下面是 moment 模块的类型声明文件的例子。</p>
</blockquote>
<pre><code>declare module &quot;moment&quot; &#123;
  function moment(): any;
  export = moment;
&#125;
</code></pre>
<ul>
<li>模块<code>moment</code>内部有一个函数<code>moment()</code>，而 <code>export =</code>表示<code>module.exports</code>输出的就是这个函数</li>
</ul>
<blockquote>
<p>除了使用<code>export =</code>，模块输出在类型声明文件中，也可以使用<code>export default</code>表示。</p>
</blockquote>
<pre><code>// 模块输出
module.exports = 3.1415;

// 类型输出文件
// 写法一
declare const pi: number;
export default pi;

// 写法二
declare const pi: number;
export = pi;
</code></pre>
<ul>
<li>模块输出的是一个整数，那么可以用 <code>export default</code> 或 <code>export =</code> 表示输出这个值</li>
</ul>
<h4 id="如何使用类型声明文件"><a href="#如何使用类型声明文件" class="headerlink" title="如何使用类型声明文件"></a>如何使用类型声明文件</h4><blockquote>
<p>下面是一个如何使用类型声明文件的简单例子，有一个类型声明文件<code>types.d.ts</code></p>
</blockquote>
<ul>
<li>在 <code>/src/types.d.ts</code> 中</li>
</ul>
<pre><code>export interface User &#123;
  language?: string;
  username: string;
&#125;
</code></pre>
<ul>
<li>然后，就可以在 TypeScript 脚本里面导入该文件声明的类型</li>
</ul>
<pre><code>// 在/src/index.ts 中
import &#123; User &#125; from &quot;./types&quot;;

export const character: User = &#123;
  language: &quot;Chinese&quot;,
  username: &quot;icoding&quot;,
&#125;;
</code></pre>
<blockquote>
<p>类型声明文件也可以包括在项目的 <code>tsconfig.json</code> 文件里面，这样的话，编译器打包项目时，会自动将类型声明文件加入编译，而不必在每个脚本里面加载类型声明文件。</p>
</blockquote>
<ul>
<li>比如，moment 模块的类型声明文件是<code>moment.d.ts</code>，使用 moment 模块的项目可以将其加入项目的 <code>tsconfig.json</code> 文件。</li>
</ul>
<pre><code>&#123;
  &quot;compilerOptions&quot;: &#123;&#125;,
  &quot;files&quot;: [&quot;src/index.ts&quot;, &quot;typings/moment.d.ts&quot;]
&#125;
</code></pre>
<h4 id="类型声明文件的来源"><a href="#类型声明文件的来源" class="headerlink" title="类型声明文件的来源"></a>类型声明文件的来源</h4><blockquote>
<p>类型声明文件主要有以下三种来源：</p>
</blockquote>
<ul>
<li>TypeScript 编译器自动生成</li>
<li>TypeScript 内置类型文件</li>
<li>外部模块的类型声明文件，需要自己安装</li>
</ul>
<ol>
<li>自动生成<blockquote>
<p>只要使用编译选项<code>declaration</code>，编译器就会在编译时自动生成单独的类型声明文件。</p>
</blockquote>
</li>
</ol>
<ul>
<li>在<code>tsconfig.json</code>文件里面，打开这个选项</li>
</ul>
<pre><code>&#123;
  &quot;compilerOptions&quot;: &#123;
    &quot;declaration&quot;: true
  &#125;
&#125;
</code></pre>
<ul>
<li>也可以</li>
</ul>
<pre><code>$ tsc --declaration
</code></pre>
<ol start="2">
<li>内置声明文件<blockquote>
<p>安装 TypeScript 语言时，会同时安装一些内置的类型声明文件，主要是内置的全局对象（JavaScript 语言接口和运行环境 API）的类型声明</p>
<ul>
<li>这些内置声明文件位于 TypeScript 语言安装目录的<code>lib</code>文件夹内，数量大概有几十个，下面是其中一些主要文件。</li>
</ul>
</blockquote>
</li>
</ol>
<ul>
<li>lib.d.ts</li>
<li>lib.dom.d.ts</li>
<li>lib.es2015.d.ts</li>
<li>lib.es2016.d.ts</li>
<li>lib.es2017.d.ts</li>
<li>lib.es2018.d.ts</li>
<li>lib.es2019.d.ts</li>
<li>lib.es2020.d.ts</li>
<li>lib.es5.d.ts</li>
<li>lib.es6.d.ts</li>
</ul>
<blockquote>
<p>这些内置声明文件的文件名统一为<code>lib.[description].d.ts</code>的形式，其中<code>description</code>部分描述了文件内容。比如，<code>lib.dom.d.ts</code>这个文件就描述了 DOM 结构的类型。</p>
</blockquote>
<blockquote>
<p>如果开发者想了解全局对象的类型接口（比如 ES6 全局对象的类型），那么就可以去查看这些内置声明文件。</p>
</blockquote>
<blockquote>
<p>TypeScript 编译器会自动根据编译目标<code>target</code>的值，加载对应的内置声明文件，所以不需要特别的配置。但是，可以使用编译选项lib，指定加载哪些内置声明文件。</p>
</blockquote>
<pre><code>&#123;
  &quot;compilerOptions&quot;: &#123;
    &quot;lib&quot;: [&quot;dom&quot;, &quot;es2021&quot;]
  &#125;
&#125;
</code></pre>
<ul>
<li><code>lib</code>选项指定加载<code>dom</code>和<code>es2021</code>这两个内置类型声明文件</li>
<li>编译选项<code>noLib</code>会禁止加载任何内置声明文件。</li>
</ul>
<ol start="3">
<li>外部类型声明文件<blockquote>
<p>如果项目中使用了外部的某个第三方代码库，那么就需要这个库的类型声明文件。</p>
<ul>
<li>这时又分成三种情况：</li>
</ul>
</blockquote>
</li>
</ol>
<p>①、这个库自带了类型声明文件</p>
<ul>
<li>一般来说，如果这个库的源码包含了<code>[vendor].d.ts</code>文件，那么就自带了类型声明文件。</li>
<li>其中的<code>vendor</code>表示这个库的名字，比如<code>moment</code>这个库就自带<code>moment.d.ts</code>。使用这个库可能需要单独加载它的类型声明文件。</li>
</ul>
<p>②、这个库没有自带，但是可以找到社区制作的类型声明文件</p>
<ul>
<li>第三方库如果没有提供类型声明文件，社区往往会提供。TypeScript 社区主要使用<a target="_blank" rel="noopener" href="https://github.com/DefinitelyTyped/DefinitelyTyped"><code>DefinitelyTyped</code>仓库</a>，各种类型声明文件都会提交到那里，已经包含了几千个第三方库。</li>
</ul>
<blockquote>
<p>这些声明文件都会作为一个单独的库，发布到 <code>npm</code> 的<code>@types</code>名称空间之下。比如，<code>jQuery</code> 的类型声明文件就发布成<code>@types/jquery</code>这个库，使用时安装这个库就可以了。</p>
</blockquote>
<pre><code>npm i @types/jquery --save-dev
</code></pre>
<ul>
<li>执行上面的命令，<code>@types/jquery</code>这个库就安装到项目的<code>node_modules/@types/jquery</code>目录</li>
<li>里面的<code>index.d.ts</code>文件就是 <code>jQuery</code> 的类型声明文件。如果类型声明文件不是<code>index.d.ts</code>，那么就需要在<code>package.json</code>的<code>types</code>或<code>typings</code>字段，指定类型声明文件的文件名。</li>
</ul>
<blockquote>
<p>TypeScript 会自动加载<code>node_modules/@types</code>目录下的模块，但可以使用编译选项<code>typeRoots</code>改变这种行为。</p>
</blockquote>
<pre><code>&#123;
  &quot;compilerOptions&quot;: &#123;
    &quot;typeRoots&quot;: [&quot;./typings&quot;, &quot;./vendor/types&quot;]
  &#125;
&#125;
</code></pre>
<ul>
<li>以上配置信息表示，TypeScript 不再去 <code>node_modules/@types</code>目录，而是去跟当前 <code>tsconfig.json</code>同级的 <code>typings</code>和<code>vendor/types</code>子目录，加载类型模块了</li>
</ul>
<blockquote>
<p>默认情况下，TypeScript 会自动加载<code>typeRoots</code>目录里的所有模块，编译选项<code>types</code>可以指定加载哪些模块。</p>
</blockquote>
<pre><code>&#123;
  &quot;compilerOptions&quot;: &#123;
    &quot;types&quot;: [&quot;jquery&quot;]
  &#125;
&#125;
</code></pre>
<ul>
<li>上面设置中，<code>types</code>属性是一个数组，成员是所要加载的类型模块，要加载几个模块，这个数组就有几个成员，每个类型模块在<code>typeRoots</code>目录下都有一个自己的子目录。这样的话，TypeScript 就会自动去<code>jquery</code>子目录，加载 <code>jQuery</code> 的类型声明文件。</li>
</ul>
<p>③、找不到类型声明文件，需要自己写</p>
<blockquote>
<p>有时实在没有第三方库的类型声明文件，又很难完整给出该库的类型描述，这时你可以告诉 TypeScript 相关对象的类型是any。比如，使用 jQuery 的脚本可以写成下面这样。</p>
</blockquote>
<pre><code>declare var $: any;

// 或者
declare type JQuery = any;
declare var $: JQuery;
</code></pre>
<ul>
<li>jQuery 的 <code>$</code> 对象是外部引入的，类型是 <code>any</code>，也就是 TypeScript 不用对它进行类型检查</li>
</ul>
<blockquote>
<p>也可以采用下面的写法，将整个外部模块的类型设为any</p>
</blockquote>
<pre><code>declare module &quot;模块名&quot;;
</code></pre>
<ul>
<li>有了上面的命令，指定模块的所有接口都将视为any类型。</li>
</ul>
<h4 id="declare-关键字"><a href="#declare-关键字" class="headerlink" title="declare 关键字"></a>declare 关键字</h4><blockquote>
<p>类型声明文件只包含类型描述，不包含具体实现，所以非常适合使用 declare 语句来描述类型。declare 关键字的具体用法，详见《declare 关键字》部分，这里讲解如何在类型声明文件里面使用它。</p>
</blockquote>
<ol>
<li>类型声明文件里面，<strong>变量</strong>的类型描述必须使用<code>declare</code>命令，否则会报错，因为变量声明语句是值相关代码</li>
</ol>
<ul>
<li>在 <code>types.d.ts</code> 中</li>
</ul>
<pre><code>declare let foo: string;
</code></pre>
<ol start="2">
<li>interface 类型有没有declare都可以，因为 interface 是完全的类型代码</li>
</ol>
<pre><code>interface Foo &#123;&#125; // 正确
declare interface Foo &#123;&#125; // 正确
</code></pre>
<blockquote>
<p>类型声明文件里面，顶层可以使用<code>export</code>命令，也可以不用，除非使用者脚本会显式使用<code>export</code>命令输入类型。</p>
</blockquote>
<pre><code>export interface Data &#123;
  version: string;
&#125;
</code></pre>
<ol start="3">
<li>下面是类型声明文件的一些例子。<blockquote>
<p>先看 <code>moment</code> 模块的类型描述文件<code>moment.d.ts</code>。</p>
</blockquote>
</li>
</ol>
<pre><code>declare module &quot;moment&quot; &#123;
  export interface Moment &#123;
    format(format: string): string;

    add(amount: number, unit: &quot;days&quot; | &quot;months&quot; | &quot;years&quot;): Moment;

    subtract(amount: number, unit: &quot;days&quot; | &quot;months&quot; | &quot;years&quot;): Moment;
  &#125;

  function moment(input?: string | Date): Moment;

  export default moment;
&#125;
</code></pre>
<ul>
<li>注意一下默认接口 <code>moment()</code> 的写法</li>
</ul>
<blockquote>
<p>D3 库的类型声明文件<code>D3.d.ts</code></p>
</blockquote>
<pre><code>declare namespace D3 &#123;
  export interface Selectors &#123;
    select: &#123;
      (selector: string): Selection;
      (element: EventTarget): Selection;
    &#125;;
  &#125;

  export interface Event &#123;
    x: number;
    y: number;
  &#125;

  export interface Base extends Selectors &#123;
    event: Event;
  &#125;
&#125;

declare var d3: D3.Base;
</code></pre>
<h4 id="模块发布"><a href="#模块发布" class="headerlink" title="模块发布"></a>模块发布</h4><blockquote>
<p>当前模块如果包含自己的类型声明文件，可以在 <code>package.json</code> 文件里面添加一个<code>types</code>字段或<code>typings</code>字段，指明类型声明文件的位置。</p>
</blockquote>
<ul>
<li>在 <code>package.json</code> 中</li>
</ul>
<pre><code>&#123;
  &quot;name&quot;: &quot;icoding-ts-course&quot;,
  &quot;author&quot;: &quot;Arry&quot;,
  &quot;version&quot;: &quot;1.0.0&quot;,
  &quot;main&quot;: &quot;./lib/main.js&quot;,
  &quot;types&quot;: &quot;./lib/main.d.ts&quot;
&#125;
</code></pre>
<ul>
<li>types 字段给出了类型声明文件的位置</li>
</ul>
<blockquote>
<p>如果类型声明文件名为<code>index.d.ts</code>，且在项目的根目录中，那就不需要在<code>package.json</code>里面注明了。</p>
</blockquote>
<blockquote>
<p>有时，类型声明文件会单独发布成一个<code>npm</code>模块，这时用户就必须同时加载该模块。</p>
</blockquote>
<pre><code>&#123;
  &quot;name&quot;: &quot;icoding-ts-course&quot;,
  &quot;author&quot;: &quot;Arry&quot;,
  &quot;version&quot;: &quot;1.0.0&quot;,
  &quot;main&quot;: &quot;./lib/main.js&quot;,
  &quot;types&quot;: &quot;./lib/main.d.ts&quot;,
  &quot;dependencies&quot;: &#123;
    &quot;browserify&quot;: &quot;latest&quot;,
    &quot;@types/browserify&quot;: &quot;latest&quot;,
    &quot;typescript&quot;: &quot;next&quot;
  &#125;
&#125;
</code></pre>
<ul>
<li>上面是一个模块的 <code>package.json</code> 文件，该模块需要 <code>browserify</code> 模块</li>
<li>由于后者的类型声明文件是一个单独的模块 <code>@types/browserify</code>，所以还需要加载那个模块</li>
</ul>
<h4 id="三斜杠命令"><a href="#三斜杠命令" class="headerlink" title="三斜杠命令"></a>三斜杠命令</h4><blockquote>
<p>如果类型声明文件的内容非常多，可以拆分成多个文件，然后入口文件使用三斜杠命令，加载其他拆分后的文件</p>
</blockquote>
<blockquote>
<p>如下在 <code>/src/</code> 目录下</p>
</blockquote>
<ul>
<li>入口文件是 <code>main.d.ts</code></li>
<li>里面的接口定义在 <code>interfaces.d.ts</code></li>
<li>函数定义在<code>functions.d.ts</code></li>
<li>那么，<code>/src/main.d.ts</code>里面可以用三斜杠命令，加载后面两个文件</li>
</ul>
<pre><code>/// &lt;reference path=&quot;./interfaces.d.ts&quot; /&gt;
/// &lt;reference path=&quot;./functions.d.ts&quot; /&gt;
</code></pre>
<blockquote>
<p>三斜杠命令（<code>///</code>）是一个 TypeScript 编译器命令，用来指定编译器行为。它只能用在文件的<strong>头部</strong>，如果用在其他地方，会被当作普通的注释</p>
</blockquote>
<ul>
<li>另外，若一个文件中使用了三斜线命令，那么在三斜线命令<strong>之前</strong>只允许使用单行注释、多行注释和其他三斜线命令，否则三斜杠命令也会被当作普通的注释。</li>
<li>除了拆分类型声明文件，三斜杠命令也可以用于普通脚本加载类型声明文件。</li>
</ul>
<blockquote>
<p>三斜杠命令主要包含三个参数，代表三种不同的命令。</p>
</blockquote>
<ul>
<li>path</li>
<li>types</li>
<li>lib</li>
</ul>
<ol>
<li><code>/// &lt;reference path=&quot;&quot; /&gt;</code><blockquote>
<p><code>/// &lt;reference path=&quot;&quot; /&gt;</code>是最常见的三斜杠命令，告诉编译器在编译时需要包括的文件，常用来声明当前脚本依赖的类型文件</p>
</blockquote>
</li>
</ol>
<p>在 <code>/src/lib.ts</code> 中</p>
<pre><code>type Add = (x: number, y: number) =&gt; number;

const add: Add = (x, y) =&gt; x + y;
</code></pre>
<p>在 <code>/src/index.ts</code> 中</p>
<pre><code>/// &lt;reference path=&quot;./lib.ts&quot; /&gt;

let res = add(1, 2);
</code></pre>
<ul>
<li>当前脚本依赖于<code>./lib.ts</code>，里面是 <code>add()</code> 的定义</li>
<li>编译当前脚本时，还会同时编译<code>./lib.ts</code>。</li>
<li>编译产物会有两个 JS 文件，一个当前脚本，另一个就是 <code>./lib.js</code></li>
</ul>
<blockquote>
<p>下面的案例是当前脚本依赖于 Node.js 类型声明文件</p>
</blockquote>
<pre><code>/// &lt;reference path=&quot;../lib/node.d.ts&quot;/&gt;

import * as URL from &quot;url&quot;;
let myUrl = URL.parse(&quot;https://www.arryblog.com&quot;);
</code></pre>
<ul>
<li>编译器会在预处理阶段，找出所有三斜杠引用的文件，将其添加到编译列表中，然后一起编译。</li>
</ul>
<blockquote>
<p><code>path</code>参数指定了所引入文件的路径。如果该路径是一个相对路径，则基于当前脚本的路径进行计算</p>
</blockquote>
<blockquote>
<p>使用该命令时，有以下两个注意事项：</p>
</blockquote>
<ul>
<li>path参数必须指向一个存在的文件，若文件不存在会报错。</li>
<li>path参数不允许指向当前文件。</li>
</ul>
<blockquote>
<p>默认情况下，每个三斜杠命令引入的脚本，都会编译成单独的 JS 文件。</p>
</blockquote>
<ul>
<li>如果希望编译后只产出一个合并文件，可以使用编译选项<code>outFile</code>。</li>
<li>但是，<code>outFile</code>编译选项不支持合并 <code>CommonJS</code> 模块和 <code>ES</code> 模块，只有当编译参数<code>module</code>的值设为 <code>None</code>、<code>System</code> 或 <code>AMD</code> 时，才能编译成一个文件。</li>
</ul>
<blockquote>
<p>如果打开了编译参数<code>noResolve</code>，则忽略三斜杠指令。将其当作一般的注释，原样保留在编译产物中。</p>
</blockquote>
<ol start="2">
<li><code>/// &lt;reference types=&quot;&quot; /&gt;</code><blockquote>
<p><code>types</code> 参数用来告诉编译器当前脚本依赖某个 <code>DefinitelyTyped</code> 类型库，通常安装在<code>node_modules/@types</code>目录。</p>
</blockquote>
</li>
</ol>
<blockquote>
<p><code>types</code> 参数的值是类型库的名称，也就是安装到<code>node_modules/@types</code>目录中的子目录的名字。</p>
</blockquote>
<pre><code>/// &lt;reference types=&quot;node&quot; /&gt;
</code></pre>
<ul>
<li>这个三斜杠命令表示编译时添加<code>Node.js</code>的类型库，实际添加的脚本是<code>node_modules</code>目录里面的<code>@types/node/index.d.ts</code></li>
</ul>
<blockquote>
<p>可以看到，这个命令的作用类似于<code>import</code>命令</p>
</blockquote>
<ul>
<li>注意：这个命令只在你自己手写类型声明文件（<code>.d.ts</code>文件）时，才有必要用到，也就是说，只应该用在<code>.d.ts</code>文件中，普通的<code>.ts</code>脚本文件不需要写这个命令。</li>
<li>如果是普通的<code>.ts</code>脚本，可以使用<code>tsconfig.json</code>文件的<code>types</code>属性指定依赖的类型库。</li>
</ul>
<ol start="3">
<li><code>/// &lt;reference lib=&quot;&quot; /&gt;</code><blockquote>
<p><code>/// &lt;reference lib=&quot;...&quot; /&gt;</code>命令允许脚本文件显式包含内置 <code>lib</code> 库，等同于在<code>tsconfig.json</code>文件里面使用<code>lib</code>属性指定 <code>lib </code>库。</p>
</blockquote>
</li>
</ol>
<blockquote>
<p>前文说过，安装 TypeScript 软件包时，会同时安装一些内置的类型声明文件，即内置的 lib 库。这些库文件位于 TypeScript 安装目录的lib文件夹中，它们描述了 JavaScript 语言和引擎的标准 API。</p>
</blockquote>
<ul>
<li>库文件并不是固定的，会随着 TypeScript 版本的升级而更新。库文件统一使用 <code>lib.[description].d.ts</code> 的命名方式，而<code>/// &lt;reference lib=&quot;&quot; /&gt;</code>里面的lib属性的值就是库文件名的<code>description</code>部分，比如<code>lib=&quot;es2015&quot;</code>就表示加载库文件<code>lib.es2015.d.ts</code>。</li>
</ul>
<pre><code>/// &lt;reference lib=&quot;es2017.string&quot; /&gt;

// es2017.string 对应的库文件就是 lib.es2017.string.d.ts
</code></pre>
<h3 id="五、类型运算符"><a href="#五、类型运算符" class="headerlink" title="五、类型运算符"></a>五、类型运算符</h3><blockquote>
<p>TypeScript 提供强大的类型运算能力，可以使用各种类型运算符，对已有的类型进行计算，得到新类型。</p>
</blockquote>
<h4 id="keyof-运算符"><a href="#keyof-运算符" class="headerlink" title="keyof 运算符"></a>keyof 运算符</h4><blockquote>
<p>keyof 是一个单目运算符，接受一个对象类型作为参数，返回该对象的所有<strong>键名</strong>组成的联合类型。</p>
</blockquote>
<pre><code>type MyObj = &#123;
  foo: number;
  bar: string;
&#125;;

type Keys = keyof MyObj; // &#39;foo&#39;|&#39;bar&#39;

const a: Keys = &quot;bar&quot;; // 正确
const b: Keys = &quot;foo&quot;; // 正确
const c: Keys = &quot;icoding&quot;; // 错误
</code></pre>
<ul>
<li><code>keyof MyObj</code>返回<code>MyObj</code>的所有键名组成的联合类型，即 <code>&#39;foo&#39;|&#39;bar&#39;</code></li>
</ul>
<blockquote>
<p>keyof 接受一个接口类型作为参数</p>
</blockquote>
<pre><code>interface T &#123;
  0: boolean;
  a: string;
  b(): void;
&#125;

type KeyT = keyof T; // 0 | &#39;a&#39; | &#39;b&#39;

const a: KeyT = &quot;a&quot;; // 正确
const b: KeyT = &quot;b&quot;; // 正确
const c: KeyT = 0; // 正确
</code></pre>
<ol>
<li>keyof 返回类型<blockquote>
<p>由于 JavaScript 对象的键名只有三种类型，所以对于任意对象的键名的联合类型就是<code>string|number|symbol</code></p>
</blockquote>
</li>
</ol>
<pre><code>// string | number | symbol
type KeyT = keyof any;
</code></pre>
<blockquote>
<p>对于没有自定义键名的类型使用 keyof 运算符，返回never类型，表示不可能有这样类型的键名。</p>
</blockquote>
<pre><code>type KeyT = keyof object; // never
</code></pre>
<ul>
<li>由于 object 类型没有自身的属性，也就没有键名，所以 <code>keyof object</code> 返回 <code>never</code> 类型</li>
</ul>
<blockquote>
<p>由于 keyof 返回的类型是<code>string|number|symbol</code>，如果有些场合只需要其中的一种类型，那么可以采用交叉类型的写法</p>
</blockquote>
<pre><code>type Capital&lt;T extends string&gt; = Capitalize&lt;T&gt;;

type MyKeys&lt;Obj extends object&gt; = Capital&lt;keyof Obj&gt;; // 报错
</code></pre>
<ul>
<li>类型 Capital 只接受字符串作为类型参数，传入<code>keyof Obj</code>会报错，原因是这时的类型参数是<code>string|number|symbol</code>，跟字符串不兼容</li>
<li>采用下面的交叉类型写法，就不会报错</li>
</ul>
<pre><code>type Capital&lt;T extends string&gt; = Capitalize&lt;T&gt;;
// 使用交叉类型的写法
type MyKeys&lt;Obj extends object&gt; = Capital&lt;string &amp; keyof Obj&gt;;
</code></pre>
<ul>
<li><code>string &amp; keyof Obj</code> 等同于 <code>string &amp; string|number|symbol</code> 进行<strong>交集</strong>运算，最后返回<code>string</code></li>
<li>因此 <code>Capital&lt;T extends string&gt;</code> 就不会报错了</li>
</ul>
<ol start="2">
<li>keyof 返回属性名的索引类型<blockquote>
<p>如果对象属性名采用索引形式，keyof 会返回属性名的索引类型。</p>
</blockquote>
</li>
</ol>
<pre><code>// 示例一
interface T &#123;
  [prop: number]: number;
&#125;

// number
type KeyT = keyof T;

const a: KeyT = 123; // 正确
const b: KeyT = &quot;icoding&quot;; // 错误

// 示例二
interface U &#123;
  [prop: string]: number;
&#125;

// string|number
type KeyU = keyof U;

const m: KeyU = 123; // 正确
const n: KeyU = &quot;icoding&quot;; // 正确
</code></pre>
<ul>
<li>以上示例二，<code>keyof T</code>返回的类型是<code>string|number</code></li>
<li>原因是 JavaScript 属性名为字符串时，<strong>包含了属性名为数值的情况</strong>，因为数值属性名会自动转为字符串</li>
</ul>
<ol start="3">
<li>keyof 用于数组 或 元组类型<blockquote>
<p>如果 keyof 运算符用于数组或元组类型，得到的结果可能出人意料。</p>
</blockquote>
</li>
</ol>
<pre><code>type Result = keyof [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;];

// 返回 number | &quot;0&quot; | &quot;1&quot; | &quot;2&quot;
// | &quot;length&quot; | &quot;pop&quot; | &quot;push&quot; | ···
// keyof 会返回数组的所有键名，包括数字键名和继承的键名

const a: Result = 123; // 正确
const b: Result = &quot;0&quot;; // 正确
const c: Result = &quot;1&quot;; // 正确
const d: Result = &quot;2&quot;; // 正确
const e: Result = &quot;3&quot;; // 报错

const f: Result = &quot;length&quot;;
const g: Result = &quot;pop&quot;;
const h: Result = &quot;push&quot;;
const o: Result = &quot;icoding&quot;; // 报错
</code></pre>
<ul>
<li>keyof 会返回数组的所有键名，包括数字键名和继承的键名</li>
</ul>
<ol start="4">
<li>keyof 用于联合类型<blockquote>
<p>对于联合类型，keyof 返回成员共有的键名。</p>
</blockquote>
</li>
</ol>
<pre><code>type A = &#123; a: string; z: boolean &#125;;
type B = &#123; b: string; z: boolean &#125;;

// 返回 &#39;z&#39;
type KeyT = keyof (A | B);

const a: KeyT = &quot;z&quot;; // 正确
</code></pre>
<ol start="5">
<li>keyof 用于交叉类型<blockquote>
<p>对于交叉类型，keyof 返回所有键名</p>
</blockquote>
</li>
</ol>
<pre><code>type A = &#123; a: string; x: boolean &#125;;
type B = &#123; b: string; y: number &#125;;

// 返回 &#39;a&#39; | &#39;x&#39; | &#39;b&#39; | &#39;y&#39;
type KeyT = keyof (A &amp; B);

// 相当于
// keyof (A &amp; B) ≡ keyof A | keyof B

const a: KeyT = &quot;a&quot;; // 正确
const b: KeyT = &quot;x&quot;; // 正确
const c: KeyT = &quot;b&quot;; // 正确
const d: KeyT = &quot;y&quot;; // 正确
const e: KeyT = &quot;m&quot;; // 错误
</code></pre>
<ul>
<li>keyof 取出的是<strong>键名</strong>组成的联合类型，如果想取出<strong>键值</strong>组成的联合类型，可以像下面这样写。</li>
</ul>
<pre><code>type MyObj = &#123;
  foo: number;
  bar: string;
&#125;;

type Keys = keyof MyObj;

type Values = MyObj[Keys]; // number|string

const a: Values = 123; // 正确
const b: Values = &quot;icoding&quot;; // 正确
const c: Values = true; // 错误
</code></pre>
<ul>
<li>Keys 是键名组成的联合类型，而 <code>MyObj[Keys]</code> 会取出每个键名对应的键值类型，组成一个新的联合类型，即 <code>number|string</code></li>
</ul>
<h4 id="keyof-运算符的用途"><a href="#keyof-运算符的用途" class="headerlink" title="keyof 运算符的用途"></a>keyof 运算符的用途</h4><blockquote>
<p>keyof 运算符往往用于精确表达对象的属性类型。</p>
</blockquote>
<ul>
<li>举例来说，取出对象的某个指定属性的值，JavaScript 版本可以写成下面这样。</li>
</ul>
<pre><code>function prop(obj, key) &#123;
  return obj[key];
&#125;
</code></pre>
<ul>
<li>上面这个函数添加类型，只能写成下面这样。</li>
</ul>
<pre><code>function prop(obj: &#123; [p: string]: any &#125;, key: string): any &#123;
  return obj[key];
&#125;
</code></pre>
<p>上面的类型声明有两个问题：</p>
<ul>
<li>一是无法表示参数 <code>key</code> 与 参数 <code>obj</code> 之间的关系</li>
<li>二是返回值类型只能写成 <code>any</code></li>
</ul>
<blockquote>
<p>有了 keyof 以后，就可以解决这两个问题，精确表达返回值类型。</p>
</blockquote>
<pre><code>function prop&lt;Obj, K extends keyof Obj&gt;(obj: Obj, key: K): Obj[K] &#123;
  return obj[key];
&#125;
</code></pre>
<ul>
<li><code>K extends keyof Obj</code> 表示 K 是 Obj 的一个属性名，传入其他字符串会报错</li>
<li>返回值类型<code>Obj[K]</code> 就表示 K 这个属性值的类型</li>
</ul>
<blockquote>
<p>keyof 的另一个用途是用于属性映射，即将一个类型的所有属性逐一映射成其他值。</p>
</blockquote>
<pre><code>type NewProps&lt;Obj&gt; = &#123;
  [Prop in keyof Obj]: boolean;
&#125;;

// 用法
type MyObj = &#123; foo: number &#125;;

// 等于 &#123; foo: boolean; &#125;
type NewObj = NewProps&lt;MyObj&gt;;
</code></pre>
<ul>
<li>类型 NewProps 是类型 Obj 的映射类型，前者继承了后者的所有属性，但是把所有属性值类型都改成了 boolean</li>
</ul>
<blockquote>
<p>下面的例子是去掉 readonly 修饰符</p>
</blockquote>
<pre><code>type Mutable&lt;Obj&gt; = &#123;
  -readonly [Prop in keyof Obj]: Obj[Prop];
&#125;;

// 用法
type MyObj = &#123;
  readonly foo: number;
&#125;;

// 等于 &#123; foo: number; &#125;
type NewObj = Mutable&lt;MyObj&gt;;
</code></pre>
<ul>
<li><code>[Prop in keyof Obj]</code> 是 Obj 类型的所有属性名，<code>-readonly</code> 表示去除这些属性的只读特性</li>
<li>对应地，还有 +readonly 的写法，表示添加只读属性设置</li>
</ul>
<blockquote>
<p>下面的例子是让可选属性变成必有的属性</p>
</blockquote>
<pre><code>type Concrete&lt;Obj&gt; = &#123;
  [Prop in keyof Obj]-?: Obj[Prop];
&#125;;

// 用法
type MyObj = &#123;
  foo?: number;
&#125;;

// 等于 &#123; foo: number; &#125;
type NewObj = Concrete&lt;MyObj&gt;;
</code></pre>
<ul>
<li><code>[Prop in keyof Obj]</code> 后面的 <code>-?</code> 表示去除可选属性设置</li>
<li>对应地，还有 +? 的写法，表示添加可选属性设置</li>
</ul>
<h4 id="in-运算符"><a href="#in-运算符" class="headerlink" title="in 运算符"></a>in 运算符</h4><blockquote>
<p>JavaScript 语言中，in运算符用来确定对象是否包含某个属性名。</p>
</blockquote>
<pre><code>const obj = &#123; a: 123 &#125;;

if (&quot;a&quot; in obj) &#123;
  console.log(&quot;找到了 a&quot;);
&#125;
</code></pre>
<ul>
<li>in 运算符用来判断对象 obj 是否包含属性 a</li>
</ul>
<blockquote>
<p>in运算符的左侧是一个字符串，表示属性名，右侧是一个对象。它的返回值是一个布尔值。</p>
</blockquote>
<ul>
<li>TypeScript 语言的类型运算中，<code>in</code>运算符有不同的用法，用来取出（遍历）联合类型的每一个成员类型。</li>
</ul>
<pre><code>type U = &quot;a&quot; | &quot;b&quot; | &quot;c&quot;;

type Foo = &#123;
  [Prop in U]: number;
&#125;;

// 等同于
type Foo = &#123;
  a: number;
  b: number;
  c: number;
&#125;;
</code></pre>
<ul>
<li><code>[Prop in U]</code> 表示依次取出联合类型 U 的每一个成员</li>
</ul>
<h4 id="方括号运算符"><a href="#方括号运算符" class="headerlink" title="方括号运算符"></a>方括号运算符</h4><blockquote>
<p>方括号运算符（<code>[]</code>）用于取出对象的<strong>键值类型</strong>，比如<code>T[K]</code>会返回对象<code>T</code>的属性<code>K</code>的类型</p>
</blockquote>
<pre><code>type Person = &#123;
  age: number;
  name: string;
  alive: boolean;
&#125;;

// Age 的类型是 number
type Age = Person[&quot;age&quot;];

// Person[&#39;age&#39;] 返回属性 age 的类型，本例是 number
</code></pre>
<blockquote>
<p>方括号的参数如果是联合类型，那么返回的也是联合类型。</p>
</blockquote>
<pre><code>type Person = &#123;
  age: number;
  name: string;
  alive: boolean;
&#125;;

// number|string
type T = Person[&quot;age&quot; | &quot;name&quot;];

// number|string|boolean
type A = Person[keyof Person];

// 方括号里面是属性名的联合类型，所以返回的也是对应的属性值的联合类型

// 如果访问不存在的属性，会报错
type T1 = Person[&quot;notExisted&quot;]; // 报错
</code></pre>
<blockquote>
<p>方括号运算符的参数也可以是属性名的索引类型。</p>
</blockquote>
<pre><code>type Obj = &#123;
  [key: string]: number;
&#125;;

// number
type T = Obj[string];
</code></pre>
<ul>
<li>Obj 的属性名是字符串的索引类型，所以可以写成 <code>Obj[string]</code>，代表所有字符串属性名，返回的就是它们的类型 <code>number</code></li>
</ul>
<blockquote>
<p>这个语法对于数组也适用，可以使用<code>number</code>作为方括号的参数。</p>
</blockquote>
<pre><code>// MyArray 的类型是 &#123; [key:number]: string &#125;
const MyArray = [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;];

// 等同于 (typeof MyArray)[number]
// 返回 string
type Person = typeof MyArray[number];
</code></pre>
<ul>
<li>MyArray 是一个数组，它的类型实际上是属性名的数值索引，而 <code>typeof MyArray[number]</code> 的typeof 运算优先级高于方括号</li>
<li>所以返回的是所有数值键名的键值类型 string</li>
</ul>
<blockquote>
<p>注意，方括号里面不能有值的运算。</p>
</blockquote>
<pre><code>// 示例一
const key = &#39;age&#39;;
type Age = Person[key]; // 报错

// 示例二
type Age = Person[&#39;a&#39; + &#39;g&#39; + &#39;e&#39;]; // 报错
</code></pre>
<ul>
<li>这两个示例，方括号里面都涉及值的运算，编译时不会进行这种运算，所以会报错</li>
</ul>
<h4 id="extends-条件运算符"><a href="#extends-条件运算符" class="headerlink" title="extends...?: 条件运算符"></a><code>extends...?:</code> 条件运算符</h4><blockquote>
<p>TypeScript 提供类似JavaScript 的<code>?:</code>运算符这样的三元运算符，但多出了一个<code>extends</code>关键字。</p>
</blockquote>
<blockquote>
<p>条件运算符<code>extends...?:</code>可以根据当前类型是否符合某种条件，返回不同的类型。</p>
</blockquote>
<pre><code>T extends U ? X : Y
</code></pre>
<ul>
<li>extends 用来判断，类型 T 是否可以赋值给类型 U，即 T 是否为 U 的子类型，这里的 T 和 U 可以是任意类型</li>
<li>如果T能够赋值给类型U，表达式的结果为类型X，否则结果为类型Y</li>
</ul>
<pre><code>// true
type T = 1 extends number ? true : false;

// 1 是 number 的子类型，所以返回 true
</code></pre>
<ol>
<li>实践应用</li>
</ol>
<pre><code>interface Animal &#123;
  live(): void;
&#125;
interface Dog extends Animal &#123;
  woof(): void;
&#125;

// number
type T1 = Dog extends Animal ? number : string;

// string
type T2 = RegExp extends Animal ? number : string;

// Dog 是 Animal 的子类型，所以 T1 的类型是 number
// RegExp 不是 Animal 的子类型，所以 T2 的类型是 string
</code></pre>
<blockquote>
<p>一般来说，调换<code>extends</code>两侧类型，会返回相反的结果。</p>
</blockquote>
<ul>
<li>举例来说，有两个类Cat和Animal，前者是后者的子类型，那么<code>Cat extends Animal</code>就为真，而A<code>nimal extends Cat</code>就为伪。</li>
</ul>
<ol start="2">
<li>判断联合类型<blockquote>
<p>如果需要判断的类型是一个联合类型，那么条件运算符会展开这个联合类型。</p>
</blockquote>
</li>
</ol>
<pre><code>(A|B) extends U ? X : Y

// 等同于

(A extends U ? X : Y) | (B extends U ? X : Y)
</code></pre>
<ul>
<li><code>A|B</code> 是一个联合类型，进行条件运算时，相当于 A 和 B 分别进行运算符，返回结果组成一个联合类型</li>
<li>如果不希望联合类型被条件运算符展开，可以把<code>extends</code>两侧的操作数都放在方括号里面。</li>
</ul>
<pre><code>// 示例一
type ToArray&lt;Type&gt; = Type extends any ? Type[] : never;

// string[]|number[]
type T = ToArray&lt;string | number&gt;;

// 示例二
type ToArray&lt;Type&gt; = [Type] extends [any] ? Type[] : never;

// (string | number)[]
type T = ToArray&lt;string | number&gt;;
</code></pre>
<ul>
<li>传入 <code>ToArray&lt;Type&gt;</code> 的类型参数是一个联合类型，所以会被展开，返回的也是联合类型</li>
<li>示例二是 <code>extends</code> 两侧的运算数都放在方括号里面，所以传入的联合类型不会展开，返回的是一个数组</li>
</ul>
<blockquote>
<p>条件运算符还可以嵌套使用。</p>
</blockquote>
<pre><code>type LiteralTypeName&lt;T&gt; = T extends undefined
  ? &quot;undefined&quot;
  : T extends null
  ? &quot;null&quot;
  : T extends boolean
  ? &quot;boolean&quot;
  : T extends number
  ? &quot;number&quot;
  : T extends bigint
  ? &quot;bigint&quot;
  : T extends string
  ? &quot;string&quot;
  : never;
</code></pre>
<ul>
<li>上面示例是一个多重判断，返回一个字符串的值类型，对应当前类型。下面是它的用法。</li>
</ul>
<pre><code>// 以上类型的用法

// &quot;bigint&quot;
type Result1 = LiteralTypeName&lt;123n&gt;;

// &quot;string&quot; | &quot;number&quot; | &quot;boolean&quot;
type Result2 = LiteralTypeName&lt;true | 1 | &quot;a&quot;&gt;;
</code></pre>
<h4 id="infer-关键字"><a href="#infer-关键字" class="headerlink" title="infer 关键字"></a>infer 关键字</h4><blockquote>
<p><code>infer</code>关键字用来定义泛型里面推断出来的类型参数，而不是外部传入的类型参数</p>
</blockquote>
<blockquote>
<p>它通常跟条件运算符一起使用，用在<code>extends</code>关键字后面的父类型之中。</p>
</blockquote>
<pre><code>type Foo&lt;Type&gt; = Type extends Array&lt;infer Item&gt; ? Item : Type;
</code></pre>
<ul>
<li><code>infer Item</code> 表示 Item 这个参数是 TypeScript 自己根据Type推断出来的，不用显式传入，<code>Foo&lt;Type&gt;</code> 则表示 Type 这个类型参数是外部传入的</li>
<li><code>Type extends Array&lt;infer Item&gt;</code> 则表示，如果参数 Type 是一个数组，那么就将该数组的成员类型推断为 Item，即 Item 是从 Type 推断出来的</li>
</ul>
<blockquote>
<p>一旦使用<code>Infer Item</code>定义了Item，后面的代码就可以直接调用Item了。下面是上例的泛型<code>Foo&lt;Type&gt;</code>的用法。</p>
</blockquote>
<pre><code>type Foo&lt;Type&gt; = Type extends Array&lt;infer Item&gt; ? Item : Type;

// 以下是 泛型 Foo&lt;Type&gt; 的用法

// string
type Str = Foo&lt;string[]&gt;;

// number
type Num = Foo&lt;number&gt;;
</code></pre>
<ul>
<li>第一个例子 <code>Foo&lt;string[]&gt;</code> 传入的类型参数是 <code>string[]</code>，可以推断出 Item 的类型是 string，所以返回的是 string</li>
<li>第二个例子 <code>Foo&lt;number&gt;</code> 传入的类型参数是 <code>number</code>，它不是数组，所以直接返回自身</li>
</ul>
<blockquote>
<p>如果不用infer定义类型参数，那么就要传入两个类型参数。</p>
</blockquote>
<pre><code>type Foo&lt;Type, Item&gt; = Type extends Array&lt;Item&gt; ? Item : Type;
</code></pre>
<ul>
<li><p>上面是不使用 infer 的写法，每次调用 Foo 的时候，都要传入两个参数，就比较麻烦</p>
</li>
<li><p>下面的例子使用infer，推断函数的参数类型和返回值类型。</p>
</li>
</ul>
<pre><code>type ReturnPromise&lt;T&gt; = T extends (...args: infer A) =&gt; infer R
  ? (...args: A) =&gt; Promise&lt;R&gt;
  : T;
</code></pre>
<ul>
<li>如果 T 不是函数，就返回这个函数的 Promise 版本，否则原样返回</li>
<li>infer A 表示该函数的参数类型为 A，infer R 表示该函数的返回值类型为 R</li>
</ul>
<blockquote>
<p>如果不使用<code>infer</code>，就不得不把<code>ReturnPromise&lt;T&gt;</code>写成<code>ReturnPromise&lt;T, A, R&gt;</code>，这样就很麻烦，相当于开发者必须人肉推断编译器可以完成的工作。</p>
</blockquote>
<blockquote>
<p>下面是infer提取对象指定属性的例子。</p>
</blockquote>
<pre><code>type MyType&lt;T&gt; = T extends &#123;
  a: infer M;
  b: infer N;
&#125;
  ? [M, N]
  : never;

// 用法示例
type T = MyType&lt;&#123; a: string; b: number &#125;&gt;;
// [string, number]
</code></pre>
<ul>
<li>infer 提取了参数对象的属性 a 和 属性 b 的类型</li>
</ul>
<blockquote>
<p>下面是infer通过正则匹配提取类型参数的例子。</p>
</blockquote>
<pre><code>type Str = &quot;foo-bar&quot;;

type Bar = Str extends `foo-$&#123;infer rest&#125;` ? rest : never; // &#39;bar&#39;
</code></pre>
<ul>
<li>rest 是从模板字符串提取的类型参数</li>
</ul>
<h4 id="is-运算符"><a href="#is-运算符" class="headerlink" title="is 运算符"></a>is 运算符</h4><blockquote>
<p>函数返回布尔值的时候，可以使用is运算符，限定返回值与参数之间的关系。</p>
<ul>
<li>is运算符用来描述返回值属于true还是false。</li>
</ul>
</blockquote>
<pre><code>function isFish(pet: Fish | Bird): pet is Fish &#123;
  return (pet as Fish).swim !== undefined;
&#125;
</code></pre>
<ul>
<li>函数 <code>isFish()</code> 的返回值类型为 <code>pet is Fish</code> ，表示如果参数 pet 类型为 Fish，则返回 true，否则返回 false。</li>
</ul>
<blockquote>
<p>is运算符总是用于描述函数的返回值类型，写法采用<code>parameterName is Type</code>的形式，即左侧为当前函数的参数名，右侧为某一种类型。它返回一个布尔值，表示左侧参数是否属于右侧的类型。</p>
</blockquote>
<pre><code>type A = &#123; a: string &#125;;
type B = &#123; b: string &#125;;

function isTypeA(x: A | B): x is A &#123;
  if (&quot;a&quot; in x) return true;
  return false;
&#125;
</code></pre>
<ul>
<li>返回值类型 x is A 可以准确描述函数体内部的运算逻辑</li>
</ul>
<blockquote>
<p>is运算符可以用于类型保护。</p>
</blockquote>
<pre><code>function isCat(a: any): a is Cat &#123;
  return a.name === &quot;kitty&quot;;
&#125;

let x: Cat | Dog;

if (isCat(x)) &#123;
  x.meow(); // 正确，因为 x 肯定是 Cat 类型
&#125;
</code></pre>
<ul>
<li>函数 isCat() 的返回类型是 a is Cat ，它是一个布尔值。</li>
<li>后面的 if 语句就用这个返回值进行判断，从而起到类型保护的作用，确保 x 是 Cat 类型，从而 <code>x.meow()</code> 不会报错（假定 Cat 类型拥有 meow() 方法）</li>
</ul>
<blockquote>
<p>is运算符还有一种特殊用法，就是用在类（class）的内部，描述类的方法的返回值。</p>
</blockquote>
<pre><code>class Teacher &#123;
  isStudent(): this is Student &#123;
    return false;
  &#125;
&#125;

class Student &#123;
  isStudent(): this is Student &#123;
    return true;
  &#125;
&#125;
</code></pre>
<ul>
<li><code>isStudent()</code>方法的返回值类型，取决于该方法内部的 this 是否为 Student 对象</li>
<li>如果是的，就返回布尔值 true ，否则返回 false</li>
</ul>
<blockquote>
<p>注意：<code>this is T</code>这种写法，只能用来描述方法的返回值类型，而不能用来描述属性的类型。</p>
</blockquote>
<h4 id="模板字符串"><a href="#模板字符串" class="headerlink" title="模板字符串"></a>模板字符串</h4><blockquote>
<p>TypeScript 允许使用模板字符串，构建类型。</p>
</blockquote>
<blockquote>
<p>模板字符串的最大特点，就是内部可以引用其他类型。</p>
</blockquote>
<pre><code>type World = &quot;world&quot;;

// &quot;hello world&quot;
type Greeting = `hello $&#123;World&#125;`;
</code></pre>
<ul>
<li>类型<code>Greeting</code>是一个模板字符串，里面引用了另一个字符串类型 world</li>
<li>因此<code>Greeting</code>实际上是字符串 hello world</li>
</ul>
<blockquote>
<p>注意，模板字符串可以引用的类型一共 6 种，分别是 <code>string</code>、<code>number</code>、<code>bigint</code>、<code>boolean</code>、<code>null</code>、<code>undefined</code>。引用这 6 种以外的类型会报错。</p>
</blockquote>
<pre><code>type Num = 123;
type Obj = &#123; n: 123 &#125;;

type T1 = `$&#123;Num&#125; received`; // 正确
type T2 = `$&#123;Obj&#125; received`; // 报错
</code></pre>
<ul>
<li>模板字符串引用数值类型的别名 Num 是可以的，但是引用对象类型的别名 Obj 就会报错</li>
</ul>
<blockquote>
<p>模板字符串里面引用的类型，如果是<strong>一个联合类型</strong>，那么它返回的也是一个联合类型，即模板字符串可以展开联合类型。</p>
</blockquote>
<pre><code>type T = &quot;A&quot; | &quot;B&quot;;

// &quot;A_id&quot;|&quot;B_id&quot;
type U = `$&#123;T&#125;_id`;

// 类型 U 是一个模板字符串，里面引用了一个联合类型 T ，导致最后得到的也是一个联合类型
</code></pre>
<blockquote>
<p>如果模板字符串引用<strong>两个联合类型</strong>，它会交叉展开这两个类型。</p>
</blockquote>
<pre><code>type T = &quot;A&quot; | &quot;B&quot;;

type U = &quot;1&quot; | &quot;2&quot;;

// &#39;A1&#39;|&#39;A2&#39;|&#39;B1&#39;|&#39;B2&#39;
type V = `$&#123;T&#125;$&#123;U&#125;`;
</code></pre>
<ul>
<li>T 和 U 都是联合类型，各自有两个成员，模板字符串里面引用了这两个类型，最后得到的就是一个 4 个成员的联合类型。</li>
</ul>
<h4 id="satisfies-运算符"><a href="#satisfies-运算符" class="headerlink" title="satisfies 运算符"></a>satisfies 运算符</h4><blockquote>
<p><code>satisfies</code>运算符用来检测某个值是否符合指定类型。</p>
</blockquote>
<blockquote>
<p>有时候，不方便将某个值指定为某种类型，但是希望这个值符合类型条件，这时候就可以用<code>satisfies</code>运算符对其进行检测。TypeScript 4.9 添加了这个运算符。</p>
</blockquote>
<p>举例来说，有一个对象的属性名拼写错误。</p>
<pre><code>const palette = &#123;
  red: [255, 0, 0],
  green: &quot;#00ff00&quot;,
  bleu: [0, 0, 255], // 属性名拼写错误
&#125;;
</code></pre>
<ul>
<li>上面示例中，对象<code>palette</code>的属性名拼写错了，将blue拼成了bleu，我们希望通过指定类型，发现这个错误。</li>
</ul>
<pre><code>type Colors = &quot;red&quot; | &quot;green&quot; | &quot;blue&quot;;
type RGB = [number, number, number];

const palette: Record&lt;Colors, string | RGB&gt; = &#123;
  red: [255, 0, 0],
  green: &quot;#00ff00&quot;,
  bleu: [0, 0, 255], // 报错
&#125;;
</code></pre>
<ul>
<li>变量 palette 的类型被指定为 <code>Record&lt;Colors, string|RGB&gt;</code> ，这是一个类型工具，用来返回一个对象，详细介绍见《类型工具》一章</li>
<li>简单说，它的第一个类型参数指定对象的属性名，第二个类型参数指定对象的属性值。</li>
<li>本例的<code>Record&lt;Colors, string|RGB&gt;</code>，就表示变量<code>palette</code>的属性名应该符合类型<code>Colors</code>，属性值应该符合类型<code>string|RGB</code>，要么是字符串，要么是元组RGB。属性名<code>bleu</code>不符合类型<code>Colors</code>，所以就报错了。</li>
</ul>
<blockquote>
<p>这样的写法，虽然可以发现属性名的拼写错误，但是带来了新的问题。</p>
</blockquote>
<pre><code>const greenComponent = palette.green.substring(1, 6); // 报错
</code></pre>
<ul>
<li><code>palette.green</code>属性调用 <code>substring()</code> 方法会报错</li>
<li>原因是这个方法只有字符串才有，而 <code>palette.green</code> 的类型是 <code>srting | RGB</code> ，除了字符串，还可能是元组 <code>RGB</code> ，而元组并不存在 <code>substring()</code> 方法，所以报错了</li>
</ul>
<blockquote>
<p>如果要避免报错，要么精确给出变量<code>palette</code>每个属性的类型，要么对<code>palette.green</code>的值进行类型缩小。两种做法都比较麻烦，也不是很有必要。</p>
<ul>
<li>这时就可以使用<code>satisfies</code>运算符，对<code>palette</code>进行类型检测，但是不改变 TypeScript 对palette的类型推断。</li>
</ul>
</blockquote>
<pre><code>type Colors = &quot;red&quot; | &quot;green&quot; | &quot;blue&quot;;
type RGB = [number, number, number];

const palette = &#123;
  red: [255, 0, 0],
  green: &quot;#00ff00&quot;,
  bleu: [0, 0, 255] // 报错
&#125; satisfies Record&lt;Colors, string|RGB&gt;;

const greenComponent = palette.green.substring(1); // 不报错
</code></pre>
<ul>
<li>变量 palette 的值后面增加了<code>satisfies Record&lt;Colors, string|RGB&gt;</code> ，表示该值必须满足 <code>Record&lt;Colors, string|RGB&gt;</code> 这个条件，所以能够检测出属性名 bleu 的拼写错误。</li>
<li>同时，它<strong>不会改变</strong><code>palette</code> 的类型推断，所以，TypeScript 知道 <code>palette.green</code> 是一个字符串，对其调用 <code>substring()</code> 方法就不会报错。</li>
</ul>
<blockquote>
<p>satisfies也可以检测属性值。</p>
</blockquote>
<pre><code>const palette = &#123;
  red: [255, 0, 0],
  green: &quot;#00ff00&quot;,
  blue: [0, 0] // 报错
&#125; satisfies Record&lt;Colors, string|RGB&gt;;
</code></pre>
<ul>
<li>属性 blue 的值只有两个成员，不符合元组 RGB 必须有三个成员的条件，从而报错了</li>
</ul>
<h3 id="六、类型映射"><a href="#六、类型映射" class="headerlink" title="六、类型映射"></a>六、类型映射</h3><blockquote>
<p>映射（mapping）指的是，将一种类型按照映射规则，转换成另一种类型，通常用于对象类型</p>
<ul>
<li>举例来说，现有一个类型 A 和另一个类型 B。</li>
</ul>
</blockquote>
<pre><code>type A = &#123;
  foo: number;
  bar: number;
&#125;;

type B = &#123;
  foo: string;
  bar: string;
&#125;;
</code></pre>
<ul>
<li>这两个类型的属性结构是一样的，但是属性的类型不一样</li>
<li>如果属性数量多的话，逐个写起来就很麻烦</li>
</ul>
<h4 id="类型映射语法"><a href="#类型映射语法" class="headerlink" title="类型映射语法"></a>类型映射语法</h4><blockquote>
<p>使用类型映射，就可以从类型A得到类型B</p>
</blockquote>
<pre><code>type A = &#123;
  foo: number;
  bar: number;
&#125;;

type B = &#123;
  [prop in keyof A]: string;
&#125;;
</code></pre>
<ul>
<li>类型 B 采用了属性名索引的写法，<code>[prop in keyof A]</code> 表示依次得到类型 A 的所有属性名，然后将每个属性的类型改成 <code>string</code></li>
</ul>
<blockquote>
<p>在语法上，<code>[prop in keyof A]</code>是一个属性名表达式，表示这里的属性名需要计算得到。具体的计算规则如下：</p>
</blockquote>
<ul>
<li>prop：属性名变量，名字可以随便起。</li>
<li>in：运算符，用来取出右侧的联合类型的每一个成员。</li>
<li>keyof A：返回类型A的每一个属性名，组成一个联合类型</li>
</ul>
<ol>
<li>复制原始类型</li>
</ol>
<pre><code>type A = &#123;
  foo: number;
  bar: string;
&#125;;

type B = &#123;
  [prop in keyof A]: A[prop];
&#125;;
</code></pre>
<ul>
<li>类型 B 原样复制了类型 A</li>
</ul>
<ol start="2">
<li>映射类型的泛型写法<blockquote>
<p>为了增加代码复用性，可以把常用的映射写成泛型。</p>
</blockquote>
</li>
</ol>
<pre><code>type ToBoolean&lt;Type&gt; = &#123;
  [Property in keyof Type]: boolean;
&#125;;
</code></pre>
<ul>
<li>定义了一个泛型，可以将其他对象的所有属性值都改成 boolean 类型</li>
</ul>
<ol start="3">
<li>实践应用</li>
</ol>
<pre><code>type MyObj = &#123;
  [P in 0 | 1 | 2]: string;
&#125;;

// 等同于
type MyObj = &#123;
  0: string;
  1: string;
  2: string;
&#125;;
</code></pre>
<ul>
<li>联合类型 <code>0|1|2</code> 映射成了三个属性名</li>
</ul>
<blockquote>
<p>不使用联合类型，直接使用某种具体类型进行属性名映射，也是可以的。</p>
</blockquote>
<pre><code>type MyObj = &#123;
  [p in &quot;foo&quot;]: number;
&#125;;

// 等同于
type MyObj = &#123;
  foo: number;
&#125;;
</code></pre>
<ul>
<li><code>p in &#39;foo&#39;</code>可以看成只有一个成员的联合类型，因此得到了只有这一个属性的对象类型</li>
<li>甚至还可以写成<code>p in string</code></li>
</ul>
<pre><code>type MyObj = &#123;
  [p in string]: boolean;
&#125;;

// 等同于
type MyObj = &#123;
  [p: string]: boolean;
&#125;;
</code></pre>
<ul>
<li><code>[p in string]</code>就是属性名索引形式<code>[p: string]</code>的映射写法</li>
</ul>
<blockquote>
<p>通过映射，可以把某个对象的所有属性改成可选属性。</p>
</blockquote>
<pre><code>type A = &#123;
  a: string;
  b: number;
&#125;;

type B = &#123;
  [Prop in keyof A]?: A[Prop];
&#125;;
</code></pre>
<ul>
<li>类型 B 在类型 A 的所有属性名后面添加问号，使得这些属性都变成了可选属性</li>
</ul>
<blockquote>
<p>事实上，TypeScript 的内置工具类型<code>Partial&lt;T&gt;</code>，就是这样实现的</p>
<ul>
<li>TypeScript 内置的工具类型<code>Readonly&lt;T&gt;</code>可以将所有属性改为只读属性，实现也是通过映射。</li>
</ul>
</blockquote>
<pre><code>// 将 T 的所有属性改为只读属性
type Readonly&lt;T&gt; = &#123;
  readonly [P in keyof T]: T[P];
&#125;;
</code></pre>
<ul>
<li>具体用法</li>
</ul>
<pre><code>type T = &#123; a: string; b: number &#125;;

type ReadonlyT = Readonly&lt;T&gt;;
// &#123;
//   readonly a: string;
//   readonly b: number;
// &#125;
</code></pre>
<h4 id="映射修饰符"><a href="#映射修饰符" class="headerlink" title="映射修饰符"></a>映射修饰符</h4><blockquote>
<p>映射会原样复制原始对象的可选属性和只读属性。</p>
</blockquote>
<pre><code>type A = &#123;
  a?: string;
  readonly b: number;
&#125;;

type B = &#123;
  [Prop in keyof A]: A[Prop];
&#125;;

// 等同于
type B = &#123;
  a?: string;
  readonly b: number;
&#125;;
</code></pre>
<ul>
<li>类型 B 是类型 A 的映射，把 A 的可选属性和只读属性都保留下来</li>
</ul>
<blockquote>
<p>如果要删改可选和只读这两个特性，并不是很方便。为了解决这个问题，TypeScript 引入了两个映射修饰符，用来在映射时添加或移除某个属性的<code>?</code>修饰符和<code>readonly</code>修饰符。</p>
</blockquote>
<ul>
<li><code>+</code>修饰符：写成<code>+?</code>或<code>+readonly</code>，为映射属性添加<code>?</code>修饰符或<code>readonly</code>修饰符。</li>
<li><code>–</code>修饰符：写成<code>-?</code>或<code>-readonly</code>，为映射属性移除<code>?</code>修饰符或<code>readonly</code>修饰符。</li>
</ul>
<blockquote>
<p>以下是添加或移除可选属性的案例</p>
</blockquote>
<pre><code>// 添加可选属性
type Optional&lt;Type&gt; = &#123;
  [Prop in keyof Type]+?: Type[Prop];
&#125;;

// 移除可选属性
type Concrete&lt;Type&gt; = &#123;
  [Prop in keyof Type]-?: Type[Prop];
&#125;;
</code></pre>
<ul>
<li>注意：<code>+?</code>或<code>-?</code>要<strong>写在属性名的后面</strong></li>
</ul>
<blockquote>
<p>以下是添加或移除只读属性的案例</p>
</blockquote>
<pre><code>// 添加 readonly
type CreateImmutable&lt;Type&gt; = &#123;
  +readonly [Prop in keyof Type]: Type[Prop];
&#125;;

// 移除 readonly
type CreateMutable&lt;Type&gt; = &#123;
  -readonly [Prop in keyof Type]: Type[Prop];
&#125;;
</code></pre>
<ul>
<li>注意：<code>+readonly</code>和<code>-readonly</code>要<strong>写在属性名的前面</strong></li>
</ul>
<blockquote>
<p>如果同时增删<code>?</code>和<code>readonly</code>这两个修饰符，写成下面这样。</p>
</blockquote>
<pre><code>// 增加
type MyObj&lt;T&gt; = &#123;
  +readonly [P in keyof T]+?: T[P];
&#125;;

// 移除
type MyObj&lt;T&gt; = &#123;
  -readonly [P in keyof T]-?: T[P];
&#125;;
</code></pre>
<blockquote>
<p>TypeScript 原生的工具类型<code>Required&lt;T&gt;</code>专门移除可选属性，就是使用<code>-?</code>修饰符实现的。</p>
<ul>
<li>注意：<code>–?</code>修饰符移除了可选属性以后，该属性就不能等于<code>undefined</code>了，实际变成必选属性了。但是，这个修饰符不会移除<code>null</code>类型。</li>
<li>另外，<code>+?</code>修饰符可以简写成<code>?</code>，<code>+readonly</code>修饰符可以简写成<code>readonly</code></li>
</ul>
</blockquote>
<pre><code>type A&lt;T&gt; = &#123;
  +readonly [P in keyof T]+?: T[P];
&#125;;

// 等同于
type A&lt;T&gt; = &#123;
  readonly [P in keyof T]?: T[P];
&#125;;
</code></pre>
<h4 id="键名重映射"><a href="#键名重映射" class="headerlink" title="键名重映射"></a>键名重映射</h4><blockquote>
<p>TypeScript 4.1 引入了键名重映射（key remapping），允许改变键名</p>
</blockquote>
<blockquote>
<p>具体语法如下</p>
</blockquote>
<pre><code>type A = &#123;
  foo: number;
  bar: number;
&#125;;

type B = &#123;
  [p in keyof A as `$&#123;p&#125;ID`]: number;
&#125;;

// 等同于
type B = &#123;
  fooID: number;
  barID: number;
&#125;;
</code></pre>
<ul>
<li>类型 B 是类型 A 的映射，但在映射时把属性名改掉了，在原始属性名后面加上了字符串 ID</li>
</ul>
<blockquote>
<p>可以看到，键名重映射的语法是在键名映射的后面加上<code>as + 新类型</code>子句。这里的“新类型”通常是一个模板字符串，里面可以对原始键名进行各种操作。</p>
</blockquote>
<pre><code>interface Person &#123;
  name: string;
  age: number;
  location: string;
&#125;

type Getters&lt;T&gt; = &#123;
  [P in keyof T as `get$&#123;Capitalize&lt;string &amp; P&gt;&#125;`]: () =&gt; T[P];
&#125;;

type LazyPerson = Getters&lt;Person&gt;;

// 等同于
type LazyPerson = &#123;
  getName: () =&gt; string;
  getAge: () =&gt; number;
  getLocation: () =&gt; string;
&#125;;
</code></pre>
<ul>
<li>类型 <code>LazyPerson</code> 是类型 Person 的映射，并且把键名改掉了</li>
</ul>
<blockquote>
<p>注：它的修改键名的代码是一个模板字符串<code>get$&#123;Capitalize&lt;string &amp; P&gt;&#125;</code>，下面是各个部分的解释。</p>
</blockquote>
<ul>
<li><code>get</code>：为键名添加的前缀。</li>
<li><code>Capitalize&lt;T&gt;</code>：一个原生的工具泛型，用来将T的首字母变成大写。</li>
<li><code>string &amp; P</code>：一个交叉类型，其中的<code>P</code>是 <code>keyof</code> 运算符返回的键名联合类型<code>string|number|symbol</code>，但是<code>Capitalize&lt;T&gt;</code>只能接受字符串作为类型参数，因此<code>string &amp; P</code>只返回P的字符串属性名。</li>
</ul>
<ol>
<li>属性过滤<blockquote>
<p>键名重映射还可以过滤掉某些属性。下面的例子是只保留字符串属性。</p>
</blockquote>
</li>
</ol>
<pre><code>type User = &#123;
  name: string;
  age: number;
&#125;;

type Filter&lt;T&gt; = &#123;
  [K in keyof T as T[K] extends string ? K : never]: string;
&#125;;

type FilteredUser = Filter&lt;User&gt;; // &#123; name: string &#125;
</code></pre>
<ul>
<li>映射 <code>K in keyof T</code> 获取类型T的每一个属性以后，然后使用 <code>as Type</code> 修改键名</li>
</ul>
<blockquote>
<p>注：它的键名重映射<code>as T[K] extends string ? K : never</code>，使用了条件运算符。如果属性值<code>T[K]</code>的类型是字符串，那么属性名不变，否则属性名类型改为<code>never</code>，即这个属性名不存在。</p>
</blockquote>
<ul>
<li>这样就等于过滤了不符合条件的属性，只保留属性值为字符串的属性。</li>
</ul>
<ol start="2">
<li>联合类型的映射<blockquote>
<p>由于键名重映射可以修改键名类型，所以原始键名的类型不必是<code>string|number|symbol</code>，任意的联合类型都可以用来进行键名重映射。</p>
</blockquote>
</li>
</ol>
<pre><code>type S = &#123;
  kind: &quot;square&quot;;
  x: number;
  y: number;
&#125;;

type C = &#123;
  kind: &quot;circle&quot;;
  radius: number;
&#125;;

type MyEvents&lt;Events extends &#123; kind: string &#125;&gt; = &#123;
  [E in Events as E[&quot;kind&quot;]]: (event: E) =&gt; void;
&#125;;

type Config = MyEvents&lt;S | C&gt;;

// 等同于
type Config = &#123;
  square: (event: S) =&gt; void;
  circle: (event: C) =&gt; void;
&#125;;
</code></pre>
<ul>
<li>原始键名的映射是 <code>E in Events</code>，这里的 <code>Events</code> 是两个对象组成的联合类型 <code>S|C</code></li>
<li>所以，E 是一个对象，然后再通过键名重映射，得到字符串键名 <code>E[&#39;kind&#39;]</code></li>
</ul>
<h3 id="七、TypeScript-类型工具"><a href="#七、TypeScript-类型工具" class="headerlink" title="七、TypeScript 类型工具"></a>七、TypeScript 类型工具</h3><blockquote>
<p><code>peScript</code>提供了一些内置的类型工具，用来方便地处理各种类型，以及生成新的类型。</p>
<ul>
<li>以下是常用的类型工具</li>
</ul>
</blockquote>
<h4 id="Awaited"><a href="#Awaited" class="headerlink" title="Awaited&lt;Type&gt;"></a><code>Awaited&lt;Type&gt;</code></h4><blockquote>
<p><code>Awaited&lt;Type&gt;</code>用来取出 <code>Promise</code> 的返回值类型，适合用在描述<code>then()</code>方法和 <code>await</code> 命令的参数类型。</p>
</blockquote>
<pre><code>type A = Awaited&lt;Promise&lt;string&gt;&gt;; // string
</code></pre>
<ul>
<li><code>Awaited&lt;Type&gt;</code>会返回 Promise 的返回值类型（string）</li>
</ul>
<blockquote>
<p>它也可以返回多重 <code>Promise</code> 的返回值类型</p>
</blockquote>
<pre><code>type B = Awaited&lt;Promise&lt;Promise&lt;number&gt;&gt;&gt;; // number
</code></pre>
<blockquote>
<p>如果它的类型参数不是 <code>Promise</code> 类型，那么就会原样返回</p>
</blockquote>
<pre><code>type C = Awaited&lt;boolean | Promise&lt;number&gt;&gt;; // number | boolean
</code></pre>
<ul>
<li>类型参数是一个联合类型，其中的 boolean 会原样返回，所以最终返回的是<code>number|boolean</code></li>
</ul>
<blockquote>
<p><code>Awaited&lt;Type&gt;</code>的实现如下</p>
</blockquote>
<pre><code>type Awaited&lt;T&gt; = T extends null | undefined
  ? T
  : T extends object &amp; &#123; then(onfulfilled: infer F): any &#125;
  ? F extends (value: infer V, ...args: any) =&gt; any
    ? Awaited&lt;V&gt;
    : never
  : T;
</code></pre>
<h4 id="ConstructorParameters"><a href="#ConstructorParameters" class="headerlink" title="ConstructorParameters"></a>ConstructorParameters<Type></h4><blockquote>
<p><code>ConstructorParameters&lt;Type&gt;</code>提取构造方法<code>Type</code>的参数类型，组成一个元组类型返回</p>
</blockquote>
<pre><code>type T1 = ConstructorParameters&lt;new (x: string, y: number) =&gt; object&gt;; // [x: string, y: number]

type T2 = ConstructorParameters&lt;new (x?: string) =&gt; object&gt;; // [x?: string | undefined]
</code></pre>
<blockquote>
<p>它可以返回一些内置构造方法的参数类型。</p>
</blockquote>
<pre><code>type T1 = ConstructorParameters&lt;ErrorConstructor&gt;; // [message?: string]

type T2 = ConstructorParameters&lt;FunctionConstructor&gt;; // string[]

type T3 = ConstructorParameters&lt;RegExpConstructor&gt;; // [pattern:string|RegExp, flags?:string]
</code></pre>
<blockquote>
<p>如果参数类型不是构造方法，就会报错。</p>
</blockquote>
<pre><code>type T1 = ConstructorParameters&lt;string&gt;; // 报错

type T2 = ConstructorParameters&lt;Function&gt;; // 报错
</code></pre>
<blockquote>
<p>any类型和never类型是两个特殊值，分别返回<code>unknown[]</code>和<code>never</code>。</p>
</blockquote>
<pre><code>type T1 = ConstructorParameters&lt;any&gt;; // unknown[]

type T2 = ConstructorParameters&lt;never&gt;; // never
ConstructorParameters&lt;Type&gt;的实现如下

type ConstructorParameters&lt;T extends abstract new (...args: any) =&gt; any&gt; =
  T extends abstract new (...args: infer P) =&gt; any ? P : never;
</code></pre>
<h4 id="Exclude"><a href="#Exclude" class="headerlink" title="Exclude&lt;UnionType, ExcludedMembers&gt;"></a><code>Exclude&lt;UnionType, ExcludedMembers&gt;</code></h4><blockquote>
<p><code>Exclude&lt;UnionType, ExcludedMembers&gt;</code>用来从联合类型<code>UnionType</code>里面，删除某些类型<code>ExcludedMembers</code>，组成一个新的类型返回。</p>
</blockquote>
<pre><code>type T1 = Exclude&lt;&quot;a&quot; | &quot;b&quot; | &quot;c&quot;, &quot;a&quot;&gt;; // &#39;b&#39;|&#39;c&#39;
type T2 = Exclude&lt;&quot;a&quot; | &quot;b&quot; | &quot;c&quot;, &quot;a&quot; | &quot;b&quot;&gt;; // &#39;c&#39;
type T3 = Exclude&lt;string | (() =&gt; void), Function&gt;; // string
type T4 = Exclude&lt;string | string[], any[]&gt;; // string
type T5 = Exclude&lt;(() =&gt; void) | null, Function&gt;; // null
type T6 = Exclude&lt;200 | 500, 200 | 201&gt;; // 500
type T7 = Exclude&lt;number, boolean&gt;; // number
</code></pre>
<blockquote>
<p><code>Exclude&lt;UnionType, ExcludedMembers&gt;</code>的实现如下</p>
</blockquote>
<pre><code>type Exclude&lt;T, U&gt; = T extends U ? never : T;
</code></pre>
<ul>
<li>上面代码中，等号右边的部分，表示先判断T是否兼容U，如果是的就返回never类型，否则返回当前类型T。</li>
<li>由于<code>never</code>类型是任何其他类型的子类型，它跟其他类型组成联合类型时，可以直接将<code>never</code>类型从联合类型中“消掉”，因此<code>Exclude&lt;T, U&gt;</code>就相当于删除兼容的类型，剩下不兼容的类型</li>
</ul>
<h4 id="Extract"><a href="#Extract" class="headerlink" title="Extract&lt;Type, Union&gt;"></a><code>Extract&lt;Type, Union&gt;</code></h4><blockquote>
<p><code>Extract&lt;UnionType, Union&gt;</code>用来从联合类型<code>UnionType</code>之中，提取指定类型<code>Union</code>，组成一个新类型返回。它与<code>Exclude&lt;T, U&gt;</code>正好相反。</p>
</blockquote>
<pre><code>type T1 = Extract&lt;&quot;a&quot; | &quot;b&quot; | &quot;c&quot;, &quot;a&quot;&gt;; // &#39;a&#39;
type T2 = Extract&lt;&quot;a&quot; | &quot;b&quot; | &quot;c&quot;, &quot;a&quot; | &quot;b&quot;&gt;; // &#39;a&#39;|&#39;b&#39;
type T3 = Extract&lt;&quot;a&quot; | &quot;b&quot; | &quot;c&quot;, &quot;a&quot; | &quot;d&quot;&gt;; // &#39;a&#39;
type T4 = Extract&lt;string | string[], any[]&gt;; // string[]
type T5 = Extract&lt;(() =&gt; void) | null, Function&gt;; // () =&gt; void
type T6 = Extract&lt;200 | 500, 200 | 201&gt;; // 200
</code></pre>
<blockquote>
<p>如果参数类型<code>Union</code>不包含在联合类型<code>UnionType</code>之中，则返回<code>never</code>类型。</p>
</blockquote>
<pre><code>type T = Extract&lt;string | number, boolean&gt;; // never
</code></pre>
<blockquote>
<p><code>Extract&lt;UnionType, Union&gt;</code>的实现如下</p>
</blockquote>
<pre><code>type Extract&lt;T, U&gt; = T extends U ? T : never;
</code></pre>
<h4 id="InstanceType"><a href="#InstanceType" class="headerlink" title="InstanceType"></a>InstanceType<Type></h4><blockquote>
<p><code>InstanceType&lt;Type&gt;</code>提取构造函数的返回值的类型（即实例类型），参数<code>Type</code>是一个构造函数，等同于构造函数的<code>ReturnType&lt;Type&gt;</code></p>
</blockquote>
<pre><code>type T = InstanceType&lt;new () =&gt; object&gt;; // object
</code></pre>
<ul>
<li>类型参数是一个构造函数 <code>new () =&gt; object</code>，返回值是该构造函数的实例类型（object）</li>
</ul>
<blockquote>
<p>以下案例</p>
</blockquote>
<pre><code>type A = InstanceType&lt;ErrorConstructor&gt;; // Error
type B = InstanceType&lt;FunctionConstructor&gt;; // Function
type C = InstanceType&lt;RegExpConstructor&gt;; // RegExp
</code></pre>
<ul>
<li><code>InstanceType&lt;T&gt;</code>的参数都是 TypeScript 内置的原生对象的构造函数类型</li>
<li><code>InstanceType&lt;T&gt;</code>的返回值就是这些构造函数的实例类型</li>
</ul>
<blockquote>
<p>由于 Class 作为类型，代表实例类型。要获取它的构造方法，必须把它当成值，然后用<code>typeof</code>运算符获取它的构造方法类型。</p>
</blockquote>
<pre><code>class C &#123;
  x = 1;
  y = 2;
&#125;

type T = InstanceType&lt;typeof C&gt;; // C
</code></pre>
<ul>
<li><code>typeof C</code>是 C 的构造方法类型，然后 <code>InstanceType</code> 就能获得实例类型，即 C 本身</li>
</ul>
<blockquote>
<p>如果类型参数不是构造方法，就会报错。</p>
</blockquote>
<pre><code>type T1 = InstanceType&lt;string&gt;; // 报错

type T2 = InstanceType&lt;Function&gt;; // 报错
</code></pre>
<blockquote>
<p>如果类型参数是<code>any</code>或<code>never</code>两个特殊值，分别返回any和never。</p>
</blockquote>
<pre><code>type T1 = InstanceType&lt;any&gt;; // any

type T2 = InstanceType&lt;never&gt;; // never
</code></pre>
<blockquote>
<p><code>InstanceType&lt;Type&gt;</code>的实现如下</p>
</blockquote>
<pre><code>type InstanceType&lt;T extends abstract new (...args: any) =&gt; any&gt; =
  T extends abstract new (...args: any) =&gt; infer R ? R : any;
</code></pre>
<h4 id="NonNullable"><a href="#NonNullable" class="headerlink" title="NonNullable"></a>NonNullable<Type></h4><blockquote>
<p><code>NonNullable&lt;Type&gt;</code>用来从联合类型<code>Type</code>删除<code>null</code>类型和<code>undefined</code>类型，组成一个新类型返回，也就是返回Type的非空类型版本。</p>
</blockquote>
<pre><code>// string|number
type T1 = NonNullable&lt;string | number | undefined&gt;;

// string[]
type T2 = NonNullable&lt;string[] | null | undefined&gt;;

type T3 = NonNullable&lt;boolean&gt;; // boolean
type T4 = NonNullable&lt;number | null&gt;; // number
type T5 = NonNullable&lt;string | undefined&gt;; // string
type T6 = NonNullable&lt;null | undefined&gt;; // never
</code></pre>
<blockquote>
<p><code>NonNullable&lt;Type&gt;</code>的实现如下</p>
</blockquote>
<pre><code>type NonNullable&lt;T&gt; = T &amp; &#123;&#125;;
</code></pre>
<ul>
<li><code>T &amp; &#123;&#125;</code> 等同于求 <code>T &amp; Object</code> 的交叉类型</li>
<li>由于 TypeScript 的非空值都属于 Object 的子类型，所以会返回自身</li>
<li>而 null 和 undefined 不属于Object，会返回 never 类型</li>
</ul>
<h4 id="Omit"><a href="#Omit" class="headerlink" title="Omit&lt;Type, Keys&gt;"></a><code>Omit&lt;Type, Keys&gt;</code></h4><blockquote>
<p><code>Omit&lt;Type, Keys&gt;</code>用来从对象类型Type中，删除指定的属性Keys，组成一个新的对象类型返回。</p>
</blockquote>
<pre><code>interface A &#123;
  x: number;
  y: number;
&#125;

type T1 = Omit&lt;A, &quot;x&quot;&gt;; // &#123; y: number &#125;
type T2 = Omit&lt;A, &quot;y&quot;&gt;; // &#123; x: number &#125;
type T3 = Omit&lt;A, &quot;x&quot; | &quot;y&quot;&gt;; // &#123; &#125;
</code></pre>
<ul>
<li><code>Omit&lt;Type, Keys&gt;</code>从对象类型A里面删除指定属性，返回剩下的属性</li>
</ul>
<blockquote>
<p>指定删除的键名Keys可以是对象类型Type中不存在的属性，但必须兼容<code>string|number|symbol</code></p>
</blockquote>
<pre><code>interface A &#123;
  x: number;
  y: number;
&#125;

type T = Omit&lt;A, &quot;z&quot;&gt;; // &#123; x: number; y: number &#125;
</code></pre>
<ul>
<li>对象类型 A 中不存在属性 z，所以就原样返回了</li>
</ul>
<blockquote>
<p><code>Omit&lt;Type, Keys&gt;</code>的实现如下</p>
</blockquote>
<pre><code>type Omit&lt;T, K extends keyof any&gt; = Pick&lt;T, Exclude&lt;keyof T, K&gt;&gt;;
</code></pre>
<h4 id="OmitThisParameter"><a href="#OmitThisParameter" class="headerlink" title="OmitThisParameter"></a>OmitThisParameter<Type></h4><blockquote>
<p><code>OmitThisParameter&lt;Type&gt;</code>从函数类型中移除 this 参数</p>
</blockquote>
<pre><code>function toHex(this: Number) &#123;
  return this.toString(16);
&#125;

type T = OmitThisParameter&lt;typeof toHex&gt;; // () =&gt; string
</code></pre>
<ul>
<li><code>OmitThisParameter&lt;T&gt;</code>给出了函数 <code>toHex()</code> 的类型，并将其中的 <code>this</code> 参数删除</li>
</ul>
<blockquote>
<p>如果函数没有 this 参数，则返回原始函数类型</p>
</blockquote>
<blockquote>
<p><code>OmitThisParameter&lt;Type&gt;</code>的实现如下</p>
</blockquote>
<pre><code>type OmitThisParameter&lt;T&gt; = unknown extends ThisParameterType&lt;T&gt;
  ? T
  : T extends (...args: infer A) =&gt; infer R
  ? (...args: A) =&gt; R
  : T;
</code></pre>
<h4 id="Parameters"><a href="#Parameters" class="headerlink" title="Parameters"></a>Parameters<Type></h4><blockquote>
<p><code>Parameters&lt;Type&gt;</code>从函数类型Type里面提取参数类型，组成一个元组返回</p>
</blockquote>
<pre><code>type T1 = Parameters&lt;() =&gt; string&gt;; // []

type T2 = Parameters&lt;(s: string) =&gt; void&gt;; // [s:string]

type T3 = Parameters&lt;&lt;T&gt;(arg: T) =&gt; T&gt;; // [arg: unknown]

type T4 = Parameters&lt;(x: &#123; a: number; b: string &#125;) =&gt; void&gt;; // [x: &#123; a: number, b: string &#125;]

type T5 = Parameters&lt;(a: number, b: number) =&gt; number&gt;; // [a:number, b:number]
</code></pre>
<ul>
<li><code>Parameters&lt;Type&gt;</code>的返回值会包括函数的参数名，这一点需要注意</li>
</ul>
<blockquote>
<p>如果参数类型Type不是带有参数的函数形式，会报错</p>
</blockquote>
<pre><code>// 报错
type T1 = Parameters&lt;string&gt;;

// 报错
type T2 = Parameters&lt;Function&gt;;
</code></pre>
<blockquote>
<p>由于any和never是两个特殊值，会返回<code>unknown[]</code>和<code>never</code></p>
</blockquote>
<pre><code>type T1 = Parameters&lt;any&gt;; // unknown[]

type T2 = Parameters&lt;never&gt;; // never
</code></pre>
<blockquote>
<p><code>Parameters&lt;Type&gt;</code>主要用于从外部模块提供的函数类型中，获取参数类型</p>
</blockquote>
<pre><code>interface SecretName &#123;
  first: string;
  last: string;
&#125;

interface SecretSanta &#123;
  name: SecretName;
  gift: string;
&#125;

export function getGift(name: SecretName, gift: string): SecretSanta &#123;
  // ...
  return &#123;
    name: &#123; first: &quot;icoding&quot;, last: &quot;ibc&quot; &#125;,
    gift: &quot;艾编程&quot;,
  &#125;;
&#125;
</code></pre>
<ul>
<li>以上代码中，模块只输出了函数 <code>getGift()</code>，没有输出参数 SecretName 和 返回值 SecretSanta。这时就可以通过 <code>Parameters&lt;T&gt;</code> 和 <code>ReturnType&lt;T&gt;</code> 拿到这两个接口类型</li>
</ul>
<pre><code>interface SecretName &#123;
  first: string;
  last: string;
&#125;

interface SecretSanta &#123;
  name: SecretName;
  gift: string;
&#125;

export function getGift(name: SecretName, gift: string): SecretSanta &#123;
  // ...
  return &#123;
    name: &#123; first: &quot;icoding&quot;, last: &quot;ibc&quot; &#125;,
    gift: &quot;艾编程&quot;,
  &#125;;
&#125;

// 从外部模块提供的函数类型中，获取参数类型

type ParaT = Parameters&lt;typeof getGift&gt;[0]; // SecretName

type ReturnT = ReturnType&lt;typeof getGift&gt;; // SecretSanta
Parameters&lt;Type&gt;的实现如下

type Parameters&lt;T extends (...args: any) =&gt; any&gt; = T extends (
  ...args: infer P
) =&gt; any
  ? P
  : never;
</code></pre>
<h4 id="Partial"><a href="#Partial" class="headerlink" title="Partial"></a>Partial<Type></h4><blockquote>
<p><code>Partial&lt;Type&gt;</code>返回一个新类型，将参数类型Type的所有属性变为可选属性</p>
</blockquote>
<pre><code>interface A &#123;
  x: number;
  y: number;
&#125;

type T = Partial&lt;A&gt;; // &#123; x?: number; y?: number; &#125;
</code></pre>
<blockquote>
<p>Partial<Type>的实现如下</p>
</blockquote>
<pre><code>type Partial&lt;T&gt; = &#123;
  [P in keyof T]?: T[P];
&#125;;
</code></pre>
<h4 id="Pick"><a href="#Pick" class="headerlink" title="Pick&lt;Type, Keys&gt;"></a><code>Pick&lt;Type, Keys&gt;</code></h4><blockquote>
<p><code>Pick&lt;Type, Keys&gt;</code>返回一个新的对象类型，第一个参数Type是一个对象类型，第二个参数<code>Keys</code>是Type里面被选定的键名</p>
</blockquote>
<pre><code>interface A &#123;
  x: number;
  y: number;
&#125;

type T1 = Pick&lt;A, &quot;x&quot;&gt;; // &#123; x: number &#125;
type T2 = Pick&lt;A, &quot;y&quot;&gt;; // &#123; y: number &#125;
type T3 = Pick&lt;A, &quot;x&quot; | &quot;y&quot;&gt;; // &#123; x: number; y: number &#125;
</code></pre>
<ul>
<li><code>Pick&lt;Type, Keys&gt;</code>会从对象类型A里面挑出指定的键名，组成一个新的对象类型</li>
</ul>
<blockquote>
<p>指定的键名Keys必须是对象键名Type里面已经存在的键名，否则会报错。</p>
</blockquote>
<pre><code>interface A &#123;
  x: number;
  y: number;
&#125;

type T = Pick&lt;A, &quot;z&quot;&gt;; // 报错

// 对象类型 A 不存在键名 z，所以报错了
Pick&lt;Type, Keys&gt;的实现如下

type Pick&lt;T, K extends keyof T&gt; = &#123;
[P in K]: TP;
&#125;;
</code></pre>
<h4 id="Readonly"><a href="#Readonly" class="headerlink" title="Readonly"></a>Readonly<Type></h4><blockquote>
<p><code>Readonly&lt;Type&gt;</code>返回一个新类型，将参数类型Type的所有属性变为只读属性</p>
</blockquote>
<pre><code>interface A &#123;
  x: number;
  y?: number;
&#125;

// &#123; readonly x: number; readonly y?: number; &#125;
type T = Readonly&lt;A&gt;;
</code></pre>
<ul>
<li>y 是可选属性，<code>Readonly&lt;Type&gt;</code> 不会改变这一点，只会让 y 变成只读</li>
</ul>
<blockquote>
<p><code>Readonly&lt;Type&gt;</code>的实现如下</p>
</blockquote>
<pre><code>type Readonly&lt;T&gt; = &#123;
  readonly [P in keyof T]: T[P];
&#125;;
</code></pre>
<blockquote>
<p>我们可以自定义类型工具<code>Mutable&lt;Type&gt;</code>，将参数类型的所有属性变成可变属性</p>
</blockquote>
<pre><code>type Mutable&lt;T&gt; = &#123;
  -readonly [P in keyof T]: T[P];
&#125;;

// -readonly 表示去除属性的只读标志
</code></pre>
<blockquote>
<p>相应地，+readonly就表示增加只读标志，等同于readonly。因此，<code>ReadOnly&lt;Type&gt;</code>的实现也可以写成下面这样。</p>
</blockquote>
<pre><code>type Readonly&lt;T&gt; = &#123;
  +readonly [P in keyof T]: T[P];
&#125;;
</code></pre>
<blockquote>
<p>Readonly<Type>可以与Partial<Type>结合使用，将所有属性变成只读的可选属性。</p>
</blockquote>
<pre><code>interface Person &#123;
  name: string;
  age: number;
&#125;

const worker: Readonly&lt;Partial&lt;Person&gt;&gt; = &#123; name: &quot;张三&quot; &#125;;

worker.name = &quot;李四&quot;; // 报错
</code></pre>
<h4 id="Record"><a href="#Record" class="headerlink" title="Record&lt;Keys, Type&gt;"></a><code>Record&lt;Keys, Type&gt;</code></h4><blockquote>
<p><code>Record&lt;Keys, Type&gt;</code>返回一个对象类型，参数Keys用作键名，参数Type用作键值类型</p>
</blockquote>
<pre><code>// &#123; a: number &#125;
type T = Record&lt;&quot;a&quot;, number&gt;;
</code></pre>
<ul>
<li><code>Record&lt;Keys, Type&gt; </code>的第一个参数 a，用作对象的键名，第二个参数 <code>number</code> 是 a 的键值类型</li>
</ul>
<blockquote>
<p>参数Keys可以是联合类型，这时会依次展开为多个键</p>
</blockquote>
<pre><code>// &#123; a: number, b: number &#125;
type T = Record&lt;&quot;a&quot; | &quot;b&quot;, number&gt;;
</code></pre>
<ul>
<li>第一个参数是联合类型<code>&#39;a&#39;|&#39;b&#39;</code>，展开成两个键名 a 和 b</li>
</ul>
<blockquote>
<p>如果参数Type是联合类型，就表明键值是联合类型</p>
</blockquote>
<pre><code>// &#123; a: number|string &#125;
type T = Record&lt;&quot;a&quot;, number | string&gt;;
</code></pre>
<blockquote>
<p>参数 Keys 的类型必须兼容 <code>string|number|symbol</code> ，否则不能用作键名，会报错</p>
</blockquote>
<blockquote>
<p><code>Record&lt;Keys, Type&gt;</code>的实现如下</p>
</blockquote>
<pre><code>type Record&lt;K extends string | number | symbol, T&gt; = &#123; [P in K]: T &#125;;
</code></pre>
<h4 id="Required"><a href="#Required" class="headerlink" title="Required"></a>Required<Type></h4><blockquote>
<p><code>Required&lt;Type&gt;</code>返回一个新类型，将参数类型Type的所有属性变为必选属性。它与<code>Partial&lt;Type&gt;</code>的作用正好相反</p>
</blockquote>
<pre><code>interface A &#123;
  x?: number;
  y: number;
&#125;

type T = Required&lt;A&gt;; // &#123; x: number; y: number; &#125;
</code></pre>
<blockquote>
<p>Required<Type>的实现如下</p>
</blockquote>
<pre><code>type Required&lt;T&gt; = &#123;
  [P in keyof T]-?: T[P];
&#125;;
</code></pre>
<ul>
<li>符号 <code>-?</code> 表示去除可选属性的 “问号”，使其变成必选属性</li>
</ul>
<blockquote>
<p>相对应地，符号<code>+?</code>表示增加可选属性的“问号”，等同于?。因此，前面的<code>Partial&lt;Type&gt;</code>的定义也可以写成下面这样。</p>
</blockquote>
<pre><code>type Partial&lt;T&gt; = &#123;
  [P in keyof T]+?: T[P];
&#125;;
</code></pre>
<h4 id="ReadonlyArray"><a href="#ReadonlyArray" class="headerlink" title="ReadonlyArray"></a>ReadonlyArray<Type></h4><blockquote>
<p><code>ReadonlyArray&lt;Type&gt;</code>用来生成一个只读数组类型，类型参数Type表示数组成员的类型。</p>
</blockquote>
<pre><code>const values: ReadonlyArray&lt;string&gt; = [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;];

values[0] = &quot;x&quot;; // 报错
values.push(&quot;x&quot;); // 报错
values.pop(); // 报错
values.splice(1, 1); // 报错
</code></pre>
<ul>
<li>变量 values 的类型是一个只读数组，所以修改成员会报错，并且那些会修改源数组的方法<code>push()</code>、<code>pop()</code>、<code>splice()</code> 等都不存在</li>
</ul>
<blockquote>
<p>ReadonlyArray<Type>的实现如下</p>
</blockquote>
<pre><code>interface ReadonlyArray&lt;T&gt; &#123;
  readonly length: number;

  readonly [n: number]: T;

  // ...
&#125;
</code></pre>
<h4 id="ReturnType"><a href="#ReturnType" class="headerlink" title="ReturnType"></a>ReturnType<Type></h4><blockquote>
<p><code>ReturnType&lt;Type&gt;</code>提取函数类型Type的返回值类型，作为一个新类型返回</p>
</blockquote>
<pre><code>type T1 = ReturnType&lt;() =&gt; string&gt;; // string

type T2 = ReturnType&lt;
  () =&gt; &#123;
    a: string;
    b: number;
  &#125;
&gt;; // &#123; a: string; b: number &#125;

type T3 = ReturnType&lt;(s: string) =&gt; void&gt;; // void

type T4 = ReturnType&lt;() =&gt; () =&gt; any[]&gt;; // () =&gt; any[]

type T5 = ReturnType&lt;typeof Math.random&gt;; // number

type T6 = ReturnType&lt;typeof Array.isArray&gt;; // boolean
</code></pre>
<blockquote>
<p>如果参数类型是泛型函数，返回值取决于泛型类型。如果泛型不带有限制条件，就会返回<code>unknown</code>。</p>
</blockquote>
<pre><code>type T1 = ReturnType&lt;&lt;T&gt;() =&gt; T&gt;; // unknown

type T2 = ReturnType&lt;&lt;T extends U, U extends number[]&gt;() =&gt; T&gt;; // number[]
</code></pre>
<blockquote>
<p>如果类型不是函数，会报错</p>
</blockquote>
<pre><code>type T1 = ReturnType&lt;boolean&gt;; // 报错

type T2 = ReturnType&lt;Function&gt;; // 报错
</code></pre>
<blockquote>
<p>any 和 never 是两个特殊值，分别返回 any 和 never</p>
</blockquote>
<pre><code>type T1 = ReturnType&lt;any&gt;; // any

type T2 = ReturnType&lt;never&gt;; // never
</code></pre>
<blockquote>
<p><code>ReturnType&lt;Type&gt;</code>的实现如下</p>
</blockquote>
<pre><code>type ReturnType&lt;T extends (...args: any) =&gt; any&gt; = T extends (
  ...args: any
) =&gt; infer R
  ? R
  : any;
</code></pre>
<h4 id="ThisParameterType"><a href="#ThisParameterType" class="headerlink" title="ThisParameterType"></a>ThisParameterType<Type></h4><blockquote>
<p><code>ThisParameterType&lt;Type&gt;</code>提取函数类型中this参数的类型。</p>
</blockquote>
<pre><code>function toHex(this: Number) &#123;
  return this.toString(16);
&#125;

type T = ThisParameterType&lt;typeof toHex&gt;; // number
</code></pre>
<blockquote>
<p>如果函数没有<code>this</code>参数，则返回<code>unknown</code></p>
</blockquote>
<blockquote>
<p><code>ThisParameterType&lt;Type&gt;</code>的实现如下</p>
</blockquote>
<pre><code>type ThisParameterType&lt;T&gt; = T extends (this: infer U, ...args: never) =&gt; any
  ? U
  : unknown;
</code></pre>
<h4 id="ThisType"><a href="#ThisType" class="headerlink" title="ThisType"></a>ThisType<Type></h4><blockquote>
<p><code>ThisType&lt;Type&gt;</code>不返回类型，只用来跟其他类型组成交叉类型，用来提示 TypeScript 其他类型里面的this的类型。</p>
</blockquote>
<pre><code>interface HelperThisValue &#123;
  logError: (error: string) =&gt; void;
&#125;

let helperFunctions: &#123; [name: string]: Function &#125; &amp; ThisType&lt;HelperThisValue&gt; =
  &#123;
    hello: function () &#123;
      this.logError(&quot;Error: Something wrong!&quot;); // 正确
      this.update(); // 报错
    &#125;,
  &#125;;
</code></pre>
<ul>
<li>变量 <code>helperFunctions</code> 的类型是一个正常的对象类型与 <code>ThisType&lt;HelperThisValue&gt;</code> 组成的交叉类型</li>
<li>这里的<code>ThisType</code>的作用是提示 TypeScript，变量<code>helperFunctions</code>的<code>this</code>应该满足<code>HelperThisValue</code>的条件。所以，<code>this.logError()</code>可以正确调用，而<code>this.update()</code>会报错，因为<code>HelperThisValue</code>里面没有这个方法。</li>
</ul>
<blockquote>
<p>注意，使用这个类型工具时，必须打开<code>noImplicitThis</code>设置。</p>
<ul>
<li>下面是另一个例子</li>
</ul>
</blockquote>
<pre><code>let obj: ThisType&lt;&#123; x: number &#125;&gt; &amp; &#123; getX: () =&gt; number &#125;;

obj = &#123;
  getX() &#123;
    return this.x + this.y; // 报错
  &#125;,
&#125;;
</code></pre>
<ul>
<li><code>getX()</code>里面的 this.y 会报错，因为根据 <code>ThisType&lt;&#123; x: number &#125;&gt;</code>，这个对象的 this 不包含属性 y</li>
</ul>
<blockquote>
<p><code>ThisType&lt;Type&gt;</code>的实现就是一个空接口</p>
</blockquote>
<pre><code>interface ThisType&lt;T&gt; &#123;&#125;
</code></pre>
<h4 id="字符串类型工具"><a href="#字符串类型工具" class="headerlink" title="字符串类型工具"></a>字符串类型工具</h4><blockquote>
<p>TypeScript 内置了四个字符串类型工具，专门用来操作字符串类型。这四个工具类型都定义在 TypeScript 自带的.<code>d.ts</code>文件里面。</p>
</blockquote>
<blockquote>
<p>它们的实现都是在底层调用 JavaScript 引擎提供 JavaScript 字符操作方法。</p>
</blockquote>
<ol>
<li><code>Uppercase&lt;StringType&gt;</code><blockquote>
<p><code>Uppercase&lt;StringType&gt;</code>将字符串类型的每个字符转为大写</p>
</blockquote>
</li>
</ol>
<pre><code>type A = &quot;icoding&quot;;

// &quot;ICODING&quot;
type B = Uppercase&lt;A&gt;;

// Uppercase&lt;T&gt; 将 icoding 转为 ICODING
</code></pre>
<ol start="2">
<li>Lowercase<StringType><blockquote>
<p><code>Lowercase&lt;StringType&gt;</code>将字符串的每个字符转为小写</p>
</blockquote>
</li>
</ol>
<pre><code>type A = &quot;ICODING&quot;;

// &quot;icoding&quot;
type B = Lowercase&lt;A&gt;;

// Lowercase&lt;T&gt; 将 ICODING 转为 icoding
</code></pre>
<ol start="3">
<li>Capitalize<StringType><blockquote>
<p><code>Capitalize&lt;StringType&gt;</code>将字符串的第一个字符转为大写</p>
</blockquote>
</li>
</ol>
<pre><code>type A = &quot;icoding&quot;;

// &quot;Icoding&quot;
type B = Capitalize&lt;A&gt;;

// Capitalize&lt;T&gt; 将 icoding 转为 Icoding
</code></pre>
<ol start="4">
<li>Uncapitalize<StringType><blockquote>
<p><code>Uncapitalize&lt;StringType&gt;</code>将字符串的第一个字符转为小写</p>
</blockquote>
</li>
</ol>
<pre><code>type A = &quot;ICODING&quot;;

// &quot;iCODING&quot;
type B = Uncapitalize&lt;A&gt;;

// Uncapitalize&lt;T&gt; 将 ICODING 转为 iCODING
</code></pre>

                
            </div>
            <hr/>

            

    <div class="reprint" id="reprint-statement">
        
            <div class="reprint__author">
                <span class="reprint-meta" style="font-weight: bold;">
                    <i class="fas fa-user">
                        文章作者:
                    </i>
                </span>
                <span class="reprint-info">
                    <a href="/about" rel="external nofollow noreferrer">hermia</a>
                </span>
            </div>
            <div class="reprint__type">
                <span class="reprint-meta" style="font-weight: bold;">
                    <i class="fas fa-link">
                        文章链接:
                    </i>
                </span>
                <span class="reprint-info">
                    <a href="https://hermiablog.com/2024/02/07/TypeScript%EF%BC%88%E5%85%AD%EF%BC%89/">https://hermiablog.com/2024/02/07/TypeScript%EF%BC%88%E5%85%AD%EF%BC%89/</a>
                </span>
            </div>
            <div class="reprint__notice">
                <span class="reprint-meta" style="font-weight: bold;">
                    <i class="fas fa-copyright">
                        版权声明:
                    </i>
                </span>
                <span class="reprint-info">
                    本博客所有文章除特別声明外，均采用
                    <a href="https://creativecommons.org/licenses/by/4.0/deed.zh" rel="external nofollow noreferrer" target="_blank">CC BY 4.0</a>
                    许可协议。转载请注明来源
                    <a href="/about" target="_blank">hermia</a>
                    !
                </span>
            </div>
        
    </div>

    <script async defer>
      document.addEventListener("copy", function (e) {
        let toastHTML = '<span>复制成功，请遵循本文的转载规则</span><button class="btn-flat toast-action" onclick="navToReprintStatement()" style="font-size: smaller">查看</a>';
        M.toast({html: toastHTML})
      });

      function navToReprintStatement() {
        $("html, body").animate({scrollTop: $("#reprint-statement").offset().top - 80}, 800);
      }
    </script>



            <div class="tag_share" style="display: block;">
                <div class="post-meta__tag-list" style="display: inline-block;">
                    
                        <div class="article-tag">
                            
                                <a href="/tags/TypesSript/">
                                    <span class="chip bg-color">TypesSript</span>
                                </a>
                            
                        </div>
                    
                </div>
                <div class="post_share" style="zoom: 80%; width: fit-content; display: inline-block; float: right; margin: -0.15rem 0;">
                    <link rel="stylesheet" type="text/css" href="/libs/share/css/share.min.css">
<div id="article-share">

    
    <div class="social-share" data-sites="qq,qzone,wechat,weibo" data-wechat-qrcode-helper="<p>微信扫一扫即可分享！</p>"></div>
    <script src="/libs/share/js/social-share.min.js"></script>
    

    

</div>

                </div>
            </div>
            
                <style>
    #reward {
        margin: 40px 0;
        text-align: center;
    }

    #reward .reward-link {
        font-size: 1.4rem;
        line-height: 38px;
    }

    #reward .btn-floating:hover {
        box-shadow: 0 6px 12px rgba(0, 0, 0, 0.2), 0 5px 15px rgba(0, 0, 0, 0.2);
    }

    #rewardModal {
        width: 320px;
        height: 350px;
    }

    #rewardModal .reward-title {
        margin: 15px auto;
        padding-bottom: 5px;
    }

    #rewardModal .modal-content {
        padding: 10px;
    }

    #rewardModal .close {
        position: absolute;
        right: 15px;
        top: 15px;
        color: rgba(0, 0, 0, 0.5);
        font-size: 1.3rem;
        line-height: 20px;
        cursor: pointer;
    }

    #rewardModal .close:hover {
        color: #ef5350;
        transform: scale(1.3);
        -moz-transform:scale(1.3);
        -webkit-transform:scale(1.3);
        -o-transform:scale(1.3);
    }

    #rewardModal .reward-tabs {
        margin: 0 auto;
        width: 210px;
    }

    .reward-tabs .tabs {
        height: 38px;
        margin: 10px auto;
        padding-left: 0;
    }

    .reward-content ul {
        padding-left: 0 !important;
    }

    .reward-tabs .tabs .tab {
        height: 38px;
        line-height: 38px;
    }

    .reward-tabs .tab a {
        color: #fff;
        background-color: #ccc;
    }

    .reward-tabs .tab a:hover {
        background-color: #ccc;
        color: #fff;
    }

    .reward-tabs .wechat-tab .active {
        color: #fff !important;
        background-color: #22AB38 !important;
    }

    .reward-tabs .alipay-tab .active {
        color: #fff !important;
        background-color: #019FE8 !important;
    }

    .reward-tabs .reward-img {
        width: 210px;
        height: 210px;
    }
</style>

<div id="reward">
    <a href="#rewardModal" class="reward-link modal-trigger btn-floating btn-medium waves-effect waves-light red">赏</a>

    <!-- Modal Structure -->
    <div id="rewardModal" class="modal">
        <div class="modal-content">
            <a class="close modal-close"><i class="fas fa-times"></i></a>
            <h4 class="reward-title">你的赏识是我前进的动力</h4>
            <div class="reward-content">
                <div class="reward-tabs">
                    <ul class="tabs row">
                        <li class="tab col s6 alipay-tab waves-effect waves-light"><a href="#alipay">支付宝</a></li>
                        <li class="tab col s6 wechat-tab waves-effect waves-light"><a href="#wechat">微 信</a></li>
                    </ul>
                    <div id="alipay">
                        <img src="/medias/reward/alipay.jpg" class="reward-img" alt="支付宝打赏二维码">
                    </div>
                    <div id="wechat">
                        <img src="/medias/reward/wechat.png" class="reward-img" alt="微信打赏二维码">
                    </div>
                </div>
            </div>
        </div>
    </div>
</div>

<script>
    $(function () {
        $('.tabs').tabs();
    });
</script>

            
        </div>
    </div>

    

    

    

    

    

    

    

    

<article id="prenext-posts" class="prev-next articles">
    <div class="row article-row">
        
        <div class="article col s12 m6" data-aos="fade-up">
            <div class="article-badge left-badge text-color">
                <i class="fas fa-chevron-left"></i>&nbsp;上一篇</div>
            <div class="card">
                <a href="/2024/02/07/TypeScript%EF%BC%88%E4%B8%83%EF%BC%89/">
                    <div class="card-image">
                        
                        <img src="/medias/featureimages/58.jpg" class="responsive-img" alt="TypeScript（七）">
                        
                        <span class="card-title">TypeScript（七）</span>
                    </div>
                </a>
                <div class="card-content article-content">
                    <div class="summary block-with-text">
                        
                            注释指令、tsconfig.json配置、环境搭建
                        
                    </div>
                    <div class="publish-info">
                        <span class="publish-date">
                            <i class="far fa-clock fa-fw icon-date"></i>2024-02-07
                        </span>
                        <span class="publish-author">
                            
                            <i class="fas fa-bookmark fa-fw icon-category"></i>
                            
                            <a href="/categories/%E6%8A%80%E6%9C%AF/" class="post-category">
                                    技术
                                </a>
                            
                            
                        </span>
                    </div>
                </div>
                
                <div class="card-action article-tags">
                    
                    <a href="/tags/TypesSript/">
                        <span class="chip bg-color">TypesSript</span>
                    </a>
                    
                </div>
                
            </div>
        </div>
        
        
        <div class="article col s12 m6" data-aos="fade-up">
            <div class="article-badge right-badge text-color">
                下一篇&nbsp;<i class="fas fa-chevron-right"></i>
            </div>
            <div class="card">
                <a href="/2024/02/06/TypeScript%EF%BC%88%E4%BA%94%EF%BC%89/">
                    <div class="card-image">
                        
                        <img src="/medias/featureimages/55.jpg" class="responsive-img" alt="TypeScript（五）">
                        
                        <span class="card-title">TypeScript（五）</span>
                    </div>
                </a>
                <div class="card-content article-content">
                    <div class="summary block-with-text">
                        
                            泛型、类型断言、类型检查机制、高级类型
                        
                    </div>
                    <div class="publish-info">
                            <span class="publish-date">
                                <i class="far fa-clock fa-fw icon-date"></i>2024-02-06
                            </span>
                        <span class="publish-author">
                            
                            <i class="fas fa-bookmark fa-fw icon-category"></i>
                            
                            <a href="/categories/%E6%8A%80%E6%9C%AF/" class="post-category">
                                    技术
                                </a>
                            
                            
                        </span>
                    </div>
                </div>
                
                <div class="card-action article-tags">
                    
                    <a href="/tags/TypesSript/">
                        <span class="chip bg-color">TypesSript</span>
                    </a>
                    
                </div>
                
            </div>
        </div>
        
    </div>
</article>

</div>



<!-- 代码块功能依赖 -->
<script type="text/javascript" src="/libs/codeBlock/codeBlockFuction.js"></script>

<!-- 代码语言 -->

<script type="text/javascript" src="/libs/codeBlock/codeLang.js"></script>


<!-- 代码块复制 -->

<script type="text/javascript" src="/libs/codeBlock/codeCopy.js"></script>


<!-- 代码块收缩 -->

<script type="text/javascript" src="/libs/codeBlock/codeShrink.js"></script>


  </div>
  <div id="toc-aside" class="expanded col l3 hide-on-med-and-down">
    <div class="toc-widget card" style="background-color: white">
      <div class="toc-title">
        <i class="far fa-list-alt"></i>&nbsp;&nbsp;目录
      </div>
      <div id="toc-content"></div>
    </div>
  </div>
</div>

<!-- TOC 悬浮按钮. -->

<div id="floating-toc-btn" class="hide-on-med-and-down">
  <a class="btn-floating btn-large bg-color">
    <i class="fas fa-list-ul"></i>
  </a>
</div>


<script src="/libs/tocbot/tocbot.min.js"></script>
<script>
  $(function () {
      tocbot.init({
          tocSelector: '#toc-content',
          contentSelector: '#articleContent',
          headingsOffset: -($(window).height() * 0.4 - 45),
          collapseDepth: Number('0'),
          headingSelector: 'h2, h3, h4'
      });

      // modify the toc link href to support Chinese.
      let i = 0;
      let tocHeading = 'toc-heading-';
      $('#toc-content a').each(function () {
          $(this).attr('href', '#' + tocHeading + (++i));
      });

      // modify the heading title id to support Chinese.
      i = 0;
      $('#articleContent').children('h2, h3, h4').each(function () {
          $(this).attr('id', tocHeading + (++i));
      });

      // Set scroll toc fixed.
      let tocHeight = parseInt($(window).height() * 0.4 - 64);
      let $tocWidget = $('.toc-widget');
      $(window).scroll(function () {
          let scroll = $(window).scrollTop();
          /* add post toc fixed. */
          if (scroll > tocHeight) {
              $tocWidget.addClass('toc-fixed');
          } else {
              $tocWidget.removeClass('toc-fixed');
          }
      });

      
      /* 修复文章卡片 div 的宽度. */
      let fixPostCardWidth = function (srcId, targetId) {
          let srcDiv = $('#' + srcId);
          if (srcDiv.length === 0) {
              return;
          }

          let w = srcDiv.width();
          if (w >= 450) {
              w = w + 21;
          } else if (w >= 350 && w < 450) {
              w = w + 18;
          } else if (w >= 300 && w < 350) {
              w = w + 16;
          } else {
              w = w + 14;
          }
          $('#' + targetId).width(w);
      };

      // 切换TOC目录展开收缩的相关操作.
      const expandedClass = 'expanded';
      let $tocAside = $('#toc-aside');
      let $mainContent = $('#main-content');
      $('#floating-toc-btn .btn-floating').click(function () {
          if ($tocAside.hasClass(expandedClass)) {
              $tocAside.removeClass(expandedClass).hide();
              $mainContent.removeClass('l9');
          } else {
              $tocAside.addClass(expandedClass).show();
              $mainContent.addClass('l9');
          }
          fixPostCardWidth('artDetail', 'prenext-posts');
      });
      
  });
</script>

    

</main>




    <footer class="page-footer bg-color">
   <link rel="stylesheet" href="/libs/aplayer/APlayer.min.css">
<style>
    .aplayer .aplayer-lrc p {
        
        font-size: 12px;
        font-weight: 700;
        line-height: 16px !important;
    }

    .aplayer .aplayer-lrc p.aplayer-lrc-current {
        
        font-size: 15px;
        color: #a3ddf0;
        /* color: #59cde9; */
    }

    
    .aplayer.aplayer-fixed.aplayer-narrow .aplayer-body {
        left: -66px !important;
    }

    .aplayer.aplayer-fixed.aplayer-narrow .aplayer-body:hover {
        left: 0px !important;
    }

    
</style>
<div class="">
    
    <div class="row">
        <meting-js class="col l8 offset-l2 m10 offset-m1 s12"
                   server="netease"
                   type="playlist"
                   id="2450546498"
                   fixed='true'
                   autoplay='false'
                   theme='#59cde9'
                   loop='all'
                   order='random'
                   preload='auto'
                   volume='0.7'
                   list-folded='true'
        >
        </meting-js>
    </div>
</div>

<script src="/libs/aplayer/APlayer.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/meting@2/dist/Meting.min.js"></script>
 
  <div
    class="container row center-align"
    style="margin-bottom: 15px !important;"
  >
    <div class="col s12 m8 l8 copy-right">
      Copyright&nbsp;&copy; 
      <span id="year"
        >2023-2024</span
      >
      
      <span id="year">2023</span>
      <a href="/about" target="_blank"
        >hermia</a
      >
      |&nbsp;Powered by&nbsp;<a href="https://hexo.io/" target="_blank">Hexo</a>
      |&nbsp;Theme&nbsp;<a
        href="https://github.com/blinkfox/hexo-theme-matery"
        target="_blank"
        >Matery</a
      >
      <br />
           
      <span id="busuanzi_container_site_pv">
        |&nbsp;<i class="far fa-eye"></i>&nbsp;总访问量:&nbsp;<span
          id="busuanzi_value_site_pv"
          class="white-color"
        ></span
        >&nbsp;次
      </span>
       
      <span id="busuanzi_container_site_uv">
        |&nbsp;<i class="fas fa-users"></i>&nbsp;总访问人数:&nbsp;<span
          id="busuanzi_value_site_uv"
          class="white-color"
        ></span
        >&nbsp;人
      </span>
      
      <br />
      
      <span id="sitetime">载入运行时间...</span>
      <script>
        function siteTime() {
          var seconds = 1000;
          var minutes = seconds * 60;
          var hours = minutes * 60;
          var days = hours * 24;
          var years = days * 365;
          var today = new Date();
          var startYear = "2023";
          var startMonth = "11";
          var startDate = "14";
          var startHour = "0";
          var startMinute = "0";
          var startSecond = "0";
          var todayYear = today.getFullYear();
          var todayMonth = today.getMonth() + 1;
          var todayDate = today.getDate();
          var todayHour = today.getHours();
          var todayMinute = today.getMinutes();
          var todaySecond = today.getSeconds();
          var t1 = Date.UTC(
            startYear,
            startMonth,
            startDate,
            startHour,
            startMinute,
            startSecond
          );
          var t2 = Date.UTC(
            todayYear,
            todayMonth,
            todayDate,
            todayHour,
            todayMinute,
            todaySecond
          );
          var diff = t2 - t1;
          var diffYears = Math.floor(diff / years);
          var diffDays = Math.floor(diff / days - diffYears * 365);
          var diffHours = Math.floor(
            (diff - (diffYears * 365 + diffDays) * days) / hours
          );
          var diffMinutes = Math.floor(
            (diff - (diffYears * 365 + diffDays) * days - diffHours * hours) /
              minutes
          );
          var diffSeconds = Math.floor(
            (diff -
              (diffYears * 365 + diffDays) * days -
              diffHours * hours -
              diffMinutes * minutes) /
              seconds
          );
          if (startYear == todayYear) {
            document.getElementById("year").innerHTML = todayYear;
            document.getElementById("sitetime").innerHTML =
              "本站已安全运行 " +
              diffDays +
              " 天 " +
              diffHours +
              " 小时 " +
              diffMinutes +
              " 分钟 " +
              diffSeconds +
              " 秒";
          } else {
            document.getElementById("year").innerHTML =
              startYear + " - " + todayYear;
            document.getElementById("sitetime").innerHTML =
              "本站已安全运行 " +
              diffYears +
              " 年 " +
              diffDays +
              " 天 " +
              diffHours +
              " 小时 " +
              diffMinutes +
              " 分钟 " +
              diffSeconds +
              " 秒";
          }
        }
        setInterval(siteTime, 1000);
      </script>
      
      <br />
      
    </div>
    <div class="col s12 m4 l4 social-link social-statis">
      
<a
  href="https://github.com/hermiablog/hermiablog.github.io"
  class="tooltipped"
  target="_blank"
  data-tooltip="访问我的GitHub"
  data-position="top"
  data-delay="50"
>
  <i class="fab fa-github"></i>
</a>
 
<a
  href="mailto:1587837237@qq.com"
  class="tooltipped"
  target="_blank"
  data-tooltip="邮件联系我"
  data-position="top"
  data-delay="50"
>
  <i class="fas fa-envelope-open"></i>
</a>
<!-- 
   
<a
  href="tencent://AddContact/?fromId=50&fromSubId=1&subcmd=all&uin=1587837237"
  class="tooltipped"
  target="_blank"
  data-tooltip="QQ联系我: 1587837237"
  data-position="top"
  data-delay="50"
>
  <i class="fab fa-qq"></i>
</a>
    -->

    </div>
  </div>
</footer>

<div class="progress-bar"></div>


    <!-- 搜索遮罩框 -->
<div id="searchModal" class="modal">
    <div class="modal-content">
        <div class="search-header">
            <span class="title"><i class="fas fa-search"></i>&nbsp;&nbsp;搜索</span>
            <input type="search" id="searchInput" name="s" placeholder="请输入搜索的关键字"
                   class="search-input">
        </div>
        <div id="searchResult"></div>
    </div>
</div>

<script type="text/javascript">
$(function () {
    var searchFunc = function (path, search_id, content_id) {
        'use strict';
        $.ajax({
            url: path,
            dataType: "xml",
            success: function (xmlResponse) {
                // get the contents from search data
                var datas = $("entry", xmlResponse).map(function () {
                    return {
                        title: $("title", this).text(),
                        content: $("content", this).text(),
                        url: $("url", this).text()
                    };
                }).get();
                var $input = document.getElementById(search_id);
                var $resultContent = document.getElementById(content_id);
                $input.addEventListener('input', function () {
                    var str = '<ul class=\"search-result-list\">';
                    var keywords = this.value.trim().toLowerCase().split(/[\s\-]+/);
                    $resultContent.innerHTML = "";
                    if (this.value.trim().length <= 0) {
                        return;
                    }
                    // perform local searching
                    datas.forEach(function (data) {
                        var isMatch = true;
                        var data_title = data.title.trim().toLowerCase();
                        var data_content = data.content.trim().replace(/<[^>]+>/g, "").toLowerCase();
                        var data_url = data.url;
                        data_url = data_url.indexOf('/') === 0 ? data.url : '/' + data_url;
                        var index_title = -1;
                        var index_content = -1;
                        var first_occur = -1;
                        // only match artiles with not empty titles and contents
                        if (data_title !== '' && data_content !== '') {
                            keywords.forEach(function (keyword, i) {
                                index_title = data_title.indexOf(keyword);
                                index_content = data_content.indexOf(keyword);
                                if (index_title < 0 && index_content < 0) {
                                    isMatch = false;
                                } else {
                                    if (index_content < 0) {
                                        index_content = 0;
                                    }
                                    if (i === 0) {
                                        first_occur = index_content;
                                    }
                                }
                            });
                        }
                        // show search results
                        if (isMatch) {
                            str += "<li><a href='" + data_url + "' class='search-result-title'>" + data_title + "</a>";
                            var content = data.content.trim().replace(/<[^>]+>/g, "");
                            if (first_occur >= 0) {
                                // cut out 100 characters
                                var start = first_occur - 20;
                                var end = first_occur + 80;
                                if (start < 0) {
                                    start = 0;
                                }
                                if (start === 0) {
                                    end = 100;
                                }
                                if (end > content.length) {
                                    end = content.length;
                                }
                                var match_content = content.substr(start, end);
                                // highlight all keywords
                                keywords.forEach(function (keyword) {
                                    var regS = new RegExp(keyword, "gi");
                                    match_content = match_content.replace(regS, "<em class=\"search-keyword\">" + keyword + "</em>");
                                });

                                str += "<p class=\"search-result\">" + match_content + "...</p>"
                            }
                            str += "</li>";
                        }
                    });
                    str += "</ul>";
                    $resultContent.innerHTML = str;
                });
            }
        });
    };

    searchFunc('/search.xml', 'searchInput', 'searchResult');
});
</script>

    <!-- 回到顶部按钮 -->
<div id="backTop" class="top-scroll">
    <a class="btn-floating btn-large waves-effect waves-light" href="#!">
        <i class="fas fa-arrow-up"></i>
    </a>
</div>


    <script src="/libs/materialize/materialize.min.js"></script>
    <script src="/libs/masonry/masonry.pkgd.min.js"></script>
    <script src="/libs/aos/aos.js"></script>
    <script src="/libs/scrollprogress/scrollProgress.min.js"></script>
    <script src="/libs/lightGallery/js/lightgallery-all.min.js"></script>
    <script src="/js/matery.js"></script>

    <!-- Baidu Analytics -->

    <!-- Baidu Push -->

<script>
    (function () {
        var bp = document.createElement('script');
        var curProtocol = window.location.protocol.split(':')[0];
        if (curProtocol === 'https') {
            bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';
        } else {
            bp.src = 'http://push.zhanzhang.baidu.com/push.js';
        }
        var s = document.getElementsByTagName("script")[0];
        s.parentNode.insertBefore(bp, s);
    })();
</script>

    
    <script src="/libs/others/clicklove.js" async="async"></script>
    
    
    <script async src="/libs/others/busuanzi.pure.mini.js"></script>
    

    

    

	
    

    

    

    
    <script src="/libs/instantpage/instantpage.js" type="module"></script>
    

</body>

</html>
