<!DOCTYPE HTML>
<html lang="zh-CN">


<head>
    <meta charset="utf-8">
    <meta name="keywords" content="Vue（七）, 技术博客">
    <meta name="description" content="个人技术博客">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <meta name="renderer" content="webkit|ie-stand|ie-comp">
    <meta name="mobile-web-app-capable" content="yes">
    <meta name="format-detection" content="telephone=no">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <!-- Global site tag (gtag.js) - Google Analytics -->


    <title>Vue（七） | hermia&#39;s blog</title>
    <link rel="icon" type="image/png" href="/favicon.png">

    <link rel="stylesheet" type="text/css" href="/libs/awesome/css/all.css">
    <link rel="stylesheet" type="text/css" href="/libs/materialize/materialize.min.css">
    <link rel="stylesheet" type="text/css" href="/libs/aos/aos.css">
    <link rel="stylesheet" type="text/css" href="/libs/animate/animate.min.css">
    <link rel="stylesheet" type="text/css" href="/libs/lightGallery/css/lightgallery.min.css">
    <link rel="stylesheet" type="text/css" href="/css/matery.css">
    <link rel="stylesheet" type="text/css" href="/css/my.css">

    <script src="/libs/jquery/jquery.min.js"></script>

<meta name="generator" content="Hexo 6.3.0"><link rel="stylesheet" href="/css/prism-tomorrow.css" type="text/css"></head>



   <style>
    body{
       background-image: url(https://cdn.pixabay.com/photo/2012/04/14/16/37/sky-34536_1280.png);
       background-repeat:no-repeat;
       background-size:cover;
       background-attachment:fixed;
    }
</style>



<body>
    <header class="navbar-fixed">
    <nav id="headNav" class="bg-color nav-transparent">
        <div id="navContainer" class="nav-wrapper container">
            <div class="brand-logo">
                <a href="/" class="waves-effect waves-light">
                    
                    <img src="/medias/logo.png" class="logo-img" alt="LOGO">
                    
                    <span class="logo-span">hermia&#39;s blog</span>
                </a>
            </div>
            

<a href="#" data-target="mobile-nav" class="sidenav-trigger button-collapse"><i class="fas fa-bars"></i></a>
<ul class="right nav-menu">
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/" class="waves-effect waves-light">
      
      <i class="fas fa-home" style="zoom: 0.6;"></i>
      
      <span>首页</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/tags" class="waves-effect waves-light">
      
      <i class="fas fa-tags" style="zoom: 0.6;"></i>
      
      <span>标签</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/categories" class="waves-effect waves-light">
      
      <i class="fas fa-bookmark" style="zoom: 0.6;"></i>
      
      <span>分类</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/archives" class="waves-effect waves-light">
      
      <i class="fas fa-archive" style="zoom: 0.6;"></i>
      
      <span>归档</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/about" class="waves-effect waves-light">
      
      <i class="fas fa-user-circle" style="zoom: 0.6;"></i>
      
      <span>关于</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/friends" class="waves-effect waves-light">
      
      <i class="fas fa-address-book" style="zoom: 0.6;"></i>
      
      <span>友情链接</span>
    </a>
    
  </li>
  
  <li>
    <a href="#searchModal" class="modal-trigger waves-effect waves-light">
      <i id="searchIcon" class="fas fa-search" title="搜索" style="zoom: 0.85;"></i>
    </a>
  </li>
</ul>


<div id="mobile-nav" class="side-nav sidenav">

    <div class="mobile-head bg-color">
        
        <img src="/medias/logo.png" class="logo-img circle responsive-img">
        
        <div class="logo-name">hermia&#39;s blog</div>
        <div class="logo-desc">
            
            个人技术博客
            
        </div>
    </div>

    

    <ul class="menu-list mobile-menu-list">
        
        <li class="m-nav-item">
	  
		<a href="/" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-home"></i>
			
			首页
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/tags" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-tags"></i>
			
			标签
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/categories" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-bookmark"></i>
			
			分类
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/archives" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-archive"></i>
			
			归档
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/about" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-user-circle"></i>
			
			关于
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/friends" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-address-book"></i>
			
			友情链接
		</a>
          
        </li>
        
        
    </ul>
</div>


        </div>

        
    </nav>

</header>

    



<div class="bg-cover pd-header post-cover" style="background-image: url('/medias/featureimages/48.jpg')">
    <div class="container" style="right: 0px;left: 0px;">
        <div class="row">
            <div class="col s12 m12 l12">
                <div class="brand">
                    <h1 class="description center-align post-title">Vue（七）</h1>
                </div>
            </div>
        </div>
    </div>
</div>




<main class="post-container content">

    
    <link
  rel="stylesheet"
  href="/libs/tocbot/tocbot.css"
/>
<style>
  #articleContent h1::before,
  #articleContent h2::before,
  #articleContent h3::before,
  #articleContent h4::before,
  #articleContent h5::before,
  #articleContent h6::before {
    display: block;
    content: " ";
    height: 100px;
    margin-top: -100px;
    visibility: hidden;
  }

  #articleContent :focus {
    outline: none;
  }

  .toc-fixed {
    position: fixed;
    top: 64px;
  }

  /* .toc-widget {
        width: 345px;
        padding-left: 20px;
    } */
  .toc-widget {
    width: 345px;
    padding-left: 20px;
    background-color: rgb(255, 255, 255, 0.7);
    border-radius: 10px;
    box-shadow: 0 10px 35px 2px rgba(0, 0, 0, 0.15),
      0 5px 15px rgba(0, 0, 0, 0.07), 0 2px 5px -5px rgba(0, 0, 0, 0.1) !important;
  }

  .toc-widget .toc-title {
    padding: 35px 0 15px 17px;
    font-size: 1.5rem;
    font-weight: bold;
    line-height: 1.5rem;
  }

  .toc-widget ol {
    padding: 0;
    list-style: none;
  }

  #toc-content {
    padding-bottom: 30px;
    overflow: auto;
  }

  #toc-content ol {
    padding-left: 10px;
  }

  #toc-content ol li {
    padding-left: 10px;
  }

  #toc-content .toc-link:hover {
    color: #a3ddf0;
    font-weight: 700;
    text-decoration: underline;
  }

  #toc-content .toc-link::before {
    background-color: transparent;
    max-height: 25px;

    position: absolute;
    right: 23.5vw;
    display: block;
  }

  #toc-content .is-active-link {
    color: #a3ddf0;
  }

  #floating-toc-btn {
    position: fixed;
    right: 15px;
    bottom: 76px;
    padding-top: 15px;
    margin-bottom: 0;
    z-index: 998;
  }

  #floating-toc-btn .btn-floating {
    width: 48px;
    height: 48px;
  }

  #floating-toc-btn .btn-floating i {
    line-height: 48px;
    font-size: 1.4rem;
  }
</style>
<div class="row">
  <div id="main-content" class="col s12 m12 l9">
    <!-- 文章内容详情 -->
<div id="artDetail">
    <div class="card">
        <div class="card-content article-info">
            <div class="row tag-cate">
                <div class="col s7">
                    
                    <div class="article-tag">
                        
                            <a href="/tags/Vue/">
                                <span class="chip bg-color">Vue</span>
                            </a>
                        
                    </div>
                    
                </div>
                <div class="col s5 right-align">
                    
                    <div class="post-cate">
                        <i class="fas fa-bookmark fa-fw icon-category"></i>
                        
                            <a href="/categories/%E6%8A%80%E6%9C%AF/" class="post-category">
                                技术
                            </a>
                        
                    </div>
                    
                </div>
            </div>

            <div class="post-info">
                
                <div class="post-date info-break-policy">
                    <i class="far fa-calendar-minus fa-fw"></i>发布日期:&nbsp;&nbsp;
                    2024-01-27
                </div>
                

                
                <div class="post-date info-break-policy">
                    <i class="far fa-calendar-check fa-fw"></i>更新日期:&nbsp;&nbsp;
                    2024-01-28
                </div>
                

                
                <div class="info-break-policy">
                    <i class="far fa-file-word fa-fw"></i>文章字数:&nbsp;&nbsp;
                    34.3k
                </div>
                

                

                
            </div>
        </div>
        <hr class="clearfix">

        

        

        <div class="card-content article-card-content">
            <div id="articleContent">
                <span id="more"></span>
<h3 id="一、路由的概念"><a href="#一、路由的概念" class="headerlink" title="一、路由的概念"></a>一、路由的概念</h3><blockquote>
<p>路由本质是请求 ULR 地址与响应内容之间的一种对应关系（映射关系）</p>
<ul>
<li>以下为后端路由原理示意图：<img src="后端路由原理示意图.png"></li>
</ul>
</blockquote>
<p>注：</p>
<ul>
<li>浏览器通过 URL 向后端服务器发送请求获取数据，后端会找到与此请求相匹配的 URL，然后响应对应的数据内容给到浏览器端。</li>
<li>请求 URL 之所以能返回对应内容，是因为后端路由设置好了，什么 URL 请求响应什么内容</li>
<li>路由分类：后端路由和前端路由</li>
</ul>
<h3 id="二、后端路由原理解析和实现"><a href="#二、后端路由原理解析和实现" class="headerlink" title="二、后端路由原理解析和实现"></a>二、后端路由原理解析和实现</h3><blockquote>
<ul>
<li>后端路由主要由<strong>服务端</strong>进行实现，用来实现资源映射分发。</li>
<li>根据不同的 URL 请求，返回不同的内容。</li>
<li>后端路由本质：是请求 URL 与服务器资源之间的对应关系（映射）</li>
</ul>
</blockquote>
<ul>
<li>后端路由常用来实现 <strong>MPA 多页面应用</strong><img src="后端路由原理示意图.png"></li>
</ul>
<ol start="2">
<li>MPA 多页面应用<blockquote>
<p>MPA（<code>Mutiple-page application</code>，多页应用）是指有多个独立页面的应用，每个页面都是由后端服务返回的一个<strong>独立的渲染好的 html 网页</strong></p>
<ul>
<li>在多页面应用中，从一个页面跳转到另一个页面，相当于向服务器发送了一次请求，服务器会返回一个新的 HTML 网页给到前端，然后浏览器会将返回的 HTML 页面渲染呈现给用户。</li>
</ul>
</blockquote>
</li>
</ol>
<p>多页面应用的优缺点</p>
<ul>
<li>缺点：<ul>
<li>每次页面切换，都需要整页刷新</li>
<li>前后端不分离，每次请求后端需要把数据渲染成 HTML 文档返回。相当于数据渲染成 HTML 文档的工作要后端来实现。</li>
</ul>
</li>
<li>优点：<ul>
<li>更有利于 SEO 搜索引擎优化，因为服务端返回的内容是渲染好的 HTML 文档</li>
</ul>
</li>
</ul>
<ol start="3">
<li>后端路由实现多页面应用<blockquote>
<p>如果一个网站为一个多页面应用，整个应用由网站首页，关于我们，404 页面三个 HTML 页面组成。</p>
<ul>
<li>当我们从网站首页跳转到关于我们页面时，相当于浏览器向服务端发送了一次请求，服务端返回了<strong>渲染好的</strong><code>about.html</code>文档，然后浏览器将 <code>HTML</code> 文档渲染成了网页</li>
</ul>
</blockquote>
</li>
</ol>
<ul>
<li>整个应用所涉及的路由及路由对应的页面、URL 地址，返回内容如下表：</li>
</ul>
<table>
<thead>
<tr>
<th>路由</th>
<th>页面</th>
<th>URL</th>
<th>返回内容</th>
</tr>
</thead>
<tbody><tr>
<td>路由一</td>
<td>网站首页</td>
<td><code>http://127.0.0.1:8889/index.html</code>或<code>http://127.0.0.1:8889</code></td>
<td><code>index.html</code>文档</td>
</tr>
<tr>
<td>路由二</td>
<td>关于我们</td>
<td><code>http://127.0.0.1:8889/about.html</code></td>
<td><code>about.html</code>文档</td>
</tr>
<tr>
<td>路由三</td>
<td><code>404</code>页面</td>
<td><code>http://127.0.0.1:8889/404</code></td>
<td><code>404.html</code>文档</td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th>路由</th>
<th>URL</th>
<th>返回内容</th>
</tr>
</thead>
<tbody><tr>
<td>路由四</td>
<td><code>http://127.0.0.1:8889/basic.css</code></td>
<td><code>basic.css</code>文件</td>
</tr>
</tbody></table>
<blockquote>
<p>代码演示：本案例采用nodejs实现</p>
</blockquote>
<ul>
<li><code>server.js</code> 用于服务端创建多个后端路由</li>
</ul>
<pre><code>const http = require(&quot;http&quot;);
const fs = require(&quot;fs&quot;);
http
  .createServer((request, response) =&gt; &#123;
    // 设置响应头
    response.writeHead(200, &#123;
      &quot;Content-Type&quot;: &quot;text/html;charset:utf-8&quot;,
      &quot;Access-Control-Allow-Origin&quot;: &quot;*&quot;, // 允许跨域
    &#125;);
    let data = &quot;&quot;;
    if (request.url === &quot;/about.html&quot;) &#123;
      // 读取html页面内容
      data = fs.readFileSync(&quot;./about.html&quot;, &quot;utf-8&quot;);
    &#125; else if (request.url === &quot;/&quot; || request.url === &quot;/index.html&quot;) &#123;
      // 读取html页面内容
      data = fs.readFileSync(&quot;./index.html&quot;, &quot;utf-8&quot;);
    &#125; else if (request.url === &quot;/basic.css&quot;) &#123;
      // 设置响应的内容类型
      response.writeHead(200, &#123;
        &quot;Content-Type&quot;: &quot;text/css;charset:utf-8&quot;,
      &#125;);
      // 读取css内容
      data = fs.readFileSync(&quot;./basic.css&quot;, &quot;utf-8&quot;);
    &#125; else &#123;
      data = fs.readFileSync(&quot;./404.html&quot;, &quot;utf-8&quot;);
    &#125;
    // 响应体内容
    response.end(data);
  &#125;)
  .listen(8889);

console.log(&quot;Server running at http:127.0.0.1:8889&quot;);
</code></pre>
<ul>
<li><code>index.html</code>、<code>about.html</code>、<code>404.html</code>文件内容如下</li>
</ul>
<pre><code>&lt;!---index.html --&gt;
&lt;body&gt;
  &lt;div class=&quot;menu&quot;&gt;
    &lt;a href=&quot;/index.html&quot; class=&quot;active&quot;&gt;网站首页&lt;/a&gt; |
    &lt;a href=&quot;/about.html&quot;&gt;关于我们&lt;/a&gt;
  &lt;/div&gt;

  &lt;div class=&quot;main&quot;&gt;网站首页&lt;/div&gt;
&lt;/body&gt;

&lt;!---about.html --&gt;
&lt;body&gt;
  &lt;div class=&quot;menu&quot;&gt;
    &lt;a href=&quot;/index.html&quot;&gt;网站首页&lt;/a&gt; |
    &lt;a href=&quot;/about.html&quot; class=&quot;active&quot;&gt;关于我们&lt;/a&gt;
  &lt;/div&gt;

  &lt;div class=&quot;main&quot;&gt;关于我们&lt;/div&gt;
&lt;/body&gt;

&lt;!---404.html --&gt;
&lt;body&gt;
  404页面,点击&lt;a href=&quot;/&quot; style=&quot;color:red&quot;&gt; 首页 &lt;/a&gt;返回网站首页
&lt;/body&gt;
</code></pre>
<ul>
<li><code>basic.css</code>文件内容如下</li>
</ul>
<pre><code>.main &#123;
  display: flex;
  justify-content: center;
  align-items: center;
  font-size: 40px;
&#125;
.menu &#123;
  margin: 50px auto 100px;
  text-align: center;
&#125;
a &#123;
  color: #000;
  font-size: 20px;
  text-decoration: none;
&#125;
a.active &#123;
  color: red;
  font-weight: bold;
  font-size: 22px;
&#125;
</code></pre>
<h3 id="三、前端路由原理和实现"><a href="#三、前端路由原理和实现" class="headerlink" title="三、前端路由原理和实现"></a>三、前端路由原理和实现</h3><h4 id="前端路由概念"><a href="#前端路由概念" class="headerlink" title="前端路由概念"></a>前端路由概念</h4><blockquote>
<p>前端路由描述的是 URL 与页面内容之间的映射关系。这种映射关系是指，当 URL 发生变化时，页面对应的内容会更新，但不会刷新整个页面，只会刷新需要更新内容的部分。</p>
<ul>
<li>前端路由主要用来实现 SPA 单页面应用</li>
</ul>
</blockquote>
<h4 id="前端-2-种路由模式"><a href="#前端-2-种路由模式" class="headerlink" title="前端 2 种路由模式"></a>前端 2 种路由模式</h4><blockquote>
<p>前端路由有以下两种模式，并且每种模式的路由表现形式和实现方式都不一样</p>
</blockquote>
<blockquote>
<ul>
<li>两种路由模式的表现形式<table>
<thead>
<tr>
<th>路由模式</th>
<th>路由表现形式</th>
</tr>
</thead>
<tbody><tr>
<td>hash</td>
<td>地址的 URL 中带有<code>#</code>号，如：<code>http://www.xxx.com/#/about</code>，<code>#</code>符号后面的 URL 部分为 hash 值</td>
</tr>
<tr>
<td>history</td>
<td>地址的 URL 为正常模式，如：<code>http://www.xx.com/a/b/c</code></td>
</tr>
</tbody></table>
</li>
</ul>
</blockquote>
<blockquote>
<ul>
<li>两种路由模式的实现方式<table>
<thead>
<tr>
<th>路由模式</th>
<th>实现方式</th>
</tr>
</thead>
<tbody><tr>
<td>hash</td>
<td>主要是通过监听浏览器的hashchange事件来实现</td>
</tr>
<tr>
<td>history</td>
<td>主要是通过监听浏览器的popstate事件与History API来实现</td>
</tr>
</tbody></table>
</li>
</ul>
</blockquote>
<h4 id="hashchange-事件"><a href="#hashchange-事件" class="headerlink" title="hashchange 事件"></a>hashchange 事件</h4><blockquote>
<p>当请求的 URL 的片段标识符（跟在<code>＃</code>符号后面的 URL 部分，包括<code>＃</code>符号）发生改变时，就会触发<code>hashchange</code>事件。</p>
<ul>
<li><code>hashchange</code>事件主要用来解决前端 hash 路由，其实现原理如下：</li>
</ul>
</blockquote>
<ul>
<li>在该事件中通过<code>location.hash</code>拿到当前 URL 地址<code>#</code>号后面的<code>hash</code>值。</li>
<li>根据 <code>hash</code> 值来判断发送请求的 url，再通过<code>Ajax</code>或<code>Fetch</code>向后端服务器发送请求获取数据，然后将数据渲染成 <code>DOM</code>，插入页面更新页面内容。</li>
<li>这种方式更新页面内容，并不会刷新整个页面，也不会产生新的页面，所以整个应用只有一个 HTML 页面。内容的更新只是在更新当前 HTML 页面内容<img src="hashchange事件.png"></li>
</ul>
<ol>
<li>hashchange 事件基本用法</li>
</ol>
<ul>
<li><code>hashchange</code>事件为浏览器事件，通过以下方式来进行监听</li>
</ul>
<pre><code>window.addEventListener(
  &quot;hashchange&quot;,
  function () &#123;
    // ....
  &#125;,
  false
);
</code></pre>
<ul>
<li>通过<code>location.hash</code>拿到 hash 值，地址<code>#</code>号后面的内容就是 hash 内容</li>
</ul>
<pre><code>window.addEventListener(&#39;hashchange&#39;, function() &#123;
    const hash = location.hash // 获取地址栏中的hash值
    &#125;, false);
/
</code></pre>
<ul>
<li>根据 hash 值决定最终要发送的 ajax 请求，获取对应内容，渲染成 DOM，插入到当前面。</li>
</ul>
<pre><code>window.addEventListener(
  &quot;hashchange&quot;,
  function () &#123;
    const hash = location.hash; // 获取地址栏中的hash值
    if (hash === &quot;#/about&quot;) &#123;
      // 发请求获了数据，然后将返回的数据渲染成DOM插入页面中，更新页面内容
      // .......
      console.log(hash); // #/about
    &#125; else if (hash === &quot;#/news&quot;) &#123;
      // 发请求获了数据，然后将返回的数据渲染成DOM插入页面中，更新页面内容
      // .......
      console.log(hash); // #/news
    &#125; else &#123;
      // .....
    &#125;
  &#125;,
  false
);
</code></pre>
<ol start="2">
<li>SPA 单页面应用<blockquote>
<p>SPA（<code>Single-page application</code>，单页应用）整个应用是只会加载一个单独的 HTML 网页（只会在第一次进到应用时，会向服务器发送请求，获取一个 HTML 网页）。后面需要显示不同的内容时，可以通过<code>Ajax</code>或<code>Fetch</code>向服务端请求内容来更新主体内容</p>
<p>这使得用户在访问网站时无需加载新的页面，可以获得性能提升和动态的体验，但会相应地丧失诸如 SEO（搜索引擎优化）的优势，因为应用主页面只有一些简单的 HTML 框架和 JS 代码。</p>
</blockquote>
</li>
</ol>
<p>SPA 单页面应用优缺点：</p>
<ul>
<li>优点：<ul>
<li>用户体验好，内容改变不需要重新加载整个页面，基于这一点，对服务器的压力较小</li>
<li>前后端分离，后端只需要返回对应的 JSON 数据，前端拿到数据后渲染成 DOM 插入页面</li>
</ul>
</li>
<li>缺点：<ul>
<li>不利于 SEO 搜索引擎优化</li>
<li>初次加载耗时多</li>
</ul>
</li>
</ul>
<h4 id="hash-模式的-SPA-单页面应用"><a href="#hash-模式的-SPA-单页面应用" class="headerlink" title="hash 模式的 SPA 单页面应用"></a>hash 模式的 SPA 单页面应用</h4><blockquote>
<p>以下为一个单页面的 web 应用，当地址中的 hash 值发生改变时，就会通过<code>Ajax</code>或<code>Fetch</code>向后台发请求，拿到数据后将其渲染成 DOM，然后插入到页面更新当前页内容。</p>
</blockquote>
<blockquote>
<p>实现原理</p>
</blockquote>
<ul>
<li>监听<code>hashchange</code>事件，当地址栏中的 hash 值发生变化时，会触发 <code>hashchange</code> 事件</li>
<li>在<code>hashchange</code>事件中通过<code>location.hash</code>来获取更新后的 hash 值。</li>
<li>根据对应的 hash 来判断应该向那个地址发送请求获取数据。</li>
<li>将获取的数据渲染成 DOM 插入到页面中。</li>
</ul>
<ol>
<li>简单版</li>
</ol>
<pre><code>&lt;style&gt;
  .router-link &#123;
    display: flex;
    list-style: none;
  &#125;
  .router-link li &#123;
    padding: 0px 10px;
  &#125;
  .router-link li a &#123;
    text-decoration: none;
    color: #000;
  &#125;
  .router-link li a:hover &#123;
    color: red;
  &#125;
&lt;/style&gt;

&lt;body&gt;
  &lt;!--路由导航--&gt;
  &lt;ul class=&quot;router-link&quot;&gt;
    &lt;li&gt;&lt;a href=&quot;#/home&quot;&gt;网站首页&lt;/a&gt;&lt;/li&gt;
    &lt;li&gt;&lt;a href=&quot;#/about&quot;&gt;关于我们&lt;/a&gt;&lt;/li&gt;
    &lt;li&gt;&lt;a href=&quot;#/news&quot;&gt;新闻中心&lt;/a&gt;&lt;/li&gt;
  &lt;/ul&gt;
  &lt;!--路由内容出口--&gt;
  &lt;div class=&quot;router-view&quot;&gt;&lt;/div&gt;

  &lt;script&gt;
    // 路由出口容器
    const $routerView = document.querySelector(&quot;.router-view&quot;);

    // 一上来就调下 onHashChange方法，根据路由显示页面内容
    onHashChange();
    // 监听 hashchange事件
    window.addEventListener(&quot;hashchange&quot;, onHashChange, false);
    function onHashChange() &#123;
      //  获取当前地址的 hash值
      const hash = location.hash;
      if (hash === &quot;#/home&quot; || hash === &quot;&quot;) &#123;
        // .... 发请求，拿数据，然后渲染
        $routerView.innerHTML = &quot;网站首页&quot;;
      &#125; else if (hash === &quot;#/about&quot;) &#123;
        $routerView.innerHTML = &quot;关于我们&quot;;
      &#125; else if (hash === &quot;#/news&quot;) &#123;
        $routerView.innerHTML = &quot;新闻中心&quot;;
      &#125; else &#123;
        $routerView.innerHTML = &quot;&quot;;
      &#125;
    &#125;
  &lt;/script&gt;
&lt;/body&gt;
</code></pre>
<ol start="2">
<li>优化版<blockquote>
<p>第一步：创建 <code>index.html</code> 项目入口文件</p>
<ul>
<li>在该文件中利用 <code>HTML + CSS</code>实现当前应用的导航和对应视图渲染出口架构</li>
</ul>
</blockquote>
</li>
</ol>
<pre><code>&lt;style&gt;
  .router-link &#123;
    display: flex;
    list-style: none;
  &#125;
  .router-link li &#123;
    padding: 0 10px;
  &#125;
  .router-link li a &#123;
    text-decoration: none;
    color: #000;
  &#125;
  .router-link li a:hover &#123;
    color: red;
  &#125;
  .router-link li a.active &#123;
    color: red;
  &#125;
&lt;/style&gt;

&lt;body&gt;
  &lt;!-- 定义路由导航 --&gt;
  &lt;ul class=&quot;router-link&quot;&gt;
    &lt;li&gt;&lt;a href=&quot;#/home&quot;&gt;网站首页&lt;/a&gt;&lt;/li&gt;
    &lt;li&gt;&lt;a href=&quot;#/about&quot;&gt;关于我们&lt;/a&gt;&lt;/li&gt;
    &lt;li&gt;&lt;a href=&quot;#/news&quot;&gt;新闻中心&lt;/a&gt;&lt;/li&gt;
  &lt;/ul&gt;
  &lt;!-- 路由视图（内容出口） --&gt;
  &lt;div class=&quot;router-view&quot;&gt;&lt;/div&gt;
&lt;/body&gt;
</code></pre>
<blockquote>
<p>第二步：定义路由</p>
<ul>
<li>创建<code>router/routes.js</code>文件，在该文件中对外暴露一个数组，数组中的每一项为一个对象，该对象我们称为路由对象，记录了当前路由相关的信息。</li>
</ul>
</blockquote>
<pre><code>export const routes = [
  &#123;
    name: &quot;网站首页&quot;,
    path: &quot;#/&quot;,
  &#125;,
  &#123;
    name: &quot;网站首页&quot;,
    path: &quot;#/home&quot;,
  &#125;,
  &#123;
    name: &quot;关于我们&quot;,
    path: &quot;#/about&quot;,
  &#125;,
  &#123;
    name: &quot;新闻中心&quot;,
    path: &quot;#/news&quot;,
  &#125;,
  // 你有多少个路由，往后加就行
];
</code></pre>
<blockquote>
<p>第三步：定义每个路由渲染内容的方法</p>
<ul>
<li>每个路由对应的页面要显示的内容我们定义在一个单独的 JS 文件中 ，然后对外暴露一个方法，调用该方法就可以获取要显示的 HTML 字符串。</li>
<li>考虑到后期内容是通过 ajax 或 fetch 发请求获取，返回的内容会被 Promise 包装，则将方法定义成 async 函数，方便在内部接受请求回来的值，如：<code>await getData(url)</code></li>
</ul>
</blockquote>
<ul>
<li><code>pages/home.js</code> 文件 - 返回网站首页内容</li>
</ul>
<pre><code>export async function home() &#123;
  // await getDate(url)
  return &quot;网站首页&quot;; // 返回的内容会被Promise包装
&#125;
</code></pre>
<ul>
<li><code>pages/about.js</code> 文件 - 返回关于我们内容</li>
</ul>
<pre><code>export async function about() &#123;
  return &quot;关于我们&quot;; // 返回的内容会被Promise包装
&#125;
</code></pre>
<ul>
<li><code>pages/news.js</code>文件 - 返回新闻中心内容</li>
</ul>
<pre><code>export async function news() &#123;
  return &quot;新闻中心&quot;; // 返回的内容会被Promise包装
&#125;
</code></pre>
<ul>
<li><code>pages/nofound.js</code> - 返回 404 页面内容</li>
</ul>
<pre><code>export async function nofound() &#123;
  return &quot;404页面&quot;; // 返回的内容会被Promise包装
&#125;
</code></pre>
<blockquote>
<p>第四步：定义路由对象的 render 方法</p>
<ul>
<li>每一条路由都有其要显示的内容，通过调用路由对象的 render 方法就可以获取要渲染内容的 HTML 字符串。</li>
</ul>
</blockquote>
<pre><code>// 以下方法 home about news 用来返回对应页面的渲染好的html字符串内容
import &#123; home &#125; from &quot;../pages/home.js&quot;;
import &#123; about &#125; from &quot;../pages/about.js&quot;;
import &#123; news &#125; from &quot;../pages/news.js&quot;;

export const routes = [
  &#123;
    name: &quot;网站首页&quot;,
    path: &quot;#/&quot;,
    render: home, // 得到当前网站首页要渲染的html字符串
  &#125;,
  &#123;
    name: &quot;网站首页&quot;,
    path: &quot;#/home&quot;,
    render: home, // 得到当前网站首页要渲染的html字符串
  &#125;,
  &#123;
    name: &quot;关于我们&quot;,
    path: &quot;#/about&quot;,
    render: about,
  &#125;,
  &#123;
    name: &quot;新闻中心&quot;,
    path: &quot;#/news&quot;,
    render: news,
  &#125;,
  // 你有多少个路由，往后加就行
];
</code></pre>
<blockquote>
<p>第五步：实现按路由渲染内容</p>
<ul>
<li>在<code>index.html</code>页面实现主要的业务逻辑，根据不同的路由渲染不同的内容</li>
</ul>
</blockquote>
<pre><code>&lt;script type=&quot;module&quot;&gt;
  // 导入路由
  import &#123; routes &#125; from &quot;./router/routes.js&quot;;
  // 导航 404d页面渲染函数
  import &#123; nofound &#125; from &quot;./pages/nofound.js&quot;;
  // 获取路由出口容器
  const $routerView = document.querySelector(&quot;.router-view&quot;);
  // 监听 hashchange事件， 当地址栏中的hash值发生改变时，会触发hashchange事件
  window.addEventListener(&quot;hashchange&quot;, onHashChange);
  // 一上来就调用，根据路由渲染初始内容
  onHashChange();
  async function onHashChange() &#123;
    // 获取到hash值
    const hash = location.hash;
    // 根据hash值，找到对应路由对象，然后拿到对应路由的要渲染的html字符串
    const route = routes.find((item) =&gt; item.path === hash);
    // 如果route存在，调用render方法获取路由要渲染的html字符串内容
    if (route) &#123;
      $routerView.innerHTML = await route.render();
    &#125; else &#123;
      // 不存当前路由就显示404页面内容
      $routerView.innerHTML = await nofound();
    &#125;
  &#125;
&lt;/script&gt;
</code></pre>
<blockquote>
<ul>
<li>刚开始进到网站首页时，并没有渲染首页面容，是因为我们没有在路由中定义该路由信息，所以需要在<code>router/routes.js</code>中再添加一条路由信息。</li>
</ul>
</blockquote>
<pre><code>export const routes = [
  &#123;
    name: &quot;网站首页&quot;,
    path: &quot;&quot;,
    render: home, // 得到当前网站首页要渲染的html字符串
  &#125;,
  &#123;
    name: &quot;网站首页&quot;,
    path: &quot;#/&quot;,
    render: home, // 得到当前网站首页要渲染的html字符串
  &#125;,
  &#123;
    name: &quot;网站首页&quot;,
    path: &quot;#/home&quot;,
    render: home, // 得到当前网站首页要渲染的html字符串
  &#125;,
  // ......
  // 你有多少个路由，往后加就行
];
</code></pre>
<ul>
<li>上面路由配置表示 <code>http://127.0.0.1:5500/index.html</code> 、<code>http://127.0.0.1:5500/#/</code> 、<code>http://127.0.0.1:5500/#/home</code> 三个地址都显示网站首页内容</li>
</ul>
<blockquote>
<p>第六步：完善新闻中心页内容</p>
<ul>
<li>完善<code>pages/news.js</code>文件的<code>news</code>方法，在该方法中通过fetch发请求获取数据，然后将获取的数据与 HTML 结合成 HTML 字符串，最终返回该 HTML 字符串。</li>
<li>将发请求获取数据的代码封装在 <code>getData</code> 方法中，并将该方法定义在<code>data/getData.js</code>文件中</li>
</ul>
</blockquote>
<ul>
<li><code>data/getData.js</code> 文件内容</li>
</ul>
<pre><code>export function getData(url) &#123;
  return new Promise((resolve, reject) =&gt; &#123;
    // fetch请求向后台获取数据
    fetch(url)
      .then((res) =&gt; &#123;
        if ((res.status &lt;= 200 &amp;&amp; res.status &lt; 300) || res.status === 304) &#123;
          return res.json(); // 读取数据流
        &#125;
      &#125;)
      .then((data) =&gt; &#123;
        resolve(data.data);
      &#125;)
      .catch((err) =&gt; &#123;
        reject();
      &#125;);
  &#125;);
&#125;
</code></pre>
<ul>
<li><code>pages/news.js</code>文件内容<ul>
<li>我们可给渲染出来的 DOM 添加 CSS 样式</li>
</ul>
</li>
</ul>
<pre><code>import &#123; getData &#125; from &quot;../data/getData.js&quot;;
// 导入css ，为渲染出来DOM添加css样式
import &quot;../css/news.css&quot;;
// 请求数据源
let url =
  &quot;https://www.fastmock.site/mock/6ec78e345df340241e1f5043f0167833/icode/news/8&quot;;
export async function news() &#123;
  let html = &quot;&lt;ul class=&#39;news&#39;&gt;&quot;;
  // 获取请求的数据
  const data = await getData(url);
  // 遍历数据，将数据与html结合拼接成html字符串
  data.forEach((item) =&gt; &#123;
    html += `
                &lt;li&gt;
                    &lt;a href=&#39;$&#123;item.path&#125;&#39;&gt;$&#123;item.title&#125;&lt;/a&gt;
                &lt;/li&gt;
               `;
  &#125;);
  html += &quot;&lt;/ul&gt;&quot;;
  return html;
&#125;
</code></pre>
<ul>
<li>css&#x2F;news.css</li>
</ul>
<pre><code>.news &#123;
  list-style: none;
  width: 400px;
  border: 1px solid skyblue;
  padding: 10px;
&#125;
.news li &#123;
  line-height: 35px;
&#125;
.news li a &#123;
  text-decoration: none;
  color: #000;
&#125;
.news li a:hover &#123;
  color: tomato;
&#125;
</code></pre>
<blockquote>
<p>第七步：运行程序</p>
<ul>
<li>因为我们在项目中用到了<code>import &#39;../css/news.css&#39;</code>导入 CSS，而浏览器本身是不支持这个语法的，所以我们需要借助vite构建工具来构建项目</li>
<li>执行<code>npm create vite@latest</code>安装 vite 前端构建工具</li>
<li>删除<code>vite-project</code>文件夹中的<code>index.html</code>文件</li>
<li>将以上文件都放入生成的<code>vite-project</code>文件夹，然后执行npx vite就可以启动项目</li>
</ul>
</blockquote>
<ul>
<li>我们发现新闻中心的数据是通过请求获取的，并且对应的 CSS 样式也生效了。</li>
</ul>
<p>注：</p>
<ul>
<li>不过以上效果还存在一个严重的 bug，当我们切换到新闻中心时，如果数据还没有回来，我们又切换到了网站首页，这里你会看到网站首页的内容会被替换成新闻中心内容。</li>
<li>因为数据请求需要一定的时间才能返回数据，所以在数据没有返回时切换到网站首页，等到请求数据回来时，就会把当.router-view中的内容替换为请求回来的新闻中心数据。</li>
<li>所以我们需要在切换到其它路由时，把之前的请求给取消。</li>
</ul>
<blockquote>
<p>第八步：取消请求</p>
</blockquote>
<ul>
<li>在<code>data/getData.js</code>中，为 <code>getData</code> 方法添加取消请求的功能。</li>
</ul>
<pre><code>// 如果内容没有回来之前，切换到了其它的页面，我就要把请求取消
let controller = new AbortController();

export function getData(url) &#123;
  // 取消请求设置
  controller = new AbortController();
  const &#123; signal &#125; = controller;

  return new Promise((resolve, reject) =&gt; &#123;
    // fetch请求向后台获取数据
    // &#123;signal&#125; 取消请求调置
    fetch(url, &#123; signal &#125;)
      .then((res) =&gt; &#123;
        if ((res.status &lt;= 200 &amp;&amp; res.status &lt; 300) || res.status === 304) &#123;
          return res.json(); // 读取数据流
        &#125;
      &#125;)
      .then((data) =&gt; &#123;
        resolve(data.data);
      &#125;)
      .catch((err) =&gt; &#123;
        reject(&quot;请求被取消了&quot;);
      &#125;);
  &#125;);
&#125;

// 调用该方法，取消请求
getData.abort = function () &#123;
  controller.abort(); // 取消当前请求
&#125;;
</code></pre>
<p>在切换到其它页面时，要取消之前的请求</p>
<ul>
<li>pages&#x2F;home.js</li>
</ul>
<pre><code>import &#123; getData &#125; from &quot;../data/getData.js&quot;;
export async function home() &#123;
  // 取消之前的请求
  getData.abort();
  return &quot;网站首页&quot;;
&#125;
</code></pre>
<ul>
<li>pages&#x2F;about.js</li>
</ul>
<pre><code>import &#123; getData &#125; from &quot;../data/getData.js&quot;;
export async function about() &#123;
  // 取消之前的请求
  getData.abort();
  return &quot;关于我们&quot;;
&#125;
</code></pre>
<ul>
<li>pages&#x2F;news.js</li>
</ul>
<pre><code>import &#123; getData &#125; from &quot;../data/getData.js&quot;;
export async function news() &#123;
  // 取消之前的请求
  getData.abort();

  //........
&#125;
</code></pre>
<ul>
<li>pages&#x2F;nofound.js</li>
</ul>
<pre><code>import &#123; getData &#125; from &quot;../data/getData.js&quot;;
export async function nofound() &#123;
  // 取消之前的请求
  getData.abort();

  return &quot;404页面&quot;;
&#125;
</code></pre>
<blockquote>
<p>第九步：处理错误</p>
<ul>
<li>如果请求被取消了，是会<code>reject</code>(‘请求被取消’)，我们可以对抛出的错误捕获并处理</li>
</ul>
</blockquote>
<ul>
<li>在<code>index.html</code>中对获取数据的代码进行<code>try...catch</code>错误捕获</li>
</ul>
<pre><code>async function onHashChange() &#123;
  // ......
  if (route) &#123;
    try &#123;
      $routerView.innerHTML = await route.render();
    &#125; catch (err) &#123;
      console.log(err);
    &#125;
  &#125; else &#123;
    // 不存当前路由就显示404页面内容
    try &#123;
      $routerView.innerHTML = await nofound();
    &#125; catch (err) &#123;
      console.log(err);
    &#125;
  &#125;
&#125;
</code></pre>
<blockquote>
<p>第十步：点亮导航</p>
<ul>
<li>实现当前路由对应的导航变成红色。</li>
</ul>
</blockquote>
<ul>
<li>我们可以通过 map 建立路由与a标签元素的映射关系</li>
</ul>
<pre><code>// 获取所有a标签
const $links = document.querySelectorAll(&quot;.router-link li a&quot;);
// 建立route与a标签的一种映射关系
const map = new Map();

$links.forEach((item) =&gt; &#123;
  let href = item.getAttribute(&quot;href&quot;);
  if (href === &quot;#/home&quot;) &#123;
    map.set(href, item);
    map.set(&quot;#/&quot;, item);
    map.set(&quot;&quot;, item);
  &#125; else &#123;
    map.set(href, item);
  &#125;
&#125;);
</code></pre>
<ul>
<li>根据路由找到 a 标签，给 a 标签添加class&#x3D;’active’</li>
</ul>
<pre><code>if (route) &#123;
  // 点亮导航
  $links.forEach((item) =&gt; &#123;
    item.classList.remove(&quot;active&quot;);
  &#125;);
  // 根据路由找到对应的a标签，添加class=&#39;active&#39;
  map.get(route.path).classList.add(&quot;active&quot;);

  // 渲染导航对应内容
  try &#123;
    $routerView.innerHTML = await route.render();
  &#125; catch (err) &#123;
    console.log(err);
  &#125;
&#125; else &#123;
  // 不存当前路由就显示404页面内容
  $routerView.innerHTML = await nofound();
&#125;
</code></pre>
<blockquote>
<p>完整代码</p>
</blockquote>
<ul>
<li>项目目录结构</li>
</ul>
<pre><code>code
├─ css
│  └─ news.css  // 新闻页css
├─ data
│  └─ getData.js   // 请求数据方法
├─ index.html   // 项目入口
├─ pages    // 返回各页面html字符串的方法
│  ├─ about.js
│  ├─ home.js
│  ├─ news.js
│  └─ nofound.js
└─ routes  // 项目路由
   └─ routes.js
</code></pre>
<ul>
<li>index.html</li>
</ul>
<pre><code>&lt;style&gt;
  .router-link &#123;
    display: flex;
    list-style: none;
  &#125;
  .router-link li &#123;
    padding: 0 10px;
  &#125;
  .router-link li a &#123;
    text-decoration: none;
    color: #000;
  &#125;
  .router-link li a:hover &#123;
    color: red;
  &#125;
  .router-link li a.active &#123;
    color: red;
  &#125;
&lt;/style&gt;

&lt;body&gt;
  &lt;!-- 定义路由导航 --&gt;
  &lt;ul class=&quot;router-link&quot;&gt;
    &lt;li&gt;&lt;a href=&quot;#/home&quot;&gt;网站首页&lt;/a&gt;&lt;/li&gt;
    &lt;li&gt;&lt;a href=&quot;#/about&quot;&gt;关于我们&lt;/a&gt;&lt;/li&gt;
    &lt;li&gt;&lt;a href=&quot;#/news&quot;&gt;新闻中心&lt;/a&gt;&lt;/li&gt;
  &lt;/ul&gt;
  &lt;!-- 路由视图（内容出口） --&gt;
  &lt;div class=&quot;router-view&quot;&gt;&lt;/div&gt;

  &lt;script type=&quot;module&quot;&gt;
    // 导入路由
    import &#123; routes &#125; from &quot;./router/routes.js&quot;;
    // 导航 404d页面渲染函数
    import &#123; nofound &#125; from &quot;./pages/nofound.js&quot;;
    // 获取路由出口容器
    const $routerView = document.querySelector(&quot;.router-view&quot;);
    // 获取所有a标签
    const $links = document.querySelectorAll(&quot;.router-link li a&quot;);
    // 建立route与a标签的一种映射关系
    const map = new Map();
    $links.forEach((item) =&gt; &#123;
      let href = item.getAttribute(&quot;href&quot;);
      if (href === &quot;#/home&quot;) &#123;
        map.set(href, item);
        map.set(&quot;#/&quot;, item);
        map.set(&quot;&quot;, item);
      &#125; else &#123;
        map.set(href, item);
      &#125;
    &#125;);
    // 监听 hashchange事件， 当地址栏中的hash值发生改变时，会触发hashchange事件
    window.addEventListener(&quot;hashchange&quot;, onHashChange);
    // 一上来就调用，根据路由渲染初始内容
    onHashChange();
    async function onHashChange() &#123;
      // 获取到hash值
      const hash = location.hash;
      // 根据hash值，找到对应路由对象，然后拿到对应路由的要渲染的html字符串
      const route = routes.find((item) =&gt; item.path === hash);
      // 如果route存在，调用render方法获取路由要渲染的html字符串内容
      if (route) &#123;
        // 点亮导航
        $links.forEach((item) =&gt; &#123;
          item.classList.remove(&quot;active&quot;);
        &#125;);
        // 根据路由找到对应的a标签，添加class=&#39;active&#39;
        map.get(route.path).classList.add(&quot;active&quot;);
        try &#123;
          $routerView.innerHTML = await route.render();
        &#125; catch (err) &#123;
          console.log(err);
        &#125;
      &#125; else &#123;
        // 不存当前路由就显示404页面内容
        $routerView.innerHTML = await nofound();
      &#125;
    &#125;
  &lt;/script&gt;
&lt;/body&gt;
</code></pre>
<ul>
<li>router&#x2F;routes.js</li>
</ul>
<pre><code>// 以下方法 home about news 用来返回对应页面的渲染好的html字符串内容
import &#123; home &#125; from &quot;../pages/home.js&quot;;
import &#123; about &#125; from &quot;../pages/about.js&quot;;
import &#123; news &#125; from &quot;../pages/news.js&quot;;

export const routes = [
  &#123;
    name: &quot;网站首页&quot;,
    path: &quot;&quot;,
    render: home, // 得到当前网站首页要渲染的html字符串
  &#125;,
  &#123;
    name: &quot;网站首页&quot;,
    path: &quot;#/&quot;,
    render: home, // 得到当前网站首页要渲染的html字符串
  &#125;,
  &#123;
    name: &quot;网站首页&quot;,
    path: &quot;#/home&quot;,
    render: home, // 得到当前网站首页要渲染的html字符串
  &#125;,
  &#123;
    name: &quot;关于我们&quot;,
    path: &quot;#/about&quot;,
    render: about,
  &#125;,
  &#123;
    name: &quot;新闻中心&quot;,
    path: &quot;#/news&quot;,
    render: news,
  &#125;,
  // 你有多少个路由，往后加就行
];
</code></pre>
<ul>
<li>pages&#x2F;home.js</li>
</ul>
<pre><code>// 考虑到后期内容是通过ajax或fetch发请求获取
// 返回的内容会被Promise包装，则将方法定义成async函数，方便接受请求回来的值
// await getData(url)
import &#123; getData &#125; from &quot;../data/getData&quot;;
export async function home() &#123;
  // 取消之前的请求
  getData.abort();
  return &quot;网站首页&quot;;
&#125;
</code></pre>
<ul>
<li>page&#x2F;about.js</li>
</ul>
<pre><code>import &#123; getData &#125; from &quot;../data/getData&quot;;
export async function about() &#123;
  // 取消之前的请求
  getData.abort();
  return &quot;关于我们&quot;;
&#125;
</code></pre>
<ul>
<li>pages&#x2F;news.js</li>
</ul>
<pre><code>import &#123; getData &#125; from &quot;../data/getData.js&quot;;
// 导入css ，为渲染出来DOM添加css样式
import &quot;../css/news.css&quot;;
// 请求数据源
let url =
  &quot;https://www.fastmock.site/mock/6ec78e345df340241e1f5043f0167833/icode/news/8&quot;;
export async function news() &#123;
  // 取消之前请求
  getData.abort();
  let html = &quot;&lt;ul class=&#39;news&#39;&gt;&quot;;
  const data = await getData(url);
  data.forEach((item) =&gt; &#123;
    html += `
                &lt;li&gt;
                    &lt;a href=&#39;$&#123;item.path&#125;&#39;&gt;$&#123;item.title&#125;&lt;/a&gt;
                &lt;/li&gt;
               `;
  &#125;);
  html += &quot;&lt;/ul&gt;&quot;;
  return html;
&#125;
</code></pre>
<ul>
<li>pages&#x2F;nofound.js</li>
</ul>
<pre><code>import &#123; getData &#125; from &quot;../data/getData.js&quot;;
export async function nofound() &#123;
  // 取消之前的请求
  getData.abort();

  return &quot;404页面&quot;;
&#125;
</code></pre>
<ul>
<li>data&#x2F;getData.js</li>
</ul>
<pre><code>// 如果内容没有回来之前，切换到了其它的页面，我就要把请求取消
let controller = new AbortController();

export function getData(url) &#123;
  // 取消请求设置
  controller = new AbortController();
  const &#123; signal &#125; = controller;

  return new Promise((resolve, reject) =&gt; &#123;
    // fetch请求向后台获取数据
    // &#123;signal&#125; 取消请求调置
    fetch(url, &#123; signal &#125;)
      .then((res) =&gt; &#123;
        if ((res.status &lt;= 200 &amp;&amp; res.status &lt; 300) || res.status === 304) &#123;
          return res.json(); // 读取数据流
        &#125;
      &#125;)
      .then((data) =&gt; &#123;
        resolve(data.data);
      &#125;)
      .catch((err) =&gt; &#123;
        reject(&quot;请求被取消了&quot;);
      &#125;);
  &#125;);
&#125;

// 调用该方法，取消请求
getData.abort = function () &#123;
  controller.abort(); // 取消当前请求
&#125;;
</code></pre>
<ul>
<li>css&#x2F;news.css 样式</li>
</ul>
<pre><code>.news &#123;
  list-style: none;
  width: 400px;
  border: 1px solid skyblue;
  padding: 10px;
&#125;
.news li &#123;
  line-height: 35px;
&#125;
.news li a &#123;
  text-decoration: none;
  color: #000;
&#125;
.news li a:hover &#123;
  color: tomato;
&#125;
</code></pre>
<h4 id="History-API-与-popstate"><a href="#History-API-与-popstate" class="headerlink" title="History API 与 popstate"></a>History API 与 popstate</h4><blockquote>
<p>History对象提供了如下 API 方法，用来实现 URL 的切换。<br>|方法|用法|<br>|go|相当于浏览器中前进或后退按扭，go(-1)后退一页，go(1)前进一页|<br>|back|相当于浏览器中的后退按扭，用于后退到前一页，back()后退一页|<br>|forward|相当于浏览器中的前进按扭，用于前进到前一页，forward()前进一页|<br>|pushState|向浏览器的会话历史栈中增加一个条目，地址栏中地址会变化，但不会向后端发请求|<br>|replaceState|修改当前历史记录，相当于替换历史栈中当前 URL，地址栏中地址会变化，但不会向后端发请求|</p>
</blockquote>
<ul>
<li>当 history 模式的 URL 地址发生变化时，某些情况下就会触发 <code>window</code> 对象上的<code>popstate</code>事件。</li>
</ul>
<ol>
<li>go，back，forward 方法</li>
</ol>
<pre><code>history.back(); // 后退
history.forward(); // 前进
history.go(1); // 前进 进入下一页
</code></pre>
<ol start="2">
<li>pushState 方法</li>
</ol>
<ul>
<li>向浏览器的会话历史栈中增加一个条目，相当于更改当前浏览器的地址，会产生历史记录</li>
<li>地址栏中 URL 虽然会变为新增的，但不会向后端发送请求，如果刷新该页面，会出现 404 错误</li>
</ul>
<pre><code>pushState(state, unused, url);
</code></pre>
<blockquote>
<p>参数</p>
</blockquote>
<ul>
<li><code>state</code>：为当前所创建的历史条件所携带的数据，其值为一个可序列化的对象，该数据保存在<code>history</code>对象的<code>state</code>属性上，同时<code>popstate</code>事件的<code>state</code>属性值为该<code>state</code>对象的副本。</li>
<li><code>unused</code>：没有用的参数，因为历史原因，但又必须存在，通常传递一个空字符串。</li>
<li><code>url</code>：新的历史条目 URL</li>
</ul>
<blockquote>
<p>案例演示</p>
</blockquote>
<pre><code>&lt;button id=&quot;add&quot;&gt;更改地址栏中URL&lt;/button&gt;
&lt;script&gt;
  const $add = document.getElementById(&quot;add&quot;);
  let num = 1;
  $add.onclick = function () &#123;
    if (num === 1) &#123;
      history.pushState(&#123; a: 1, b: 2 &#125;, &quot;&quot;, &quot;/about&quot;);
      num = 2;
    &#125; else &#123;
      history.pushState(&#123;&#125;, &quot;&quot;, &quot;/news&quot;);
    &#125;
    // 注意观察history的state属性
    console.log(history);
  &#125;;
&lt;/script&gt;
</code></pre>
<ul>
<li>注意观察地址栏中地址的变化，并且点击前进和后退按扭可以前进和回退</li>
</ul>
<ol start="3">
<li>replaceState 方法</li>
</ol>
<ul>
<li>修改当前历史记录，相当于替换历史栈中当前历史记录，地址栏为替换后地址。替换前的地址不会产生历史记录，后退按扭没法后退到替换前的地址。</li>
<li>同样不会向后端发送请求，如果刷新改页面，会出现 404 错误</li>
</ul>
<pre><code>replaceState(state, unused, url);
</code></pre>
<ul>
<li>replaceState 方法的每个参数与 pushState 方法的参数是一个意思</li>
</ul>
<pre><code>&lt;button id=&quot;add&quot;&gt;更改地址栏中URL&lt;/button&gt;
&lt;script&gt;
  const $add = document.getElementById(&quot;add&quot;);
  let num = 1;
  $add.onclick = function () &#123;
    if (num === 1) &#123;
      history.replaceState(&#123; a: 1, b: 2 &#125;, &quot;&quot;, &quot;/about&quot;);
      num = 2;
    &#125; else &#123;
      history.replaceState(&#123;&#125;, &quot;&quot;, &quot;/news&quot;);
    &#125;
    // 注意观察history的state属性
    console.log(history);
  &#125;;
&lt;/script&gt;
</code></pre>
<ul>
<li>注意观察地址栏中地址的变化，并且前进和后退按扭是灰色的禁用状态。</li>
</ul>
<ol start="4">
<li>popstate 事件</li>
</ol>
<ul>
<li>当 history 模式的 URL 地址发生变化时，popstate 事件只会在浏览器某些行为下触发。比如：点击后退按钮或者在 JavaScript 中调用<code>history.back</code>() 等方法</li>
</ul>
<blockquote>
<p>注意事项</p>
</blockquote>
<ul>
<li>如果当前的 URL 的地址是通过<code>history.pushState()</code> 创建或者 <code>history.replaceState()</code>方法修改的，则不会触发<code>popstate</code>事件。</li>
<li><code>popstate</code>事件的的事件对象 e 上可以获取通过<code>pushState</code>、<code>replaceState</code>方法添加的历史条目的 <code>state</code> 值。</li>
<li>通过<code>location.pathname</code>可以获取到当前 URL 的后面的路径值。</li>
</ul>
<blockquote>
<p>代码演示</p>
</blockquote>
<pre><code>&lt;button id=&quot;but&quot;&gt;更改地址栏中URL&lt;/button&gt;
&lt;script&gt;
  window.addEventListener(&quot;popstate&quot;, (e) =&gt; &#123;
    console.log(&quot;pathname:&quot;, location.pathname);
    console.log(&quot;state:&quot;, e.state);
  &#125;);

  // 获取元素，添加点击事件
  $but = document.getElementById(&quot;but&quot;);
  $but.onclick = changeUrl;

  let num = 0;
  function changeUrl() &#123;
    num++;
    switch (num) &#123;
      case 1:
        history.pushState(&#123;&#125;, &quot;&quot;, &quot;/home&quot;); // 不会触发popstate事件
        break;
      case 2:
        history.pushState(&#123;&#125;, &quot;&quot;, &quot;/about&quot;); // 不会触发popstate事件
        break;
      case 3:
        history.replaceState(&#123; a: 1 &#125;, &quot;&quot;, &quot;/news&quot;); // 不会触发popstate事件
        break;
      case 4:
        history.back(); // 会触发popstate事件
        break;
      case 5:
        history.go(1); // 会触发popstate事件
        break;
    &#125;
  &#125;
&lt;/script&gt;
</code></pre>
<ul>
<li>前面三次地址发生了变化，都没有触发<code>popstate</code>事件，但后面两次都触发<code>popstate</code>事件</li>
</ul>
<h4 id="history-模式的-SPA-单页面应用"><a href="#history-模式的-SPA-单页面应用" class="headerlink" title="history 模式的 SPA 单页面应用"></a>history 模式的 SPA 单页面应用</h4><blockquote>
<p>实现原理：</p>
</blockquote>
<ul>
<li>通过pushState和replaceState方法修改的 URL，并不会触发popstate事件，所以针对这种情况，我们可以采用如下办法：</li>
<li>通过监听<code>&lt;a&gt;</code>标签的点击事件，来监听要变化的 URL</li>
<li>针对要变化的 URL，可以调用pushState和replaceState方法来实现地址栏中 URL 的变化</li>
<li>最后根据当前地址 URL，来发送对应的Ajax或Fetch请求，获取数据后，渲染成 DOM 插入到页面，更新内容。</li>
<li>如果是调用了histroy的go、back()、forward()或浏览器的前进后退按扭来改变 URL，则都会触发popstate事件，可以在该事件中来处理。在该事件中通过location.pathname来获取 URL 的路径值</li>
</ul>
<img src="history模式的SPA单页面应用.png">

<blockquote>
<p>完整版代码</p>
</blockquote>
<pre><code>&lt;style&gt;
  .router-view &#123;
    display: flex;
    justify-content: center;
    align-items: center;
    font-size: 40px;
  &#125;
  .router-link &#123;
    display: flex;
    margin: 50px auto 100px;
    text-align: center;
    list-style: none;
  &#125;
  .router-link li &#123;
    margin: 0 10px;
  &#125;
  .router-link li a &#123;
    color: #000;
    font-size: 20px;
    text-decoration: none;
  &#125;
&lt;/style&gt;
&lt;body&gt;
  &lt;div class=&quot;router-link&quot;&gt;
    &lt;li&gt;&lt;a href=&quot;/home&quot;&gt;网站首页&lt;/a&gt;&lt;/li&gt;
    &lt;li&gt;&lt;a href=&quot;/about&quot;&gt;关于我们&lt;/a&gt;&lt;/li&gt;
    &lt;li&gt;&lt;a href=&quot;/news&quot;&gt;新闻中心&lt;/a&gt;&lt;/li&gt;
    &lt;li&gt;&lt;a href=&quot;/product&quot;&gt;产品中心&lt;/a&gt;&lt;/li&gt;
  &lt;/div&gt;
  &lt;!--路由视图：内容的出口--&gt;
  &lt;div class=&quot;router-view&quot;&gt;&lt;/div&gt;

  &lt;script&gt;
    // 获取用来放路由视图的容器
    const $routerLink = document.querySelector(&quot;.router-link&quot;);
    const $routerView = document.querySelector(&quot;.router-view&quot;);
    // 获取所有a标签
    const $links = document.querySelectorAll(&quot;a&quot;);

    // 页面首次加载时，触发onPopState方法，渲染首页内容
    window.addEventListener(&quot;DOMContentLoaded&quot;, onPopState);

    // 事件代理
    $routerLink.onclick = function (e) &#123;
      e.preventDefault();
      const target = e.target;
      const targetName = target.tagName.toLowerCase();
      if (targetName !== &quot;a&quot;) return;
      // 阻止默认行为
      e.preventDefault();
      // 清除所有a标签的active class
      $links.forEach((item) =&gt; &#123;
        item.classList.remove(&quot;active&quot;);
      &#125;);
      target.classList.add(&quot;active&quot;);
      // 更新URL
      history.pushState(&#123;&#125;, &quot;&quot;, target.getAttribute(&quot;href&quot;));
      // 更新页面内容
      onPopState();
    &#125;;

    // 根据URL变化，渲染对应的内容
    function onPopState() &#123;
      switch (location.pathname) &#123;
        case &quot;/&quot;:
        case &quot;/index.html&quot;:
        case &quot;/home&quot;:
          $routerView.innerHTML = &quot;网站首页&quot;;
          break;
        case &quot;/about&quot;:
          $routerView.innerHTML = &quot;关于我们&quot;;
          break;
        case &quot;/news&quot;:
          $routerView.innerHTML = &quot;新闻中心&quot;;
          break;
        default:
          // 对于没有匹配的路由，显示404页面
          $routerView.innerHTML = &quot;404页面&quot;;
      &#125;
    &#125;
  &lt;/script&gt;
&lt;/body&gt;
</code></pre>
<h4 id="为什么需要前端路由"><a href="#为什么需要前端路由" class="headerlink" title="为什么需要前端路由"></a>为什么需要前端路由</h4><blockquote>
<p>没有前端路由，如何实现单页面开发？</p>
<ul>
<li>我们只需要监听对应a标签的事件，然后在事件中发送<code>Ajax</code>或<code>Fetch</code>请求，拿到数据后渲染成 DOM，插入页面，更新对应内容即可。</li>
</ul>
</blockquote>
<ul>
<li>代码如下：</li>
</ul>
<pre><code>&lt;script&gt;
  // 获取用来放路由视图的容器
  const $routerLink = document.querySelector(&quot;.router-link&quot;);
  const $routerView = document.querySelector(&quot;.router-view&quot;);
  // 获取所有a标签
  const $links = document.querySelectorAll(&quot;a&quot;);

  // 页面首次加载时，触发onPopState方法，渲染首页内容
  window.addEventListener(&quot;DOMContentLoaded&quot;, onPopState);

  // 事件代理
  $routerLink.onclick = function (e) &#123;
    const target = e.target;
    const targetName = target.tagName.toLowerCase();
    if (targetName !== &quot;a&quot;) return;
    // 阻止默认行为
    e.preventDefault();
    // 清除所有a标签的active class
    $links.forEach((item) =&gt; &#123;
      item.classList.remove(&quot;active&quot;);
    &#125;);
    target.classList.add(&quot;active&quot;);
    // 更新URL
    // history.pushState(&#123;&#125;, &quot;&quot;, target.getAttribute(&quot;href&quot;));
    // 更新页面内容
    // 直接传递 url
    onPopState(target.getAttribute(&quot;href&quot;));
  &#125;;

  // 根据URL变化，渲染对应的内容
  function onPopState(url) &#123;
    switch (url) &#123;
      case &quot;/&quot;:
      case &quot;/index.html&quot;:
      case &quot;/home&quot;:
        $routerView.innerHTML = &quot;网站首页&quot;;
        break;
      case &quot;/about&quot;:
        $routerView.innerHTML = &quot;关于我们&quot;;
        break;
      case &quot;/news&quot;:
        $routerView.innerHTML = &quot;新闻中心&quot;;
        break;
      default:
        // 对于没有匹配的路由，显示404页面
        $routerView.innerHTML = &quot;404页面&quot;;
    &#125;
  &#125;
&lt;/script&gt;
</code></pre>
<ul>
<li>注意上面的<code>onPopState(url)</code>方法的地址是动态传递进来的。</li>
</ul>
<blockquote>
<p>原因如下：</p>
</blockquote>
<ul>
<li><code>AJAX</code>局部刷新，导致浏览器的<code>URL</code>不会发生任何变化而完成了请求，从而破坏了用户浏览体验。</li>
<li>同时本次浏览的页面内容在用户下次使用URL访问时将无法重新呈现（前提还需要后端配合），使用路由可以很好地解决这个问题。</li>
<li>所以，前端路由本质是为了让用户有一个更好的体验</li>
</ul>
<h3 id="四、Vue-中如何实现前端路由"><a href="#四、Vue-中如何实现前端路由" class="headerlink" title="四、Vue 中如何实现前端路由"></a>四、Vue 中如何实现前端路由</h3><blockquote>
<p>在利用 Vue 框架开发项目时，如果我们的页面路由相对较复杂，我们可以使用 Vue 官方推荐的<code>Vue Route</code>r路由库来实现。如果只需要实现简单的页面路由，我们可以<strong>手动</strong>通过以下两种方式：</p>
<ul>
<li><code>hash</code> 模式的前端路由：是通过<code>hashchange</code>事件与<code>&lt;component&gt;</code>动态组件来实现的</li>
<li><code>history</code> 模式的前端路由：是通过<code>History API</code>和<code>popState</code>事件，然后结合<code>&lt;component&gt;</code>动态组件来实现的。</li>
</ul>
<p>以上两种实现路由的方式就是 Vue Router 背后的实现原理，只是 Vue Router 相对考虑的更全面。</p>
<ul>
<li>所以我们先来学习下，如果在 Vue 中通过以上两种方式手动实现一个简单的路由。然后再学习Vue Router</li>
</ul>
</blockquote>
<h4 id="通过-hashchange-事件来实现"><a href="#通过-hashchange-事件来实现" class="headerlink" title="通过 hashchange 事件来实现"></a>通过 hashchange 事件来实现</h4><blockquote>
<p>创建为一个简单的 SPA 单页面应用，根据不同的hash地址，来显示不同组件的内容。</p>
<ul>
<li>访问的<code>hash</code>值为<code>#/</code>或<code>#/home</code>时，当前页面显示 Home 组件内容</li>
<li>访问的<code>hash</code>值为<code>#/about</code>时，当前页面显示 About 组件内容</li>
<li>访问的<code>hash</code>值为<code>#/news</code>时，当前页面显示 News 组件内容</li>
<li>当访问不存在的页面时，会显示<code>NotFound</code>组件内容，即：404 页面</li>
</ul>
</blockquote>
<ol>
<li>实现原理</li>
</ol>
<ul>
<li>当浏览器中的<code>hash</code>值发生改变时，会触发浏览器的<code>hashchange</code>事件。</li>
<li>我们可以通过监听<code>hashchange</code>事件，在事件内部获限当前路由 <code>hash</code>值，然后根据不同的<code>hash</code>值，在当前页面渲染不同的组件。</li>
</ul>
<ol start="2">
<li>实现步骤<blockquote>
<p>定义如下html结构，<code>currentView</code>变量保存了当前需要显示的组件</p>
</blockquote>
</li>
</ol>
<pre><code>&lt;template&gt;
  &lt;!-- 路由导航 --&gt;
  &lt;ul class=&quot;router-link&quot;&gt;
    &lt;li&gt;&lt;a href=&quot;#/&quot;&gt;网站首页&lt;/a&gt;&lt;/li&gt;
    &lt;li&gt;&lt;a href=&quot;#/about&quot;&gt;关于我们&lt;/a&gt;&lt;/li&gt;
    &lt;li&gt;&lt;a href=&quot;#/news&quot;&gt;新闻中心&lt;/a&gt;&lt;/li&gt;
  &lt;/ul&gt;
  &lt;!-- 路由内容出口 --&gt;
  &lt;component :is=&quot;currentView&quot; class=&quot;router-view&quot; /&gt;
&lt;/template&gt;
&lt;style scoped&gt;
  .router-link &#123;
    display: flex;
    margin: 10px auto;
    text-align: center;
    list-style: none;
  &#125;

  .router-link li &#123;
    margin: 0 10px;
  &#125;

  .router-link li a &#123;
    color: #000;
    font-size: 20px;
    text-decoration: none;
  &#125;

  .router-view &#123;
    margin: 20px;
    font-size: 30px;
    min-height: 300px;
  &#125;
&lt;/style&gt;
</code></pre>
<ul>
<li>在当前项目的<code>src</code>目录下，新建<code>views</code>目录，在此目录下创建应用需要用到的所有视图组件</li>
</ul>
<pre><code>views / Home.vue; // Home 组件
views / About.vue; //  About 组件
views / News.vue; // News 组件
views / NotFound.vue; // NotFound 组件
</code></pre>
<ul>
<li>定义路由对象<code>routes</code>，这个对象的属性和值分别为<code>hash</code>值和<code>hash</code>值需要显示的组件。</li>
</ul>
<pre><code>// 定义一些路由 (url地址与 组件的对应关系)
const routes = &#123;
  &quot;/&quot;: Home,
  &quot;/about&quot;: About,
  &quot;/news&quot;: News,
&#125;;
</code></pre>
<ul>
<li>定义<code>currentPath</code>变量，用来保存当前地址的<code>hash</code>值</li>
</ul>
<pre><code>// 获取当前地址的hash值
const currentPath = ref(window.location.hash);
监听浏览器的hashchange事件，当hash值改变时，修改currentPath的值
// 监听浏览器的hashchange事件，当hash值改变时，修改currentPath的值
window.addEventListener(&quot;hashchange&quot;, () =&gt; &#123;
  currentPath.value = window.location.hash;
&#125;);
</code></pre>
<ul>
<li>创建一个计算属性<code>currentView</code>，根据hash值，返回最终要显示的组件。</li>
</ul>
<pre><code>// 计算属性，根据hash值，返回最终需要显示的组件
const currentView = computed(() =&gt; &#123;
  // currentPath.value.slice(1) || &#39;/&#39; 表示访问根目录时，显示Home组件内容
  // 当访问routes中不存在的地址时，显示NotFound组件（404页面）
  // slice(1) 去掉hash值前面的#号
  return routes[currentPath.value.slice(1) || &quot;/&quot;] || NotFound;
&#125;);
</code></pre>
<ol start="3">
<li>完整版代码</li>
</ol>
<pre><code>&lt;script setup&gt;
  import &#123; ref, computed &#125; from &quot;vue&quot;;
  // 获取视图组件
  import Home from &quot;./views/Home.vue&quot;;
  import About from &quot;./views/About.vue&quot;;
  import News from &quot;./views/News.vue&quot;;
  import NotFound from &quot;./views/NotFound.vue&quot;; // 404页面

  // 定义一些路由 (url地址与 组件的对应关系)
  const routes = &#123;
    &quot;/&quot;: Home,
    &quot;/about&quot;: About,
    &quot;/news&quot;: News,
  &#125;;

  // 获取当前地址的hash值
  const currentPath = ref(window.location.hash);

  // 监听浏览器的hashchange事件，当hash值改变时，修改currentPath的值
  window.addEventListener(&quot;hashchange&quot;, () =&gt; &#123;
    currentPath.value = window.location.hash;
  &#125;);

  // 计算属性，根据hash值，返回最终需要显示的组件
  const currentView = computed(() =&gt; &#123;
    // currentPath.value.slice(1) || &#39;/&#39; 表示访问根目录时，显示Home组件内容
    // 当访问routes中不存在的地址时，显示NotFound组件（404页面）
    // slice(1) 去掉hash值前面的#号
    return routes[currentPath.value.slice(1) || &quot;/&quot;] || NotFound;
  &#125;);
&lt;/script&gt;

&lt;template&gt;
  &lt;!-- 路由导航 --&gt;
  &lt;ul class=&quot;router-link&quot;&gt;
    &lt;li&gt;&lt;a href=&quot;#/&quot;&gt;网站首页&lt;/a&gt;&lt;/li&gt;
    &lt;li&gt;&lt;a href=&quot;#/about&quot;&gt;关于我们&lt;/a&gt;&lt;/li&gt;
    &lt;li&gt;&lt;a href=&quot;#/news&quot;&gt;新闻中心&lt;/a&gt;&lt;/li&gt;
  &lt;/ul&gt;
  &lt;!-- 路由内容出口 --&gt;
  &lt;component :is=&quot;currentView&quot; class=&quot;router-view&quot; /&gt;
&lt;/template&gt;
&lt;style scoped&gt;
  .router-link &#123;
    display: flex;
    margin: 10px auto 100px;
    text-align: center;
    list-style: none;
  &#125;

  .router-link li &#123;
    margin: 0 10px;
  &#125;

  .router-link li a &#123;
    color: #000;
    font-size: 20px;
    text-decoration: none;
  &#125;
  .router-view &#123;
    margin: 20px;
    font-size: 30px;
    min-height: 300px;
  &#125;
&lt;/style&gt;
</code></pre>
<h4 id="通过History-API与-popstate事件实现"><a href="#通过History-API与-popstate事件实现" class="headerlink" title="通过History API与 popstate事件实现"></a>通过History API与 popstate事件实现</h4><blockquote>
<p>以下为一个简单的 SPA 单页面应用，根据不同的路径，来显示不同组件的内容。</p>
<ul>
<li>地址后的路径为：<code>/home</code>或<code>/</code>时，当前页面显示 <code>Home</code> 组件内容</li>
<li>地址后的路径为：<code>/about</code>时，，当前页面显示 <code>About</code> 组件内容</li>
<li>地址后的路径为：<code>/news</code>时，，当前页面显示 <code>News</code> 组件内容</li>
<li>当访问不存在的页面时，会显示<code>NotFound</code>组件内容，即：404 页面</li>
</ul>
</blockquote>
<ol>
<li>实现原理</li>
</ol>
<ul>
<li>针对a标签，通过监听<code>&lt;a&gt;</code>标签的点击事件，在事件中获取要跳转的 url，同时调用<code>pushState</code>和<code>replaceState</code>方法来实现地址栏中 URL 的变化，最后根据 url 来显示对应的组件</li>
<li>针对调用<code>histroy</code>的<code>go</code>、<code>back()</code>、<code>forward()</code>或浏览器的前进后退按扭来改变 URL。通过监听<code>popstate</code>事件，在该事件中通过<code>location.pathname</code>来获取更新后的 url 路径，最后根据 url 来显示对应的组件</li>
</ul>
<ol start="2">
<li>实现步骤<blockquote>
<p>定义如下html结构，<code>currentView</code>变量保存了当前需要显示的组件</p>
</blockquote>
</li>
</ol>
<pre><code>&lt;template&gt;
  &lt;!-- 路由导航 --&gt;
  &lt;ul class=&quot;router-link&quot; @click.prevent=&quot;onPushState&quot;&gt;
    &lt;li&gt;&lt;a href=&quot;/home&quot;&gt;网站首页&lt;/a&gt;&lt;/li&gt;
    &lt;li&gt;&lt;a href=&quot;/about&quot;&gt;关于我们&lt;/a&gt;&lt;/li&gt;
    &lt;li&gt;&lt;a href=&quot;/news&quot;&gt;新闻中心&lt;/a&gt;&lt;/li&gt;
    &lt;li&gt;&lt;a href=&quot;/product&quot;&gt;产品中心&lt;/a&gt;&lt;/li&gt;
  &lt;/ul&gt;
  &lt;!-- 路由内容出口 --&gt;
  &lt;component :is=&quot;currentView&quot; class=&quot;router-view&quot; /&gt;
&lt;/template&gt;
&lt;style scoped&gt;
  .router-link &#123;
    display: flex;
    margin: 10px auto;
    text-align: center;
    list-style: none;
  &#125;

  .router-link li &#123;
    margin: 0 10px;
  &#125;

  .router-link li a &#123;
    color: #000;
    font-size: 20px;
    text-decoration: none;
  &#125;

  .router-view &#123;
    margin: 20px;
    font-size: 30px;
    min-height: 300px;
  &#125;
&lt;/style&gt;
</code></pre>
<ul>
<li>在当前项目的src目录下，新建<code>views</code>目录，在此目录下创建应用需要用到的所有视图组件</li>
</ul>
<pre><code>views / Home.vue; // Home 组件
views / About.vue; //  About 组件
views / News.vue; // News 组件
views / NotFound.vue; // NotFound 组件
</code></pre>
<ul>
<li>定义路由对象routes，这个对象的属性和值分别为 url和url路径值需要显示的组件。</li>
</ul>
<pre><code>// 定义一些路由
const routes = &#123;
  &quot;/&quot;: Home,
  &quot;/home&quot;: Home,
  &quot;/about&quot;: About,
  &quot;/news&quot;: News,
&#125;;
</code></pre>
<ul>
<li>定义<code>currentPath</code>变量，用来保存当前 url 的路径址值</li>
</ul>
<pre><code>// 获取当前地址的hash值
const currentPath = ref(window.location.pathname);
监听浏览器的popstate事件，当url路径值改变时，修改currentPath的值
// 监听浏览器的hashchange事件，当hash值改变时，修改currentPath的值
window.addEventListener(&quot;hashchange&quot;, () =&gt; &#123;
  currentPath.value = window.location.pathname;
&#125;);
</code></pre>
<ul>
<li>创建一个计算属性<code>currentView</code>，根据url路径值，返回最终要显示的组件。</li>
</ul>
<pre><code>// 计算属性，根据hash值，返回最终需要显示的组件
const currentView = computed(() =&gt; &#123;
  // currentPath.value.slice(1) || &#39;/&#39; 表示访问根目录时，显示Home组件内容
  // 当访问routes中不存在的地址时，显示NotFound组件（404页面）
  // slice(1) 去掉hash值前面的#号
  return routes[currentPath.value.slice(1) || &quot;/&quot;] || NotFound;
&#125;);
</code></pre>
<ul>
<li>处理 a 标签的点击事件，获取 a 标签上的href属性值，然后通过<code>history.pushState()</code>方法来更新 url 路径。最后修改<code>pathname</code>的值，当<code>pathname</code>值改时，计算属性<code>currentView</code>会重新计算，得到新的需要显示的组件</li>
</ul>
<pre><code>// a标签点击事件的处理函数
function onPushState(e) &#123;
  //获取href属性的值
  const url = e.target.getAttribute(&quot;href&quot;);
  // 添加一条新的历史条目（修改地址栏中URL）
  history.pushState(&#123;&#125;, &quot;&quot;, url);
  // 给pathname重新赋值，会触发currentView计算属性重新计算，返回新的组件
  pathname.value = url;
&#125;
</code></pre>
<ol start="3">
<li>完整版代码</li>
</ol>
<pre><code>&lt;script setup&gt;
  import &#123; computed, ref &#125; from &quot;@vue/reactivity&quot;;
  import About from &quot;./views/About.vue&quot;;
  import Home from &quot;./views/Home.vue&quot;;
  import News from &quot;./views/News.vue&quot;;
  import NotFound from &quot;./views/NotFound.vue&quot;;

  // 定义一些路由 url与显示的组件映射关系
  const routes = &#123;
    &quot;/&quot;: Home,
    &quot;/home&quot;: Home,
    &quot;/about&quot;: About,
    &quot;/news&quot;: News,
  &#125;;

  // 获取当前地址后面的路径值
  const pathname = ref(window.location.pathname);

  // a标签点击事件的处理函数
  function onPushState(e) &#123;
    const target = e.target;
    const tagName = target.tagName.toLowerCase();
    if (tagName !== &quot;a&quot;) return;
    //获取href属性的值
    const url = e.target.getAttribute(&quot;href&quot;);
    // 添加一条新的历史条目（修改地址栏中URL）
    history.pushState(&#123;&#125;, &quot;&quot;, url);
    // 给pathname重新赋值，会触发currentView计算属性重新计算，返回新的组件
    pathname.value = url;
  &#125;

  // 计算属性，根据路径返回最终要显示的组件
  const currentView = computed(() =&gt; &#123;
    return routes[pathname.value || &quot;/&quot;] || NotFound;
  &#125;);

  // 监听window的popstate事件
  window.addEventListener(&quot;popstate&quot;, () =&gt; &#123;
    // 获取url后面路径
    pathname.value = window.location.pathname;
  &#125;);
&lt;/script&gt;

&lt;template&gt;
  &lt;!--路由--&gt;
  &lt;ul class=&quot;router-link&quot; @click.prevent=&quot;onPushState&quot;&gt;
    &lt;li&gt;&lt;a href=&quot;/home&quot;&gt;网站首页&lt;/a&gt;&lt;/li&gt;
    &lt;li&gt;&lt;a href=&quot;/about&quot;&gt;关于我们&lt;/a&gt;&lt;/li&gt;
    &lt;li&gt;&lt;a href=&quot;/news&quot;&gt;新闻中心&lt;/a&gt;&lt;/li&gt;
    &lt;li&gt;&lt;a href=&quot;/product&quot;&gt;产品中心&lt;/a&gt;&lt;/li&gt;
  &lt;/ul&gt;
  &lt;!--路由内容显示出口--&gt;
  &lt;component :is=&quot;currentView&quot; class=&quot;router-view&quot; /&gt;
&lt;/template&gt;

&lt;style scoped&gt;
  .router-link &#123;
    display: flex;
    margin: 10px auto;
    text-align: center;
    list-style: none;
  &#125;

  .router-link li &#123;
    margin: 0 10px;
  &#125;

  .router-link li a &#123;
    color: #000;
    font-size: 20px;
    text-decoration: none;
  &#125;

  .router-view &#123;
    margin: 20px;
    font-size: 30px;
    min-height: 300px;
  &#125;
&lt;/style&gt;
</code></pre>
<h3 id="五、Vue-Router-的基本用法"><a href="#五、Vue-Router-的基本用法" class="headerlink" title="五、Vue Router 的基本用法"></a>五、Vue Router 的基本用法</h3><blockquote>
<p><code>Vue Router</code>是<code>Vue.js</code>的官方路由。它与 <code>Vue.js</code> 核心深度集成，让用 <code>Vue.js</code> 构建SPA 单页应用变得轻而易举。在 Vue3 中需要安装<code>vue-router4</code> 版本。</p>
<ul>
<li><code>Vue Router</code> 官网地址：<code>https://router.vuejs.org/zh/guide/</code></li>
</ul>
</blockquote>
<h4 id="使用-vue-router-的步骤"><a href="#使用-vue-router-的步骤" class="headerlink" title="使用 vue-router 的步骤"></a>使用 vue-router 的步骤</h4><blockquote>
<p>在 vue3 中使用<code>vue-router@4.x</code>版本步骤</p>
<ul>
<li>第一步：安装<code>vue-router@4</code></li>
<li>第二步：定义路由组件</li>
<li>第二步：创建路由实例</li>
<li>第三步：配置路由映射：路径和组件映射关系</li>
<li>第四步：在 app 应用实例中挂载创建的路由实例</li>
<li>第五步：使用路由：通过<code>&lt;router-link&gt;</code>和<code>&lt;router-view&gt;</code>组件</li>
</ul>
</blockquote>
<ol>
<li>第一步：安装<code>vue-router@4.x</code>版本<blockquote>
<p>执行以下 npm 命令，安装<code>vue-router4.x</code>版本，安装成生产依赖</p>
</blockquote>
</li>
</ol>
<pre><code>npm install vue-router@4
</code></pre>
<ol start="2">
<li>第二步：定义路由组件<blockquote>
<p>在 <code>src/views/</code>目录下新建当前应用需要用到的所有路由组件（也称视图组件）</p>
</blockquote>
</li>
</ol>
<pre><code>views / Home.vue; // Home 组件
views / About.vue; //  About 组件
views / News.vue; // News 组件
</code></pre>
<ol start="3">
<li>第三步：创建路由实例<blockquote>
<p>在<code>src/router/</code>目录下新建<code>router.js</code>文件，此文件最终对外暴露<code>router</code>路由实例</p>
</blockquote>
</li>
</ol>
<pre><code>import &#123; createRouter, createWebHashHistory &#125; from &quot;vue-router&quot;;

// createRouter方法，用来创建路由实例，参数为一个对象，用来配置路由相关信息
const router = createRouter(&#123;
  // 路由模式，createWebHashHistory()创建 hash 模式。
  history: createWebHashHistory(),
&#125;);

// 对外暴露router实例
export &#123; router &#125;;
</code></pre>
<ol start="4">
<li>第四步：配置路由映射 - 路径和组件映射关系</li>
</ol>
<ul>
<li>①、导入路由组件</li>
<li>②、定义路由：路径与组件的映射关系</li>
<li>③、在createRouter方法的参数中配置routes选项</li>
</ul>
<pre><code>import &#123; createRouter, createWebHashHistory &#125; from &quot;vue-router&quot;;

// 1、导入路由组件 -------------------
import Home from &quot;../views/Home.vue&quot;;
import About from &quot;../views/About.vue&quot;;
import News from &quot;../views/News.vue&quot;;

// 2、定义一些路由： 路径和组件映射关系 -------------------
const routes = [
  &#123;
    path: &quot;/&quot;, // 路径
    component: Home, // 路径对应渲染的组件
  &#125;,
  &#123;
    path: &quot;/about&quot;,
    component: About,
  &#125;,
  &#123;
    path: &quot;/news&quot;,
    component: News,
  &#125;,
];

// createRouter方法，用来创建路由实例，参数为一个对象，用来配置路由相关信息
const router = createRouter(&#123;
  // 路由模式，createWebHashHistory()创建 hash 模式。
  history: createWebHashHistory(),
  // 3、配置routes -------------------
  routes, // &#39;routes&#39;:routes的缩写
&#125;);

// 对外暴露router实例
export &#123; router &#125;;
</code></pre>
<ol start="5">
<li>第五步：全局注册 router 实例<blockquote>
<p>在<code>main.js</code>中利用 <code>app.use</code> 方法注册 <code>router</code> 路由实例</p>
</blockquote>
</li>
</ol>
<pre><code>import &#123; createApp &#125; from &quot;vue&quot;;
import App from &quot;./App.vue&quot;;
// 导入router实例
import &#123; router &#125; from &quot;./router/router.js&quot;;
const app = createApp(App);
// 全局注册路由
app.use(router);
app.mount(&quot;#app&quot;);
</code></pre>
<ol start="6">
<li>第六步：使用路由通过<code>&lt;router-link&gt;</code>和<code>&lt;router-view&gt;</code><blockquote>
<p>可以在<code>App.vue</code>组件中调用<code>&lt;router-link&gt;</code>和<code>&lt;router-view&gt;</code>组件使用路由</p>
</blockquote>
</li>
</ol>
<ul>
<li><code>&lt;router-link&gt;</code>组件用来创建链接，最终会生成<code>&lt;a&gt;</code>标签形式的导航</li>
<li><code>&lt;router-view&gt;</code>组件用来显示与<code>Url</code>对应的组件内容</li>
</ul>
<pre><code>&lt;!--App组件--&gt;
&lt;template&gt;
  &lt;ul class=&quot;router-link&quot;&gt;
    &lt;!--创建a标签链接  to属性最终转换为a标签的href属性值--&gt;
    &lt;li&gt;&lt;router-link to=&quot;/&quot;&gt;网站首页&lt;/router-link&gt;&lt;/li&gt;
    &lt;li&gt;&lt;router-link to=&quot;/about&quot;&gt;关于我们&lt;/router-link&gt;&lt;/li&gt;
    &lt;li&gt;&lt;router-link to=&quot;/news&quot;&gt;新闻中心&lt;/router-link&gt;&lt;/li&gt;
  &lt;/ul&gt;

  &lt;div class=&quot;router-view&quot;&gt;
    &lt;!--url对应组件内容渲染出口--&gt;
    &lt;router-view&gt;&lt;/router-view&gt;
  &lt;/div&gt;
&lt;/template&gt;

&lt;style&gt;
  .router-link &#123;
    display: flex;
    justify-content: center;
    text-align: center;
    list-style: none;
    margin-top: 30px;
  &#125;

  .router-link li &#123;
    margin: 0 10px;
  &#125;

  .router-link li a &#123;
    color: #000;
    font-size: 16px;
    text-decoration: none;
  &#125;

  .router-link li a:hover &#123;
    color: tomato;
  &#125;
  .router-view &#123;
    width: 80%;
    margin: 30px auto;
    font-size: 20px;
    min-height: 300px;
    background-color: rgb(251, 249, 249);
  &#125;
&lt;/style&gt;
</code></pre>
<ul>
<li>经过以上 6 步，最终我们完成了刚开始我们期望的效果。</li>
</ul>
<h4 id="路由模式"><a href="#路由模式" class="headerlink" title="路由模式"></a>路由模式</h4><blockquote>
<p><code>createRouter</code>方法参数对象的<code>history</code>属性用来指定路由的模式，当<code>history</code>的值为</p>
</blockquote>
<ul>
<li><code>createWebHashHistory()</code>创建 <code>hash</code> 路由模式</li>
<li><code>createWebHistory()</code>创建 <code>history</code> 路由 模式</li>
</ul>
<pre><code>const router = createRouter(&#123;
  // history属性指定路由模式
  history: createWebHashHistory(), // 创建 hash 路由 模式。
  //  history: createWebHistory(),  // 创建 history 路由 模式
&#125;);
</code></pre>
<h4 id="链接激活时-Class-类名"><a href="#链接激活时-Class-类名" class="headerlink" title="链接激活时 Class 类名"></a>链接激活时 Class 类名</h4><blockquote>
<p>默认情况下，链接被激活时会加上<code>router-link-active</code> Class 类名，比如前面提到的案例<br><img src="链接激活时class类名.png"></p>
</blockquote>
<ul>
<li>我们可以通过添中<code>router-link-active</code> Class 类名，来控制被激活链接的样式</li>
</ul>
<pre><code>/* 在上面案例的基础上，在style标签中 添加如下css样式 */
.router-link li a.router-link-active &#123;
  color: tomato;
&#125;
</code></pre>
<ul>
<li>我们还可以设置<code>&lt;router-link&gt;</code>组件的<code>active-class</code>属性值来更改链接激活时使用的 CSS 类名</li>
</ul>
<pre><code>/* 我们修改上面案例中的如下css样式 */
.router-link li a.router-link-active &#123;
  color: tomato;
&#125;
/* 修改成 */
.router-link li a.active &#123;
  color: tomato;
&#125;
</code></pre>
<h4 id="去掉路由历史记录"><a href="#去掉路由历史记录" class="headerlink" title="去掉路由历史记录"></a>去掉路由历史记录</h4><blockquote>
<p>如果想在页面切换时，不留下历史记录，也就是在浏览器最顶部左侧不会出现前进和后退按扭。我们只需要在<code>&lt;router-link&gt;</code>标签上添加<code>replace</code>属性（表示用当前路径替换之前路径）</p>
<ul>
<li>修改以上案例中<code>&lt;App&gt;</code>组件中 所有<code>&lt;router-link&gt;</code>标签内容如下：</li>
</ul>
</blockquote>
<pre><code>&lt;ul class=&quot;router-link&quot;&gt;
  &lt;!--创建a标签链接  to属性最终转换为a标签的href属性值--&gt;
  &lt;li&gt;
    &lt;router-link to=&quot;/&quot; replace active-class=&quot;active&quot;&gt;网站首页&lt;/router-link&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;router-link to=&quot;/about&quot; replace active-class=&quot;active&quot;
      &gt;关于我们&lt;/router-link
    &gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;router-link to=&quot;/news&quot; replace active-class=&quot;active&quot;&gt;新闻中心&lt;/router-link&gt;
  &lt;/li&gt;
&lt;/ul&gt;
</code></pre>
<ul>
<li>最终效果如下，注意观察，导航切换时，浏览器最顶部前进和后退按扭一直是不灰色，不可点状态</li>
</ul>
<h4 id="访问router实例和当前路由route"><a href="#访问router实例和当前路由route" class="headerlink" title="访问router实例和当前路由route"></a>访问router实例和当前路由route</h4><blockquote>
<p>通过调用<code>app.use(router)</code>注册<code>vue-router</code>插件后。</p>
</blockquote>
<p>选项式 API 中，我们可以在任意的组件中以</p>
<ul>
<li><code>this.$router</code>访问到<code>router</code>实例 (即：<code>createRouter()</code>方法返回的 <code>router</code> 实例)</li>
<li><code>this.$route</code>访问到当前路由</li>
</ul>
<p>组合式 API 中，我们可以在任意组件中，调用<code>vue router</code>提供的</p>
<ul>
<li><code>useRouter</code> 函数访问到<code>router</code> 实例</li>
<li><code>useRoute</code> 函数访问到当前路由</li>
</ul>
<p>在任意组件的模板中，通过</p>
<ul>
<li><p><code>$router</code>访问到 <code>router</code> 实例</p>
</li>
<li><p><code>$route</code>访问到当前路由</p>
</li>
<li><p><a target="_blank" rel="noopener" href="https://v3.router.vuejs.org/zh/api/#router-%E5%AE%9E%E4%BE%8B%E6%96%B9%E6%B3%95">路由实例方法查阅教程</a></p>
</li>
<li><p><a target="_blank" rel="noopener" href="https://v3.router.vuejs.org/zh/api/#%E8%B7%AF%E7%94%B1%E5%AF%B9%E8%B1%A1%E5%B1%9E%E6%80%A7">路由对象属性查阅教程</a></p>
</li>
<li><p>用以下代码，替换前面案例中的<code>About</code>组件内容</p>
</li>
</ul>
<pre><code>&lt;script&gt;
  export default &#123;
    data() &#123;
      // this.$router.currentRoute.value.path 当有url后面的路径值
      console.log(&quot;选项式API：路由实例&quot;, this.$router.currentRoute.value.path);
      console.log(&quot;选项式API：当前路由信息&quot;, this.$route.path);
      return &#123;&#125;;
    &#125;,
  &#125;;
&lt;/script&gt;
&lt;script setup&gt;
  import &#123; useRouter, useRoute &#125; from &quot;vue-router&quot;;
  console.log(&quot;组合式API：路由实例&quot;, useRouter().currentRoute.value.path);
  console.log(&quot;组合式API：当前路由信息&quot;, useRoute().path);
&lt;/script&gt;

&lt;template&gt;
  &lt;div&gt;关于我们&lt;/div&gt;
  &lt;div&gt;路由实例：&#123;&#123; $router.currentRoute.value.path &#125;&#125;&lt;/div&gt;
  &lt;div&gt;当前路由的路径：&#123;&#123; $route.path &#125;&#125;&lt;/div&gt;
&lt;/template&gt;
</code></pre>
<h4 id="嵌套路由"><a href="#嵌套路由" class="headerlink" title="嵌套路由"></a>嵌套路由</h4><blockquote>
<p>以下图中展示的效果就是一个嵌套路由效果</p>
</blockquote>
<ul>
<li>在点击<code>News</code>导航时，会显示对应组件的内容，在该组件中还存在二级导航，点击对应二级导航时，会加载不同的组件来显示不同内容。</li>
<li>我们把<code>/home</code>、<code>/about</code>、<code>/news</code>看作是一级路由，则<code>/news/tab1</code>、<code>/news/tab2</code>、<code>/news/tab3</code>可以看成是二级路由。</li>
<li>并且这些路由显示的内容是嵌套在<code>/news</code>路由所在组件中，所以我们在定义路由时，需要把这些二级路由作为<code>/news</code>路由的子路由</li>
</ul>
<img src="嵌套路由.gif">

<blockquote>
<p>以下代码为<code>/news</code>一级路由定义了三个子路由 ,记得先用<code>import</code>导入Tab1、Tab2、Tab3（用以下代码替换前面案例中的对应代码）</p>
</blockquote>
<pre><code>&#123;
    path: &quot;/news&quot;,
    component: News,
     // 所有子路由的书写方式和父路由一样，父路由对应子路由按以下方式写在children数组中
    children: [
        &#123;
            // 这里不需要加 / ，加/ 表示的是绝对路径  http://www.xx.com/tab1
            // 不加表示相对父路由而言  http://www.xx.com/news/tab1
            path: &quot;tab1&quot;,
            component: Tab1,
        &#125;,
        &#123;
            path: &quot;tab2&quot;,
            component: Tab2,
        &#125;,
        &#123;
            path: &quot;tab3&quot;,
            component: Tab3,
        &#125;

    ]
&#125;
</code></pre>
<ul>
<li>子路由是在父路由组件中显示的，所以我们需要在父路由组件<code>News</code>中来定义子路由链接及路由组件内容渲染出口</li>
<li>用以下代码替换掉前面案例中的<code>News.vue</code>组件内容。</li>
</ul>
<pre><code>&lt;!--News.vue 组件--&gt;
&lt;template&gt;
  &lt;div class=&quot;menu&quot;&gt;
    &lt;router-link to=&quot;/news/tab1&quot;&gt;最新动态&lt;/router-link&gt; |
    &lt;router-link to=&quot;/news/tab2&quot;&gt;热门推荐&lt;/router-link&gt; |
    &lt;router-link to=&quot;/news/tab3&quot;&gt;历史动态&lt;/router-link&gt;
  &lt;/div&gt;

  &lt;div class=&quot;main&quot;&gt;
    &lt;router-view /&gt;
  &lt;/div&gt;
&lt;/template&gt;

&lt;style scoped&gt;
  .menu a &#123;
    font-size: 16px;
  &#125;

  .router-link-active &#123;
    color: #fff;
    background-color: skyblue;
    padding: 5px;
    border-radius: 10px;
  &#125;
&lt;/style&gt;
</code></pre>
<ul>
<li>按以上两步操作后，就可以实现如上图所示案例效果。</li>
<li>关于更深层级的路由嵌套和上面一样，一层一层嵌套下去就好</li>
</ul>
<h4 id="链接精确激活时-Class-类名"><a href="#链接精确激活时-Class-类名" class="headerlink" title="链接精确激活时 Class 类名"></a>链接精确激活时 Class 类名</h4><blockquote>
<p>默认情况下，链接精确激活时会加上<code>router-link-exact-active</code> Class 类名。</p>
</blockquote>
<blockquote>
<p>链接精确激活与链接激活的区别</p>
</blockquote>
<ul>
<li>精确激活：当地址栏链接为<code>/news/tab1</code>时，则只有链接<code>/news/tab1</code>对应的 <code>a</code> 标签会被添加<code>router-link-exact-active</code> Class 类，此时<code>/news/tab1</code>链接为精确激活状态</li>
<li>激活：当地址栏链接为<code>/news/tab1</code>时，链接<code>/news</code>和<code>/news/tab1</code>对应的 a 标签会被添加<code>router-link-active Class</code> 类名，此时<code>/news/tab1</code>和<code>/news</code>链接为激活状态<ul>
<li>激活状态的链接中包含精确激活状态的链接</li>
</ul>
</li>
<li>如果精确激活的链接样式包含了激活链接的样式，则我们只需要针不同部分的样式，给精确激活的链接添加<code>router-link-exact-active</code>类名来实现。</li>
</ul>
<blockquote>
<p><code>exact-active-class</code> 属性</p>
</blockquote>
<ul>
<li>我们可以通过<code>&lt;router-link&gt;</code>标签的<code>exact-active-class</code>属性来自定义精确激活链接时添加的 Class 类名</li>
</ul>
<pre><code>&lt;router-link to=&quot;/news/tab1&quot; exact-active-class=&quot;exact-active&quot;
  &gt;最新动态&lt;/router-link
&gt;
</code></pre>
<h4 id="命名路由"><a href="#命名路由" class="headerlink" title="命名路由"></a>命名路由</h4><blockquote>
<p>在定义路由时，我们可以为路由添加<code>name</code>属性来指定路由的名字</p>
</blockquote>
<pre><code>const routes = [
    &#123;

        name: &#39;home&#39;, // 路由名字，名字自定义，不一定是home
        path: &quot;/&quot;, // 路径
        component: Home, // 路径对应渲染的组件
    &#125;,
    &#123;
        name: &#39;about&#39;,
        path: &quot;/about&quot;,
        component: About,

    &#125;,
    &#123;
        name: &#39;news&#39;,
        path: &quot;/news&quot;,
        component: News,
        children: [
            &#123;
                name:&#39;tab1&#39; // 路由名字
                path: &quot;tab1&quot;,
                component: Tab1,
            &#125;,
            &#123;
                path: &quot;tab2&quot;,
                component: Tab2,
            &#125;,
            &#123;
                path: &quot;tab3&quot;,
                component: Tab3,
            &#125;

        ]
    &#125;
]
</code></pre>
<ul>
<li>有了<code>name</code>属性后，我们可以向<code>&lt;rotuer-link&gt;</code>组件的 <code>to</code> 属性传递一个对象，来实现路由的跳转。</li>
</ul>
<pre><code>&lt;!--以下方式，会根据name属性来找到指定的路由中的path值，实现路由跳转--&gt;
&lt;router-link :to=&quot;&#123; name: &#39;home&#39; &#125;&quot; active-class=&quot;active&quot;&gt;Home&lt;/router-link&gt; |
&lt;router-link :to=&quot;&#123; name: &#39;about&#39; &#125;&quot; active-class=&quot;active&quot;&gt;About&lt;/router-link&gt; |
&lt;router-link :to=&quot;&#123; name: &#39;news&#39; &#125;&quot; active-class=&quot;active&quot;&gt;News&lt;/router-link&gt;

&lt;!--以上代码，与以下代码实现的效果一模一样--&gt;
&lt;router-link to=&quot;/&quot; active-class=&quot;active&quot;&gt;Home&lt;/router-link&gt; |
&lt;router-link to=&quot;/about&quot; active-class=&quot;active&quot;&gt;About&lt;/router-link&gt; |
&lt;router-link to=&quot;/news&quot; active-class=&quot;active&quot;&gt;News&lt;/router-link&gt;
</code></pre>
<ul>
<li>当<code>&lt;router-link&gt;</code>to 的属性值为一个<strong>对象</strong>时，<code>name</code> 属性与 <code>path</code> 属性只需要写一个即可</li>
</ul>
<pre><code>&lt;!--以下写法是错的--&gt;
&lt;router-link :to=&quot;&#123;name:&#39;home&#39;,path:&#39;/&#39;&#125;&quot; active-class=&quot;active&quot;
  &gt;Home&lt;/router-link
&gt;

&lt;!--以下两种写法是对的--&gt;
&lt;router-link :to=&quot;&#123;name:&#39;home&#39;&#125;&quot; active-class=&quot;active&quot;&gt;Home&lt;/router-link&gt; |
&lt;router-link :to=&quot;&#123;path:&#39;/&#39;&#125;&quot; active-class=&quot;active&quot;&gt;Home&lt;/router-link&gt; |
</code></pre>
<ul>
<li>当我们的路由名很长很复杂时，在<code>&lt;router-link&gt;</code>标签中可以通过<code>name</code>属性来简化，而不需要书写<code>path</code>属性</li>
</ul>
<h4 id="路由重定向"><a href="#路由重定向" class="headerlink" title="路由重定向"></a>路由重定向</h4><blockquote>
<p>当我们访问某个路径时，我们希望他能重定向到其它的路径，比如访问<code>/news</code>时，希望重定向到到<code>/news/tab1</code></p>
<p>我们就可以在路由的配置中添加<code>redirect</code>属性来实现路由的重定向。</p>
</blockquote>
<ul>
<li>重定向的目标可以是一个<strong>字符串路径</strong></li>
</ul>
<pre><code>&#123;
        name: &#39;news&#39;,
        path: &quot;/news&quot;,
        component: News,
        redirect: &quot;/news/tab1&quot;,  // 重定向到 /news/tab1
        children: [
            &#123;
                name: &#39;tab1&#39;,
                path: &quot;tab1&quot;,
                component: Tab1,
            &#125;,
           // ....此处省略部分代码
        ]
    &#125;
</code></pre>
<ul>
<li>重定向的目标可以是一个<strong>命名的路由</strong> （采用路由对象写法）</li>
</ul>
<pre><code>&#123;
        name: &#39;news&#39;,
        path: &quot;/news&quot;,
        component: News,
        redirect: &#123; name: &#39;tab1&#39; &#125;,  // 重定向到路由命名name所在的路径
        children: [
            &#123;
                name: &#39;tab1&#39;,
                path: &quot;tab1&quot;,
                component: Tab1,
            &#125;,
           // ....此处省略部分代码
        ]
    &#125;
</code></pre>
<ul>
<li>重定向的目标也可以是一个<strong>方法</strong>，该方法的返回值可以是前面提到的”字符串路径” 或 “路由对象”中的一种</li>
</ul>
<pre><code>&#123;
        name: &#39;news&#39;,
        path: &quot;/news&quot;,
        component: News,
       redirect: (to) =&gt; &#123;
 // to为目标路由对象，此处为/news路由对象
//  &#123;fullPath: &#39;/news&#39;, hash: &#39;&#39;, query: &#123;…&#125;, name: &#39;news&#39;, path: &#39;/news&#39;, …&#125;
            console.log(to)
            return &#123; path: &#39;/news/tab1&#39; &#125;
        &#125;
        children: [
            &#123;
                name: &#39;tab1&#39;,
                path: &quot;tab1&quot;,
                component: Tab1,
            &#125;,
           // ....此处省略部分代码
        ]
    &#125;
</code></pre>
<ul>
<li>以上三种方式，最终都能实现，当我们访问<code>/news</code>路由时，会重定向到<code>/new/tab1</code>路由</li>
</ul>
<blockquote>
<p>注意事项</p>
</blockquote>
<ul>
<li>如果重定向的路由<strong>没有子路由</strong>，则该路由中的<code>component</code>可以省略不写，因为它从来没有被直接访问过</li>
</ul>
<pre><code>const routes = [
    &#123;
        path:&quot;/&quot;
        redirect:&quot;/home&quot;
        // 此处可以没有component
    &#125;,
    &#123;
        name: &#39;home&#39;, // 名字自定义，不一定是home
        path: &quot;/home&quot;, // 路径
        component: Home,
    &#125;
]
</code></pre>
<h3 id="六、vue-Router-路由传参"><a href="#六、vue-Router-路由传参" class="headerlink" title="六、vue Router 路由传参"></a>六、vue Router 路由传参</h3><blockquote>
<p>在路由进行跳转时，我们可以通过传参的形式为当前路由携带相关数据。</p>
<ul>
<li>路由传参有以下两种形式：</li>
</ul>
</blockquote>
<ul>
<li>query 参数</li>
<li>params 参数</li>
</ul>
<h4 id="路由的-query-参数"><a href="#路由的-query-参数" class="headerlink" title="路由的 query 参数"></a>路由的 query 参数</h4><blockquote>
<p><code>query</code> 参数最终会以<code>key = value</code>键值对的形式出现在地址 <code>？</code>后面</p>
</blockquote>
<ul>
<li>我们来看下面这个路由</li>
</ul>
<pre><code>const routes = [
  &#123;
    name: &quot;user&quot;,
    path: &quot;/user&quot;,
    component: User,
  &#125;,
  // ....
];
</code></pre>
<ol>
<li>传递<code>query</code>参数<blockquote>
<p>我们在定义路由导航时，就可以通过以下两种方式来传递<code>query</code>参数</p>
<ul>
<li>query 参数的两种写法</li>
</ul>
</blockquote>
</li>
</ol>
<ul>
<li>直接在地址后面以<code>key=value</code>形式携带传递的数据</li>
</ul>
<pre><code>&lt;!--id=001 为传递的参数数据--&gt;
&lt;router-link to=&quot;/user?id=001&quot;&gt;用户中心&lt;/router-link&gt;
</code></pre>
<ul>
<li>将<code>to</code>属性的值定义为一个路由对象，通过<code>query</code>字段来传递参数</li>
</ul>
<pre><code>&lt;router-link
  :to=&quot;&#123;
                  path: &#39;/user&#39;,
                  query: &#123;
                      id: &#39;001&#39;,
                         title:&#39;abc&#39;
                  &#125;
                  &#125;&quot;
  &gt;用户中心&lt;/router-link
&gt;

&lt;!-- 也可以采用如下写法 --&gt;
&lt;router-link
  :to=&quot;&#123;
                  name: &#39;user&#39;,
                  query: &#123;
                      id: &#39;001&#39;
                  &#125;
                  &#125;&quot;
  &gt;用户中心&lt;/router-link
&gt;
</code></pre>
<ol start="2">
<li>接受 query 参数</li>
</ol>
<ul>
<li>在<code>User.vue</code>组件中，接受传递的<code>query</code>参数，代码如下：</li>
</ul>
<pre><code>&lt;script setup&gt;
  import &#123; useRoute &#125; from &quot;vue-router&quot;;
  // 当前路由对象
  const route = useRoute();
  // 读取query参数
  console.log(route.query.id); // 001
&lt;/script&gt;
&lt;template&gt;
  &lt;div&gt;用户中心&lt;/div&gt;
  &lt;!--$route.query.id 读取传递的id，值为 001--&gt;
  &lt;div&gt;query参数：&#123;&#123; $route.query.id &#125;&#125;&lt;/div&gt;
  &lt;div&gt;query参数：&#123;&#123; route.query.id &#125;&#125;&lt;/div&gt;
&lt;/template&gt;
</code></pre>
<ol start="3">
<li>实战应用：根据 query 参数渲染数据</li>
</ol>
<ul>
<li>当我们点击不同的新闻标题时，需要把当前新闻的<code>id</code>作为参数传递给到<code>Detail</code>组件</li>
<li><code>Detail</code>组件接受传递过来的<code>id</code>值，向后端发请求获取当前<code>Id</code>对应的新闻详细内容，然后渲染在页面中</li>
</ul>
<blockquote>
<p>实现步骤</p>
</blockquote>
<ul>
<li>在前面项目的基础上，在<code>views/news</code>目录下新建<code>Detail</code>组件</li>
<li>在<code>routes</code>配置中，<code>/news/detail</code>路由定义为<code>/news</code>的子路由，因为<code>/news/detail</code>路由对应的组件最终被渲染后显示在<code>News</code>组件中</li>
</ul>
<pre><code>const routes = [
  // ...省略部分代码
    &#123;
        name: &#39;news&#39;,
        path: &quot;/news&quot;,
        component: News,
        redirect: &#123; name: &#39;tab1&#39; &#125;,  // 重定向到路由命名name所在的路径
        children: [
            // 因为该组件内容显示在  News组件中，所以定义为他的子路由
            &#123;
                name: &quot;detail&quot;,
                path: &#39;detail&#39;,
                component: Detail

            &#125;,
            &#123;
                name: &#39;tab1&#39;,
                path: &quot;tab1&quot;,
                component: Tab1,
            &#125;
            // ....省略部分代码

        ]
    &#125;
]
</code></pre>
<ul>
<li>修改组件 Tab1 的内容如下</li>
</ul>
<pre><code>&lt;script setup&gt;
  import &#123; reactive &#125; from &quot;vue&quot;;
  const list = reactive([
    &#123;
      id: &quot;001&quot;,
      title: &quot;新闻标题1111&quot;,
    &#125;,
    &#123;
      id: &quot;002&quot;,
      title: &quot;新闻标题2222&quot;,
    &#125;,
    &#123;
      id: &quot;003&quot;,
      title: &quot;新闻标题3333&quot;,
    &#125;,
  ]);
&lt;/script&gt;

&lt;template&gt;
  &lt;div&gt;最新动态内容&lt;/div&gt;
  &lt;ul&gt;
    &lt;li v-for=&quot;&#123; id, title &#125; in list&quot;&gt;
      &lt;!--  方式一
            &lt;RouterLink :to=&quot;`/news/detail?id=$&#123;id&#125;`&quot;&gt;&#123;&#123; title &#125;&#125;&lt;/RouterLink&gt; 
            --&gt;
      &lt;!--以下把path去掉,改用name=&quot;detail&quot; 也可以--&gt;
      &lt;RouterLink
        :to=&quot;&#123;
                path: &#39;/news/detail&#39;,
                query: &#123;
                    id: `$&#123;id&#125;`
                &#125;
            &#125;&quot;
        &gt;&#123;&#123; title &#125;&#125;&lt;/RouterLink
      &gt;
    &lt;/li&gt;
  &lt;/ul&gt;
&lt;/template&gt;

&lt;style scoped&gt;
  ul li &#123;
    line-height: 35px;
    border-bottom: 1px dashed #ddd;
  &#125;

  ul li a &#123;
    font-size: 16px;
    color: #666;
  &#125;
&lt;/style&gt;
</code></pre>
<ul>
<li>在Detail组件中接受传递的id参数，并根据 id 查找满足条件的新闻，将新闻标题和内容显示在页面中</li>
</ul>
<pre><code>&lt;script setup&gt;
  import &#123; ref &#125; from &quot;vue&quot;;
  import axios from &quot;axios&quot;;
  import &#123; useRoute &#125; from &quot;vue-router&quot;;
  // 获取当前路由
  const route = useRoute();
  // 接受传递的参数id
  const id = route.query.id;
  // 保存请求回来的新闻详情
  const info = ref(&#123;&#125;);
  // 根据id来发请求，获取当前新闻的详细内容
  axios
    .get(
      `https://www.fastmock.site/mock/6ec78e345df340241e1f5043f0167833/icode/detail/$&#123;id&#125;`
    )
    .then((res) =&gt; &#123;
      info.value = res.data.data;
    &#125;)
    .catch((err) =&gt; &#123;
      console.log(err);
    &#125;);
&lt;/script&gt;

&lt;template&gt;
  &lt;h3&gt;&#123;&#123; info.title &#125;&#125;&lt;/h3&gt;
  &lt;div class=&quot;main&quot;&gt;&#123;&#123; info.content &#125;&#125;&lt;/div&gt;
&lt;/template&gt;
</code></pre>
<h4 id="路由的-params-参数"><a href="#路由的-params-参数" class="headerlink" title="路由的 params 参数"></a>路由的 params 参数</h4><ol>
<li>以<code>params</code>形式传参，需要在配置路由时，以<code>:key</code>形式先占位。<blockquote>
<ul>
<li>如下：</li>
</ul>
</blockquote>
</li>
</ol>
<pre><code>const routes=[
    // ....
            &#123;
                name:&#39;detail&#39;,
                 // 能匹配detail/12  detail/ab    不能匹配detail/12/b
                path:&#39;detail/:id&#39;,
                component:Detail
            &#125;,
            &#123;
               path:&#39;add/:id/:typeid
                // path:&#39;add/:id/a/:typeid&#39;
                component:Add&#39;
            &#125;
            // ......
        ]
</code></pre>
<ol start="2">
<li>在<code>&lt;router-link&gt;</code>组件中，<code>to</code>属性的值可以写成一个路由对象，<code>params</code>属性表示传递的参数。<blockquote>
<ul>
<li>注意：以 <code>params</code> 形式传参时，只能通过<code>name</code>属性来指定要跳转的链接，<strong>不能</strong>用<code>path</code>属性。</li>
</ul>
</blockquote>
</li>
</ol>
<pre><code>&lt;RouterLink
  :to=&quot;&#123;
                name: &#39;detail&#39;,
                params: &#123;
                    id: &#39;001&#39;
                &#125;
            &#125;&quot;
  &gt;&#123;&#123; title &#125;&#125;&lt;/RouterLink
&gt;

&lt;!--以下为错误写法,params只能与name属性配合使用 --&gt;
&lt;RouterLink
  :to=&quot;&#123;
                path: &#39;/news/detail/&#39;,
                params: &#123;
                    id: &#39;001&#39;
                &#125;
                  &#125;&quot;
  &gt;&#123;&#123; title &#125;&#125;&lt;/RouterLink
&gt;
</code></pre>
<ol start="3">
<li>在组件中可以通过<code>params.id</code>形式来访问到传递的<code>params</code>参数 <code>id</code> 等。</li>
</ol>
<pre><code>&lt;script setup&gt;
  import &#123; useRouter, useRoute &#125; from &quot;vue-router&quot;;
  console.log(&quot;参数id:&quot;, useRoute().params.id);
&lt;/script&gt;

&lt;template&gt;
  &lt;div&gt;params参数：&#123;&#123; $route.params.id &#125;&#125;&lt;/div&gt;
&lt;/template&gt;
</code></pre>
<ol start="4">
<li>实战应用：根据 params 参数渲染数据<blockquote>
<p>针对前面的query参数案例，我们只需做以下相关修改，就可以实现与之相同的效果</p>
</blockquote>
</li>
</ol>
<ul>
<li>修改路由配置，在路由中添加<code>:id</code>占位符</li>
</ul>
<pre><code>const routes = [
  // .....
  &#123;
    name: &quot;news&quot;,
    path: &quot;/news&quot;,
    component: News,
    redirect: &#123; name: &quot;tab1&quot; &#125;, // 重定向到路由命名name所在的路径
    children: [
      &#123;
        name: &quot;detail&quot;,
        path: &quot;detail/:id&quot;,
        component: Detail,
      &#125;,
      // ....
    ],
  &#125;,
];
</code></pre>
<ul>
<li>修改<code>Tab1.vue</code>中<code>&lt;route-link&gt;</code>组件内容如下：(把 query 改成了 params)</li>
</ul>
<pre><code>&lt;RouterLink
  :to=&quot;&#123;
                name: &#39;detail&#39;,
                params: &#123;
                    id: `$&#123;id&#125;`
                &#125;
            &#125;&quot;
  &gt;&#123;&#123; title &#125;&#125;&lt;/RouterLink
&gt;
</code></pre>
<ul>
<li>将<code>Detail.vue</code>组件中的<code>route.query.id</code>修改成<code>route.params.id</code>即可</li>
</ul>
<pre><code>// 接受传递的参数id
const id = route.params.id;
</code></pre>
<h4 id="路由的-props-配置"><a href="#路由的-props-配置" class="headerlink" title="路由的 props 配置"></a>路由的 props 配置</h4><blockquote>
<p>路由的<code>props</code>配置可以让路由组件以<code>props</code>的形式来接受传递的 <code>params</code> 或 <code>query</code> 参数，写法更简洁。</p>
</blockquote>
<ul>
<li>在没有设置<code>props</code>属性前，在路由组件中只能以如下方式接受<code>params</code>参数</li>
</ul>
<pre><code>&lt;script setup&gt;
  import &#123; useRouter, useRoute &#125; from &quot;vue-router&quot;;
  console.log(&quot;参数id:&quot;, useRoute().params.id);
&lt;/script&gt;

&lt;template&gt;
  &lt;div&gt;参数：&#123;&#123; $route.params.id &#125;&#125;&lt;/div&gt;
&lt;/template&gt;
</code></pre>
<ul>
<li>有了 props 配置后，可以以 <code>props</code> 形式来接受传递的参数，如下写法更简洁</li>
</ul>
<pre><code>&lt;script setup&gt;
  // 这里的属性名，必需要与路由组件的参数名相同
  const props = defineProps([&quot;id&quot;]);
  console.log(&quot;id参数&quot;, props.id);
&lt;/script&gt;

&lt;template&gt;
  &lt;div&gt;参数：&#123;&#123; props.id &#125;&#125;&lt;/div&gt;
&lt;/template&gt;
</code></pre>
<ol>
<li>props 布尔模式<blockquote>
<p>当 <code>props</code> 的值为布尔值 <code>true</code> 时，相当于<code>route.params</code>将被设置为组件的<code>props</code></p>
</blockquote>
</li>
</ol>
<ul>
<li>即：把所有 <code>params</code> 参数作为 <code>props</code> 传递给路由组件。</li>
</ul>
<pre><code>// 定义一些路由
const routes = [
  // ...
  &#123;
    name: &quot;detail&quot;,
    path: &quot;detail/:id&quot;,
    component: Detail,
    // route.params将设置为组件的props
    // 相当于在组件中 &lt;Detail v-bind:=route.params /&gt;
    props: true,
  &#125;,
];
</code></pre>
<ul>
<li>我们可以在<code>Deatil</code>组件中以 <code>props</code> 的形式来接受传递的<code>params</code>参数</li>
</ul>
<pre><code>&lt;script setup&gt;
  import &#123; ref &#125; from &quot;vue&quot;;
  import axios from &quot;axios&quot;;

  // 接受params形式传递的参数 ----------------------
  const props = defineProps([&quot;id&quot;]);
  const id = props.id;

  const info = ref(&#123;&#125;);

  // 根据id来发请求，获取当前新闻的详细内容
  axios
    .get(
      `https://www.fastmock.site/mock/6ec78e345df340241e1f5043f0167833/icode/detail/$&#123;id&#125;`
    )
    .then((res) =&gt; &#123;
      info.value = res.data.data;
    &#125;)
    .catch((err) =&gt; &#123;
      console.log(err);
    &#125;);
&lt;/script&gt;

&lt;template&gt;
  &lt;h3&gt;&#123;&#123; info.title &#125;&#125;&lt;/h3&gt;
  &lt;div class=&quot;main&quot;&gt;&#123;&#123; info.content &#125;&#125;&lt;/div&gt;
&lt;/template&gt;
</code></pre>
<ol start="2">
<li>props 对象模式<blockquote>
<p>当props是一个对象时，这个对象会被设置为组件的 props</p>
</blockquote>
</li>
</ol>
<pre><code>// 定义一些路由
const routes = [
  // ...
  &#123;
    name: &quot;detail&quot;,
    path: &quot;detail/:id&quot;,
    component: Detail,
    // route.params将设置为组件的props
    // 相当于在组件中 &lt;Detail v-bind:=&#123;a:1,b:2&#125; /&gt;
    props: &#123; a: 1, b: 2 &#125;,
  &#125;,
];
</code></pre>
<ul>
<li>我们可以在路由组件中以<code>props</code>的形式来接受 <code>props</code> 配置传递的数据</li>
</ul>
<pre><code>&lt;script setup&gt;
  const props = defineProps([&quot;a&quot;, &quot;b&quot;]);
  console.log(&quot;参数a&quot;, props.a); // 1
  console.log(&quot;参数b&quot;, props.b); // 2
&lt;/script&gt;

&lt;template&gt;
  &lt;div&gt;关于我们&lt;/div&gt;
  &lt;div&gt;参数a：&#123;&#123; props.a &#125;&#125;&lt;/div&gt;
  &lt;div&gt;参数b：&#123;&#123; props.b &#125;&#125;&lt;/div&gt;
&lt;/template&gt;
</code></pre>
<ol start="3">
<li>props 函数模式<blockquote>
<p>当 props 的值是一个函数时，允许返回值是一个 <code>props</code> 对象，函数的<strong>第一个参数</strong>为当前<code>route</code>路由对象。</p>
<ul>
<li>我们可以利用 props 的函数模式，实现以下功能：</li>
</ul>
</blockquote>
</li>
</ol>
<ul>
<li>将传递的<code>query</code>参数作为 <code>props</code> 传递给路由组件</li>
<li>将传递的<code>query</code>参数与<strong>静态值</strong>一起作为<code>props</code>传递给路由组件</li>
<li>将传递的<code>params</code>参数与静态值一起作为<code>props</code>传递给路由组件</li>
</ul>
<blockquote>
<p>将传递的query参数与静态值一起作为 props 传递给路由组件</p>
</blockquote>
<ul>
<li>定义路由导航</li>
</ul>
<pre><code>&lt;router-link to=&quot;/about?id=001&quot;&gt;关于我们&lt;/router-link&gt;
</code></pre>
<ul>
<li>定义路由</li>
</ul>
<pre><code>const routes = [
  // .....
  &#123;
    name: &quot;about&quot;,
    path: &quot;/about&quot;,
    component: About,
    // 写法一 将query参数作为props传递
    props: (route) =&gt; route.query,
  &#125;,
];
</code></pre>
<ul>
<li>路由组件中通过 props 接受传递的 query 参数</li>
</ul>
<pre><code>const props = defineProps([&#39;id&#39;]);
</code></pre>
<blockquote>
<p>将传递的<code>query</code>参数与静态值一起作为 <code>props</code> 传递给路由组件</p>
</blockquote>
<ul>
<li>定义路由导航</li>
</ul>
<pre><code>&lt;router-link to=&quot;/about?id=001&amp;title=123&quot;&gt;关于我们&lt;/router-link&gt;
&lt;!-- 或 --&gt;
&lt;router-link
  :to=&quot;&#123;
                  name: &#39;about&#39;,
                  query: &#123;
                      id: &#39;001&#39;,
                      title: &#39;123&#39;
                  &#125;
                  &#125;&quot;
  &gt;关于我们&lt;/router-link
&gt;
</code></pre>
<ul>
<li>定义路由</li>
</ul>
<pre><code>const routes = [
  // ....
  &#123;
    name: &quot;about&quot;,
    path: &quot;/about&quot;,
    component: About,
    alias: &quot;/myabout&quot;,
    // 将query参数与静态值组合，一起作为props传递
    props: (route) =&gt; (&#123;
      id: route.query.id,
      title: route.query.title,
      msg: &quot;其它数据&quot;,
    &#125;),
  &#125;,
];
</code></pre>
<ul>
<li>路由组件中通过 <code>props</code> 接受传递的 <code>query</code> 参数</li>
</ul>
<pre><code>const props = defineProps([&quot;id&quot;, &quot;title&quot;, &quot;msg&quot;]);
</code></pre>
<blockquote>
<p>将传递的params参数与静态值一起作为 props 传递给路由组件</p>
</blockquote>
<ul>
<li>定义路由导航</li>
</ul>
<pre><code>&lt;router-link
  :to=&quot;&#123;
                  name: &#39;about&#39;,
                  params: &#123;
                      id: &#39;001&#39;,
                      title: &#39;1233&#39;
                  &#125;
                  &#125;&quot;
  &gt;关于我们&lt;/router-link
&gt;
</code></pre>
<ul>
<li>定义路由</li>
</ul>
<pre><code>const routes = [
  // ....
  &#123;
    name: &quot;about&quot;,
    path: &quot;/about/:id/:title&quot;,
    component: About,
    alias: &quot;/myabout&quot;,
    // 写法三：将params参数与静态值组合，一起作为props传递
    props: (route) =&gt; (&#123;
      id: route.params.id,
      title: route.params.title,
      msg: &quot;其它数据&quot;,
    &#125;),
  &#125;,
];
</code></pre>
<ul>
<li>路由组件中通过 props 接受传递的 query 参数</li>
</ul>
<pre><code>const props = defineProps([&quot;id&quot;, &quot;title&quot;, &quot;msg&quot;]);
</code></pre>
<h4 id="响应路由参数的变化"><a href="#响应路由参数的变化" class="headerlink" title="响应路由参数的变化"></a>响应路由参数的变化</h4><blockquote>
<p>我们来看下面这个带参的路由</p>
</blockquote>
<pre><code>const routes = [
  &#123;
    name: &quot;news&quot;, // 路由名
    path: &quot;/news/:id&quot;, // 路径
    component: News, // 路径需要渲染的组件
  &#125;,
];
</code></pre>
<ul>
<li>当用户从<code>/news/1001</code>导航到<code>/news/1002</code>或<code>/news/1003</code>时，相同的组件实例将被<strong>重复使用</strong>。</li>
<li>因为 3 个路由都渲染同个News组件，比起销毁再创建，复用则显得更加高效。不过，这也意味着组件的生命周期钩子<strong>不会</strong>被调用，所以当路由的参数发生变化时，在<code>&lt;script setup&gt;</code>中并不能获取到变化后的参数</li>
</ul>
<pre><code>&lt;script setup&gt;
  import &#123; useRoute &#125; from &quot;vue-router&quot;;
  const route = useRoute();
  const id = route.params.id;
  const url = &quot;http://wwww.xxx.com/....&quot;; // 请求数据源
  // 只能在刚进到/news/1001时才能拿到id=1001。
  // 后面从从/news/1001导航到/news/1002或/news/1003时,拿不到变化后的id

  axios.get(`$&#123;url&#125;$&#123;id&#125;`).then((res) =&gt; &#123;
    // 发请求拿数据
  &#125;);
&lt;/script&gt;
</code></pre>
<blockquote>
<p>要对同一个组件中参数的变化做出响应的话，你可以简单地<code>watch</code> route 对象上的任意属性</p>
</blockquote>
<pre><code>&lt;script setup&gt;
  import &#123; useRoute &#125; from &quot;vue-router&quot;;
  const route = useRoute();
  const url = &quot;http://wwww.xxx.com/....&quot;; // 请求数据源

  // 侦听 route.params的变化
  watch(
    () =&gt; route.params,
    (newValue, oldValue, onCleanup) =&gt; &#123;
      // 对路由的变化做出响应
      axios.get(`$&#123;url&#125;$&#123;newValue.id&#125;`).then((res) =&gt; &#123;
        // 发请求拿数据
      &#125;);
    &#125;
  );
&lt;/script&gt;
</code></pre>
<ol>
<li>实战应用<blockquote>
<p>我们来实现如下效果，当用户从<code>/news/1001</code>导航到<code>/news/1002</code>或<code>/news/1003</code>时都能拿到变化后的参数，然后根据参数的值来发请求获取新闻数据列表</p>
</blockquote>
</li>
</ol>
<ul>
<li><code>src/router/router.js</code> 创建路由实例</li>
</ul>
<pre><code>// 1、从vue-router中解构两个方法
import &#123;
  createRouter,
  createWebHashHistory,
  createWebHistory,
&#125; from &quot;vue-router&quot;;
import News from &quot;../views/News.vue&quot;;

// 定义一些路由：路径与组件的映射关系....
const routes = [
  &#123;
    name: &quot;home&quot;,
    path: &quot;/&quot;,
    redirect: &quot;/news/1001&quot;,
  &#125;,
  &#123;
    name: &quot;news&quot;,
    path: &quot;/news/:id&quot;,
    component: News,
  &#125;,
];

// 创建router 路由实例
const router = createRouter(&#123;
  // 路由模式
  //  history:createWebHashHistory(),  // hash模式的路由
  history: createWebHistory(),
  // 配置一些路由
  // routes:routes
  routes,
&#125;);

// 对外暴露
export &#123; router &#125;;
</code></pre>
<ul>
<li><code>App.vue</code>中，创建路由导航</li>
</ul>
<pre><code>&lt;template&gt;
  &lt;ul class=&quot;router-link&quot;&gt;
    &lt;li&gt;
      &lt;router-link to=&quot;/news/1001&quot;&gt;最新动态&lt;/router-link&gt;
    &lt;/li&gt;
    &lt;li&gt;
      &lt;router-link to=&quot;/news/1002&quot;&gt;执门推荐&lt;/router-link&gt;
    &lt;/li&gt;
    &lt;li&gt;
      &lt;router-link to=&quot;/news/1003&quot;&gt;历史动态&lt;/router-link&gt;
    &lt;/li&gt;
  &lt;/ul&gt;

  &lt;!-- url对应组件内容输出口 --&gt;
  &lt;div class=&quot;router-view&quot;&gt;
    &lt;router-view&gt;&lt;/router-view&gt;
  &lt;/div&gt;
&lt;/template&gt;
&lt;style&gt;
  .router-link &#123;
    display: flex;
    justify-content: center;
    text-align: center;
    list-style: none;
    margin-top: 30px;
  &#125;

  .router-link li &#123;
    margin: 0 10px;
  &#125;

  .router-link li a &#123;
    color: #000;
    font-size: 16px;
    text-decoration: none;
  &#125;

  .router-link li a:hover &#123;
    color: tomato;
  &#125;

  .router-link li a.router-link-active &#123;
    color: tomato;
  &#125;

  .router-view &#123;
    width: 80%;
    margin: 30px auto;
    font-size: 20px;
    min-height: 300px;
    background-color: rgb(251, 249, 249);
  &#125;
&lt;/style&gt;
</code></pre>
<ul>
<li><code>NewList</code>，根据id获取并渲染不同的数据</li>
</ul>
<pre><code>&lt;script setup&gt;
  import &#123; ref, watch &#125; from &quot;vue&quot;;
  import axios from &quot;axios&quot;;
  import &#123; useRoute &#125; from &quot;vue-router&quot;;
  const route = useRoute();
  const list = ref([]);
  const url =
    &quot;https://www.fastmock.site/mock/6ec78e345df340241e1f5043f0167833/icode/new/list/&quot;;

  // 用来取消请求的对象
  let controller = null;

  // 侦听器侦听 route.params 的变化
  watch(
    () =&gt; route.params,
    (newValue, oldValue, onCleanup) =&gt; &#123;
      controller = new AbortController();
      // 发请求，拿数据
      axios
        .get(`$&#123;url&#125;$&#123;route.params.id&#125;`, &#123;
          // 配置取消请求
          signal: controller.signal,
        &#125;)
        .then((res) =&gt; &#123;
          list.value = res.data.data;
        &#125;)
        .catch((err) =&gt; &#123;
          console.log(err.message);
        &#125;);

      // 取消请求
      function cancle() &#123;
        controller.abort();
      &#125;

      // 取消之前的请求
      onCleanup(cancle);
    &#125;,
    &#123;
      immediate: true,
    &#125;
  );
&lt;/script&gt;

&lt;template&gt;
  &lt;ul&gt;
    &lt;li v-for=&quot;&#123; id, title &#125; in list&quot;&gt;
      &lt;router-link to=&quot;&quot;&gt; &#123;&#123; title &#125;&#125;&lt;/router-link&gt;
    &lt;/li&gt;
  &lt;/ul&gt;
&lt;/template&gt;

&lt;style scoped&gt;
  ul &#123;
    padding: 20px;
  &#125;

  ul li &#123;
    line-height: 35px;
    border-bottom: 1px dashed #ddd;
    text-indent: 2em;
  &#125;

  ul li a &#123;
    color: #333;
    text-decoration: none;
  &#125;
&lt;/style&gt;
</code></pre>
<h3 id="七、路由别名"><a href="#七、路由别名" class="headerlink" title="七、路由别名"></a>七、路由别名</h3><blockquote>
<p>在路由配置时，我们可以通过<code>alias</code>属性为路由取别名。</p>
</blockquote>
<ul>
<li>当路由<code>/about</code>的别名为<code>/myabout</code>时，我们通过地址<code>/myabout</code>访问的是<code>/about</code>路由的内容，但路由地址显示的是<code>/myabout</code></li>
<li>当路由<code>/news/tab2</code>的别名为<code>/newsInfo</code>时，我们通过地址<code>/newsInfo</code>访问的是<code>/news/tab2</code>路由的内容，但地址显示的是<code>/newsInfo</code></li>
<li>通过别名，你可以自由地将 UI 结构映射到一个任意的 URL，而不受配置的嵌套结构的限制</li>
</ul>
<ol>
<li>别名是一个绝对或相对路径<blockquote>
<p>别名可以是一个以<code>/</code>开头的<strong>绝对路径</strong>，也可以是一个没有<code>/</code>开头的<strong>相对路径</strong></p>
</blockquote>
</li>
</ol>
<pre><code>const routes = [
      // 省略部分代码......
    &#123;
        name: &#39;about&#39;,
        path: &quot;/about&quot;,
        component: About,
        alias: &quot;/myabout&quot;  // 别名 绝对路径，访问地址 /myabout
    &#125;,
    &#123;
        name: &#39;news&#39;,
        path: &quot;/news&quot;,
        component: News,
        redirect: &#123; name: &#39;tab1&#39; &#125;,
        children: [

                name: &#39;tab1&#39;,
                path: &quot;tab1&quot;,
                component: Tab1,
            &#125;,
            &#123;
                path: &quot;tab2&quot;,
                component: Tab2,
                alias: &#39;/newsInfo&#39;,  // 别名 ，绝对路径 访问地址 /newsInfo
            &#125;,
            &#123;
                path: &quot;tab3&quot;,
                component: Tab3,
                alias:&quot;commonInfo&quot;  // 别名，相对路径 访问地址 /news/commonInfo
            &#125;

        ]
</code></pre>
<ul>
<li>接下来，我们可以把页面中访问路由的地址修改为访问别名，如下</li>
</ul>
<pre><code>&lt;ul class=&quot;router-link&quot;&gt;
  &lt;li&gt;&lt;router-link to=&quot;/&quot;&gt;网站首页&lt;/router-link&gt;&lt;/li&gt;
  &lt;li&gt;&lt;router-link to=&quot;/myabout&quot;&gt;关于我们&lt;/router-link&gt;&lt;/li&gt;
  &lt;li&gt;&lt;router-link to=&quot;/newsInfo&quot;&gt;热门推荐&lt;/router-link&gt;&lt;/li&gt;
  &lt;li&gt;&lt;router-link to=&quot;/news/commonInfo&quot;&gt;历史动态&lt;/router-link&gt;&lt;/li&gt;
&lt;/ul&gt;
</code></pre>
<ol start="2">
<li>别名是一个数组<blockquote>
<p>别名可以由多个以相对或绝对路径组成的数组</p>
</blockquote>
</li>
</ol>
<ul>
<li>路由<code>/news/tab3</code>的别名是一个数组，如下：</li>
</ul>
<pre><code>const routes = [
  // ......
  &#123;
    name: &quot;news&quot;,
    path: &quot;/news&quot;,
    component: News,
    redirect: &#123; name: &quot;tab1&quot; &#125;,
    children: [
      // ......
      &#123;
        path: &quot;tab3&quot;,
        component: Tab3,
        // /Info  /news/commonInfo   最终访问的都是 /news/tab3路由的内容
        alias: [&quot;/Info&quot;, &quot;commonInfo&quot;],
      &#125;,
    ],
  &#125;,
];
</code></pre>
<ul>
<li>我们通过<code>/Info</code>、<code>/news/commonInfo</code> 最终访问的都是<code>/news/tab3</code>路由的内容</li>
</ul>
<ol start="3">
<li>别名携带参数<blockquote>
<p>如果路由有参数，一定要在任何绝对别名中包含它们</p>
</blockquote>
</li>
</ol>
<pre><code>const routes = [
  // .....
  &#123;
    name: &quot;about&quot;,
    path: &quot;/about/:id&quot;,
    component: About,
    // 可以通过 /about/1001  、 /myabout/1001/   、 /1001  访问到about关于我们页面
    alias: [
      &quot;/myabout/:id&quot;, // 绝对路径必须带上参数
      &quot;/:id&quot;,
    ],
  &#125;,
];
</code></pre>
<ul>
<li>以下导航访问的都是同一个页面关于我们</li>
</ul>
<pre><code>&lt;li&gt;&lt;router-link to=&quot;/about/1001&quot;&gt;关于我们&lt;/router-link&gt;&lt;/li&gt;
&lt;li&gt;&lt;router-link to=&quot;/myabout/1001&quot;&gt;关于我们&lt;/router-link&gt;&lt;/li&gt;
&lt;li&gt;&lt;router-link to=&quot;/1001&quot;&gt;关于我们&lt;/router-link&gt;&lt;/li&gt;
</code></pre>
<h3 id="八、命名视图"><a href="#八、命名视图" class="headerlink" title="八、命名视图"></a>八、命名视图</h3><ol>
<li>命名视图<blockquote>
<p>有时候想同时（同级）展示多个视图，而不是嵌套展示。例如创建一个布局，有 header（头部）、main（主内容）、footer（底部）三个视图，这个时候命名视图就派上用场了</p>
</blockquote>
</li>
</ol>
<ul>
<li>你可以在界面中拥有多个单独命名视图，而不是只有一个单独的出口，如下：</li>
</ul>
<pre><code>&lt;router-view name=&quot;Header&quot;&gt;&lt;/router-view&gt;
&lt;router-view&gt;&lt;/router-view&gt;
&lt;!-- 没有name属性，默认为name=&#39;default&#39;  上面写法等同于下面写法--&gt;
&lt;!-- &lt;router-view name=&quot;default&quot;&gt;&lt;/router-view&gt; --&gt;

&lt;router-view name=&quot;Footer&quot;&gt;&lt;/router-view&gt;
</code></pre>
<ul>
<li><p>如果<code>router-view</code> 没有设置 <code>name</code> 名字，那么默认为<code>name=&quot;default&quot;</code></p>
</li>
<li><p>一个视图使用一个组件渲染，因此对于同个路由，有多个视图就需要多个组件渲染。确保正确使用 <code>components</code> 配置 (带上 s)：</p>
</li>
</ul>
<pre><code>const router = createRouter(&#123;
  history: createWebHashHistory(),
  routes: [
    &#123;
      path: &quot;/&quot;,
      components: &#123;
        default: Main,
        // Header: Header 的缩写
        Header,
        // 它们与 `&lt;router-view&gt;` 上的 `name` 属性匹配
        Footer,
      &#125;,
    &#125;,
  ],
&#125;);
</code></pre>
<ol start="2">
<li>命名视图应用</li>
</ol>
<ul>
<li>App.vue</li>
</ul>
<pre><code>&lt;script setup&gt;
  import Header from &quot;./views/Header.vue&quot;;
&lt;/script&gt;
&lt;template&gt;
  &lt;header&gt;&lt;/header&gt;
  &lt;!--多个命名视图, 注意这里的名字采用的是小写--&gt;
  &lt;router-view name=&quot;header&quot;&gt;&lt;/router-view&gt;
  &lt;router-view&gt;&lt;/router-view&gt;
  &lt;router-view name=&quot;footer&quot;&gt;&lt;/router-view&gt;
&lt;/template&gt;
Header.vue
&lt;template&gt;
  &lt;div class=&quot;header&quot;&gt;
    &lt;ul class=&quot;router-link&quot;&gt;
      &lt;li&gt;&lt;router-link to=&quot;/&quot;&gt;网站首页&lt;/router-link&gt;&lt;/li&gt;
      &lt;li&gt;&lt;router-link to=&quot;/about&quot;&gt;关于我们&lt;/router-link&gt;&lt;/li&gt;
      &lt;li&gt;&lt;router-link to=&quot;/news&quot;&gt;新闻中心&lt;/router-link&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/div&gt;
&lt;/template&gt;
&lt;style scoped&gt;
  .header &#123;
    height: 50px;
  &#125;

  .router-link &#123;
    display: flex;
    justify-content: center;
    text-align: center;
    list-style: none;
  &#125;

  .router-link li &#123;
    line-height: 50px;
    margin: 0 10px;
  &#125;

  .router-link li a &#123;
    color: #000;
    font-size: 16px;
    text-decoration: none;
  &#125;

  .router-link li a:hover &#123;
    color: tomato;
  &#125;

  .router-link li a.router-link-active &#123;
    color: tomato;
  &#125;
&lt;/style&gt;
</code></pre>
<ul>
<li><code>router/router.js</code></li>
</ul>
<pre><code>import &#123; createRouter, createWebHistory &#125; from &quot;vue-router&quot;;

import HomeHeader from &quot;../views/HomeHeader.vue&quot;;
import HomeMain from &quot;../views/HomeMain.vue&quot;;
import HomeFooter from &quot;../views/HomeFooter.vue&quot;;

import AboutHeader from &quot;../views/AboutHeader.vue&quot;;
import AboutMain from &quot;../views/AboutMain.vue&quot;;

import NewsMain from &quot;../views/NewsMain.vue&quot;;

const routes = [
  &#123;
    path: &quot;/&quot;,
    // 当前路由对应多个组件
    components: &#123;
      header: HomeHeader, // 对应默认视图
      default: HomeMain, // 对应命名视图 name=&#39;main&#39;
      footer: HomeFooter, // 对应命名视图 name=&#39;footer&#39;
    &#125;,
  &#125;,
  &#123;
    path: &quot;/about&quot;,
    components: &#123;
      header: AboutHeader, // 对应默认视图
      default: AboutMain,
    &#125;,
  &#125;,
  &#123;
    path: &quot;/news&quot;,
    components: NewsMain,
    // 如果只渲染默认视图， components:&#123; default:NewHeader &#125;可以简写成
    // component:NewHeader
  &#125;,
];

const router = createRouter(&#123;
  history: createWebHistory(),
  routes,
&#125;);

export &#123; router &#125;;
</code></pre>
<ol start="3">
<li>嵌套命名视图<blockquote>
<p>如果上面案例中 <code>/news</code> 路由还存在子路由，子路由对应的页面也可以由多个命名视图来展示</p>
</blockquote>
</li>
</ol>
<ul>
<li><code>NewsMain.vue</code></li>
</ul>
<pre><code>&lt;template&gt;
  &lt;div class=&quot;router-link&quot;&gt;
    &lt;router-link to=&quot;/news/tab1&quot;&gt;最新动态&lt;/router-link&gt;
  &lt;/div&gt;
  &lt;div class=&quot;router-view&quot;&gt;
    &lt;router-view name=&quot;Left&quot; class=&quot;left&quot;&gt;&lt;/router-view&gt;
    &lt;router-view name=&quot;Right&quot; class=&quot;right&quot;&gt;&lt;/router-view&gt;
  &lt;/div&gt;
&lt;/template&gt;

&lt;style scoped&gt;
  .router-view &#123;
    display: flex;
    justify-content: space-between;
  &#125;
&lt;/style&gt;
</code></pre>
<ul>
<li><code>router/router.js</code></li>
</ul>
<pre><code>const routes = [
  &#123;
    path: &quot;/news&quot;,
    component: NewsMain,
    children: [
      &#123;
        path: &quot;tab1&quot;,
        components: &#123;
          Left: TabLeft1,
          Right: TabRight1,
        &#125;,
      &#125;,
    ],
  &#125;,
];
</code></pre>
<ul>
<li><code>name</code>严格区分大小写，如果<code>name</code>和组件名相同，可以简写</li>
</ul>
<pre><code>components: &#123;
//如果name=组件名
  Left,
  Right: TabRight1,
&#125;,
</code></pre>
<h3 id="九、动态路由的匹配语法"><a href="#九、动态路由的匹配语法" class="headerlink" title="九、动态路由的匹配语法"></a>九、动态路由的匹配语法</h3><ol>
<li>参数中自定义正则<blockquote>
<p>当我们使用<code>user/:userId</code>这样的动态路由时，<code>:userId</code>为路径参数，他能匹配任意的字符，所以<code>user/12</code>、<code>user/ab</code> 都能匹配成功。</p>
</blockquote>
</li>
</ol>
<blockquote>
<p>如果我们希望<code>:userId</code>只能匹配数字，也就是<code>user/12</code> 能匹配成功，但<code>user/ab</code>会匹配失败。我们可在路径参数 后面的括号中加入正则表达式来限定</p>
</blockquote>
<pre><code>const routes = [
  &#123;
    // 只能匹配 /user/1  /user/123  等 但不能匹配 /user/ab
    path: &quot;/user/:userId(\\d+)&quot;,
  &#125;,
];
</code></pre>
<ul>
<li>注意：字符中的<code>\</code>反斜杆有特殊用途，所以要加上<code>\\</code>来转义，确保能正确匹配<code>\d</code></li>
</ul>
<blockquote>
<p>如果我们希望路由<code>/user/：userId</code>后面的<code>:userId</code>只能匹配数字或字母类字符，我们可以在路径参数后面的括号加入正则表达式来限定</p>
</blockquote>
<pre><code>const routes = [
  &#123;
    // 只能匹配 /user/1  /user/123  等 但不能匹配 /user/ab
    path: &quot;/user/:userId([a-zA-Z0-9]+)&quot;,
  &#125;,
];
</code></pre>
<ol start="2">
<li>可重复的参数<blockquote>
<p>如果你需要匹配具有<strong>多个部分</strong>的路由，如<code>/user/:urls</code> 可以匹配 <code>/user/one</code>、<code>/user/one/two</code>、<code>/user/one/two/123</code> 等</p>
<ul>
<li>则可以在路径参数后面使用 <code>*</code>（0 个或多个）和 <code>+</code>（1 个或多个）将参数标记为可重复</li>
</ul>
</blockquote>
</li>
</ol>
<pre><code>const routes = [
  &#123;
    // 可以匹配 /user/one   /user/one/two    /user/one/two/123
    // 不能匹配 /user/
    path: &quot;/user/:userId+&quot;,
  &#125;,
  &#123;
    // 可以匹配 /product/one  /product/one/two  /product/one/two/123
    // 也能匹配 /user/
    path: &quot;/product/:productId*&quot;,
  &#125;,
  &#123;
    // 可以匹配 /news/12   /news/12/23   不能匹配 /news/a   /news/12/b
    // 只要重复的路径中包含非数字，都不能匹配成功
    path: &quot;/news/:id（\\d+）+&quot;,
  &#125;,
];
</code></pre>
<ol start="3">
<li>可选参数<blockquote>
<p>你可以在路径参数后面使用 <code>?</code> 修饰符（0 个或 1 个）将一个参数标记为可选。</p>
</blockquote>
</li>
</ol>
<pre><code>const routes = [
  &#123;
    // 可以匹配 /user   /user/ab   /user/12 等
    path: &quot;/user/:userId?&quot;,
  &#125;,
  &#123;
    // 可以匹配 /news  /news/12   不能匹配 /user/ab
    path: &quot;/news/:id(\\d+)?&quot;,
  &#125;,
];
</code></pre>
<blockquote>
<p>总结</p>
</blockquote>
<ul>
<li><code>+</code>表示<code>1</code>个或多个，同时参数可以重复</li>
<li><code>*</code>表示<code>0</code>个或多个，同时参数可以重复</li>
<li><code>?</code>表示<code>0</code>个或 1 个，参数不能重复</li>
</ul>
<ol start="4">
<li>注意事项<blockquote>
<p>我们来看下面两个路由</p>
</blockquote>
</li>
</ol>
<pre><code>const routes = [
  &#123;
    path: &quot;/:keyword&quot;,
  &#125;,
  &#123;
    path: &quot;/:id(\\d+)&quot;,
  &#125;,
];
</code></pre>
<blockquote>
<p>注：</p>
</blockquote>
<ul>
<li>当我们访问<code>/12</code>时，或<code>/</code>反斜杆后面跟着数字时，将匹配<code>/:id(\\d+)</code>，其它情况将会匹配<code>/:keyword</code>。</li>
<li>与<code>/:id(\\d+)</code>和<code>/:keyword</code>在 routes 数组中的顺序没有关系</li>
</ul>
<ol start="5">
<li>捕获 404 Not Found 路由<blockquote>
<p>我们可以在定义<code>routes</code>时，配置一个匹配所有路由的路由对象，该路由所渲染的组件为<code>NotFound</code>显示 <code>404</code> 页面内容。</p>
</blockquote>
</li>
</ol>
<ul>
<li>如果当前访问的路径没有被<code>/:pathMatch(.*)</code>之外的路由匹配，则就会被<code>/:pathMatch(.*)</code>匹配，显示<code>NotFound</code>组件</li>
</ul>
<pre><code>const routes = [
  // .......
  &#123;
    name: &quot;NotFound&quot;,
    // 匹配任意路由
    path: &quot;/:pathMatch(.*)*&quot;,
    component: NotFound,
  &#125;,
  // .......
];
</code></pre>
<ol start="6">
<li><code>Sensitive</code> 与 <code>strict</code> 路由配置<blockquote>
<p>默认情况下路由<code>/users</code>将匹配 <code>/users</code>、<code>/users/</code>、甚至 <code>/Users/</code>。我们可以在<code>createRouter(options)</code>的 <code>options</code> 中来配置<code>sensitive</code>与<code>strict</code>选项来<strong>区分大小写</strong>和<strong>禁用尾部斜线</strong>。</p>
</blockquote>
</li>
</ol>
<ul>
<li><code>sensitive</code>：设置路由是否区分大小写,true 表示区分大小写，false 表示不区分，默认值为 fasle</li>
<li><code>strict</code>：路由是否禁止尾部斜线 true 表示禁用，false 表示不禁用，默认值为 false</li>
</ul>
<pre><code>const router = createRouter(&#123;
  history: createWebHistory(),
  routes: [
    &#123;
      path: &quot;/about&quot;,
      component: About,
    &#125;,
    &#123;
      path: &quot;/news&quot;,
      component: News,
    &#125;,
  ],
  strict: true, // 禁止尾部斜线
  sensitive: true, // 区分大小写
&#125;);
</code></pre>
<ul>
<li>以上<code>/about</code>路由只能与<code>/about</code>匹配，与<code>/About</code>和<code>/about/</code>都不会匹配成功。<code>/news</code>路由只能与<code>/news</code>匹配，与<code>/News</code>和<code>/news/</code>都不会匹配成功。</li>
<li><code>sensitive</code>与<code>strict</code>选项即可以如上面一样应用在整个全局路由上，也可以应用于当前路由上，如下：</li>
</ul>
<pre><code>const router = createRouter(&#123;
  history: createWebHistory(),
  routes: [
    &#123;
      path: &quot;/about&quot;,
      component: About,
      strict: true, // 禁止尾部斜线
    &#125;,
    &#123;
      path: &quot;/news&quot;,
      component: News,
      sensitive: true, // 区分大小写
    &#125;,
  ],
&#125;);
</code></pre>
<ul>
<li>以上<code>/about</code>路由可以与<code>/about</code>和<code>/About</code>匹配成功，但与<code>/about/</code>匹配失败</li>
<li>以上<code>/news</code>路由可以与<code>/news</code>和<code>/news/</code>匹配成功，但与<code>/News</code>匹配失败</li>
</ul>
<h3 id="十、vue-Router-编程式导航"><a href="#十、vue-Router-编程式导航" class="headerlink" title="十、vue Router 编程式导航"></a>十、vue Router 编程式导航</h3><blockquote>
<p>除了使用 <code>&lt;router-link&gt;</code> 创建 a 标签来定义导航链接，我们还可以借助 <code>router</code> 的实例方法，通过编写代码来实现。</p>
</blockquote>
<ul>
<li>在组件中插入<code>&lt;router-link&gt;</code>组件来创建导航，属于<strong>声明式</strong>写法</li>
<li>通过<code>router</code>实例方法来创建导航，属于<strong>编程式</strong>导航写法。</li>
</ul>
<table>
<thead>
<tr>
<th>声明式</th>
<th>编程式</th>
</tr>
</thead>
<tbody><tr>
<td><router-link :to="..."></td>
<td>router.push(…)</td>
</tr>
</tbody></table>
<ul>
<li>以下表格中列出的 <code>router</code> 实例方法，可以用来实现页面导航<table>
<thead>
<tr>
<th>router</th>
<th>实例方法</th>
<th>功能</th>
</tr>
</thead>
<tbody><tr>
<td>push()</td>
<td>用来导航到一个新的 URL</td>
<td></td>
</tr>
<tr>
<td>replace()</td>
<td>用来导航到一个新的 URL，但会替换掉之前的 URL，无法后退到之前 URL</td>
<td></td>
</tr>
<tr>
<td>go()</td>
<td>导航到指定记录，用于前进或后退</td>
<td></td>
</tr>
<tr>
<td>back()</td>
<td>相当于后退按扭，后退到前一页</td>
<td></td>
</tr>
<tr>
<td>forward()</td>
<td>相当于前进按扭，前进到前一页</td>
<td></td>
</tr>
</tbody></table>
</li>
</ul>
<h4 id="push-方法"><a href="#push-方法" class="headerlink" title="push 方法"></a>push 方法</h4><blockquote>
<p>push 方法用来导航到一个新的 URL，他接受一个参数，该参数与<code>&lt;router-link&gt;</code>组件中 <code>to</code> 属性值的写法一模一样，可以是一个字符串路径，或者一个描述地址对象。</p>
</blockquote>
<pre><code>// 字符串路径
router.push(&quot;/news/tab1&quot;);

// 带有路径的对象
router.push(&#123; path: &quot;/news/tab1&quot; &#125;);

// 命名的路由，并加上参数，让路由建立 url
router.push(&#123; name: &quot;tab1&quot;, params: &#123; id: &quot;001&quot; &#125; &#125;);

// 带query查询参数，结果是 /news/tab1?id=001
router.push(&#123; path: &quot;/news/tab1&quot;, query: &#123; id: &quot;001&quot; &#125; &#125;);

// 带 hash，结果是 /about#team
router.push(&#123; path: &quot;/about&quot;, hash: &quot;#team&quot; &#125;);
</code></pre>
<blockquote>
<p>注意事项</p>
</blockquote>
<ul>
<li><code>params</code>参数只能与<code>name</code>属性配合，不能与<code>path</code>属性配合，以下写法 <code>params</code> 会被忽略</li>
</ul>
<pre><code>// 错误写法
router.push(&#123; path: &quot;/news/tab1&quot;, params: &#123; id: &quot;001&quot; &#125; &#125;);
</code></pre>
<h4 id="实战应用"><a href="#实战应用" class="headerlink" title="实战应用"></a>实战应用</h4><blockquote>
<p>利用编程式导航实现导航切换</p>
</blockquote>
<ul>
<li>在src目录下新建<code>views</code>目录，在此目录所需要的路由组件</li>
</ul>
<pre><code>views
   ├─ Home.vue    // 首页组件
   ├─ Login.vue   // 登录组件
   ├─ Register.vue // 注册组件
</code></pre>
<ul>
<li>各个路由组件内容如下</li>
</ul>
<pre><code>&lt;!--Home.vue--&gt;
&lt;template&gt;
  &lt;h3&gt;网站首页&lt;/h3&gt;
&lt;/template&gt;

&lt;!--Login.vue--&gt;
&lt;template&gt;
  &lt;h3&gt;用户登录&lt;/h3&gt;
&lt;/template&gt;

&lt;!--Register.vue--&gt;
&lt;template&gt;
  &lt;h3&gt;用户注册&lt;/h3&gt;
&lt;/template&gt;
</code></pre>
<ul>
<li>在<code>src</code>目录下新建<code>router</code>目录，在此目录下新建<code>index.js</code>文件，用来定义路由</li>
</ul>
<pre><code>import &#123; createRouter, createWebHistory &#125; from &quot;vue-router&quot;;
import Home from &quot;../views/Home.vue&quot;;
import Login from &quot;../views/Login.vue&quot;;
import Register from &quot;../views/Register.vue&quot;;
import User from &quot;../views/User.vue&quot;;

// 定义一些路由
const routes = [
  &#123;
    name: &quot;home&quot;,
    path: &quot;/&quot;,
    component: Home,
    strict: true,
    sensitive: true
  &#125;,
  &#123;
    name: &quot;login&quot;,
    path: &quot;/login&quot;,
    component: Login,
  &#125;,
  &#123;
    name: &quot;register&quot;,
    path: &quot;/register&quot;,
    component: Register,
  &#125;,
];

// 创建路由实例
const router = createRouter(&#123;
  history: createWebHistory(),
  routes,
&#125;);

// 对外暴露
export &#123; router &#125;;
</code></pre>
<ul>
<li>App.vue 组件</li>
</ul>
<pre><code>&lt;script setup&gt;
  import &#123; useRouter &#125; from &quot;vue-router&quot;;
  // 获取router实例
  const router = useRouter();
  // 切换URL方法
  function goTo(url) &#123;
    router.push(url); // 切换到对应URL
  &#125;
&lt;/script&gt;
&lt;template&gt;
  &lt;button @click=&quot;goTo(&#123;
    path: &#39;/login&#39;,
    query: &#123;
      id : 11
      &#125;
    &#125;)&quot;&gt;登录&lt;/button&gt; |
  &lt;button @click=&quot;goTo(&#123;
    name = &#39;register&#39;,
    params:&#123;
      id : 123
    &#125;
    &#125;)&quot;&gt;注册&lt;/button&gt;

  &lt;div class=&quot;main&quot;&gt;
    &lt;router-view&gt;&lt;/router-view&gt;
  &lt;/div&gt;
&lt;/template&gt;

&lt;style&gt;
  .main &#123;
    margin-top: 50px;
    display: flex;
    justify-content: center;
    align-items: center;
  &#125;
&lt;/style&gt;
</code></pre>
<h4 id="replace-方法"><a href="#replace-方法" class="headerlink" title="replace 方法"></a>replace 方法</h4><blockquote>
<p>与 push 方法一样用来导航到一个新的 URL，但会替换掉之前的 URL，<strong>无法后退</strong>到之前 URL</p>
<p>|声明式	编程式|<br>|–|–|<br>|<router-link :to="..." replace>|router.replace(…)|</p>
</blockquote>
<pre><code>router.replace(&#123; path: &quot;/home&quot; &#125;);
</code></pre>
<ul>
<li>如果把上面案例中的 push 方法，换成 replace 方法，发现浏览器顶部左侧的前进后退按扭一直是灰色的。</li>
</ul>
<pre><code>function goTo(url) &#123;
  router.replace(url); // 切换到对应URL
&#125;
</code></pre>
<h4 id="go、back、forward-方法"><a href="#go、back、forward-方法" class="headerlink" title="go、back、forward 方法"></a>go、back、forward 方法</h4><pre><code>router.go(1); // 向前移动一页，相当于前进按扭
router.back(); // 返回前一页 ，相当于后退按扭
router.forward(); // 与go(1) 是一样的
</code></pre>
<ul>
<li>把上面案例<code>App.vue</code>中代码更改成如下：</li>
</ul>
<pre><code>&lt;script setup&gt;
  import &#123; useRouter &#125; from &quot;vue-router&quot;;
  const router = useRouter();
  function goTo(url) &#123;
    router.push(url);
  &#125;
  function go() &#123;
    router.go(1);
  &#125;
  function back() &#123;
    router.back();
  &#125;
&lt;/script&gt;
&lt;template&gt;
  &lt;button @click=&quot;goTo(&#39;/login&#39;)&quot;&gt;登录&lt;/button&gt; |
  &lt;button @click=&quot;goTo(&#39;/register&#39;)&quot;&gt;注册&lt;/button&gt; |

  &lt;button @click=&quot;go&quot;&gt;前进&lt;/button&gt; |
  &lt;button @click=&quot;back&quot;&gt;后退&lt;/button&gt;

  &lt;div class=&quot;main&quot;&gt;
    &lt;router-view&gt;&lt;/router-view&gt;
  &lt;/div&gt;
&lt;/template&gt;

&lt;style&gt;
  .main &#123;
    margin-top: 30px;
    display: flex;
    justify-content: center;
    align-items: center;
  &#125;
&lt;/style&gt;
</code></pre>
<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><blockquote>
<p>你可能已经注意到，<code>router.push</code>、<code>router.replace</code> 和 <code>router.go</code> 是 <code>window.history.pushState</code>、<code>window.history.replaceState</code> 和 <code>window.history.go</code>的翻版，它们确实模仿了 <code>window.history</code> 的 API。</p>
</blockquote>
<ul>
<li>因此，如果你已经熟悉<code>Browser History APIs</code>，在使用 <code>Vue Router</code> 时，操作历史记录就会觉得很熟悉。</li>
<li>值得一提的是，无论在创建路由器实例时传递什么样的 <code>history</code> 配置，<code>Vue Router</code> 的导航方法(push、replace、go)都能始终正常工作</li>
</ul>
<h3 id="十一、实战应用：项目框架搭建"><a href="#十一、实战应用：项目框架搭建" class="headerlink" title="十一、实战应用：项目框架搭建"></a>十一、实战应用：项目框架搭建</h3><blockquote>
<p>本小节结合前面学习过的 Vant UI 与 Vue Router 实现一个简单的应用导航框架</p>
</blockquote>
<ol>
<li>实现步骤</li>
</ol>
<ul>
<li>路由设计</li>
<li>安装 Vant 组件库</li>
<li>实现页面路由</li>
<li>单页面开发</li>
</ul>
<ol start="2">
<li>路由设计<blockquote>
<p>首先根据当前应用的需求设计好当前应用的路由</p>
<ul>
<li>当前项目只涉及一级导航（路由），各路由关系与路由对应的组件如下表</li>
</ul>
</blockquote>
</li>
</ol>
<table>
<thead>
<tr>
<th>页面</th>
<th>一级路由</th>
<th>路由组件</th>
</tr>
</thead>
<tbody><tr>
<td>首页</td>
<td>&#x2F;	Home</td>
<td></td>
</tr>
<tr>
<td>购物车</td>
<td>&#x2F;mycart	MyCart</td>
<td></td>
</tr>
<tr>
<td>好看</td>
<td>&#x2F;nice	Nice</td>
<td></td>
</tr>
<tr>
<td>我的</td>
<td>&#x2F;my	My</td>
<td></td>
</tr>
</tbody></table>
<ul>
<li>在<code>src/router/index.js</code>中创建 <code>router</code> 实例，并对外暴露</li>
</ul>
<pre><code>import &#123; createApp &#125; from &quot;vue&quot;;
import &#123; createRouter, createWebHistory &#125; from &quot;vue-router&quot;;
import Home from &quot;../views/Home.vue&quot;;
import MyCart from &quot;../views/MyCart.vue&quot;;
import My from &quot;../views/My.vue&quot;;
import Nice from &quot;../views/Nice.vue&quot;;
const routes = [
  &#123;
    path: &quot;/&quot;,
    component: Home,
  &#125;,
  &#123;
    path: &quot;/mycart&quot;,
    component: MyCart,
  &#125;,
  &#123;
    path: &quot;/nice&quot;,
    component: Nice,
  &#125;,
  &#123;
    path: &quot;/my&quot;,
    component: My,
  &#125;,
];

const router = createRouter(&#123;
  history: createWebHistory(),
  routes,
&#125;);

export &#123; router &#125;;
</code></pre>
<ul>
<li>在<code>src/main.js</code>中注册 <code>router</code> 实例</li>
</ul>
<pre><code>// .....此处省略部分代码
import &#123; router &#125; from &quot;./router/&quot;;
// 注册路由
app.use(router);
// ......
</code></pre>
<ol start="3">
<li>安装 Vant 组件库<blockquote>
<p>在此项目中，我们会用到 Vant 组件库，所以我们需要先安装好 Vant 组件库</p>
</blockquote>
</li>
</ol>
<ul>
<li>安装 UI 组件库</li>
</ul>
<pre><code>npm i vant
</code></pre>
<ul>
<li>按需引入组件，则需要安装以下插件</li>
</ul>
<pre><code>npm i unplugin-vue-components -D
</code></pre>
<ul>
<li>在 <code>vite.config.js</code> 文件中配置好此插件</li>
</ul>
<pre><code>import vue from &quot;@vitejs/plugin-vue&quot;;
import Components from &quot;unplugin-vue-components/vite&quot;;
import &#123; VantResolver &#125; from &quot;unplugin-vue-components/resolvers&quot;;

export default &#123;
  plugins: [
    vue(),
    Components(&#123;
      resolvers: [VantResolver()],
    &#125;),
  ],
&#125;;
</code></pre>
<ol start="4">
<li>实现页面路由<blockquote>
<p>根据路由实现各页面之间的链接（跳转）关系。</p>
<ul>
<li>在此项目中，主要构建当前应用底部的 Tabbar 导航。此导航采用 Vant 组件库中的 Tabbar 组件实现。</li>
</ul>
</blockquote>
</li>
</ol>
<pre><code>&lt;script setup&gt;
  import &#123; ref &#125; from &quot;vue&quot;;
  const active = ref(0);
&lt;/script&gt;

&lt;template&gt;
  &lt;router-view&gt;&lt;/router-view&gt;

  &lt;van-tabbar active-color=&quot;#ee0a24&quot; v-model=&quot;active&quot;&gt;
    &lt;van-tabbar-item icon=&quot;home-o&quot; to=&quot;/&quot;&gt;首页&lt;/van-tabbar-item&gt;
    &lt;van-tabbar-item icon=&quot;shopping-cart-o&quot; to=&quot;/mycart&quot;
      &gt;购物车&lt;/van-tabbar-item
    &gt;
    &lt;van-tabbar-item icon=&quot;tv-o&quot; to=&quot;/nice&quot;&gt;好看&lt;/van-tabbar-item&gt;
    &lt;van-tabbar-item icon=&quot;friends-o&quot; to=&quot;/my&quot;&gt;我的&lt;/van-tabbar-item&gt;
  &lt;/van-tabbar&gt;
&lt;/template&gt;
</code></pre>
<ol start="5">
<li>单页面开发<blockquote>
<p>整个应用的页面路由（导航）实现好之后，我们就可以开发单个路由页面的功能了。</p>
<ul>
<li>在这个应用中，每个页面（除首页）的顶部都有一个返回按扭，可以返回到到前一页。这里利用 Vant UI 的<code>NavBar</code>导航栏组件来实现。</li>
</ul>
</blockquote>
</li>
</ol>
<ul>
<li><code>MyCart.vue</code>组件内容</li>
</ul>
<pre><code>&lt;script setup&gt;
  // 返回前一页
  function onClickLeft() &#123;
    history.back();
  &#125;
&lt;/script&gt;

&lt;template&gt;
  &lt;!-- 导航栏 --&gt;
  &lt;van-nav-bar
    title=&quot;购物车&quot;
    left-text=&quot;返回&quot;
    left-arrow
    @click-left=&quot;onClickLeft&quot;
  /&gt;
  &lt;!--主体内容--&gt;
  &lt;div class=&quot;main&quot;&gt;购物车.....&lt;/div&gt;
&lt;/template&gt;
&lt;style scoped&gt;
  .main &#123;
    text-align: center;
  &#125;

  /* 修改导航栏中 &lt; 返回 的颜色为黑色*/
  :global(.van-nav-bar__text) &#123;
    color: #000;
  &#125;

  :global(.van-nav-bar .van-icon) &#123;
    color: #000;
  &#125;
&lt;/style&gt;
</code></pre>
<ul>
<li>其它带有返回导航栏的<code>Nice</code>、<code>My</code>组件的内容也按上面格式书写即可，针对修改导航栏中 <code>&lt;</code> 返回 颜色的样式可以不用再重写</li>
<li>全局样式可以写在单独的CSS文件夹里，在<code>index.html</code>中引入或者<code>main.js</code>中引入，后者优先级最高</li>
</ul>
<h3 id="十二、路由元信息"><a href="#十二、路由元信息" class="headerlink" title="十二、路由元信息"></a>十二、路由元信息</h3><blockquote>
<p>有时，你可能希望将任意信息附加到路由上，比如:</p>
</blockquote>
<ul>
<li>路由组件过渡动画时会用到的过渡名</li>
<li>访问该路由是否需要身份验证等信息</li>
</ul>
<blockquote>
<p>我们可以在定义路由时，将这些信息配置在每个路由对象的<code>meta</code>属性中，如下:</p>
</blockquote>
<pre><code>//定义一些路由
const routes = [
    &#123;
      name: &quot;home&quot;,
      path: &#39;/&#39;,
      component: Home
    &#125;,
    &#123;
      name: &#39;login&quot; ,
      path: &#39;/login&#39; ,
      component: Login,
      //任何人都可以进入登录页
      meta: &#123;
        requiresAuth: false
      &#125;
    &#125;,
    &#123;
      name: &#39;register &#39;,
      path: &quot;/register,
      component: Register
    &#125;,
    &#123;
      name: &quot;user &quot;,
      path: &quot;/user&quot;,
      component: User,
      //只有经过身份验证的用户才能访问用户中心
      meta: &#123;
        requiresAuth: true
      &#125;
    &#125;
  ]
</code></pre>
<ul>
<li>在选项式API中，可以通过<code>$route.meta</code>来访问<code>meta</code>配置项中的信息。</li>
<li>在组合式API中，可以通过<code>useRoute( ).meta</code>来访问<code>meta</code>配置项中的信息。</li>
</ul>
<pre><code>&lt;script setup&gt;
    import &#123; useRoute &#125; from &#39;vue-router &#39;;
    const route=useRoute();
    //访问router中的meta信息
    console.log(route.meta.requiresAuth)
&lt;/script&gt;
</code></pre>
<h3 id="十三、导航守卫（路由守卫）"><a href="#十三、导航守卫（路由守卫）" class="headerlink" title="十三、导航守卫（路由守卫）"></a>十三、导航守卫（路由守卫）</h3><h4 id="什么是导航（路由）守卫"><a href="#什么是导航（路由）守卫" class="headerlink" title="什么是导航（路由）守卫"></a>什么是导航（路由）守卫</h4><ul>
<li>导航守卫是指从路由跳转开始到结束这一生命周期过程中的生命周期函数。</li>
<li>这些函数会在路由跳转开始到结束过程中的某个时刻执行， 这些函数也被称为 “导航（路由）守卫函数”</li>
</ul>
<img src="导航解析流程.png">

<blockquote>
<p>如果我们想在路由跳转到结束整个过程中的某个时刻做一些事情，就可以把想要做的事情写入对应的守卫函数中。</p>
<p>导航守卫函数常用来控制对路由的访问权限或路由跳转成功后要做的相关操作。比如：</p>
</blockquote>
<ul>
<li>对于没有访问权限的访问可以直接拒绝或跳转到其它页面等</li>
<li>在路由跳转时，在浏览器顶部实现页面加载的进度条效果，在加载成功后隐藏。</li>
<li>在路由跳转成功后修改网页标题的信息等</li>
</ul>
<h4 id="导航守卫分类"><a href="#导航守卫分类" class="headerlink" title="导航守卫分类"></a>导航守卫分类</h4><blockquote>
<p>vue-router 提供了以下三类导航守卫来实现对路由的守卫</p>
</blockquote>
<ul>
<li>全局导航守</li>
<li>路由独享导航守卫</li>
<li>组件级导航守卫</li>
</ul>
<h4 id="全局导航守卫"><a href="#全局导航守卫" class="headerlink" title="全局导航守卫"></a>全局导航守卫</h4><blockquote>
<p>全局导航守卫就是在路由跳转时，对整个应用内的所有路由进行拦截，然后进行一些操作。</p>
<p>全局导航守卫主要有以下三个钩子函数，所有路由跳转都会触发这三个钩子函数</p>
</blockquote>
<ul>
<li>全局前置守卫<code>beforeEach</code></li>
<li>全局解析守卫<code>beforeResolve</code></li>
<li>全局后置钩子<code>afterEach</code></li>
</ul>
<blockquote>
<ul>
<li>全局导航守卫持载在全局路由实例上，如下：</li>
</ul>
</blockquote>
<pre><code>// 创建路由实例
const router = createRouter(&#123;
  // ...
&#125;);

// 添加全局前置守卫
router.beforeEach((to, from, next) =&gt; &#123;
  // ...
&#125;);

// 全局解析守卫
router.beforeResolve((to, from, next) =&gt; &#123;
  // ...
&#125;);

// 全局后置钩子  没有next参数
router.afterEach((to, from) =&gt; &#123;
  // ...
&#125;);
</code></pre>
<ol>
<li>全局前置守卫 beforeEach<blockquote>
<p>当路由被触发时就会调用 <code>beforeEach</code> 钩子函数。比如：调用<code>router.push()</code>或<code>router.replace()</code>触发导航更新时，<code>beforeEach</code> 钩子函数就会调用</p>
</blockquote>
</li>
</ol>
<blockquote>
<p>应用场景：</p>
</blockquote>
<ul>
<li>常用于在路由跳转时对路由访问权限进行验证，验证通过放行，不通过做别做处理，比如返回首页。</li>
</ul>
<blockquote>
<p>语法</p>
</blockquote>
<pre><code>// 创建路由实例
const router = createRouter(&#123;
  /*   */
&#125;);

// 添加全局前置守卫  next为可选参数
router.beforeEach((to, from, next) =&gt; &#123;
  // ...
&#125;);
</code></pre>
<blockquote>
<p>守卫方法参数</p>
</blockquote>
<ul>
<li><code>to</code>: 跳转到的目标路由对象。 比如从<code>/a</code>跳转到<code>/b</code>，目标路由对象为<code>/b</code>对应的路由对象</li>
<li><code>from</code>：离开的路由对象。 比如从<code>/a</code>跳转到<code>/b</code>，离开的路由对象为<code>/b</code>对应的路由对象</li>
</ul>
<blockquote>
<p>守卫方法返回值</p>
</blockquote>
<ul>
<li><code>false</code>： 取消当前的导航，则会重置到<code>from</code>路由对应的地址</li>
<li>路由地址：可以是一个地址字符串，也可以是一个路由地址对象。和你调用<code>router.push()</code>方法传入的参数一样。</li>
<li><code>true</code> 或 <code>undefined</code> ： 表示当前导航有效，放行，并调用下一个导航守卫</li>
</ul>
<blockquote>
<p>可选参数 next</p>
</blockquote>
<ul>
<li>next：是一个方法，表示是否正常放行</li>
<li>在之前的 Vue Router 版本中会用到，在 vue Router4 中不考虑用，但也保留了这个功能<ul>
<li>如果当前跳转是合法的，调用<code>next()</code>导航就可以正常跳转到目标路由</li>
<li><code>next(false)</code> 中断当前的导航，会返回到跳转前的路由</li>
<li><code>next()</code>方法也可以传递一个“路由字符串”或“路由对象”，表示跳转到一个新的路由</li>
</ul>
</li>
</ul>
<pre><code>next(&quot;/home&quot;);
next(&#123; path: &quot;/home&quot; &#125;);
</code></pre>
<ul>
<li>温馨提示：<ul>
<li>如果不调用<code>next()</code>方法，切记不要在参数中出现<code>next</code>方法，否则路由<strong>没有办法跳转</strong></li>
</ul>
</li>
</ul>
<ol start="2">
<li>实战应用：登录及权限控制<blockquote>
<p>功能：</p>
</blockquote>
</li>
</ol>
<ul>
<li>如果用户没有登录，不允许进入个人中心，只能进入首页、关于我们、登录页、注册页</li>
<li>如果用户在没有登录的情况下访问用户中心页面，则会跳转到登录页</li>
<li>用户可以通过登录页输入用户名和密码进行验证，验证成功可以进入任意页面，包括个人中心。</li>
<li>如果点击了退出登录按扭，则回退出登录，返回到登录页，则不能再进入到用户中心，只能重新登录成功后才可以</li>
</ul>
<blockquote>
<p>实现原理</p>
</blockquote>
<ul>
<li>对于需要身份验证的路由，我们可以在路由配置上添加<code>meta: &#123; requiresAuth: true&#125;</code>字段，表示需要身份验证成功后方可进入</li>
<li>添加全局前置导航守卫，在导航守卫中判断要进入的目标路由对象是否需要身份验证</li>
<li>如果不需要验证，则直接放行，如果需要身份验证，则进入身份验证环节，判断用户是否登录成功</li>
</ul>
<pre><code>// 添加全局前置导航守卫
router.beforeEach((to, from, next) =&gt; &#123;
  // 需要身份验证
  if (to.meta.requiresAuth) &#123;
    // 判断用户是否登录
  &#125; else &#123;
    // 不需要身份验证，直接放行
    next();
  &#125;
&#125;);
</code></pre>
<ul>
<li>登录页——我们可以在用户登录成功时，把后端发送的token保存在<code>locaStorage</code>中</li>
</ul>
<pre><code>import &#123; useRouter &#125; from &quot;vue-router&quot;;
const router = useRouter();

// 点击登录按扭，会调用login方法进行登录验证
function login() &#123;
  // 正常是发请求验证用户名和密码是否正确

  // 判断用户名和密码是否正确
  if (username.value === &quot;admin&quot; &amp;&amp; password.value === &quot;123456&quot;) &#123;
    // 验证成功，把后端发送的token保存在localStorage，此处模拟
    localStorage.setItem(&quot;token&quot;, &quot;xxxx-token&quot;);
    // 验证成功跳转到用户中心，带上用户id
    router.push(&quot;/user/1001&quot;);
  &#125;
&#125;
</code></pre>
<ul>
<li>在<code>beforeEach</code>中判断是否有<code>token</code>，如果有表示用户登录成功，则放行；如果没有，则让用户跳转到登录页。(实际开发，需要把 token 发送给后端验证，验证通过则放行)</li>
</ul>
<pre><code>// 全局前置守卫
router.beforeEach((to, from) =&gt; &#123;
  // 判断进入当前路由是否需要验证
  if (to.meta.requiresAuth) &#123;
    // 判断用户是否登录成功
    if (localStorage.getItem(&quot;token&quot;)) &#123;
      return true;
    &#125; else &#123;
      alert(&quot;没有访问权限！！请先登录&quot;);
      return &quot;/login&quot;;
    &#125;
  &#125;
&#125;);
</code></pre>
<blockquote>
<p>实现步骤</p>
</blockquote>
<ul>
<li>在<code>src/router/index.js</code>中定义 <code>router</code> 实例</li>
</ul>
<pre><code>import &#123; createRouter, createWebHistory &#125; from &quot;vue-router&quot;;

import Home from &quot;../views/Home.vue&quot;;
import User from &quot;../views/User.vue&quot;;
import About from &quot;../views/About.vue&quot;;
import Login from &quot;../views/Login.vue&quot;;

const routes = [
  &#123;
    path: &quot;/&quot;,
    component: Home,
  &#125;,
  &#123;
    path: &quot;/about&quot;,
    component: About,
  &#125;,
  &#123;
    path: &quot;/user/:id&quot;,
    component: User,
    meta: &#123;
      requiresAuth: true, // 需要身份验证
    &#125;,
  &#125;,
  &#123;
    name: &quot;login&quot;,
    path: &quot;/login&quot;,
    component: Login,
  &#125;,
];
const router = createRouter(&#123;
  history: createWebHistory(),
  routes,
&#125;);

// 全局前置守卫
router.beforeEach((to, from) =&gt; &#123;
  // 判断进入当前路由是否需要验证
  if (to.meta.requiresAuth) &#123;
    // 判断用户是否登录成功
    if (localStorage.getItem(&quot;token&quot;)) &#123;
      return true;
    &#125; else &#123;
      alert(&quot;没有访问权限！！请先登录&quot;);
      return &quot;/login&quot;;
    &#125;
  &#125;
&#125;);

export &#123; router &#125;;
</code></pre>
<ul>
<li>在<code>/src/views</code>目录下新建首页、关于我们、注册页、个人中心页组件</li>
</ul>
<pre><code>&lt;template&gt; 首页/关于我们/注册个人账号..../个人中心 &lt;/template&gt;
</code></pre>
<ul>
<li>登录页</li>
</ul>
<pre><code>&lt;script setup&gt;
  import &#123; ref &#125; from &quot;vue&quot;;
  import &#123; useRouter &#125; from &quot;vue-router&quot;;
  const router = useRouter();
  const username = ref(&quot;&quot;); // 用户名
  const password = ref(&quot;&quot;); // 密码

  // 登录验证
  function login() &#123;
    // 正常是发请求验证用户名和密码是否正确
    // 判断用户名和密码是否正确
    if (username.value === &quot;admin&quot; &amp;&amp; password.value === &quot;123456&quot;) &#123;
      // 验证成功，把后端发送的token保存在localStorage，此处模拟
      localStorage.setItem(&quot;token&quot;, &quot;xxxx-token&quot;);
      router.push(&quot;/user&quot;); // 验证成功跳转到用户中心
    &#125;
  &#125;
&lt;/script&gt;

&lt;template&gt;
  &lt;div class=&quot;login&quot;&gt;
    &lt;form&gt;
      &lt;div&gt;
        &lt;label for=&quot;username&quot;&gt;用户名&lt;/label&gt;
        &lt;input type=&quot;text&quot; v-model=&quot;username&quot; id=&quot;username&quot; /&gt;
      &lt;/div&gt;
      &lt;div&gt;
        &lt;label for=&quot;password&quot;&gt;密码&lt;/label&gt;
        &lt;input
          type=&quot;password&quot;
          v-model=&quot;password&quot;
          id=&quot;password&quot;
          autocomplete=&quot;none&quot;
        /&gt;
      &lt;/div&gt;
      &lt;div&gt;
        &lt;button @click.prevent=&quot;login&quot;&gt;登录&lt;/button&gt;
      &lt;/div&gt;
    &lt;/form&gt;
  &lt;/div&gt;
&lt;/template&gt;

&lt;style&gt;
  .login &#123;
    width: 300px;
  &#125;

  .login div &#123;
    margin-top: 20px;
  &#125;

  .login div label &#123;
    display: block;
    margin-bottom: 5px;
    font-size: 20px;
  &#125;

  .login div input &#123;
    width: 100%;
    box-sizing: content-box;
    border: 1px solid #ddd;
    height: 30px;
    line-height: 30px;
  &#125;

  .login div button &#123;
    box-sizing: border-box;
    width: 100%;
    height: 40px;
    border: none;
    font-size: 24px;
    color: #fff;
    background-color: tomato;
  &#125;
&lt;/style&gt;
</code></pre>
<ul>
<li><code>App.vue</code>中添加导航</li>
</ul>
<pre><code>&lt;script setup&gt;
  import &#123; useRouter &#125; from &quot;vue-router&quot;;
  const router = useRouter();
  // 退出登录
  function exit() &#123;
    // 退出登录时要清除掉token
    localStorage.setItem(&quot;token&quot;, &quot;&quot;);
    // 跳转到首页
    router.push(&quot;/login&quot;);
  &#125;
&lt;/script&gt;
&lt;template&gt;
  &lt;div class=&quot;router-link&quot;&gt;
    &lt;router-link to=&quot;/&quot;&gt; 网站首页 &lt;/router-link&gt;
    &lt;router-link to=&quot;/about/&quot;&gt; 关于我们 &lt;/router-link&gt;
    &lt;router-link to=&quot;/user/1001&quot;&gt; 个人中心 &lt;/router-link&gt;
    &lt;router-link to=&quot;/login&quot;&gt; 登录 &lt;/router-link&gt;
    &lt;router-link to=&quot;/register&quot;&gt;注册&lt;/router-link&gt;
    &lt;a href=&quot;/&quot; @click.prevent=&quot;exit&quot;&gt; 退出&lt;/a&gt;
  &lt;/div&gt;
  &lt;div class=&quot;router-view&quot;&gt;
    &lt;router-view&gt;&lt;/router-view&gt;
  &lt;/div&gt;
&lt;/template&gt;
&lt;style scoped&gt;
  .router-link &#123;
    display: flex;
    margin-top: 20px;
  &#125;

  .router-link a &#123;
    margin: 10px;
    text-decoration: none;
    color: #000;
  &#125;

  .router-link a.router-link-active &#123;
    color: red;
  &#125;

  .router-view &#123;
    font-size: 30px;
  &#125;
&lt;/style&gt;
</code></pre>
<ol start="3">
<li>全局解析守卫 beforeResolve<blockquote>
<p>全局解析守卫<code>beforeResolve</code>刚好在导航被确认之前调用，即地址栏中的地址改变为目标地址之前。在<code>beforeResolve</code>钩子调用前，所有组件内守卫和异步路由组件被解析完成。</p>
</blockquote>
</li>
</ol>
<blockquote>
<p>应用场景：</p>
</blockquote>
<ul>
<li>获取数据：导航被确认后想马上做的事情，就可以在里，比如：获取数据</li>
<li>任何其他操作：如果用户无法进入页面时你希望避免执行的操作。比如：数据获取失败，则可以取消导航。</li>
</ul>
<pre><code>// 创建路由实例
const router = createRouter(&#123;
  /*   */
&#125;);

// 全局解析守卫
router.beforeResolve((to, from, next) =&gt; &#123;
  // ...
&#125;);
</code></pre>
<ol start="4">
<li>全局后置守卫 afterEach</li>
</ol>
<ul>
<li>当路由跳转成功后就会触发<code>afterEach</code>钩子函数，此时地址栏中路由地址改变为目标地址。</li>
<li>钩子函数的<code>to</code>和<code>from</code>用法与<code>beforeEach</code>一样，不过这个钩子函数没有<code>next</code>，因为路由已经跳转成功，在该钩子函数中并不能改变导航本身。</li>
</ul>
<blockquote>
<p>应用场景：</p>
</blockquote>
<ul>
<li>常用于分析导航跳转成功之后要做的事情，对于分析、更改页面标题等辅助功能以及许多其他事情都很有用</li>
</ul>
<pre><code>// 创建路由实例
const router = createRouter(&#123;
  /*   */
&#125;);
//  全局后置钩子
router.afterEach((to, from) =&gt; &#123;
  // 导航成功后，需要做的事情
&#125;);
</code></pre>
<blockquote>
<p>代码演示：</p>
</blockquote>
<ul>
<li>定义路由</li>
</ul>
<pre><code>const routes = [
  &#123;
    path: &quot;/&quot;,
    component: Home,
    meta: &#123;
      title: &quot;艾编程官网&quot;,
    &#125;,
  &#125;,
  &#123;
    path: &quot;/about&quot;,
    component: About,
    meta: &#123;
      title: &quot;关于我们&quot;,
    &#125;,
  &#125;,
  &#123;
    path: &quot;/user/:id&quot;,
    component: User,
    meta: &#123;
      requiresAuth: true,
      title: &quot;个人中心&quot;,
    &#125;,
  &#125;,
  &#123;
    name: &quot;login&quot;,
    path: &quot;/login&quot;,
    component: Login,
    meta: &#123;
      title: &quot;登录中心&quot;,
    &#125;,
  &#125;,
  &#123;
    name: &quot;register&quot;,
    path: &quot;/register&quot;,
    component: Register,
    meta: &#123;
      title: &quot;注册中心&quot;,
    &#125;,
  &#125;,
];
</code></pre>
<ul>
<li>添加全局后置导航守卫，当页面跳转成功后修改页面标题</li>
</ul>
<pre><code>//  全局后置导航守卫
router.afterEach((to, from) =&gt; &#123;
  // 导航成功后，修改页面标题
  document.title = to.meta.title;
&#125;);
</code></pre>
<ol start="5">
<li>导航加载进度条<blockquote>
<p>实现原理：</p>
</blockquote>
</li>
</ol>
<ul>
<li>首先创建 <code>LoadingBar</code> 组件，该组件有以下两个方法用来实现进度条的加载：<ul>
<li><code>startLoading</code>方法，调用该方法用于开始加载进度条</li>
<li><code>endLoading</code>方法，调用该方法用于将进度条拉满，并结束进度条</li>
</ul>
</li>
</ul>
<blockquote>
<p>同时将这两个方法通过<code>defineExpose</code>方法对外暴露为公共方法。这样在外部获取当前件实例时，就可以拿到这两个方法来实现进度条的加载。</p>
</blockquote>
<ul>
<li><code>LoadingBar.vue</code> 进度条组件</li>
</ul>
<pre><code>&lt;script setup&gt;
  import &#123; ref &#125; from &quot;vue&quot;;
  const progress = ref(0); // 当前进度
  const speed = ref(1); // 动画速度
  const timer = ref(null); // 定时器
  const bar = ref(null); // 进度条

  // 开始加载进度条
  function startLoading() &#123;
    progress.value = 0; // 每次加载时将进度改为0
    timer.value = window.requestAnimationFrame(function fn() &#123;
      if (progress.value &lt; 85) &#123;
        progress.value += speed.value;
        bar.value.style.width = progress.value + &quot;%&quot;;
        timer.value = window.requestAnimationFrame(fn);
      &#125; else &#123;
        // 清除动画
        cancelAnimationFrame(timer.value);
      &#125;
    &#125;);
  &#125;
  // 进度条拉满，结束进度条
  function endLoading() &#123;
    window.requestAnimationFrame(() =&gt; &#123;
      setTimeout(() =&gt; &#123;
        progress.value = 100;
        bar.value.style.width = &quot;100%&quot;;
        // 拉满后，过30ms去掉进度条
        setTimeout(() =&gt; &#123;
          bar.value.style.width = &quot;0%&quot;;
        &#125;, 30);
      &#125;, 1000);
    &#125;);
  &#125;

  defineExpose(&#123;
    startLoading,
    endLoading,
  &#125;);
&lt;/script&gt;
&lt;template&gt;
  &lt;div class=&quot;wraps&quot;&gt;
    &lt;div class=&quot;loading-bar&quot; ref=&quot;bar&quot;&gt;&lt;/div&gt;
  &lt;/div&gt;
&lt;/template&gt;

&lt;style scoped&gt;
  .wraps &#123;
    width: 100%;
    height: 20px;

    position: fixed;
    top: 0;
    left: 0;
  &#125;

  .wraps .loading-bar &#123;
    height: inherit;
    width: 10px;
    background-color: red;
  &#125;
&lt;/style&gt;
</code></pre>
<ul>
<li><p><code>/src/router/index.js</code>中</p>
<blockquote>
<p>路由配置中</p>
</blockquote>
</li>
<li><p>导航 <code>LoadingBar</code>组件，并利用 <code>createApp</code>方法创建应用实例，然后调用mount方法得到<code>LoadingBar</code>的组件实例。</p>
</li>
<li><p>在<code>router.beforeEach</code> 全局前置守卫中，调用 <code>LoadingBar</code>组件实例的<code>startLoading</code>方法开始加载进度条</p>
</li>
<li><p>在<code>router.afterEach</code> 全局后置守卫中，调用 <code>LoadingBar</code>组件实例的 <code>endLoading</code>方法将进度条拉满，并结束进度条</p>
</li>
<li><p>方法一：</p>
</li>
</ul>
<pre><code>import &#123; createApp &#125; from &quot;vue&quot;;
// 加载组件
import LoadingBar from &quot;../components/loading-bar/LoadingBar.vue&quot;;
// 创建应用实例
const LoadingApp = createApp(LoadingBar);
const fragement = document.createDocumentFragment();
// loadingVm 进度条组件实例
const loadingVm = LoadingApp.mount(fragement);
// 将DOM挂载到页面
document.body.appendChild(fragement);

const router = createRouter(&#123;
  // ....
&#125;);

// 全局前置守卫
router.beforeEach((to, from) =&gt; &#123;
  loadingVm.startLoading();
&#125;);
// 全局后置守卫
router.afterEach((to, from) =&gt; &#123;
  loadingVm.endLoading();
&#125;);
</code></pre>
<ul>
<li>方法二：</li>
</ul>
<pre><code>import &#123; h, render &#125; from &quot;vue&quot;;
import LoadingBar from &quot;../components/LoadingBar.vue&quot;;
const vnode = h(LoadingBar); // 虚拟DOM
render(vnode, document.body); // DOM挂载

// 全局前置守卫
router.beforeEach((to, from) =&gt; &#123;
  vnode.component.exposed.startLoading();
&#125;);
// 全局后置守卫
router.afterEach((to, from) =&gt; &#123;
  vnode.component.exposed.endLoading();
&#125;);
</code></pre>
<ol start="6">
<li>总结<blockquote>
<p>全局导航守卫主要有以下三个钩子函数，所有路由跳转都会触发这三个钩子函数</p>
<table>
<thead>
<tr>
<th>全局守卫</th>
<th>钩子函数</th>
<th>触发时机</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>全局前置守卫</td>
<td>router.beforeEach</td>
<td>导航被触发时执行</td>
<td>在路由跳转时对路由访问权限进行验证，验证通过放行，不通过别做处理</td>
</tr>
<tr>
<td>全局解析守卫</td>
<td>router.beforeResolve</td>
<td>刚好在导航被确认之前触发</td>
<td>是获取数据或执行任何其他操作（如果用户无法进入页面时你希望避免执行的操作）的理想位置</td>
</tr>
<tr>
<td>全局后置钩子</td>
<td>router.afterEach</td>
<td>在导航结束后调用</td>
<td>对于分析、更改页面标题、等辅助功能以及许多其他事情都很有用</td>
</tr>
</tbody></table>
</blockquote>
</li>
</ol>
<h4 id="路由独享导航守卫"><a href="#路由独享导航守卫" class="headerlink" title="路由独享导航守卫"></a>路由独享导航守卫</h4><blockquote>
<p>路由独享导航守卫只有<code>beforeEnter</code>一个钩子函数，当指定路由被进入时触发这个钩子函数。</p>
<p>它会在<code>router.beforeEach</code>和<code>beforeRouteUpdate</code>钩子之后执行</p>
</blockquote>
<table>
<thead>
<tr>
<th>钩子函数</th>
<th>触发时机</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>beforeEnter</td>
<td><strong>只在进入路由时触发</strong>，不会在 <code>params</code>、<code>query</code> 或 <code>hash</code> 改变时触</td>
<td>判断用户是否有权限访问当前路由，如果没有权限就跳转到首页</td>
</tr>
</tbody></table>
<ul>
<li>你可以直接在路由配置上定义<code>beforeEnter</code>守卫（函数）</li>
</ul>
<pre><code>const routes = [
  &#123;
    path: &quot;/about&quot;,
    component: About,
    meta: &#123;
      title: &quot;关于我们&quot;,
    &#125;,
  &#125;,
  &#123;
    path: &quot;/user/:id&quot;,
    component: User,
    meta: &#123;
      // requiresAuth:true,
      title: &quot;个人中心&quot;,
    &#125;,
    // 路由独享导航守卫
    beforeEnter(to, from) &#123;
      console.log(&quot;个人中心beforeEnter&quot;);
    &#125;,
  &#125;,
];
</code></pre>
<blockquote>
<p>注意：针对以上路由</p>
</blockquote>
<ul>
<li>当我们从路由<code>/about</code>跳转到<code>/user/1001</code>时会触发<code>beforeEnter</code>钩子函数。</li>
<li>从路由<code>/user/1001</code>跳转到<code>/user/1002</code>时，不会触发<code>beforeEnter</code> 钩子函数。</li>
<li>当我们从路由<code>/about?a=1</code> 调转到<code>/about?a=2</code>时，不会触发<code>beforeEnter</code>钩子函数。</li>
</ul>
<h4 id="组件级导航守卫"><a href="#组件级导航守卫" class="headerlink" title="组件级导航守卫"></a>组件级导航守卫</h4><blockquote>
<p>组件级导航守卫是指组件内的钩子函数，类似于组件内的生命周期函数，当加载或更新指定组件时触发</p>
<ul>
<li>组件级导航守卫有以下三个钩子函数<table>
<thead>
<tr>
<th>钩子函数</th>
<th>组合式 API</th>
<th>触发时机</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>beforeRouteUpdate</td>
<td>onBeforeRouteUpdate</td>
<td>在当前路由改变，但是该组件被复用时调用</td>
<td>路由参数更新：当同一个组件在不同参数下进行切换时，可能需要根据新的参数更新组件的数据或状态</td>
</tr>
<tr>
<td>beforeRouteEnter</td>
<td>&#x2F;</td>
<td>在渲染该组件的对应路由被确认前调用</td>
<td>数据预加载：在进入组件之前，需要先加载一些数据</td>
</tr>
<tr>
<td>beforeRouteLeave</td>
<td>onBeforeRouteLeave</td>
<td>在导航离开渲染该组件的对应路由时调用</td>
<td>数据清理：在离开当前路由之前需要执行一些清理操作，例如取消订阅事件、重置组件状态，或确认是否保证内容等</td>
</tr>
</tbody></table>
</li>
</ul>
</blockquote>
<blockquote>
<p>注意：</p>
</blockquote>
<ul>
<li><code>beforeRouteUpdate</code>与<code>beforeRouteEnter</code> 两个钩子函数<strong>不会</strong>都触发，如果组件复用就会触发 <code>beforeRouteUpdate</code> 这个钩子，如果组件不复用，则会触发 <code>beforeRouteEnter</code> 钩子</li>
</ul>
<blockquote>
<p>组件级导航守卫是定义在 Vue 组件中，如下：</p>
</blockquote>
<ul>
<li>选项式API</li>
</ul>
<pre><code>&lt;script&gt;
  export default &#123;
    beforeRouteEnter(to, from) &#123;
      // 在渲染该组件的对应路由被验证前调用
      // 不能获取组件实例 `this` ！
      // 因为当守卫执行时，组件实例还没被创建！
    &#125;,
    beforeRouteUpdate(to, from) &#123;
      // 在当前路由改变，但是该组件被复用时调用
      // 举例来说，对于一个带有动态参数的路径 `/users/:id`，在 `/users/1` 和 `/users/2` 之间跳转的时候，
      // 由于会渲染同样的 `UserDetails` 组件，因此组件实例会被复用。而这个钩子就会在这个情况下被调用。
      // 因为在这种情况发生的时候，组件已经挂载好了，导航守卫可以访问组件实例 `this`
    &#125;,
    beforeRouteLeave(to, from) &#123;
      // 在导航离开渲染该组件的对应路由时调用
      // 与 `beforeRouteUpdate` 一样，它可以访问组件实例 `this`
    &#125;,
  &#125;;
&lt;/script&gt;
</code></pre>
<ul>
<li>组合式 API 中没有与<code>onBeforeRouteEnter</code> 对应的钩子函数</li>
</ul>
<pre><code>&lt;script setup&gt;
  import &#123; onBeforeRouteLeave, onBeforeRouteUpdate &#125; from &quot;vue-router&quot;;
  onBeforeRouteUpdate((to, from) =&gt; &#123;
    // ......  注意 this为undefined
  &#125;);

  onBeforeRouteLeave((to, from) =&gt; &#123;
    // ......  注意 this为undefined
  &#125;);
&lt;/script&gt;
</code></pre>
<ol>
<li>beforeRouteEnter<blockquote>
<p><code>beforeRouteEnter</code>守卫<strong>不能</strong>访问 this，因为守卫在导航确认前被调用，因此即将登场的新组件还没被创建。</p>
<p>不过，你可以通过传一个回调给 <code>next</code> 来访问组件实例。在导航被确认的时候执行回调，并且把组件实例作为回调方法的参数</p>
</blockquote>
</li>
</ol>
<pre><code>beforeRouteEnter (to, from, next) &#123;
  next(vm =&gt; &#123;
    // 通过 `vm` 访问组件实例
  &#125;)
&#125;
</code></pre>
<ul>
<li>注意：<code>beforeRouteEnter</code>是支持给 next 传递回调的唯一守卫</li>
</ul>
<ol start="2">
<li>onBeforeRouteUpdate 应用<blockquote>
<p>对于一个带有动态参数的路径 <code>/news/:id</code>，在 <code>/news/1001</code> 和 <code>/news/1002</code> 之间跳转的时候，相同的组件实例将被重复使用，所以生周命期函数并不会被调用。</p>
<p>原本在<code>&lt;script setup&gt;</code>中并不能获取到变化后的参数</p>
<ul>
<li>之前我们是采用侦听器来侦听<code>route</code>对象上的任意属性来实现</li>
</ul>
</blockquote>
</li>
</ol>
<pre><code>// 侦听 route.params的变化
watch(
  () =&gt; route.params,
  (newValue, oldValue, onCleanup) =&gt; &#123;
    // 对路由的变化做出响应
    axios.get(`$&#123;url&#125;$&#123;newValue.id&#125;`).then((res) =&gt; &#123;
      // 发请求拿数据
    &#125;);
  &#125;
);
</code></pre>
<blockquote>
<ul>
<li>有了<code>beforeRouteUpdate</code>钩子函数，我们也可以在这个钩子函数中获取变化后的参数，然后根据不同的参数 id 值来发请求获取数据</li>
</ul>
</blockquote>
<ul>
<li>News.vue 组件</li>
</ul>
<pre><code>&lt;script setup&gt;
  import &#123; ref, watch &#125; from &quot;vue&quot;;
  import axios from &quot;axios&quot;;
  import &#123; useRoute, onBeforeRouteUpdate &#125; from &quot;vue-router&quot;;
  const route = useRoute();
  const list = ref([]);
  const url =
    &quot;https://www.fastmock.site/mock/6ec78e345df340241e1f5043f0167833/icode/new/list/&quot;;

  // 用来取消请求的对象
  let controller = null;
  function getData(id) &#123;
    if (controller) &#123;
      controller.abort();
    &#125;
    controller = new AbortController();
    // // 发请求，拿数据
    axios
      .get(`$&#123;url&#125;$&#123;id&#125;`, &#123;
        // 配置取消请求
        signal: controller.signal,
      &#125;)
      .then((res) =&gt; &#123;
        list.value = res.data.data;
      &#125;)
      .catch((err) =&gt; &#123;
        console.log(err.message);
        console.log(&quot;取消了&quot;);
      &#125;);
  &#125;

  // 未重用组件是调用该方法渲染数据
  getData(route.params.id);
  // 重用组件时
  onBeforeRouteUpdate((to, from) =&gt; &#123;
    getData(to.params.id);
  &#125;);
&lt;/script&gt;

&lt;template&gt;
  &lt;ul&gt;
    &lt;li v-for=&quot;&#123; id, title &#125; in list&quot;&gt;
      &lt;router-link to=&quot;&quot;&gt; &#123;&#123; title &#125;&#125;&lt;/router-link&gt;
    &lt;/li&gt;
  &lt;/ul&gt;
&lt;/template&gt;

&lt;style scoped&gt;
  ul &#123;
    padding: 20px;
  &#125;

  ul li &#123;
    line-height: 35px;
    border-bottom: 1px dashed #ddd;
    text-indent: 2em;
  &#125;

  ul li a &#123;
    color: #333;
    text-decoration: none;
  &#125;
&lt;/style&gt;
</code></pre>
<ul>
<li>路由定义</li>
</ul>
<pre><code>const routes = [
  &#123;
    name: &quot;news&quot;,
    path: &quot;/news/:id&quot;,
    component: News,
  &#125;,
];
</code></pre>
<ul>
<li>导航</li>
</ul>
<pre><code>&lt;router-link to=&quot;/news/1001&quot;&gt; 最新动态 &lt;/router-link&gt;
&lt;router-link to=&quot;/news/1002&quot;&gt; 热门推荐 &lt;/router-link&gt;
&lt;router-link to=&quot;/news/1003&quot;&gt;历史动态 &lt;/router-link&gt;
</code></pre>
<ol start="3">
<li>onBeforeRouteLeave 应用<blockquote>
<p>在离开导航前，可以弹出确认框确认是否要离开，如果确认是则跳到新目标，否则取消导航</p>
</blockquote>
</li>
</ol>
<pre><code>beforeRouteLeave(to, from) &#123;
    const answer = window.confirm(&#39;确认要立开马？当前页面内容是否有保存？&#39;)
    if (!answer) return false
&#125;,
</code></pre>
<h4 id="完整的导航解析流程"><a href="#完整的导航解析流程" class="headerlink" title="完整的导航解析流程"></a>完整的导航解析流程</h4><img src="导航解析流程.png">

<ul>
<li>假设当前应用的路由配置如下：</li>
</ul>
<pre><code>const routes = [
  &#123;
    path: &quot;/&quot;,
    component: Home,
  &#125;,
  &#123;
    path: &quot;/a/:id&quot;,
    component: A,
  &#125;,
  &#123;
    path: &quot;/b&quot;,
    component: B,
  &#125;,
];
</code></pre>
<blockquote>
<p>注：</p>
<ul>
<li>现在我们所在的页面路由为<code>/a/1</code>，接下来我们点击页面导航跳转到<code>/b</code>，整个导航解析流程如下：</li>
</ul>
</blockquote>
<ul>
<li>①、导航被触发。（比如：调用<code>router.push</code>、<code>router.replace</code>等触发导航，但地址栏中导航没有发生变化）</li>
<li>②、在失活的组件里调用<code>beforeRouteLeave</code>守卫。（从<code>/a/1</code>跳转到<code>/b</code>，<code>/a/1</code>路由对应的 A 组件将被销毁，A 组件为失活的组件。在执行 <code>Unmounted</code> 之前，会调用<code>beforeRouteLeave</code>进行拦截）</li>
<li>③、调用全局的 <code>beforeEach</code> 守卫。 （可以在这里验证用户是否有访问该路由权限，如果没有，直接返回首页，如果有就放行，会接着执行后面的钩子函数等）</li>
<li>④、在重用的组件里调用 <code>beforeRouteUpdate</code> 守卫(2.2+)。 （如果从<code>/a/1</code>跳转到<code>/a/2</code>时，会触发这个钩子函数，因为这两个路由重用同一个组件 A。如果从<code>&#39;/a/1&#39;</code>跳转到<code>&#39;/b&#39;</code>则不会触发这个钩子函数）</li>
<li>⑤、在路由配置里调用 <code>beforeEnter</code>。 （只针对指定的路由做拦截，判断用户是否有访问权限等）</li>
<li>⑥、解析异步路由组件。</li>
<li>⑦、在被激活的组件里调用 <code>beforeRouteEnter</code>。 （从&#x2F;a&#x2F;1跳转到&#x2F;b，&#x2F;b路由对应的 B 组件需要渲染成 DOM 挂载到页面，B 组件为激活的组件）</li>
<li>⑧、调用全局的 <code>beforeResolve</code> 守卫(2.5+)。</li>
<li>⑨、导航被确认。（地址栏中导航改变为跳转后地址）</li>
<li>⑩、调用全局的 <code>afterEach</code> 钩子。（导航成功后，可以修改页面标题等其它事情）</li>
<li>⑪、触发 DOM 更新。</li>
<li>⑫、调用 <code>beforeRouteEnter</code> 守卫中传给 next 的回调函数，创建好的组件实例会作为回调函数的参数传入</li>
</ul>
<h3 id="十四、路由组件过渡动画"><a href="#十四、路由组件过渡动画" class="headerlink" title="十四、路由组件过渡动画"></a>十四、路由组件过渡动画</h3><h4 id="路由组件过渡动画"><a href="#路由组件过渡动画" class="headerlink" title="路由组件过渡动画"></a>路由组件过渡动画</h4><blockquote>
<p>如果我们想在路由组件上使用过渡动画，可以使用<code>&lt;router-view&gt;</code>组件的<strong>插槽</strong>功能。</p>
</blockquote>
<ul>
<li>以下代码，所有路由组件在过渡时采用的是统一的过渡动画</li>
</ul>
<pre><code>&lt;!-- route 为当前路由对象  Component 为当前路由显示的组件--&gt;
&lt;router-view v-slot=&quot;&#123;route, Component &#125;&quot;&gt;
  &lt;transition name=&quot;fade&quot;&gt;
    &lt;component :is=&quot;Component&quot; /&gt;
  &lt;/transition&gt;
&lt;/router-view&gt;
</code></pre>
<ul>
<li>注意：上面v-slot中的Component的首字母要大写</li>
</ul>
<blockquote>
<p>代码示例</p>
<ul>
<li>当在不同的路由间进行切换时，被渲染的路由组件以淡入淡出的效果显示<img src="路由组件过渡动画.gif"></li>
</ul>
</blockquote>
<ul>
<li>定义路由</li>
</ul>
<pre><code>import &#123; createRouter, createWebHistory &#125; from &quot;vue-router&quot;;
import Tab1 from &quot;../views/Tab1.vue&quot;;
import Tab2 from &quot;../views/Tab2.vue&quot;;
import Tab3 from &quot;../views/Tab3.vue&quot;;

// 定义一些路由
const routes = [
  &#123;
    name: &quot;tab1&quot;,
    path: &quot;/&quot;,
    component: Tab1,
  &#125;,
  &#123;
    name: &quot;tab2&quot;,
    path: &quot;/tab2&quot;,
    component: Tab2,
  &#125;,
  &#123;
    name: &quot;tab3&quot;,
    path: &quot;/tab3&quot;,
    component: Tab3,
  &#125;,
];

// 创建路由实例
const router = createRouter(&#123;
  history: createWebHistory(),
  routes,
&#125;);

export &#123; router &#125;;
</code></pre>
<ul>
<li>定义三个视图组件<code>Tab1</code>、<code>Tab2</code>、<code>Tab3</code>，内容如下</li>
</ul>
<pre><code>&lt;!--Tab1 组件--&gt;
&lt;template&gt;
  &lt;div class=&quot;tab tab1&quot;&gt;&lt;/div&gt;
&lt;/template&gt;
&lt;style&gt;
  .tab1 &#123;
    width: 400px;
    height: 200px;
    background-color: tomato; /* 红色 */
  &#125;
&lt;/style&gt;

&lt;!--Tab2 组件--&gt;
&lt;template&gt;
  &lt;div class=&quot;tab tab2&quot;&gt;&lt;/div&gt;
&lt;/template&gt;
&lt;style&gt;
  .tab2 &#123;
    width: 400px;
    height: 200px;
    background-color: skyblue; /* 蓝色 */
  &#125;
&lt;/style&gt;

&lt;!--Tab3 组件--&gt;
&lt;template&gt;
  &lt;div class=&quot;tab tab3&quot;&gt;&lt;/div&gt;
&lt;/template&gt;
&lt;style&gt;
  .tab3 &#123;
    width: 400px;
    height: 200px;
    background-color: khaki; /* 黄色 */
  &#125;
&lt;/style&gt;
</code></pre>
<ul>
<li><code>App.vue</code>中创建路由链接和路由视图出口，并对路由组件使用过渡动画</li>
</ul>
<pre><code>&lt;template&gt;
  &lt;ul class=&quot;router-link&quot;&gt;
    &lt;li&gt;&lt;router-link to=&quot;/&quot;&gt;Tab1&lt;/router-link&gt;&lt;/li&gt;
    &lt;li&gt;&lt;router-link to=&quot;/tab2&quot;&gt;Tab2&lt;/router-link&gt;&lt;/li&gt;
    &lt;li&gt;&lt;router-link to=&quot;/tab3&quot;&gt;Tab3&lt;/router-link&gt;&lt;/li&gt;
  &lt;/ul&gt;
  &lt;div class=&quot;router-view&quot;&gt;
    &lt;router-view v-slot=&quot;&#123; route, Component &#125;&quot;&gt;
      &lt;Transition name=&quot;fade&quot; mode=&quot;out-in&quot;&gt;
        &lt;component :is=&quot;Component&quot;&gt;&lt;/component&gt;
      &lt;/Transition&gt;
    &lt;/router-view&gt;
  &lt;/div&gt;
&lt;/template&gt;
&lt;style scoped&gt;
  /* 导航样式 */
  .router-link &#123;
    position: fixed;
    width: 100px;
    height: 200px;
    left: 100px;
  &#125;

  .router-link li &#123;
    list-style: none;
    line-height: 40px;
    border-bottom: 1px dashed #ddd;
  &#125;

  .router-link li a &#123;
    text-decoration: none;
    color: #000;
  &#125;

  .router-link li a.router-link-active &#123;
    color: red;
  &#125;

  .router-view &#123;
    height: 200px;
    width: 400px;
    margin-left: 200px;
    margin-top: 120px;
    overflow: hidden;
  &#125;

  /* 过渡动画样式 */
  .fade-enter-from,
  .fade-leave-to &#123;
    opacity: 0;
  &#125;

  .fade-enter-active,
  .fade-leave-active &#123;
    transition: all 1s ease;
  &#125;
&lt;/style&gt;
</code></pre>
<h4 id="单个路由过渡动画"><a href="#单个路由过渡动画" class="headerlink" title="单个路由过渡动画"></a>单个路由过渡动画</h4><blockquote>
<p>上面的用法会对所有的路由使用相同的过渡，如果你想让每个路由的组件有不同的过渡</p>
</blockquote>
<ul>
<li>你可以将<code>meta</code>路由元信息和动态的 <code>name</code> 或 自定义过渡 <code>class</code> 结合在一起，放在<code>&lt;transition&gt;</code> 上</li>
</ul>
<pre><code>&lt;router-view v-slot=&quot;&#123; route, Component &#125;&quot;&gt;
  &lt;Transition :name=&quot;route.meta.transition &quot;&gt;
    &lt;component :is=&quot;Component&quot; /&gt;
  &lt;/Transition&gt;
&lt;/router-view&gt;
&lt;router-view v-slot=&quot;&#123; route, Component &#125;&quot;&gt;
  &lt;Transition
    :enter-active-class=&quot;route.meta.enterTransition&quot;
    :leave-active-class=&quot;route.meta.leaveTransition&quot;
    mode=&quot;out-in&quot;
  &gt;
    &lt;component :is=&quot;Component&quot; /&gt;
  &lt;/Transition&gt;
&lt;/router-view&gt;
</code></pre>
<blockquote>
<p>完整代码示例</p>
</blockquote>
<ul>
<li>在前面案例的基础上，把每个路由组件需要的动画名配置在<code>meta</code>项中。</li>
<li>以下动画名采用的是第三方的<code>animate.css</code>插件库的动画名</li>
</ul>
<pre><code>import &#123; createRouter, createWebHistory &#125; from &quot;vue-router&quot;;
import Tab1 from &quot;../views/Tab1.vue&quot;;
import Tab2 from &quot;../views/Tab2.vue&quot;;
import Tab3 from &quot;../views/Tab3.vue&quot;;

// 定义一些路由
const routes = [
  &#123;
    name: &quot;tab1&quot;,
    path: &quot;/&quot;,
    component: Tab1,
    meta: &#123;
      enterTransition: &quot;animate__backInDown&quot;,
      leaveTransition: &quot;animate__backOutDown&quot;,
    &#125;,
  &#125;,
  &#123;
    name: &quot;tab2&quot;,
    path: &quot;/tab2&quot;,
    component: Tab2,
    meta: &#123;
      enterTransition: &quot;animate__backInLeft&quot;,
      leaveTransition: &quot;animate__backOutLeft&quot;,
    &#125;,
  &#125;,
  &#123;
    name: &quot;tab3&quot;,
    path: &quot;/tab3&quot;,
    component: Tab3,
    meta: &#123;
      enterTransition: &quot;animate__backInUp&quot;,
      leaveTransition: &quot;animate__backOutUp&quot;,
    &#125;,
  &#125;,
];

// 创建路由实例
const router = createRouter(&#123;
  history: createWebHistory(),
  routes,
&#125;);

export &#123; router &#125;;
</code></pre>
<ul>
<li><code>&lt;Transition&gt;</code>组件的过渡 class 直接从<code>route.meta</code>中读取</li>
</ul>
<pre><code>&lt;script setup&gt;
  import &quot;animate.css&quot;; // 要先执行 npm install animate.css --save 命令安装
&lt;/script&gt;

&lt;template&gt;
  &lt;ul class=&quot;router-link&quot;&gt;
    &lt;li&gt;&lt;router-link to=&quot;/&quot;&gt;Tab1&lt;/router-link&gt;&lt;/li&gt;
    &lt;li&gt;&lt;router-link to=&quot;/tab2&quot;&gt;Tab2&lt;/router-link&gt;&lt;/li&gt;
    &lt;li&gt;&lt;router-link to=&quot;/tab3&quot;&gt;Tab3&lt;/router-link&gt;&lt;/li&gt;
  &lt;/ul&gt;
  &lt;div class=&quot;router-view&quot;&gt;
    &lt;router-view v-slot=&quot;&#123; route, Component &#125;&quot;&gt;
      &lt;Transition
        :enter-active-class=&quot;`animate__animated $&#123;route.meta.enterTransition&#125;`&quot;
        :leave-active-class=&quot;`animate__animated $&#123;route.meta.leaveTransition&#125;`&quot;
        mode=&quot;out-in&quot;
      &gt;
        &lt;component :is=&quot;Component&quot; /&gt;
      &lt;/Transition&gt;
    &lt;/router-view&gt;
  &lt;/div&gt;
&lt;/template&gt;

&lt;style scoped&gt;
  /* ....*/
&lt;/style&gt;
</code></pre>
<h4 id="基于路由的动态过渡"><a href="#基于路由的动态过渡" class="headerlink" title="基于路由的动态过渡"></a>基于路由的动态过渡</h4><blockquote>
<p>也可以根据目标路由和当前路由之间的关系，动态地确定使用的过渡。<br>当从<code>/tab2/1</code>跳到<code>/tab1</code>时，采用的是淡入淡出动画。当从<code>tab1</code>跳转到<code>/tab2/1</code>时，采用的是左右滑动动画。 我们可以根据目标路由与当前路由的深度来决定采用何种动画过渡。</p>
</blockquote>
<blockquote>
<p>代码实现</p>
</blockquote>
<pre><code>&lt;!-- 使用动态过渡名称 --&gt;
&lt;router-view v-slot=&quot;&#123; Component, route &#125;&quot;&gt;
  &lt;transition :name=&quot;route.meta.transition&quot;&gt;
    &lt;component :is=&quot;Component&quot; /&gt;
  &lt;/transition&gt;
&lt;/router-view&gt;
</code></pre>
<ul>
<li>我们可以在<code>router.afterEach</code>导航后置守卫中，根据路径的深度动态添加信息到 <code>meta</code> 字段，来决定当前路由组件的过渡动画</li>
</ul>
<pre><code>router.afterEach((to, from) =&gt; &#123;
  const toDepth = to.path.split(&quot;/&quot;).length;
  const fromDepth = from.path.split(&quot;/&quot;).length;
  to.meta.transition = toDepth &lt; fromDepth ? &quot;fade&quot; : &quot;slide&quot;;
&#125;);
</code></pre>
<h4 id="强制在复用的视图之间进行过渡"><a href="#强制在复用的视图之间进行过渡" class="headerlink" title="强制在复用的视图之间进行过渡"></a>强制在复用的视图之间进行过渡</h4><blockquote>
<p>Vue 可能会自动复用看起来相似的组件，从而忽略了任何过渡。幸运的是，可以添加一个 <code>key</code> 属性来强制过渡。</p>
</blockquote>
<ul>
<li>这也允许你在相同路由上使用不同的参数触发过渡</li>
</ul>
<pre><code>&lt;router-view v-slot=&quot;&#123; Component, route &#125;&quot;&gt;
  &lt;transition name=&quot;fade&quot;&gt;
    &lt;component :is=&quot;Component&quot; :key=&quot;route.path&quot; /&gt;
  &lt;/transition&gt;
&lt;/router-view&gt;
const routes = [
  &#123;
    name: &quot;tab2&quot;,
    path: &quot;/tab2/:id&quot;,
    component: Tab2,
  &#125;,
];
&lt;div class=&quot;menu&quot;&gt;
  &lt;div&gt;&lt;router-link to=&quot;/tab2/1&quot;&gt;Tab2-1&lt;/router-link&gt;&lt;/div&gt;
  &lt;div&gt;&lt;router-link to=&quot;/tab2/2&quot;&gt;Tab2-2&lt;/router-link&gt;&lt;/div&gt;
  &lt;div&gt;&lt;router-link to=&quot;/tab2/3&quot;&gt;Tab2-3&lt;/router-link&gt;&lt;/div&gt;
&lt;/div&gt;
</code></pre>
<ul>
<li>如果<code>&lt;component :is=&quot;Component&quot; :key=&quot;route.path&quot; /&gt;</code>中没有添加<code>:key</code>属性，从<code>/tab2/</code>跳转到<code>/tab2/2</code>或<code>/tab2/3</code>时，并不会有过渡动画</li>
</ul>
<h3 id="十五、页面滚动行为"><a href="#十五、页面滚动行为" class="headerlink" title="十五、页面滚动行为"></a>十五、页面滚动行为</h3><blockquote>
<p>使用前端路由，当切换到新的路由时，想要滚动到页面顶部，或者保持原先的滚动位置是可以做到的。<br>注意：这个功能只在支持 <code>history.pushState</code> 的浏览器中可用。</p>
</blockquote>
<ul>
<li>我们需要在创建 Router 实例时，提供一个<code>scrollBehavior</code>方法</li>
</ul>
<pre><code>const router = createRouter(&#123;
  history: createWebHistory(),
  routes,
  // to 目标路由
  // from 离开页面路由
  // savedPosition 保存当前路由滚动的位置  只有当这是一个 popstate 导航时才可用（由浏览器的后退/前进按钮触发）
  scrollBehavior(to, from, savedPosition) &#123;
    // return 你期望滚动到的位置
  &#125;,
&#125;);
</code></pre>
<blockquote>
<p>scrollBehavior 函数返回值</p>
</blockquote>
<ul>
<li>返回值如果为一个空对象，表示路由切换时不发生滚动</li>
<li>如果是包含以下属性的对象，会滚动到你所设置的位置</li>
</ul>
<pre><code>&#123;
    // el 值为一个css选择器或一个DOM元素
    // 在没有el属性时，top与left值分表示滚动条与浏览器顶部与左边距离
    // 有el属性时，top值与left值是相对于el选中元素的位置偏移量
    top:0,
    left:0,
    // 值是一个css选择器或获取的DOM元素
    el:&#39;.title&#39;  // document.querySelector(&#39;.title&#39;)
    behavior：&#39;smooth&#39; // 平滑滚动
&#125;
</code></pre>
<ul>
<li>如果返加一个<code>Promise</code>对象， 则表示期望在等待一定时间后再滚动到指定位置，比如：当前页面有过渡动画，希望在过渡动画结束后再来滚动。</li>
</ul>
<pre><code>const router = createRouter(&#123;
  scrollBehavior(to, from, savedPosition) &#123;
    return new Promise((resolve, reject) =&gt; &#123;
      //  在 500秒后，再滚动浏览器顶部
      setTimeout(() =&gt; &#123;
        resolve(&#123; left: 0, top: 0 &#125;);
      &#125;, 500);
    &#125;);
  &#125;,
&#125;);
</code></pre>
<ol>
<li>滚动到页面顶部<blockquote>
<p>以下代码中<code>scrollBehavior函数</code>的返回值，表示进入页面时，滚动条滚动到页面顶部</p>
</blockquote>
</li>
</ol>
<pre><code>scrollBehavior(to, from, savedPosition) &#123;
    return &#123;top:0&#125;  // 进入页面时，滚动条滚动到页面顶部
    // return &#123;top:0,left:0&#125;
&#125;
</code></pre>
<ol start="2">
<li>滚动到指定元素偏移位置<blockquote>
<p>以下代码中<code>scrollBehavior</code>的返回值，表示进入<code>/tab2/1001</code>页面时，滚动到<code>h3.title</code>元素顶部所在位置，其它情况滚动到浏览器的顶部。</p>
</blockquote>
</li>
</ol>
<pre><code>scrollBehavior(to, from, savedPosition) &#123;
    if(to.path===&#39;/tab2/1001&#39;)&#123;
        return &#123;
            // 滚动值top，为相对路由组件中 h3.title元素的偏移量
            el: &#39;h3.title&#39;,
            top: 0
        &#125;
    &#125;else&#123;
        return &#123;
            top:0
        &#125;
    &#125;

&#125;
</code></pre>
<ul>
<li>我们在<code>App.vue</code>文件<code>.main</code>元素下添加<code>h3.title</code>元素</li>
</ul>
<pre><code>&lt;div class=&quot;main&quot;&gt;
  &lt;!-- 部分代码省略--&gt;
&lt;/div&gt;
&lt;h3 class=&quot;title&quot;&gt;我是h3.title元素，滚动位置相对我的偏移量&lt;/h3&gt;
</code></pre>
<ol start="3">
<li>保持原先滚动位置<blockquote>
<p>当通过浏览器的浏览器的 <strong>后退</strong> 或 <strong>前进</strong> 按钮返回到原来页面时，会滚动到原先滚动的位置。</p>
<ul>
<li>如果不是通过后退和前进按扭，则滚动到浏览器顶部。</li>
</ul>
</blockquote>
</li>
</ol>
<ul>
<li>代码如下：</li>
</ul>
<pre><code>scrollBehavior(to, from, savedPosition) &#123;
    // savedPosition 保存当当前路由的滚动位置
    // 只有当这是一个 popstate`导航时才可用（由浏览器的后退/前进按钮触发），所以针对前进和后退按扭可以滚动到原先位置，其它的情况则不行。
    console.log(savedPosition)

    // 有值，表示是浏览器前进后退按扭触发导航，则可以返回到原位置，否则返回到顶部
    if (savedPosition) &#123;
        return savedPosition
    &#125; else &#123;
        return &#123;
            top: 0,
            behavior: &#39;smooth&#39;
        &#125;
    &#125;
&#125;
</code></pre>
<ol start="4">
<li>滚动到锚点<blockquote>
<p>当我们点击锚点链接时，能平滑滚动到页面的锚点所在位置，如下图</p>
</blockquote>
</li>
</ol>
<ul>
<li>我们在<code>Tab1</code>组件中添加锚点链接和锚点要跳转到位置</li>
</ul>
<pre><code>&lt;div class=&quot;tab tab1&quot;&gt;
  &lt;!-- 锚点链接 --&gt;
  &lt;router-link to=&quot;#ab&quot;&gt;锚点链接&lt;/router-link&gt;
  &lt;h1 style=&quot;height:1000px&quot;&gt;&lt;/h1&gt;
  &lt;!-- 锚点位置--&gt;
  &lt;div id=&quot;ab&quot;&gt;&lt;/div&gt;
&lt;/div&gt;
</code></pre>
<ul>
<li>添加以下配置使滚动条平滑滚动到锚点所在位置</li>
</ul>
<pre><code>// 创建路由实例
const router = createRouter(&#123;
  history: createWebHistory(), // history模式
  routes,
  scrollBehavior(to, from, savedPosition) &#123;
    // 判断是否有hash值，如果有hash值，则跳转到指定hash值（锚点所链接位置）
    if (to.hash) &#123;
      return &#123;
        el: to.hash,
        behavior: &quot;smooth&quot;,
      &#125;;
    &#125;
  &#125;,
&#125;);
</code></pre>
<ol start="5">
<li>延迟滚动<blockquote>
<p>当进入到页面后，会先执行路由组件过渡动画，2 秒后动画执行完，滚动条再滚动到与浏览器顶部100px的位置</p>
</blockquote>
</li>
</ol>
<pre><code>scrollBehavior(to, from, savedPosition) &#123;
        return new Promise((resolve, reject) =&gt; &#123;
            // 2秒后，滚动条再开始平滑滚动到与浏览器顶部100px位置
            setTimeout(() =&gt; &#123;
                resolve(&#123;
                    top: 100,
                    left: 0,
                    behavior: &#39;smooth&#39;
                &#125;)
            &#125;, 2000)
        &#125;)
    &#125;
</code></pre>
<h3 id="十六、路由懒加载"><a href="#十六、路由懒加载" class="headerlink" title="十六、路由懒加载"></a>十六、路由懒加载</h3><ol>
<li>路由懒加载</li>
</ol>
<ul>
<li>路由懒加载是指按需加载路由所需的组件，即用到该组件就加载，没用到就不加载</li>
<li>使用<code>import()</code>函数就可以实现动态导入（按需加载）组件</li>
</ul>
<pre><code>// import() 动态加载组件，我们并不需要他一上来就加载，而是希望在用到时才加载，所以我们把import()作为箭头函数的返回值
const Tab3 = () =&gt; import(&quot;../views/Tab3.vue&quot;);

// 需要加载组件时，调用Tab3，加载Tab3组件
Tab3();
</code></pre>
<ul>
<li>在定义路由时，<code>component</code>和<code>components</code>配置可以接收一个返回 <code>Promise</code> 组件的函数。</li>
</ul>
<pre><code>const routes = [
  &#123;
    name: &quot;tab3&quot;,
    path: &quot;/tab3&quot;,
    // 以下import()方法本身返回的是一个Promise组件函数
    component: () =&gt; import(&quot;../views/Tab1.vue&quot;),
  &#125;,
];

// 或
const routes = [
  &#123;
    name: &quot;tab3&quot;,
    path: &quot;/tab3&quot;,
    // 接受一个返回Promise组件函数
    component: () =&gt;
      Promise.resolve(&#123;
        render() &#123;
          return h(&quot;div&quot;, &quot;动态导入组件Tab2&quot;);
        &#125;,
      &#125;),
  &#125;,
];
</code></pre>
<blockquote>
<p>代码演示</p>
</blockquote>
<ul>
<li>把之前案例中<code>router/index.js</code>中定义路由相关代码替换成如下</li>
</ul>
<pre><code>// 定义一些路由
const routes = [
  &#123;
    name: &quot;tab1&quot;,
    path: &quot;/&quot;,
    // 动态加载组件
    component: () =&gt; import(&quot;../views/Tab1.vue&quot;),
    meta: &#123;
      enterTransition: &quot;animate__backInDown&quot;,
      leaveTransition: &quot;animate__backOutDown&quot;,
    &#125;,
  &#125;,
  &#123;
    name: &quot;tab2&quot;,
    path: &quot;/tab2&quot;,
    // 动态加载组件
    component: () =&gt; import(&quot;../views/Tab2.vue&quot;),
    meta: &#123;
      enterTransition: &quot;animate__backInLeft&quot;,
      leaveTransition: &quot;animate__backOutLeft&quot;,
    &#125;,
  &#125;,
  &#123;
    name: &quot;tab3&quot;,
    path: &quot;/tab3&quot;,
    // 动态加载组件
    component: () =&gt;
      Promise.resolve(&#123;
        // 定义组件
        setup() &#123;
          const msg = ref(&quot;Hello 动态加载组件&quot;);
          return () =&gt; h(&quot;div&quot;, msg.value);
        &#125;,
      &#125;),
    meta: &#123;
      enterTransition: &quot;animate__backInUp&quot;,
      leaveTransition: &quot;animate__backOutUp&quot;,
    &#125;,
  &#125;,
];
</code></pre>
<ul>
<li>初次加载应用时，并不会加载没有用到的<code>Tab2</code>和<code>Tab3</code>组件，所以初次加载应用会非常快</li>
<li>当我们点击<code>Tab2</code>导航进入当前路由时，才会加载<code>Tab2</code>组件，并将组件缓存起来，当后面再次进到<code>Tab2</code>页面，不会再加载对应组件，而是会从缓存中读取。</li>
<li>当我们点击<code>Tab3</code>导航进入当前路由时，才会调用<code>component</code>后面的函数，渲染 DOM，插入页面</li>
</ul>
<ol start="2">
<li>静态与动态加载组件对比</li>
</ol>
<ul>
<li>使用<code>import</code>关键字来加载组件，属于静态加载</li>
<li>静态导入组件有一个很大的弊端，在初次加载应用时，不管是否用到该路由，都会加载该组件，所以造成应用初次加载会很慢。</li>
</ul>
<pre><code>// 静态导入组件
import Tab1 from &quot;../views/Tab1.vue&quot;;
使用import()函数来加载组件，属于动态加载组件
动态导入组件实现按需加载所需组件，所以初次加载应用时，用不到的组件不会加载，首次加载应用会很快，性能更好。
// 动态导入组件
const Tab1 = () =&gt; import(&quot;../views/Tab1.vue&quot;);
</code></pre>
<ul>
<li>对于单页面开发，对所有的路由都实现按需加载是非常好的，这样初始加载应用时速度会更快，更高效。</li>
</ul>
<h3 id="十七、动态路由"><a href="#十七、动态路由" class="headerlink" title="十七、动态路由"></a>十七、动态路由</h3><blockquote>
<p>对路由的添加通常是通过<code>createRouter</code>构造函数的配置项<code>routes</code>选项来完成的。</p>
<p>但有些情况下，我们需要在程序运行时动态的添加或删除路由，我们可以调用<code>router</code>实例的相关方法来完成。</p>
</blockquote>
<ol>
<li>添加路由</li>
</ol>
<ul>
<li>调用<code>router.addRoute()</code>方法实现添加路由，只是添加路由到 <code>routes</code>选项中，并不会发生页面导航行为</li>
<li>在<code>router.addRoute()</code>中传入一个路由对象作为参数，会动态添加该路由到<code>routes</code>选项中</li>
</ul>
<pre><code>router.addRoute(&#123; name: &quot;tab1&quot;, path: &quot;/tab1&quot;, component: Tab1 &#125;);
</code></pre>
<ol start="2">
<li>添加嵌套路由<blockquote>
<p>如果需要为某个路由添加嵌套的子路由，可以将该路由的名字作为第一个参数传递给<code>router.addRoute()</code>，需要添加的子路由作为第二个参数传入。</p>
</blockquote>
</li>
</ol>
<pre><code>// 添加路由
router.addRoute(&#123; path: &quot;/user&quot;, name: &quot;user&quot;, component: User &#125;);
// 为上一条路由添加子路由
router.addRoute(&quot;user&quot;, &#123; path: &quot;info&quot;, name: &quot;info&quot;, component: Info &#125;);
</code></pre>
<ul>
<li>以上两条代码执行后，相当于在routes选项中添加了如下路由</li>
</ul>
<pre><code>const routes = [
  &#123;
    path: &quot;/user&quot;,
    name: &quot;user&quot;,
    component: User,
    children: [
      &#123;
        path: &quot;info&quot;,
        name: &quot;info&quot;,
        component: Info,
      &#125;,
    ],
  &#125;,
];
</code></pre>
<ol start="3">
<li>删除路由<blockquote>
<p>删除routes选项中的某个路由，有以下三种方式</p>
</blockquote>
</li>
</ol>
<ul>
<li>方法1：添加一个已存在的同名（<code>name</code>值相同）路由，则会先删除原路由，再加添新路由</li>
</ul>
<pre><code>router.addRoute(&#123; name: &quot;tab1&quot;, path: &quot;/tab1&quot;, component: Tab1 &#125;);
// 最终以下面这个为主
router.addRoute(&#123; name: &quot;tab1&quot;, path: &quot;/&quot;, component: Home &#125;);
</code></pre>
<ul>
<li>方法2：通过调用<code>router.addRoute()</code>返回的回调，针对没有名字的路由，这个方式很有用</li>
</ul>
<pre><code>//这里的removeRoute只是自己取的名字，与方法3不同
const removeRoute = router.addRoute(&#123;
  name: &quot;tab1&quot;,
  path: &quot;/tab1&quot;,
  component: Tab1,
&#125;);

//  删除路由如果存在的话
removeRoute();
</code></pre>
<ul>
<li>方法3：通过调用<code>router.removeRoute()</code>按路由名称来删除路由</li>
</ul>
<pre><code>router.addRoute(&#123; path: &quot;/tab2&quot;, name: &quot;tab2&quot;, component: Tab2 &#125;);
// 删除路由
router.removeRoute(&quot;tab2&quot;);
</code></pre>
<ul>
<li>当路由被删除时，所有与该路由相关的内容都会被删除，也就是routes选项中没有该项</li>
</ul>
<ol start="4">
<li>查看现有路由</li>
</ol>
<ul>
<li><code>router.hasRoute()</code>方法用于检查一个给定名称的路由是否存在，存在返回 true，不存在返回 false</li>
</ul>
<pre><code>router.hasRoute(&quot;user&quot;); // user为路由名称，存在返回true,不存在返回false
</code></pre>
<ul>
<li><code>router.getRoutes()</code>方法能获得所有路由记录的完整列表</li>
</ul>
<pre><code>const routes = router.getRoutes(); // 相当于返回 路由定义中的routes
</code></pre>
<ol start="5">
<li>演示案例</li>
</ol>
<ul>
<li>当前项目的 routes 选项，默认只配置了一个路由，其它全都通过动态形式来添加</li>
</ul>
<pre><code>import &#123; createRouter, createWebHistory &#125; from &quot;vue-router&quot;;

// 定义一些路由
const routes = [
  &#123;
    name: &quot;home&quot;,
    path: &quot;/&quot;,
    component: () =&gt; import(&quot;../views/Home.vue&quot;),
  &#125;,
];

// 创建路由实例
const router = createRouter(&#123;
  history: createWebHistory(),
  routes,
&#125;);

export &#123; router &#125;;
</code></pre>
<ul>
<li>App.vue组件</li>
</ul>
<pre><code>&lt;script setup&gt;
  import &#123; ref &#125; from &quot;vue&quot;;

  const removeRoute = ref(null);
  import &#123; useRouter &#125; from &quot;vue-router&quot;;
  const router = useRouter();
  // 添加路由Tab1 和 user 及 user子路由
  function addRoute1(nameOrRoute, route) &#123;
    if (arguments.length === 1) &#123;
      router.addRoute(nameOrRoute);
    &#125; else &#123;
      router.addRoute(nameOrRoute, route);
    &#125;
  &#125;

  // 添加路由Tab2
  function addRoute2() &#123;
    removeRoute.value = router.addRoute(&#123;
      name: &quot;tab2&quot;,
      path: &quot;/tab2&quot;,
      component: () =&gt; import(&quot;./views/Tab2.vue&quot;),
    &#125;);
  &#125;

  // 移除路由Tab1
  function removeRoute1(route) &#123;
    router.removeRoute(route);
  &#125;

  // 删除路由2
  function removeRoute2() &#123;
    removeRoute.value();
  &#125;

  // 查看当前所有路由记录
  function getRoutes() &#123;
    console.log(router.getRoutes());
  &#125;
&lt;/script&gt;

&lt;template&gt;
  &lt;button
    @click=&quot;addRoute1(&#123; name: &#39;tab1&#39;, path: &#39;/tab1&#39;, component: () =&gt; import(&#39;./views/Tab1.vue&#39;) &#125;)&quot;
  &gt;
    添加 / tab1路由
  &lt;/button&gt;
  |
  &lt;button @click=&quot; addRoute2()&quot;&gt;添加/tab2路由&lt;/button&gt;

  &lt;br /&gt;&lt;br /&gt;
  &lt;button @click=&quot;removeRoute1(&#39;tab1&#39;)&quot;&gt;按名路由名删除/tab1路由&lt;/button&gt; |
  &lt;button @click=&quot;removeRoute2()&quot;&gt;按addRoute回调删除/tab2路由&lt;/button&gt;

  &lt;br /&gt;&lt;br /&gt;
  &lt;button
    @click=&quot;addRoute1(&#123; name: &#39;user&#39;, path: &#39;/user&#39;, component: () =&gt; import(&#39;./views/user.vue&#39;) &#125;)&quot;
  &gt;
    添加/user路由
  &lt;/button&gt;
  |
  &lt;button
    @click=&quot;addRoute1(&#39;user&#39;, &#123; path: &#39;info&#39;, name: &#39;info&#39;, component: () =&gt; import(&#39;./views/Info.vue&#39;) &#125;)&quot;
  &gt;
    添加user子路由
  &lt;/button&gt;

  &lt;button @click=&quot;getRoutes&quot;&gt;查看当前所有路由记录&lt;/button&gt;

  &lt;br /&gt;&lt;br /&gt;
  &lt;div class=&quot;menu&quot;&gt;
    &lt;router-link to=&quot;/&quot;&gt; home &lt;/router-link&gt; |
    &lt;router-link to=&quot;/tab1&quot;&gt; tab1 &lt;/router-link&gt; |
    &lt;router-link to=&quot;/tab2&quot;&gt; tab2 &lt;/router-link&gt; |
    &lt;router-link to=&quot;/user&quot;&gt; user &lt;/router-link&gt;
  &lt;/div&gt;

  &lt;div class=&quot;main&quot;&gt;
    &lt;router-view&gt;&lt;/router-view&gt;
  &lt;/div&gt;
&lt;/template&gt;

&lt;style&gt;
  .main &#123;
    margin-top: 30px;
    display: flex;
    justify-content: center;
    align-items: center;
  &#125;
&lt;/style&gt;
</code></pre>
<ul>
<li>User 组件中内容如下，其它路由子组件内容，大家可以自己随意添加</li>
</ul>
<pre><code>&lt;template&gt;
  &lt;div&gt;
    &lt;h3&gt;用户中心&lt;/h3&gt;
    &lt;div class=&quot;menu&quot;&gt;
      &lt;router-link to=&quot;/user/info&quot;&gt; Info &lt;/router-link&gt;
    &lt;/div&gt;

    &lt;div&gt;
      &lt;router-view&gt;&lt;/router-view&gt;
    &lt;/div&gt;
  &lt;/div&gt;
&lt;/template&gt;
</code></pre>
<ul>
<li>刚开始，除了网站首页能访问，其它路由都不存在，则都无法访问，控制台抛出一堆警告</li>
<li>点击添加<code>/tab1</code>与<code>/tab2</code>路由后，两路由可正常访问</li>
<li>添加删除<code>/tab1</code>与<code>/tab2</code>路由后，两路由失效，无法访问</li>
<li>点击添加<code>/user</code>路由后，<code>/user</code>路由可访问，但其子路由<code>/user/info</code>还没法访问</li>
<li>点击添加<code>/user</code>子路由后，则<code>/user/info</code>路由可正常访问</li>
<li>最后点击查看当前所有路由记录</li>
</ul>

                
            </div>
            <hr/>

            

    <div class="reprint" id="reprint-statement">
        
            <div class="reprint__author">
                <span class="reprint-meta" style="font-weight: bold;">
                    <i class="fas fa-user">
                        文章作者:
                    </i>
                </span>
                <span class="reprint-info">
                    <a href="/about" rel="external nofollow noreferrer">hermia</a>
                </span>
            </div>
            <div class="reprint__type">
                <span class="reprint-meta" style="font-weight: bold;">
                    <i class="fas fa-link">
                        文章链接:
                    </i>
                </span>
                <span class="reprint-info">
                    <a href="https://hermiablog.com/2024/01/27/Vue%EF%BC%88%E4%B8%83%EF%BC%89/">https://hermiablog.com/2024/01/27/Vue%EF%BC%88%E4%B8%83%EF%BC%89/</a>
                </span>
            </div>
            <div class="reprint__notice">
                <span class="reprint-meta" style="font-weight: bold;">
                    <i class="fas fa-copyright">
                        版权声明:
                    </i>
                </span>
                <span class="reprint-info">
                    本博客所有文章除特別声明外，均采用
                    <a href="https://creativecommons.org/licenses/by/4.0/deed.zh" rel="external nofollow noreferrer" target="_blank">CC BY 4.0</a>
                    许可协议。转载请注明来源
                    <a href="/about" target="_blank">hermia</a>
                    !
                </span>
            </div>
        
    </div>

    <script async defer>
      document.addEventListener("copy", function (e) {
        let toastHTML = '<span>复制成功，请遵循本文的转载规则</span><button class="btn-flat toast-action" onclick="navToReprintStatement()" style="font-size: smaller">查看</a>';
        M.toast({html: toastHTML})
      });

      function navToReprintStatement() {
        $("html, body").animate({scrollTop: $("#reprint-statement").offset().top - 80}, 800);
      }
    </script>



            <div class="tag_share" style="display: block;">
                <div class="post-meta__tag-list" style="display: inline-block;">
                    
                        <div class="article-tag">
                            
                                <a href="/tags/Vue/">
                                    <span class="chip bg-color">Vue</span>
                                </a>
                            
                        </div>
                    
                </div>
                <div class="post_share" style="zoom: 80%; width: fit-content; display: inline-block; float: right; margin: -0.15rem 0;">
                    <link rel="stylesheet" type="text/css" href="/libs/share/css/share.min.css">
<div id="article-share">

    
    <div class="social-share" data-sites="qq,qzone,wechat,weibo" data-wechat-qrcode-helper="<p>微信扫一扫即可分享！</p>"></div>
    <script src="/libs/share/js/social-share.min.js"></script>
    

    

</div>

                </div>
            </div>
            
                <style>
    #reward {
        margin: 40px 0;
        text-align: center;
    }

    #reward .reward-link {
        font-size: 1.4rem;
        line-height: 38px;
    }

    #reward .btn-floating:hover {
        box-shadow: 0 6px 12px rgba(0, 0, 0, 0.2), 0 5px 15px rgba(0, 0, 0, 0.2);
    }

    #rewardModal {
        width: 320px;
        height: 350px;
    }

    #rewardModal .reward-title {
        margin: 15px auto;
        padding-bottom: 5px;
    }

    #rewardModal .modal-content {
        padding: 10px;
    }

    #rewardModal .close {
        position: absolute;
        right: 15px;
        top: 15px;
        color: rgba(0, 0, 0, 0.5);
        font-size: 1.3rem;
        line-height: 20px;
        cursor: pointer;
    }

    #rewardModal .close:hover {
        color: #ef5350;
        transform: scale(1.3);
        -moz-transform:scale(1.3);
        -webkit-transform:scale(1.3);
        -o-transform:scale(1.3);
    }

    #rewardModal .reward-tabs {
        margin: 0 auto;
        width: 210px;
    }

    .reward-tabs .tabs {
        height: 38px;
        margin: 10px auto;
        padding-left: 0;
    }

    .reward-content ul {
        padding-left: 0 !important;
    }

    .reward-tabs .tabs .tab {
        height: 38px;
        line-height: 38px;
    }

    .reward-tabs .tab a {
        color: #fff;
        background-color: #ccc;
    }

    .reward-tabs .tab a:hover {
        background-color: #ccc;
        color: #fff;
    }

    .reward-tabs .wechat-tab .active {
        color: #fff !important;
        background-color: #22AB38 !important;
    }

    .reward-tabs .alipay-tab .active {
        color: #fff !important;
        background-color: #019FE8 !important;
    }

    .reward-tabs .reward-img {
        width: 210px;
        height: 210px;
    }
</style>

<div id="reward">
    <a href="#rewardModal" class="reward-link modal-trigger btn-floating btn-medium waves-effect waves-light red">赏</a>

    <!-- Modal Structure -->
    <div id="rewardModal" class="modal">
        <div class="modal-content">
            <a class="close modal-close"><i class="fas fa-times"></i></a>
            <h4 class="reward-title">你的赏识是我前进的动力</h4>
            <div class="reward-content">
                <div class="reward-tabs">
                    <ul class="tabs row">
                        <li class="tab col s6 alipay-tab waves-effect waves-light"><a href="#alipay">支付宝</a></li>
                        <li class="tab col s6 wechat-tab waves-effect waves-light"><a href="#wechat">微 信</a></li>
                    </ul>
                    <div id="alipay">
                        <img src="/medias/reward/alipay.jpg" class="reward-img" alt="支付宝打赏二维码">
                    </div>
                    <div id="wechat">
                        <img src="/medias/reward/wechat.png" class="reward-img" alt="微信打赏二维码">
                    </div>
                </div>
            </div>
        </div>
    </div>
</div>

<script>
    $(function () {
        $('.tabs').tabs();
    });
</script>

            
        </div>
    </div>

    

    

    

    

    

    

    

    

<article id="prenext-posts" class="prev-next articles">
    <div class="row article-row">
        
        <div class="article col s12 m6" data-aos="fade-up">
            <div class="article-badge left-badge text-color">
                <i class="fas fa-chevron-left"></i>&nbsp;上一篇</div>
            <div class="card">
                <a href="/2024/01/28/Vue%EF%BC%88%E5%85%AB%EF%BC%89/">
                    <div class="card-image">
                        
                        <img src="/medias/featureimages/49.jpg" class="responsive-img" alt="Vue（八）">
                        
                        <span class="card-title">Vue（八）</span>
                    </div>
                </a>
                <div class="card-content article-content">
                    <div class="summary block-with-text">
                        
                            Pinia、Teleport内置组件、ESLint、Prettier、VueUse
                        
                    </div>
                    <div class="publish-info">
                        <span class="publish-date">
                            <i class="far fa-clock fa-fw icon-date"></i>2024-01-28
                        </span>
                        <span class="publish-author">
                            
                            <i class="fas fa-bookmark fa-fw icon-category"></i>
                            
                            <a href="/categories/%E6%8A%80%E6%9C%AF/" class="post-category">
                                    技术
                                </a>
                            
                            
                        </span>
                    </div>
                </div>
                
                <div class="card-action article-tags">
                    
                    <a href="/tags/Vue/">
                        <span class="chip bg-color">Vue</span>
                    </a>
                    
                </div>
                
            </div>
        </div>
        
        
        <div class="article col s12 m6" data-aos="fade-up">
            <div class="article-badge right-badge text-color">
                下一篇&nbsp;<i class="fas fa-chevron-right"></i>
            </div>
            <div class="card">
                <a href="/2024/01/26/Vue%EF%BC%88%E5%85%AD%EF%BC%89/">
                    <div class="card-image">
                        
                        <img src="/medias/featureimages/47.jpg" class="responsive-img" alt="Vue（六）">
                        
                        <span class="card-title">Vue（六）</span>
                    </div>
                </a>
                <div class="card-content article-content">
                    <div class="summary block-with-text">
                        
                            渲染机制、虚拟DOM、render函数、h函数、渲染流程、函数式组件、Transition内置组件
                        
                    </div>
                    <div class="publish-info">
                            <span class="publish-date">
                                <i class="far fa-clock fa-fw icon-date"></i>2024-01-26
                            </span>
                        <span class="publish-author">
                            
                            <i class="fas fa-bookmark fa-fw icon-category"></i>
                            
                            <a href="/categories/%E6%8A%80%E6%9C%AF/" class="post-category">
                                    技术
                                </a>
                            
                            
                        </span>
                    </div>
                </div>
                
                <div class="card-action article-tags">
                    
                    <a href="/tags/Vue/">
                        <span class="chip bg-color">Vue</span>
                    </a>
                    
                </div>
                
            </div>
        </div>
        
    </div>
</article>

</div>



<!-- 代码块功能依赖 -->
<script type="text/javascript" src="/libs/codeBlock/codeBlockFuction.js"></script>

<!-- 代码语言 -->

<script type="text/javascript" src="/libs/codeBlock/codeLang.js"></script>


<!-- 代码块复制 -->

<script type="text/javascript" src="/libs/codeBlock/codeCopy.js"></script>


<!-- 代码块收缩 -->

<script type="text/javascript" src="/libs/codeBlock/codeShrink.js"></script>


  </div>
  <div id="toc-aside" class="expanded col l3 hide-on-med-and-down">
    <div class="toc-widget card" style="background-color: white">
      <div class="toc-title">
        <i class="far fa-list-alt"></i>&nbsp;&nbsp;目录
      </div>
      <div id="toc-content"></div>
    </div>
  </div>
</div>

<!-- TOC 悬浮按钮. -->

<div id="floating-toc-btn" class="hide-on-med-and-down">
  <a class="btn-floating btn-large bg-color">
    <i class="fas fa-list-ul"></i>
  </a>
</div>


<script src="/libs/tocbot/tocbot.min.js"></script>
<script>
  $(function () {
      tocbot.init({
          tocSelector: '#toc-content',
          contentSelector: '#articleContent',
          headingsOffset: -($(window).height() * 0.4 - 45),
          collapseDepth: Number('0'),
          headingSelector: 'h2, h3, h4'
      });

      // modify the toc link href to support Chinese.
      let i = 0;
      let tocHeading = 'toc-heading-';
      $('#toc-content a').each(function () {
          $(this).attr('href', '#' + tocHeading + (++i));
      });

      // modify the heading title id to support Chinese.
      i = 0;
      $('#articleContent').children('h2, h3, h4').each(function () {
          $(this).attr('id', tocHeading + (++i));
      });

      // Set scroll toc fixed.
      let tocHeight = parseInt($(window).height() * 0.4 - 64);
      let $tocWidget = $('.toc-widget');
      $(window).scroll(function () {
          let scroll = $(window).scrollTop();
          /* add post toc fixed. */
          if (scroll > tocHeight) {
              $tocWidget.addClass('toc-fixed');
          } else {
              $tocWidget.removeClass('toc-fixed');
          }
      });

      
      /* 修复文章卡片 div 的宽度. */
      let fixPostCardWidth = function (srcId, targetId) {
          let srcDiv = $('#' + srcId);
          if (srcDiv.length === 0) {
              return;
          }

          let w = srcDiv.width();
          if (w >= 450) {
              w = w + 21;
          } else if (w >= 350 && w < 450) {
              w = w + 18;
          } else if (w >= 300 && w < 350) {
              w = w + 16;
          } else {
              w = w + 14;
          }
          $('#' + targetId).width(w);
      };

      // 切换TOC目录展开收缩的相关操作.
      const expandedClass = 'expanded';
      let $tocAside = $('#toc-aside');
      let $mainContent = $('#main-content');
      $('#floating-toc-btn .btn-floating').click(function () {
          if ($tocAside.hasClass(expandedClass)) {
              $tocAside.removeClass(expandedClass).hide();
              $mainContent.removeClass('l9');
          } else {
              $tocAside.addClass(expandedClass).show();
              $mainContent.addClass('l9');
          }
          fixPostCardWidth('artDetail', 'prenext-posts');
      });
      
  });
</script>

    

</main>




    <footer class="page-footer bg-color">
   <link rel="stylesheet" href="/libs/aplayer/APlayer.min.css">
<style>
    .aplayer .aplayer-lrc p {
        
        font-size: 12px;
        font-weight: 700;
        line-height: 16px !important;
    }

    .aplayer .aplayer-lrc p.aplayer-lrc-current {
        
        font-size: 15px;
        color: #a3ddf0;
        /* color: #59cde9; */
    }

    
    .aplayer.aplayer-fixed.aplayer-narrow .aplayer-body {
        left: -66px !important;
    }

    .aplayer.aplayer-fixed.aplayer-narrow .aplayer-body:hover {
        left: 0px !important;
    }

    
</style>
<div class="">
    
    <div class="row">
        <meting-js class="col l8 offset-l2 m10 offset-m1 s12"
                   server="netease"
                   type="playlist"
                   id="2450546498"
                   fixed='true'
                   autoplay='false'
                   theme='#59cde9'
                   loop='all'
                   order='random'
                   preload='auto'
                   volume='0.7'
                   list-folded='true'
        >
        </meting-js>
    </div>
</div>

<script src="/libs/aplayer/APlayer.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/meting@2/dist/Meting.min.js"></script>
 
  <div
    class="container row center-align"
    style="margin-bottom: 15px !important;"
  >
    <div class="col s12 m8 l8 copy-right">
      Copyright&nbsp;&copy; 
      <span id="year"
        >2023-2024</span
      >
      
      <span id="year">2023</span>
      <a href="/about" target="_blank"
        >hermia</a
      >
      |&nbsp;Powered by&nbsp;<a href="https://hexo.io/" target="_blank">Hexo</a>
      |&nbsp;Theme&nbsp;<a
        href="https://github.com/blinkfox/hexo-theme-matery"
        target="_blank"
        >Matery</a
      >
      <br />
           
      <span id="busuanzi_container_site_pv">
        |&nbsp;<i class="far fa-eye"></i>&nbsp;总访问量:&nbsp;<span
          id="busuanzi_value_site_pv"
          class="white-color"
        ></span
        >&nbsp;次
      </span>
       
      <span id="busuanzi_container_site_uv">
        |&nbsp;<i class="fas fa-users"></i>&nbsp;总访问人数:&nbsp;<span
          id="busuanzi_value_site_uv"
          class="white-color"
        ></span
        >&nbsp;人
      </span>
      
      <br />
      
      <span id="sitetime">载入运行时间...</span>
      <script>
        function siteTime() {
          var seconds = 1000;
          var minutes = seconds * 60;
          var hours = minutes * 60;
          var days = hours * 24;
          var years = days * 365;
          var today = new Date();
          var startYear = "2023";
          var startMonth = "11";
          var startDate = "14";
          var startHour = "0";
          var startMinute = "0";
          var startSecond = "0";
          var todayYear = today.getFullYear();
          var todayMonth = today.getMonth() + 1;
          var todayDate = today.getDate();
          var todayHour = today.getHours();
          var todayMinute = today.getMinutes();
          var todaySecond = today.getSeconds();
          var t1 = Date.UTC(
            startYear,
            startMonth,
            startDate,
            startHour,
            startMinute,
            startSecond
          );
          var t2 = Date.UTC(
            todayYear,
            todayMonth,
            todayDate,
            todayHour,
            todayMinute,
            todaySecond
          );
          var diff = t2 - t1;
          var diffYears = Math.floor(diff / years);
          var diffDays = Math.floor(diff / days - diffYears * 365);
          var diffHours = Math.floor(
            (diff - (diffYears * 365 + diffDays) * days) / hours
          );
          var diffMinutes = Math.floor(
            (diff - (diffYears * 365 + diffDays) * days - diffHours * hours) /
              minutes
          );
          var diffSeconds = Math.floor(
            (diff -
              (diffYears * 365 + diffDays) * days -
              diffHours * hours -
              diffMinutes * minutes) /
              seconds
          );
          if (startYear == todayYear) {
            document.getElementById("year").innerHTML = todayYear;
            document.getElementById("sitetime").innerHTML =
              "本站已安全运行 " +
              diffDays +
              " 天 " +
              diffHours +
              " 小时 " +
              diffMinutes +
              " 分钟 " +
              diffSeconds +
              " 秒";
          } else {
            document.getElementById("year").innerHTML =
              startYear + " - " + todayYear;
            document.getElementById("sitetime").innerHTML =
              "本站已安全运行 " +
              diffYears +
              " 年 " +
              diffDays +
              " 天 " +
              diffHours +
              " 小时 " +
              diffMinutes +
              " 分钟 " +
              diffSeconds +
              " 秒";
          }
        }
        setInterval(siteTime, 1000);
      </script>
      
      <br />
      
    </div>
    <div class="col s12 m4 l4 social-link social-statis">
      
<a
  href="https://github.com/hermiablog/hermiablog.github.io"
  class="tooltipped"
  target="_blank"
  data-tooltip="访问我的GitHub"
  data-position="top"
  data-delay="50"
>
  <i class="fab fa-github"></i>
</a>
 
<a
  href="mailto:1587837237@qq.com"
  class="tooltipped"
  target="_blank"
  data-tooltip="邮件联系我"
  data-position="top"
  data-delay="50"
>
  <i class="fas fa-envelope-open"></i>
</a>
<!-- 
   
<a
  href="tencent://AddContact/?fromId=50&fromSubId=1&subcmd=all&uin=1587837237"
  class="tooltipped"
  target="_blank"
  data-tooltip="QQ联系我: 1587837237"
  data-position="top"
  data-delay="50"
>
  <i class="fab fa-qq"></i>
</a>
    -->

    </div>
  </div>
</footer>

<div class="progress-bar"></div>


    <!-- 搜索遮罩框 -->
<div id="searchModal" class="modal">
    <div class="modal-content">
        <div class="search-header">
            <span class="title"><i class="fas fa-search"></i>&nbsp;&nbsp;搜索</span>
            <input type="search" id="searchInput" name="s" placeholder="请输入搜索的关键字"
                   class="search-input">
        </div>
        <div id="searchResult"></div>
    </div>
</div>

<script type="text/javascript">
$(function () {
    var searchFunc = function (path, search_id, content_id) {
        'use strict';
        $.ajax({
            url: path,
            dataType: "xml",
            success: function (xmlResponse) {
                // get the contents from search data
                var datas = $("entry", xmlResponse).map(function () {
                    return {
                        title: $("title", this).text(),
                        content: $("content", this).text(),
                        url: $("url", this).text()
                    };
                }).get();
                var $input = document.getElementById(search_id);
                var $resultContent = document.getElementById(content_id);
                $input.addEventListener('input', function () {
                    var str = '<ul class=\"search-result-list\">';
                    var keywords = this.value.trim().toLowerCase().split(/[\s\-]+/);
                    $resultContent.innerHTML = "";
                    if (this.value.trim().length <= 0) {
                        return;
                    }
                    // perform local searching
                    datas.forEach(function (data) {
                        var isMatch = true;
                        var data_title = data.title.trim().toLowerCase();
                        var data_content = data.content.trim().replace(/<[^>]+>/g, "").toLowerCase();
                        var data_url = data.url;
                        data_url = data_url.indexOf('/') === 0 ? data.url : '/' + data_url;
                        var index_title = -1;
                        var index_content = -1;
                        var first_occur = -1;
                        // only match artiles with not empty titles and contents
                        if (data_title !== '' && data_content !== '') {
                            keywords.forEach(function (keyword, i) {
                                index_title = data_title.indexOf(keyword);
                                index_content = data_content.indexOf(keyword);
                                if (index_title < 0 && index_content < 0) {
                                    isMatch = false;
                                } else {
                                    if (index_content < 0) {
                                        index_content = 0;
                                    }
                                    if (i === 0) {
                                        first_occur = index_content;
                                    }
                                }
                            });
                        }
                        // show search results
                        if (isMatch) {
                            str += "<li><a href='" + data_url + "' class='search-result-title'>" + data_title + "</a>";
                            var content = data.content.trim().replace(/<[^>]+>/g, "");
                            if (first_occur >= 0) {
                                // cut out 100 characters
                                var start = first_occur - 20;
                                var end = first_occur + 80;
                                if (start < 0) {
                                    start = 0;
                                }
                                if (start === 0) {
                                    end = 100;
                                }
                                if (end > content.length) {
                                    end = content.length;
                                }
                                var match_content = content.substr(start, end);
                                // highlight all keywords
                                keywords.forEach(function (keyword) {
                                    var regS = new RegExp(keyword, "gi");
                                    match_content = match_content.replace(regS, "<em class=\"search-keyword\">" + keyword + "</em>");
                                });

                                str += "<p class=\"search-result\">" + match_content + "...</p>"
                            }
                            str += "</li>";
                        }
                    });
                    str += "</ul>";
                    $resultContent.innerHTML = str;
                });
            }
        });
    };

    searchFunc('/search.xml', 'searchInput', 'searchResult');
});
</script>

    <!-- 回到顶部按钮 -->
<div id="backTop" class="top-scroll">
    <a class="btn-floating btn-large waves-effect waves-light" href="#!">
        <i class="fas fa-arrow-up"></i>
    </a>
</div>


    <script src="/libs/materialize/materialize.min.js"></script>
    <script src="/libs/masonry/masonry.pkgd.min.js"></script>
    <script src="/libs/aos/aos.js"></script>
    <script src="/libs/scrollprogress/scrollProgress.min.js"></script>
    <script src="/libs/lightGallery/js/lightgallery-all.min.js"></script>
    <script src="/js/matery.js"></script>

    <!-- Baidu Analytics -->

    <!-- Baidu Push -->

<script>
    (function () {
        var bp = document.createElement('script');
        var curProtocol = window.location.protocol.split(':')[0];
        if (curProtocol === 'https') {
            bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';
        } else {
            bp.src = 'http://push.zhanzhang.baidu.com/push.js';
        }
        var s = document.getElementsByTagName("script")[0];
        s.parentNode.insertBefore(bp, s);
    })();
</script>

    
    <script src="/libs/others/clicklove.js" async="async"></script>
    
    
    <script async src="/libs/others/busuanzi.pure.mini.js"></script>
    

    

    

	
    

    

    

    
    <script src="/libs/instantpage/instantpage.js" type="module"></script>
    

</body>

</html>
