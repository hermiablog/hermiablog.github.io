<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>原生组件开发（一）</title>
      <link href="/2024/01/30/%E5%8E%9F%E7%94%9F%E7%BB%84%E4%BB%B6%E5%BC%80%E5%8F%91%EF%BC%88%E4%B8%80%EF%BC%89/"/>
      <url>/2024/01/30/%E5%8E%9F%E7%94%9F%E7%BB%84%E4%BB%B6%E5%BC%80%E5%8F%91%EF%BC%88%E4%B8%80%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<span id="more"></span><h2 id="todos组件"><a href="#todos组件" class="headerlink" title="todos组件"></a>todos组件</h2><h3 id="项目介绍"><a href="#项目介绍" class="headerlink" title="项目介绍"></a>项目介绍</h3><blockquote><p>项目功能</p></blockquote><ul><li>输入添加todos</li><li>可以单项删除</li><li>可以编辑每一项todos</li><li>选中后，文字出现删除线</li><li>可以全选或取消全选所有todos</li><li>具有统计功能，统计当前已完成和全部todos项</li><li>具有筛选功能，可以筛选未完成、已完成、全部</li><li>可以批量删除已完成事件</li></ul><blockquote><p>项目涉及核心知识点</p></blockquote><table><thead><tr><th>知识点分类</th><th>…</th></tr></thead><tbody><tr><td>Vue基础</td><td>插值语法、列表渲染、v-bind指令、表单元素绑定、事件绑定、样式绑定、事件修饰符、计算属性、methods方法</td></tr><tr><td>组件间通信</td><td>props、组件事件、组件v-model、依赖注入</td></tr><tr><td>原生JS基础</td><td>本地数据持久化：localStorage本地存储、JSON.parse、JSON.stringify、数组相关API：filter、find、findIndex、splice、unshift、reduce</td></tr></tbody></table><blockquote><p>交互效果</p></blockquote><ul><li>输入框获取焦点和失去焦点后的样式</li><li>当鼠标滑动到每一项Todos时，在当前项最后面显示删除按钮</li><li>双击每一项，会变成单行文本输入框，可以输入内容，同时todos和删除按钮隐藏</li><li>复选框的选中和未选中状态</li><li>点击不同的筛选按钮，显示不同数据，并且该按钮样式改变</li></ul><blockquote><p>实现步骤</p></blockquote><ul><li>实现UI静态布局–&gt;拆分组件–&gt;根据功能点逐个击破<img src="todos-ui图.png"></li></ul><h3 id="功能点"><a href="#功能点" class="headerlink" title="功能点"></a>功能点</h3><h4 id="渲染todos数据"><a href="#渲染todos数据" class="headerlink" title="渲染todos数据"></a>渲染todos数据</h4><blockquote><p>父组件向子组件传值<br><strong>思路</strong></p></blockquote><ul><li>todos数据应该是由App组件传给子组件TodoList进行列表循环</li><li>TodoList再把对应数据传给TodoItem组件进行渲染<br><strong>注意点</strong></li><li>TodoList在进行列表循环时，需要给todoItem组件传入数据</li><li>因为每个事件都是一个对象，因此，采用不带参数的<code>v-bind</code>进行传入，todoItem组件在接收时，直接用对象里的属性名接收</li></ul><pre><code>props: [&quot;title&quot;, &quot;id&quot;, &quot;complected&quot;],</code></pre><blockquote><p>孙组件修改祖先组件的值</p></blockquote><ul><li>App组件提供一个方法，根据其他组件传过来的id来修改对应的事件的完成状态；<ul><li>使用<code>find()</code>方法来查找满足条件的事件</li></ul></li><li>需要修改时间状态的组件，注入依赖，并绑定注入的方法，传入对应id</li></ul><h4 id="添加todo"><a href="#添加todo" class="headerlink" title="添加todo"></a>添加todo</h4><blockquote><p>子组件向父组件传值：<code>emit</code>事件</p></blockquote><ul><li>父组件定义添加todo的方法</li><li>子组件中：<ul><li>在键盘抬起并按下回车键时触发<code>emit</code>事件 </li><li>获取输入框中的值，当<code>value</code>不为空时，再进行下一步</li><li>定义一个对象，将<code>value</code>作为title，再加上id、completed属性</li><li>将该对象传入<code>emit</code>事件</li><li>清除输入框中的内容</li></ul></li></ul><h4 id="单项删除"><a href="#单项删除" class="headerlink" title="单项删除"></a>单项删除</h4><blockquote><p>孙组件<code>todoItem</code>修改祖先组件的值</p></blockquote><ul><li>使用依赖与注入</li><li>App组件提供方法，根据孙组件提供的id来修改todos，删除对应事件</li><li>使用<code>findIndex()</code>方法，找到对应事件的下标</li><li>使用<code>splice()</code>方法，删除事件</li></ul><h4 id="编辑每一项todo"><a href="#编辑每一项todo" class="headerlink" title="编辑每一项todo"></a>编辑每一项todo</h4><ul><li>定义变量<code>modifyId</code>，双击事件名部分后，把<code>modifyId</code>修改成对应的id，当id等于<code>modifyId</code>时，显示对应id的输入框，隐藏事件内容</li><li>编辑后要修改祖先组件的数据：使用依赖与注入</li><li>App组件定义修改todo的方法，孙组件注入该方法</li><li>当键盘抬起并按下回车键后<ul><li>获取输入的值</li><li>如果输入框有值，就调用该方法，并传入id和输入的值；没有的话就什么都不做</li><li>修改<code>modifyId</code>，以隐藏输入框</li></ul></li></ul><h3 id="全选或取消全选"><a href="#全选或取消全选" class="headerlink" title="全选或取消全选"></a>全选或取消全选</h3><ul><li>单个选中后全选：<ul><li>使用计算属性<code>selectState</code>，监测<code>todos</code>属性的变化；当事件的状态改变后，计算属性也会重新计算</li><li><code>selectState</code>的值根据<code>todos</code>的完成状态得到，当所有事件都完成时，<code>selectState</code>才会等于true</li><li>使用<code>reduce()</code>方法</li></ul></li><li>点击全选按钮选中：子组件修改父组件的数据用<code>emit</code><ul><li>全选按钮的状态由<code>selectState</code>决定</li><li>App定义自定义事件，接收子组件传来的状态值<code>selectState</code>，当它为<code>true</code>时，就将所有事件的状态改为<code>false</code>(注意是相反的，已经是true，再次点击时就是不选中)</li></ul></li></ul><h3 id="筛选功能"><a href="#筛选功能" class="headerlink" title="筛选功能"></a>筛选功能</h3><ul><li>定义一个变量<code>filterIndex</code>表示筛选条件</li><li>使用计算属性<code>filterTodos</code>来根据<code>filterIndex</code>筛选todos事件</li><li>父组件定义一个事件来接收<code>TodoFooter</code>组件传来的值，修改筛选条件</li><li>子组件中，点击不同按钮，给父组件传递不同的值</li></ul><h3 id="批量删除已完成的事件"><a href="#批量删除已完成的事件" class="headerlink" title="批量删除已完成的事件"></a>批量删除已完成的事件</h3><ul><li>父组件定义一个事件，当子组件点击删除按钮时，将<code>todos</code>数据进行修改，删除所有已完成项</li></ul><h3 id="组件内部操作"><a href="#组件内部操作" class="headerlink" title="组件内部操作"></a>组件内部操作</h3><h4 id="TodoHeader组件"><a href="#TodoHeader组件" class="headerlink" title="TodoHeader组件"></a>TodoHeader组件</h4><blockquote><p>输入框的样式</p></blockquote><ul><li>定义一个变量<code>active</code></li><li>动态绑定class样式，当active为true时，显示样式</li><li>绑定<code>focus</code>和<code>blur</code>事件，并分别修改active的样式</li></ul><h4 id="TodoItem组件"><a href="#TodoItem组件" class="headerlink" title="TodoItem组件"></a>TodoItem组件</h4><blockquote><p>删除按钮</p></blockquote><ul><li>滑动到对应位置才显示</li></ul><blockquote><p>输入框样式</p></blockquote><ul><li>绑定<code>focus</code>事件，当active为true时，显示样式</li><li>绑定<code>blur</code>事件，当失去焦点时，将<code>modifyId</code>的值重置，隐藏输入框</li></ul><h4 id="TodoFooter组件"><a href="#TodoFooter组件" class="headerlink" title="TodoFooter组件"></a>TodoFooter组件</h4><blockquote><p>统计当前已完成和全部todos项</p></blockquote><ul><li>全部数量即数据长度</li><li>已完成数：使用<code>reduce()</code>方法</li></ul><blockquote><p>按钮点击后，样式需要改变</p></blockquote><ul><li>按钮的emit事件触发后，需要传入对应的分类号</li><li>定义一个变量<code>clickIndex</code>保存当前点击的按钮的分类号</li><li>在点击触发emit事件后，将<code>clickIndex</code>修改为当前按钮的分类号</li><li>当<code>clickIndex</code>等于自己的分类号时，点击样式生效</li></ul><h3 id="本地存储"><a href="#本地存储" class="headerlink" title="本地存储"></a>本地存储</h3><blockquote><p>使用侦听器的方式，侦听todos的变化，在每次变化后，将新的值保存到<code>localStorage</code>中</p></blockquote><ul><li>初始化时，从本地存储中取数据(一定要解析JSON字符串)：</li></ul><pre><code>todos: JSON.parse(window.localStorage.getItem(&quot;todos&quot;)) || [],</code></pre><ul><li>侦听器，侦听todos的变化(一定要序列化)：</li></ul><pre><code>watch: &#123;    todos: &#123;      handler(todos) &#123;        window.localStorage.setItem(&quot;todos&quot;, JSON.stringify(todos));      &#125;,      deep: true,    &#125;,  &#125;,</code></pre><h2 id="带历史记录的搜索"><a href="#带历史记录的搜索" class="headerlink" title="带历史记录的搜索"></a>带历史记录的搜索</h2><h3 id="项目介绍-1"><a href="#项目介绍-1" class="headerlink" title="项目介绍"></a>项目介绍</h3><blockquote><p>功能点</p></blockquote><ul><li>在搜索框输入内容，并按回车键<ul><li>输入框中的内容添加到<strong>搜索历史</strong>列表中</li><li>根据关键词搜索对应的课程，并将<strong>搜索结果</strong>呈现在页面中</li></ul></li><li>点击搜索框右则的<strong>取消</strong>按扭，可以取消输入框中的的内容</li><li>点击<strong>搜索历史列表中的关键字</strong>，可以触发搜索功能，将搜索的结果以列表形式呈现在页面中</li><li>点击搜索历史列表右则的<strong>删除</strong>按扭，可以清空搜索历史列表</li></ul><blockquote><p>项目涉及核心知识点</p><ul><li>该项目所涉及知识点较多，主要有：</li></ul></blockquote><table><thead><tr><th>知识点分类</th><th>涉及内容</th></tr></thead><tbody><tr><td>Vue 基础（组合式）</td><td>插值语法、列表渲染、v-bind 指令、表单元素绑定、事件绑定、样式绑定、事件修饰符、watchEffect 侦听器、响应式 API-reactive</td></tr><tr><td>组件间通信</td><td>defineProps、defineEmits、组件 v-model</td></tr><tr><td>原生 JS 基础</td><td>本地数据持久化：localStorage 本地存储、JSON.parse、JSON.stringify；数组相关 API：unshift</td></tr><tr><td>网络请求</td><td>axios</td></tr></tbody></table><blockquote><p>实现步骤</p></blockquote><ul><li>实现UI静态布局–&gt;拆分组件–&gt;根据功能点逐个击破<img src="带历史记录的搜索UI图.png"></li></ul><h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3><blockquote><p>核心数据</p><ul><li>为了实现响应式，需要使用<code>reactive</code>方法</li><li>将核心数据都存入<code>state</code>变量中</li></ul></blockquote><ul><li><code>url</code>：保存接口地址</li><li><code>searchList</code>：保存搜索结果</li><li><code>historyList</code>：保存搜索记录</li></ul><pre><code>const state = reactive(&#123;  text: &quot;&quot;, //搜索框的值  url: &quot;https://www.fastmock.site/mock/804fcae2e74bf1139d47b1fd79c3bbaa/vue/search&quot;,  historyList: [    //模拟数据    &#123;      id: Date.now(),      keyword: &quot;前端&quot;,    &#125;,  ],  searchList: [],&#125;);</code></pre><ul><li>定义获取数据的方法：使用axios</li></ul><pre><code>import axios from &quot;axios&quot;;//定义一个方法 发起axios请求 获取数据async function getSearchList(keyword) &#123;  const res = await axios.get(`$&#123;state.url&#125;?keyword=$&#123;keyword&#125;`);  //如果成功获取数据  if (res) &#123;    //如果获取的是空数据，就为空数组    state.searchList = res.data.data || [];  &#125;&#125;</code></pre><h4 id="SearchInput组件"><a href="#SearchInput组件" class="headerlink" title="SearchInput组件"></a>SearchInput组件</h4><blockquote><p>需要实现的功能</p></blockquote><ul><li>在搜索框输入关键词，按下回车键后<ul><li>根据关键词发送axios请求，获取数据，存入<code>searchList</code>中</li><li>同时搜索框的值存入父组件的<code>historyList</code>中</li></ul></li></ul><blockquote><p>功能实现</p></blockquote><ol><li>实现App组件与输入框的双向数据绑定</li></ol><ul><li>通过<code>v-model</code>将父组件的<code>state.text</code>传入子组件</li><li>子组件接收<code>modelValue</code>属性和<code>update:modelValue</code>方法，并绑定在<code>input</code>标签上</li><li>当<code>input</code>事件发生时，触发<code>update:modelValue</code>方法，并将输入框中的值传入</li></ul><ol start="2"><li>输入框回车时，修改父组件的<code>state.historyList</code>数据</li></ol><ul><li>子向父传值，需要使用自定义事件；在父组件中定义事件名和事件处理函数，input标签在回车时触发事件，并将输入框中的值传入</li><li>父组件的事件处理函数：接收子组件传来的值<ul><li>如果值不为空，就调用<code>getSearchList</code>方法</li><li>添加进历史记录：前提是不能传入相同的值</li></ul></li></ul><ol start="3"><li>点击取消按钮删除输入框中的内容</li></ol><ul><li>在父组件中定义一个方法</li><li>绑定在子组件的取消按钮上</li></ul><blockquote><p>props</p></blockquote><table><thead><tr><th>属性名</th><th>说明</th><th>类型</th><th>默认值</th></tr></thead><tbody><tr><td>placehoder</td><td>输入框中的占位提示文字</td><td>string</td><td>-</td></tr><tr><td>action-text</td><td>输入框右侧的取消文字</td><td>string</td><td>取消</td></tr><tr><td>modelValue(state.text)</td><td>输入框的值，通过v-model实现双向绑定</td><td>string</td><td>“”</td></tr></tbody></table><blockquote><p>Events事件</p></blockquote><table><thead><tr><th>事件名</th><th>说明</th><th>参数</th></tr></thead><tbody><tr><td>search</td><td>在回车后调用自定义事件</td><td>e.target.value</td></tr><tr><td>update:modelValue</td><td>将输入框中的值传给父组件</td><td>$event.target.value</td></tr></tbody></table><blockquote><p>slot插槽</p></blockquote><table><thead><tr><th>名称</th><th>说明</th></tr></thead><tbody><tr><td>location</td><td>输入框左侧的内容</td></tr></tbody></table><h4 id="SearchHistory插件与Badge插件"><a href="#SearchHistory插件与Badge插件" class="headerlink" title="SearchHistory插件与Badge插件"></a>SearchHistory插件与Badge插件</h4><blockquote><p>核心数据传递</p></blockquote><ul><li>App组件将历史数据<code>state.historyList</code>传给<code>SearchHistory</code>组件</li><li><code>SearchHistory</code>组件，使用<code>v-for</code>列表渲染<code>state.historyList</code>，然后将<code>item</code>传给<code>Badge</code>组件</li><li><code>Badge</code>组件再将接收的数据渲染到页面</li></ul><blockquote><p>功能</p></blockquote><ul><li>孙组件修改祖先组件的数据，利用依赖与注入</li></ul><ol><li>点击删除键，根据id删除对应的历史记录</li></ol><ul><li>在App组件中定义一个方法，当接收到子孙组件传来的id后，将id与<code>searchHistory</code>中的数据比较，删除id相同的项</li></ul><ol start="2"><li>点击历史记录，可以进行搜索</li></ol><ul><li>在App组件中将发起请求的getSearchList方法提供出去</li></ul><ol start="3"><li>点击删除图标，删除App组件中的历史数据</li></ol><blockquote><p>props</p></blockquote><table><thead><tr><th>属性名</th><th>说明</th><th>类型</th><th>默认值</th></tr></thead><tbody><tr><td>historyList</td><td>历史搜索记录</td><td>Array</td><td>-</td></tr></tbody></table><blockquote><p>Events事件</p></blockquote><table><thead><tr><th>事件名</th><th>说明</th></tr></thead><tbody><tr><td>delAllHistory</td><td>删除所有历史数据</td></tr></tbody></table><h4 id="SearchList组件"><a href="#SearchList组件" class="headerlink" title="SearchList组件"></a>SearchList组件</h4><ul><li>App将搜索结果传给<code>SearchList</code>组件</li><li><code>SearchList</code>组件接收数据后，进行渲染</li></ul><h4 id="本地存储-1"><a href="#本地存储-1" class="headerlink" title="本地存储"></a>本地存储</h4><blockquote><p>使用侦听器的方式，侦听todos的变化，在每次变化后，将新的值保存到<code>localStorage</code>中</p></blockquote><ul><li>初始化时，从本地存储中取数据(一定要解析JSON字符串)：</li></ul><pre><code>history: JSON.parse(window.localStorage.getItem(&quot;history&quot;)) || [],</code></pre><ul><li>侦听器，侦听todos的变化(一定要序列化)：</li></ul><pre><code>watchEffect(() =&gt; &#123;  localStorage.setItem(&quot;history&quot;, JSON.stringify(state.historyList));&#125;);</code></pre><h2 id="无线下拉菜单"><a href="#无线下拉菜单" class="headerlink" title="无线下拉菜单"></a>无线下拉菜单</h2><h3 id="项目介绍-2"><a href="#项目介绍-2" class="headerlink" title="项目介绍"></a>项目介绍</h3><h4 id="项目功能"><a href="#项目功能" class="headerlink" title="项目功能"></a>项目功能</h4><blockquote><p>该项目所需要实现的功能如下：</p></blockquote><ul><li>无论菜单有多少级，都能够递归渲染出来。</li><li>当鼠标滑动到对应的菜单上时，才会显示对应菜单的下级菜单。</li><li>针对有下级菜单的菜单不能点击跳转，针对没有下级菜单的菜单可以点击跳转</li></ul><h4 id="项目涉及核心知识点"><a href="#项目涉及核心知识点" class="headerlink" title="项目涉及核心知识点"></a>项目涉及核心知识点</h4><blockquote><p>该项目涉及知识点主要有：</p></blockquote><table><thead><tr><th>知识分类</th><th>涉及内容</th></tr></thead><tbody><tr><td>Vue 基础（组合式）</td><td>插值语法、列表渲染、v-bind 指令、响应式 API-reactive</td></tr><tr><td>组件间通信</td><td>defineProps、slot 插槽</td></tr><tr><td>其它知识</td><td>递归组件</td></tr></tbody></table><h4 id="学习目标"><a href="#学习目标" class="headerlink" title="学习目标"></a>学习目标</h4><ul><li>组件拆分：一个完整的项目，应该如何进行组件化拆分</li><li>项目开发流程：如何一步步完成项目的开发，先做什么后做什么</li><li>递归组件：如何实现递归一个组件自身</li><li>render 渲染函数：掌握渲染函数何递归组件。</li></ul><h4 id="项目开发流程"><a href="#项目开发流程" class="headerlink" title="项目开发流程"></a>项目开发流程</h4><p>分析 UI 图 –&gt; 实现 UI 静态布局 –&gt; 拆分组件 –&gt; 确定数据源 –&gt; 渲染一级 与 二级菜单 –&gt; 渲染无限级菜单</p><blockquote><p>分析 UI 图</p></blockquote><ul><li>首先我们需要通过 UI 图，分析当前项目可以拆分成哪些组件，当前项目可以拆分成以下 3 个组件（未包含当前应用的 APP 组件）<img src="无线下拉菜单UI图.png"></li></ul><table><thead><tr><th>组件</th><th>功能</th></tr></thead><tbody><tr><td>MenuItem</td><td>单个菜单项</td></tr><tr><td>SubMenu</td><td>二级菜单（二级菜单子菜单调用<MenuItem>）</td></tr><tr><td>ReSubMenu</td><td>递归组件，用来递归自身。该组件内部调用<SubMenu>组件</td></tr></tbody></table><blockquote><p>实现 UI 静态布局<br>根据 UI 图，利用HTML + CSS实现静态布局，同时要把所有的交互效果用到的 CSS 样式也要写好。并且要清楚的知道每一个交互背后的实现逻辑。</p><ul><li>本案例中涉及到如下几个交互效果</li></ul></blockquote><ul><li>鼠标滑动到对应的菜单项，菜单项的背景变黄色</li><li>当鼠标滑动到对应菜单项的子项时，对应菜单项和子项的背景都变黄色</li><li>当鼠标滑动到对应的菜单项时，如果有子级，显示对应的子菜单项</li></ul><blockquote><p>确定数据源<br>整个应用中最核心的数据就是菜单列表，以下数据为模拟的菜单列表数据，定义在 <code>src/data/menu.js</code> 文件中</p></blockquote><pre><code>export default [  &#123;    id: 1,    title: &quot;菜单一&quot;,    href: &quot;http://www.xxx11.com&quot;,  &#125;,  &#123;    id: 2,    title: &quot;菜单二&quot;,    children: [      &#123;        id: 21,        title: &quot;菜单二-21&quot;,        children: [          &#123;            id: 211,            title: &quot;菜单21-1&quot;,            href: &quot;http://www.xxx211.com&quot;,          &#125;,          &#123;            id: 212,            title: &quot;菜单21-2&quot;,            children: [              &#123;                id: 2121,                title: &quot;菜单21-2-1&quot;,                href: &quot;http://www.xxx2121.com&quot;,              &#125;,            ],          &#125;,          &#123;            id: 213,            title: &quot;菜单21-3&quot;,            href: &quot;http://www.xxx213.com&quot;,          &#125;,        ],      &#125;,      &#123;        id: 22,        title: &quot;菜单二-22&quot;,        href: &quot;http://www.xxx22.com&quot;,      &#125;,      &#123;        id: 23,        title: &quot;菜单二-23&quot;,        href: &quot;http://www.xxx23.com&quot;,      &#125;,    ],  &#125;,  &#123;    id: 3,    title: &quot;菜单三&quot;,    href: &quot;http://www.xxx3.com&quot;,  &#125;,  &#123;    id: 4,    title: &quot;菜单四&quot;,    href: &quot;http://www.xxx4.com&quot;,  &#125;,];</code></pre><h3 id="实现-1"><a href="#实现-1" class="headerlink" title="实现"></a>实现</h3><blockquote><p>步骤</p></blockquote><ul><li>先拆成两个组件<ul><li>渲染一二级菜单</li><li>渲染多级菜单，在SubMenu组件进行递归</li><li>使用rend函数渲染SubMenu组件</li></ul></li><li>拆成三个组件<ul><li>SubMenu组件只进行二级渲染</li></ul></li></ul><h4 id="拆分组件——App、MenuItem、SubMenu"><a href="#拆分组件——App、MenuItem、SubMenu" class="headerlink" title="拆分组件——App、MenuItem、SubMenu"></a>拆分组件——App、MenuItem、SubMenu</h4><ul><li>App 根组件</li></ul><pre><code>&lt;script setup&gt;  import MenuItem from &quot;./components/MenuItem.vue&quot;;  import SubMenu from &quot;./components/SubMenu.vue&quot;;&lt;/script&gt;&lt;template&gt;  &lt;div class=&quot;menu&quot;&gt;    &lt;!--menu-item start--&gt;    &lt;Menuitem&gt; &lt;/Menuitem&gt;    &lt;!--menu-item end--&gt;    &lt;!--sub-menu start--&gt;    &lt;SubMenu&gt;&lt;/SubMenu&gt;    &lt;!--sub-menu end--&gt;  &lt;/div&gt;&lt;/template&gt;&lt;style scoped&gt;  .menu &#123;    width: 200px;    margin: 150px;  &#125;&lt;/style&gt;</code></pre><ul><li>MenuItem 组件</li></ul><pre><code>&lt;template&gt;  &lt;div class=&quot;menu-item&quot;&gt;    &lt;a href=&quot;#&quot;&gt;菜单一&lt;/a&gt;  &lt;/div&gt;&lt;/template&gt;&lt;style scoped&gt;  /* menu-item start */  .menu-item &#123;    width: 100%;  &#125;  .menu-item a &#123;    display: block;    line-height: 35px;    text-indent: 2em;    background-color: skyblue;    color: #fff;    text-decoration: none;  &#125;  .menu-item a:hover &#123;    background-color: khaki;  &#125;&lt;/style&gt;</code></pre><ul><li>SubMenu 组件</li></ul><pre><code>&lt;script setup&gt;  import MenuItem from &quot;./MenuItem.vue&quot;;&lt;/script&gt;&lt;template&gt;  &lt;div class=&quot;sub-menu&quot;&gt;    &lt;div class=&quot;title&quot;&gt;      菜单二      &lt;span&gt;&amp;gt;&lt;/span&gt;    &lt;/div&gt;    &lt;div class=&quot;sub-item&quot;&gt;      &lt;Menuitem&gt; 菜单二-21&lt;/Menuitem&gt;      &lt;Menuitem&gt; 菜单二-22&lt;/Menuitem&gt;      &lt;Menuitem&gt; 菜单二-23&lt;/Menuitem&gt;    &lt;/div&gt;  &lt;/div&gt;&lt;/template&gt;&lt;style scoped&gt;  /* sub-menu start */  .sub-menu &#123;    height: 35px;    position: relative;  &#125;  .sub-menu:hover &gt; .title &#123;    background-color: khaki;  &#125;  .sub-menu:hover &gt; .sub-item &#123;    display: block;  &#125;  .sub-menu .title &#123;    height: 35px;    align-items: center;    display: flex;    justify-content: space-between;    text-indent: 2em;    background-color: skyblue;    color: #fff;  &#125;  .sub-menu:hover .title &#123;    background-color: khaki;  &#125;  .sub-menu .title span &#123;    margin-right: 10px;  &#125;  .sub-menu .sub-item &#123;    width: 100%;    position: absolute;    left: 100%;    top: 0;    display: none;  &#125;&lt;/style&gt;</code></pre><h5 id="渲染一二级菜单"><a href="#渲染一二级菜单" class="headerlink" title="渲染一二级菜单"></a>渲染一二级菜单</h5><blockquote><p>我们先只考虑 1 级到二级菜单内容的渲染，然后再考虑递归组件渲染无限级菜单</p><p>在数据渲染时，我们希望菜单的内容由用户通过插槽来传入，这样用户就可以根据自己的需求来定义菜单的样式</p></blockquote><ul><li>MenuItem组件模板内容调整如下</li></ul><pre><code>&lt;script setup&gt;  defineProps([&quot;href&quot;]);&lt;/script&gt;&lt;template&gt;  &lt;div class=&quot;menu-item&quot;&gt;    &lt;a :href=&quot;href&quot;&gt;      &lt;slot&gt;&lt;/slot&gt;    &lt;/a&gt;  &lt;/div&gt;&lt;/template&gt;</code></pre><ul><li>App组件中将菜单数据渲染成列表</li></ul><pre><code>&lt;script setup&gt;  import MenuItem from &quot;./components/MenuItem.vue&quot;;  import SubMenu from &quot;./components/SubMenu.vue&quot;;  import menuList from &quot;./data/menu.js&quot;;&lt;/script&gt;&lt;template&gt;  &lt;div class=&quot;menu&quot;&gt;    &lt;template v-for=&quot;item in menuList&quot;&gt;      &lt;!--没有子菜单，就渲染一级--&gt;      &lt;menuitem v-if=&quot;!item.children&quot; :key=&quot;item.id&quot; :href=&quot;item.href&quot;&gt;        &#123;&#123; item.title &#125;&#125;      &lt;/menuitem&gt;      &lt;!--有子菜单，就渲染二级--&gt;      &lt;SubMenu v-else :data=&quot;item&quot;&gt;&lt;/SubMenu&gt;    &lt;/template&gt;  &lt;/div&gt;&lt;/template&gt;</code></pre><ul><li>SubMenu组件对接受的 data 数据进行渲染</li></ul><pre><code>&lt;script setup&gt;  import MenuItem from &quot;./MenuItem.vue&quot;;  defineProps([&quot;data&quot;]);&lt;/script&gt;&lt;template&gt;  &lt;div class=&quot;sub-menu&quot;&gt;    &lt;div class=&quot;title&quot;&gt;      &#123;&#123; data.title &#125;&#125;      &lt;span&gt;&amp;gt;&lt;/span&gt;    &lt;/div&gt;    &lt;div class=&quot;sub-item&quot;&gt;      &lt;menuitem        v-for=&quot;child in data.children&quot;        :key=&quot;child.id&quot;        :href=&quot;child.href&quot;      &gt;        &#123;&#123; child.title &#125;&#125;      &lt;/menuitem&gt;    &lt;/div&gt;  &lt;/div&gt;&lt;/template&gt;</code></pre><h5 id="渲染无限级菜单"><a href="#渲染无限级菜单" class="headerlink" title="渲染无限级菜单"></a>渲染无限级菜单</h5><blockquote><p>在SubMenu使用递归</p></blockquote><pre><code>&lt;script setup&gt;import MenuItem from &quot;./MenuItem.vue&quot;;defineProps([&quot;data&quot;]);&lt;/script&gt;&lt;template&gt;  &lt;div class=&quot;sub-menu&quot;&gt;    &lt;div class=&quot;title&quot;&gt;      &#123;&#123; data.title &#125;&#125;      &lt;span class=&quot;more&quot;&gt;&gt;&lt;/span&gt;    &lt;/div&gt;    &lt;div class=&quot;sub-item&quot;&gt;      &lt;template v-for=&quot;item in data.children&quot;&gt;        &lt;MenuItem v-if=&quot;!item.children&quot; :href=&quot;item.href&quot;&gt;&#123;&#123;          item.title        &#125;&#125;&lt;/MenuItem&gt;        &lt;SubMenu v-else :data=&quot;item&quot;&gt;&lt;/SubMenu&gt;      &lt;/template&gt;    &lt;/div&gt;  &lt;/div&gt;&lt;/template&gt;</code></pre><ul><li>完整代码</li><li>App.vue</li></ul><pre><code>&lt;script setup&gt;import MenuItem from &quot;./components/MenuItem.vue&quot;;import SubMenu from &quot;./components/SubMenu.vue&quot;;import data from &quot;./data/menu&quot;;&lt;/script&gt;&lt;template&gt;  &lt;div class=&quot;menu&quot;&gt;    &lt;template v-for=&quot;item in data&quot; :key=&quot;item.id&quot;&gt;      &lt;MenuItem v-if=&quot;!item.children&quot; :href=&quot;item.href&quot;&gt;&#123;&#123;        item.title      &#125;&#125;&lt;/MenuItem&gt;      &lt;SubMenu v-else :data=&quot;item&quot;&gt;&lt;/SubMenu&gt;    &lt;/template&gt;  &lt;/div&gt;&lt;/template&gt;&lt;style&gt;a &#123;  color: #333;  text-decoration: none;&#125;&lt;/style&gt;&lt;style scoped&gt;.menu &#123;  width: 200px;  height: 35px;&#125;&lt;/style&gt;</code></pre><ul><li>MenuItem.vue</li></ul><pre><code>&lt;script setup&gt;defineProps([&quot;href&quot;]);&lt;/script&gt;&lt;template&gt;  &lt;div class=&quot;menu-item&quot;&gt;    &lt;a :href=&quot;href&quot;&gt;      &lt;slot&gt;&lt;/slot&gt;    &lt;/a&gt;  &lt;/div&gt;&lt;/template&gt;&lt;style scoped&gt;/* menu-item start */.menu-item &#123;  width: 100%;  height: 100%;&#125;.menu-item a &#123;  display: block;  width: 100%;  height: 100%;  line-height: 35px;  text-indent: 2em;  background-color: skyblue;&#125;.menu-item a:hover &#123;  background-color: khaki;&#125;&lt;/style&gt;</code></pre><ul><li>SubMenu.vue</li></ul><pre><code>&lt;script setup&gt;import MenuItem from &quot;./MenuItem.vue&quot;;defineProps([&quot;data&quot;]);&lt;/script&gt;&lt;template&gt;  &lt;div class=&quot;sub-menu&quot;&gt;    &lt;div class=&quot;title&quot;&gt;      &#123;&#123; data.title &#125;&#125;      &lt;span class=&quot;more&quot;&gt;&gt;&lt;/span&gt;    &lt;/div&gt;    &lt;div class=&quot;sub-item&quot;&gt;      &lt;template v-for=&quot;item in data.children&quot;&gt;        &lt;MenuItem v-if=&quot;!item.children&quot; :href=&quot;item.href&quot;&gt;&#123;&#123;          item.title        &#125;&#125;&lt;/MenuItem&gt;        &lt;SubMenu v-else :data=&quot;item&quot;&gt;&lt;/SubMenu&gt;      &lt;/template&gt;    &lt;/div&gt;  &lt;/div&gt;&lt;/template&gt;&lt;style scoped&gt;/* sub-menu start */.sub-menu &#123;  width: 100%;  height: 100%;  position: relative;&#125;.sub-menu .title &#123;  display: flex;  justify-content: space-between;  align-items: center;  text-indent: 2em;  width: 100%;  height: 100%;  background-color: skyblue;&#125;.title .more &#123;  margin-right: 10px;&#125;.sub-item &#123;  width: 200px;  height: 100%;  position: absolute;  left: 100%;  top: 0;  display: none;&#125;.sub-menu:hover &gt; .title &#123;  background-color: khaki;&#125;.sub-menu:hover &gt; .sub-item &#123;  display: block;&#125;&lt;/style&gt;</code></pre><h5 id="使用render函数渲染组件"><a href="#使用render函数渲染组件" class="headerlink" title="使用render函数渲染组件"></a>使用render函数渲染组件</h5><blockquote><p>涉及知识点：</p></blockquote><ul><li>渲染函数同时实现<code>v-for</code>、<code>v-if</code>指令、传递插槽内容<ul><li>v-for：使用<code>.map()</code></li><li>v-if：使用<code>if...else</code></li><li>传递插槽内容：默认插槽直接使用箭头函数，具名插槽要使用对象形式</li></ul></li><li>SubMenu.vue</li></ul><pre><code>&lt;script&gt;import &#123; h &#125; from &quot;vue&quot;;import MenuItem from &quot;./MenuItem.vue&quot;;import SubMenu from &quot;./SubMenu.vue&quot;;export default &#123;  props: [&quot;data&quot;],  setup(props) &#123;    return () =&gt;      h(&quot;div&quot;, &#123; class: &quot;sub-menu&quot; &#125;, [        h(&quot;div&quot;, &#123; class: &quot;title&quot; &#125;, [          props.data.title,          h(&quot;span&quot;, &#123; class: &quot;more&quot; &#125;, &quot;&gt;&quot;),        ]),        h(          &quot;div&quot;,          &#123; class: &quot;sub-item&quot; &#125;,          props.data.children.map((item) =&gt; &#123;            if (!item.children) &#123;              return h(MenuItem, &#123; href: item.href &#125;, () =&gt; item.title);            &#125; else &#123;              return h(SubMenu, &#123; data: item &#125;);            &#125;          &#125;)        ),      ]);  &#125;,&#125;;&lt;/script&gt;</code></pre><ul><li>App.vue</li></ul><pre><code>&lt;script&gt;import &#123; h &#125; from &quot;vue&quot;;import MenuItem from &quot;./components/MenuItem.vue&quot;;import SubMenu from &quot;./components/SubMenu.vue&quot;;import data from &quot;./data/menu&quot;;export default &#123;  setup() &#123;    return () =&gt;      h(        &quot;div&quot;,        &#123; class: &quot;menu&quot; &#125;,        data.map((item) =&gt; &#123;          if (!item.children) &#123;            return h(              MenuItem,              &#123; href: item.href, key: item.id &#125;,              () =&gt; item.title            );          &#125; else &#123;            return h(SubMenu, &#123; data: item &#125;);          &#125;        &#125;)      );  &#125;,&#125;;&lt;/script&gt;</code></pre><h4 id="拆分成三个组件"><a href="#拆分成三个组件" class="headerlink" title="拆分成三个组件"></a>拆分成三个组件</h4><ul><li><p>我们新建一个ReSubMenu组件，这个组件主要是用来递归</p></li><li><p>根据传递的数据来渲染SubMenu组件，考虑到要渲染无限菜单，后续的子菜单内容要跟在上一级菜单的后面，所以传递给SubMenu组件中的内容需要通过插槽来接受</p></li><li><p>在 App 组件中调用ReSubMenu组件，并将一级菜单的数据内容传递过来</p></li><li><p>在ReSubMenu组件中调用 SubMenu组件，利用插槽传递内容 </p><ul><li>如果没有子级，则正常显示title</li><li>如果当前菜单项有子级；在插槽中：二级使用<code>SubMenu</code>，不传递内容，三级使用递归<code>ReSubMenu</code>继续渲染；</li></ul></li><li><p>App.vue</p></li></ul><pre><code>&lt;script setup&gt;import MenuItem from &quot;./components/MenuItem.vue&quot;;import ReSubMenu from &quot;./components/ReSubMenu.vue&quot;;import data from &quot;./data/menu&quot;;&lt;/script&gt;&lt;template&gt;  &lt;div class=&quot;menu&quot;&gt;    &lt;template v-for=&quot;item in data&quot;&gt;      &lt;MenuItem v-if=&quot;!item.children&quot; :key=&quot;item.id&quot; :href=&quot;item.href&quot;&gt;&#123;&#123;        item.title      &#125;&#125;&lt;/MenuItem&gt;      &lt;ReSubMenu v-else :data=&quot;item&quot;&gt;&lt;/ReSubMenu&gt;    &lt;/template&gt;  &lt;/div&gt;&lt;/template&gt;</code></pre><ul><li>ReSubMenu.vue</li></ul><pre><code>&lt;script setup&gt;import SubMenu from &quot;./SubMenu.vue&quot;;import MenuItem from &quot;./MenuItem.vue&quot;;import ReSubMenu from &quot;./ReSubMenu.vue&quot;;defineProps([&quot;data&quot;]);&lt;/script&gt;&lt;template&gt;  &lt;SubMenu&gt;    &lt;template #title&gt;&#123;&#123; data.title &#125;&#125;&lt;/template&gt;    &lt;template #default&gt;      &lt;template v-for=&quot;item in data.children&quot;&gt;        &lt;MenuItem v-if=&quot;!item.children&quot; :key=&quot;item.id&quot;&gt;          &#123;&#123; item.title &#125;&#125;        &lt;/MenuItem&gt;        &lt;!-- 渲染更多层级时 --&gt;        &lt;!-- &lt;ReSubMenu v-else :data=&quot;item&quot;&gt;&lt;/ReSubMenu&gt; --&gt;        &lt;!-- 只渲染到二级 --&gt;        &lt;SubMenu v-else :data=&quot;item&quot;&gt;          &lt;template #title&gt;&#123;&#123; data.title &#125;&#125;&lt;/template&gt;        &lt;/SubMenu&gt;      &lt;/template&gt;    &lt;/template&gt;  &lt;/SubMenu&gt;&lt;/template&gt;</code></pre><ul><li>SubMenu.vue</li></ul><pre><code>&lt;script setup&gt;&lt;/script&gt;&lt;template&gt;  &lt;div class=&quot;sub-menu&quot;&gt;    &lt;div class=&quot;title&quot;&gt;      &lt;slot name=&quot;title&quot;&gt;&lt;/slot&gt;      &lt;span class=&quot;more&quot;&gt;&gt;&lt;/span&gt;    &lt;/div&gt;    &lt;div class=&quot;sub-item&quot;&gt;      &lt;slot&gt;&lt;/slot&gt;    &lt;/div&gt;  &lt;/div&gt;&lt;/template&gt;</code></pre><h5 id="使用render函数"><a href="#使用render函数" class="headerlink" title="使用render函数"></a>使用render函数</h5><ul><li><code>ReSubMenu.vue</code></li></ul><pre><code>&lt;script&gt;import SubMenu from &quot;./SubMenu.vue&quot;;import MenuItem from &quot;./MenuItem.vue&quot;;import ReSubMenu from &quot;./ReSubMenu.vue&quot;;import &#123; h &#125; from &quot;vue&quot;;export default &#123;  props: [&quot;data&quot;],  setup(props) &#123;    return () =&gt;      h(SubMenu, null, &#123;        title: () =&gt; props.data.title,        default: () =&gt;          props.data.children.map((item) =&gt; &#123;            if (!item.children) &#123;              return h(                MenuItem,                &#123; key: item.id, href: item.href &#125;,                () =&gt; item.title              );            &#125; else &#123;              return h(ReSubMenu, &#123; data: item &#125;);            &#125;          &#125;),      &#125;);  &#125;,&#125;;&lt;/script&gt;</code></pre><ul><li>注意：<code>null</code>不能丢</li><li>给<code>MenuItem</code>组件传值时，要使用给组件传值的方式：<code>()=&gt;&#123;&#125;</code>，因为是给默认插槽传值</li></ul><h2 id="开发Message组件"><a href="#开发Message组件" class="headerlink" title="开发Message组件"></a>开发Message组件</h2><h3 id="项目介绍-3"><a href="#项目介绍-3" class="headerlink" title="项目介绍"></a>项目介绍</h3><h4 id="项目功能-1"><a href="#项目功能-1" class="headerlink" title="项目功能"></a>项目功能</h4><ul><li>Message组件有<strong>成功、警告、消息、错误</strong>四种样式，显示不同的操作反馈</li><li>提示框显示与离开都伴有动画效果</li><li>同时显示多个提示框时，会有序的从上往下排列，前面元素离开后，后面元素会缓慢的向上移动<img src="Message组件.gif"></li></ul><h4 id="项目涉及核心知识点-1"><a href="#项目涉及核心知识点-1" class="headerlink" title="项目涉及核心知识点"></a>项目涉及核心知识点</h4><table><thead><tr><th>知识分类</th><th>涉及内容</th></tr></thead><tbody><tr><td>Vue 基础（组合式）</td><td>插值语法、reactive、ref、事件监听、样式绑定、v-show 指令、<Transition>内置组件、createApp 创建应用实例</td></tr><tr><td>组件间通信</td><td>defineProps、defineExpose</td></tr><tr><td>其它知识</td><td>async&#x2F;await 、Promise、setTimeout、clearTimeout；数组方法：forEach、findIndex</td></tr></tbody></table><h3 id="实现-2"><a href="#实现-2" class="headerlink" title="实现"></a>实现</h3><blockquote><p>关系概况</p></blockquote><ul><li>创建Meassage组件，实现信息的动态弹窗效果</li><li>在<code>index.js</code>文件中，创建Message方法，用来实现Message组件的挂载</li><li>App组件，设置四个按钮，点击后可调用Message方法，传入不同的按钮类型和信息，可实现不同的动画效果</li></ul><blockquote><p>具体项目开发思路</p></blockquote><ul><li>创建<code>&lt;Message&gt;</code>组件，组件的 UI 显示有 4 种不同的状态，并且组件显示与离开都有动画效果。</li><li>创建 <code>Message</code> 方法，该方法接受一个对象作为参数，当调用该方法或该方法的静态方法（<code>Message.success</code>&#x2F;<code>message</code>&#x2F;<code>error</code>&#x2F;<code>warning</code>）都可以实现<code>Message</code>组件的挂载</li><li><code>Message</code>组件挂载成功后，以动画形式显示</li><li><code>Message</code>组件挂载成功后，过<code>3000ms</code>或<code>xxx</code>时间则以动画形式消失</li><li>当同时有多个 <code>Messag</code> 组件挂载后，后面的组件的按顺序在其它组件后面显示<ul><li>设置数组，存放组件实例</li></ul></li><li>当前面的组件消失后，后面组件会有序的缓慢向前移动<ul><li>当动画结束时，卸载组件，将它从数组中删除；用watch侦听数组变化，每次变化都更新top值</li></ul></li></ul><h4 id="实现-Message-组件"><a href="#实现-Message-组件" class="headerlink" title="实现 Message 组件"></a>实现 Message 组件</h4><blockquote><p>根据 UI 图，利用html+css实现静态布局，同时要把所有的交互效果用到的 CSS 样式也要写好。并且要清楚的知道每一个交互背后的实现逻辑。</p><ul><li>组件显示与离开都有动画效果，可以利用<code>&lt;Transition&gt;</code>组件来实现</li><li>当前面的组件卸载后，后面的组件缓慢向前移动，可以利用 <code>CSS3</code> 的 <code>transition</code> 来实现过渡动画</li></ul></blockquote><pre><code>&lt;script setup&gt;  import &#123; ref &#125; from &quot;vue&quot;;  // 控制元素的显示与隐藏  const isShow = ref(false);  // 模拟修改isShow的值来触发动画  setTimeout(() =&gt; &#123;    isShow.value = true;    setTimeout(() =&gt; &#123;      isShow.value = false;    &#125;, 2000);  &#125;, 1000);&lt;/script&gt;&lt;template&gt;  &lt;Transition name=&quot;slide&quot;&gt;    &lt;!--             弹窗显示的内容和4种UI状态由：            Message(&#123;type:&#39;message&#39;,message:&#39;this is a message&#39;&#125;) 函数传入的参数决定            --&gt;    &lt;div class=&quot;ibc-message message&quot; v-show=&quot;isShow&quot;&gt;this is a message&lt;/div&gt;    &lt;!--             &lt;div class=&quot;ibc-message success&quot;&gt; this is a success&lt;/div&gt;            &lt;div class=&quot;ibc-message warning&quot;&gt; this is a warning&lt;/div&gt;            &lt;div class=&quot;ibc-message error&quot;&gt; this is a error&lt;/div&gt;         --&gt;  &lt;/Transition&gt;&lt;/template&gt;&lt;style scoped&gt;  .ibc-message &#123;    min-width: 200px;    height: 35px;    line-height: 35px;    position: fixed;    top: 20px;    left: 50%;    text-align: center;    background-color: #ddd;    transform: translateX(-50%);    border-radius: 3px;    /* 元素本身一直有过渡动画效果 */    transition: top 0.5s ease;  &#125;  .message &#123;    background-color: #e9e9eb;    color: #73767a;    border: 1px solid #dedfe0;  &#125;    .success &#123;    background-color: #e1f3d8;    color: #529b2e;    border: 1px solid #d1edc4;  &#125;    .warning &#123;    background-color: #faecd8;    color: #b88230;    border: 1px solid #f8e3c5;  &#125;    .error &#123;    background-color: #fde2e2;    color: #c45656;    border: 1px solid #fcd3d3;  &#125;  .slide-enter-from,  .slide-leave-to &#123;    transform: translate(-50%, -20px);    opacity: 0;  &#125;  .slide-enter-active,  .slide-leave-active &#123;    transition: all 0.5s ease;  &#125;  /*    .slide-enter-to &#123;        transform: translateY(0);        opacity: 1;    &#125;    */&lt;/style&gt;</code></pre><h4 id="实现-Message-方法基本框架"><a href="#实现-Message-方法基本框架" class="headerlink" title="实现 Message 方法基本框架"></a>实现 Message 方法基本框架</h4><ul><li>在App.vue组件中，创建 4 个按扭，点击不同按扭分别调用 Message 方法或 Message 身上的静态方法，显示 4 种不同状态的提示框</li></ul><pre><code>&lt;script setup&gt;  // 以下代码相当于导入 src/components/Message/index.js  import Message from &quot;./components/Message&quot;;&lt;/script&gt;&lt;template&gt;  &lt;button    @click=&quot;Message(&#123;        type: &#39;message&#39;,        message: &#39;this is a message&#39;        &#125;)&quot;  &gt;    message  &lt;/button&gt;  &lt;button    @click=&quot;Message(&#123;    type: &#39;success&#39;,    message: &#39;this is a success&#39;    &#125;)&quot;  &gt;    success  &lt;/button&gt;  &lt;button    @click=&quot;Message.warning(&#123;      message: &#39;this is a warning&#39;      &#125;)&quot;  &gt;    warning  &lt;/button&gt;  &lt;button    @click=&quot;Message.error(&#123;      message: &#39;this is a error&#39;      &#125;)&quot;  &gt;    error  &lt;/button&gt;&lt;/template&gt;&lt;style scoped&gt;  button &#123;    line-height: 30px;    margin: 10px;    border: 1px solid #ddd;    border-radius: 3px;    cursor: pointer;  &#125;&lt;/style&gt;</code></pre><ul><li>在<code>./src/Message/index.js</code>中，定义Message方法，和Message身上的静态方法，然后对外默认暴露 Message 方法</li></ul><pre><code>// 创建Message方法，用来实现Message组件挂载function Message(options) &#123;  console.log(options);&#125;// 为Message添加以下四个静态方法[&quot;message&quot;, &quot;success&quot;, &quot;warning&quot;, &quot;error&quot;].forEach((item) =&gt; &#123;  Message[item] = function (options) &#123;    options.type = item;    Message(options);  &#125;;&#125;);export default Message;</code></pre><h4 id="Message-方法实现组件挂载"><a href="#Message-方法实现组件挂载" class="headerlink" title="Message 方法实现组件挂载"></a>Message 方法实现组件挂载</h4><blockquote><p>当调用 Message 方法时，需要将 Message 组件挂载到页面中。需要分以下几步：</p><ul><li>利用 createApp 来创建 Message 的应用实例 MessageApp，createApp 的第二个参数相当于传递给组件 Message 的 props。则可以在 Message 组件中接受传过来的 props。</li><li>利用document.createDocumentFragment()方法创建文档碎片</li><li>调用MessageApp.mount()方法，将 Message 组件挂载到fragment中，得到返回值 vm 组件实例</li><li>利用document.body.appendChild(fragment)，将文档碎片（即 Message 组件）添加到页面。</li></ul></blockquote><pre><code>import &#123; createApp &#125; from &quot;vue&quot;;import MessageCom from &quot;./Message.vue&quot;;// 创建Message方法，用来实现Message组件挂载function Message(options) &#123;  // 创建Message应用实例，并挂载到页面中  const MessageApp = createApp(MessageCom, options);  showMessage(MessageApp, options);&#125;// 为Message添加以下四个静态方法[&quot;message&quot;, &quot;success&quot;, &quot;warning&quot;, &quot;error&quot;].forEach((item) =&gt; &#123;  Message[item] = function (options) &#123;    options.type = item;    Message(options);  &#125;;&#125;);// options要往后传，后面需要用到从显示到离开需要的延迟时间function showMessage(app, options) &#123;  // 创建文档碎片  const fragment = document.createDocumentFragment();  // 将组件挂载到文档碎片，返回组件实例vm  const vm = app.mount(fragment);  // 将文档碎片，即（Message）组件挂载到页面中  document.body.appendChild(fragment);&#125;export default Message;</code></pre><ul><li>Message 组件中接受传递的 props</li></ul><pre><code>&lt;script setup&gt;  import &#123; ref &#125; from &quot;vue&quot;;  // 控制元素的显示与隐藏  const isShow = ref(false);  // 声明接受的props，即createApp(MessageCom,options) 方法的options参数的属性  defineProps(&#123;    type: &#123;      type: String,      default: &quot;message&quot;,      /* 校验 */      validator(value) &#123;        return [&quot;message&quot;, &quot;success&quot;, &quot;warning&quot;, &quot;error&quot;].includes(value);      &#125;,    &#125;,    message: &#123;      type: String,      default: &quot;this is a message&quot;,    &#125;,  &#125;);  // 模拟修改isShow的值来触发动画  setTimeout(() =&gt; &#123;    isShow.value = true;    setTimeout(() =&gt; &#123;      isShow.value = false;    &#125;, 2000);  &#125;, 1000);&lt;/script&gt;&lt;template&gt;  &lt;Transition name=&quot;slide&quot;&gt;    &lt;div class=&quot;ibc-message&quot; :class=&quot;type&quot; v-show=&quot;isShow&quot;&gt;&#123;&#123; message &#125;&#125;&lt;/div&gt;  &lt;/Transition&gt;&lt;/template&gt;</code></pre><ul><li>但是，组件的显示与隐藏是通过定时器来模拟控制的。</li><li>实际上，我们在将组件挂载到页面后就要将 Message 组件的 isShow 设置为 true，在规定的延迟时间到了后，才将组件从页面移除。</li></ul><h4 id="实现显示组件"><a href="#实现显示组件" class="headerlink" title="实现显示组件"></a>实现显示组件</h4><blockquote><ul><li>一开始 Message 组件中的<code>isShow = false</code>，所以 Message 组件挂载到页面后，并不会显示，则需要设置<code>isShow = true</code>。</li><li>在 Message 组件中创建<code>setShow</code>方法，用来设置<code>isShow</code>属性的值，然后将该方法通过<code>defineExpose</code>对外暴露</li></ul></blockquote><pre><code>// 控制元素显示与隐藏function setShow(value) &#123;  isShow.value = value;&#125;// 对外暴露一些公共属性defineExpose(&#123;  setShow,&#125;);在index.js中,showMessage方法中调用 setShow 方法来显示组件function showMessage(app, options) &#123;  // .......  // 显示  vm.setShow(true);&#125;</code></pre><h4 id="实现卸载组件"><a href="#实现卸载组件" class="headerlink" title="实现卸载组件"></a>实现卸载组件</h4><blockquote><ul><li>我们可以创建hideMessage方法，在规定的延迟时间到达后，用来卸载对应的 Message 组件</li><li>卸载组件时要保证先完成离开动画，然后再卸载组件</li></ul></blockquote><pre><code>function showMessage(app, options) &#123;  // .....  // 显示  vm.setShow(true);  // 隐藏  在规定的延迟时间到达后再隐藏，所以要传入options.duration，同时在调用  // Message(&#123; duration:2000 &#125;) 方法时可以传入duration选项  hideMessage(app, vm, options.duration);&#125;// 隐藏组件function hideMessage(app, vm, duration) &#123;  vm.timer = setTimeout(() =&gt; &#123;    // 隐藏    vm.setShow(false);    // 卸载    app.unmount();    clearTimeout(vm.timer);    vm.timer = null;  &#125;, duration || 2000);&#125;</code></pre><ul><li>显然在hideMessage方法中，调用vm.setShow(false)方法隐藏组件时，动画还没有执行完，组件就被卸载了，上面的代码显示是不行的。</li><li>我们需要等待动画执行完再卸载组件，所以我们可以修改setShow()方法，在该方法中返回一个Promise对象，在组件动画执行完后，调用Promise的 resolve 方法。</li><li>然后在Promise的 then 方法中来卸载组件</li></ul><pre><code>// 控制元素显示与隐藏function setShow(value) &#123;  // 触发动画  isShow.value = value;  return new Promise((resolve, reject) =&gt; &#123;    timer = setTimeout(() =&gt; &#123;      // 动画结束了，调resolve      clearTimeout(timer);      resolve();    &#125;, 500);  &#125;);&#125;// 移除应用实例（在移除前要先触发动画）function hideMessage(app, vm, duration) &#123;  vm.timer = setTimeout(async () =&gt; &#123;    await vm.setShow(false);    // 卸载    app.unmount();    clearTimeout(vm.timer);    vm.timer = null;  &#125;, duration || 2000);&#125;</code></pre><h4 id="计算元素的-Top-值"><a href="#计算元素的-Top-值" class="headerlink" title="计算元素的 Top 值"></a>计算元素的 Top 值</h4><blockquote><ul><li>创建一个数组messageArr &#x3D; []用来保存当前创的所有 vm 组件实例</li><li>每创建一个新的 vm，将 vm 添加 push 到 messageArr 数组中，每当有一个 vm 被卸载，则从数组中移除</li><li>然后根据 vm 在数组messageArr中的索引来计算当前 vm 元素的 top 值</li><li>在 Message 组件中动态绑style &#x3D; ‘{top: top + ‘px’} 样式，来设置 top 的值， 同时暴露setTop方法来修改 top 的值。</li></ul></blockquote><ul><li>Message 组件</li></ul><pre><code>&lt;script setup&gt;  const top = ref(20);  // 设置top值  function setTop(value) &#123;    top.value = value;  &#125;  // 对外暴露一些公共属性  defineExpose(&#123;    setShow,    setTop,  &#125;);&lt;/script&gt;&lt;template&gt;  &lt;div    class=&quot;ibc-message&quot;    :class=&quot;type&quot;    v-show=&quot;isShow&quot;    :style=&quot;&#123; top: top + &#39;px&#39; &#125;&quot;  &gt;    &#123;&#123; message &#125;&#125;  &lt;/div&gt;&lt;/template&gt;</code></pre><h4 id="完整版代码"><a href="#完整版代码" class="headerlink" title="完整版代码"></a>完整版代码</h4><ul><li>App.vue</li></ul><pre><code>&lt;script setup&gt;  import Message from &quot;./components/Message&quot;;&lt;/script&gt;&lt;template&gt;  &lt;button    @click=&quot;Message(&#123;        type: &#39;message2&#39;,        message: &#39;this is a message&#39;    &#125;)&quot;  &gt;    message  &lt;/button&gt;  &lt;button    @click=&quot;Message(&#123;        type: &#39;success&#39;,        message: &#39;this is a success&#39;    &#125;)&quot;  &gt;    success  &lt;/button&gt;  &lt;button    @click=&quot;Message.warning(&#123;        message: &#39;this is a warning&#39;    &#125;)&quot;  &gt;    warning  &lt;/button&gt;  &lt;button    @click=&quot;Message.error(&#123;        message: &#39;this is a error&#39;    &#125;)&quot;  &gt;    error  &lt;/button&gt;&lt;/template&gt;&lt;style scoped&gt;  button &#123;    line-height: 30px;    margin: 10px;    border: 1px solid #ddd;    border-radius: 3px;    cursor: pointer;  &#125;&lt;/style&gt;</code></pre><ul><li>index.js</li></ul><pre><code>import MessageCom from &quot;./Message.vue&quot;;import &#123; createApp, reactive, watch &#125; from &quot;vue&quot;;// 存放存放的Message组件实例const messageArr = reactive([]);function Message(options) &#123;  // 创建Message应用实例，并挂载到页面中  const MessageApp = createApp(MessageCom, options);  showMessage(MessageApp, options.duration);&#125;// 为Message添加以下四个静态方法[&quot;message&quot;, &quot;success&quot;, &quot;warning&quot;, &quot;error&quot;].forEach((item) =&gt; &#123;  Message[item] = function (options) &#123;    options.type = item;    Message(options);  &#125;;&#125;);// 显示提示框function showMessage(app, duration) &#123;  const fragment = document.createDocumentFragment();  // 组件实例  const vm = app.mount(fragment);  // 将vm组件实例添加到数组中  messageArr.push(vm);  document.body.appendChild(fragment);  setTop(vm);  watch(messageArr, () =&gt; &#123;    setTop(vm);  &#125;);  // 显示  vm.setShow(true);  // 隐藏  hideMessage(app, vm, duration);&#125;// 移除应用实例（在移除前要先触发动画）function hideMessage(app, vm, duration) &#123;  vm.timer = setTimeout(async () =&gt; &#123;    await vm.setShow(false);    // 从数组中移除vm    const index = messageArr.findIndex((item) =&gt; item === vm);    messageArr.splice(index, 1);    // 卸载    app.unmount();    clearTimeout(vm.timer);    vm.timer = null;  &#125;, duration || 2000);&#125;// 设置提示框与顶部的距离function setTop(vm) &#123;  // 设置message显示的top值  const index = messageArr.findIndex((item) =&gt; item === vm);  console.log(messageArr);  const top = 20 + index * 60;  vm.setTop(top);&#125;export default Message;</code></pre><ul><li>Message.vue</li></ul><pre><code>&lt;script setup&gt;  import &#123; computed, ref &#125; from &quot;vue&quot;;  const isShow = ref(false);  const top = ref(20);  const timer = ref(null);  defineProps(&#123;    type: &#123;      type: String,      default: &quot;message&quot;,      /* 校验 */      validator(value) &#123;        return [&quot;message&quot;, &quot;success&quot;, &quot;warning&quot;, &quot;error&quot;].includes(value);      &#125;,    &#125;,    message: &#123;      type: String,      default: &quot;this is a message&quot;,    &#125;,  &#125;);  function setShow(value) &#123;    // 触发动画    isShow.value = value;    return new Promise((resolve, reject) =&gt; &#123;      timer.value = setTimeout(() =&gt; &#123;        // 动画结束了，调resolve        clearTimeout(timer);        resolve();      &#125;, 500);    &#125;);  &#125;  // 设置top值  function setTop(value) &#123;    top.value = value;  &#125;  // 对外暴露一些公共属性  defineExpose(&#123;    setShow,    setTop,  &#125;);&lt;/script&gt;&lt;template&gt;  &lt;Transition name=&quot;slide&quot;&gt;    &lt;div      class=&quot;ibc-message&quot;      :class=&quot;type&quot;      v-show=&quot;isShow&quot;      :style=&quot;&#123; top: top + &#39;px&#39; &#125;&quot;    &gt;      &#123;&#123; message &#125;&#125;    &lt;/div&gt;  &lt;/Transition&gt;&lt;/template&gt;&lt;style scoped&gt;  .ibc-message &#123;    min-width: 200px;    height: 35px;    line-height: 35px;    position: fixed;    top: 20px;    left: 50%;    text-align: center;    background-color: #ddd;    transform: translateX(-50%);    border-radius: 3px;    transition: top 0.5s ease;  &#125;  .message &#123;    background-color: #e9e9eb;    color: #73767a;    border: 1px solid #dedfe0;  &#125;  .success &#123;    background-color: #e1f3d8;    color: #529b2e;    border: 1px solid #d1edc4;  &#125;  .warning &#123;    background-color: #faecd8;    color: #b88230;    border: 1px solid #f8e3c5;  &#125;  .error &#123;    background-color: #fde2e2;    color: #c45656;    border: 1px solid #fcd3d3;  &#125;  .slide-enter-from,  .slide-leave-to &#123;    transform: translate(-50%, -20px);    opacity: 0;  &#125;  .slide-enter-active,  .slide-leave-active &#123;    transition: all 0.5s ease;  &#125;&lt;/style&gt;</code></pre>]]></content>
      
      
      <categories>
          
          <category> 手写 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 组件 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Vue（八）</title>
      <link href="/2024/01/28/Vue%EF%BC%88%E5%85%AB%EF%BC%89/"/>
      <url>/2024/01/28/Vue%EF%BC%88%E5%85%AB%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<span id="more"></span><blockquote><p>Pinia 是 Vue 的专属状态（状态指的就是数据）管理库，它允许你跨组件或页面共享状态。 Pinia 相当于一个数据仓库，所有当前应用的组件都可以访问数据仓库中的数据</p></blockquote><h3 id="一、Pinia-的基本使用"><a href="#一、Pinia-的基本使用" class="headerlink" title="一、Pinia 的基本使用"></a>一、Pinia 的基本使用</h3><blockquote><p>本小节主要讲解关于 Pinai 的基本使用，使用 Pinia 需要经历以下 5 步：</p></blockquote><ul><li>安装 Pinia</li><li>在 vue3 中注册 Pinia 插件</li><li>定义 Store</li><li>使用 Store</li></ul><h4 id="安装-Pinia"><a href="#安装-Pinia" class="headerlink" title="安装 Pinia"></a>安装 Pinia</h4><ul><li>执行以下命令安装 pinia</li></ul><pre><code>yarn add pinia# 或者使用 npm 安装npm install pinia</code></pre><h4 id="注册-Pinia"><a href="#注册-Pinia" class="headerlink" title="注册 Pinia"></a>注册 Pinia</h4><ul><li>以下为在 Vue3 中注册 Pinia 的方法</li><li>首先导入 pinia 提供的<code>createPinia</code>方法，然后调用创建 pinia 实例</li><li>执行<code>app.use()</code>方法，将 pinia 实例传递给应用</li></ul><pre><code>import &#123; createApp &#125; from &quot;vue&quot;;import App from &quot;./App.vue&quot;;// 导航pinia的createPinia方法import &#123; createPinia &#125; from &quot;pinia&quot;;// 创建 pinia实例const pinia = createPinia();const app = createApp(App);// 注册pinia插件app.use(pinia);app.mount(&quot;#app&quot;);</code></pre><h4 id="定义-Store"><a href="#定义-Store" class="headerlink" title="定义 Store"></a>定义 Store</h4><blockquote><p>在定义 Store 之前，我们需要先了解下什么是 Store ？Store 有仓库的意思，在这里好比是数据存放的仓库。</p></blockquote><ol><li>Store 是什么 ？<blockquote><p>Store （如 Pinia）是一个保存状态和业务逻辑的实例，它并不与你的组件树绑定</p><p>上面这句话你可以理解为，应用中需要共享的全局状态（数据）及数据处理相关的逻辑都保存在 Store 实例上，但他不与应用中的任何组件单独绑定。</p><p>它有点像一个永远存在的组件，每个组件都可以读取和写入它。它有三个概念，<code>state</code>、<code>getter</code>和<code>action</code>，我们可以假设这些概念相当于组件中的<code>data</code>、<code>computed</code>和<code>methods</code>。</p></blockquote></li></ol><blockquote><p>如何定义 Store</p></blockquote><ul><li>Store 是用<code>defineStore()</code>定义的，返回值为一个函数，函数名推荐使用<code>use...Store</code>写法</li><li>它的第一个参数要求是一个独一无二的名字</li><li>它的第二个参数接受两类值：<code>Setup</code> 函数或<code>Option</code> 对象</li></ul><pre><code>import &#123; defineStore &#125; from &quot;pinia&quot;;// 定义Store ，Store的命名推荐使用 usexxxStore 这种写法export const useCountStore = defineStore(&quot;count&quot;, &#123;  //  Option对象&#125;);// 或export const useCountStore = defineStore(&quot;count&quot;, () =&gt; &#123;  // setup函数&#125;);</code></pre><ol start="2"><li>Option Store<blockquote><p><code>defineStore()</code>方法的第二个参数可以是一个Option对象，该对象与 Vue 的<strong>选项式 API</strong> 类似，接受 state、actions 与 getters 属性。</p></blockquote></li></ol><ul><li>在当前项目的src目录下新建store目录，并在该目录下新建 <code>count.js</code>文件，在文件中定义 Store 并对外暴露</li></ul><pre><code>import &#123; defineStore &#125; from &quot;pinia&quot;;// 定义Store ，Store的命名推荐使用 usexxxStore 这种写法export const useCountStore = defineStore(&quot;count&quot;, &#123;  // Option对象,有三个重要的属性 state、actions 与 getters,  // state 相当于组件中的data  // 为了完整类型推理，state函数更推荐箭头函数写法  state: () =&gt; &#123;    return &#123;      count: 10,    &#125;;  &#125;,  // getters 相当于组件中的computed,会对数据缓存  getters: &#123;    doubleCount: (state) =&gt; state.count * 2,  &#125;,  // actions 相当于组件中的methods  actions: &#123;    add() &#123;      this.count++; // this指向创建的store    &#125;,  &#125;,&#125;);</code></pre><ul><li>你可以认为以上代码中的 state 是 store 的数据 (data)，getters 是 store 的计算属性 (computed)，而 actions 则是方法 (methods)。</li></ul><blockquote><p>温馨提示：为了完整类型推理，state 函数更推荐箭头函数写法</p></blockquote><ol start="4"><li>使用 Store</li></ol><ul><li>上面我们定义了一个 Store，但在我们没有调用<code>defineStore()</code>方法返回的值（一个函数）之前，store 实例是不会被创建的</li><li>我们在<code>&lt;script setup&gt;</code>中调用<code>useCountStore()</code>创建 store 实例</li><li>一旦 store 被实例化，你可以直接访问在 store 的 state、getters 和 actions 中定义的任何属性</li></ul><pre><code>&lt;script setup&gt;  import &#123; useCountStore &#125; from &quot;./store/count&quot;;  // countStore为创建的store实例，可以在组件的任意位置访问countStore  const countStore = useCountStore();&lt;/script&gt;&lt;template&gt;  &lt;div&gt;count的值：&#123;&#123; countStore.count &#125;&#125;&lt;/div&gt;  &lt;div&gt;count放大2倍值：&#123;&#123; countStore.doubleCount &#125;&#125;&lt;/div&gt;  &lt;button @click=&quot;countStore.add&quot;&gt;count++&lt;/button&gt;&lt;/template&gt;</code></pre><ol start="5"><li>Setup Store</li></ol><ul><li><code>defineStore()</code>方法的第二个参数除了是一个 <code>Option</code> 对象，还可以是一个<code>Setup</code>函数。</li><li>该函数与 Vue 组合式 API 的<strong>Setup函数</strong>相似。该函数定义了一些响应式属性和方法，并且返回一个带有我们想暴露出去的属性和方法的对象。</li></ul><blockquote><p>温馨提示：</p></blockquote><ul><li><p>我们可以定义任意多的 Store，但为了让使用 pinia 的益处最大化（比如允许构建工具自动进行代码分割以及 TypeScript 推断），我们应该在不同的文件中去定义 store</p></li><li><p>在store目录下新建<code>user.js</code>文件，在文件中创建一个 Store</p></li></ul><pre><code>import &#123; ref, computed, reactive &#125; from &quot;vue&quot;;import &#123; defineStore &#125; from &quot;pinia&quot;;export const useUserStore = defineStore(&quot;user&quot;, () =&gt; &#123;  // 定义的ref变量，相当于Option对象中的state 即相当于组件中的data  const username = ref(&quot;艾编程&quot;);  const age = ref(17);  const hobbies = reactive([&quot;画画&quot;, &quot;写字&quot;]);  // 计算属性  相当于Option对象的getters，即相当于组件中的computed  // 返回的计算属性 identity 是一个ref对象，所以是响应式的  const identity = computed(() =&gt; &#123;    return age.value &gt;= 18 ? &quot;成年&quot; : &quot;未成年&quot;;  &#125;);  // 函数，相当于Option对象的actions，即相当于组件中的methods方法  function update() &#123;    age.value++;  &#125;  // 对外暴露属性和方法  return &#123;    username,    age,    hobbies,    identity,    update,  &#125;;&#125;);</code></pre><blockquote><p>在Setup Store中，Setup 函数中</p></blockquote><ul><li><p>定义的响应式变量，就是 state 属性，好比组件的 data 属性</p></li><li><p>定义的<code>computed()</code>计算属性，就是 <code>getters</code>，好比组件中的计算属性</p></li><li><p>定义的<code>function()</code>就是 actions，好比组件中的 methods 方法</p></li><li><p>在组件中使用创建好的 Store</p></li></ul><pre><code>&lt;script setup&gt;  import &#123; useUserStore &#125; from &quot;./store/user&quot;;  // countStore为创建的store实例，可以在组件的任意位置访问countStore  const userStore = useUserStore();&lt;/script&gt;&lt;template&gt;  &lt;div&gt;用户姓名：&#123;&#123; userStore.username &#125;&#125;&lt;/div&gt;  &lt;div&gt;用户年龄：&#123;&#123; userStore.age &#125;&#125;&lt;/div&gt;  &lt;!--    identity计算属性虽然是一个ref对象，但是userStore是一个用reactive包装的响应式对象    针对响应式对象的ref属性，在模板中调用时会自动解包，所以模板中调用不需要`.value`    --&gt;  &lt;div&gt;用户身份：&#123;&#123; userStore.identity &#125;&#125;&lt;/div&gt;  &lt;button @click=&quot;userStore.update&quot;&gt;更新年龄&lt;/button&gt;&lt;/template&gt;</code></pre><ol start="6"><li>解构 Store</li></ol><ul><li>创建的<code>Store</code>实例对象是一个用<code>reactive</code>包装的响应式对象（即 <code>Proxy</code> 代理对象）。</li><li>所以不能直接解构 <code>Store</code>，因为解构后会失去响应式</li></ul><blockquote><p>错误示例</p></blockquote><pre><code>&lt;script setup&gt;  import &#123; useUserStore &#125; from &quot;./store/user&quot;;  //  直接解构store，会失去响应性，  const &#123; username, age, identity, update &#125; = useUserStore();&lt;/script&gt;&lt;template&gt;  &lt;div&gt;用户姓名：&#123;&#123; username &#125;&#125;&lt;/div&gt;  &lt;div&gt;用户年龄：&#123;&#123; age &#125;&#125;&lt;/div&gt;  &lt;div&gt;用户身份：&#123;&#123; identity &#125;&#125;&lt;/div&gt;  &lt;button @click=&quot;update&quot;&gt;更新年龄&lt;/button&gt;&lt;/template&gt;</code></pre><ul><li>为了从 store 中提取属性时保持其响应性，你需要使用 <code>storeToRefs()</code>。</li><li>该方法类似于 Vue 中的<code>toRefs()</code>，最终解构出来的每个属性都是一个单的ref对象。</li><li>不过要特别注意，store 实例中的方法是可以直接从 store 实例解构的</li></ul><blockquote><p>正确示例</p></blockquote><pre><code>&lt;script setup&gt;  import &#123; storeToRefs &#125; from &quot;pinia&quot;;  import &#123; useUserStore &#125; from &quot;./store/user&quot;;  const UserStore = useUserStore();  //  直接解构store，会失去响应性  const &#123; username, age, identity &#125; = storeToRefs(UserStore);  // 方法，可以直接解构  const &#123; update &#125; = UserStore;&lt;/script&gt;&lt;template&gt;  &lt;div&gt;用户姓名：&#123;&#123; username &#125;&#125;&lt;/div&gt;  &lt;div&gt;用户年龄：&#123;&#123; age &#125;&#125;&lt;/div&gt;  &lt;div&gt;用户身份：&#123;&#123; identity &#125;&#125;&lt;/div&gt;  &lt;button @click=&quot;update&quot;&gt;更新年龄&lt;/button&gt;&lt;/template&gt;</code></pre><h3 id="二、深入-State"><a href="#二、深入-State" class="headerlink" title="二、深入 State"></a>二、深入 State</h3><ol><li>直接修改 state 的值<blockquote><p>我们可以通过 store 实例访问 state，直接修改其值</p></blockquote></li></ol><pre><code>&lt;script setup&gt;  import &#123; storeToRefs &#125; from &quot;pinia&quot;;  import &#123; useUserStore &#125; from &quot;./store/user&quot;;  const userStore = useUserStore();  function update() &#123;    userStore.username = &quot;清心&quot;;    userStore.age = 33;  &#125;&lt;/script&gt;&lt;template&gt;  &lt;div&gt;用户姓名：&#123;&#123; userStore.username &#125;&#125;&lt;/div&gt;  &lt;div&gt;用户年龄：&#123;&#123; userStore.age &#125;&#125;&lt;/div&gt;  &lt;div&gt;用户身份：&#123;&#123; userStore.identity &#125;&#125;&lt;/div&gt;  &lt;button @click=&quot;update&quot;&gt;更新数据&lt;/button&gt;&lt;/template&gt;</code></pre><ol start="2"><li>批量修改 State 的值<blockquote><p>调用 store 实例的<code>$patch</code>方法，它允许你用一个 state 的补丁对象在同一时间更改多个属性。</p></blockquote></li></ol><pre><code>&lt;script setup&gt;  import &#123; storeToRefs &#125; from &quot;pinia&quot;;  import &#123; useUserStore &#125; from &quot;./store/user&quot;;  const userStore = useUserStore();  function update() &#123;    userStore.$patch(&#123;      username: &quot;清心&quot;,      age: 33,    &#125;);  &#125;&lt;/script&gt;&lt;template&gt;  &lt;div&gt;用户姓名：&#123;&#123; userStore.username &#125;&#125;&lt;/div&gt;  &lt;div&gt;用户年龄：&#123;&#123; userStore.age &#125;&#125;&lt;/div&gt;  &lt;div&gt;用户身份：&#123;&#123; userStore.identity &#125;&#125;&lt;/div&gt;  &lt;button @click=&quot;update&quot;&gt;更新用户信息&lt;/button&gt;&lt;/template&gt;</code></pre><blockquote><p>如果<code>UserStore</code>有一个<code>hobbies</code>属性，该属性是一个数组，我们需要向数组中添加一项，则需要<strong>创建一个新的数组</strong>来实现。</p></blockquote><pre><code>function update() &#123;  UserStore.$patch(&#123;    username: &quot;清心&quot;,    age: 33,    hobbies: [...userStore.hobbies, &quot;唱歌&quot;],  &#125;);&#125;</code></pre><ul><li>所以针对任何集合类型的修改，上面这种方式都是非常麻烦的，所以<code>$patch</code>也接受一个函数作为参数。</li></ul><ol start="3"><li>批量修改函数形式<blockquote><p>你可以向 store 实例的<code>$patch</code>方法传入一个<strong>函数</strong>作为参数来实现一次性修改多个 state 属性值</p></blockquote></li></ol><ul><li>该回调函数接受 state 作为第一个参数</li></ul><pre><code>&lt;script setup&gt;  import &#123; storeToRefs &#125; from &quot;pinia&quot;;  import &#123; useUserStore &#125; from &quot;./store/user&quot;;  const userStore = useUserStore();  // 修改state中多个属性的值  function update() &#123;    userStore.$patch((state) =&gt; &#123;      state.username = &quot;清心&quot;;      state.age = 33;      state.hobbies.push(&quot;唱歌&quot;);    &#125;);  &#125;&lt;/script&gt;&lt;template&gt;  &lt;div&gt;用户姓名：&#123;&#123; userStore.username &#125;&#125;&lt;/div&gt;  &lt;div&gt;用户年龄：&#123;&#123; userStore.age &#125;&#125;&lt;/div&gt;  &lt;div&gt;用户身份：&#123;&#123; userStore.identity &#125;&#125;&lt;/div&gt;  &lt;div&gt;用户爱好：&#123;&#123; userStore.hobbies &#125;&#125;&lt;/div&gt;  &lt;button @click=&quot;update&quot;&gt;更新用户信息&lt;/button&gt;&lt;/template&gt;</code></pre><ol start="4"><li>通过 actions 修改<blockquote><p>我们可以在 Store 的 <code>actions</code> 选项中定义方法来修改 state 中的值</p></blockquote></li></ol><ul><li>以下代码中的 update 方法用来修改 state 属性中的值</li></ul><pre><code>import &#123; ref, computed, reactive &#125; from &quot;vue&quot;;import &#123; defineStore &#125; from &quot;pinia&quot;;export const useUserStore = defineStore(&quot;user&quot;, () =&gt; &#123;  // 定义的ref变量，相当于Option对象中的state 即相当于组件中的data  const username = ref(&quot;艾编程&quot;);  const age = ref(17);  const hobbies = reactive([&quot;画画&quot;, &quot;写字&quot;]);  // 计算属性  相当于Option对象的getters，即相当于组件中的computed  const identity = computed(() =&gt; &#123;    return age.value &gt;= 18 ? &quot;成年&quot; : &quot;未成年&quot;;  &#125;);  // 函数，相当于Option对象的actions，即相当于组件中的methods  function update() &#123;    username.value = &quot;清心&quot;;    age.value = 33;    hobbies.push(&quot;喝歌&quot;);  &#125;  // 对外暴露属性和方法  return &#123;    username,    age,    identity,    update,    hobbies,  &#125;;&#125;);</code></pre><ol start="5"><li>注意事项<blockquote><p>我们没有办法替换掉<code>store</code>的<code>state</code>，因为那样会破坏其响应性。</p></blockquote></li></ol><ul><li>即使你使用<code>store.$state</code>来重新给 state 赋值，也无计于事。因为<code>store.$state</code>代码内部本质是调用了<code>sotre.$patch</code>来实现打补丁修改<code>state</code>某些属性值。</li></ul><pre><code>// 以下代码实际上并没有替换掉整个stateuserStore.$state = &#123; username: &quot;清心&quot; &#125;;// 上面代码相当于内部调用了$patch()方法，如下userStore.$patch(&#123; username: &quot;清心&quot; &#125;);</code></pre><ol start="6"><li>订阅 state<blockquote><p>你可以通过 store 的 <code>$subscribe()</code> 方法侦听 state 及其变化。当 state 的值发生改变时就会触发<code>$subscribe()</code>方法及回调函数。比起普通的 <code>watch()</code>，使用 <code>$subscribe()</code> 的好处是 <code>subscriptions</code> 在 <code>patch</code> 后<strong>只触发一次</strong></p></blockquote></li></ol><ul><li>使用<code>store.$patch()</code>方法一次修改多个 state 的值，只会触发一次<code>$subscribe()</code>方法的执行</li></ul><blockquote><p>语法</p></blockquote><pre><code>const stop = store.$subscribe(  (mutation, state) =&gt; &#123;    /*      * mutation主要包含三个属性值：      *   events：当前state改变的具体数据都在该对象上      *   storeId：是当前store的id      *   type：用于记录这次数据变化是通过什么途径，主要有三个分别是      *         “direct” ：直接修改 , 如：store.count++                ”patch object“ ：通过 $patch 传递对象的方式改变的                “patch function” ：通过 $patch 传递函数的方式改变的      *      * */    // 我们就可以在此处监听store中值的变化，当变化为某个值的时候，去做一些业务操作之类的  &#125;,  &#123;    /*     * 第二个参数options对象，是各种配置参数     * detached:布尔值，默认是 false，正常情况下，当订阅所在的组件被卸载时，订阅将被停止删除， 如果设置detached值为 true 时，即使所在组件被卸载，订阅依然在生效     * immediate，deep，flush等等参数 和vue3 watch的参数是一样的     *     * */  &#125;);// 停止订阅stop();</code></pre><blockquote><p>代码演示</p></blockquote><ul><li>定义 store</li></ul><pre><code>import &#123; ref &#125; from &quot;vue&quot;;import &#123; defineStore &#125; from &quot;pinia&quot;;export const useCountStore = defineStore(&quot;count&quot;, () =&gt; &#123;  const count = ref(10);  const num = ref(1);  return &#123;    count,    num,  &#125;;&#125;);</code></pre><ul><li>使用<code>store</code>，并订阅<code>state</code></li></ul><pre><code>&lt;script setup&gt;  import &#123; watch &#125; from &quot;vue&quot;;  import &#123; storeToRefs &#125; from &quot;pinia&quot;;  import &#123; useCountStore &#125; from &quot;./store/count&quot;;  const countStore = useCountStore();  // 解构state  const &#123; count, num &#125; = storeToRefs(countStore);  // 修改值  function add() &#123;    countStore.$patch(() =&gt; &#123;      count.value++;      num.value++;    &#125;);  &#125;  // 订阅  const stop = countStore.$subscribe((mutation, state) =&gt; &#123;    console.log(&quot;改变后count的值&quot;, state.count);  &#125;);&lt;/script&gt;&lt;template&gt;  &lt;div&gt;count的值：&#123;&#123; count &#125;&#125;&lt;/div&gt;  &lt;div&gt;num的值&#123;&#123; num &#125;&#125;&lt;/div&gt;  &lt;button @click=&quot;add&quot;&gt;count++&lt;/button&gt;  &lt;button @click=&quot;stop()&quot;&gt;停止订阅&lt;/button&gt;&lt;/template&gt;</code></pre><h3 id="三、深入-Getter"><a href="#三、深入-Getter" class="headerlink" title="三、深入 Getter"></a>三、深入 Getter</h3><blockquote><p><code>Getter</code> 完全等同于 <code>store</code> 的 <code>state</code> 的计算值。可以通过 <code>defineStore()</code> 中的 <code>getters</code> 属性来定义它们。</p><p><strong>推荐</strong>使用箭头函数，并且它将接收 <code>state</code> 作为第一个参数</p></blockquote><pre><code>import &#123; defineStore &#125; from &quot;pinia&quot;;export const useCountStore = defineStore(&quot;count&quot;, &#123;  state: () =&gt; &#123;    return &#123;      count: 10,    &#125;;  &#125;,  getters: &#123;    doubleCount: (state) =&gt; state.count * 2,    price: (state) =&gt; &quot;$&quot; + state.count,  &#125;,&#125;);</code></pre><ol><li>Getter 中的 this<blockquote><p>使用普通函数（非箭头函数）定义<code>getter</code>时，<code>getter</code>函数内部的 this 指向整个 store 实例。</p></blockquote></li></ol><ul><li>我们可以通过<code>this</code>问<code>state</code>、<code>getter</code>、<code>actions</code></li></ul><pre><code>import &#123; defineStore &#125; from &quot;pinia&quot;;export const useCountStore = defineStore(&quot;count&quot;, &#123;  state: () =&gt; &#123;    return &#123;      count: 10,    &#125;;  &#125;,  getters: &#123;    doubleCount: (state) =&gt; state.count * 2,    price() &#123;      return this.fn() + &quot;$&quot; + this.doubleCount;    &#125;,  &#125;,  actions: &#123;    fn() &#123;      return &quot;价格：&quot;;    &#125;,  &#125;,&#125;);</code></pre><ol start="2"><li>向 getter 传递参数<blockquote><p>Getter 只是幕后的计算属性，所以不可以向它们传递任何参数。不过，你可以从 getter 返回一个函数，该函数可以接受任意参数</p></blockquote></li></ol><pre><code>const sum = computed(() =&gt; &#123;  // 这里的数据相当于被缓存  // 返回一个带有函数的函数，函数本身不会被缓存，因为他并不是一个具体的值  return (item) =&gt; total + item;&#125;);</code></pre><blockquote><p>请注意</p></blockquote><ul><li>当你这样做时，<code>getter</code>将不再被缓存，它们只是一个被你调用的函数。</li><li>不过，你可以在<code>getter</code>本身中缓存一些结果，虽然这种做法并不常见，但有证明表明它的性能会更好</li></ul><pre><code>import &#123; reactive, computed &#125; from &quot;vue&quot;;import &#123; defineStore &#125; from &quot;pinia&quot;;export const useUserStore = defineStore(&quot;user&quot;, () =&gt; &#123;  const list = reactive([1, 2, 3, 4, 5, 6]);  const sum = computed(() =&gt; &#123;    // 计算数组中所有数之和    const total = list.reduce((total, prev, next) =&gt; total + prev, 0);    console.log(&quot;total相当于缓存下来了&quot;);    return (item) =&gt; total + item;  &#125;);  return &#123;    sum,    list,  &#125;;&#125;);</code></pre><ul><li>测试代码</li></ul><pre><code>&lt;script setup&gt;  import &#123; storeToRefs &#125; from &quot;pinia&quot;;  import &#123; useUserStore &#125; from &quot;../src/store/user.js&quot;;  const userStore = useUserStore();  console.log(userStore.sum(4));  console.log(userStore.sum(5));  console.log(userStore.sum(6));  console.log(userStore.sum(7));  userStore.list.push(20);  console.log(userStore.sum(4));&lt;/script&gt;</code></pre><h3 id="四、深入-Action"><a href="#四、深入-Action" class="headerlink" title="四、深入 Action"></a>四、深入 Action</h3><ol><li>action 的异步写法<blockquote><p>在 setup store 中，我们像写正常的异步方法一样来书写就可</p></blockquote></li></ol><ul><li>以下代码中的 <code>getInfo</code> 方法，根据 id 来返回对应的用户条数</li></ul><pre><code>import axios from &quot;axios&quot;;import &#123; reactive, ref &#125; from &quot;vue&quot;;import &#123; defineStore &#125; from &quot;pinia&quot;;export const useUserStore = defineStore(&quot;user&quot;, () =&gt; &#123;  // 保存获取的数据  let result = ref([]);  // 异步获取数据  async function getInfo(id) &#123;    const list = await axios.get(      `https://www.fastmock.site/mock/6ec78e345df340241e1f5043f0167833/icode/users/list?num=$&#123;id&#125;`    );    result.value = list.data.data.userslist || [];  &#125;  return &#123;    getInfo,    result,  &#125;;&#125;);</code></pre><ul><li>代码测试</li></ul><pre><code>&lt;script setup&gt;  import &#123; ref &#125; from &quot;vue&quot;;  import &#123; useUserStore &#125; from &quot;../src/store/user.js&quot;;  const userStore = useUserStore();  // 获取数据  userStore.getInfo(3);&lt;/script&gt;&lt;template&gt;  &lt;div v-for=&quot;item in userStore.result&quot;&gt;    &lt;h3&gt;&#123;&#123; item.username &#125;&#125;&lt;/h3&gt;    &lt;p&gt;&#123;&#123; item.desc &#125;&#125;&lt;/p&gt;  &lt;/div&gt;&lt;/template&gt;</code></pre><ol start="2"><li>订阅 action<blockquote><p>我们可以通过<code>store.$onAction()</code>来监听 action 和它们的返回结果，即 action 被调用时就会触发<code>$onAction</code>。</p></blockquote></li></ol><ul><li><p><code>store.$onAction()</code>方法的第一个参数是一个回调函数，回调函数会在 <code>action</code> 本身<strong>之前</strong>执行。</p></li><li><p>回调函数的参数对象的每个属性的作用如下</p></li></ul><pre><code>userStore.$onAction(  (&#123;    name, // action 名称    store, // store 实例，类似 `someStore`    args, // 传递给 action 的参数数组    after, // 在 action执行完后，会调用after方法的回调    onError, // action 抛出错误或 reject 时执行执行该方法的回调  &#125;) =&gt; &#123;    console.log(&quot;name&quot;, name);    console.log(&quot;store&quot;, &quot;store&quot;);    console.log(&quot;args&quot;, args);    // 在action 函数执行完后调用，    // 如果action是一个异步方法，会在返回后的promise的then方法前调用。    // result为 action执行后的返回结果    after((result) =&gt; &#123;      console.log(&quot;after回调执行&quot;, result);    &#125;);  &#125;);</code></pre><blockquote><p>代码演示</p></blockquote><ul><li>在 store 文件夹下新建<code>user.js</code>文件，内容如下：</li></ul><pre><code>import axios from &quot;axios&quot;;import &#123; defineStore &#125; from &quot;pinia&quot;;import &#123; ref &#125; from &quot;vue&quot;;let url =  &quot;https://www.fastmock.site/mock/6ec78e345df340241e1f5043f0167833/icode/users/list?num=&quot;;export const useUserStore = defineStore(&quot;user&quot;, () =&gt; &#123;  let result = ref([]);  // 请求数据方法  async function getInfo(id) &#123;    console.log(&quot;action的getInfo方法正在执行&quot;);    const list = await axios.get(`$&#123;url&#125;$&#123;id&#125;`);    result.value = list.data.data.userslist || [];  &#125;  // 对外暴露属性  return &#123;    getInfo,    result,  &#125;;&#125;);</code></pre><ul><li>在组件中使用 store，App.vue文件内容如下：</li></ul><pre><code>&lt;script setup&gt;  import &#123; storeToRefs &#125; from &quot;pinia&quot;;  import &#123; useUserStore &#125; from &quot;../src/store/user.js&quot;;  const userStore = useUserStore();  const &#123; getInfo &#125; = userStore;  // 订阅action  userStore.$onAction(    (&#123;      name, // action 名称      store, // store 实例，类似 `someStore`      args, // 传递给 action 的参数数组      after, // 在 action执行完后，会调用after方法的回调      onError, // action 抛出错误或 reject 时执行执行该方法的回调    &#125;) =&gt; &#123;      console.log(&quot;name&quot;, name);      console.log(&quot;store&quot;, &quot;store&quot;);      console.log(&quot;args&quot;, args);      // 在action 函数执行完后调用，      // 如果action是一个异步方法，会在返回后的promise的then方法前调用。      // result为 action执行后的返回结果      after((result) =&gt; &#123;        console.log(&quot;after回调执行&quot;, result);      &#125;);    &#125;  );  // 请求获取数据  getInfo(3);&lt;/script&gt;&lt;template&gt;  &lt;div v-for=&quot;item in userStore.result&quot;&gt;    &lt;h3&gt;&#123;&#123; item.username &#125;&#125;&lt;/h3&gt;    &lt;p&gt;&#123;&#123; item.desc &#125;&#125;&lt;/p&gt;  &lt;/div&gt;&lt;/template&gt;</code></pre><ul><li>想要在<code>action</code>执行前做相关操作，可以直接写在的<code>$onAction()</code>的回调函数中</li><li>想要在<code>action</code>执行后做相关操作，可以直接写在 <code>after</code> 方法的回调函数中</li></ul><h3 id="五、组合式-Store"><a href="#五、组合式-Store" class="headerlink" title="五、组合式 Store"></a>五、组合式 Store</h3><blockquote><p>你可以在一个 store 中使用另一个 store，使用步骤如下：</p></blockquote><ul><li>在当前 store 的顶部直接通过<code>import</code>导入另一个 store</li><li>调用导入的 store，创建 store 实例</li><li>在需要使用的地方，直接通过 store 实例来访问其身上的 state、getter、action</li></ul><pre><code>import &#123; defineStore &#125; from &quot;pinia&quot;;import &#123; useBStore &#125; from &quot;../store/useB.js&quot;;// 注意，不要在这里  const bStore=useBStore()export const useAStore = defineStore(&quot;useA&quot;, &#123;  state() &#123;    return &#123;      a: useBStore().m, // 使用别一个store中数据    &#125;;  &#125;,&#125;);</code></pre><pre><code>import &#123; defineStore &#125; from &quot;pinia&quot;;import &#123; useAStore &#125; from &quot;../store/useA.js&quot;;// 注意，不要在这里  const aStore=useAStore()export const useBStore = defineStore(&quot;useB&quot;, () =&gt; &#123;  const m = 10;  return &#123;    m,  &#125;;&#125;);</code></pre><blockquote><p>注意事项:</p></blockquote><ul><li>如果两个或更多的 store <strong>相互使用</strong><ul><li>它们不可以通过<code> getters</code> 或 <code>actions</code> 创建一个无限循环。</li><li>它们也不可以同时在它们的 <code>setup</code> 函数中直接互相读取对方的 state</li></ul></li></ul><h3 id="六、组件间通信的方案"><a href="#六、组件间通信的方案" class="headerlink" title="六、组件间通信的方案"></a>六、组件间通信的方案</h3><blockquote><p>大家可以自行去复习下我们之前讲过的通信方案，包括（使用方法，场景）</p></blockquote><ul><li><code>props</code>父子组件间通信</li><li><code>emit</code>父子组件间通信</li><li><code>v-model</code>父子组件间通信</li><li>依赖注入（provide &#x2F; inject）</li><li><code>$attrs</code>透传属性</li><li>任意组件间通信- 发布与订阅</li><li><code>ref</code> 获取子组件实例</li><li><code>$parent</code>访问父组件实例</li><li><code>$children</code>访问子组件实例</li><li><code>$root</code>访问根组件</li><li><code>pinia</code>全局状态管理</li></ul><h3 id="七、Teleport内置组件"><a href="#七、Teleport内置组件" class="headerlink" title="七、Teleport内置组件"></a>七、Teleport内置组件</h3><blockquote><p><code>&lt;Teleport&gt;</code>是一个内置组件，它可以将一个组件内部的一部分模板 “传送” 到该组件的 DOM 结构外层的位置去。<br><code>&lt;Teleport&gt;</code>组件相关内容如下：</p></blockquote><ul><li><code>to</code> 属性</li><li>为什么需要 <code>Teleport</code> 组件</li><li>搭配组件使用</li><li>禁用 <code>Teleport</code></li><li>实战应用：根据屏幕尺寸渲染县浮窗</li><li>多个 <code>Teleport</code> 共享目标</li></ul><h4 id="to-属性"><a href="#to-属性" class="headerlink" title="to 属性"></a>to 属性</h4><blockquote><p><code>&lt;Teleport&gt;</code>接收一个 <code>to</code> prop 来指定传送的目标。<code>to</code> 的值可以是一个 <code>CSS </code>选择器字符串，也可以是一个 <code>DOM</code> 元素对象。</p></blockquote><pre><code>&lt;Teleport to=&quot;#id&quot;&gt;&lt;/Teleport&gt;&lt;Teleport to=&quot;.class&quot;&gt; &lt;/Teleport&gt;&lt;Teleport to=&quot;[title=&#39;xxx&#39;]&quot;&gt; &lt;/Teleport&gt;&lt;Teleport to=&quot;tagname&quot;&gt; &lt;/Teleport&gt;</code></pre><blockquote><p>代码示例</p></blockquote><ul><li>下面Modal组件中这段代码的作用就是告诉 Vue“把<code>&lt;Teleport&gt;</code>中的模板片段传送到 body 标签下”。</li></ul><pre><code>&lt;!--Modal组件--&gt;&lt;Teleport to=&quot;body&quot;&gt;  &lt;div class=&quot;modal-mask&quot;&gt;    &lt;div class=&quot;modal-container&quot;&gt;弹窗&lt;/div&gt;  &lt;/div&gt;&lt;/Teleport&gt;</code></pre><ul><li>在 App 根组件中使用 Modal 组件</li></ul><pre><code>&lt;script setup&gt;  import Modal from &quot;./components/Modal.vue&quot;;&lt;/script&gt;&lt;template&gt;  &lt;div class=&quot;main&quot;&gt;    &lt;Modal&gt;&lt;/Modal&gt;  &lt;/div&gt;&lt;/template&gt;</code></pre><ul><li>以上代码最终渲染后的 HTML 结构如下，<code>.modal-mask</code>对应的 Div 从<code>.main</code>中移除添加到了 body 中</li></ul><pre><code>&lt;body&gt;  &lt;div id=&quot;app&quot;&gt;    &lt;div class=&quot;main&quot;&gt;      &lt;!--.modal-maks从这里被移除，添加到了body中--&gt;    &lt;/div&gt;  &lt;/div&gt;  &lt;!--.modal-mask被添加到了body中--&gt;  &lt;div class=&quot;modal-mask&quot;&gt;    &lt;div class=&quot;modal-container&quot;&gt;弹窗&lt;/div&gt;  &lt;/div&gt;&lt;/body&gt;</code></pre><h4 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h4><blockquote><p><code>&lt;Teleport&gt;</code> 挂载时，传送的 to 目标必须已经存在于 DOM 中。理想情况下，这应该是整个 Vue 应用 DOM 树外部的一个元素。</p><p>如果目标元素也是由 Vue 渲染的，你需要确保在挂载 <code>&lt;Teleport&gt;</code> 之前先挂载该元素。</p></blockquote><blockquote><p>以下为错误示例</p></blockquote><ul><li>因为<code>&lt;Teleport&gt;</code>挂载前，<code>h3.title</code>元素还没有被挂载到页面中</li></ul><pre><code>&lt;div class=&quot;main&quot;&gt;  &lt;Teleport to=&quot;h3.title&quot;&gt;    &lt;div class=&quot;a&quot;&gt;A&lt;/div&gt;  &lt;/Teleport&gt;&lt;/div&gt;&lt;h3 class=&quot;title&quot;&gt;&lt;/h3&gt;</code></pre><ul><li>以下为正确示例</li></ul><pre><code>&lt;h3 class=&quot;title&quot;&gt;&lt;/h3&gt;&lt;div class=&quot;main&quot;&gt;  &lt;Teleport to=&quot;h3.title&quot;&gt;    &lt;div class=&quot;a&quot;&gt;A&lt;/div&gt;  &lt;/Teleport&gt;&lt;/div&gt;</code></pre><h4 id="为什么需要-Teleport-组件"><a href="#为什么需要-Teleport-组件" class="headerlink" title="为什么需要 Teleport 组件"></a>为什么需要 Teleport 组件</h4><blockquote><p>在实际开发中我们可能会遇到这样的场景：</p><ul><li>一个组件模板的一部分在逻辑上从属于该组件，但从整个应用视图的角度来看，它在 DOM 中应该被渲染在整个 Vue 应用外部的其他地方。</li></ul></blockquote><ul><li>我们来看下面这个弹窗的例子</li></ul><pre><code>&lt;!--Modal.vue--&gt;&lt;template&gt;  &lt;div class=&quot;main&quot;&gt;    &lt;div class=&quot;modal-mask&quot;&gt;      &lt;div class=&quot;modal-container&quot;&gt;        &lt;button&gt;确认&lt;/button&gt;      &lt;/div&gt;    &lt;/div&gt;  &lt;/div&gt;&lt;/template&gt;&lt;style scoped&gt;  .main &#123;    width: 300px;    height: 300px;    border: 2px solid red;    margin: 100px auto;    /* transform: translate(10px); */  &#125;  /* 弹窗样式 */  .modal-mask &#123;    width: 100%;    height: 100%;    background-color: rgba(0, 0, 0, 0.5);    position: fixed;    left: 0;    top: 0;    display: flex;  &#125;  .modal-container &#123;    width: 300px;    margin: auto;    padding: 20px;    background-color: #fff;    border-radius: 3px;  &#125;&lt;/style&gt;</code></pre><ul><li><p>以上代码最终渲染效果如下：</p><img src="./src/teleport组件实例1.png"></li><li><p>如果我在<code>.main</code>中添加如下样式</p></li></ul><pre><code>.main &#123;  transform: translate(0px);&#125;</code></pre><ul><li><p>最终渲染出来的效果如下，并不是我们期望的效果</p><img src="./src/teleport组件实例2.png"></li><li><p>是因为固定定位元素的祖先元素添加了 <code>transform</code>、<code>perspective</code>、<code>filter</code> 或 <code>backdrop-filter</code> 属性非 none 时，其相的容器由视口改为该祖先。（即非 body 而为该祖先元素）</p></li><li><p>有了<code>&lt;Teleport&gt;</code>我们就不需要再顾虑 DOM 结构问题，使用<code>&lt;Teleport&gt;</code>组件并结合 to 属性即可指定弹窗的具体 DOM 位置。</p></li><li><p>如下代码中的<code>.modal-mask</code>渲染后会被移动到 body 标签中</p></li></ul><pre><code>&lt;template&gt;  &lt;div class=&quot;main&quot;&gt;    &lt;Teleport to=&quot;body&quot;&gt;      &lt;div class=&quot;modal-mask&quot;&gt;        &lt;div class=&quot;modal-container&quot;&gt;          &lt;button&gt;确认&lt;/button&gt;        &lt;/div&gt;      &lt;/div&gt;    &lt;/Teleport&gt;  &lt;/div&gt;&lt;/template&gt;</code></pre><h4 id="搭配组件使用"><a href="#搭配组件使用" class="headerlink" title="搭配组件使用"></a>搭配组件使用</h4><blockquote><p><code>&lt;Teleport&gt;</code>只改变了渲染的 DOM 结构，它<strong>不会影响</strong>组件间的逻辑关系。</p><p>也就是说，如果 <code>&lt;Teleport&gt;</code> 包含了一个组件，那么该组件始终和这个使用了 <code>&lt;teleport&gt;</code> 的组件保持逻辑上的父子关系。传入的 props 和触发的事件也会照常工作。</p></blockquote><ul><li>Modal 组件</li></ul><pre><code>&lt;script setup&gt;  import Modal from &quot;./components/Modal.vue&quot;;&lt;/script&gt;&lt;template&gt;  &lt;div class=&quot;main&quot;&gt;    &lt;Teleport to=&quot;body&quot;&gt;      &lt;Modal title=&quot;弹窗标题&quot;&gt;&lt;/Modal&gt;    &lt;/Teleport&gt;  &lt;/div&gt;&lt;/template&gt;</code></pre><ul><li>App 组件中，在 <code>&lt;Teleport&gt;</code> 组件中使用 <code>&lt;Modal&gt;</code> 组件</li></ul><pre><code>&lt;script setup&gt;  const props = defineProps([&quot;title&quot;]);&lt;/script&gt;&lt;template&gt;  &lt;!--Modal组件--&gt;  &lt;div class=&quot;modal-mask&quot;&gt;    &lt;div class=&quot;modal-container&quot;&gt;      &lt;div class=&quot;modal-header&quot;&gt;&#123;&#123; title &#125;&#125;&lt;/div&gt;    &lt;/div&gt;  &lt;/div&gt;&lt;/template&gt;</code></pre><ul><li>最终渲染后的 HTML 结构如下：</li></ul><pre><code>&lt;div id=&quot;app&quot;&gt;  &lt;div class=&quot;main&quot;&gt;&lt;/div&gt;&lt;/div&gt;&lt;div class=&quot;modal-mask&quot;&gt;  &lt;div class=&quot;modal-container&quot;&gt;    &lt;div class=&quot;modal-header&quot;&gt;弹窗标题&lt;/div&gt;  &lt;/div&gt;&lt;/div&gt;</code></pre><h4 id="禁用-Teleport"><a href="#禁用-Teleport" class="headerlink" title="禁用 Teleport"></a>禁用 Teleport</h4><blockquote><p>我们可以通过对 <code>&lt;Teleport&gt;</code> 动态地传入一个 <code>disabled</code> prop 来决定使用还是禁用<code>&lt;Teleport&gt;</code>组件。</p></blockquote><ul><li>值为 true 表示禁用</li><li>flase 表示启用</li></ul><pre><code>&lt;Teleport :disabled=&quot;isMobile&quot;&gt; ... &lt;/Teleport&gt;</code></pre><h4 id="实战应用：根据屏幕大小渲染悬浮窗"><a href="#实战应用：根据屏幕大小渲染悬浮窗" class="headerlink" title="实战应用：根据屏幕大小渲染悬浮窗"></a>实战应用：根据屏幕大小渲染悬浮窗</h4><ul><li>当屏幕尺寸 &gt; 750 时，元素相对于浏览器左侧悬浮显示</li><li>当屏幕尺寸 &lt;&#x3D; 750 时， 元素在组件内全屏显示</li></ul><blockquote><p>实现步骤</p></blockquote><ul><li>定义Menu导航组件，该组件内定义了两套样式，分别用来展示不同状态下的样式<ul><li><code>.fixed</code>菜单相对浏览器固定定位在左侧，显示为左侧悬浮菜单效果</li><li><code>.relative</code>菜单为普通的块元素，显示为全屏菜单效果</li></ul></li><li>将<code>.sidebar</code>放置在<code>&lt;Teleport&gt;</code>组件中<ul><li>添加to属性，用来控制<code>.sidebar</code>渲染的 DOM 结构位置</li><li>添加<code>disabled</code>属性，用来控制是禁用还是使用<code>&lt;Teleport&gt;</code>组件</li></ul></li></ul><pre><code>&lt;!--Menu.vue 组件--&gt;&lt;script setup&gt;  import &#123; ref &#125; from &quot;vue&quot;;  const disabled = ref(false);&lt;/script&gt;&lt;template&gt;  &lt;Teleport to=&quot;body&quot; :disabled=&quot;disabled&quot;&gt;    &lt;div class=&quot;sidebar&quot;&gt;&lt;/div&gt;  &lt;/Teleport&gt;&lt;/template&gt;&lt;style scoped&gt;  .fixed &#123;    width: 150px;    height: 200px;    background-color: skyblue;    position: fixed;    left: 0px;    top: 50px;  &#125;  .relative &#123;    width: 100%;    height: 200px;    background-color: skyblue;  &#125;&lt;/style&gt;</code></pre><ul><li>根据屏幕宽度来决定<code>&lt;Teleport&gt;</code>组件的使用情况，并为<code>.sidebar</code>元素动态添加 class<ul><li>如果屏幕宽 <code>&gt; 750px</code>，启用 <code>Teleport</code> 组件，变量<code>disabled.value=false</code>，同时为<code>.sidebar</code>添加<code>fixed </code>class</li><li>如果屏幕宽 <code>&lt;= 750px</code>，禁用 <code>Teleport</code> 组件，变量<code>disabled.value=true</code>,同时为<code>.sidebar</code>添加<code>relative</code> class</li></ul></li><li>根据<code>disabled</code>的值来决定当前Menu导航根元素对应的 CSS 样式</li></ul><pre><code>&lt;script setup&gt;  import &#123; ref, onMounted, onUnmounted, computed &#125; from &quot;vue&quot;;  const disabled = ref(false);  // const modalClass = ref(&quot;fixed&quot;)  // 计算属性,根据disabled的值来决来modalClass的值  const modalClass = computed(() =&gt; &#123;    return disabled.value ? &quot;relative&quot; : &quot;fixed&quot;;  &#125;);  // 根据浏览器当前窗口大小，决定是启用还是禁用Teleport组件  function onResize() &#123;    // 获取浏览器的宽    const w = window.innerWidth;    if (w &gt; 750) &#123;      // pc 端,悬浮效果 不能禁用Teleport      disabled.value = false;      // modalClass.value = &quot;fixed&quot;    &#125; else &#123;      // 移动端  正常显示, 禁用Teleport      disabled.value = true;      // modalClass.value = &quot;relative&quot;    &#125;  &#125;  // 调用fn  onResize();  // 组件挂载成功，添加事件监听  onMounted(() =&gt; &#123;    window.addEventListener(&quot;resize&quot;, onResize);  &#125;);  // 卸载组件时,要移除事件监听  onUnmounted(() =&gt; &#123;    window.removeEventListener(&quot;resize&quot;, fn);  &#125;);&lt;/script&gt;&lt;template&gt;  &lt;!--         当浏览器宽&gt;750px  不能禁用Teleport  class=&quot;fixed&quot;        当浏览器宽&lt;750px  禁用Teleport class=&quot;relative&quot;     --&gt;  &lt;Teleport to=&quot;body&quot; :disabled=&quot;disabled&quot;&gt;    &lt;div class=&quot;sidebar&quot; :class=&quot;modalClass&quot;&gt;&lt;/div&gt;  &lt;/Teleport&gt;&lt;/template&gt;&lt;style scoped&gt;  .sidebar &#123;  &#125;  /* 左侧悬浮菜单样式 */  .fixed &#123;    width: 150px;    height: 200px;    background-color: skyblue;    position: fixed;    top: 100px;    left: 0;  &#125;  /* 正常渲染的样式 */  .relative &#123;    width: 100%;    height: 200px;    background-color: tomato;  &#125;&lt;/style&gt;</code></pre><ul><li>App 组件中使用Menu导航组件</li></ul><pre><code>&lt;script setup&gt;  import Menu from &quot;./components/Menu.vue&quot;;&lt;/script&gt;&lt;template&gt;  &lt;div class=&quot;main&quot;&gt;    &lt;menu&gt;&lt;/menu&gt;  &lt;/div&gt;&lt;/template&gt;&lt;style scoped&gt;  /* 让页面产生滚动条 */  :global(body) &#123;    height: 3000px;  &#125;  .main &#123;    width: 100%;    height: 200px;    border: 1px solid blue;    margin: 100px auto;    transform: translate(0px); /* 设置的干扰因素 */  &#125;&lt;/style&gt;</code></pre><h4 id="多个-Teleport-共享目标"><a href="#多个-Teleport-共享目标" class="headerlink" title="多个 Teleport 共享目标"></a>多个 Teleport 共享目标</h4><blockquote><p>我们可以将多个<code>&lt;Teleport&gt;</code>组件的内容挂载在同一个目标元素上，他们的挂载顺序书写时的顺序。</p></blockquote><ul><li>代码示例</li></ul><pre><code>&lt;Teleport to=&quot;.sidebar&quot;&gt;  &lt;div class=&quot;a&quot;&gt;A&lt;/div&gt;&lt;/Teleport&gt;&lt;Teleport to=&quot;.sidebar&quot;&gt;  &lt;div class=&quot;b&quot;&gt;B&lt;/div&gt;&lt;/Teleport&gt;</code></pre><ul><li>以上代码渲染的结果为：</li></ul><pre><code>&lt;div data-v-94fcd891=&quot;&quot; class=&quot;sidebar fixed&quot;&gt;  &lt;div class=&quot;a&quot;&gt;A&lt;/div&gt;  &lt;div class=&quot;b&quot;&gt;B&lt;/div&gt;&lt;/div&gt;</code></pre><h3 id="八、ESLint"><a href="#八、ESLint" class="headerlink" title="八、ESLint"></a>八、ESLint</h3><blockquote><p>当我们在进行团队协作开发项目时，每个人的代码习惯和理解的差异会导致团队中出现各种各样规范的代码。如：有的人认为语句后应加冒号，有的人认为不应该加；有的人习惯用单引号来包裹字符串，有的人习惯用双引号包裹字符串等之类的各种问题。</p></blockquote><blockquote><p>这种差异性会造成团队协作效率低下，也会影响项目的健壮性和可维护性。所以我们需要对代码风格进行规范，这种规范有以下好处：</p></blockquote><ul><li>代码风格保持统一</li><li>并且可以在代码运行之前检测出错误和 bug，提高协作开发效率</li></ul><h4 id="什么是-ESLint"><a href="#什么是-ESLint" class="headerlink" title="什么是 ESLint"></a>什么是 ESLint</h4><blockquote><p>ESLint 是一个 JavaScript 的 Lint（静态代码分析）工具，其目的使代码风格更加一致并避免错误。他可以帮助我们在运行代码前就发现语法错误和潜在的 bug，非常适合用于制定团队代码规范。</p><ul><li>ESLint 官网：<a href="http://eslint.cn/">http://eslint.cn/</a></li></ul></blockquote><h4 id="ESLint-的基本使用"><a href="#ESLint-的基本使用" class="headerlink" title="ESLint 的基本使用"></a>ESLint 的基本使用</h4><blockquote><p>ESLint 是用来对项目中的代码进行统一规范，所以 ESLint 必须结合项目来使用。</p></blockquote><blockquote><p>首先我们需要创建一个项目目录，然后执行以下命令，初始化<code>package.json</code>文件</p></blockquote><pre><code>npm init -y   #初始化package.json文件</code></pre><blockquote><p>你可以使用该命令安装并配置 ESLint</p></blockquote><pre><code>npm init @eslint/config</code></pre><ul><li>以上命令执行后，在控制台会提出一系列的问题让我们来选择，根据自身项目情况选择即可。</li></ul><blockquote><p>安装成功后，在当前根目录下会生成<code>.eslintrc.js</code>文件(选择了js格式的配置文件)，该文件为 <code>ESLint</code> 的配置文件。默认生成后的内容如下：</p></blockquote><pre><code>module.exports = &#123;  env: &#123;    browser: true,    commonjs: true,    es2021: true,  &#125;,  extends: &quot;eslint:recommended&quot;,  overrides: [    &#123;      env: &#123;        node: true,      &#125;,      files: [&quot;.eslintrc.&#123;js,cjs&#125;&quot;],      parserOptions: &#123;        sourceType: &quot;script&quot;,      &#125;,    &#125;,  ],  parserOptions: &#123;    ecmaVersion: &quot;latest&quot;,  &#125;,  rules: &#123;&#125;,&#125;;</code></pre><ul><li>以上配置文件中各个配置项的具体含义和作用，我们放在后面 ESLint 配置文件版块再讲。</li></ul><h4 id="使用-ESLint-工具"><a href="#使用-ESLint-工具" class="headerlink" title="使用 ESLint 工具"></a>使用 ESLint 工具</h4><blockquote><p>我们可以在当前项目下新建<code>src/test.js</code>文件，然后书写如下代码</p></blockquote><pre><code>function sum(a, b) &#123;  console.log(a + b);  return a + b;&#125;</code></pre><blockquote><p>使用 ESLint 命令行检查<code>src/test.js</code>文件中代码</p></blockquote><pre><code># 检查src/test.js文件中代码是否符合规范npx eslint ./src/test.js # 检查 ./src 目录下的所有JS文件是否符合规范npx eslint ./src  </code></pre><blockquote><p>会发现，在控制台抛出了如下一个错误：sun定义了但从未使用</p></blockquote><blockquote><p>如果我们把配置文件中的<code>&quot;extends&quot;: &quot;eslint:recommended&quot;</code>, 换成 <code>&quot;extends&quot;: &quot;eslint:all&quot;</code>。</p><ul><li>再执行 <code>npx eslint ./src</code>时，会抛出更多错误</li></ul></blockquote><blockquote><p>原因在于</p></blockquote><ul><li><code>eslint:recommended</code>内置规范包，只有 60 条左右的代码规范</li><li><code>eslint:all</code>内置规范包，包含所有（280 条）的代码规范</li></ul><h4 id="修复问题-–fix"><a href="#修复问题-–fix" class="headerlink" title="修复问题 –fix"></a>修复问题 –fix</h4><blockquote><p>执行以下命令可以修复存在的部分规范问题，但不是所有的问题都可以用此项来修复</p></blockquote><pre><code>npx eslint --fix ./src</code></pre><ul><li>命令执行后，部分问题会被自动修复，但仍有问题是没有办法修复的，需要人为去修复。</li><li>最终人为将代码修改成如下内容，然后执行<code>npx eslint ./src</code>命令后，将没有任何错误信息</li></ul><pre><code>&quot;use strict&quot;;const aa = 1,  bb = 2,  sum = function sum(a1, b1) &#123;    return a1 + b1;  &#125;;sum(aa, bb);</code></pre><h4 id="VSCode-中安装-ESLint-插件"><a href="#VSCode-中安装-ESLint-插件" class="headerlink" title="VSCode 中安装 ESLint 插件"></a>VSCode 中安装 ESLint 插件</h4><blockquote><p>通过前面的代码演示我们知道，只有当我们执行npx eslint …命令时，才会调用 eslint 来帮助我们检查代码。</p></blockquote><ul><li>如果我们想在编写代码的时候，一旦出现不符合要求的代码，就给你们提示，就需要借助 VSCode 的 ESLint 插件。</li><li>安装 ESLint 插件</li></ul><blockquote><p>VSCode 的 ESLint 插件对代码的检查规则是：</p></blockquote><ul><li>如果当前项目目录下有<code>.eslintrc</code>文件，就会按该文件中配置的规则来检测代码，</li><li>如果没有，就会按插件本身的默认规则来。</li></ul><h3 id="九、ESLint-配置文件"><a href="#九、ESLint-配置文件" class="headerlink" title="九、ESLint 配置文件"></a>九、ESLint 配置文件</h3><h4 id="配置文件格式"><a href="#配置文件格式" class="headerlink" title="配置文件格式"></a>配置文件格式</h4><blockquote><p>配置文件有<code>.js</code>、<code>.yml</code>、<code>.json</code> 三种格式。</p></blockquote><h4 id="env-节点"><a href="#env-节点" class="headerlink" title="env 节点"></a>env 节点</h4><blockquote><p>env 用于启用特定环境的全局变量。</p></blockquote><blockquote><p>由于 ESLint 的各种规范中，一般都不允许使用未在页面内声明的成员（变量），而在开发中经常会用到一些运行环境自带的全局变量，如：</p></blockquote><ul><li>浏览器中的 window、document等</li><li>nodejs 中的 __dirname 等</li><li>es2021 中的 WeakRef 等</li></ul><blockquote><p>如果我们没有启用任何特定环境全局变量，那我们在代码中使用了 <code>window</code>，<code>document</code> 时，ESLint 就会认为这两个变量没有定义，会抛出未定义的错误。</p></blockquote><blockquote><p>所以我们需要告诉 ESLint，当前代码运行在哪个环境中，这些环境下的全局变量检查时就不会报错</p></blockquote><blockquote><p>代码测式一</p></blockquote><pre><code>&quot;env&quot;: &#123;    &quot;browser&quot;: true,  //  启用浏览器环境下的全局变量&#125;,</code></pre><ul><li>如果 env 中指定了以上配置，以下代码在 ESLint 检测时，不会抛出错误</li></ul><pre><code>window.a = 1;</code></pre><ul><li>如果 env 中没有启用特定环境的全局变量，则代码在 ESLint 检测时，会抛出错误</li></ul><h4 id="extends-节点"><a href="#extends-节点" class="headerlink" title="extends 节点"></a>extends 节点</h4><blockquote><p><code>extends</code>用于配置 ESLint 使用哪种规则包来检查代码。</p></blockquote><blockquote><p>规则包分为以下 2 类：</p></blockquote><p>①、ESLint 内置规范包：</p><ul><li><code>eslint-all</code> 要使用全部 280 多个规则</li><li><code>eslint-recommended</code> 只需要满足部分核心规则</li></ul><pre><code>&quot;extends&quot;: &quot;eslint:recommended&quot;, // 使用内置的推荐规则包</code></pre><ul><li>eslint-all包与eslint-recommended包的所有规则，查阅 <a href="https://zh-hans.eslint.org/docs/latest/rules/">ESLint规则参考</a></li></ul><p>②、第三方规范包</p><ul><li><code>eslint-config-standard</code> 目前比较流行的一个标准规则包，<a href="https://www.npmjs.com/package/eslint-config-standard">standard 包使用教程</a></li><li><code>eslint-config-airbnb-base</code> 目前最流行的一个规则包，<a href="https://www.npmjs.com/package/eslint-config-airbnb-base">airbnb-base 包使用教程</a><blockquote><p>使用 <code>eslint-config-standard</code> 规则包</p></blockquote></li></ul><pre><code>extends: &quot;standard&quot;,    // 使用 eslint-config-standard 规则包</code></pre><ul><li>使用这个规则包之前，要执行以下命令安装相关包</li></ul><pre><code>npm install --save-dev eslint-config-standard eslint-plugin-promise eslint-plugin-import eslint-plugin-n</code></pre><ul><li>standard 包指定了哪些规则，可以在<code>node_modules/eslint-config-standard/index.js</code>中可以查看到，具体如下：</li></ul><pre><code>&#123;  &quot;parserOptions&quot;: &#123;    &quot;ecmaVersion&quot;: 2022,    &quot;ecmaFeatures&quot;: &#123;      &quot;jsx&quot;: true    &#125;,    &quot;sourceType&quot;: &quot;module&quot;  &#125;,  &quot;env&quot;: &#123;    &quot;es2021&quot;: true,    &quot;node&quot;: true  &#125;,  &quot;plugins&quot;: [    &quot;import&quot;,    &quot;n&quot;,    &quot;promise&quot;  ],  &quot;globals&quot;: &#123;    &quot;document&quot;: &quot;readonly&quot;,    &quot;navigator&quot;: &quot;readonly&quot;,    &quot;window&quot;: &quot;readonly&quot;  &#125;,  &quot;rules&quot;: &#123;    &quot;no-var&quot;: &quot;warn&quot;,    &quot;object-shorthand&quot;: [&quot;warn&quot;, &quot;properties&quot;],    &quot;accessor-pairs&quot;: [&quot;error&quot;, &#123; &quot;setWithoutGet&quot;: true, &quot;enforceForClassMembers&quot;: true &#125;],    &quot;array-bracket-spacing&quot;: [&quot;error&quot;, &quot;never&quot;],    &quot;array-callback-return&quot;: [&quot;error&quot;, &#123;      &quot;allowImplicit&quot;: false,      &quot;checkForEach&quot;: false    &#125;],    &quot;arrow-spacing&quot;: [&quot;error&quot;, &#123; &quot;before&quot;: true, &quot;after&quot;: true &#125;],    &quot;block-spacing&quot;: [&quot;error&quot;, &quot;always&quot;],    &quot;brace-style&quot;: [&quot;error&quot;, &quot;1tbs&quot;, &#123; &quot;allowSingleLine&quot;: true &#125;],    &quot;camelcase&quot;: [&quot;error&quot;, &#123;      &quot;allow&quot;: [&quot;^UNSAFE_&quot;],      &quot;properties&quot;: &quot;never&quot;,      &quot;ignoreGlobals&quot;: true    &#125;],    &quot;comma-dangle&quot;: [&quot;error&quot;, &#123;      &quot;arrays&quot;: &quot;never&quot;,      &quot;objects&quot;: &quot;never&quot;,      &quot;imports&quot;: &quot;never&quot;,      &quot;exports&quot;: &quot;never&quot;,      &quot;functions&quot;: &quot;never&quot;    &#125;],    &quot;comma-spacing&quot;: [&quot;error&quot;, &#123; &quot;before&quot;: false, &quot;after&quot;: true &#125;],    &quot;comma-style&quot;: [&quot;error&quot;, &quot;last&quot;],    &quot;computed-property-spacing&quot;: [&quot;error&quot;, &quot;never&quot;, &#123; &quot;enforceForClassMembers&quot;: true &#125;],    &quot;constructor-super&quot;: &quot;error&quot;,    &quot;curly&quot;: [&quot;error&quot;, &quot;multi-line&quot;],    &quot;default-case-last&quot;: &quot;error&quot;,    &quot;dot-location&quot;: [&quot;error&quot;, &quot;property&quot;],    &quot;dot-notation&quot;: [&quot;error&quot;, &#123; &quot;allowKeywords&quot;: true &#125;],    &quot;eol-last&quot;: &quot;error&quot;,    &quot;eqeqeq&quot;: [&quot;error&quot;, &quot;always&quot;, &#123; &quot;null&quot;: &quot;ignore&quot; &#125;],    &quot;func-call-spacing&quot;: [&quot;error&quot;, &quot;never&quot;],    &quot;generator-star-spacing&quot;: [&quot;error&quot;, &#123; &quot;before&quot;: true, &quot;after&quot;: true &#125;],    &quot;indent&quot;: [&quot;error&quot;, 2, &#123;      &quot;SwitchCase&quot;: 1,      &quot;VariableDeclarator&quot;: 1,      &quot;outerIIFEBody&quot;: 1,      &quot;MemberExpression&quot;: 1,      &quot;FunctionDeclaration&quot;: &#123; &quot;parameters&quot;: 1, &quot;body&quot;: 1 &#125;,      &quot;FunctionExpression&quot;: &#123; &quot;parameters&quot;: 1, &quot;body&quot;: 1 &#125;,      &quot;CallExpression&quot;: &#123; &quot;arguments&quot;: 1 &#125;,      &quot;ArrayExpression&quot;: 1,      &quot;ObjectExpression&quot;: 1,      &quot;ImportDeclaration&quot;: 1,      &quot;flatTernaryExpressions&quot;: false,      &quot;ignoreComments&quot;: false,      &quot;ignoredNodes&quot;: [&quot;TemplateLiteral *&quot;, &quot;JSXElement&quot;, &quot;JSXElement &gt; *&quot;, &quot;JSXAttribute&quot;, &quot;JSXIdentifier&quot;, &quot;JSXNamespacedName&quot;, &quot;JSXMemberExpression&quot;, &quot;JSXSpreadAttribute&quot;, &quot;JSXExpressionContainer&quot;, &quot;JSXOpeningElement&quot;, &quot;JSXClosingElement&quot;, &quot;JSXFragment&quot;, &quot;JSXOpeningFragment&quot;, &quot;JSXClosingFragment&quot;, &quot;JSXText&quot;, &quot;JSXEmptyExpression&quot;, &quot;JSXSpreadChild&quot;],      &quot;offsetTernaryExpressions&quot;: true    &#125;],    &quot;key-spacing&quot;: [&quot;error&quot;, &#123; &quot;beforeColon&quot;: false, &quot;afterColon&quot;: true &#125;],    &quot;keyword-spacing&quot;: [&quot;error&quot;, &#123; &quot;before&quot;: true, &quot;after&quot;: true &#125;],    &quot;lines-between-class-members&quot;: [&quot;error&quot;, &quot;always&quot;, &#123; &quot;exceptAfterSingleLine&quot;: true &#125;],    &quot;multiline-ternary&quot;: [&quot;error&quot;, &quot;always-multiline&quot;],    &quot;new-cap&quot;: [&quot;error&quot;, &#123; &quot;newIsCap&quot;: true, &quot;capIsNew&quot;: false, &quot;properties&quot;: true &#125;],    &quot;new-parens&quot;: &quot;error&quot;,    &quot;no-array-constructor&quot;: &quot;error&quot;,    &quot;no-async-promise-executor&quot;: &quot;error&quot;,    &quot;no-caller&quot;: &quot;error&quot;,    &quot;no-case-declarations&quot;: &quot;error&quot;,    &quot;no-class-assign&quot;: &quot;error&quot;,    &quot;no-compare-neg-zero&quot;: &quot;error&quot;,    &quot;no-cond-assign&quot;: &quot;error&quot;,    &quot;no-const-assign&quot;: &quot;error&quot;,    &quot;no-constant-condition&quot;: [&quot;error&quot;, &#123; &quot;checkLoops&quot;: false &#125;],    &quot;no-control-regex&quot;: &quot;error&quot;,    &quot;no-debugger&quot;: &quot;error&quot;,    &quot;no-delete-var&quot;: &quot;error&quot;,    &quot;no-dupe-args&quot;: &quot;error&quot;,    &quot;no-dupe-class-members&quot;: &quot;error&quot;,    &quot;no-dupe-keys&quot;: &quot;error&quot;,    &quot;no-duplicate-case&quot;: &quot;error&quot;,    &quot;no-useless-backreference&quot;: &quot;error&quot;,    &quot;no-empty&quot;: [&quot;error&quot;, &#123; &quot;allowEmptyCatch&quot;: true &#125;],    &quot;no-empty-character-class&quot;: &quot;error&quot;,    &quot;no-empty-pattern&quot;: &quot;error&quot;,    &quot;no-eval&quot;: &quot;error&quot;,    &quot;no-ex-assign&quot;: &quot;error&quot;,    &quot;no-extend-native&quot;: &quot;error&quot;,    &quot;no-extra-bind&quot;: &quot;error&quot;,    &quot;no-extra-boolean-cast&quot;: &quot;error&quot;,    &quot;no-extra-parens&quot;: [&quot;error&quot;, &quot;functions&quot;],    &quot;no-fallthrough&quot;: &quot;error&quot;,    &quot;no-floating-decimal&quot;: &quot;error&quot;,    &quot;no-func-assign&quot;: &quot;error&quot;,    &quot;no-global-assign&quot;: &quot;error&quot;,    &quot;no-implied-eval&quot;: &quot;error&quot;,    &quot;no-import-assign&quot;: &quot;error&quot;,    &quot;no-invalid-regexp&quot;: &quot;error&quot;,    &quot;no-irregular-whitespace&quot;: &quot;error&quot;,    &quot;no-iterator&quot;: &quot;error&quot;,    &quot;no-labels&quot;: [&quot;error&quot;, &#123; &quot;allowLoop&quot;: false, &quot;allowSwitch&quot;: false &#125;],    &quot;no-lone-blocks&quot;: &quot;error&quot;,    &quot;no-loss-of-precision&quot;: &quot;error&quot;,    &quot;no-misleading-character-class&quot;: &quot;error&quot;,    &quot;no-prototype-builtins&quot;: &quot;error&quot;,    &quot;no-useless-catch&quot;: &quot;error&quot;,    &quot;no-mixed-operators&quot;: [&quot;error&quot;, &#123;      &quot;groups&quot;: [        [&quot;==&quot;, &quot;!=&quot;, &quot;===&quot;, &quot;!==&quot;, &quot;&gt;&quot;, &quot;&gt;=&quot;, &quot;&lt;&quot;, &quot;&lt;=&quot;],        [&quot;&amp;&amp;&quot;, &quot;||&quot;],        [&quot;in&quot;, &quot;instanceof&quot;]      ],      &quot;allowSamePrecedence&quot;: true    &#125;],    &quot;no-mixed-spaces-and-tabs&quot;: &quot;error&quot;,    &quot;no-multi-spaces&quot;: &quot;error&quot;,    &quot;no-multi-str&quot;: &quot;error&quot;,    &quot;no-multiple-empty-lines&quot;: [&quot;error&quot;, &#123; &quot;max&quot;: 1, &quot;maxBOF&quot;: 0, &quot;maxEOF&quot;: 0 &#125;],    &quot;no-new&quot;: &quot;error&quot;,    &quot;no-new-func&quot;: &quot;error&quot;,    &quot;no-new-object&quot;: &quot;error&quot;,    &quot;no-new-symbol&quot;: &quot;error&quot;,    &quot;no-new-wrappers&quot;: &quot;error&quot;,    &quot;no-obj-calls&quot;: &quot;error&quot;,    &quot;no-octal&quot;: &quot;error&quot;,    &quot;no-octal-escape&quot;: &quot;error&quot;,    &quot;no-proto&quot;: &quot;error&quot;,    &quot;no-redeclare&quot;: [&quot;error&quot;, &#123; &quot;builtinGlobals&quot;: false &#125;],    &quot;no-regex-spaces&quot;: &quot;error&quot;,    &quot;no-return-assign&quot;: [&quot;error&quot;, &quot;except-parens&quot;],    &quot;no-self-assign&quot;: [&quot;error&quot;, &#123; &quot;props&quot;: true &#125;],    &quot;no-self-compare&quot;: &quot;error&quot;,    &quot;no-sequences&quot;: &quot;error&quot;,    &quot;no-shadow-restricted-names&quot;: &quot;error&quot;,    &quot;no-sparse-arrays&quot;: &quot;error&quot;,    &quot;no-tabs&quot;: &quot;error&quot;,    &quot;no-template-curly-in-string&quot;: &quot;error&quot;,    &quot;no-this-before-super&quot;: &quot;error&quot;,    &quot;no-throw-literal&quot;: &quot;error&quot;,    &quot;no-trailing-spaces&quot;: &quot;error&quot;,    &quot;no-undef&quot;: &quot;error&quot;,    &quot;no-undef-init&quot;: &quot;error&quot;,    &quot;no-unexpected-multiline&quot;: &quot;error&quot;,    &quot;no-unmodified-loop-condition&quot;: &quot;error&quot;,    &quot;no-unneeded-ternary&quot;: [&quot;error&quot;, &#123; &quot;defaultAssignment&quot;: false &#125;],    &quot;no-unreachable&quot;: &quot;error&quot;,    &quot;no-unreachable-loop&quot;: &quot;error&quot;,    &quot;no-unsafe-finally&quot;: &quot;error&quot;,    &quot;no-unsafe-negation&quot;: &quot;error&quot;,    &quot;no-unused-expressions&quot;: [&quot;error&quot;, &#123;      &quot;allowShortCircuit&quot;: true,      &quot;allowTernary&quot;: true,      &quot;allowTaggedTemplates&quot;: true    &#125;],    &quot;no-unused-vars&quot;: [&quot;error&quot;, &#123;      &quot;args&quot;: &quot;none&quot;,      &quot;caughtErrors&quot;: &quot;none&quot;,      &quot;ignoreRestSiblings&quot;: true,      &quot;vars&quot;: &quot;all&quot;    &#125;],    &quot;no-use-before-define&quot;: [&quot;error&quot;, &#123; &quot;functions&quot;: false, &quot;classes&quot;: false, &quot;variables&quot;: false &#125;],    &quot;no-useless-call&quot;: &quot;error&quot;,    &quot;no-useless-computed-key&quot;: &quot;error&quot;,    &quot;no-useless-constructor&quot;: &quot;error&quot;,    &quot;no-useless-escape&quot;: &quot;error&quot;,    &quot;no-useless-rename&quot;: &quot;error&quot;,    &quot;no-useless-return&quot;: &quot;error&quot;,    &quot;no-void&quot;: &quot;error&quot;,    &quot;no-whitespace-before-property&quot;: &quot;error&quot;,    &quot;no-with&quot;: &quot;error&quot;,    &quot;object-curly-newline&quot;: [&quot;error&quot;, &#123; &quot;multiline&quot;: true, &quot;consistent&quot;: true &#125;],    &quot;object-curly-spacing&quot;: [&quot;error&quot;, &quot;always&quot;],    &quot;object-property-newline&quot;: [&quot;error&quot;, &#123; &quot;allowMultiplePropertiesPerLine&quot;: true &#125;],    &quot;one-var&quot;: [&quot;error&quot;, &#123; &quot;initialized&quot;: &quot;never&quot; &#125;],    &quot;operator-linebreak&quot;: [&quot;error&quot;, &quot;after&quot;, &#123; &quot;overrides&quot;: &#123; &quot;?&quot;: &quot;before&quot;, &quot;:&quot;: &quot;before&quot;, &quot;|&gt;&quot;: &quot;before&quot; &#125; &#125;],    &quot;padded-blocks&quot;: [&quot;error&quot;, &#123; &quot;blocks&quot;: &quot;never&quot;, &quot;switches&quot;: &quot;never&quot;, &quot;classes&quot;: &quot;never&quot; &#125;],    &quot;prefer-const&quot;: [&quot;error&quot;, &#123;&quot;destructuring&quot;: &quot;all&quot;&#125;],    &quot;prefer-promise-reject-errors&quot;: &quot;error&quot;,    &quot;prefer-regex-literals&quot;: [&quot;error&quot;, &#123; &quot;disallowRedundantWrapping&quot;: true &#125;],    &quot;quote-props&quot;: [&quot;error&quot;, &quot;as-needed&quot;],    &quot;quotes&quot;: [&quot;error&quot;, &quot;single&quot;, &#123; &quot;avoidEscape&quot;: true, &quot;allowTemplateLiterals&quot;: false &#125;],    &quot;rest-spread-spacing&quot;: [&quot;error&quot;, &quot;never&quot;],    &quot;semi&quot;: [&quot;error&quot;, &quot;never&quot;],    &quot;semi-spacing&quot;: [&quot;error&quot;, &#123; &quot;before&quot;: false, &quot;after&quot;: true &#125;],    &quot;space-before-blocks&quot;: [&quot;error&quot;, &quot;always&quot;],    &quot;space-before-function-paren&quot;: [&quot;error&quot;, &quot;always&quot;],    &quot;space-in-parens&quot;: [&quot;error&quot;, &quot;never&quot;],    &quot;space-infix-ops&quot;: &quot;error&quot;,    &quot;space-unary-ops&quot;: [&quot;error&quot;, &#123; &quot;words&quot;: true, &quot;nonwords&quot;: false &#125;],    &quot;spaced-comment&quot;: [&quot;error&quot;, &quot;always&quot;, &#123;      &quot;line&quot;: &#123; &quot;markers&quot;: [&quot;*package&quot;, &quot;!&quot;, &quot;/&quot;, &quot;,&quot;, &quot;=&quot;] &#125;,      &quot;block&quot;: &#123; &quot;balanced&quot;: true, &quot;markers&quot;: [&quot;*package&quot;, &quot;!&quot;, &quot;,&quot;, &quot;:&quot;, &quot;::&quot;, &quot;flow-include&quot;], &quot;exceptions&quot;: [&quot;*&quot;] &#125;    &#125;],    &quot;symbol-description&quot;: &quot;error&quot;,    &quot;template-curly-spacing&quot;: [&quot;error&quot;, &quot;never&quot;],    &quot;template-tag-spacing&quot;: [&quot;error&quot;, &quot;never&quot;],    &quot;unicode-bom&quot;: [&quot;error&quot;, &quot;never&quot;],    &quot;use-isnan&quot;: [&quot;error&quot;, &#123;      &quot;enforceForSwitchCase&quot;: true,      &quot;enforceForIndexOf&quot;: true    &#125;],    &quot;valid-typeof&quot;: [&quot;error&quot;, &#123; &quot;requireStringLiterals&quot;: true &#125;],    &quot;wrap-iife&quot;: [&quot;error&quot;, &quot;any&quot;, &#123; &quot;functionPrototypeMethods&quot;: true &#125;],    &quot;yield-star-spacing&quot;: [&quot;error&quot;, &quot;both&quot;],    &quot;yoda&quot;: [&quot;error&quot;, &quot;never&quot;],    &quot;import/export&quot;: &quot;error&quot;,    &quot;import/first&quot;: &quot;error&quot;,    &quot;import/no-absolute-path&quot;: [&quot;error&quot;, &#123; &quot;esmodule&quot;: true, &quot;commonjs&quot;: true, &quot;amd&quot;: false &#125;],    &quot;import/no-duplicates&quot;: &quot;error&quot;,    &quot;import/no-named-default&quot;: &quot;error&quot;,    &quot;import/no-webpack-loader-syntax&quot;: &quot;error&quot;,    &quot;n/handle-callback-err&quot;: [&quot;error&quot;, &quot;^(err|error)$&quot; ],    &quot;n/no-callback-literal&quot;: &quot;error&quot;,    &quot;n/no-deprecated-api&quot;: &quot;error&quot;,    &quot;n/no-exports-assign&quot;: &quot;error&quot;,    &quot;n/no-new-require&quot;: &quot;error&quot;,    &quot;n/no-path-concat&quot;: &quot;error&quot;,    &quot;n/process-exit-as-throw&quot;: &quot;error&quot;,    &quot;promise/param-names&quot;: &quot;error&quot;  &#125;&#125;</code></pre><ul><li>standard 规则中使用单引号、首行缩进 2 个空格，对象属性不用加引号，这样<code>.eslintrc.js</code>文件格式不符合要求，需要对配置文件单独配置这些规则。如下：</li></ul><pre><code>&quot;overrides&quot;: [        &#123;            &quot;files&quot;: [                &quot;.eslintrc.&#123;js,cjs&#125;&quot;            ],            &quot;parserOptions&quot;: &#123;                &quot;sourceType&quot;: &quot;script&quot;            &#125;,            &quot;rules&quot;: &#123;                &quot;quotes&quot;: [2, &quot;double&quot;],  // 双引号                &quot;indent&quot;: [&quot;error&quot;, 4],  // 首行缩进4个字符                &quot;quote-props&quot;: [&quot;error&quot;, &quot;always&quot;]  // 对象属性名用双号号            &#125;        &#125;    ],</code></pre><blockquote><p>注意：</p></blockquote><ul><li>在使用第三方规范包时，一定要记得先下载对应的包，包的使用教程在 npm 上查询。</li><li>所有以<code>eslint-config-</code>前缀的规则包，可以省略 <code>eslint-config-前缀</code></li></ul><h4 id="overrides-节点"><a href="#overrides-节点" class="headerlink" title="overrides 节点"></a>overrides 节点</h4><blockquote><p>有时同一目录下的文件的配置不同。</p><p>因此，你可以在 overrides 键下提供配置，这些配置只应用于特定的文件。</p></blockquote><pre><code>module.exports = &#123;  env: &#123;    browser: true,    commonjs: true,    es2021: true,  &#125;,  extends: &quot;standard&quot;,  overrides: [    // 针对.eslintrc.&#123;js,cjs&#125; 文件使用以下规则，其它文件使用 standard 规则    &#123;      env: &#123;        node: true, // 启用node环境的全局变量      &#125;,      files: [        &quot;.eslintrc.&#123;js,cjs&#125;&quot;, // 文件      ],      parserOptions: &#123;        sourceType: &quot;script&quot;,      &#125;,      rules: &#123;        // 文件对应的检查规则        quotes: [2, &quot;double&quot;],        indent: [&quot;error&quot;, 4],        &quot;quote-props&quot;: [&quot;error&quot;, &quot;always&quot;],      &#125;,    &#125;,  ],&#125;;</code></pre><h4 id="rules-节点"><a href="#rules-节点" class="headerlink" title="rules 节点"></a>rules 节点</h4><blockquote><p>我们可以在 rules 节点中配置相关的规则，这些规则会覆盖 extends 节点中指定的规则</p><ul><li>要改变规则的设置，你必须把规则 ID 设置为这些值之一：</li></ul></blockquote><ul><li><p><code>&quot;off&quot;</code>或 <code>0</code> —— 关闭规则</p></li><li><p><code>&quot;warn&quot;</code>或 <code>1</code> —— 启用并视作警告（不影响退出）</p></li><li><p><code>&quot;error&quot;</code>或 <code>2</code> —— 启用并视作错误（触发时退出代码为 1）</p></li><li><p>ESLint 的所有规则参考：<a href="https://zh-hans.eslint.org/docs/latest/rules/">规则参考</a></p></li></ul><pre><code>module.exports = &#123;  env: &#123;    // 环境全局变量    browser: true,    commonjs: true,    es2021: true,  &#125;,  extends: &quot;standard&quot;, // 检查规则包  overrides: [], //覆盖  parserOptions: &#123;    //    ecmaVersion: &quot;latest&quot;,  &#125;,  rules: &#123;    // 文件对应的检查规则 ，会覆盖standard规则包中对应规则    quotes: [2, &quot;double&quot;],    indent: [&quot;error&quot;, 4],    &quot;quote-props&quot;: [&quot;error&quot;, &quot;always&quot;],    &quot;no-var&quot;: 0,  &#125;,&#125;;</code></pre><blockquote><p>常见规则</p></blockquote><pre><code>&quot;no-alert&quot;: 0,//禁止使用alert confirm prompt&quot;no-array-constructor&quot;: 2,//禁止使用数组构造器&quot;no-bitwise&quot;: 0,//禁止使用按位运算符&quot;no-caller&quot;: 1,//禁止使用arguments.caller或arguments.callee&quot;no-catch-shadow&quot;: 2,//禁止catch子句参数与外部作用域变量同名&quot;no-class-assign&quot;: 2,//禁止给类赋值&quot;no-cond-assign&quot;: 2,//禁止在条件表达式中使用赋值语句&quot;no-console&quot;: 2,//禁止使用console&quot;no-const-assign&quot;: 2,//禁止修改const声明的变量&quot;no-constant-condition&quot;: 2,//禁止在条件中使用常量表达式 if(true) if(1)&quot;no-continue&quot;: 0,//禁止使用continue&quot;no-control-regex&quot;: 2,//禁止在正则表达式中使用控制字符&quot;no-debugger&quot;: 2,//禁止使用debugger&quot;no-delete-var&quot;: 2,//不能对var声明的变量使用delete操作符&quot;no-div-regex&quot;: 1,//不能使用看起来像除法的正则表达式/=foo/&quot;no-dupe-keys&quot;: 2,//在创建对象字面量时不允许键重复 &#123;a:1,a:1&#125;&quot;no-dupe-args&quot;: 2,//函数参数不能重复&quot;no-duplicate-case&quot;: 2,//switch中的case标签不能重复&quot;no-else-return&quot;: 2,//如果if语句里面有return,后面不能跟else语句&quot;no-empty&quot;: 2,//块语句中的内容不能为空&quot;no-empty-character-class&quot;: 2,//正则表达式中的[]内容不能为空&quot;no-empty-label&quot;: 2,//禁止使用空label&quot;no-eq-null&quot;: 2,//禁止对null使用==或!=运算符&quot;no-eval&quot;: 1,//禁止使用eval&quot;no-ex-assign&quot;: 2,//禁止给catch语句中的异常参数赋值&quot;no-extend-native&quot;: 2,//禁止扩展native对象&quot;no-extra-bind&quot;: 2,//禁止不必要的函数绑定&quot;no-extra-boolean-cast&quot;: 2,//禁止不必要的bool转换&quot;no-extra-parens&quot;: 2,//禁止非必要的括号&quot;no-extra-semi&quot;: 2,//禁止多余的冒号&quot;no-fallthrough&quot;: 1,//禁止switch穿透&quot;no-floating-decimal&quot;: 2,//禁止省略浮点数中的0 .5 3.&quot;no-func-assign&quot;: 2,//禁止重复的函数声明&quot;no-implicit-coercion&quot;: 1,//禁止隐式转换&quot;no-implied-eval&quot;: 2,//禁止使用隐式eval&quot;no-inline-comments&quot;: 0,//禁止行内备注&quot;no-inner-declarations&quot;: [2, &quot;functions&quot;],//禁止在块语句中使用声明（变量或函数）&quot;no-invalid-regexp&quot;: 2,//禁止无效的正则表达式&quot;no-invalid-this&quot;: 2,//禁止无效的this，只能用在构造器，类，对象字面量&quot;no-irregular-whitespace&quot;: 2,//不能有不规则的空格&quot;no-iterator&quot;: 2,//禁止使用__iterator__ 属性&quot;no-label-var&quot;: 2,//label名不能与var声明的变量名相同&quot;no-labels&quot;: 2,//禁止标签声明&quot;no-lone-blocks&quot;: 2,//禁止不必要的嵌套块&quot;no-lonely-if&quot;: 2,//禁止else语句内只有if语句&quot;no-loop-func&quot;: 1,//禁止在循环中使用函数（如果没有引用外部变量不形成闭包就可以）&quot;no-mixed-requires&quot;: [0, false],//声明时不能混用声明类型&quot;no-mixed-spaces-and-tabs&quot;: [2, false],//禁止混用tab和空格&quot;linebreak-style&quot;: [0, &quot;windows&quot;],//换行风格&quot;no-multi-spaces&quot;: 1,//不能用多余的空格&quot;no-multi-str&quot;: 2,//字符串不能用\换行&quot;no-multiple-empty-lines&quot;: [1, &#123;&quot;max&quot;: 2&#125;],//空行最多不能超过2行&quot;no-native-reassign&quot;: 2,//不能重写native对象&quot;no-negated-in-lhs&quot;: 2,//in 操作符的左边不能有!&quot;no-nested-ternary&quot;: 0,//禁止使用嵌套的三目运算&quot;no-new&quot;: 1,//禁止在使用new构造一个实例后不赋值&quot;no-new-func&quot;: 1,//禁止使用new Function&quot;no-new-object&quot;: 2,//禁止使用new Object()&quot;no-new-require&quot;: 2,//禁止使用new require&quot;no-new-wrappers&quot;: 2,//禁止使用new创建包装实例，new String new Boolean new Number&quot;no-obj-calls&quot;: 2,//不能调用内置的全局对象，比如Math() JSON()&quot;no-octal&quot;: 2,//禁止使用八进制数字&quot;no-octal-escape&quot;: 2,//禁止使用八进制转义序列&quot;no-param-reassign&quot;: 2,//禁止给参数重新赋值&quot;no-path-concat&quot;: 0,//node中不能使用__dirname或__filename做路径拼接&quot;no-plusplus&quot;: 0,//禁止使用++，--&quot;no-process-env&quot;: 0,//禁止使用process.env&quot;no-process-exit&quot;: 0,//禁止使用process.exit()&quot;no-proto&quot;: 2,//禁止使用__proto__属性&quot;no-redeclare&quot;: 2,//禁止重复声明变量&quot;no-regex-spaces&quot;: 2,//禁止在正则表达式字面量中使用多个空格 /foo bar/&quot;no-restricted-modules&quot;: 0,//如果禁用了指定模块，使用就会报错&quot;no-return-assign&quot;: 1,//return 语句中不能有赋值表达式&quot;no-script-url&quot;: 0,//禁止使用javascript:void(0)&quot;no-self-compare&quot;: 2,//不能比较自身&quot;no-sequences&quot;: 0,//禁止使用逗号运算符&quot;no-shadow&quot;: 2,//外部作用域中的变量不能与它所包含的作用域中的变量或参数同名&quot;no-shadow-restricted-names&quot;: 2,//严格模式中规定的限制标识符不能作为声明时的变量名使用&quot;no-spaced-func&quot;: 2,//函数调用时 函数名与()之间不能有空格&quot;no-sparse-arrays&quot;: 2,//禁止稀疏数组， [1,,2]&quot;no-sync&quot;: 0,//nodejs 禁止同步方法&quot;no-ternary&quot;: 0,//禁止使用三目运算符&quot;no-trailing-spaces&quot;: 1,//一行结束后面不要有空格&quot;no-this-before-super&quot;: 0,//在调用super()之前不能使用this或super&quot;no-throw-literal&quot;: 2,//禁止抛出字面量错误 throw &quot;error&quot;;&quot;no-undef&quot;: 1,//不能有未定义的变量&quot;no-undef-init&quot;: 2,//变量初始化时不能直接给它赋值为undefined&quot;no-undefined&quot;: 2,//不能使用undefined&quot;no-unexpected-multiline&quot;: 2,//避免多行表达式&quot;no-underscore-dangle&quot;: 1,//标识符不能以_开头或结尾&quot;no-unneeded-ternary&quot;: 2,//禁止不必要的嵌套 var isYes = answer === 1 ? true : false;&quot;no-unreachable&quot;: 2,//不能有无法执行的代码&quot;no-unused-expressions&quot;: 2,//禁止无用的表达式&quot;no-unused-vars&quot;: [2, &#123;&quot;vars&quot;: &quot;all&quot;, &quot;args&quot;: &quot;after-used&quot;&#125;],//不能有声明后未被使用的变量或参数&quot;no-use-before-define&quot;: 2,//未定义前不能使用&quot;no-useless-call&quot;: 2,//禁止不必要的call和apply&quot;no-void&quot;: 2,//禁用void操作符&quot;no-var&quot;: 0,//禁用var，用let和const代替&quot;no-warning-comments&quot;: [1, &#123; &quot;terms&quot;: [&quot;todo&quot;, &quot;fixme&quot;, &quot;xxx&quot;], &quot;location&quot;: &quot;start&quot; &#125;],//不能有警告备注&quot;no-with&quot;: 2,//禁用with&quot;array-bracket-spacing&quot;: [2, &quot;never&quot;],//是否允许非空数组里面有多余的空格&quot;arrow-parens&quot;: 0,//箭头函数用小括号括起来&quot;arrow-spacing&quot;: 0,//=&gt;的前/后括号&quot;accessor-pairs&quot;: 0,//在对象中使用getter/setter&quot;block-scoped-var&quot;: 0,//块语句中使用var&quot;brace-style&quot;: [1, &quot;1tbs&quot;],//大括号风格&quot;callback-return&quot;: 1,//避免多次调用回调什么的&quot;camelcase&quot;: 2,//强制驼峰法命名&quot;comma-dangle&quot;: [2, &quot;never&quot;],//对象字面量项尾不能有逗号&quot;comma-spacing&quot;: 0,//逗号前后的空格&quot;comma-style&quot;: [2, &quot;last&quot;],//逗号风格，换行时在行首还是行尾&quot;complexity&quot;: [0, 11],//循环复杂度&quot;computed-property-spacing&quot;: [0, &quot;never&quot;],//是否允许计算后的键名什么的&quot;consistent-return&quot;: 0,//return 后面是否允许省略&quot;consistent-this&quot;: [2, &quot;that&quot;],//this别名&quot;constructor-super&quot;: 0,//非派生类不能调用super，派生类必须调用super&quot;curly&quot;: [2, &quot;all&quot;],//必须使用 if()&#123;&#125; 中的&#123;&#125;&quot;default-case&quot;: 2,//switch语句最后必须有default&quot;dot-location&quot;: 0,//对象访问符的位置，换行的时候在行首还是行尾&quot;dot-notation&quot;: [0, &#123; &quot;allowKeywords&quot;: true &#125;],//避免不必要的方括号&quot;eol-last&quot;: 0,//文件以单一的换行符结束&quot;eqeqeq&quot;: 2,//必须使用全等&quot;func-names&quot;: 0,//函数表达式必须有名字&quot;func-style&quot;: [0, &quot;declaration&quot;],//函数风格，规定只能使用函数声明/函数表达式&quot;generator-star-spacing&quot;: 0,//生成器函数*的前后空格&quot;guard-for-in&quot;: 0,//for in循环要用if语句过滤&quot;handle-callback-err&quot;: 0,//nodejs 处理错误&quot;id-length&quot;: 0,//变量名长度&quot;indent&quot;: [2, 4],//缩进风格&quot;init-declarations&quot;: 0,//声明时必须赋初值&quot;key-spacing&quot;: [0, &#123; &quot;beforeColon&quot;: false, &quot;afterColon&quot;: true &#125;],//对象字面量中冒号的前后空格&quot;lines-around-comment&quot;: 0,//行前/行后备注&quot;max-depth&quot;: [0, 4],//嵌套块深度&quot;max-len&quot;: [0, 80, 4],//字符串最大长度&quot;max-nested-callbacks&quot;: [0, 2],//回调嵌套深度&quot;max-params&quot;: [0, 3],//函数最多只能有3个参数&quot;max-statements&quot;: [0, 10],//函数内最多有几个声明&quot;new-cap&quot;: 2,//函数名首行大写必须使用new方式调用，首行小写必须用不带new方式调用&quot;new-parens&quot;: 2,//new时必须加小括号&quot;newline-after-var&quot;: 2,//变量声明后是否需要空一行&quot;object-curly-spacing&quot;: [0, &quot;never&quot;],//大括号内是否允许不必要的空格&quot;object-shorthand&quot;: 0,//强制对象字面量缩写语法&quot;one-var&quot;: 1,//连续声明&quot;operator-assignment&quot;: [0, &quot;always&quot;],//赋值运算符 += -=什么的&quot;operator-linebreak&quot;: [2, &quot;after&quot;],//换行时运算符在行尾还是行首&quot;padded-blocks&quot;: 0,//块语句内行首行尾是否要空行&quot;prefer-const&quot;: 0,//首选const&quot;prefer-spread&quot;: 0,//首选展开运算&quot;prefer-reflect&quot;: 0,//首选Reflect的方法&quot;quotes&quot;: [1, &quot;single&quot;],//引号类型 &quot;&quot; &#39;&#39;&quot;quote-props&quot;:[2, &quot;always&quot;],//对象字面量中的属性名是否强制双引号&quot;radix&quot;: 2,//parseInt必须指定第二个参数&quot;id-match&quot;: 0,//命名检测&quot;require-yield&quot;: 0,//生成器函数必须有yield&quot;semi&quot;: [2, &quot;always&quot;],//语句强制分号结尾&quot;semi-spacing&quot;: [0, &#123;&quot;before&quot;: false, &quot;after&quot;: true&#125;],//分号前后空格&quot;sort-vars&quot;: 0,//变量声明时排序&quot;space-after-keywords&quot;: [0, &quot;always&quot;],//关键字后面是否要空一格&quot;space-before-blocks&quot;: [0, &quot;always&quot;],//不以新行开始的块&#123;前面要不要有空格&quot;space-before-function-paren&quot;: [0, &quot;always&quot;],//函数定义时括号前面要不要有空格&quot;space-in-parens&quot;: [0, &quot;never&quot;],//小括号里面要不要有空格&quot;space-infix-ops&quot;: 0,//中缀操作符周围要不要有空格&quot;space-return-throw-case&quot;: 2,//return throw case后面要不要加空格&quot;space-unary-ops&quot;: [0, &#123; &quot;words&quot;: true, &quot;nonwords&quot;: false &#125;],//一元运算符的前/后要不要加空格&quot;spaced-comment&quot;: 0,//注释风格要不要有空格什么的&quot;strict&quot;: 2,//使用严格模式&quot;use-isnan&quot;: 2,//禁止比较时使用NaN，只能用isNaN()&quot;valid-jsdoc&quot;: 0,//jsdoc规则&quot;valid-typeof&quot;: 2,//必须使用合法的typeof的值&quot;vars-on-top&quot;: 2,//var必须放在作用域顶部&quot;wrap-iife&quot;: [2, &quot;inside&quot;],//立即执行函数表达式的小括号风格&quot;wrap-regex&quot;: 0,//正则表达式字面量用小括号包起来&quot;yoda&quot;: [2, &quot;never&quot;]//禁止尤达条件</code></pre><h4 id="parserOptions-节点"><a href="#parserOptions-节点" class="headerlink" title="parserOptions 节点"></a>parserOptions 节点</h4><blockquote><p>ESLint 允许你指定你想要支持的 JavaScript 语言选项。默认情况下，ESLint 希望使用 ECMAScript 5 语法。</p></blockquote><blockquote><p>你可以通过使用解析器选项来覆盖这一设置，以实现对其他 ECMAScript 版本以及 JSX 的支持。</p></blockquote><pre><code>&#123;    &quot;parserOptions&quot;: &#123;        &quot;ecmaVersion&quot;: 6   // 启用 ES6 语法    &#125;&#125;</code></pre><blockquote><p>注：</p></blockquote><ul><li><code>ecmaVersion</code>- 设置为 3、5（默认）、6、7、8、9、10、11、12 或 13，以指定你要使用的 ECMAScript 语法的版本。</li><li>你也可以设置为 2015（6）、2016（7）、2017（8）、2018（9）、2019（10）、2020（11）、2021（12）或 2022（13）来使用基于年份的命名。你也可以设置 “latest” 来使用受支持的最新版本。</li><li>具体配置参考官方：<a href="https://zh-hans.eslint.org/docs/latest/use/configure/language-options#%E6%8C%87%E5%AE%9A%E8%A7%A3%E6%9E%90%E5%99%A8%E9%80%89%E9%A1%B9">指定解析器选项</a></li></ul><h3 id="十、Prettier-代码格式化"><a href="#十、Prettier-代码格式化" class="headerlink" title="十、Prettier 代码格式化"></a>十、Prettier 代码格式化</h3><blockquote><p>Prettier 是一个代码格式化工具。</p><p>我们通过一个简单的代码示例来帮助大家学习如何使用 Prettier 插件。</p></blockquote><h4 id="创建项目"><a href="#创建项目" class="headerlink" title="创建项目"></a>创建项目</h4><p>执行以下命令，初始化<code>package.json</code>文件</p><pre><code>npm init -y</code></pre><p>新建<code>src/index.js</code>文件，内容如下：</p><pre><code>const obj = &#123;  username: &quot;admin&quot;,  password: &quot;123456&quot;,&#125;;const a = 1;const b = 2;const arr = [1, 2, 3];</code></pre><h4 id="安装-Prettier"><a href="#安装-Prettier" class="headerlink" title="安装 Prettier"></a>安装 Prettier</h4><blockquote><p>执行以下命令安装 Prettier</p></blockquote><pre><code>npm install --save-dev --save-exact prettier</code></pre><h4 id="添加配置"><a href="#添加配置" class="headerlink" title="添加配置"></a>添加配置</h4><blockquote><p>在项目根目录下新建<code>.prettierrc.json</code>文件，该文件为<code>Prettier</code>插件的配置文件，然后添加相关配置。</p></blockquote><blockquote><p>配置示例</p></blockquote><pre><code>&#123;  &quot;semi&quot;: false,  // 仅在特列情况下在代码尾部加分号，其它都不加  &quot;tabWidth&quot;: 2, // 指定每个缩进级别的空格数2  &quot;singleQuote&quot;: true,  // 使用单引号  &quot;printWidth&quot;: 100,   // 代码换行的长度  &quot;trailingComma&quot;: &quot;none&quot;  // 没有尾随逗号&#125;</code></pre><ul><li>更多配置查阅 <a href="https://www.prettier.cn/docs/options.html">prettier-配置选项</a>，以下为部分配置示例</li></ul><pre><code>&#123;  // 一行的字符数，如果超过会进行换行，默认为80    printWidth: 80,    // tab缩进大小,默认为2    tabWidth: 2,    // 使用tab缩进，默认false    useTabs: true,    // 不使用分号, 默认true, true表示添加    semi: false,    // 使用单引号, 默认false(在jsx中配置无效, 默认都是双引号)    singleQuote: true,    // 行尾逗号,默认none,可选 none|es5|all    // es5 包括es5中的数组、对象    // all 包括函数对象等所有可选    trailingComma: &#39;es5&#39;,    // 对象中的空格 默认true    // true: &#123; foo: bar &#125;    // false: &#123;foo: bar&#125;    bracketSpacing: true,    // JSX标签闭合位置 默认false    // false: &lt;div    //          className=&quot;&quot;    //          style=&#123;&#123;&#125;&#125;    //       &gt;    // true: &lt;div    //          className=&quot;&quot;    //          style=&#123;&#123;&#125;&#125; &gt;    jsxBracketSameLine: true,    // 箭头函数参数括号 默认avoid 可选 avoid| always    // avoid 能省略括号的时候就省略 例如x =&gt; x    // always 总是有括号    arrowParens: &#39;avoid&#39;,    endOfLine: &#39;auto&#39;, // 结尾是 \n \r \n\r auto&#125;</code></pre><h4 id="代码格式化"><a href="#代码格式化" class="headerlink" title="代码格式化"></a>代码格式化</h4><blockquote><p>执行以下命令，调用Prettier来格式化代码</p></blockquote><pre><code># 只格式化src/index.js文件npx prettier src/index.js --write  # 格式化 src目录下所有文件npx prettier src/  --write  # 格式化整个项目npx prettier . --write    </code></pre><blockquote><p>最终格式化后<code>src/index.js</code>文件内容如下：</p></blockquote><pre><code>const obj = &#123;  username: &quot;admin&quot;,  password: &quot;123456&quot;,&#125;;const a = 1;const b = 2;const arr = [1, 2, 3];</code></pre><h3 id="十一、VueUse"><a href="#十一、VueUse" class="headerlink" title="十一、VueUse"></a>十一、VueUse</h3><blockquote><p>VueUse 是一款基于组合式 API 的函数集合，到目前为止大概有 200 多个函数。</p><p>VusUse 中文文档：<a href="https://www.vueusejs.com/">https://www.vueusejs.com</a></p></blockquote><h4 id="VueUse-基本使用"><a href="#VueUse-基本使用" class="headerlink" title="VueUse 基本使用"></a>VueUse 基本使用</h4><ul><li>使用 VueUse 提供的函数前，需要先执行以下命令安装 VueUse 核心包</li></ul><pre><code>npm i @vueuse/core</code></pre><ul><li>然后在<code>@vueuse/core</code>中导入你需要的<a href="https://www.vueusejs.com/functions.html">函数</a>，这里以<code>useToggle</code>函数为例来讲解</li><li><code>useToggle</code>函数用来实现对某个响应式变量布尔值的切换，主要用来实现<code>toggle</code>切换</li></ul><pre><code>&lt;script setup lang=&quot;ts&quot;&gt;  import &#123; useToggle &#125; from &quot;@vueuse/core&quot;;  // isShow=ref(false) toggle用来切换isShow的布尔值  const [isShow, toggle] = useToggle(false);&lt;/script&gt;&lt;template&gt;  &lt;button @click=&quot;toggle()&quot;&gt;切换&lt;/button&gt; |  &lt;button @click=&quot;toggle(false)&quot;&gt;隐藏&lt;/button&gt; |  &lt;button @click=&quot;toggle(true)&quot;&gt;显示&lt;/button&gt;  &lt;div class=&quot;box&quot; v-if=&quot;isShow&quot;&gt;box.....&lt;/div&gt;&lt;/template&gt;</code></pre><h4 id="useStorage-响应式本地存储"><a href="#useStorage-响应式本地存储" class="headerlink" title="useStorage 响应式本地存储"></a>useStorage 响应式本地存储</h4><blockquote><p><code>useStorage</code>用于实现响应式本地存储，当数据发生变会时，页面用到数据的地址方会自动更新，同时也会更新本地存储。</p><ul><li>也可参考 VueUse 官方应用</li></ul></blockquote><pre><code>&lt;script setup lang=&quot;ts&quot;&gt;  import &#123; useStorage &#125; from &quot;@vueuse/core&quot;;  // 初始值  const theDefault = [    &#123;      id: 1,      keyword: &quot;奶茶&quot;,    &#125;,    &#123;      id: 2,      keyword: &quot;葡萄&quot;,    &#125;,    &#123;      id: 3,      keyword: &quot;口红&quot;,    &#125;,  ];  // historyList为theDefault的响应式 ， historyList=ref(theDefault) 当值被修改时，本地存储中也会更新  // theDefault 为默认值  const historyList = useStorage(&quot;historyList&quot;, theDefault);  // 添加  const add = () =&gt; &#123;    historyList.value.push(&#123;      id: Date.now(),      keyword: &quot;苹果&quot;,    &#125;);  &#125;;  // 移除  const remove = () =&gt; &#123;    historyList.value.shift();  &#125;;&lt;/script&gt;&lt;template&gt;  &lt;button @click=&quot;add&quot;&gt;添加数据&lt;/button&gt; |  &lt;button @click=&quot;remove&quot;&gt;移除数据&lt;/button&gt;  &lt;ul&gt;    &lt;li v-for=&quot;item in historyList&quot; :key=&quot;item.id&quot;&gt;&#123;&#123; item.keyword &#125;&#125;&lt;/li&gt;  &lt;/ul&gt;&lt;/template&gt;</code></pre>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Vue </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Vue（七）</title>
      <link href="/2024/01/27/Vue%EF%BC%88%E4%B8%83%EF%BC%89/"/>
      <url>/2024/01/27/Vue%EF%BC%88%E4%B8%83%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<span id="more"></span><h3 id="一、路由的概念"><a href="#一、路由的概念" class="headerlink" title="一、路由的概念"></a>一、路由的概念</h3><blockquote><p>路由本质是请求 ULR 地址与响应内容之间的一种对应关系（映射关系）</p><ul><li>以下为后端路由原理示意图：<img src="后端路由原理示意图.png"></li></ul></blockquote><p>注：</p><ul><li>浏览器通过 URL 向后端服务器发送请求获取数据，后端会找到与此请求相匹配的 URL，然后响应对应的数据内容给到浏览器端。</li><li>请求 URL 之所以能返回对应内容，是因为后端路由设置好了，什么 URL 请求响应什么内容</li><li>路由分类：后端路由和前端路由</li></ul><h3 id="二、后端路由原理解析和实现"><a href="#二、后端路由原理解析和实现" class="headerlink" title="二、后端路由原理解析和实现"></a>二、后端路由原理解析和实现</h3><blockquote><ul><li>后端路由主要由<strong>服务端</strong>进行实现，用来实现资源映射分发。</li><li>根据不同的 URL 请求，返回不同的内容。</li><li>后端路由本质：是请求 URL 与服务器资源之间的对应关系（映射）</li></ul></blockquote><ul><li>后端路由常用来实现 <strong>MPA 多页面应用</strong><img src="后端路由原理示意图.png"></li></ul><ol start="2"><li>MPA 多页面应用<blockquote><p>MPA（<code>Mutiple-page application</code>，多页应用）是指有多个独立页面的应用，每个页面都是由后端服务返回的一个<strong>独立的渲染好的 html 网页</strong></p><ul><li>在多页面应用中，从一个页面跳转到另一个页面，相当于向服务器发送了一次请求，服务器会返回一个新的 HTML 网页给到前端，然后浏览器会将返回的 HTML 页面渲染呈现给用户。</li></ul></blockquote></li></ol><p>多页面应用的优缺点</p><ul><li>缺点：<ul><li>每次页面切换，都需要整页刷新</li><li>前后端不分离，每次请求后端需要把数据渲染成 HTML 文档返回。相当于数据渲染成 HTML 文档的工作要后端来实现。</li></ul></li><li>优点：<ul><li>更有利于 SEO 搜索引擎优化，因为服务端返回的内容是渲染好的 HTML 文档</li></ul></li></ul><ol start="3"><li>后端路由实现多页面应用<blockquote><p>如果一个网站为一个多页面应用，整个应用由网站首页，关于我们，404 页面三个 HTML 页面组成。</p><ul><li>当我们从网站首页跳转到关于我们页面时，相当于浏览器向服务端发送了一次请求，服务端返回了<strong>渲染好的</strong><code>about.html</code>文档，然后浏览器将 <code>HTML</code> 文档渲染成了网页</li></ul></blockquote></li></ol><ul><li>整个应用所涉及的路由及路由对应的页面、URL 地址，返回内容如下表：</li></ul><table><thead><tr><th>路由</th><th>页面</th><th>URL</th><th>返回内容</th></tr></thead><tbody><tr><td>路由一</td><td>网站首页</td><td><code>http://127.0.0.1:8889/index.html</code>或<code>http://127.0.0.1:8889</code></td><td><code>index.html</code>文档</td></tr><tr><td>路由二</td><td>关于我们</td><td><code>http://127.0.0.1:8889/about.html</code></td><td><code>about.html</code>文档</td></tr><tr><td>路由三</td><td><code>404</code>页面</td><td><code>http://127.0.0.1:8889/404</code></td><td><code>404.html</code>文档</td></tr></tbody></table><table><thead><tr><th>路由</th><th>URL</th><th>返回内容</th></tr></thead><tbody><tr><td>路由四</td><td><code>http://127.0.0.1:8889/basic.css</code></td><td><code>basic.css</code>文件</td></tr></tbody></table><blockquote><p>代码演示：本案例采用nodejs实现</p></blockquote><ul><li><code>server.js</code> 用于服务端创建多个后端路由</li></ul><pre><code>const http = require(&quot;http&quot;);const fs = require(&quot;fs&quot;);http  .createServer((request, response) =&gt; &#123;    // 设置响应头    response.writeHead(200, &#123;      &quot;Content-Type&quot;: &quot;text/html;charset:utf-8&quot;,      &quot;Access-Control-Allow-Origin&quot;: &quot;*&quot;, // 允许跨域    &#125;);    let data = &quot;&quot;;    if (request.url === &quot;/about.html&quot;) &#123;      // 读取html页面内容      data = fs.readFileSync(&quot;./about.html&quot;, &quot;utf-8&quot;);    &#125; else if (request.url === &quot;/&quot; || request.url === &quot;/index.html&quot;) &#123;      // 读取html页面内容      data = fs.readFileSync(&quot;./index.html&quot;, &quot;utf-8&quot;);    &#125; else if (request.url === &quot;/basic.css&quot;) &#123;      // 设置响应的内容类型      response.writeHead(200, &#123;        &quot;Content-Type&quot;: &quot;text/css;charset:utf-8&quot;,      &#125;);      // 读取css内容      data = fs.readFileSync(&quot;./basic.css&quot;, &quot;utf-8&quot;);    &#125; else &#123;      data = fs.readFileSync(&quot;./404.html&quot;, &quot;utf-8&quot;);    &#125;    // 响应体内容    response.end(data);  &#125;)  .listen(8889);console.log(&quot;Server running at http:127.0.0.1:8889&quot;);</code></pre><ul><li><code>index.html</code>、<code>about.html</code>、<code>404.html</code>文件内容如下</li></ul><pre><code>&lt;!---index.html --&gt;&lt;body&gt;  &lt;div class=&quot;menu&quot;&gt;    &lt;a href=&quot;/index.html&quot; class=&quot;active&quot;&gt;网站首页&lt;/a&gt; |    &lt;a href=&quot;/about.html&quot;&gt;关于我们&lt;/a&gt;  &lt;/div&gt;  &lt;div class=&quot;main&quot;&gt;网站首页&lt;/div&gt;&lt;/body&gt;&lt;!---about.html --&gt;&lt;body&gt;  &lt;div class=&quot;menu&quot;&gt;    &lt;a href=&quot;/index.html&quot;&gt;网站首页&lt;/a&gt; |    &lt;a href=&quot;/about.html&quot; class=&quot;active&quot;&gt;关于我们&lt;/a&gt;  &lt;/div&gt;  &lt;div class=&quot;main&quot;&gt;关于我们&lt;/div&gt;&lt;/body&gt;&lt;!---404.html --&gt;&lt;body&gt;  404页面,点击&lt;a href=&quot;/&quot; style=&quot;color:red&quot;&gt; 首页 &lt;/a&gt;返回网站首页&lt;/body&gt;</code></pre><ul><li><code>basic.css</code>文件内容如下</li></ul><pre><code>.main &#123;  display: flex;  justify-content: center;  align-items: center;  font-size: 40px;&#125;.menu &#123;  margin: 50px auto 100px;  text-align: center;&#125;a &#123;  color: #000;  font-size: 20px;  text-decoration: none;&#125;a.active &#123;  color: red;  font-weight: bold;  font-size: 22px;&#125;</code></pre><h3 id="三、前端路由原理和实现"><a href="#三、前端路由原理和实现" class="headerlink" title="三、前端路由原理和实现"></a>三、前端路由原理和实现</h3><h4 id="前端路由概念"><a href="#前端路由概念" class="headerlink" title="前端路由概念"></a>前端路由概念</h4><blockquote><p>前端路由描述的是 URL 与页面内容之间的映射关系。这种映射关系是指，当 URL 发生变化时，页面对应的内容会更新，但不会刷新整个页面，只会刷新需要更新内容的部分。</p><ul><li>前端路由主要用来实现 SPA 单页面应用</li></ul></blockquote><h4 id="前端-2-种路由模式"><a href="#前端-2-种路由模式" class="headerlink" title="前端 2 种路由模式"></a>前端 2 种路由模式</h4><blockquote><p>前端路由有以下两种模式，并且每种模式的路由表现形式和实现方式都不一样</p></blockquote><blockquote><ul><li>两种路由模式的表现形式<table><thead><tr><th>路由模式</th><th>路由表现形式</th></tr></thead><tbody><tr><td>hash</td><td>地址的 URL 中带有<code>#</code>号，如：<code>http://www.xxx.com/#/about</code>，<code>#</code>符号后面的 URL 部分为 hash 值</td></tr><tr><td>history</td><td>地址的 URL 为正常模式，如：<code>http://www.xx.com/a/b/c</code></td></tr></tbody></table></li></ul></blockquote><blockquote><ul><li>两种路由模式的实现方式<table><thead><tr><th>路由模式</th><th>实现方式</th></tr></thead><tbody><tr><td>hash</td><td>主要是通过监听浏览器的hashchange事件来实现</td></tr><tr><td>history</td><td>主要是通过监听浏览器的popstate事件与History API来实现</td></tr></tbody></table></li></ul></blockquote><h4 id="hashchange-事件"><a href="#hashchange-事件" class="headerlink" title="hashchange 事件"></a>hashchange 事件</h4><blockquote><p>当请求的 URL 的片段标识符（跟在<code>＃</code>符号后面的 URL 部分，包括<code>＃</code>符号）发生改变时，就会触发<code>hashchange</code>事件。</p><ul><li><code>hashchange</code>事件主要用来解决前端 hash 路由，其实现原理如下：</li></ul></blockquote><ul><li>在该事件中通过<code>location.hash</code>拿到当前 URL 地址<code>#</code>号后面的<code>hash</code>值。</li><li>根据 <code>hash</code> 值来判断发送请求的 url，再通过<code>Ajax</code>或<code>Fetch</code>向后端服务器发送请求获取数据，然后将数据渲染成 <code>DOM</code>，插入页面更新页面内容。</li><li>这种方式更新页面内容，并不会刷新整个页面，也不会产生新的页面，所以整个应用只有一个 HTML 页面。内容的更新只是在更新当前 HTML 页面内容<img src="hashchange事件.png"></li></ul><ol><li>hashchange 事件基本用法</li></ol><ul><li><code>hashchange</code>事件为浏览器事件，通过以下方式来进行监听</li></ul><pre><code>window.addEventListener(  &quot;hashchange&quot;,  function () &#123;    // ....  &#125;,  false);</code></pre><ul><li>通过<code>location.hash</code>拿到 hash 值，地址<code>#</code>号后面的内容就是 hash 内容</li></ul><pre><code>window.addEventListener(&#39;hashchange&#39;, function() &#123;    const hash = location.hash // 获取地址栏中的hash值    &#125;, false);/</code></pre><ul><li>根据 hash 值决定最终要发送的 ajax 请求，获取对应内容，渲染成 DOM，插入到当前面。</li></ul><pre><code>window.addEventListener(  &quot;hashchange&quot;,  function () &#123;    const hash = location.hash; // 获取地址栏中的hash值    if (hash === &quot;#/about&quot;) &#123;      // 发请求获了数据，然后将返回的数据渲染成DOM插入页面中，更新页面内容      // .......      console.log(hash); // #/about    &#125; else if (hash === &quot;#/news&quot;) &#123;      // 发请求获了数据，然后将返回的数据渲染成DOM插入页面中，更新页面内容      // .......      console.log(hash); // #/news    &#125; else &#123;      // .....    &#125;  &#125;,  false);</code></pre><ol start="2"><li>SPA 单页面应用<blockquote><p>SPA（<code>Single-page application</code>，单页应用）整个应用是只会加载一个单独的 HTML 网页（只会在第一次进到应用时，会向服务器发送请求，获取一个 HTML 网页）。后面需要显示不同的内容时，可以通过<code>Ajax</code>或<code>Fetch</code>向服务端请求内容来更新主体内容</p><p>这使得用户在访问网站时无需加载新的页面，可以获得性能提升和动态的体验，但会相应地丧失诸如 SEO（搜索引擎优化）的优势，因为应用主页面只有一些简单的 HTML 框架和 JS 代码。</p></blockquote></li></ol><p>SPA 单页面应用优缺点：</p><ul><li>优点：<ul><li>用户体验好，内容改变不需要重新加载整个页面，基于这一点，对服务器的压力较小</li><li>前后端分离，后端只需要返回对应的 JSON 数据，前端拿到数据后渲染成 DOM 插入页面</li></ul></li><li>缺点：<ul><li>不利于 SEO 搜索引擎优化</li><li>初次加载耗时多</li></ul></li></ul><h4 id="hash-模式的-SPA-单页面应用"><a href="#hash-模式的-SPA-单页面应用" class="headerlink" title="hash 模式的 SPA 单页面应用"></a>hash 模式的 SPA 单页面应用</h4><blockquote><p>以下为一个单页面的 web 应用，当地址中的 hash 值发生改变时，就会通过<code>Ajax</code>或<code>Fetch</code>向后台发请求，拿到数据后将其渲染成 DOM，然后插入到页面更新当前页内容。</p></blockquote><blockquote><p>实现原理</p></blockquote><ul><li>监听<code>hashchange</code>事件，当地址栏中的 hash 值发生变化时，会触发 <code>hashchange</code> 事件</li><li>在<code>hashchange</code>事件中通过<code>location.hash</code>来获取更新后的 hash 值。</li><li>根据对应的 hash 来判断应该向那个地址发送请求获取数据。</li><li>将获取的数据渲染成 DOM 插入到页面中。</li></ul><ol><li>简单版</li></ol><pre><code>&lt;style&gt;  .router-link &#123;    display: flex;    list-style: none;  &#125;  .router-link li &#123;    padding: 0px 10px;  &#125;  .router-link li a &#123;    text-decoration: none;    color: #000;  &#125;  .router-link li a:hover &#123;    color: red;  &#125;&lt;/style&gt;&lt;body&gt;  &lt;!--路由导航--&gt;  &lt;ul class=&quot;router-link&quot;&gt;    &lt;li&gt;&lt;a href=&quot;#/home&quot;&gt;网站首页&lt;/a&gt;&lt;/li&gt;    &lt;li&gt;&lt;a href=&quot;#/about&quot;&gt;关于我们&lt;/a&gt;&lt;/li&gt;    &lt;li&gt;&lt;a href=&quot;#/news&quot;&gt;新闻中心&lt;/a&gt;&lt;/li&gt;  &lt;/ul&gt;  &lt;!--路由内容出口--&gt;  &lt;div class=&quot;router-view&quot;&gt;&lt;/div&gt;  &lt;script&gt;    // 路由出口容器    const $routerView = document.querySelector(&quot;.router-view&quot;);    // 一上来就调下 onHashChange方法，根据路由显示页面内容    onHashChange();    // 监听 hashchange事件    window.addEventListener(&quot;hashchange&quot;, onHashChange, false);    function onHashChange() &#123;      //  获取当前地址的 hash值      const hash = location.hash;      if (hash === &quot;#/home&quot; || hash === &quot;&quot;) &#123;        // .... 发请求，拿数据，然后渲染        $routerView.innerHTML = &quot;网站首页&quot;;      &#125; else if (hash === &quot;#/about&quot;) &#123;        $routerView.innerHTML = &quot;关于我们&quot;;      &#125; else if (hash === &quot;#/news&quot;) &#123;        $routerView.innerHTML = &quot;新闻中心&quot;;      &#125; else &#123;        $routerView.innerHTML = &quot;&quot;;      &#125;    &#125;  &lt;/script&gt;&lt;/body&gt;</code></pre><ol start="2"><li>优化版<blockquote><p>第一步：创建 <code>index.html</code> 项目入口文件</p><ul><li>在该文件中利用 <code>HTML + CSS</code>实现当前应用的导航和对应视图渲染出口架构</li></ul></blockquote></li></ol><pre><code>&lt;style&gt;  .router-link &#123;    display: flex;    list-style: none;  &#125;  .router-link li &#123;    padding: 0 10px;  &#125;  .router-link li a &#123;    text-decoration: none;    color: #000;  &#125;  .router-link li a:hover &#123;    color: red;  &#125;  .router-link li a.active &#123;    color: red;  &#125;&lt;/style&gt;&lt;body&gt;  &lt;!-- 定义路由导航 --&gt;  &lt;ul class=&quot;router-link&quot;&gt;    &lt;li&gt;&lt;a href=&quot;#/home&quot;&gt;网站首页&lt;/a&gt;&lt;/li&gt;    &lt;li&gt;&lt;a href=&quot;#/about&quot;&gt;关于我们&lt;/a&gt;&lt;/li&gt;    &lt;li&gt;&lt;a href=&quot;#/news&quot;&gt;新闻中心&lt;/a&gt;&lt;/li&gt;  &lt;/ul&gt;  &lt;!-- 路由视图（内容出口） --&gt;  &lt;div class=&quot;router-view&quot;&gt;&lt;/div&gt;&lt;/body&gt;</code></pre><blockquote><p>第二步：定义路由</p><ul><li>创建<code>router/routes.js</code>文件，在该文件中对外暴露一个数组，数组中的每一项为一个对象，该对象我们称为路由对象，记录了当前路由相关的信息。</li></ul></blockquote><pre><code>export const routes = [  &#123;    name: &quot;网站首页&quot;,    path: &quot;#/&quot;,  &#125;,  &#123;    name: &quot;网站首页&quot;,    path: &quot;#/home&quot;,  &#125;,  &#123;    name: &quot;关于我们&quot;,    path: &quot;#/about&quot;,  &#125;,  &#123;    name: &quot;新闻中心&quot;,    path: &quot;#/news&quot;,  &#125;,  // 你有多少个路由，往后加就行];</code></pre><blockquote><p>第三步：定义每个路由渲染内容的方法</p><ul><li>每个路由对应的页面要显示的内容我们定义在一个单独的 JS 文件中 ，然后对外暴露一个方法，调用该方法就可以获取要显示的 HTML 字符串。</li><li>考虑到后期内容是通过 ajax 或 fetch 发请求获取，返回的内容会被 Promise 包装，则将方法定义成 async 函数，方便在内部接受请求回来的值，如：<code>await getData(url)</code></li></ul></blockquote><ul><li><code>pages/home.js</code> 文件 - 返回网站首页内容</li></ul><pre><code>export async function home() &#123;  // await getDate(url)  return &quot;网站首页&quot;; // 返回的内容会被Promise包装&#125;</code></pre><ul><li><code>pages/about.js</code> 文件 - 返回关于我们内容</li></ul><pre><code>export async function about() &#123;  return &quot;关于我们&quot;; // 返回的内容会被Promise包装&#125;</code></pre><ul><li><code>pages/news.js</code>文件 - 返回新闻中心内容</li></ul><pre><code>export async function news() &#123;  return &quot;新闻中心&quot;; // 返回的内容会被Promise包装&#125;</code></pre><ul><li><code>pages/nofound.js</code> - 返回 404 页面内容</li></ul><pre><code>export async function nofound() &#123;  return &quot;404页面&quot;; // 返回的内容会被Promise包装&#125;</code></pre><blockquote><p>第四步：定义路由对象的 render 方法</p><ul><li>每一条路由都有其要显示的内容，通过调用路由对象的 render 方法就可以获取要渲染内容的 HTML 字符串。</li></ul></blockquote><pre><code>// 以下方法 home about news 用来返回对应页面的渲染好的html字符串内容import &#123; home &#125; from &quot;../pages/home.js&quot;;import &#123; about &#125; from &quot;../pages/about.js&quot;;import &#123; news &#125; from &quot;../pages/news.js&quot;;export const routes = [  &#123;    name: &quot;网站首页&quot;,    path: &quot;#/&quot;,    render: home, // 得到当前网站首页要渲染的html字符串  &#125;,  &#123;    name: &quot;网站首页&quot;,    path: &quot;#/home&quot;,    render: home, // 得到当前网站首页要渲染的html字符串  &#125;,  &#123;    name: &quot;关于我们&quot;,    path: &quot;#/about&quot;,    render: about,  &#125;,  &#123;    name: &quot;新闻中心&quot;,    path: &quot;#/news&quot;,    render: news,  &#125;,  // 你有多少个路由，往后加就行];</code></pre><blockquote><p>第五步：实现按路由渲染内容</p><ul><li>在<code>index.html</code>页面实现主要的业务逻辑，根据不同的路由渲染不同的内容</li></ul></blockquote><pre><code>&lt;script type=&quot;module&quot;&gt;  // 导入路由  import &#123; routes &#125; from &quot;./router/routes.js&quot;;  // 导航 404d页面渲染函数  import &#123; nofound &#125; from &quot;./pages/nofound.js&quot;;  // 获取路由出口容器  const $routerView = document.querySelector(&quot;.router-view&quot;);  // 监听 hashchange事件， 当地址栏中的hash值发生改变时，会触发hashchange事件  window.addEventListener(&quot;hashchange&quot;, onHashChange);  // 一上来就调用，根据路由渲染初始内容  onHashChange();  async function onHashChange() &#123;    // 获取到hash值    const hash = location.hash;    // 根据hash值，找到对应路由对象，然后拿到对应路由的要渲染的html字符串    const route = routes.find((item) =&gt; item.path === hash);    // 如果route存在，调用render方法获取路由要渲染的html字符串内容    if (route) &#123;      $routerView.innerHTML = await route.render();    &#125; else &#123;      // 不存当前路由就显示404页面内容      $routerView.innerHTML = await nofound();    &#125;  &#125;&lt;/script&gt;</code></pre><blockquote><ul><li>刚开始进到网站首页时，并没有渲染首页面容，是因为我们没有在路由中定义该路由信息，所以需要在<code>router/routes.js</code>中再添加一条路由信息。</li></ul></blockquote><pre><code>export const routes = [  &#123;    name: &quot;网站首页&quot;,    path: &quot;&quot;,    render: home, // 得到当前网站首页要渲染的html字符串  &#125;,  &#123;    name: &quot;网站首页&quot;,    path: &quot;#/&quot;,    render: home, // 得到当前网站首页要渲染的html字符串  &#125;,  &#123;    name: &quot;网站首页&quot;,    path: &quot;#/home&quot;,    render: home, // 得到当前网站首页要渲染的html字符串  &#125;,  // ......  // 你有多少个路由，往后加就行];</code></pre><ul><li>上面路由配置表示 <code>http://127.0.0.1:5500/index.html</code> 、<code>http://127.0.0.1:5500/#/</code> 、<code>http://127.0.0.1:5500/#/home</code> 三个地址都显示网站首页内容</li></ul><blockquote><p>第六步：完善新闻中心页内容</p><ul><li>完善<code>pages/news.js</code>文件的<code>news</code>方法，在该方法中通过fetch发请求获取数据，然后将获取的数据与 HTML 结合成 HTML 字符串，最终返回该 HTML 字符串。</li><li>将发请求获取数据的代码封装在 <code>getData</code> 方法中，并将该方法定义在<code>data/getData.js</code>文件中</li></ul></blockquote><ul><li><code>data/getData.js</code> 文件内容</li></ul><pre><code>export function getData(url) &#123;  return new Promise((resolve, reject) =&gt; &#123;    // fetch请求向后台获取数据    fetch(url)      .then((res) =&gt; &#123;        if ((res.status &lt;= 200 &amp;&amp; res.status &lt; 300) || res.status === 304) &#123;          return res.json(); // 读取数据流        &#125;      &#125;)      .then((data) =&gt; &#123;        resolve(data.data);      &#125;)      .catch((err) =&gt; &#123;        reject();      &#125;);  &#125;);&#125;</code></pre><ul><li><code>pages/news.js</code>文件内容<ul><li>我们可给渲染出来的 DOM 添加 CSS 样式</li></ul></li></ul><pre><code>import &#123; getData &#125; from &quot;../data/getData.js&quot;;// 导入css ，为渲染出来DOM添加css样式import &quot;../css/news.css&quot;;// 请求数据源let url =  &quot;https://www.fastmock.site/mock/6ec78e345df340241e1f5043f0167833/icode/news/8&quot;;export async function news() &#123;  let html = &quot;&lt;ul class=&#39;news&#39;&gt;&quot;;  // 获取请求的数据  const data = await getData(url);  // 遍历数据，将数据与html结合拼接成html字符串  data.forEach((item) =&gt; &#123;    html += `                &lt;li&gt;                    &lt;a href=&#39;$&#123;item.path&#125;&#39;&gt;$&#123;item.title&#125;&lt;/a&gt;                &lt;/li&gt;               `;  &#125;);  html += &quot;&lt;/ul&gt;&quot;;  return html;&#125;</code></pre><ul><li>css&#x2F;news.css</li></ul><pre><code>.news &#123;  list-style: none;  width: 400px;  border: 1px solid skyblue;  padding: 10px;&#125;.news li &#123;  line-height: 35px;&#125;.news li a &#123;  text-decoration: none;  color: #000;&#125;.news li a:hover &#123;  color: tomato;&#125;</code></pre><blockquote><p>第七步：运行程序</p><ul><li>因为我们在项目中用到了<code>import &#39;../css/news.css&#39;</code>导入 CSS，而浏览器本身是不支持这个语法的，所以我们需要借助vite构建工具来构建项目</li><li>执行<code>npm create vite@latest</code>安装 vite 前端构建工具</li><li>删除<code>vite-project</code>文件夹中的<code>index.html</code>文件</li><li>将以上文件都放入生成的<code>vite-project</code>文件夹，然后执行npx vite就可以启动项目</li></ul></blockquote><ul><li>我们发现新闻中心的数据是通过请求获取的，并且对应的 CSS 样式也生效了。</li></ul><p>注：</p><ul><li>不过以上效果还存在一个严重的 bug，当我们切换到新闻中心时，如果数据还没有回来，我们又切换到了网站首页，这里你会看到网站首页的内容会被替换成新闻中心内容。</li><li>因为数据请求需要一定的时间才能返回数据，所以在数据没有返回时切换到网站首页，等到请求数据回来时，就会把当.router-view中的内容替换为请求回来的新闻中心数据。</li><li>所以我们需要在切换到其它路由时，把之前的请求给取消。</li></ul><blockquote><p>第八步：取消请求</p></blockquote><ul><li>在<code>data/getData.js</code>中，为 <code>getData</code> 方法添加取消请求的功能。</li></ul><pre><code>// 如果内容没有回来之前，切换到了其它的页面，我就要把请求取消let controller = new AbortController();export function getData(url) &#123;  // 取消请求设置  controller = new AbortController();  const &#123; signal &#125; = controller;  return new Promise((resolve, reject) =&gt; &#123;    // fetch请求向后台获取数据    // &#123;signal&#125; 取消请求调置    fetch(url, &#123; signal &#125;)      .then((res) =&gt; &#123;        if ((res.status &lt;= 200 &amp;&amp; res.status &lt; 300) || res.status === 304) &#123;          return res.json(); // 读取数据流        &#125;      &#125;)      .then((data) =&gt; &#123;        resolve(data.data);      &#125;)      .catch((err) =&gt; &#123;        reject(&quot;请求被取消了&quot;);      &#125;);  &#125;);&#125;// 调用该方法，取消请求getData.abort = function () &#123;  controller.abort(); // 取消当前请求&#125;;</code></pre><p>在切换到其它页面时，要取消之前的请求</p><ul><li>pages&#x2F;home.js</li></ul><pre><code>import &#123; getData &#125; from &quot;../data/getData.js&quot;;export async function home() &#123;  // 取消之前的请求  getData.abort();  return &quot;网站首页&quot;;&#125;</code></pre><ul><li>pages&#x2F;about.js</li></ul><pre><code>import &#123; getData &#125; from &quot;../data/getData.js&quot;;export async function about() &#123;  // 取消之前的请求  getData.abort();  return &quot;关于我们&quot;;&#125;</code></pre><ul><li>pages&#x2F;news.js</li></ul><pre><code>import &#123; getData &#125; from &quot;../data/getData.js&quot;;export async function news() &#123;  // 取消之前的请求  getData.abort();  //........&#125;</code></pre><ul><li>pages&#x2F;nofound.js</li></ul><pre><code>import &#123; getData &#125; from &quot;../data/getData.js&quot;;export async function nofound() &#123;  // 取消之前的请求  getData.abort();  return &quot;404页面&quot;;&#125;</code></pre><blockquote><p>第九步：处理错误</p><ul><li>如果请求被取消了，是会<code>reject</code>(‘请求被取消’)，我们可以对抛出的错误捕获并处理</li></ul></blockquote><ul><li>在<code>index.html</code>中对获取数据的代码进行<code>try...catch</code>错误捕获</li></ul><pre><code>async function onHashChange() &#123;  // ......  if (route) &#123;    try &#123;      $routerView.innerHTML = await route.render();    &#125; catch (err) &#123;      console.log(err);    &#125;  &#125; else &#123;    // 不存当前路由就显示404页面内容    try &#123;      $routerView.innerHTML = await nofound();    &#125; catch (err) &#123;      console.log(err);    &#125;  &#125;&#125;</code></pre><blockquote><p>第十步：点亮导航</p><ul><li>实现当前路由对应的导航变成红色。</li></ul></blockquote><ul><li>我们可以通过 map 建立路由与a标签元素的映射关系</li></ul><pre><code>// 获取所有a标签const $links = document.querySelectorAll(&quot;.router-link li a&quot;);// 建立route与a标签的一种映射关系const map = new Map();$links.forEach((item) =&gt; &#123;  let href = item.getAttribute(&quot;href&quot;);  if (href === &quot;#/home&quot;) &#123;    map.set(href, item);    map.set(&quot;#/&quot;, item);    map.set(&quot;&quot;, item);  &#125; else &#123;    map.set(href, item);  &#125;&#125;);</code></pre><ul><li>根据路由找到 a 标签，给 a 标签添加class&#x3D;’active’</li></ul><pre><code>if (route) &#123;  // 点亮导航  $links.forEach((item) =&gt; &#123;    item.classList.remove(&quot;active&quot;);  &#125;);  // 根据路由找到对应的a标签，添加class=&#39;active&#39;  map.get(route.path).classList.add(&quot;active&quot;);  // 渲染导航对应内容  try &#123;    $routerView.innerHTML = await route.render();  &#125; catch (err) &#123;    console.log(err);  &#125;&#125; else &#123;  // 不存当前路由就显示404页面内容  $routerView.innerHTML = await nofound();&#125;</code></pre><blockquote><p>完整代码</p></blockquote><ul><li>项目目录结构</li></ul><pre><code>code├─ css│  └─ news.css  // 新闻页css├─ data│  └─ getData.js   // 请求数据方法├─ index.html   // 项目入口├─ pages    // 返回各页面html字符串的方法│  ├─ about.js│  ├─ home.js│  ├─ news.js│  └─ nofound.js└─ routes  // 项目路由   └─ routes.js</code></pre><ul><li>index.html</li></ul><pre><code>&lt;style&gt;  .router-link &#123;    display: flex;    list-style: none;  &#125;  .router-link li &#123;    padding: 0 10px;  &#125;  .router-link li a &#123;    text-decoration: none;    color: #000;  &#125;  .router-link li a:hover &#123;    color: red;  &#125;  .router-link li a.active &#123;    color: red;  &#125;&lt;/style&gt;&lt;body&gt;  &lt;!-- 定义路由导航 --&gt;  &lt;ul class=&quot;router-link&quot;&gt;    &lt;li&gt;&lt;a href=&quot;#/home&quot;&gt;网站首页&lt;/a&gt;&lt;/li&gt;    &lt;li&gt;&lt;a href=&quot;#/about&quot;&gt;关于我们&lt;/a&gt;&lt;/li&gt;    &lt;li&gt;&lt;a href=&quot;#/news&quot;&gt;新闻中心&lt;/a&gt;&lt;/li&gt;  &lt;/ul&gt;  &lt;!-- 路由视图（内容出口） --&gt;  &lt;div class=&quot;router-view&quot;&gt;&lt;/div&gt;  &lt;script type=&quot;module&quot;&gt;    // 导入路由    import &#123; routes &#125; from &quot;./router/routes.js&quot;;    // 导航 404d页面渲染函数    import &#123; nofound &#125; from &quot;./pages/nofound.js&quot;;    // 获取路由出口容器    const $routerView = document.querySelector(&quot;.router-view&quot;);    // 获取所有a标签    const $links = document.querySelectorAll(&quot;.router-link li a&quot;);    // 建立route与a标签的一种映射关系    const map = new Map();    $links.forEach((item) =&gt; &#123;      let href = item.getAttribute(&quot;href&quot;);      if (href === &quot;#/home&quot;) &#123;        map.set(href, item);        map.set(&quot;#/&quot;, item);        map.set(&quot;&quot;, item);      &#125; else &#123;        map.set(href, item);      &#125;    &#125;);    // 监听 hashchange事件， 当地址栏中的hash值发生改变时，会触发hashchange事件    window.addEventListener(&quot;hashchange&quot;, onHashChange);    // 一上来就调用，根据路由渲染初始内容    onHashChange();    async function onHashChange() &#123;      // 获取到hash值      const hash = location.hash;      // 根据hash值，找到对应路由对象，然后拿到对应路由的要渲染的html字符串      const route = routes.find((item) =&gt; item.path === hash);      // 如果route存在，调用render方法获取路由要渲染的html字符串内容      if (route) &#123;        // 点亮导航        $links.forEach((item) =&gt; &#123;          item.classList.remove(&quot;active&quot;);        &#125;);        // 根据路由找到对应的a标签，添加class=&#39;active&#39;        map.get(route.path).classList.add(&quot;active&quot;);        try &#123;          $routerView.innerHTML = await route.render();        &#125; catch (err) &#123;          console.log(err);        &#125;      &#125; else &#123;        // 不存当前路由就显示404页面内容        $routerView.innerHTML = await nofound();      &#125;    &#125;  &lt;/script&gt;&lt;/body&gt;</code></pre><ul><li>router&#x2F;routes.js</li></ul><pre><code>// 以下方法 home about news 用来返回对应页面的渲染好的html字符串内容import &#123; home &#125; from &quot;../pages/home.js&quot;;import &#123; about &#125; from &quot;../pages/about.js&quot;;import &#123; news &#125; from &quot;../pages/news.js&quot;;export const routes = [  &#123;    name: &quot;网站首页&quot;,    path: &quot;&quot;,    render: home, // 得到当前网站首页要渲染的html字符串  &#125;,  &#123;    name: &quot;网站首页&quot;,    path: &quot;#/&quot;,    render: home, // 得到当前网站首页要渲染的html字符串  &#125;,  &#123;    name: &quot;网站首页&quot;,    path: &quot;#/home&quot;,    render: home, // 得到当前网站首页要渲染的html字符串  &#125;,  &#123;    name: &quot;关于我们&quot;,    path: &quot;#/about&quot;,    render: about,  &#125;,  &#123;    name: &quot;新闻中心&quot;,    path: &quot;#/news&quot;,    render: news,  &#125;,  // 你有多少个路由，往后加就行];</code></pre><ul><li>pages&#x2F;home.js</li></ul><pre><code>// 考虑到后期内容是通过ajax或fetch发请求获取// 返回的内容会被Promise包装，则将方法定义成async函数，方便接受请求回来的值// await getData(url)import &#123; getData &#125; from &quot;../data/getData&quot;;export async function home() &#123;  // 取消之前的请求  getData.abort();  return &quot;网站首页&quot;;&#125;</code></pre><ul><li>page&#x2F;about.js</li></ul><pre><code>import &#123; getData &#125; from &quot;../data/getData&quot;;export async function about() &#123;  // 取消之前的请求  getData.abort();  return &quot;关于我们&quot;;&#125;</code></pre><ul><li>pages&#x2F;news.js</li></ul><pre><code>import &#123; getData &#125; from &quot;../data/getData.js&quot;;// 导入css ，为渲染出来DOM添加css样式import &quot;../css/news.css&quot;;// 请求数据源let url =  &quot;https://www.fastmock.site/mock/6ec78e345df340241e1f5043f0167833/icode/news/8&quot;;export async function news() &#123;  // 取消之前请求  getData.abort();  let html = &quot;&lt;ul class=&#39;news&#39;&gt;&quot;;  const data = await getData(url);  data.forEach((item) =&gt; &#123;    html += `                &lt;li&gt;                    &lt;a href=&#39;$&#123;item.path&#125;&#39;&gt;$&#123;item.title&#125;&lt;/a&gt;                &lt;/li&gt;               `;  &#125;);  html += &quot;&lt;/ul&gt;&quot;;  return html;&#125;</code></pre><ul><li>pages&#x2F;nofound.js</li></ul><pre><code>import &#123; getData &#125; from &quot;../data/getData.js&quot;;export async function nofound() &#123;  // 取消之前的请求  getData.abort();  return &quot;404页面&quot;;&#125;</code></pre><ul><li>data&#x2F;getData.js</li></ul><pre><code>// 如果内容没有回来之前，切换到了其它的页面，我就要把请求取消let controller = new AbortController();export function getData(url) &#123;  // 取消请求设置  controller = new AbortController();  const &#123; signal &#125; = controller;  return new Promise((resolve, reject) =&gt; &#123;    // fetch请求向后台获取数据    // &#123;signal&#125; 取消请求调置    fetch(url, &#123; signal &#125;)      .then((res) =&gt; &#123;        if ((res.status &lt;= 200 &amp;&amp; res.status &lt; 300) || res.status === 304) &#123;          return res.json(); // 读取数据流        &#125;      &#125;)      .then((data) =&gt; &#123;        resolve(data.data);      &#125;)      .catch((err) =&gt; &#123;        reject(&quot;请求被取消了&quot;);      &#125;);  &#125;);&#125;// 调用该方法，取消请求getData.abort = function () &#123;  controller.abort(); // 取消当前请求&#125;;</code></pre><ul><li>css&#x2F;news.css 样式</li></ul><pre><code>.news &#123;  list-style: none;  width: 400px;  border: 1px solid skyblue;  padding: 10px;&#125;.news li &#123;  line-height: 35px;&#125;.news li a &#123;  text-decoration: none;  color: #000;&#125;.news li a:hover &#123;  color: tomato;&#125;</code></pre><h4 id="History-API-与-popstate"><a href="#History-API-与-popstate" class="headerlink" title="History API 与 popstate"></a>History API 与 popstate</h4><blockquote><p>History对象提供了如下 API 方法，用来实现 URL 的切换。<br>|方法|用法|<br>|go|相当于浏览器中前进或后退按扭，go(-1)后退一页，go(1)前进一页|<br>|back|相当于浏览器中的后退按扭，用于后退到前一页，back()后退一页|<br>|forward|相当于浏览器中的前进按扭，用于前进到前一页，forward()前进一页|<br>|pushState|向浏览器的会话历史栈中增加一个条目，地址栏中地址会变化，但不会向后端发请求|<br>|replaceState|修改当前历史记录，相当于替换历史栈中当前 URL，地址栏中地址会变化，但不会向后端发请求|</p></blockquote><ul><li>当 history 模式的 URL 地址发生变化时，某些情况下就会触发 <code>window</code> 对象上的<code>popstate</code>事件。</li></ul><ol><li>go，back，forward 方法</li></ol><pre><code>history.back(); // 后退history.forward(); // 前进history.go(1); // 前进 进入下一页</code></pre><ol start="2"><li>pushState 方法</li></ol><ul><li>向浏览器的会话历史栈中增加一个条目，相当于更改当前浏览器的地址，会产生历史记录</li><li>地址栏中 URL 虽然会变为新增的，但不会向后端发送请求，如果刷新该页面，会出现 404 错误</li></ul><pre><code>pushState(state, unused, url);</code></pre><blockquote><p>参数</p></blockquote><ul><li><code>state</code>：为当前所创建的历史条件所携带的数据，其值为一个可序列化的对象，该数据保存在<code>history</code>对象的<code>state</code>属性上，同时<code>popstate</code>事件的<code>state</code>属性值为该<code>state</code>对象的副本。</li><li><code>unused</code>：没有用的参数，因为历史原因，但又必须存在，通常传递一个空字符串。</li><li><code>url</code>：新的历史条目 URL</li></ul><blockquote><p>案例演示</p></blockquote><pre><code>&lt;button id=&quot;add&quot;&gt;更改地址栏中URL&lt;/button&gt;&lt;script&gt;  const $add = document.getElementById(&quot;add&quot;);  let num = 1;  $add.onclick = function () &#123;    if (num === 1) &#123;      history.pushState(&#123; a: 1, b: 2 &#125;, &quot;&quot;, &quot;/about&quot;);      num = 2;    &#125; else &#123;      history.pushState(&#123;&#125;, &quot;&quot;, &quot;/news&quot;);    &#125;    // 注意观察history的state属性    console.log(history);  &#125;;&lt;/script&gt;</code></pre><ul><li>注意观察地址栏中地址的变化，并且点击前进和后退按扭可以前进和回退</li></ul><ol start="3"><li>replaceState 方法</li></ol><ul><li>修改当前历史记录，相当于替换历史栈中当前历史记录，地址栏为替换后地址。替换前的地址不会产生历史记录，后退按扭没法后退到替换前的地址。</li><li>同样不会向后端发送请求，如果刷新改页面，会出现 404 错误</li></ul><pre><code>replaceState(state, unused, url);</code></pre><ul><li>replaceState 方法的每个参数与 pushState 方法的参数是一个意思</li></ul><pre><code>&lt;button id=&quot;add&quot;&gt;更改地址栏中URL&lt;/button&gt;&lt;script&gt;  const $add = document.getElementById(&quot;add&quot;);  let num = 1;  $add.onclick = function () &#123;    if (num === 1) &#123;      history.replaceState(&#123; a: 1, b: 2 &#125;, &quot;&quot;, &quot;/about&quot;);      num = 2;    &#125; else &#123;      history.replaceState(&#123;&#125;, &quot;&quot;, &quot;/news&quot;);    &#125;    // 注意观察history的state属性    console.log(history);  &#125;;&lt;/script&gt;</code></pre><ul><li>注意观察地址栏中地址的变化，并且前进和后退按扭是灰色的禁用状态。</li></ul><ol start="4"><li>popstate 事件</li></ol><ul><li>当 history 模式的 URL 地址发生变化时，popstate 事件只会在浏览器某些行为下触发。比如：点击后退按钮或者在 JavaScript 中调用<code>history.back</code>() 等方法</li></ul><blockquote><p>注意事项</p></blockquote><ul><li>如果当前的 URL 的地址是通过<code>history.pushState()</code> 创建或者 <code>history.replaceState()</code>方法修改的，则不会触发<code>popstate</code>事件。</li><li><code>popstate</code>事件的的事件对象 e 上可以获取通过<code>pushState</code>、<code>replaceState</code>方法添加的历史条目的 <code>state</code> 值。</li><li>通过<code>location.pathname</code>可以获取到当前 URL 的后面的路径值。</li></ul><blockquote><p>代码演示</p></blockquote><pre><code>&lt;button id=&quot;but&quot;&gt;更改地址栏中URL&lt;/button&gt;&lt;script&gt;  window.addEventListener(&quot;popstate&quot;, (e) =&gt; &#123;    console.log(&quot;pathname:&quot;, location.pathname);    console.log(&quot;state:&quot;, e.state);  &#125;);  // 获取元素，添加点击事件  $but = document.getElementById(&quot;but&quot;);  $but.onclick = changeUrl;  let num = 0;  function changeUrl() &#123;    num++;    switch (num) &#123;      case 1:        history.pushState(&#123;&#125;, &quot;&quot;, &quot;/home&quot;); // 不会触发popstate事件        break;      case 2:        history.pushState(&#123;&#125;, &quot;&quot;, &quot;/about&quot;); // 不会触发popstate事件        break;      case 3:        history.replaceState(&#123; a: 1 &#125;, &quot;&quot;, &quot;/news&quot;); // 不会触发popstate事件        break;      case 4:        history.back(); // 会触发popstate事件        break;      case 5:        history.go(1); // 会触发popstate事件        break;    &#125;  &#125;&lt;/script&gt;</code></pre><ul><li>前面三次地址发生了变化，都没有触发<code>popstate</code>事件，但后面两次都触发<code>popstate</code>事件</li></ul><h4 id="history-模式的-SPA-单页面应用"><a href="#history-模式的-SPA-单页面应用" class="headerlink" title="history 模式的 SPA 单页面应用"></a>history 模式的 SPA 单页面应用</h4><blockquote><p>实现原理：</p></blockquote><ul><li>通过pushState和replaceState方法修改的 URL，并不会触发popstate事件，所以针对这种情况，我们可以采用如下办法：</li><li>通过监听<code>&lt;a&gt;</code>标签的点击事件，来监听要变化的 URL</li><li>针对要变化的 URL，可以调用pushState和replaceState方法来实现地址栏中 URL 的变化</li><li>最后根据当前地址 URL，来发送对应的Ajax或Fetch请求，获取数据后，渲染成 DOM 插入到页面，更新内容。</li><li>如果是调用了histroy的go、back()、forward()或浏览器的前进后退按扭来改变 URL，则都会触发popstate事件，可以在该事件中来处理。在该事件中通过location.pathname来获取 URL 的路径值</li></ul><img src="history模式的SPA单页面应用.png"><blockquote><p>完整版代码</p></blockquote><pre><code>&lt;style&gt;  .router-view &#123;    display: flex;    justify-content: center;    align-items: center;    font-size: 40px;  &#125;  .router-link &#123;    display: flex;    margin: 50px auto 100px;    text-align: center;    list-style: none;  &#125;  .router-link li &#123;    margin: 0 10px;  &#125;  .router-link li a &#123;    color: #000;    font-size: 20px;    text-decoration: none;  &#125;&lt;/style&gt;&lt;body&gt;  &lt;div class=&quot;router-link&quot;&gt;    &lt;li&gt;&lt;a href=&quot;/home&quot;&gt;网站首页&lt;/a&gt;&lt;/li&gt;    &lt;li&gt;&lt;a href=&quot;/about&quot;&gt;关于我们&lt;/a&gt;&lt;/li&gt;    &lt;li&gt;&lt;a href=&quot;/news&quot;&gt;新闻中心&lt;/a&gt;&lt;/li&gt;    &lt;li&gt;&lt;a href=&quot;/product&quot;&gt;产品中心&lt;/a&gt;&lt;/li&gt;  &lt;/div&gt;  &lt;!--路由视图：内容的出口--&gt;  &lt;div class=&quot;router-view&quot;&gt;&lt;/div&gt;  &lt;script&gt;    // 获取用来放路由视图的容器    const $routerLink = document.querySelector(&quot;.router-link&quot;);    const $routerView = document.querySelector(&quot;.router-view&quot;);    // 获取所有a标签    const $links = document.querySelectorAll(&quot;a&quot;);    // 页面首次加载时，触发onPopState方法，渲染首页内容    window.addEventListener(&quot;DOMContentLoaded&quot;, onPopState);    // 事件代理    $routerLink.onclick = function (e) &#123;      e.preventDefault();      const target = e.target;      const targetName = target.tagName.toLowerCase();      if (targetName !== &quot;a&quot;) return;      // 阻止默认行为      e.preventDefault();      // 清除所有a标签的active class      $links.forEach((item) =&gt; &#123;        item.classList.remove(&quot;active&quot;);      &#125;);      target.classList.add(&quot;active&quot;);      // 更新URL      history.pushState(&#123;&#125;, &quot;&quot;, target.getAttribute(&quot;href&quot;));      // 更新页面内容      onPopState();    &#125;;    // 根据URL变化，渲染对应的内容    function onPopState() &#123;      switch (location.pathname) &#123;        case &quot;/&quot;:        case &quot;/index.html&quot;:        case &quot;/home&quot;:          $routerView.innerHTML = &quot;网站首页&quot;;          break;        case &quot;/about&quot;:          $routerView.innerHTML = &quot;关于我们&quot;;          break;        case &quot;/news&quot;:          $routerView.innerHTML = &quot;新闻中心&quot;;          break;        default:          // 对于没有匹配的路由，显示404页面          $routerView.innerHTML = &quot;404页面&quot;;      &#125;    &#125;  &lt;/script&gt;&lt;/body&gt;</code></pre><h4 id="为什么需要前端路由"><a href="#为什么需要前端路由" class="headerlink" title="为什么需要前端路由"></a>为什么需要前端路由</h4><blockquote><p>没有前端路由，如何实现单页面开发？</p><ul><li>我们只需要监听对应a标签的事件，然后在事件中发送<code>Ajax</code>或<code>Fetch</code>请求，拿到数据后渲染成 DOM，插入页面，更新对应内容即可。</li></ul></blockquote><ul><li>代码如下：</li></ul><pre><code>&lt;script&gt;  // 获取用来放路由视图的容器  const $routerLink = document.querySelector(&quot;.router-link&quot;);  const $routerView = document.querySelector(&quot;.router-view&quot;);  // 获取所有a标签  const $links = document.querySelectorAll(&quot;a&quot;);  // 页面首次加载时，触发onPopState方法，渲染首页内容  window.addEventListener(&quot;DOMContentLoaded&quot;, onPopState);  // 事件代理  $routerLink.onclick = function (e) &#123;    const target = e.target;    const targetName = target.tagName.toLowerCase();    if (targetName !== &quot;a&quot;) return;    // 阻止默认行为    e.preventDefault();    // 清除所有a标签的active class    $links.forEach((item) =&gt; &#123;      item.classList.remove(&quot;active&quot;);    &#125;);    target.classList.add(&quot;active&quot;);    // 更新URL    // history.pushState(&#123;&#125;, &quot;&quot;, target.getAttribute(&quot;href&quot;));    // 更新页面内容    // 直接传递 url    onPopState(target.getAttribute(&quot;href&quot;));  &#125;;  // 根据URL变化，渲染对应的内容  function onPopState(url) &#123;    switch (url) &#123;      case &quot;/&quot;:      case &quot;/index.html&quot;:      case &quot;/home&quot;:        $routerView.innerHTML = &quot;网站首页&quot;;        break;      case &quot;/about&quot;:        $routerView.innerHTML = &quot;关于我们&quot;;        break;      case &quot;/news&quot;:        $routerView.innerHTML = &quot;新闻中心&quot;;        break;      default:        // 对于没有匹配的路由，显示404页面        $routerView.innerHTML = &quot;404页面&quot;;    &#125;  &#125;&lt;/script&gt;</code></pre><ul><li>注意上面的<code>onPopState(url)</code>方法的地址是动态传递进来的。</li></ul><blockquote><p>原因如下：</p></blockquote><ul><li><code>AJAX</code>局部刷新，导致浏览器的<code>URL</code>不会发生任何变化而完成了请求，从而破坏了用户浏览体验。</li><li>同时本次浏览的页面内容在用户下次使用URL访问时将无法重新呈现（前提还需要后端配合），使用路由可以很好地解决这个问题。</li><li>所以，前端路由本质是为了让用户有一个更好的体验</li></ul><h3 id="四、Vue-中如何实现前端路由"><a href="#四、Vue-中如何实现前端路由" class="headerlink" title="四、Vue 中如何实现前端路由"></a>四、Vue 中如何实现前端路由</h3><blockquote><p>在利用 Vue 框架开发项目时，如果我们的页面路由相对较复杂，我们可以使用 Vue 官方推荐的<code>Vue Route</code>r路由库来实现。如果只需要实现简单的页面路由，我们可以<strong>手动</strong>通过以下两种方式：</p><ul><li><code>hash</code> 模式的前端路由：是通过<code>hashchange</code>事件与<code>&lt;component&gt;</code>动态组件来实现的</li><li><code>history</code> 模式的前端路由：是通过<code>History API</code>和<code>popState</code>事件，然后结合<code>&lt;component&gt;</code>动态组件来实现的。</li></ul><p>以上两种实现路由的方式就是 Vue Router 背后的实现原理，只是 Vue Router 相对考虑的更全面。</p><ul><li>所以我们先来学习下，如果在 Vue 中通过以上两种方式手动实现一个简单的路由。然后再学习Vue Router</li></ul></blockquote><h4 id="通过-hashchange-事件来实现"><a href="#通过-hashchange-事件来实现" class="headerlink" title="通过 hashchange 事件来实现"></a>通过 hashchange 事件来实现</h4><blockquote><p>创建为一个简单的 SPA 单页面应用，根据不同的hash地址，来显示不同组件的内容。</p><ul><li>访问的<code>hash</code>值为<code>#/</code>或<code>#/home</code>时，当前页面显示 Home 组件内容</li><li>访问的<code>hash</code>值为<code>#/about</code>时，当前页面显示 About 组件内容</li><li>访问的<code>hash</code>值为<code>#/news</code>时，当前页面显示 News 组件内容</li><li>当访问不存在的页面时，会显示<code>NotFound</code>组件内容，即：404 页面</li></ul></blockquote><ol><li>实现原理</li></ol><ul><li>当浏览器中的<code>hash</code>值发生改变时，会触发浏览器的<code>hashchange</code>事件。</li><li>我们可以通过监听<code>hashchange</code>事件，在事件内部获限当前路由 <code>hash</code>值，然后根据不同的<code>hash</code>值，在当前页面渲染不同的组件。</li></ul><ol start="2"><li>实现步骤<blockquote><p>定义如下html结构，<code>currentView</code>变量保存了当前需要显示的组件</p></blockquote></li></ol><pre><code>&lt;template&gt;  &lt;!-- 路由导航 --&gt;  &lt;ul class=&quot;router-link&quot;&gt;    &lt;li&gt;&lt;a href=&quot;#/&quot;&gt;网站首页&lt;/a&gt;&lt;/li&gt;    &lt;li&gt;&lt;a href=&quot;#/about&quot;&gt;关于我们&lt;/a&gt;&lt;/li&gt;    &lt;li&gt;&lt;a href=&quot;#/news&quot;&gt;新闻中心&lt;/a&gt;&lt;/li&gt;  &lt;/ul&gt;  &lt;!-- 路由内容出口 --&gt;  &lt;component :is=&quot;currentView&quot; class=&quot;router-view&quot; /&gt;&lt;/template&gt;&lt;style scoped&gt;  .router-link &#123;    display: flex;    margin: 10px auto;    text-align: center;    list-style: none;  &#125;  .router-link li &#123;    margin: 0 10px;  &#125;  .router-link li a &#123;    color: #000;    font-size: 20px;    text-decoration: none;  &#125;  .router-view &#123;    margin: 20px;    font-size: 30px;    min-height: 300px;  &#125;&lt;/style&gt;</code></pre><ul><li>在当前项目的<code>src</code>目录下，新建<code>views</code>目录，在此目录下创建应用需要用到的所有视图组件</li></ul><pre><code>views / Home.vue; // Home 组件views / About.vue; //  About 组件views / News.vue; // News 组件views / NotFound.vue; // NotFound 组件</code></pre><ul><li>定义路由对象<code>routes</code>，这个对象的属性和值分别为<code>hash</code>值和<code>hash</code>值需要显示的组件。</li></ul><pre><code>// 定义一些路由 (url地址与 组件的对应关系)const routes = &#123;  &quot;/&quot;: Home,  &quot;/about&quot;: About,  &quot;/news&quot;: News,&#125;;</code></pre><ul><li>定义<code>currentPath</code>变量，用来保存当前地址的<code>hash</code>值</li></ul><pre><code>// 获取当前地址的hash值const currentPath = ref(window.location.hash);监听浏览器的hashchange事件，当hash值改变时，修改currentPath的值// 监听浏览器的hashchange事件，当hash值改变时，修改currentPath的值window.addEventListener(&quot;hashchange&quot;, () =&gt; &#123;  currentPath.value = window.location.hash;&#125;);</code></pre><ul><li>创建一个计算属性<code>currentView</code>，根据hash值，返回最终要显示的组件。</li></ul><pre><code>// 计算属性，根据hash值，返回最终需要显示的组件const currentView = computed(() =&gt; &#123;  // currentPath.value.slice(1) || &#39;/&#39; 表示访问根目录时，显示Home组件内容  // 当访问routes中不存在的地址时，显示NotFound组件（404页面）  // slice(1) 去掉hash值前面的#号  return routes[currentPath.value.slice(1) || &quot;/&quot;] || NotFound;&#125;);</code></pre><ol start="3"><li>完整版代码</li></ol><pre><code>&lt;script setup&gt;  import &#123; ref, computed &#125; from &quot;vue&quot;;  // 获取视图组件  import Home from &quot;./views/Home.vue&quot;;  import About from &quot;./views/About.vue&quot;;  import News from &quot;./views/News.vue&quot;;  import NotFound from &quot;./views/NotFound.vue&quot;; // 404页面  // 定义一些路由 (url地址与 组件的对应关系)  const routes = &#123;    &quot;/&quot;: Home,    &quot;/about&quot;: About,    &quot;/news&quot;: News,  &#125;;  // 获取当前地址的hash值  const currentPath = ref(window.location.hash);  // 监听浏览器的hashchange事件，当hash值改变时，修改currentPath的值  window.addEventListener(&quot;hashchange&quot;, () =&gt; &#123;    currentPath.value = window.location.hash;  &#125;);  // 计算属性，根据hash值，返回最终需要显示的组件  const currentView = computed(() =&gt; &#123;    // currentPath.value.slice(1) || &#39;/&#39; 表示访问根目录时，显示Home组件内容    // 当访问routes中不存在的地址时，显示NotFound组件（404页面）    // slice(1) 去掉hash值前面的#号    return routes[currentPath.value.slice(1) || &quot;/&quot;] || NotFound;  &#125;);&lt;/script&gt;&lt;template&gt;  &lt;!-- 路由导航 --&gt;  &lt;ul class=&quot;router-link&quot;&gt;    &lt;li&gt;&lt;a href=&quot;#/&quot;&gt;网站首页&lt;/a&gt;&lt;/li&gt;    &lt;li&gt;&lt;a href=&quot;#/about&quot;&gt;关于我们&lt;/a&gt;&lt;/li&gt;    &lt;li&gt;&lt;a href=&quot;#/news&quot;&gt;新闻中心&lt;/a&gt;&lt;/li&gt;  &lt;/ul&gt;  &lt;!-- 路由内容出口 --&gt;  &lt;component :is=&quot;currentView&quot; class=&quot;router-view&quot; /&gt;&lt;/template&gt;&lt;style scoped&gt;  .router-link &#123;    display: flex;    margin: 10px auto 100px;    text-align: center;    list-style: none;  &#125;  .router-link li &#123;    margin: 0 10px;  &#125;  .router-link li a &#123;    color: #000;    font-size: 20px;    text-decoration: none;  &#125;  .router-view &#123;    margin: 20px;    font-size: 30px;    min-height: 300px;  &#125;&lt;/style&gt;</code></pre><h4 id="通过History-API与-popstate事件实现"><a href="#通过History-API与-popstate事件实现" class="headerlink" title="通过History API与 popstate事件实现"></a>通过History API与 popstate事件实现</h4><blockquote><p>以下为一个简单的 SPA 单页面应用，根据不同的路径，来显示不同组件的内容。</p><ul><li>地址后的路径为：<code>/home</code>或<code>/</code>时，当前页面显示 <code>Home</code> 组件内容</li><li>地址后的路径为：<code>/about</code>时，，当前页面显示 <code>About</code> 组件内容</li><li>地址后的路径为：<code>/news</code>时，，当前页面显示 <code>News</code> 组件内容</li><li>当访问不存在的页面时，会显示<code>NotFound</code>组件内容，即：404 页面</li></ul></blockquote><ol><li>实现原理</li></ol><ul><li>针对a标签，通过监听<code>&lt;a&gt;</code>标签的点击事件，在事件中获取要跳转的 url，同时调用<code>pushState</code>和<code>replaceState</code>方法来实现地址栏中 URL 的变化，最后根据 url 来显示对应的组件</li><li>针对调用<code>histroy</code>的<code>go</code>、<code>back()</code>、<code>forward()</code>或浏览器的前进后退按扭来改变 URL。通过监听<code>popstate</code>事件，在该事件中通过<code>location.pathname</code>来获取更新后的 url 路径，最后根据 url 来显示对应的组件</li></ul><ol start="2"><li>实现步骤<blockquote><p>定义如下html结构，<code>currentView</code>变量保存了当前需要显示的组件</p></blockquote></li></ol><pre><code>&lt;template&gt;  &lt;!-- 路由导航 --&gt;  &lt;ul class=&quot;router-link&quot; @click.prevent=&quot;onPushState&quot;&gt;    &lt;li&gt;&lt;a href=&quot;/home&quot;&gt;网站首页&lt;/a&gt;&lt;/li&gt;    &lt;li&gt;&lt;a href=&quot;/about&quot;&gt;关于我们&lt;/a&gt;&lt;/li&gt;    &lt;li&gt;&lt;a href=&quot;/news&quot;&gt;新闻中心&lt;/a&gt;&lt;/li&gt;    &lt;li&gt;&lt;a href=&quot;/product&quot;&gt;产品中心&lt;/a&gt;&lt;/li&gt;  &lt;/ul&gt;  &lt;!-- 路由内容出口 --&gt;  &lt;component :is=&quot;currentView&quot; class=&quot;router-view&quot; /&gt;&lt;/template&gt;&lt;style scoped&gt;  .router-link &#123;    display: flex;    margin: 10px auto;    text-align: center;    list-style: none;  &#125;  .router-link li &#123;    margin: 0 10px;  &#125;  .router-link li a &#123;    color: #000;    font-size: 20px;    text-decoration: none;  &#125;  .router-view &#123;    margin: 20px;    font-size: 30px;    min-height: 300px;  &#125;&lt;/style&gt;</code></pre><ul><li>在当前项目的src目录下，新建<code>views</code>目录，在此目录下创建应用需要用到的所有视图组件</li></ul><pre><code>views / Home.vue; // Home 组件views / About.vue; //  About 组件views / News.vue; // News 组件views / NotFound.vue; // NotFound 组件</code></pre><ul><li>定义路由对象routes，这个对象的属性和值分别为 url和url路径值需要显示的组件。</li></ul><pre><code>// 定义一些路由const routes = &#123;  &quot;/&quot;: Home,  &quot;/home&quot;: Home,  &quot;/about&quot;: About,  &quot;/news&quot;: News,&#125;;</code></pre><ul><li>定义<code>currentPath</code>变量，用来保存当前 url 的路径址值</li></ul><pre><code>// 获取当前地址的hash值const currentPath = ref(window.location.pathname);监听浏览器的popstate事件，当url路径值改变时，修改currentPath的值// 监听浏览器的hashchange事件，当hash值改变时，修改currentPath的值window.addEventListener(&quot;hashchange&quot;, () =&gt; &#123;  currentPath.value = window.location.pathname;&#125;);</code></pre><ul><li>创建一个计算属性<code>currentView</code>，根据url路径值，返回最终要显示的组件。</li></ul><pre><code>// 计算属性，根据hash值，返回最终需要显示的组件const currentView = computed(() =&gt; &#123;  // currentPath.value.slice(1) || &#39;/&#39; 表示访问根目录时，显示Home组件内容  // 当访问routes中不存在的地址时，显示NotFound组件（404页面）  // slice(1) 去掉hash值前面的#号  return routes[currentPath.value.slice(1) || &quot;/&quot;] || NotFound;&#125;);</code></pre><ul><li>处理 a 标签的点击事件，获取 a 标签上的href属性值，然后通过<code>history.pushState()</code>方法来更新 url 路径。最后修改<code>pathname</code>的值，当<code>pathname</code>值改时，计算属性<code>currentView</code>会重新计算，得到新的需要显示的组件</li></ul><pre><code>// a标签点击事件的处理函数function onPushState(e) &#123;  //获取href属性的值  const url = e.target.getAttribute(&quot;href&quot;);  // 添加一条新的历史条目（修改地址栏中URL）  history.pushState(&#123;&#125;, &quot;&quot;, url);  // 给pathname重新赋值，会触发currentView计算属性重新计算，返回新的组件  pathname.value = url;&#125;</code></pre><ol start="3"><li>完整版代码</li></ol><pre><code>&lt;script setup&gt;  import &#123; computed, ref &#125; from &quot;@vue/reactivity&quot;;  import About from &quot;./views/About.vue&quot;;  import Home from &quot;./views/Home.vue&quot;;  import News from &quot;./views/News.vue&quot;;  import NotFound from &quot;./views/NotFound.vue&quot;;  // 定义一些路由 url与显示的组件映射关系  const routes = &#123;    &quot;/&quot;: Home,    &quot;/home&quot;: Home,    &quot;/about&quot;: About,    &quot;/news&quot;: News,  &#125;;  // 获取当前地址后面的路径值  const pathname = ref(window.location.pathname);  // a标签点击事件的处理函数  function onPushState(e) &#123;    const target = e.target;    const tagName = target.tagName.toLowerCase();    if (tagName !== &quot;a&quot;) return;    //获取href属性的值    const url = e.target.getAttribute(&quot;href&quot;);    // 添加一条新的历史条目（修改地址栏中URL）    history.pushState(&#123;&#125;, &quot;&quot;, url);    // 给pathname重新赋值，会触发currentView计算属性重新计算，返回新的组件    pathname.value = url;  &#125;  // 计算属性，根据路径返回最终要显示的组件  const currentView = computed(() =&gt; &#123;    return routes[pathname.value || &quot;/&quot;] || NotFound;  &#125;);  // 监听window的popstate事件  window.addEventListener(&quot;popstate&quot;, () =&gt; &#123;    // 获取url后面路径    pathname.value = window.location.pathname;  &#125;);&lt;/script&gt;&lt;template&gt;  &lt;!--路由--&gt;  &lt;ul class=&quot;router-link&quot; @click.prevent=&quot;onPushState&quot;&gt;    &lt;li&gt;&lt;a href=&quot;/home&quot;&gt;网站首页&lt;/a&gt;&lt;/li&gt;    &lt;li&gt;&lt;a href=&quot;/about&quot;&gt;关于我们&lt;/a&gt;&lt;/li&gt;    &lt;li&gt;&lt;a href=&quot;/news&quot;&gt;新闻中心&lt;/a&gt;&lt;/li&gt;    &lt;li&gt;&lt;a href=&quot;/product&quot;&gt;产品中心&lt;/a&gt;&lt;/li&gt;  &lt;/ul&gt;  &lt;!--路由内容显示出口--&gt;  &lt;component :is=&quot;currentView&quot; class=&quot;router-view&quot; /&gt;&lt;/template&gt;&lt;style scoped&gt;  .router-link &#123;    display: flex;    margin: 10px auto;    text-align: center;    list-style: none;  &#125;  .router-link li &#123;    margin: 0 10px;  &#125;  .router-link li a &#123;    color: #000;    font-size: 20px;    text-decoration: none;  &#125;  .router-view &#123;    margin: 20px;    font-size: 30px;    min-height: 300px;  &#125;&lt;/style&gt;</code></pre><h3 id="五、Vue-Router-的基本用法"><a href="#五、Vue-Router-的基本用法" class="headerlink" title="五、Vue Router 的基本用法"></a>五、Vue Router 的基本用法</h3><blockquote><p><code>Vue Router</code>是<code>Vue.js</code>的官方路由。它与 <code>Vue.js</code> 核心深度集成，让用 <code>Vue.js</code> 构建SPA 单页应用变得轻而易举。在 Vue3 中需要安装<code>vue-router4</code> 版本。</p><ul><li><code>Vue Router</code> 官网地址：<code>https://router.vuejs.org/zh/guide/</code></li></ul></blockquote><h4 id="使用-vue-router-的步骤"><a href="#使用-vue-router-的步骤" class="headerlink" title="使用 vue-router 的步骤"></a>使用 vue-router 的步骤</h4><blockquote><p>在 vue3 中使用<code>vue-router@4.x</code>版本步骤</p><ul><li>第一步：安装<code>vue-router@4</code></li><li>第二步：定义路由组件</li><li>第二步：创建路由实例</li><li>第三步：配置路由映射：路径和组件映射关系</li><li>第四步：在 app 应用实例中挂载创建的路由实例</li><li>第五步：使用路由：通过<code>&lt;router-link&gt;</code>和<code>&lt;router-view&gt;</code>组件</li></ul></blockquote><ol><li>第一步：安装<code>vue-router@4.x</code>版本<blockquote><p>执行以下 npm 命令，安装<code>vue-router4.x</code>版本，安装成生产依赖</p></blockquote></li></ol><pre><code>npm install vue-router@4</code></pre><ol start="2"><li>第二步：定义路由组件<blockquote><p>在 <code>src/views/</code>目录下新建当前应用需要用到的所有路由组件（也称视图组件）</p></blockquote></li></ol><pre><code>views / Home.vue; // Home 组件views / About.vue; //  About 组件views / News.vue; // News 组件</code></pre><ol start="3"><li>第三步：创建路由实例<blockquote><p>在<code>src/router/</code>目录下新建<code>router.js</code>文件，此文件最终对外暴露<code>router</code>路由实例</p></blockquote></li></ol><pre><code>import &#123; createRouter, createWebHashHistory &#125; from &quot;vue-router&quot;;// createRouter方法，用来创建路由实例，参数为一个对象，用来配置路由相关信息const router = createRouter(&#123;  // 路由模式，createWebHashHistory()创建 hash 模式。  history: createWebHashHistory(),&#125;);// 对外暴露router实例export &#123; router &#125;;</code></pre><ol start="4"><li>第四步：配置路由映射 - 路径和组件映射关系</li></ol><ul><li>①、导入路由组件</li><li>②、定义路由：路径与组件的映射关系</li><li>③、在createRouter方法的参数中配置routes选项</li></ul><pre><code>import &#123; createRouter, createWebHashHistory &#125; from &quot;vue-router&quot;;// 1、导入路由组件 -------------------import Home from &quot;../views/Home.vue&quot;;import About from &quot;../views/About.vue&quot;;import News from &quot;../views/News.vue&quot;;// 2、定义一些路由： 路径和组件映射关系 -------------------const routes = [  &#123;    path: &quot;/&quot;, // 路径    component: Home, // 路径对应渲染的组件  &#125;,  &#123;    path: &quot;/about&quot;,    component: About,  &#125;,  &#123;    path: &quot;/news&quot;,    component: News,  &#125;,];// createRouter方法，用来创建路由实例，参数为一个对象，用来配置路由相关信息const router = createRouter(&#123;  // 路由模式，createWebHashHistory()创建 hash 模式。  history: createWebHashHistory(),  // 3、配置routes -------------------  routes, // &#39;routes&#39;:routes的缩写&#125;);// 对外暴露router实例export &#123; router &#125;;</code></pre><ol start="5"><li>第五步：全局注册 router 实例<blockquote><p>在<code>main.js</code>中利用 <code>app.use</code> 方法注册 <code>router</code> 路由实例</p></blockquote></li></ol><pre><code>import &#123; createApp &#125; from &quot;vue&quot;;import App from &quot;./App.vue&quot;;// 导入router实例import &#123; router &#125; from &quot;./router/router.js&quot;;const app = createApp(App);// 全局注册路由app.use(router);app.mount(&quot;#app&quot;);</code></pre><ol start="6"><li>第六步：使用路由通过<code>&lt;router-link&gt;</code>和<code>&lt;router-view&gt;</code><blockquote><p>可以在<code>App.vue</code>组件中调用<code>&lt;router-link&gt;</code>和<code>&lt;router-view&gt;</code>组件使用路由</p></blockquote></li></ol><ul><li><code>&lt;router-link&gt;</code>组件用来创建链接，最终会生成<code>&lt;a&gt;</code>标签形式的导航</li><li><code>&lt;router-view&gt;</code>组件用来显示与<code>Url</code>对应的组件内容</li></ul><pre><code>&lt;!--App组件--&gt;&lt;template&gt;  &lt;ul class=&quot;router-link&quot;&gt;    &lt;!--创建a标签链接  to属性最终转换为a标签的href属性值--&gt;    &lt;li&gt;&lt;router-link to=&quot;/&quot;&gt;网站首页&lt;/router-link&gt;&lt;/li&gt;    &lt;li&gt;&lt;router-link to=&quot;/about&quot;&gt;关于我们&lt;/router-link&gt;&lt;/li&gt;    &lt;li&gt;&lt;router-link to=&quot;/news&quot;&gt;新闻中心&lt;/router-link&gt;&lt;/li&gt;  &lt;/ul&gt;  &lt;div class=&quot;router-view&quot;&gt;    &lt;!--url对应组件内容渲染出口--&gt;    &lt;router-view&gt;&lt;/router-view&gt;  &lt;/div&gt;&lt;/template&gt;&lt;style&gt;  .router-link &#123;    display: flex;    justify-content: center;    text-align: center;    list-style: none;    margin-top: 30px;  &#125;  .router-link li &#123;    margin: 0 10px;  &#125;  .router-link li a &#123;    color: #000;    font-size: 16px;    text-decoration: none;  &#125;  .router-link li a:hover &#123;    color: tomato;  &#125;  .router-view &#123;    width: 80%;    margin: 30px auto;    font-size: 20px;    min-height: 300px;    background-color: rgb(251, 249, 249);  &#125;&lt;/style&gt;</code></pre><ul><li>经过以上 6 步，最终我们完成了刚开始我们期望的效果。</li></ul><h4 id="路由模式"><a href="#路由模式" class="headerlink" title="路由模式"></a>路由模式</h4><blockquote><p><code>createRouter</code>方法参数对象的<code>history</code>属性用来指定路由的模式，当<code>history</code>的值为</p></blockquote><ul><li><code>createWebHashHistory()</code>创建 <code>hash</code> 路由模式</li><li><code>createWebHistory()</code>创建 <code>history</code> 路由 模式</li></ul><pre><code>const router = createRouter(&#123;  // history属性指定路由模式  history: createWebHashHistory(), // 创建 hash 路由 模式。  //  history: createWebHistory(),  // 创建 history 路由 模式&#125;);</code></pre><h4 id="链接激活时-Class-类名"><a href="#链接激活时-Class-类名" class="headerlink" title="链接激活时 Class 类名"></a>链接激活时 Class 类名</h4><blockquote><p>默认情况下，链接被激活时会加上<code>router-link-active</code> Class 类名，比如前面提到的案例<br><img src="链接激活时class类名.png"></p></blockquote><ul><li>我们可以通过添中<code>router-link-active</code> Class 类名，来控制被激活链接的样式</li></ul><pre><code>/* 在上面案例的基础上，在style标签中 添加如下css样式 */.router-link li a.router-link-active &#123;  color: tomato;&#125;</code></pre><ul><li>我们还可以设置<code>&lt;router-link&gt;</code>组件的<code>active-class</code>属性值来更改链接激活时使用的 CSS 类名</li></ul><pre><code>/* 我们修改上面案例中的如下css样式 */.router-link li a.router-link-active &#123;  color: tomato;&#125;/* 修改成 */.router-link li a.active &#123;  color: tomato;&#125;</code></pre><h4 id="去掉路由历史记录"><a href="#去掉路由历史记录" class="headerlink" title="去掉路由历史记录"></a>去掉路由历史记录</h4><blockquote><p>如果想在页面切换时，不留下历史记录，也就是在浏览器最顶部左侧不会出现前进和后退按扭。我们只需要在<code>&lt;router-link&gt;</code>标签上添加<code>replace</code>属性（表示用当前路径替换之前路径）</p><ul><li>修改以上案例中<code>&lt;App&gt;</code>组件中 所有<code>&lt;router-link&gt;</code>标签内容如下：</li></ul></blockquote><pre><code>&lt;ul class=&quot;router-link&quot;&gt;  &lt;!--创建a标签链接  to属性最终转换为a标签的href属性值--&gt;  &lt;li&gt;    &lt;router-link to=&quot;/&quot; replace active-class=&quot;active&quot;&gt;网站首页&lt;/router-link&gt;  &lt;/li&gt;  &lt;li&gt;    &lt;router-link to=&quot;/about&quot; replace active-class=&quot;active&quot;      &gt;关于我们&lt;/router-link    &gt;  &lt;/li&gt;  &lt;li&gt;    &lt;router-link to=&quot;/news&quot; replace active-class=&quot;active&quot;&gt;新闻中心&lt;/router-link&gt;  &lt;/li&gt;&lt;/ul&gt;</code></pre><ul><li>最终效果如下，注意观察，导航切换时，浏览器最顶部前进和后退按扭一直是不灰色，不可点状态</li></ul><h4 id="访问router实例和当前路由route"><a href="#访问router实例和当前路由route" class="headerlink" title="访问router实例和当前路由route"></a>访问router实例和当前路由route</h4><blockquote><p>通过调用<code>app.use(router)</code>注册<code>vue-router</code>插件后。</p></blockquote><p>选项式 API 中，我们可以在任意的组件中以</p><ul><li><code>this.$router</code>访问到<code>router</code>实例 (即：<code>createRouter()</code>方法返回的 <code>router</code> 实例)</li><li><code>this.$route</code>访问到当前路由</li></ul><p>组合式 API 中，我们可以在任意组件中，调用<code>vue router</code>提供的</p><ul><li><code>useRouter</code> 函数访问到<code>router</code> 实例</li><li><code>useRoute</code> 函数访问到当前路由</li></ul><p>在任意组件的模板中，通过</p><ul><li><p><code>$router</code>访问到 <code>router</code> 实例</p></li><li><p><code>$route</code>访问到当前路由</p></li><li><p><a href="https://v3.router.vuejs.org/zh/api/#router-%E5%AE%9E%E4%BE%8B%E6%96%B9%E6%B3%95">路由实例方法查阅教程</a></p></li><li><p><a href="https://v3.router.vuejs.org/zh/api/#%E8%B7%AF%E7%94%B1%E5%AF%B9%E8%B1%A1%E5%B1%9E%E6%80%A7">路由对象属性查阅教程</a></p></li><li><p>用以下代码，替换前面案例中的<code>About</code>组件内容</p></li></ul><pre><code>&lt;script&gt;  export default &#123;    data() &#123;      // this.$router.currentRoute.value.path 当有url后面的路径值      console.log(&quot;选项式API：路由实例&quot;, this.$router.currentRoute.value.path);      console.log(&quot;选项式API：当前路由信息&quot;, this.$route.path);      return &#123;&#125;;    &#125;,  &#125;;&lt;/script&gt;&lt;script setup&gt;  import &#123; useRouter, useRoute &#125; from &quot;vue-router&quot;;  console.log(&quot;组合式API：路由实例&quot;, useRouter().currentRoute.value.path);  console.log(&quot;组合式API：当前路由信息&quot;, useRoute().path);&lt;/script&gt;&lt;template&gt;  &lt;div&gt;关于我们&lt;/div&gt;  &lt;div&gt;路由实例：&#123;&#123; $router.currentRoute.value.path &#125;&#125;&lt;/div&gt;  &lt;div&gt;当前路由的路径：&#123;&#123; $route.path &#125;&#125;&lt;/div&gt;&lt;/template&gt;</code></pre><h4 id="嵌套路由"><a href="#嵌套路由" class="headerlink" title="嵌套路由"></a>嵌套路由</h4><blockquote><p>以下图中展示的效果就是一个嵌套路由效果</p></blockquote><ul><li>在点击<code>News</code>导航时，会显示对应组件的内容，在该组件中还存在二级导航，点击对应二级导航时，会加载不同的组件来显示不同内容。</li><li>我们把<code>/home</code>、<code>/about</code>、<code>/news</code>看作是一级路由，则<code>/news/tab1</code>、<code>/news/tab2</code>、<code>/news/tab3</code>可以看成是二级路由。</li><li>并且这些路由显示的内容是嵌套在<code>/news</code>路由所在组件中，所以我们在定义路由时，需要把这些二级路由作为<code>/news</code>路由的子路由</li></ul><img src="嵌套路由.gif"><blockquote><p>以下代码为<code>/news</code>一级路由定义了三个子路由 ,记得先用<code>import</code>导入Tab1、Tab2、Tab3（用以下代码替换前面案例中的对应代码）</p></blockquote><pre><code>&#123;    path: &quot;/news&quot;,    component: News,     // 所有子路由的书写方式和父路由一样，父路由对应子路由按以下方式写在children数组中    children: [        &#123;            // 这里不需要加 / ，加/ 表示的是绝对路径  http://www.xx.com/tab1            // 不加表示相对父路由而言  http://www.xx.com/news/tab1            path: &quot;tab1&quot;,            component: Tab1,        &#125;,        &#123;            path: &quot;tab2&quot;,            component: Tab2,        &#125;,        &#123;            path: &quot;tab3&quot;,            component: Tab3,        &#125;    ]&#125;</code></pre><ul><li>子路由是在父路由组件中显示的，所以我们需要在父路由组件<code>News</code>中来定义子路由链接及路由组件内容渲染出口</li><li>用以下代码替换掉前面案例中的<code>News.vue</code>组件内容。</li></ul><pre><code>&lt;!--News.vue 组件--&gt;&lt;template&gt;  &lt;div class=&quot;menu&quot;&gt;    &lt;router-link to=&quot;/news/tab1&quot;&gt;最新动态&lt;/router-link&gt; |    &lt;router-link to=&quot;/news/tab2&quot;&gt;热门推荐&lt;/router-link&gt; |    &lt;router-link to=&quot;/news/tab3&quot;&gt;历史动态&lt;/router-link&gt;  &lt;/div&gt;  &lt;div class=&quot;main&quot;&gt;    &lt;router-view /&gt;  &lt;/div&gt;&lt;/template&gt;&lt;style scoped&gt;  .menu a &#123;    font-size: 16px;  &#125;  .router-link-active &#123;    color: #fff;    background-color: skyblue;    padding: 5px;    border-radius: 10px;  &#125;&lt;/style&gt;</code></pre><ul><li>按以上两步操作后，就可以实现如上图所示案例效果。</li><li>关于更深层级的路由嵌套和上面一样，一层一层嵌套下去就好</li></ul><h4 id="链接精确激活时-Class-类名"><a href="#链接精确激活时-Class-类名" class="headerlink" title="链接精确激活时 Class 类名"></a>链接精确激活时 Class 类名</h4><blockquote><p>默认情况下，链接精确激活时会加上<code>router-link-exact-active</code> Class 类名。</p></blockquote><blockquote><p>链接精确激活与链接激活的区别</p></blockquote><ul><li>精确激活：当地址栏链接为<code>/news/tab1</code>时，则只有链接<code>/news/tab1</code>对应的 <code>a</code> 标签会被添加<code>router-link-exact-active</code> Class 类，此时<code>/news/tab1</code>链接为精确激活状态</li><li>激活：当地址栏链接为<code>/news/tab1</code>时，链接<code>/news</code>和<code>/news/tab1</code>对应的 a 标签会被添加<code>router-link-active Class</code> 类名，此时<code>/news/tab1</code>和<code>/news</code>链接为激活状态<ul><li>激活状态的链接中包含精确激活状态的链接</li></ul></li><li>如果精确激活的链接样式包含了激活链接的样式，则我们只需要针不同部分的样式，给精确激活的链接添加<code>router-link-exact-active</code>类名来实现。</li></ul><blockquote><p><code>exact-active-class</code> 属性</p></blockquote><ul><li>我们可以通过<code>&lt;router-link&gt;</code>标签的<code>exact-active-class</code>属性来自定义精确激活链接时添加的 Class 类名</li></ul><pre><code>&lt;router-link to=&quot;/news/tab1&quot; exact-active-class=&quot;exact-active&quot;  &gt;最新动态&lt;/router-link&gt;</code></pre><h4 id="命名路由"><a href="#命名路由" class="headerlink" title="命名路由"></a>命名路由</h4><blockquote><p>在定义路由时，我们可以为路由添加<code>name</code>属性来指定路由的名字</p></blockquote><pre><code>const routes = [    &#123;        name: &#39;home&#39;, // 路由名字，名字自定义，不一定是home        path: &quot;/&quot;, // 路径        component: Home, // 路径对应渲染的组件    &#125;,    &#123;        name: &#39;about&#39;,        path: &quot;/about&quot;,        component: About,    &#125;,    &#123;        name: &#39;news&#39;,        path: &quot;/news&quot;,        component: News,        children: [            &#123;                name:&#39;tab1&#39; // 路由名字                path: &quot;tab1&quot;,                component: Tab1,            &#125;,            &#123;                path: &quot;tab2&quot;,                component: Tab2,            &#125;,            &#123;                path: &quot;tab3&quot;,                component: Tab3,            &#125;        ]    &#125;]</code></pre><ul><li>有了<code>name</code>属性后，我们可以向<code>&lt;rotuer-link&gt;</code>组件的 <code>to</code> 属性传递一个对象，来实现路由的跳转。</li></ul><pre><code>&lt;!--以下方式，会根据name属性来找到指定的路由中的path值，实现路由跳转--&gt;&lt;router-link :to=&quot;&#123; name: &#39;home&#39; &#125;&quot; active-class=&quot;active&quot;&gt;Home&lt;/router-link&gt; |&lt;router-link :to=&quot;&#123; name: &#39;about&#39; &#125;&quot; active-class=&quot;active&quot;&gt;About&lt;/router-link&gt; |&lt;router-link :to=&quot;&#123; name: &#39;news&#39; &#125;&quot; active-class=&quot;active&quot;&gt;News&lt;/router-link&gt;&lt;!--以上代码，与以下代码实现的效果一模一样--&gt;&lt;router-link to=&quot;/&quot; active-class=&quot;active&quot;&gt;Home&lt;/router-link&gt; |&lt;router-link to=&quot;/about&quot; active-class=&quot;active&quot;&gt;About&lt;/router-link&gt; |&lt;router-link to=&quot;/news&quot; active-class=&quot;active&quot;&gt;News&lt;/router-link&gt;</code></pre><ul><li>当<code>&lt;router-link&gt;</code>to 的属性值为一个<strong>对象</strong>时，<code>name</code> 属性与 <code>path</code> 属性只需要写一个即可</li></ul><pre><code>&lt;!--以下写法是错的--&gt;&lt;router-link :to=&quot;&#123;name:&#39;home&#39;,path:&#39;/&#39;&#125;&quot; active-class=&quot;active&quot;  &gt;Home&lt;/router-link&gt;&lt;!--以下两种写法是对的--&gt;&lt;router-link :to=&quot;&#123;name:&#39;home&#39;&#125;&quot; active-class=&quot;active&quot;&gt;Home&lt;/router-link&gt; |&lt;router-link :to=&quot;&#123;path:&#39;/&#39;&#125;&quot; active-class=&quot;active&quot;&gt;Home&lt;/router-link&gt; |</code></pre><ul><li>当我们的路由名很长很复杂时，在<code>&lt;router-link&gt;</code>标签中可以通过<code>name</code>属性来简化，而不需要书写<code>path</code>属性</li></ul><h4 id="路由重定向"><a href="#路由重定向" class="headerlink" title="路由重定向"></a>路由重定向</h4><blockquote><p>当我们访问某个路径时，我们希望他能重定向到其它的路径，比如访问<code>/news</code>时，希望重定向到到<code>/news/tab1</code></p><p>我们就可以在路由的配置中添加<code>redirect</code>属性来实现路由的重定向。</p></blockquote><ul><li>重定向的目标可以是一个<strong>字符串路径</strong></li></ul><pre><code>&#123;        name: &#39;news&#39;,        path: &quot;/news&quot;,        component: News,        redirect: &quot;/news/tab1&quot;,  // 重定向到 /news/tab1        children: [            &#123;                name: &#39;tab1&#39;,                path: &quot;tab1&quot;,                component: Tab1,            &#125;,           // ....此处省略部分代码        ]    &#125;</code></pre><ul><li>重定向的目标可以是一个<strong>命名的路由</strong> （采用路由对象写法）</li></ul><pre><code>&#123;        name: &#39;news&#39;,        path: &quot;/news&quot;,        component: News,        redirect: &#123; name: &#39;tab1&#39; &#125;,  // 重定向到路由命名name所在的路径        children: [            &#123;                name: &#39;tab1&#39;,                path: &quot;tab1&quot;,                component: Tab1,            &#125;,           // ....此处省略部分代码        ]    &#125;</code></pre><ul><li>重定向的目标也可以是一个<strong>方法</strong>，该方法的返回值可以是前面提到的”字符串路径” 或 “路由对象”中的一种</li></ul><pre><code>&#123;        name: &#39;news&#39;,        path: &quot;/news&quot;,        component: News,       redirect: (to) =&gt; &#123; // to为目标路由对象，此处为/news路由对象//  &#123;fullPath: &#39;/news&#39;, hash: &#39;&#39;, query: &#123;…&#125;, name: &#39;news&#39;, path: &#39;/news&#39;, …&#125;            console.log(to)            return &#123; path: &#39;/news/tab1&#39; &#125;        &#125;        children: [            &#123;                name: &#39;tab1&#39;,                path: &quot;tab1&quot;,                component: Tab1,            &#125;,           // ....此处省略部分代码        ]    &#125;</code></pre><ul><li>以上三种方式，最终都能实现，当我们访问<code>/news</code>路由时，会重定向到<code>/new/tab1</code>路由</li></ul><blockquote><p>注意事项</p></blockquote><ul><li>如果重定向的路由<strong>没有子路由</strong>，则该路由中的<code>component</code>可以省略不写，因为它从来没有被直接访问过</li></ul><pre><code>const routes = [    &#123;        path:&quot;/&quot;        redirect:&quot;/home&quot;        // 此处可以没有component    &#125;,    &#123;        name: &#39;home&#39;, // 名字自定义，不一定是home        path: &quot;/home&quot;, // 路径        component: Home,    &#125;]</code></pre><h3 id="六、vue-Router-路由传参"><a href="#六、vue-Router-路由传参" class="headerlink" title="六、vue Router 路由传参"></a>六、vue Router 路由传参</h3><blockquote><p>在路由进行跳转时，我们可以通过传参的形式为当前路由携带相关数据。</p><ul><li>路由传参有以下两种形式：</li></ul></blockquote><ul><li>query 参数</li><li>params 参数</li></ul><h4 id="路由的-query-参数"><a href="#路由的-query-参数" class="headerlink" title="路由的 query 参数"></a>路由的 query 参数</h4><blockquote><p><code>query</code> 参数最终会以<code>key = value</code>键值对的形式出现在地址 <code>？</code>后面</p></blockquote><ul><li>我们来看下面这个路由</li></ul><pre><code>const routes = [  &#123;    name: &quot;user&quot;,    path: &quot;/user&quot;,    component: User,  &#125;,  // ....];</code></pre><ol><li>传递<code>query</code>参数<blockquote><p>我们在定义路由导航时，就可以通过以下两种方式来传递<code>query</code>参数</p><ul><li>query 参数的两种写法</li></ul></blockquote></li></ol><ul><li>直接在地址后面以<code>key=value</code>形式携带传递的数据</li></ul><pre><code>&lt;!--id=001 为传递的参数数据--&gt;&lt;router-link to=&quot;/user?id=001&quot;&gt;用户中心&lt;/router-link&gt;</code></pre><ul><li>将<code>to</code>属性的值定义为一个路由对象，通过<code>query</code>字段来传递参数</li></ul><pre><code>&lt;router-link  :to=&quot;&#123;                  path: &#39;/user&#39;,                  query: &#123;                      id: &#39;001&#39;,                         title:&#39;abc&#39;                  &#125;                  &#125;&quot;  &gt;用户中心&lt;/router-link&gt;&lt;!-- 也可以采用如下写法 --&gt;&lt;router-link  :to=&quot;&#123;                  name: &#39;user&#39;,                  query: &#123;                      id: &#39;001&#39;                  &#125;                  &#125;&quot;  &gt;用户中心&lt;/router-link&gt;</code></pre><ol start="2"><li>接受 query 参数</li></ol><ul><li>在<code>User.vue</code>组件中，接受传递的<code>query</code>参数，代码如下：</li></ul><pre><code>&lt;script setup&gt;  import &#123; useRoute &#125; from &quot;vue-router&quot;;  // 当前路由对象  const route = useRoute();  // 读取query参数  console.log(route.query.id); // 001&lt;/script&gt;&lt;template&gt;  &lt;div&gt;用户中心&lt;/div&gt;  &lt;!--$route.query.id 读取传递的id，值为 001--&gt;  &lt;div&gt;query参数：&#123;&#123; $route.query.id &#125;&#125;&lt;/div&gt;  &lt;div&gt;query参数：&#123;&#123; route.query.id &#125;&#125;&lt;/div&gt;&lt;/template&gt;</code></pre><ol start="3"><li>实战应用：根据 query 参数渲染数据</li></ol><ul><li>当我们点击不同的新闻标题时，需要把当前新闻的<code>id</code>作为参数传递给到<code>Detail</code>组件</li><li><code>Detail</code>组件接受传递过来的<code>id</code>值，向后端发请求获取当前<code>Id</code>对应的新闻详细内容，然后渲染在页面中</li></ul><blockquote><p>实现步骤</p></blockquote><ul><li>在前面项目的基础上，在<code>views/news</code>目录下新建<code>Detail</code>组件</li><li>在<code>routes</code>配置中，<code>/news/detail</code>路由定义为<code>/news</code>的子路由，因为<code>/news/detail</code>路由对应的组件最终被渲染后显示在<code>News</code>组件中</li></ul><pre><code>const routes = [  // ...省略部分代码    &#123;        name: &#39;news&#39;,        path: &quot;/news&quot;,        component: News,        redirect: &#123; name: &#39;tab1&#39; &#125;,  // 重定向到路由命名name所在的路径        children: [            // 因为该组件内容显示在  News组件中，所以定义为他的子路由            &#123;                name: &quot;detail&quot;,                path: &#39;detail&#39;,                component: Detail            &#125;,            &#123;                name: &#39;tab1&#39;,                path: &quot;tab1&quot;,                component: Tab1,            &#125;            // ....省略部分代码        ]    &#125;]</code></pre><ul><li>修改组件 Tab1 的内容如下</li></ul><pre><code>&lt;script setup&gt;  import &#123; reactive &#125; from &quot;vue&quot;;  const list = reactive([    &#123;      id: &quot;001&quot;,      title: &quot;新闻标题1111&quot;,    &#125;,    &#123;      id: &quot;002&quot;,      title: &quot;新闻标题2222&quot;,    &#125;,    &#123;      id: &quot;003&quot;,      title: &quot;新闻标题3333&quot;,    &#125;,  ]);&lt;/script&gt;&lt;template&gt;  &lt;div&gt;最新动态内容&lt;/div&gt;  &lt;ul&gt;    &lt;li v-for=&quot;&#123; id, title &#125; in list&quot;&gt;      &lt;!--  方式一            &lt;RouterLink :to=&quot;`/news/detail?id=$&#123;id&#125;`&quot;&gt;&#123;&#123; title &#125;&#125;&lt;/RouterLink&gt;             --&gt;      &lt;!--以下把path去掉,改用name=&quot;detail&quot; 也可以--&gt;      &lt;RouterLink        :to=&quot;&#123;                path: &#39;/news/detail&#39;,                query: &#123;                    id: `$&#123;id&#125;`                &#125;            &#125;&quot;        &gt;&#123;&#123; title &#125;&#125;&lt;/RouterLink      &gt;    &lt;/li&gt;  &lt;/ul&gt;&lt;/template&gt;&lt;style scoped&gt;  ul li &#123;    line-height: 35px;    border-bottom: 1px dashed #ddd;  &#125;  ul li a &#123;    font-size: 16px;    color: #666;  &#125;&lt;/style&gt;</code></pre><ul><li>在Detail组件中接受传递的id参数，并根据 id 查找满足条件的新闻，将新闻标题和内容显示在页面中</li></ul><pre><code>&lt;script setup&gt;  import &#123; ref &#125; from &quot;vue&quot;;  import axios from &quot;axios&quot;;  import &#123; useRoute &#125; from &quot;vue-router&quot;;  // 获取当前路由  const route = useRoute();  // 接受传递的参数id  const id = route.query.id;  // 保存请求回来的新闻详情  const info = ref(&#123;&#125;);  // 根据id来发请求，获取当前新闻的详细内容  axios    .get(      `https://www.fastmock.site/mock/6ec78e345df340241e1f5043f0167833/icode/detail/$&#123;id&#125;`    )    .then((res) =&gt; &#123;      info.value = res.data.data;    &#125;)    .catch((err) =&gt; &#123;      console.log(err);    &#125;);&lt;/script&gt;&lt;template&gt;  &lt;h3&gt;&#123;&#123; info.title &#125;&#125;&lt;/h3&gt;  &lt;div class=&quot;main&quot;&gt;&#123;&#123; info.content &#125;&#125;&lt;/div&gt;&lt;/template&gt;</code></pre><h4 id="路由的-params-参数"><a href="#路由的-params-参数" class="headerlink" title="路由的 params 参数"></a>路由的 params 参数</h4><ol><li>以<code>params</code>形式传参，需要在配置路由时，以<code>:key</code>形式先占位。<blockquote><ul><li>如下：</li></ul></blockquote></li></ol><pre><code>const routes=[    // ....            &#123;                name:&#39;detail&#39;,                 // 能匹配detail/12  detail/ab    不能匹配detail/12/b                path:&#39;detail/:id&#39;,                component:Detail            &#125;,            &#123;               path:&#39;add/:id/:typeid                // path:&#39;add/:id/a/:typeid&#39;                component:Add&#39;            &#125;            // ......        ]</code></pre><ol start="2"><li>在<code>&lt;router-link&gt;</code>组件中，<code>to</code>属性的值可以写成一个路由对象，<code>params</code>属性表示传递的参数。<blockquote><ul><li>注意：以 <code>params</code> 形式传参时，只能通过<code>name</code>属性来指定要跳转的链接，<strong>不能</strong>用<code>path</code>属性。</li></ul></blockquote></li></ol><pre><code>&lt;RouterLink  :to=&quot;&#123;                name: &#39;detail&#39;,                params: &#123;                    id: &#39;001&#39;                &#125;            &#125;&quot;  &gt;&#123;&#123; title &#125;&#125;&lt;/RouterLink&gt;&lt;!--以下为错误写法,params只能与name属性配合使用 --&gt;&lt;RouterLink  :to=&quot;&#123;                path: &#39;/news/detail/&#39;,                params: &#123;                    id: &#39;001&#39;                &#125;                  &#125;&quot;  &gt;&#123;&#123; title &#125;&#125;&lt;/RouterLink&gt;</code></pre><ol start="3"><li>在组件中可以通过<code>params.id</code>形式来访问到传递的<code>params</code>参数 <code>id</code> 等。</li></ol><pre><code>&lt;script setup&gt;  import &#123; useRouter, useRoute &#125; from &quot;vue-router&quot;;  console.log(&quot;参数id:&quot;, useRoute().params.id);&lt;/script&gt;&lt;template&gt;  &lt;div&gt;params参数：&#123;&#123; $route.params.id &#125;&#125;&lt;/div&gt;&lt;/template&gt;</code></pre><ol start="4"><li>实战应用：根据 params 参数渲染数据<blockquote><p>针对前面的query参数案例，我们只需做以下相关修改，就可以实现与之相同的效果</p></blockquote></li></ol><ul><li>修改路由配置，在路由中添加<code>:id</code>占位符</li></ul><pre><code>const routes = [  // .....  &#123;    name: &quot;news&quot;,    path: &quot;/news&quot;,    component: News,    redirect: &#123; name: &quot;tab1&quot; &#125;, // 重定向到路由命名name所在的路径    children: [      &#123;        name: &quot;detail&quot;,        path: &quot;detail/:id&quot;,        component: Detail,      &#125;,      // ....    ],  &#125;,];</code></pre><ul><li>修改<code>Tab1.vue</code>中<code>&lt;route-link&gt;</code>组件内容如下：(把 query 改成了 params)</li></ul><pre><code>&lt;RouterLink  :to=&quot;&#123;                name: &#39;detail&#39;,                params: &#123;                    id: `$&#123;id&#125;`                &#125;            &#125;&quot;  &gt;&#123;&#123; title &#125;&#125;&lt;/RouterLink&gt;</code></pre><ul><li>将<code>Detail.vue</code>组件中的<code>route.query.id</code>修改成<code>route.params.id</code>即可</li></ul><pre><code>// 接受传递的参数idconst id = route.params.id;</code></pre><h4 id="路由的-props-配置"><a href="#路由的-props-配置" class="headerlink" title="路由的 props 配置"></a>路由的 props 配置</h4><blockquote><p>路由的<code>props</code>配置可以让路由组件以<code>props</code>的形式来接受传递的 <code>params</code> 或 <code>query</code> 参数，写法更简洁。</p></blockquote><ul><li>在没有设置<code>props</code>属性前，在路由组件中只能以如下方式接受<code>params</code>参数</li></ul><pre><code>&lt;script setup&gt;  import &#123; useRouter, useRoute &#125; from &quot;vue-router&quot;;  console.log(&quot;参数id:&quot;, useRoute().params.id);&lt;/script&gt;&lt;template&gt;  &lt;div&gt;参数：&#123;&#123; $route.params.id &#125;&#125;&lt;/div&gt;&lt;/template&gt;</code></pre><ul><li>有了 props 配置后，可以以 <code>props</code> 形式来接受传递的参数，如下写法更简洁</li></ul><pre><code>&lt;script setup&gt;  // 这里的属性名，必需要与路由组件的参数名相同  const props = defineProps([&quot;id&quot;]);  console.log(&quot;id参数&quot;, props.id);&lt;/script&gt;&lt;template&gt;  &lt;div&gt;参数：&#123;&#123; props.id &#125;&#125;&lt;/div&gt;&lt;/template&gt;</code></pre><ol><li>props 布尔模式<blockquote><p>当 <code>props</code> 的值为布尔值 <code>true</code> 时，相当于<code>route.params</code>将被设置为组件的<code>props</code></p></blockquote></li></ol><ul><li>即：把所有 <code>params</code> 参数作为 <code>props</code> 传递给路由组件。</li></ul><pre><code>// 定义一些路由const routes = [  // ...  &#123;    name: &quot;detail&quot;,    path: &quot;detail/:id&quot;,    component: Detail,    // route.params将设置为组件的props    // 相当于在组件中 &lt;Detail v-bind:=route.params /&gt;    props: true,  &#125;,];</code></pre><ul><li>我们可以在<code>Deatil</code>组件中以 <code>props</code> 的形式来接受传递的<code>params</code>参数</li></ul><pre><code>&lt;script setup&gt;  import &#123; ref &#125; from &quot;vue&quot;;  import axios from &quot;axios&quot;;  // 接受params形式传递的参数 ----------------------  const props = defineProps([&quot;id&quot;]);  const id = props.id;  const info = ref(&#123;&#125;);  // 根据id来发请求，获取当前新闻的详细内容  axios    .get(      `https://www.fastmock.site/mock/6ec78e345df340241e1f5043f0167833/icode/detail/$&#123;id&#125;`    )    .then((res) =&gt; &#123;      info.value = res.data.data;    &#125;)    .catch((err) =&gt; &#123;      console.log(err);    &#125;);&lt;/script&gt;&lt;template&gt;  &lt;h3&gt;&#123;&#123; info.title &#125;&#125;&lt;/h3&gt;  &lt;div class=&quot;main&quot;&gt;&#123;&#123; info.content &#125;&#125;&lt;/div&gt;&lt;/template&gt;</code></pre><ol start="2"><li>props 对象模式<blockquote><p>当props是一个对象时，这个对象会被设置为组件的 props</p></blockquote></li></ol><pre><code>// 定义一些路由const routes = [  // ...  &#123;    name: &quot;detail&quot;,    path: &quot;detail/:id&quot;,    component: Detail,    // route.params将设置为组件的props    // 相当于在组件中 &lt;Detail v-bind:=&#123;a:1,b:2&#125; /&gt;    props: &#123; a: 1, b: 2 &#125;,  &#125;,];</code></pre><ul><li>我们可以在路由组件中以<code>props</code>的形式来接受 <code>props</code> 配置传递的数据</li></ul><pre><code>&lt;script setup&gt;  const props = defineProps([&quot;a&quot;, &quot;b&quot;]);  console.log(&quot;参数a&quot;, props.a); // 1  console.log(&quot;参数b&quot;, props.b); // 2&lt;/script&gt;&lt;template&gt;  &lt;div&gt;关于我们&lt;/div&gt;  &lt;div&gt;参数a：&#123;&#123; props.a &#125;&#125;&lt;/div&gt;  &lt;div&gt;参数b：&#123;&#123; props.b &#125;&#125;&lt;/div&gt;&lt;/template&gt;</code></pre><ol start="3"><li>props 函数模式<blockquote><p>当 props 的值是一个函数时，允许返回值是一个 <code>props</code> 对象，函数的<strong>第一个参数</strong>为当前<code>route</code>路由对象。</p><ul><li>我们可以利用 props 的函数模式，实现以下功能：</li></ul></blockquote></li></ol><ul><li>将传递的<code>query</code>参数作为 <code>props</code> 传递给路由组件</li><li>将传递的<code>query</code>参数与<strong>静态值</strong>一起作为<code>props</code>传递给路由组件</li><li>将传递的<code>params</code>参数与静态值一起作为<code>props</code>传递给路由组件</li></ul><blockquote><p>将传递的query参数与静态值一起作为 props 传递给路由组件</p></blockquote><ul><li>定义路由导航</li></ul><pre><code>&lt;router-link to=&quot;/about?id=001&quot;&gt;关于我们&lt;/router-link&gt;</code></pre><ul><li>定义路由</li></ul><pre><code>const routes = [  // .....  &#123;    name: &quot;about&quot;,    path: &quot;/about&quot;,    component: About,    // 写法一 将query参数作为props传递    props: (route) =&gt; route.query,  &#125;,];</code></pre><ul><li>路由组件中通过 props 接受传递的 query 参数</li></ul><pre><code>const props = defineProps([&#39;id&#39;]);</code></pre><blockquote><p>将传递的<code>query</code>参数与静态值一起作为 <code>props</code> 传递给路由组件</p></blockquote><ul><li>定义路由导航</li></ul><pre><code>&lt;router-link to=&quot;/about?id=001&amp;title=123&quot;&gt;关于我们&lt;/router-link&gt;&lt;!-- 或 --&gt;&lt;router-link  :to=&quot;&#123;                  name: &#39;about&#39;,                  query: &#123;                      id: &#39;001&#39;,                      title: &#39;123&#39;                  &#125;                  &#125;&quot;  &gt;关于我们&lt;/router-link&gt;</code></pre><ul><li>定义路由</li></ul><pre><code>const routes = [  // ....  &#123;    name: &quot;about&quot;,    path: &quot;/about&quot;,    component: About,    alias: &quot;/myabout&quot;,    // 将query参数与静态值组合，一起作为props传递    props: (route) =&gt; (&#123;      id: route.query.id,      title: route.query.title,      msg: &quot;其它数据&quot;,    &#125;),  &#125;,];</code></pre><ul><li>路由组件中通过 <code>props</code> 接受传递的 <code>query</code> 参数</li></ul><pre><code>const props = defineProps([&quot;id&quot;, &quot;title&quot;, &quot;msg&quot;]);</code></pre><blockquote><p>将传递的params参数与静态值一起作为 props 传递给路由组件</p></blockquote><ul><li>定义路由导航</li></ul><pre><code>&lt;router-link  :to=&quot;&#123;                  name: &#39;about&#39;,                  params: &#123;                      id: &#39;001&#39;,                      title: &#39;1233&#39;                  &#125;                  &#125;&quot;  &gt;关于我们&lt;/router-link&gt;</code></pre><ul><li>定义路由</li></ul><pre><code>const routes = [  // ....  &#123;    name: &quot;about&quot;,    path: &quot;/about/:id/:title&quot;,    component: About,    alias: &quot;/myabout&quot;,    // 写法三：将params参数与静态值组合，一起作为props传递    props: (route) =&gt; (&#123;      id: route.params.id,      title: route.params.title,      msg: &quot;其它数据&quot;,    &#125;),  &#125;,];</code></pre><ul><li>路由组件中通过 props 接受传递的 query 参数</li></ul><pre><code>const props = defineProps([&quot;id&quot;, &quot;title&quot;, &quot;msg&quot;]);</code></pre><h4 id="响应路由参数的变化"><a href="#响应路由参数的变化" class="headerlink" title="响应路由参数的变化"></a>响应路由参数的变化</h4><blockquote><p>我们来看下面这个带参的路由</p></blockquote><pre><code>const routes = [  &#123;    name: &quot;news&quot;, // 路由名    path: &quot;/news/:id&quot;, // 路径    component: News, // 路径需要渲染的组件  &#125;,];</code></pre><ul><li>当用户从<code>/news/1001</code>导航到<code>/news/1002</code>或<code>/news/1003</code>时，相同的组件实例将被<strong>重复使用</strong>。</li><li>因为 3 个路由都渲染同个News组件，比起销毁再创建，复用则显得更加高效。不过，这也意味着组件的生命周期钩子<strong>不会</strong>被调用，所以当路由的参数发生变化时，在<code>&lt;script setup&gt;</code>中并不能获取到变化后的参数</li></ul><pre><code>&lt;script setup&gt;  import &#123; useRoute &#125; from &quot;vue-router&quot;;  const route = useRoute();  const id = route.params.id;  const url = &quot;http://wwww.xxx.com/....&quot;; // 请求数据源  // 只能在刚进到/news/1001时才能拿到id=1001。  // 后面从从/news/1001导航到/news/1002或/news/1003时,拿不到变化后的id  axios.get(`$&#123;url&#125;$&#123;id&#125;`).then((res) =&gt; &#123;    // 发请求拿数据  &#125;);&lt;/script&gt;</code></pre><blockquote><p>要对同一个组件中参数的变化做出响应的话，你可以简单地<code>watch</code> route 对象上的任意属性</p></blockquote><pre><code>&lt;script setup&gt;  import &#123; useRoute &#125; from &quot;vue-router&quot;;  const route = useRoute();  const url = &quot;http://wwww.xxx.com/....&quot;; // 请求数据源  // 侦听 route.params的变化  watch(    () =&gt; route.params,    (newValue, oldValue, onCleanup) =&gt; &#123;      // 对路由的变化做出响应      axios.get(`$&#123;url&#125;$&#123;newValue.id&#125;`).then((res) =&gt; &#123;        // 发请求拿数据      &#125;);    &#125;  );&lt;/script&gt;</code></pre><ol><li>实战应用<blockquote><p>我们来实现如下效果，当用户从<code>/news/1001</code>导航到<code>/news/1002</code>或<code>/news/1003</code>时都能拿到变化后的参数，然后根据参数的值来发请求获取新闻数据列表</p></blockquote></li></ol><ul><li><code>src/router/router.js</code> 创建路由实例</li></ul><pre><code>// 1、从vue-router中解构两个方法import &#123;  createRouter,  createWebHashHistory,  createWebHistory,&#125; from &quot;vue-router&quot;;import News from &quot;../views/News.vue&quot;;// 定义一些路由：路径与组件的映射关系....const routes = [  &#123;    name: &quot;home&quot;,    path: &quot;/&quot;,    redirect: &quot;/news/1001&quot;,  &#125;,  &#123;    name: &quot;news&quot;,    path: &quot;/news/:id&quot;,    component: News,  &#125;,];// 创建router 路由实例const router = createRouter(&#123;  // 路由模式  //  history:createWebHashHistory(),  // hash模式的路由  history: createWebHistory(),  // 配置一些路由  // routes:routes  routes,&#125;);// 对外暴露export &#123; router &#125;;</code></pre><ul><li><code>App.vue</code>中，创建路由导航</li></ul><pre><code>&lt;template&gt;  &lt;ul class=&quot;router-link&quot;&gt;    &lt;li&gt;      &lt;router-link to=&quot;/news/1001&quot;&gt;最新动态&lt;/router-link&gt;    &lt;/li&gt;    &lt;li&gt;      &lt;router-link to=&quot;/news/1002&quot;&gt;执门推荐&lt;/router-link&gt;    &lt;/li&gt;    &lt;li&gt;      &lt;router-link to=&quot;/news/1003&quot;&gt;历史动态&lt;/router-link&gt;    &lt;/li&gt;  &lt;/ul&gt;  &lt;!-- url对应组件内容输出口 --&gt;  &lt;div class=&quot;router-view&quot;&gt;    &lt;router-view&gt;&lt;/router-view&gt;  &lt;/div&gt;&lt;/template&gt;&lt;style&gt;  .router-link &#123;    display: flex;    justify-content: center;    text-align: center;    list-style: none;    margin-top: 30px;  &#125;  .router-link li &#123;    margin: 0 10px;  &#125;  .router-link li a &#123;    color: #000;    font-size: 16px;    text-decoration: none;  &#125;  .router-link li a:hover &#123;    color: tomato;  &#125;  .router-link li a.router-link-active &#123;    color: tomato;  &#125;  .router-view &#123;    width: 80%;    margin: 30px auto;    font-size: 20px;    min-height: 300px;    background-color: rgb(251, 249, 249);  &#125;&lt;/style&gt;</code></pre><ul><li><code>NewList</code>，根据id获取并渲染不同的数据</li></ul><pre><code>&lt;script setup&gt;  import &#123; ref, watch &#125; from &quot;vue&quot;;  import axios from &quot;axios&quot;;  import &#123; useRoute &#125; from &quot;vue-router&quot;;  const route = useRoute();  const list = ref([]);  const url =    &quot;https://www.fastmock.site/mock/6ec78e345df340241e1f5043f0167833/icode/new/list/&quot;;  // 用来取消请求的对象  let controller = null;  // 侦听器侦听 route.params 的变化  watch(    () =&gt; route.params,    (newValue, oldValue, onCleanup) =&gt; &#123;      controller = new AbortController();      // 发请求，拿数据      axios        .get(`$&#123;url&#125;$&#123;route.params.id&#125;`, &#123;          // 配置取消请求          signal: controller.signal,        &#125;)        .then((res) =&gt; &#123;          list.value = res.data.data;        &#125;)        .catch((err) =&gt; &#123;          console.log(err.message);        &#125;);      // 取消请求      function cancle() &#123;        controller.abort();      &#125;      // 取消之前的请求      onCleanup(cancle);    &#125;,    &#123;      immediate: true,    &#125;  );&lt;/script&gt;&lt;template&gt;  &lt;ul&gt;    &lt;li v-for=&quot;&#123; id, title &#125; in list&quot;&gt;      &lt;router-link to=&quot;&quot;&gt; &#123;&#123; title &#125;&#125;&lt;/router-link&gt;    &lt;/li&gt;  &lt;/ul&gt;&lt;/template&gt;&lt;style scoped&gt;  ul &#123;    padding: 20px;  &#125;  ul li &#123;    line-height: 35px;    border-bottom: 1px dashed #ddd;    text-indent: 2em;  &#125;  ul li a &#123;    color: #333;    text-decoration: none;  &#125;&lt;/style&gt;</code></pre><h3 id="七、路由别名"><a href="#七、路由别名" class="headerlink" title="七、路由别名"></a>七、路由别名</h3><blockquote><p>在路由配置时，我们可以通过<code>alias</code>属性为路由取别名。</p></blockquote><ul><li>当路由<code>/about</code>的别名为<code>/myabout</code>时，我们通过地址<code>/myabout</code>访问的是<code>/about</code>路由的内容，但路由地址显示的是<code>/myabout</code></li><li>当路由<code>/news/tab2</code>的别名为<code>/newsInfo</code>时，我们通过地址<code>/newsInfo</code>访问的是<code>/news/tab2</code>路由的内容，但地址显示的是<code>/newsInfo</code></li><li>通过别名，你可以自由地将 UI 结构映射到一个任意的 URL，而不受配置的嵌套结构的限制</li></ul><ol><li>别名是一个绝对或相对路径<blockquote><p>别名可以是一个以<code>/</code>开头的<strong>绝对路径</strong>，也可以是一个没有<code>/</code>开头的<strong>相对路径</strong></p></blockquote></li></ol><pre><code>const routes = [      // 省略部分代码......    &#123;        name: &#39;about&#39;,        path: &quot;/about&quot;,        component: About,        alias: &quot;/myabout&quot;  // 别名 绝对路径，访问地址 /myabout    &#125;,    &#123;        name: &#39;news&#39;,        path: &quot;/news&quot;,        component: News,        redirect: &#123; name: &#39;tab1&#39; &#125;,        children: [                name: &#39;tab1&#39;,                path: &quot;tab1&quot;,                component: Tab1,            &#125;,            &#123;                path: &quot;tab2&quot;,                component: Tab2,                alias: &#39;/newsInfo&#39;,  // 别名 ，绝对路径 访问地址 /newsInfo            &#125;,            &#123;                path: &quot;tab3&quot;,                component: Tab3,                alias:&quot;commonInfo&quot;  // 别名，相对路径 访问地址 /news/commonInfo            &#125;        ]</code></pre><ul><li>接下来，我们可以把页面中访问路由的地址修改为访问别名，如下</li></ul><pre><code>&lt;ul class=&quot;router-link&quot;&gt;  &lt;li&gt;&lt;router-link to=&quot;/&quot;&gt;网站首页&lt;/router-link&gt;&lt;/li&gt;  &lt;li&gt;&lt;router-link to=&quot;/myabout&quot;&gt;关于我们&lt;/router-link&gt;&lt;/li&gt;  &lt;li&gt;&lt;router-link to=&quot;/newsInfo&quot;&gt;热门推荐&lt;/router-link&gt;&lt;/li&gt;  &lt;li&gt;&lt;router-link to=&quot;/news/commonInfo&quot;&gt;历史动态&lt;/router-link&gt;&lt;/li&gt;&lt;/ul&gt;</code></pre><ol start="2"><li>别名是一个数组<blockquote><p>别名可以由多个以相对或绝对路径组成的数组</p></blockquote></li></ol><ul><li>路由<code>/news/tab3</code>的别名是一个数组，如下：</li></ul><pre><code>const routes = [  // ......  &#123;    name: &quot;news&quot;,    path: &quot;/news&quot;,    component: News,    redirect: &#123; name: &quot;tab1&quot; &#125;,    children: [      // ......      &#123;        path: &quot;tab3&quot;,        component: Tab3,        // /Info  /news/commonInfo   最终访问的都是 /news/tab3路由的内容        alias: [&quot;/Info&quot;, &quot;commonInfo&quot;],      &#125;,    ],  &#125;,];</code></pre><ul><li>我们通过<code>/Info</code>、<code>/news/commonInfo</code> 最终访问的都是<code>/news/tab3</code>路由的内容</li></ul><ol start="3"><li>别名携带参数<blockquote><p>如果路由有参数，一定要在任何绝对别名中包含它们</p></blockquote></li></ol><pre><code>const routes = [  // .....  &#123;    name: &quot;about&quot;,    path: &quot;/about/:id&quot;,    component: About,    // 可以通过 /about/1001  、 /myabout/1001/   、 /1001  访问到about关于我们页面    alias: [      &quot;/myabout/:id&quot;, // 绝对路径必须带上参数      &quot;/:id&quot;,    ],  &#125;,];</code></pre><ul><li>以下导航访问的都是同一个页面关于我们</li></ul><pre><code>&lt;li&gt;&lt;router-link to=&quot;/about/1001&quot;&gt;关于我们&lt;/router-link&gt;&lt;/li&gt;&lt;li&gt;&lt;router-link to=&quot;/myabout/1001&quot;&gt;关于我们&lt;/router-link&gt;&lt;/li&gt;&lt;li&gt;&lt;router-link to=&quot;/1001&quot;&gt;关于我们&lt;/router-link&gt;&lt;/li&gt;</code></pre><h3 id="八、命名视图"><a href="#八、命名视图" class="headerlink" title="八、命名视图"></a>八、命名视图</h3><ol><li>命名视图<blockquote><p>有时候想同时（同级）展示多个视图，而不是嵌套展示。例如创建一个布局，有 header（头部）、main（主内容）、footer（底部）三个视图，这个时候命名视图就派上用场了</p></blockquote></li></ol><ul><li>你可以在界面中拥有多个单独命名视图，而不是只有一个单独的出口，如下：</li></ul><pre><code>&lt;router-view name=&quot;Header&quot;&gt;&lt;/router-view&gt;&lt;router-view&gt;&lt;/router-view&gt;&lt;!-- 没有name属性，默认为name=&#39;default&#39;  上面写法等同于下面写法--&gt;&lt;!-- &lt;router-view name=&quot;default&quot;&gt;&lt;/router-view&gt; --&gt;&lt;router-view name=&quot;Footer&quot;&gt;&lt;/router-view&gt;</code></pre><ul><li><p>如果<code>router-view</code> 没有设置 <code>name</code> 名字，那么默认为<code>name=&quot;default&quot;</code></p></li><li><p>一个视图使用一个组件渲染，因此对于同个路由，有多个视图就需要多个组件渲染。确保正确使用 <code>components</code> 配置 (带上 s)：</p></li></ul><pre><code>const router = createRouter(&#123;  history: createWebHashHistory(),  routes: [    &#123;      path: &quot;/&quot;,      components: &#123;        default: Main,        // Header: Header 的缩写        Header,        // 它们与 `&lt;router-view&gt;` 上的 `name` 属性匹配        Footer,      &#125;,    &#125;,  ],&#125;);</code></pre><ol start="2"><li>命名视图应用</li></ol><ul><li>App.vue</li></ul><pre><code>&lt;script setup&gt;  import Header from &quot;./views/Header.vue&quot;;&lt;/script&gt;&lt;template&gt;  &lt;header&gt;&lt;/header&gt;  &lt;!--多个命名视图, 注意这里的名字采用的是小写--&gt;  &lt;router-view name=&quot;header&quot;&gt;&lt;/router-view&gt;  &lt;router-view&gt;&lt;/router-view&gt;  &lt;router-view name=&quot;footer&quot;&gt;&lt;/router-view&gt;&lt;/template&gt;Header.vue&lt;template&gt;  &lt;div class=&quot;header&quot;&gt;    &lt;ul class=&quot;router-link&quot;&gt;      &lt;li&gt;&lt;router-link to=&quot;/&quot;&gt;网站首页&lt;/router-link&gt;&lt;/li&gt;      &lt;li&gt;&lt;router-link to=&quot;/about&quot;&gt;关于我们&lt;/router-link&gt;&lt;/li&gt;      &lt;li&gt;&lt;router-link to=&quot;/news&quot;&gt;新闻中心&lt;/router-link&gt;&lt;/li&gt;    &lt;/ul&gt;  &lt;/div&gt;&lt;/template&gt;&lt;style scoped&gt;  .header &#123;    height: 50px;  &#125;  .router-link &#123;    display: flex;    justify-content: center;    text-align: center;    list-style: none;  &#125;  .router-link li &#123;    line-height: 50px;    margin: 0 10px;  &#125;  .router-link li a &#123;    color: #000;    font-size: 16px;    text-decoration: none;  &#125;  .router-link li a:hover &#123;    color: tomato;  &#125;  .router-link li a.router-link-active &#123;    color: tomato;  &#125;&lt;/style&gt;</code></pre><ul><li><code>router/router.js</code></li></ul><pre><code>import &#123; createRouter, createWebHistory &#125; from &quot;vue-router&quot;;import HomeHeader from &quot;../views/HomeHeader.vue&quot;;import HomeMain from &quot;../views/HomeMain.vue&quot;;import HomeFooter from &quot;../views/HomeFooter.vue&quot;;import AboutHeader from &quot;../views/AboutHeader.vue&quot;;import AboutMain from &quot;../views/AboutMain.vue&quot;;import NewsMain from &quot;../views/NewsMain.vue&quot;;const routes = [  &#123;    path: &quot;/&quot;,    // 当前路由对应多个组件    components: &#123;      header: HomeHeader, // 对应默认视图      default: HomeMain, // 对应命名视图 name=&#39;main&#39;      footer: HomeFooter, // 对应命名视图 name=&#39;footer&#39;    &#125;,  &#125;,  &#123;    path: &quot;/about&quot;,    components: &#123;      header: AboutHeader, // 对应默认视图      default: AboutMain,    &#125;,  &#125;,  &#123;    path: &quot;/news&quot;,    components: NewsMain,    // 如果只渲染默认视图， components:&#123; default:NewHeader &#125;可以简写成    // component:NewHeader  &#125;,];const router = createRouter(&#123;  history: createWebHistory(),  routes,&#125;);export &#123; router &#125;;</code></pre><ol start="3"><li>嵌套命名视图<blockquote><p>如果上面案例中 <code>/news</code> 路由还存在子路由，子路由对应的页面也可以由多个命名视图来展示</p></blockquote></li></ol><ul><li><code>NewsMain.vue</code></li></ul><pre><code>&lt;template&gt;  &lt;div class=&quot;router-link&quot;&gt;    &lt;router-link to=&quot;/news/tab1&quot;&gt;最新动态&lt;/router-link&gt;  &lt;/div&gt;  &lt;div class=&quot;router-view&quot;&gt;    &lt;router-view name=&quot;Left&quot; class=&quot;left&quot;&gt;&lt;/router-view&gt;    &lt;router-view name=&quot;Right&quot; class=&quot;right&quot;&gt;&lt;/router-view&gt;  &lt;/div&gt;&lt;/template&gt;&lt;style scoped&gt;  .router-view &#123;    display: flex;    justify-content: space-between;  &#125;&lt;/style&gt;</code></pre><ul><li><code>router/router.js</code></li></ul><pre><code>const routes = [  &#123;    path: &quot;/news&quot;,    component: NewsMain,    children: [      &#123;        path: &quot;tab1&quot;,        components: &#123;          Left: TabLeft1,          Right: TabRight1,        &#125;,      &#125;,    ],  &#125;,];</code></pre><ul><li><code>name</code>严格区分大小写，如果<code>name</code>和组件名相同，可以简写</li></ul><pre><code>components: &#123;//如果name=组件名  Left,  Right: TabRight1,&#125;,</code></pre><h3 id="九、动态路由的匹配语法"><a href="#九、动态路由的匹配语法" class="headerlink" title="九、动态路由的匹配语法"></a>九、动态路由的匹配语法</h3><ol><li>参数中自定义正则<blockquote><p>当我们使用<code>user/:userId</code>这样的动态路由时，<code>:userId</code>为路径参数，他能匹配任意的字符，所以<code>user/12</code>、<code>user/ab</code> 都能匹配成功。</p></blockquote></li></ol><blockquote><p>如果我们希望<code>:userId</code>只能匹配数字，也就是<code>user/12</code> 能匹配成功，但<code>user/ab</code>会匹配失败。我们可在路径参数 后面的括号中加入正则表达式来限定</p></blockquote><pre><code>const routes = [  &#123;    // 只能匹配 /user/1  /user/123  等 但不能匹配 /user/ab    path: &quot;/user/:userId(\\d+)&quot;,  &#125;,];</code></pre><ul><li>注意：字符中的<code>\</code>反斜杆有特殊用途，所以要加上<code>\\</code>来转义，确保能正确匹配<code>\d</code></li></ul><blockquote><p>如果我们希望路由<code>/user/：userId</code>后面的<code>:userId</code>只能匹配数字或字母类字符，我们可以在路径参数后面的括号加入正则表达式来限定</p></blockquote><pre><code>const routes = [  &#123;    // 只能匹配 /user/1  /user/123  等 但不能匹配 /user/ab    path: &quot;/user/:userId([a-zA-Z0-9]+)&quot;,  &#125;,];</code></pre><ol start="2"><li>可重复的参数<blockquote><p>如果你需要匹配具有<strong>多个部分</strong>的路由，如<code>/user/:urls</code> 可以匹配 <code>/user/one</code>、<code>/user/one/two</code>、<code>/user/one/two/123</code> 等</p><ul><li>则可以在路径参数后面使用 <code>*</code>（0 个或多个）和 <code>+</code>（1 个或多个）将参数标记为可重复</li></ul></blockquote></li></ol><pre><code>const routes = [  &#123;    // 可以匹配 /user/one   /user/one/two    /user/one/two/123    // 不能匹配 /user/    path: &quot;/user/:userId+&quot;,  &#125;,  &#123;    // 可以匹配 /product/one  /product/one/two  /product/one/two/123    // 也能匹配 /user/    path: &quot;/product/:productId*&quot;,  &#125;,  &#123;    // 可以匹配 /news/12   /news/12/23   不能匹配 /news/a   /news/12/b    // 只要重复的路径中包含非数字，都不能匹配成功    path: &quot;/news/:id（\\d+）+&quot;,  &#125;,];</code></pre><ol start="3"><li>可选参数<blockquote><p>你可以在路径参数后面使用 <code>?</code> 修饰符（0 个或 1 个）将一个参数标记为可选。</p></blockquote></li></ol><pre><code>const routes = [  &#123;    // 可以匹配 /user   /user/ab   /user/12 等    path: &quot;/user/:userId?&quot;,  &#125;,  &#123;    // 可以匹配 /news  /news/12   不能匹配 /user/ab    path: &quot;/news/:id(\\d+)?&quot;,  &#125;,];</code></pre><blockquote><p>总结</p></blockquote><ul><li><code>+</code>表示<code>1</code>个或多个，同时参数可以重复</li><li><code>*</code>表示<code>0</code>个或多个，同时参数可以重复</li><li><code>?</code>表示<code>0</code>个或 1 个，参数不能重复</li></ul><ol start="4"><li>注意事项<blockquote><p>我们来看下面两个路由</p></blockquote></li></ol><pre><code>const routes = [  &#123;    path: &quot;/:keyword&quot;,  &#125;,  &#123;    path: &quot;/:id(\\d+)&quot;,  &#125;,];</code></pre><blockquote><p>注：</p></blockquote><ul><li>当我们访问<code>/12</code>时，或<code>/</code>反斜杆后面跟着数字时，将匹配<code>/:id(\\d+)</code>，其它情况将会匹配<code>/:keyword</code>。</li><li>与<code>/:id(\\d+)</code>和<code>/:keyword</code>在 routes 数组中的顺序没有关系</li></ul><ol start="5"><li>捕获 404 Not Found 路由<blockquote><p>我们可以在定义<code>routes</code>时，配置一个匹配所有路由的路由对象，该路由所渲染的组件为<code>NotFound</code>显示 <code>404</code> 页面内容。</p></blockquote></li></ol><ul><li>如果当前访问的路径没有被<code>/:pathMatch(.*)</code>之外的路由匹配，则就会被<code>/:pathMatch(.*)</code>匹配，显示<code>NotFound</code>组件</li></ul><pre><code>const routes = [  // .......  &#123;    name: &quot;NotFound&quot;,    // 匹配任意路由    path: &quot;/:pathMatch(.*)*&quot;,    component: NotFound,  &#125;,  // .......];</code></pre><ol start="6"><li><code>Sensitive</code> 与 <code>strict</code> 路由配置<blockquote><p>默认情况下路由<code>/users</code>将匹配 <code>/users</code>、<code>/users/</code>、甚至 <code>/Users/</code>。我们可以在<code>createRouter(options)</code>的 <code>options</code> 中来配置<code>sensitive</code>与<code>strict</code>选项来<strong>区分大小写</strong>和<strong>禁用尾部斜线</strong>。</p></blockquote></li></ol><ul><li><code>sensitive</code>：设置路由是否区分大小写,true 表示区分大小写，false 表示不区分，默认值为 fasle</li><li><code>strict</code>：路由是否禁止尾部斜线 true 表示禁用，false 表示不禁用，默认值为 false</li></ul><pre><code>const router = createRouter(&#123;  history: createWebHistory(),  routes: [    &#123;      path: &quot;/about&quot;,      component: About,    &#125;,    &#123;      path: &quot;/news&quot;,      component: News,    &#125;,  ],  strict: true, // 禁止尾部斜线  sensitive: true, // 区分大小写&#125;);</code></pre><ul><li>以上<code>/about</code>路由只能与<code>/about</code>匹配，与<code>/About</code>和<code>/about/</code>都不会匹配成功。<code>/news</code>路由只能与<code>/news</code>匹配，与<code>/News</code>和<code>/news/</code>都不会匹配成功。</li><li><code>sensitive</code>与<code>strict</code>选项即可以如上面一样应用在整个全局路由上，也可以应用于当前路由上，如下：</li></ul><pre><code>const router = createRouter(&#123;  history: createWebHistory(),  routes: [    &#123;      path: &quot;/about&quot;,      component: About,      strict: true, // 禁止尾部斜线    &#125;,    &#123;      path: &quot;/news&quot;,      component: News,      sensitive: true, // 区分大小写    &#125;,  ],&#125;);</code></pre><ul><li>以上<code>/about</code>路由可以与<code>/about</code>和<code>/About</code>匹配成功，但与<code>/about/</code>匹配失败</li><li>以上<code>/news</code>路由可以与<code>/news</code>和<code>/news/</code>匹配成功，但与<code>/News</code>匹配失败</li></ul><h3 id="十、vue-Router-编程式导航"><a href="#十、vue-Router-编程式导航" class="headerlink" title="十、vue Router 编程式导航"></a>十、vue Router 编程式导航</h3><blockquote><p>除了使用 <code>&lt;router-link&gt;</code> 创建 a 标签来定义导航链接，我们还可以借助 <code>router</code> 的实例方法，通过编写代码来实现。</p></blockquote><ul><li>在组件中插入<code>&lt;router-link&gt;</code>组件来创建导航，属于<strong>声明式</strong>写法</li><li>通过<code>router</code>实例方法来创建导航，属于<strong>编程式</strong>导航写法。</li></ul><table><thead><tr><th>声明式</th><th>编程式</th></tr></thead><tbody><tr><td><router-link :to="..."></td><td>router.push(…)</td></tr></tbody></table><ul><li>以下表格中列出的 <code>router</code> 实例方法，可以用来实现页面导航<table><thead><tr><th>router</th><th>实例方法</th><th>功能</th></tr></thead><tbody><tr><td>push()</td><td>用来导航到一个新的 URL</td><td></td></tr><tr><td>replace()</td><td>用来导航到一个新的 URL，但会替换掉之前的 URL，无法后退到之前 URL</td><td></td></tr><tr><td>go()</td><td>导航到指定记录，用于前进或后退</td><td></td></tr><tr><td>back()</td><td>相当于后退按扭，后退到前一页</td><td></td></tr><tr><td>forward()</td><td>相当于前进按扭，前进到前一页</td><td></td></tr></tbody></table></li></ul><h4 id="push-方法"><a href="#push-方法" class="headerlink" title="push 方法"></a>push 方法</h4><blockquote><p>push 方法用来导航到一个新的 URL，他接受一个参数，该参数与<code>&lt;router-link&gt;</code>组件中 <code>to</code> 属性值的写法一模一样，可以是一个字符串路径，或者一个描述地址对象。</p></blockquote><pre><code>// 字符串路径router.push(&quot;/news/tab1&quot;);// 带有路径的对象router.push(&#123; path: &quot;/news/tab1&quot; &#125;);// 命名的路由，并加上参数，让路由建立 urlrouter.push(&#123; name: &quot;tab1&quot;, params: &#123; id: &quot;001&quot; &#125; &#125;);// 带query查询参数，结果是 /news/tab1?id=001router.push(&#123; path: &quot;/news/tab1&quot;, query: &#123; id: &quot;001&quot; &#125; &#125;);// 带 hash，结果是 /about#teamrouter.push(&#123; path: &quot;/about&quot;, hash: &quot;#team&quot; &#125;);</code></pre><blockquote><p>注意事项</p></blockquote><ul><li><code>params</code>参数只能与<code>name</code>属性配合，不能与<code>path</code>属性配合，以下写法 <code>params</code> 会被忽略</li></ul><pre><code>// 错误写法router.push(&#123; path: &quot;/news/tab1&quot;, params: &#123; id: &quot;001&quot; &#125; &#125;);</code></pre><h4 id="实战应用"><a href="#实战应用" class="headerlink" title="实战应用"></a>实战应用</h4><blockquote><p>利用编程式导航实现导航切换</p></blockquote><ul><li>在src目录下新建<code>views</code>目录，在此目录所需要的路由组件</li></ul><pre><code>views   ├─ Home.vue    // 首页组件   ├─ Login.vue   // 登录组件   ├─ Register.vue // 注册组件</code></pre><ul><li>各个路由组件内容如下</li></ul><pre><code>&lt;!--Home.vue--&gt;&lt;template&gt;  &lt;h3&gt;网站首页&lt;/h3&gt;&lt;/template&gt;&lt;!--Login.vue--&gt;&lt;template&gt;  &lt;h3&gt;用户登录&lt;/h3&gt;&lt;/template&gt;&lt;!--Register.vue--&gt;&lt;template&gt;  &lt;h3&gt;用户注册&lt;/h3&gt;&lt;/template&gt;</code></pre><ul><li>在<code>src</code>目录下新建<code>router</code>目录，在此目录下新建<code>index.js</code>文件，用来定义路由</li></ul><pre><code>import &#123; createRouter, createWebHistory &#125; from &quot;vue-router&quot;;import Home from &quot;../views/Home.vue&quot;;import Login from &quot;../views/Login.vue&quot;;import Register from &quot;../views/Register.vue&quot;;import User from &quot;../views/User.vue&quot;;// 定义一些路由const routes = [  &#123;    name: &quot;home&quot;,    path: &quot;/&quot;,    component: Home,    strict: true,    sensitive: true  &#125;,  &#123;    name: &quot;login&quot;,    path: &quot;/login&quot;,    component: Login,  &#125;,  &#123;    name: &quot;register&quot;,    path: &quot;/register&quot;,    component: Register,  &#125;,];// 创建路由实例const router = createRouter(&#123;  history: createWebHistory(),  routes,&#125;);// 对外暴露export &#123; router &#125;;</code></pre><ul><li>App.vue 组件</li></ul><pre><code>&lt;script setup&gt;  import &#123; useRouter &#125; from &quot;vue-router&quot;;  // 获取router实例  const router = useRouter();  // 切换URL方法  function goTo(url) &#123;    router.push(url); // 切换到对应URL  &#125;&lt;/script&gt;&lt;template&gt;  &lt;button @click=&quot;goTo(&#123;    path: &#39;/login&#39;,    query: &#123;      id : 11      &#125;    &#125;)&quot;&gt;登录&lt;/button&gt; |  &lt;button @click=&quot;goTo(&#123;    name = &#39;register&#39;,    params:&#123;      id : 123    &#125;    &#125;)&quot;&gt;注册&lt;/button&gt;  &lt;div class=&quot;main&quot;&gt;    &lt;router-view&gt;&lt;/router-view&gt;  &lt;/div&gt;&lt;/template&gt;&lt;style&gt;  .main &#123;    margin-top: 50px;    display: flex;    justify-content: center;    align-items: center;  &#125;&lt;/style&gt;</code></pre><h4 id="replace-方法"><a href="#replace-方法" class="headerlink" title="replace 方法"></a>replace 方法</h4><blockquote><p>与 push 方法一样用来导航到一个新的 URL，但会替换掉之前的 URL，<strong>无法后退</strong>到之前 URL</p><p>|声明式编程式|<br>|–|–|<br>|<router-link :to="..." replace>|router.replace(…)|</p></blockquote><pre><code>router.replace(&#123; path: &quot;/home&quot; &#125;);</code></pre><ul><li>如果把上面案例中的 push 方法，换成 replace 方法，发现浏览器顶部左侧的前进后退按扭一直是灰色的。</li></ul><pre><code>function goTo(url) &#123;  router.replace(url); // 切换到对应URL&#125;</code></pre><h4 id="go、back、forward-方法"><a href="#go、back、forward-方法" class="headerlink" title="go、back、forward 方法"></a>go、back、forward 方法</h4><pre><code>router.go(1); // 向前移动一页，相当于前进按扭router.back(); // 返回前一页 ，相当于后退按扭router.forward(); // 与go(1) 是一样的</code></pre><ul><li>把上面案例<code>App.vue</code>中代码更改成如下：</li></ul><pre><code>&lt;script setup&gt;  import &#123; useRouter &#125; from &quot;vue-router&quot;;  const router = useRouter();  function goTo(url) &#123;    router.push(url);  &#125;  function go() &#123;    router.go(1);  &#125;  function back() &#123;    router.back();  &#125;&lt;/script&gt;&lt;template&gt;  &lt;button @click=&quot;goTo(&#39;/login&#39;)&quot;&gt;登录&lt;/button&gt; |  &lt;button @click=&quot;goTo(&#39;/register&#39;)&quot;&gt;注册&lt;/button&gt; |  &lt;button @click=&quot;go&quot;&gt;前进&lt;/button&gt; |  &lt;button @click=&quot;back&quot;&gt;后退&lt;/button&gt;  &lt;div class=&quot;main&quot;&gt;    &lt;router-view&gt;&lt;/router-view&gt;  &lt;/div&gt;&lt;/template&gt;&lt;style&gt;  .main &#123;    margin-top: 30px;    display: flex;    justify-content: center;    align-items: center;  &#125;&lt;/style&gt;</code></pre><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><blockquote><p>你可能已经注意到，<code>router.push</code>、<code>router.replace</code> 和 <code>router.go</code> 是 <code>window.history.pushState</code>、<code>window.history.replaceState</code> 和 <code>window.history.go</code>的翻版，它们确实模仿了 <code>window.history</code> 的 API。</p></blockquote><ul><li>因此，如果你已经熟悉<code>Browser History APIs</code>，在使用 <code>Vue Router</code> 时，操作历史记录就会觉得很熟悉。</li><li>值得一提的是，无论在创建路由器实例时传递什么样的 <code>history</code> 配置，<code>Vue Router</code> 的导航方法(push、replace、go)都能始终正常工作</li></ul><h3 id="十一、实战应用：项目框架搭建"><a href="#十一、实战应用：项目框架搭建" class="headerlink" title="十一、实战应用：项目框架搭建"></a>十一、实战应用：项目框架搭建</h3><blockquote><p>本小节结合前面学习过的 Vant UI 与 Vue Router 实现一个简单的应用导航框架</p></blockquote><ol><li>实现步骤</li></ol><ul><li>路由设计</li><li>安装 Vant 组件库</li><li>实现页面路由</li><li>单页面开发</li></ul><ol start="2"><li>路由设计<blockquote><p>首先根据当前应用的需求设计好当前应用的路由</p><ul><li>当前项目只涉及一级导航（路由），各路由关系与路由对应的组件如下表</li></ul></blockquote></li></ol><table><thead><tr><th>页面</th><th>一级路由</th><th>路由组件</th></tr></thead><tbody><tr><td>首页</td><td>&#x2F;Home</td><td></td></tr><tr><td>购物车</td><td>&#x2F;mycartMyCart</td><td></td></tr><tr><td>好看</td><td>&#x2F;niceNice</td><td></td></tr><tr><td>我的</td><td>&#x2F;myMy</td><td></td></tr></tbody></table><ul><li>在<code>src/router/index.js</code>中创建 <code>router</code> 实例，并对外暴露</li></ul><pre><code>import &#123; createApp &#125; from &quot;vue&quot;;import &#123; createRouter, createWebHistory &#125; from &quot;vue-router&quot;;import Home from &quot;../views/Home.vue&quot;;import MyCart from &quot;../views/MyCart.vue&quot;;import My from &quot;../views/My.vue&quot;;import Nice from &quot;../views/Nice.vue&quot;;const routes = [  &#123;    path: &quot;/&quot;,    component: Home,  &#125;,  &#123;    path: &quot;/mycart&quot;,    component: MyCart,  &#125;,  &#123;    path: &quot;/nice&quot;,    component: Nice,  &#125;,  &#123;    path: &quot;/my&quot;,    component: My,  &#125;,];const router = createRouter(&#123;  history: createWebHistory(),  routes,&#125;);export &#123; router &#125;;</code></pre><ul><li>在<code>src/main.js</code>中注册 <code>router</code> 实例</li></ul><pre><code>// .....此处省略部分代码import &#123; router &#125; from &quot;./router/&quot;;// 注册路由app.use(router);// ......</code></pre><ol start="3"><li>安装 Vant 组件库<blockquote><p>在此项目中，我们会用到 Vant 组件库，所以我们需要先安装好 Vant 组件库</p></blockquote></li></ol><ul><li>安装 UI 组件库</li></ul><pre><code>npm i vant</code></pre><ul><li>按需引入组件，则需要安装以下插件</li></ul><pre><code>npm i unplugin-vue-components -D</code></pre><ul><li>在 <code>vite.config.js</code> 文件中配置好此插件</li></ul><pre><code>import vue from &quot;@vitejs/plugin-vue&quot;;import Components from &quot;unplugin-vue-components/vite&quot;;import &#123; VantResolver &#125; from &quot;unplugin-vue-components/resolvers&quot;;export default &#123;  plugins: [    vue(),    Components(&#123;      resolvers: [VantResolver()],    &#125;),  ],&#125;;</code></pre><ol start="4"><li>实现页面路由<blockquote><p>根据路由实现各页面之间的链接（跳转）关系。</p><ul><li>在此项目中，主要构建当前应用底部的 Tabbar 导航。此导航采用 Vant 组件库中的 Tabbar 组件实现。</li></ul></blockquote></li></ol><pre><code>&lt;script setup&gt;  import &#123; ref &#125; from &quot;vue&quot;;  const active = ref(0);&lt;/script&gt;&lt;template&gt;  &lt;router-view&gt;&lt;/router-view&gt;  &lt;van-tabbar active-color=&quot;#ee0a24&quot; v-model=&quot;active&quot;&gt;    &lt;van-tabbar-item icon=&quot;home-o&quot; to=&quot;/&quot;&gt;首页&lt;/van-tabbar-item&gt;    &lt;van-tabbar-item icon=&quot;shopping-cart-o&quot; to=&quot;/mycart&quot;      &gt;购物车&lt;/van-tabbar-item    &gt;    &lt;van-tabbar-item icon=&quot;tv-o&quot; to=&quot;/nice&quot;&gt;好看&lt;/van-tabbar-item&gt;    &lt;van-tabbar-item icon=&quot;friends-o&quot; to=&quot;/my&quot;&gt;我的&lt;/van-tabbar-item&gt;  &lt;/van-tabbar&gt;&lt;/template&gt;</code></pre><ol start="5"><li>单页面开发<blockquote><p>整个应用的页面路由（导航）实现好之后，我们就可以开发单个路由页面的功能了。</p><ul><li>在这个应用中，每个页面（除首页）的顶部都有一个返回按扭，可以返回到到前一页。这里利用 Vant UI 的<code>NavBar</code>导航栏组件来实现。</li></ul></blockquote></li></ol><ul><li><code>MyCart.vue</code>组件内容</li></ul><pre><code>&lt;script setup&gt;  // 返回前一页  function onClickLeft() &#123;    history.back();  &#125;&lt;/script&gt;&lt;template&gt;  &lt;!-- 导航栏 --&gt;  &lt;van-nav-bar    title=&quot;购物车&quot;    left-text=&quot;返回&quot;    left-arrow    @click-left=&quot;onClickLeft&quot;  /&gt;  &lt;!--主体内容--&gt;  &lt;div class=&quot;main&quot;&gt;购物车.....&lt;/div&gt;&lt;/template&gt;&lt;style scoped&gt;  .main &#123;    text-align: center;  &#125;  /* 修改导航栏中 &lt; 返回 的颜色为黑色*/  :global(.van-nav-bar__text) &#123;    color: #000;  &#125;  :global(.van-nav-bar .van-icon) &#123;    color: #000;  &#125;&lt;/style&gt;</code></pre><ul><li>其它带有返回导航栏的<code>Nice</code>、<code>My</code>组件的内容也按上面格式书写即可，针对修改导航栏中 <code>&lt;</code> 返回 颜色的样式可以不用再重写</li><li>全局样式可以写在单独的CSS文件夹里，在<code>index.html</code>中引入或者<code>main.js</code>中引入，后者优先级最高</li></ul><h3 id="十二、路由元信息"><a href="#十二、路由元信息" class="headerlink" title="十二、路由元信息"></a>十二、路由元信息</h3><blockquote><p>有时，你可能希望将任意信息附加到路由上，比如:</p></blockquote><ul><li>路由组件过渡动画时会用到的过渡名</li><li>访问该路由是否需要身份验证等信息</li></ul><blockquote><p>我们可以在定义路由时，将这些信息配置在每个路由对象的<code>meta</code>属性中，如下:</p></blockquote><pre><code>//定义一些路由const routes = [    &#123;      name: &quot;home&quot;,      path: &#39;/&#39;,      component: Home    &#125;,    &#123;      name: &#39;login&quot; ,      path: &#39;/login&#39; ,      component: Login,      //任何人都可以进入登录页      meta: &#123;        requiresAuth: false      &#125;    &#125;,    &#123;      name: &#39;register &#39;,      path: &quot;/register,      component: Register    &#125;,    &#123;      name: &quot;user &quot;,      path: &quot;/user&quot;,      component: User,      //只有经过身份验证的用户才能访问用户中心      meta: &#123;        requiresAuth: true      &#125;    &#125;  ]</code></pre><ul><li>在选项式API中，可以通过<code>$route.meta</code>来访问<code>meta</code>配置项中的信息。</li><li>在组合式API中，可以通过<code>useRoute( ).meta</code>来访问<code>meta</code>配置项中的信息。</li></ul><pre><code>&lt;script setup&gt;    import &#123; useRoute &#125; from &#39;vue-router &#39;;    const route=useRoute();    //访问router中的meta信息    console.log(route.meta.requiresAuth)&lt;/script&gt;</code></pre><h3 id="十三、导航守卫（路由守卫）"><a href="#十三、导航守卫（路由守卫）" class="headerlink" title="十三、导航守卫（路由守卫）"></a>十三、导航守卫（路由守卫）</h3><h4 id="什么是导航（路由）守卫"><a href="#什么是导航（路由）守卫" class="headerlink" title="什么是导航（路由）守卫"></a>什么是导航（路由）守卫</h4><ul><li>导航守卫是指从路由跳转开始到结束这一生命周期过程中的生命周期函数。</li><li>这些函数会在路由跳转开始到结束过程中的某个时刻执行， 这些函数也被称为 “导航（路由）守卫函数”</li></ul><img src="导航解析流程.png"><blockquote><p>如果我们想在路由跳转到结束整个过程中的某个时刻做一些事情，就可以把想要做的事情写入对应的守卫函数中。</p><p>导航守卫函数常用来控制对路由的访问权限或路由跳转成功后要做的相关操作。比如：</p></blockquote><ul><li>对于没有访问权限的访问可以直接拒绝或跳转到其它页面等</li><li>在路由跳转时，在浏览器顶部实现页面加载的进度条效果，在加载成功后隐藏。</li><li>在路由跳转成功后修改网页标题的信息等</li></ul><h4 id="导航守卫分类"><a href="#导航守卫分类" class="headerlink" title="导航守卫分类"></a>导航守卫分类</h4><blockquote><p>vue-router 提供了以下三类导航守卫来实现对路由的守卫</p></blockquote><ul><li>全局导航守</li><li>路由独享导航守卫</li><li>组件级导航守卫</li></ul><h4 id="全局导航守卫"><a href="#全局导航守卫" class="headerlink" title="全局导航守卫"></a>全局导航守卫</h4><blockquote><p>全局导航守卫就是在路由跳转时，对整个应用内的所有路由进行拦截，然后进行一些操作。</p><p>全局导航守卫主要有以下三个钩子函数，所有路由跳转都会触发这三个钩子函数</p></blockquote><ul><li>全局前置守卫<code>beforeEach</code></li><li>全局解析守卫<code>beforeResolve</code></li><li>全局后置钩子<code>afterEach</code></li></ul><blockquote><ul><li>全局导航守卫持载在全局路由实例上，如下：</li></ul></blockquote><pre><code>// 创建路由实例const router = createRouter(&#123;  // ...&#125;);// 添加全局前置守卫router.beforeEach((to, from, next) =&gt; &#123;  // ...&#125;);// 全局解析守卫router.beforeResolve((to, from, next) =&gt; &#123;  // ...&#125;);// 全局后置钩子  没有next参数router.afterEach((to, from) =&gt; &#123;  // ...&#125;);</code></pre><ol><li>全局前置守卫 beforeEach<blockquote><p>当路由被触发时就会调用 <code>beforeEach</code> 钩子函数。比如：调用<code>router.push()</code>或<code>router.replace()</code>触发导航更新时，<code>beforeEach</code> 钩子函数就会调用</p></blockquote></li></ol><blockquote><p>应用场景：</p></blockquote><ul><li>常用于在路由跳转时对路由访问权限进行验证，验证通过放行，不通过做别做处理，比如返回首页。</li></ul><blockquote><p>语法</p></blockquote><pre><code>// 创建路由实例const router = createRouter(&#123;  /*   */&#125;);// 添加全局前置守卫  next为可选参数router.beforeEach((to, from, next) =&gt; &#123;  // ...&#125;);</code></pre><blockquote><p>守卫方法参数</p></blockquote><ul><li><code>to</code>: 跳转到的目标路由对象。 比如从<code>/a</code>跳转到<code>/b</code>，目标路由对象为<code>/b</code>对应的路由对象</li><li><code>from</code>：离开的路由对象。 比如从<code>/a</code>跳转到<code>/b</code>，离开的路由对象为<code>/b</code>对应的路由对象</li></ul><blockquote><p>守卫方法返回值</p></blockquote><ul><li><code>false</code>： 取消当前的导航，则会重置到<code>from</code>路由对应的地址</li><li>路由地址：可以是一个地址字符串，也可以是一个路由地址对象。和你调用<code>router.push()</code>方法传入的参数一样。</li><li><code>true</code> 或 <code>undefined</code> ： 表示当前导航有效，放行，并调用下一个导航守卫</li></ul><blockquote><p>可选参数 next</p></blockquote><ul><li>next：是一个方法，表示是否正常放行</li><li>在之前的 Vue Router 版本中会用到，在 vue Router4 中不考虑用，但也保留了这个功能<ul><li>如果当前跳转是合法的，调用<code>next()</code>导航就可以正常跳转到目标路由</li><li><code>next(false)</code> 中断当前的导航，会返回到跳转前的路由</li><li><code>next()</code>方法也可以传递一个“路由字符串”或“路由对象”，表示跳转到一个新的路由</li></ul></li></ul><pre><code>next(&quot;/home&quot;);next(&#123; path: &quot;/home&quot; &#125;);</code></pre><ul><li>温馨提示：<ul><li>如果不调用<code>next()</code>方法，切记不要在参数中出现<code>next</code>方法，否则路由<strong>没有办法跳转</strong></li></ul></li></ul><ol start="2"><li>实战应用：登录及权限控制<blockquote><p>功能：</p></blockquote></li></ol><ul><li>如果用户没有登录，不允许进入个人中心，只能进入首页、关于我们、登录页、注册页</li><li>如果用户在没有登录的情况下访问用户中心页面，则会跳转到登录页</li><li>用户可以通过登录页输入用户名和密码进行验证，验证成功可以进入任意页面，包括个人中心。</li><li>如果点击了退出登录按扭，则回退出登录，返回到登录页，则不能再进入到用户中心，只能重新登录成功后才可以</li></ul><blockquote><p>实现原理</p></blockquote><ul><li>对于需要身份验证的路由，我们可以在路由配置上添加<code>meta: &#123; requiresAuth: true&#125;</code>字段，表示需要身份验证成功后方可进入</li><li>添加全局前置导航守卫，在导航守卫中判断要进入的目标路由对象是否需要身份验证</li><li>如果不需要验证，则直接放行，如果需要身份验证，则进入身份验证环节，判断用户是否登录成功</li></ul><pre><code>// 添加全局前置导航守卫router.beforeEach((to, from, next) =&gt; &#123;  // 需要身份验证  if (to.meta.requiresAuth) &#123;    // 判断用户是否登录  &#125; else &#123;    // 不需要身份验证，直接放行    next();  &#125;&#125;);</code></pre><ul><li>登录页——我们可以在用户登录成功时，把后端发送的token保存在<code>locaStorage</code>中</li></ul><pre><code>import &#123; useRouter &#125; from &quot;vue-router&quot;;const router = useRouter();// 点击登录按扭，会调用login方法进行登录验证function login() &#123;  // 正常是发请求验证用户名和密码是否正确  // 判断用户名和密码是否正确  if (username.value === &quot;admin&quot; &amp;&amp; password.value === &quot;123456&quot;) &#123;    // 验证成功，把后端发送的token保存在localStorage，此处模拟    localStorage.setItem(&quot;token&quot;, &quot;xxxx-token&quot;);    // 验证成功跳转到用户中心，带上用户id    router.push(&quot;/user/1001&quot;);  &#125;&#125;</code></pre><ul><li>在<code>beforeEach</code>中判断是否有<code>token</code>，如果有表示用户登录成功，则放行；如果没有，则让用户跳转到登录页。(实际开发，需要把 token 发送给后端验证，验证通过则放行)</li></ul><pre><code>// 全局前置守卫router.beforeEach((to, from) =&gt; &#123;  // 判断进入当前路由是否需要验证  if (to.meta.requiresAuth) &#123;    // 判断用户是否登录成功    if (localStorage.getItem(&quot;token&quot;)) &#123;      return true;    &#125; else &#123;      alert(&quot;没有访问权限！！请先登录&quot;);      return &quot;/login&quot;;    &#125;  &#125;&#125;);</code></pre><blockquote><p>实现步骤</p></blockquote><ul><li>在<code>src/router/index.js</code>中定义 <code>router</code> 实例</li></ul><pre><code>import &#123; createRouter, createWebHistory &#125; from &quot;vue-router&quot;;import Home from &quot;../views/Home.vue&quot;;import User from &quot;../views/User.vue&quot;;import About from &quot;../views/About.vue&quot;;import Login from &quot;../views/Login.vue&quot;;const routes = [  &#123;    path: &quot;/&quot;,    component: Home,  &#125;,  &#123;    path: &quot;/about&quot;,    component: About,  &#125;,  &#123;    path: &quot;/user/:id&quot;,    component: User,    meta: &#123;      requiresAuth: true, // 需要身份验证    &#125;,  &#125;,  &#123;    name: &quot;login&quot;,    path: &quot;/login&quot;,    component: Login,  &#125;,];const router = createRouter(&#123;  history: createWebHistory(),  routes,&#125;);// 全局前置守卫router.beforeEach((to, from) =&gt; &#123;  // 判断进入当前路由是否需要验证  if (to.meta.requiresAuth) &#123;    // 判断用户是否登录成功    if (localStorage.getItem(&quot;token&quot;)) &#123;      return true;    &#125; else &#123;      alert(&quot;没有访问权限！！请先登录&quot;);      return &quot;/login&quot;;    &#125;  &#125;&#125;);export &#123; router &#125;;</code></pre><ul><li>在<code>/src/views</code>目录下新建首页、关于我们、注册页、个人中心页组件</li></ul><pre><code>&lt;template&gt; 首页/关于我们/注册个人账号..../个人中心 &lt;/template&gt;</code></pre><ul><li>登录页</li></ul><pre><code>&lt;script setup&gt;  import &#123; ref &#125; from &quot;vue&quot;;  import &#123; useRouter &#125; from &quot;vue-router&quot;;  const router = useRouter();  const username = ref(&quot;&quot;); // 用户名  const password = ref(&quot;&quot;); // 密码  // 登录验证  function login() &#123;    // 正常是发请求验证用户名和密码是否正确    // 判断用户名和密码是否正确    if (username.value === &quot;admin&quot; &amp;&amp; password.value === &quot;123456&quot;) &#123;      // 验证成功，把后端发送的token保存在localStorage，此处模拟      localStorage.setItem(&quot;token&quot;, &quot;xxxx-token&quot;);      router.push(&quot;/user&quot;); // 验证成功跳转到用户中心    &#125;  &#125;&lt;/script&gt;&lt;template&gt;  &lt;div class=&quot;login&quot;&gt;    &lt;form&gt;      &lt;div&gt;        &lt;label for=&quot;username&quot;&gt;用户名&lt;/label&gt;        &lt;input type=&quot;text&quot; v-model=&quot;username&quot; id=&quot;username&quot; /&gt;      &lt;/div&gt;      &lt;div&gt;        &lt;label for=&quot;password&quot;&gt;密码&lt;/label&gt;        &lt;input          type=&quot;password&quot;          v-model=&quot;password&quot;          id=&quot;password&quot;          autocomplete=&quot;none&quot;        /&gt;      &lt;/div&gt;      &lt;div&gt;        &lt;button @click.prevent=&quot;login&quot;&gt;登录&lt;/button&gt;      &lt;/div&gt;    &lt;/form&gt;  &lt;/div&gt;&lt;/template&gt;&lt;style&gt;  .login &#123;    width: 300px;  &#125;  .login div &#123;    margin-top: 20px;  &#125;  .login div label &#123;    display: block;    margin-bottom: 5px;    font-size: 20px;  &#125;  .login div input &#123;    width: 100%;    box-sizing: content-box;    border: 1px solid #ddd;    height: 30px;    line-height: 30px;  &#125;  .login div button &#123;    box-sizing: border-box;    width: 100%;    height: 40px;    border: none;    font-size: 24px;    color: #fff;    background-color: tomato;  &#125;&lt;/style&gt;</code></pre><ul><li><code>App.vue</code>中添加导航</li></ul><pre><code>&lt;script setup&gt;  import &#123; useRouter &#125; from &quot;vue-router&quot;;  const router = useRouter();  // 退出登录  function exit() &#123;    // 退出登录时要清除掉token    localStorage.setItem(&quot;token&quot;, &quot;&quot;);    // 跳转到首页    router.push(&quot;/login&quot;);  &#125;&lt;/script&gt;&lt;template&gt;  &lt;div class=&quot;router-link&quot;&gt;    &lt;router-link to=&quot;/&quot;&gt; 网站首页 &lt;/router-link&gt;    &lt;router-link to=&quot;/about/&quot;&gt; 关于我们 &lt;/router-link&gt;    &lt;router-link to=&quot;/user/1001&quot;&gt; 个人中心 &lt;/router-link&gt;    &lt;router-link to=&quot;/login&quot;&gt; 登录 &lt;/router-link&gt;    &lt;router-link to=&quot;/register&quot;&gt;注册&lt;/router-link&gt;    &lt;a href=&quot;/&quot; @click.prevent=&quot;exit&quot;&gt; 退出&lt;/a&gt;  &lt;/div&gt;  &lt;div class=&quot;router-view&quot;&gt;    &lt;router-view&gt;&lt;/router-view&gt;  &lt;/div&gt;&lt;/template&gt;&lt;style scoped&gt;  .router-link &#123;    display: flex;    margin-top: 20px;  &#125;  .router-link a &#123;    margin: 10px;    text-decoration: none;    color: #000;  &#125;  .router-link a.router-link-active &#123;    color: red;  &#125;  .router-view &#123;    font-size: 30px;  &#125;&lt;/style&gt;</code></pre><ol start="3"><li>全局解析守卫 beforeResolve<blockquote><p>全局解析守卫<code>beforeResolve</code>刚好在导航被确认之前调用，即地址栏中的地址改变为目标地址之前。在<code>beforeResolve</code>钩子调用前，所有组件内守卫和异步路由组件被解析完成。</p></blockquote></li></ol><blockquote><p>应用场景：</p></blockquote><ul><li>获取数据：导航被确认后想马上做的事情，就可以在里，比如：获取数据</li><li>任何其他操作：如果用户无法进入页面时你希望避免执行的操作。比如：数据获取失败，则可以取消导航。</li></ul><pre><code>// 创建路由实例const router = createRouter(&#123;  /*   */&#125;);// 全局解析守卫router.beforeResolve((to, from, next) =&gt; &#123;  // ...&#125;);</code></pre><ol start="4"><li>全局后置守卫 afterEach</li></ol><ul><li>当路由跳转成功后就会触发<code>afterEach</code>钩子函数，此时地址栏中路由地址改变为目标地址。</li><li>钩子函数的<code>to</code>和<code>from</code>用法与<code>beforeEach</code>一样，不过这个钩子函数没有<code>next</code>，因为路由已经跳转成功，在该钩子函数中并不能改变导航本身。</li></ul><blockquote><p>应用场景：</p></blockquote><ul><li>常用于分析导航跳转成功之后要做的事情，对于分析、更改页面标题等辅助功能以及许多其他事情都很有用</li></ul><pre><code>// 创建路由实例const router = createRouter(&#123;  /*   */&#125;);//  全局后置钩子router.afterEach((to, from) =&gt; &#123;  // 导航成功后，需要做的事情&#125;);</code></pre><blockquote><p>代码演示：</p></blockquote><ul><li>定义路由</li></ul><pre><code>const routes = [  &#123;    path: &quot;/&quot;,    component: Home,    meta: &#123;      title: &quot;艾编程官网&quot;,    &#125;,  &#125;,  &#123;    path: &quot;/about&quot;,    component: About,    meta: &#123;      title: &quot;关于我们&quot;,    &#125;,  &#125;,  &#123;    path: &quot;/user/:id&quot;,    component: User,    meta: &#123;      requiresAuth: true,      title: &quot;个人中心&quot;,    &#125;,  &#125;,  &#123;    name: &quot;login&quot;,    path: &quot;/login&quot;,    component: Login,    meta: &#123;      title: &quot;登录中心&quot;,    &#125;,  &#125;,  &#123;    name: &quot;register&quot;,    path: &quot;/register&quot;,    component: Register,    meta: &#123;      title: &quot;注册中心&quot;,    &#125;,  &#125;,];</code></pre><ul><li>添加全局后置导航守卫，当页面跳转成功后修改页面标题</li></ul><pre><code>//  全局后置导航守卫router.afterEach((to, from) =&gt; &#123;  // 导航成功后，修改页面标题  document.title = to.meta.title;&#125;);</code></pre><ol start="5"><li>导航加载进度条<blockquote><p>实现原理：</p></blockquote></li></ol><ul><li>首先创建 <code>LoadingBar</code> 组件，该组件有以下两个方法用来实现进度条的加载：<ul><li><code>startLoading</code>方法，调用该方法用于开始加载进度条</li><li><code>endLoading</code>方法，调用该方法用于将进度条拉满，并结束进度条</li></ul></li></ul><blockquote><p>同时将这两个方法通过<code>defineExpose</code>方法对外暴露为公共方法。这样在外部获取当前件实例时，就可以拿到这两个方法来实现进度条的加载。</p></blockquote><ul><li><code>LoadingBar.vue</code> 进度条组件</li></ul><pre><code>&lt;script setup&gt;  import &#123; ref &#125; from &quot;vue&quot;;  const progress = ref(0); // 当前进度  const speed = ref(1); // 动画速度  const timer = ref(null); // 定时器  const bar = ref(null); // 进度条  // 开始加载进度条  function startLoading() &#123;    progress.value = 0; // 每次加载时将进度改为0    timer.value = window.requestAnimationFrame(function fn() &#123;      if (progress.value &lt; 85) &#123;        progress.value += speed.value;        bar.value.style.width = progress.value + &quot;%&quot;;        timer.value = window.requestAnimationFrame(fn);      &#125; else &#123;        // 清除动画        cancelAnimationFrame(timer.value);      &#125;    &#125;);  &#125;  // 进度条拉满，结束进度条  function endLoading() &#123;    window.requestAnimationFrame(() =&gt; &#123;      setTimeout(() =&gt; &#123;        progress.value = 100;        bar.value.style.width = &quot;100%&quot;;        // 拉满后，过30ms去掉进度条        setTimeout(() =&gt; &#123;          bar.value.style.width = &quot;0%&quot;;        &#125;, 30);      &#125;, 1000);    &#125;);  &#125;  defineExpose(&#123;    startLoading,    endLoading,  &#125;);&lt;/script&gt;&lt;template&gt;  &lt;div class=&quot;wraps&quot;&gt;    &lt;div class=&quot;loading-bar&quot; ref=&quot;bar&quot;&gt;&lt;/div&gt;  &lt;/div&gt;&lt;/template&gt;&lt;style scoped&gt;  .wraps &#123;    width: 100%;    height: 20px;    position: fixed;    top: 0;    left: 0;  &#125;  .wraps .loading-bar &#123;    height: inherit;    width: 10px;    background-color: red;  &#125;&lt;/style&gt;</code></pre><ul><li><p><code>/src/router/index.js</code>中</p><blockquote><p>路由配置中</p></blockquote></li><li><p>导航 <code>LoadingBar</code>组件，并利用 <code>createApp</code>方法创建应用实例，然后调用mount方法得到<code>LoadingBar</code>的组件实例。</p></li><li><p>在<code>router.beforeEach</code> 全局前置守卫中，调用 <code>LoadingBar</code>组件实例的<code>startLoading</code>方法开始加载进度条</p></li><li><p>在<code>router.afterEach</code> 全局后置守卫中，调用 <code>LoadingBar</code>组件实例的 <code>endLoading</code>方法将进度条拉满，并结束进度条</p></li><li><p>方法一：</p></li></ul><pre><code>import &#123; createApp &#125; from &quot;vue&quot;;// 加载组件import LoadingBar from &quot;../components/loading-bar/LoadingBar.vue&quot;;// 创建应用实例const LoadingApp = createApp(LoadingBar);const fragement = document.createDocumentFragment();// loadingVm 进度条组件实例const loadingVm = LoadingApp.mount(fragement);// 将DOM挂载到页面document.body.appendChild(fragement);const router = createRouter(&#123;  // ....&#125;);// 全局前置守卫router.beforeEach((to, from) =&gt; &#123;  loadingVm.startLoading();&#125;);// 全局后置守卫router.afterEach((to, from) =&gt; &#123;  loadingVm.endLoading();&#125;);</code></pre><ul><li>方法二：</li></ul><pre><code>import &#123; h, render &#125; from &quot;vue&quot;;import LoadingBar from &quot;../components/LoadingBar.vue&quot;;const vnode = h(LoadingBar); // 虚拟DOMrender(vnode, document.body); // DOM挂载// 全局前置守卫router.beforeEach((to, from) =&gt; &#123;  vnode.component.exposed.startLoading();&#125;);// 全局后置守卫router.afterEach((to, from) =&gt; &#123;  vnode.component.exposed.endLoading();&#125;);</code></pre><ol start="6"><li>总结<blockquote><p>全局导航守卫主要有以下三个钩子函数，所有路由跳转都会触发这三个钩子函数</p><table><thead><tr><th>全局守卫</th><th>钩子函数</th><th>触发时机</th><th>作用</th></tr></thead><tbody><tr><td>全局前置守卫</td><td>router.beforeEach</td><td>导航被触发时执行</td><td>在路由跳转时对路由访问权限进行验证，验证通过放行，不通过别做处理</td></tr><tr><td>全局解析守卫</td><td>router.beforeResolve</td><td>刚好在导航被确认之前触发</td><td>是获取数据或执行任何其他操作（如果用户无法进入页面时你希望避免执行的操作）的理想位置</td></tr><tr><td>全局后置钩子</td><td>router.afterEach</td><td>在导航结束后调用</td><td>对于分析、更改页面标题、等辅助功能以及许多其他事情都很有用</td></tr></tbody></table></blockquote></li></ol><h4 id="路由独享导航守卫"><a href="#路由独享导航守卫" class="headerlink" title="路由独享导航守卫"></a>路由独享导航守卫</h4><blockquote><p>路由独享导航守卫只有<code>beforeEnter</code>一个钩子函数，当指定路由被进入时触发这个钩子函数。</p><p>它会在<code>router.beforeEach</code>和<code>beforeRouteUpdate</code>钩子之后执行</p></blockquote><table><thead><tr><th>钩子函数</th><th>触发时机</th><th>作用</th></tr></thead><tbody><tr><td>beforeEnter</td><td><strong>只在进入路由时触发</strong>，不会在 <code>params</code>、<code>query</code> 或 <code>hash</code> 改变时触</td><td>判断用户是否有权限访问当前路由，如果没有权限就跳转到首页</td></tr></tbody></table><ul><li>你可以直接在路由配置上定义<code>beforeEnter</code>守卫（函数）</li></ul><pre><code>const routes = [  &#123;    path: &quot;/about&quot;,    component: About,    meta: &#123;      title: &quot;关于我们&quot;,    &#125;,  &#125;,  &#123;    path: &quot;/user/:id&quot;,    component: User,    meta: &#123;      // requiresAuth:true,      title: &quot;个人中心&quot;,    &#125;,    // 路由独享导航守卫    beforeEnter(to, from) &#123;      console.log(&quot;个人中心beforeEnter&quot;);    &#125;,  &#125;,];</code></pre><blockquote><p>注意：针对以上路由</p></blockquote><ul><li>当我们从路由<code>/about</code>跳转到<code>/user/1001</code>时会触发<code>beforeEnter</code>钩子函数。</li><li>从路由<code>/user/1001</code>跳转到<code>/user/1002</code>时，不会触发<code>beforeEnter</code> 钩子函数。</li><li>当我们从路由<code>/about?a=1</code> 调转到<code>/about?a=2</code>时，不会触发<code>beforeEnter</code>钩子函数。</li></ul><h4 id="组件级导航守卫"><a href="#组件级导航守卫" class="headerlink" title="组件级导航守卫"></a>组件级导航守卫</h4><blockquote><p>组件级导航守卫是指组件内的钩子函数，类似于组件内的生命周期函数，当加载或更新指定组件时触发</p><ul><li>组件级导航守卫有以下三个钩子函数<table><thead><tr><th>钩子函数</th><th>组合式 API</th><th>触发时机</th><th>作用</th></tr></thead><tbody><tr><td>beforeRouteUpdate</td><td>onBeforeRouteUpdate</td><td>在当前路由改变，但是该组件被复用时调用</td><td>路由参数更新：当同一个组件在不同参数下进行切换时，可能需要根据新的参数更新组件的数据或状态</td></tr><tr><td>beforeRouteEnter</td><td>&#x2F;</td><td>在渲染该组件的对应路由被确认前调用</td><td>数据预加载：在进入组件之前，需要先加载一些数据</td></tr><tr><td>beforeRouteLeave</td><td>onBeforeRouteLeave</td><td>在导航离开渲染该组件的对应路由时调用</td><td>数据清理：在离开当前路由之前需要执行一些清理操作，例如取消订阅事件、重置组件状态，或确认是否保证内容等</td></tr></tbody></table></li></ul></blockquote><blockquote><p>注意：</p></blockquote><ul><li><code>beforeRouteUpdate</code>与<code>beforeRouteEnter</code> 两个钩子函数<strong>不会</strong>都触发，如果组件复用就会触发 <code>beforeRouteUpdate</code> 这个钩子，如果组件不复用，则会触发 <code>beforeRouteEnter</code> 钩子</li></ul><blockquote><p>组件级导航守卫是定义在 Vue 组件中，如下：</p></blockquote><ul><li>选项式API</li></ul><pre><code>&lt;script&gt;  export default &#123;    beforeRouteEnter(to, from) &#123;      // 在渲染该组件的对应路由被验证前调用      // 不能获取组件实例 `this` ！      // 因为当守卫执行时，组件实例还没被创建！    &#125;,    beforeRouteUpdate(to, from) &#123;      // 在当前路由改变，但是该组件被复用时调用      // 举例来说，对于一个带有动态参数的路径 `/users/:id`，在 `/users/1` 和 `/users/2` 之间跳转的时候，      // 由于会渲染同样的 `UserDetails` 组件，因此组件实例会被复用。而这个钩子就会在这个情况下被调用。      // 因为在这种情况发生的时候，组件已经挂载好了，导航守卫可以访问组件实例 `this`    &#125;,    beforeRouteLeave(to, from) &#123;      // 在导航离开渲染该组件的对应路由时调用      // 与 `beforeRouteUpdate` 一样，它可以访问组件实例 `this`    &#125;,  &#125;;&lt;/script&gt;</code></pre><ul><li>组合式 API 中没有与<code>onBeforeRouteEnter</code> 对应的钩子函数</li></ul><pre><code>&lt;script setup&gt;  import &#123; onBeforeRouteLeave, onBeforeRouteUpdate &#125; from &quot;vue-router&quot;;  onBeforeRouteUpdate((to, from) =&gt; &#123;    // ......  注意 this为undefined  &#125;);  onBeforeRouteLeave((to, from) =&gt; &#123;    // ......  注意 this为undefined  &#125;);&lt;/script&gt;</code></pre><ol><li>beforeRouteEnter<blockquote><p><code>beforeRouteEnter</code>守卫<strong>不能</strong>访问 this，因为守卫在导航确认前被调用，因此即将登场的新组件还没被创建。</p><p>不过，你可以通过传一个回调给 <code>next</code> 来访问组件实例。在导航被确认的时候执行回调，并且把组件实例作为回调方法的参数</p></blockquote></li></ol><pre><code>beforeRouteEnter (to, from, next) &#123;  next(vm =&gt; &#123;    // 通过 `vm` 访问组件实例  &#125;)&#125;</code></pre><ul><li>注意：<code>beforeRouteEnter</code>是支持给 next 传递回调的唯一守卫</li></ul><ol start="2"><li>onBeforeRouteUpdate 应用<blockquote><p>对于一个带有动态参数的路径 <code>/news/:id</code>，在 <code>/news/1001</code> 和 <code>/news/1002</code> 之间跳转的时候，相同的组件实例将被重复使用，所以生周命期函数并不会被调用。</p><p>原本在<code>&lt;script setup&gt;</code>中并不能获取到变化后的参数</p><ul><li>之前我们是采用侦听器来侦听<code>route</code>对象上的任意属性来实现</li></ul></blockquote></li></ol><pre><code>// 侦听 route.params的变化watch(  () =&gt; route.params,  (newValue, oldValue, onCleanup) =&gt; &#123;    // 对路由的变化做出响应    axios.get(`$&#123;url&#125;$&#123;newValue.id&#125;`).then((res) =&gt; &#123;      // 发请求拿数据    &#125;);  &#125;);</code></pre><blockquote><ul><li>有了<code>beforeRouteUpdate</code>钩子函数，我们也可以在这个钩子函数中获取变化后的参数，然后根据不同的参数 id 值来发请求获取数据</li></ul></blockquote><ul><li>News.vue 组件</li></ul><pre><code>&lt;script setup&gt;  import &#123; ref, watch &#125; from &quot;vue&quot;;  import axios from &quot;axios&quot;;  import &#123; useRoute, onBeforeRouteUpdate &#125; from &quot;vue-router&quot;;  const route = useRoute();  const list = ref([]);  const url =    &quot;https://www.fastmock.site/mock/6ec78e345df340241e1f5043f0167833/icode/new/list/&quot;;  // 用来取消请求的对象  let controller = null;  function getData(id) &#123;    if (controller) &#123;      controller.abort();    &#125;    controller = new AbortController();    // // 发请求，拿数据    axios      .get(`$&#123;url&#125;$&#123;id&#125;`, &#123;        // 配置取消请求        signal: controller.signal,      &#125;)      .then((res) =&gt; &#123;        list.value = res.data.data;      &#125;)      .catch((err) =&gt; &#123;        console.log(err.message);        console.log(&quot;取消了&quot;);      &#125;);  &#125;  // 未重用组件是调用该方法渲染数据  getData(route.params.id);  // 重用组件时  onBeforeRouteUpdate((to, from) =&gt; &#123;    getData(to.params.id);  &#125;);&lt;/script&gt;&lt;template&gt;  &lt;ul&gt;    &lt;li v-for=&quot;&#123; id, title &#125; in list&quot;&gt;      &lt;router-link to=&quot;&quot;&gt; &#123;&#123; title &#125;&#125;&lt;/router-link&gt;    &lt;/li&gt;  &lt;/ul&gt;&lt;/template&gt;&lt;style scoped&gt;  ul &#123;    padding: 20px;  &#125;  ul li &#123;    line-height: 35px;    border-bottom: 1px dashed #ddd;    text-indent: 2em;  &#125;  ul li a &#123;    color: #333;    text-decoration: none;  &#125;&lt;/style&gt;</code></pre><ul><li>路由定义</li></ul><pre><code>const routes = [  &#123;    name: &quot;news&quot;,    path: &quot;/news/:id&quot;,    component: News,  &#125;,];</code></pre><ul><li>导航</li></ul><pre><code>&lt;router-link to=&quot;/news/1001&quot;&gt; 最新动态 &lt;/router-link&gt;&lt;router-link to=&quot;/news/1002&quot;&gt; 热门推荐 &lt;/router-link&gt;&lt;router-link to=&quot;/news/1003&quot;&gt;历史动态 &lt;/router-link&gt;</code></pre><ol start="3"><li>onBeforeRouteLeave 应用<blockquote><p>在离开导航前，可以弹出确认框确认是否要离开，如果确认是则跳到新目标，否则取消导航</p></blockquote></li></ol><pre><code>beforeRouteLeave(to, from) &#123;    const answer = window.confirm(&#39;确认要立开马？当前页面内容是否有保存？&#39;)    if (!answer) return false&#125;,</code></pre><h4 id="完整的导航解析流程"><a href="#完整的导航解析流程" class="headerlink" title="完整的导航解析流程"></a>完整的导航解析流程</h4><img src="导航解析流程.png"><ul><li>假设当前应用的路由配置如下：</li></ul><pre><code>const routes = [  &#123;    path: &quot;/&quot;,    component: Home,  &#125;,  &#123;    path: &quot;/a/:id&quot;,    component: A,  &#125;,  &#123;    path: &quot;/b&quot;,    component: B,  &#125;,];</code></pre><blockquote><p>注：</p><ul><li>现在我们所在的页面路由为<code>/a/1</code>，接下来我们点击页面导航跳转到<code>/b</code>，整个导航解析流程如下：</li></ul></blockquote><ul><li>①、导航被触发。（比如：调用<code>router.push</code>、<code>router.replace</code>等触发导航，但地址栏中导航没有发生变化）</li><li>②、在失活的组件里调用<code>beforeRouteLeave</code>守卫。（从<code>/a/1</code>跳转到<code>/b</code>，<code>/a/1</code>路由对应的 A 组件将被销毁，A 组件为失活的组件。在执行 <code>Unmounted</code> 之前，会调用<code>beforeRouteLeave</code>进行拦截）</li><li>③、调用全局的 <code>beforeEach</code> 守卫。 （可以在这里验证用户是否有访问该路由权限，如果没有，直接返回首页，如果有就放行，会接着执行后面的钩子函数等）</li><li>④、在重用的组件里调用 <code>beforeRouteUpdate</code> 守卫(2.2+)。 （如果从<code>/a/1</code>跳转到<code>/a/2</code>时，会触发这个钩子函数，因为这两个路由重用同一个组件 A。如果从<code>&#39;/a/1&#39;</code>跳转到<code>&#39;/b&#39;</code>则不会触发这个钩子函数）</li><li>⑤、在路由配置里调用 <code>beforeEnter</code>。 （只针对指定的路由做拦截，判断用户是否有访问权限等）</li><li>⑥、解析异步路由组件。</li><li>⑦、在被激活的组件里调用 <code>beforeRouteEnter</code>。 （从&#x2F;a&#x2F;1跳转到&#x2F;b，&#x2F;b路由对应的 B 组件需要渲染成 DOM 挂载到页面，B 组件为激活的组件）</li><li>⑧、调用全局的 <code>beforeResolve</code> 守卫(2.5+)。</li><li>⑨、导航被确认。（地址栏中导航改变为跳转后地址）</li><li>⑩、调用全局的 <code>afterEach</code> 钩子。（导航成功后，可以修改页面标题等其它事情）</li><li>⑪、触发 DOM 更新。</li><li>⑫、调用 <code>beforeRouteEnter</code> 守卫中传给 next 的回调函数，创建好的组件实例会作为回调函数的参数传入</li></ul><h3 id="十四、路由组件过渡动画"><a href="#十四、路由组件过渡动画" class="headerlink" title="十四、路由组件过渡动画"></a>十四、路由组件过渡动画</h3><h4 id="路由组件过渡动画"><a href="#路由组件过渡动画" class="headerlink" title="路由组件过渡动画"></a>路由组件过渡动画</h4><blockquote><p>如果我们想在路由组件上使用过渡动画，可以使用<code>&lt;router-view&gt;</code>组件的<strong>插槽</strong>功能。</p></blockquote><ul><li>以下代码，所有路由组件在过渡时采用的是统一的过渡动画</li></ul><pre><code>&lt;!-- route 为当前路由对象  Component 为当前路由显示的组件--&gt;&lt;router-view v-slot=&quot;&#123;route, Component &#125;&quot;&gt;  &lt;transition name=&quot;fade&quot;&gt;    &lt;component :is=&quot;Component&quot; /&gt;  &lt;/transition&gt;&lt;/router-view&gt;</code></pre><ul><li>注意：上面v-slot中的Component的首字母要大写</li></ul><blockquote><p>代码示例</p><ul><li>当在不同的路由间进行切换时，被渲染的路由组件以淡入淡出的效果显示<img src="路由组件过渡动画.gif"></li></ul></blockquote><ul><li>定义路由</li></ul><pre><code>import &#123; createRouter, createWebHistory &#125; from &quot;vue-router&quot;;import Tab1 from &quot;../views/Tab1.vue&quot;;import Tab2 from &quot;../views/Tab2.vue&quot;;import Tab3 from &quot;../views/Tab3.vue&quot;;// 定义一些路由const routes = [  &#123;    name: &quot;tab1&quot;,    path: &quot;/&quot;,    component: Tab1,  &#125;,  &#123;    name: &quot;tab2&quot;,    path: &quot;/tab2&quot;,    component: Tab2,  &#125;,  &#123;    name: &quot;tab3&quot;,    path: &quot;/tab3&quot;,    component: Tab3,  &#125;,];// 创建路由实例const router = createRouter(&#123;  history: createWebHistory(),  routes,&#125;);export &#123; router &#125;;</code></pre><ul><li>定义三个视图组件<code>Tab1</code>、<code>Tab2</code>、<code>Tab3</code>，内容如下</li></ul><pre><code>&lt;!--Tab1 组件--&gt;&lt;template&gt;  &lt;div class=&quot;tab tab1&quot;&gt;&lt;/div&gt;&lt;/template&gt;&lt;style&gt;  .tab1 &#123;    width: 400px;    height: 200px;    background-color: tomato; /* 红色 */  &#125;&lt;/style&gt;&lt;!--Tab2 组件--&gt;&lt;template&gt;  &lt;div class=&quot;tab tab2&quot;&gt;&lt;/div&gt;&lt;/template&gt;&lt;style&gt;  .tab2 &#123;    width: 400px;    height: 200px;    background-color: skyblue; /* 蓝色 */  &#125;&lt;/style&gt;&lt;!--Tab3 组件--&gt;&lt;template&gt;  &lt;div class=&quot;tab tab3&quot;&gt;&lt;/div&gt;&lt;/template&gt;&lt;style&gt;  .tab3 &#123;    width: 400px;    height: 200px;    background-color: khaki; /* 黄色 */  &#125;&lt;/style&gt;</code></pre><ul><li><code>App.vue</code>中创建路由链接和路由视图出口，并对路由组件使用过渡动画</li></ul><pre><code>&lt;template&gt;  &lt;ul class=&quot;router-link&quot;&gt;    &lt;li&gt;&lt;router-link to=&quot;/&quot;&gt;Tab1&lt;/router-link&gt;&lt;/li&gt;    &lt;li&gt;&lt;router-link to=&quot;/tab2&quot;&gt;Tab2&lt;/router-link&gt;&lt;/li&gt;    &lt;li&gt;&lt;router-link to=&quot;/tab3&quot;&gt;Tab3&lt;/router-link&gt;&lt;/li&gt;  &lt;/ul&gt;  &lt;div class=&quot;router-view&quot;&gt;    &lt;router-view v-slot=&quot;&#123; route, Component &#125;&quot;&gt;      &lt;Transition name=&quot;fade&quot; mode=&quot;out-in&quot;&gt;        &lt;component :is=&quot;Component&quot;&gt;&lt;/component&gt;      &lt;/Transition&gt;    &lt;/router-view&gt;  &lt;/div&gt;&lt;/template&gt;&lt;style scoped&gt;  /* 导航样式 */  .router-link &#123;    position: fixed;    width: 100px;    height: 200px;    left: 100px;  &#125;  .router-link li &#123;    list-style: none;    line-height: 40px;    border-bottom: 1px dashed #ddd;  &#125;  .router-link li a &#123;    text-decoration: none;    color: #000;  &#125;  .router-link li a.router-link-active &#123;    color: red;  &#125;  .router-view &#123;    height: 200px;    width: 400px;    margin-left: 200px;    margin-top: 120px;    overflow: hidden;  &#125;  /* 过渡动画样式 */  .fade-enter-from,  .fade-leave-to &#123;    opacity: 0;  &#125;  .fade-enter-active,  .fade-leave-active &#123;    transition: all 1s ease;  &#125;&lt;/style&gt;</code></pre><h4 id="单个路由过渡动画"><a href="#单个路由过渡动画" class="headerlink" title="单个路由过渡动画"></a>单个路由过渡动画</h4><blockquote><p>上面的用法会对所有的路由使用相同的过渡，如果你想让每个路由的组件有不同的过渡</p></blockquote><ul><li>你可以将<code>meta</code>路由元信息和动态的 <code>name</code> 或 自定义过渡 <code>class</code> 结合在一起，放在<code>&lt;transition&gt;</code> 上</li></ul><pre><code>&lt;router-view v-slot=&quot;&#123; route, Component &#125;&quot;&gt;  &lt;Transition :name=&quot;route.meta.transition &quot;&gt;    &lt;component :is=&quot;Component&quot; /&gt;  &lt;/Transition&gt;&lt;/router-view&gt;&lt;router-view v-slot=&quot;&#123; route, Component &#125;&quot;&gt;  &lt;Transition    :enter-active-class=&quot;route.meta.enterTransition&quot;    :leave-active-class=&quot;route.meta.leaveTransition&quot;    mode=&quot;out-in&quot;  &gt;    &lt;component :is=&quot;Component&quot; /&gt;  &lt;/Transition&gt;&lt;/router-view&gt;</code></pre><blockquote><p>完整代码示例</p></blockquote><ul><li>在前面案例的基础上，把每个路由组件需要的动画名配置在<code>meta</code>项中。</li><li>以下动画名采用的是第三方的<code>animate.css</code>插件库的动画名</li></ul><pre><code>import &#123; createRouter, createWebHistory &#125; from &quot;vue-router&quot;;import Tab1 from &quot;../views/Tab1.vue&quot;;import Tab2 from &quot;../views/Tab2.vue&quot;;import Tab3 from &quot;../views/Tab3.vue&quot;;// 定义一些路由const routes = [  &#123;    name: &quot;tab1&quot;,    path: &quot;/&quot;,    component: Tab1,    meta: &#123;      enterTransition: &quot;animate__backInDown&quot;,      leaveTransition: &quot;animate__backOutDown&quot;,    &#125;,  &#125;,  &#123;    name: &quot;tab2&quot;,    path: &quot;/tab2&quot;,    component: Tab2,    meta: &#123;      enterTransition: &quot;animate__backInLeft&quot;,      leaveTransition: &quot;animate__backOutLeft&quot;,    &#125;,  &#125;,  &#123;    name: &quot;tab3&quot;,    path: &quot;/tab3&quot;,    component: Tab3,    meta: &#123;      enterTransition: &quot;animate__backInUp&quot;,      leaveTransition: &quot;animate__backOutUp&quot;,    &#125;,  &#125;,];// 创建路由实例const router = createRouter(&#123;  history: createWebHistory(),  routes,&#125;);export &#123; router &#125;;</code></pre><ul><li><code>&lt;Transition&gt;</code>组件的过渡 class 直接从<code>route.meta</code>中读取</li></ul><pre><code>&lt;script setup&gt;  import &quot;animate.css&quot;; // 要先执行 npm install animate.css --save 命令安装&lt;/script&gt;&lt;template&gt;  &lt;ul class=&quot;router-link&quot;&gt;    &lt;li&gt;&lt;router-link to=&quot;/&quot;&gt;Tab1&lt;/router-link&gt;&lt;/li&gt;    &lt;li&gt;&lt;router-link to=&quot;/tab2&quot;&gt;Tab2&lt;/router-link&gt;&lt;/li&gt;    &lt;li&gt;&lt;router-link to=&quot;/tab3&quot;&gt;Tab3&lt;/router-link&gt;&lt;/li&gt;  &lt;/ul&gt;  &lt;div class=&quot;router-view&quot;&gt;    &lt;router-view v-slot=&quot;&#123; route, Component &#125;&quot;&gt;      &lt;Transition        :enter-active-class=&quot;`animate__animated $&#123;route.meta.enterTransition&#125;`&quot;        :leave-active-class=&quot;`animate__animated $&#123;route.meta.leaveTransition&#125;`&quot;        mode=&quot;out-in&quot;      &gt;        &lt;component :is=&quot;Component&quot; /&gt;      &lt;/Transition&gt;    &lt;/router-view&gt;  &lt;/div&gt;&lt;/template&gt;&lt;style scoped&gt;  /* ....*/&lt;/style&gt;</code></pre><h4 id="基于路由的动态过渡"><a href="#基于路由的动态过渡" class="headerlink" title="基于路由的动态过渡"></a>基于路由的动态过渡</h4><blockquote><p>也可以根据目标路由和当前路由之间的关系，动态地确定使用的过渡。<br>当从<code>/tab2/1</code>跳到<code>/tab1</code>时，采用的是淡入淡出动画。当从<code>tab1</code>跳转到<code>/tab2/1</code>时，采用的是左右滑动动画。 我们可以根据目标路由与当前路由的深度来决定采用何种动画过渡。</p></blockquote><blockquote><p>代码实现</p></blockquote><pre><code>&lt;!-- 使用动态过渡名称 --&gt;&lt;router-view v-slot=&quot;&#123; Component, route &#125;&quot;&gt;  &lt;transition :name=&quot;route.meta.transition&quot;&gt;    &lt;component :is=&quot;Component&quot; /&gt;  &lt;/transition&gt;&lt;/router-view&gt;</code></pre><ul><li>我们可以在<code>router.afterEach</code>导航后置守卫中，根据路径的深度动态添加信息到 <code>meta</code> 字段，来决定当前路由组件的过渡动画</li></ul><pre><code>router.afterEach((to, from) =&gt; &#123;  const toDepth = to.path.split(&quot;/&quot;).length;  const fromDepth = from.path.split(&quot;/&quot;).length;  to.meta.transition = toDepth &lt; fromDepth ? &quot;fade&quot; : &quot;slide&quot;;&#125;);</code></pre><h4 id="强制在复用的视图之间进行过渡"><a href="#强制在复用的视图之间进行过渡" class="headerlink" title="强制在复用的视图之间进行过渡"></a>强制在复用的视图之间进行过渡</h4><blockquote><p>Vue 可能会自动复用看起来相似的组件，从而忽略了任何过渡。幸运的是，可以添加一个 <code>key</code> 属性来强制过渡。</p></blockquote><ul><li>这也允许你在相同路由上使用不同的参数触发过渡</li></ul><pre><code>&lt;router-view v-slot=&quot;&#123; Component, route &#125;&quot;&gt;  &lt;transition name=&quot;fade&quot;&gt;    &lt;component :is=&quot;Component&quot; :key=&quot;route.path&quot; /&gt;  &lt;/transition&gt;&lt;/router-view&gt;const routes = [  &#123;    name: &quot;tab2&quot;,    path: &quot;/tab2/:id&quot;,    component: Tab2,  &#125;,];&lt;div class=&quot;menu&quot;&gt;  &lt;div&gt;&lt;router-link to=&quot;/tab2/1&quot;&gt;Tab2-1&lt;/router-link&gt;&lt;/div&gt;  &lt;div&gt;&lt;router-link to=&quot;/tab2/2&quot;&gt;Tab2-2&lt;/router-link&gt;&lt;/div&gt;  &lt;div&gt;&lt;router-link to=&quot;/tab2/3&quot;&gt;Tab2-3&lt;/router-link&gt;&lt;/div&gt;&lt;/div&gt;</code></pre><ul><li>如果<code>&lt;component :is=&quot;Component&quot; :key=&quot;route.path&quot; /&gt;</code>中没有添加<code>:key</code>属性，从<code>/tab2/</code>跳转到<code>/tab2/2</code>或<code>/tab2/3</code>时，并不会有过渡动画</li></ul><h3 id="十五、页面滚动行为"><a href="#十五、页面滚动行为" class="headerlink" title="十五、页面滚动行为"></a>十五、页面滚动行为</h3><blockquote><p>使用前端路由，当切换到新的路由时，想要滚动到页面顶部，或者保持原先的滚动位置是可以做到的。<br>注意：这个功能只在支持 <code>history.pushState</code> 的浏览器中可用。</p></blockquote><ul><li>我们需要在创建 Router 实例时，提供一个<code>scrollBehavior</code>方法</li></ul><pre><code>const router = createRouter(&#123;  history: createWebHistory(),  routes,  // to 目标路由  // from 离开页面路由  // savedPosition 保存当前路由滚动的位置  只有当这是一个 popstate 导航时才可用（由浏览器的后退/前进按钮触发）  scrollBehavior(to, from, savedPosition) &#123;    // return 你期望滚动到的位置  &#125;,&#125;);</code></pre><blockquote><p>scrollBehavior 函数返回值</p></blockquote><ul><li>返回值如果为一个空对象，表示路由切换时不发生滚动</li><li>如果是包含以下属性的对象，会滚动到你所设置的位置</li></ul><pre><code>&#123;    // el 值为一个css选择器或一个DOM元素    // 在没有el属性时，top与left值分表示滚动条与浏览器顶部与左边距离    // 有el属性时，top值与left值是相对于el选中元素的位置偏移量    top:0,    left:0,    // 值是一个css选择器或获取的DOM元素    el:&#39;.title&#39;  // document.querySelector(&#39;.title&#39;)    behavior：&#39;smooth&#39; // 平滑滚动&#125;</code></pre><ul><li>如果返加一个<code>Promise</code>对象， 则表示期望在等待一定时间后再滚动到指定位置，比如：当前页面有过渡动画，希望在过渡动画结束后再来滚动。</li></ul><pre><code>const router = createRouter(&#123;  scrollBehavior(to, from, savedPosition) &#123;    return new Promise((resolve, reject) =&gt; &#123;      //  在 500秒后，再滚动浏览器顶部      setTimeout(() =&gt; &#123;        resolve(&#123; left: 0, top: 0 &#125;);      &#125;, 500);    &#125;);  &#125;,&#125;);</code></pre><ol><li>滚动到页面顶部<blockquote><p>以下代码中<code>scrollBehavior函数</code>的返回值，表示进入页面时，滚动条滚动到页面顶部</p></blockquote></li></ol><pre><code>scrollBehavior(to, from, savedPosition) &#123;    return &#123;top:0&#125;  // 进入页面时，滚动条滚动到页面顶部    // return &#123;top:0,left:0&#125;&#125;</code></pre><ol start="2"><li>滚动到指定元素偏移位置<blockquote><p>以下代码中<code>scrollBehavior</code>的返回值，表示进入<code>/tab2/1001</code>页面时，滚动到<code>h3.title</code>元素顶部所在位置，其它情况滚动到浏览器的顶部。</p></blockquote></li></ol><pre><code>scrollBehavior(to, from, savedPosition) &#123;    if(to.path===&#39;/tab2/1001&#39;)&#123;        return &#123;            // 滚动值top，为相对路由组件中 h3.title元素的偏移量            el: &#39;h3.title&#39;,            top: 0        &#125;    &#125;else&#123;        return &#123;            top:0        &#125;    &#125;&#125;</code></pre><ul><li>我们在<code>App.vue</code>文件<code>.main</code>元素下添加<code>h3.title</code>元素</li></ul><pre><code>&lt;div class=&quot;main&quot;&gt;  &lt;!-- 部分代码省略--&gt;&lt;/div&gt;&lt;h3 class=&quot;title&quot;&gt;我是h3.title元素，滚动位置相对我的偏移量&lt;/h3&gt;</code></pre><ol start="3"><li>保持原先滚动位置<blockquote><p>当通过浏览器的浏览器的 <strong>后退</strong> 或 <strong>前进</strong> 按钮返回到原来页面时，会滚动到原先滚动的位置。</p><ul><li>如果不是通过后退和前进按扭，则滚动到浏览器顶部。</li></ul></blockquote></li></ol><ul><li>代码如下：</li></ul><pre><code>scrollBehavior(to, from, savedPosition) &#123;    // savedPosition 保存当当前路由的滚动位置    // 只有当这是一个 popstate`导航时才可用（由浏览器的后退/前进按钮触发），所以针对前进和后退按扭可以滚动到原先位置，其它的情况则不行。    console.log(savedPosition)    // 有值，表示是浏览器前进后退按扭触发导航，则可以返回到原位置，否则返回到顶部    if (savedPosition) &#123;        return savedPosition    &#125; else &#123;        return &#123;            top: 0,            behavior: &#39;smooth&#39;        &#125;    &#125;&#125;</code></pre><ol start="4"><li>滚动到锚点<blockquote><p>当我们点击锚点链接时，能平滑滚动到页面的锚点所在位置，如下图</p></blockquote></li></ol><ul><li>我们在<code>Tab1</code>组件中添加锚点链接和锚点要跳转到位置</li></ul><pre><code>&lt;div class=&quot;tab tab1&quot;&gt;  &lt;!-- 锚点链接 --&gt;  &lt;router-link to=&quot;#ab&quot;&gt;锚点链接&lt;/router-link&gt;  &lt;h1 style=&quot;height:1000px&quot;&gt;&lt;/h1&gt;  &lt;!-- 锚点位置--&gt;  &lt;div id=&quot;ab&quot;&gt;&lt;/div&gt;&lt;/div&gt;</code></pre><ul><li>添加以下配置使滚动条平滑滚动到锚点所在位置</li></ul><pre><code>// 创建路由实例const router = createRouter(&#123;  history: createWebHistory(), // history模式  routes,  scrollBehavior(to, from, savedPosition) &#123;    // 判断是否有hash值，如果有hash值，则跳转到指定hash值（锚点所链接位置）    if (to.hash) &#123;      return &#123;        el: to.hash,        behavior: &quot;smooth&quot;,      &#125;;    &#125;  &#125;,&#125;);</code></pre><ol start="5"><li>延迟滚动<blockquote><p>当进入到页面后，会先执行路由组件过渡动画，2 秒后动画执行完，滚动条再滚动到与浏览器顶部100px的位置</p></blockquote></li></ol><pre><code>scrollBehavior(to, from, savedPosition) &#123;        return new Promise((resolve, reject) =&gt; &#123;            // 2秒后，滚动条再开始平滑滚动到与浏览器顶部100px位置            setTimeout(() =&gt; &#123;                resolve(&#123;                    top: 100,                    left: 0,                    behavior: &#39;smooth&#39;                &#125;)            &#125;, 2000)        &#125;)    &#125;</code></pre><h3 id="十六、路由懒加载"><a href="#十六、路由懒加载" class="headerlink" title="十六、路由懒加载"></a>十六、路由懒加载</h3><ol><li>路由懒加载</li></ol><ul><li>路由懒加载是指按需加载路由所需的组件，即用到该组件就加载，没用到就不加载</li><li>使用<code>import()</code>函数就可以实现动态导入（按需加载）组件</li></ul><pre><code>// import() 动态加载组件，我们并不需要他一上来就加载，而是希望在用到时才加载，所以我们把import()作为箭头函数的返回值const Tab3 = () =&gt; import(&quot;../views/Tab3.vue&quot;);// 需要加载组件时，调用Tab3，加载Tab3组件Tab3();</code></pre><ul><li>在定义路由时，<code>component</code>和<code>components</code>配置可以接收一个返回 <code>Promise</code> 组件的函数。</li></ul><pre><code>const routes = [  &#123;    name: &quot;tab3&quot;,    path: &quot;/tab3&quot;,    // 以下import()方法本身返回的是一个Promise组件函数    component: () =&gt; import(&quot;../views/Tab1.vue&quot;),  &#125;,];// 或const routes = [  &#123;    name: &quot;tab3&quot;,    path: &quot;/tab3&quot;,    // 接受一个返回Promise组件函数    component: () =&gt;      Promise.resolve(&#123;        render() &#123;          return h(&quot;div&quot;, &quot;动态导入组件Tab2&quot;);        &#125;,      &#125;),  &#125;,];</code></pre><blockquote><p>代码演示</p></blockquote><ul><li>把之前案例中<code>router/index.js</code>中定义路由相关代码替换成如下</li></ul><pre><code>// 定义一些路由const routes = [  &#123;    name: &quot;tab1&quot;,    path: &quot;/&quot;,    // 动态加载组件    component: () =&gt; import(&quot;../views/Tab1.vue&quot;),    meta: &#123;      enterTransition: &quot;animate__backInDown&quot;,      leaveTransition: &quot;animate__backOutDown&quot;,    &#125;,  &#125;,  &#123;    name: &quot;tab2&quot;,    path: &quot;/tab2&quot;,    // 动态加载组件    component: () =&gt; import(&quot;../views/Tab2.vue&quot;),    meta: &#123;      enterTransition: &quot;animate__backInLeft&quot;,      leaveTransition: &quot;animate__backOutLeft&quot;,    &#125;,  &#125;,  &#123;    name: &quot;tab3&quot;,    path: &quot;/tab3&quot;,    // 动态加载组件    component: () =&gt;      Promise.resolve(&#123;        // 定义组件        setup() &#123;          const msg = ref(&quot;Hello 动态加载组件&quot;);          return () =&gt; h(&quot;div&quot;, msg.value);        &#125;,      &#125;),    meta: &#123;      enterTransition: &quot;animate__backInUp&quot;,      leaveTransition: &quot;animate__backOutUp&quot;,    &#125;,  &#125;,];</code></pre><ul><li>初次加载应用时，并不会加载没有用到的<code>Tab2</code>和<code>Tab3</code>组件，所以初次加载应用会非常快</li><li>当我们点击<code>Tab2</code>导航进入当前路由时，才会加载<code>Tab2</code>组件，并将组件缓存起来，当后面再次进到<code>Tab2</code>页面，不会再加载对应组件，而是会从缓存中读取。</li><li>当我们点击<code>Tab3</code>导航进入当前路由时，才会调用<code>component</code>后面的函数，渲染 DOM，插入页面</li></ul><ol start="2"><li>静态与动态加载组件对比</li></ol><ul><li>使用<code>import</code>关键字来加载组件，属于静态加载</li><li>静态导入组件有一个很大的弊端，在初次加载应用时，不管是否用到该路由，都会加载该组件，所以造成应用初次加载会很慢。</li></ul><pre><code>// 静态导入组件import Tab1 from &quot;../views/Tab1.vue&quot;;使用import()函数来加载组件，属于动态加载组件动态导入组件实现按需加载所需组件，所以初次加载应用时，用不到的组件不会加载，首次加载应用会很快，性能更好。// 动态导入组件const Tab1 = () =&gt; import(&quot;../views/Tab1.vue&quot;);</code></pre><ul><li>对于单页面开发，对所有的路由都实现按需加载是非常好的，这样初始加载应用时速度会更快，更高效。</li></ul><h3 id="十七、动态路由"><a href="#十七、动态路由" class="headerlink" title="十七、动态路由"></a>十七、动态路由</h3><blockquote><p>对路由的添加通常是通过<code>createRouter</code>构造函数的配置项<code>routes</code>选项来完成的。</p><p>但有些情况下，我们需要在程序运行时动态的添加或删除路由，我们可以调用<code>router</code>实例的相关方法来完成。</p></blockquote><ol><li>添加路由</li></ol><ul><li>调用<code>router.addRoute()</code>方法实现添加路由，只是添加路由到 <code>routes</code>选项中，并不会发生页面导航行为</li><li>在<code>router.addRoute()</code>中传入一个路由对象作为参数，会动态添加该路由到<code>routes</code>选项中</li></ul><pre><code>router.addRoute(&#123; name: &quot;tab1&quot;, path: &quot;/tab1&quot;, component: Tab1 &#125;);</code></pre><ol start="2"><li>添加嵌套路由<blockquote><p>如果需要为某个路由添加嵌套的子路由，可以将该路由的名字作为第一个参数传递给<code>router.addRoute()</code>，需要添加的子路由作为第二个参数传入。</p></blockquote></li></ol><pre><code>// 添加路由router.addRoute(&#123; path: &quot;/user&quot;, name: &quot;user&quot;, component: User &#125;);// 为上一条路由添加子路由router.addRoute(&quot;user&quot;, &#123; path: &quot;info&quot;, name: &quot;info&quot;, component: Info &#125;);</code></pre><ul><li>以上两条代码执行后，相当于在routes选项中添加了如下路由</li></ul><pre><code>const routes = [  &#123;    path: &quot;/user&quot;,    name: &quot;user&quot;,    component: User,    children: [      &#123;        path: &quot;info&quot;,        name: &quot;info&quot;,        component: Info,      &#125;,    ],  &#125;,];</code></pre><ol start="3"><li>删除路由<blockquote><p>删除routes选项中的某个路由，有以下三种方式</p></blockquote></li></ol><ul><li>方法1：添加一个已存在的同名（<code>name</code>值相同）路由，则会先删除原路由，再加添新路由</li></ul><pre><code>router.addRoute(&#123; name: &quot;tab1&quot;, path: &quot;/tab1&quot;, component: Tab1 &#125;);// 最终以下面这个为主router.addRoute(&#123; name: &quot;tab1&quot;, path: &quot;/&quot;, component: Home &#125;);</code></pre><ul><li>方法2：通过调用<code>router.addRoute()</code>返回的回调，针对没有名字的路由，这个方式很有用</li></ul><pre><code>//这里的removeRoute只是自己取的名字，与方法3不同const removeRoute = router.addRoute(&#123;  name: &quot;tab1&quot;,  path: &quot;/tab1&quot;,  component: Tab1,&#125;);//  删除路由如果存在的话removeRoute();</code></pre><ul><li>方法3：通过调用<code>router.removeRoute()</code>按路由名称来删除路由</li></ul><pre><code>router.addRoute(&#123; path: &quot;/tab2&quot;, name: &quot;tab2&quot;, component: Tab2 &#125;);// 删除路由router.removeRoute(&quot;tab2&quot;);</code></pre><ul><li>当路由被删除时，所有与该路由相关的内容都会被删除，也就是routes选项中没有该项</li></ul><ol start="4"><li>查看现有路由</li></ol><ul><li><code>router.hasRoute()</code>方法用于检查一个给定名称的路由是否存在，存在返回 true，不存在返回 false</li></ul><pre><code>router.hasRoute(&quot;user&quot;); // user为路由名称，存在返回true,不存在返回false</code></pre><ul><li><code>router.getRoutes()</code>方法能获得所有路由记录的完整列表</li></ul><pre><code>const routes = router.getRoutes(); // 相当于返回 路由定义中的routes</code></pre><ol start="5"><li>演示案例</li></ol><ul><li>当前项目的 routes 选项，默认只配置了一个路由，其它全都通过动态形式来添加</li></ul><pre><code>import &#123; createRouter, createWebHistory &#125; from &quot;vue-router&quot;;// 定义一些路由const routes = [  &#123;    name: &quot;home&quot;,    path: &quot;/&quot;,    component: () =&gt; import(&quot;../views/Home.vue&quot;),  &#125;,];// 创建路由实例const router = createRouter(&#123;  history: createWebHistory(),  routes,&#125;);export &#123; router &#125;;</code></pre><ul><li>App.vue组件</li></ul><pre><code>&lt;script setup&gt;  import &#123; ref &#125; from &quot;vue&quot;;  const removeRoute = ref(null);  import &#123; useRouter &#125; from &quot;vue-router&quot;;  const router = useRouter();  // 添加路由Tab1 和 user 及 user子路由  function addRoute1(nameOrRoute, route) &#123;    if (arguments.length === 1) &#123;      router.addRoute(nameOrRoute);    &#125; else &#123;      router.addRoute(nameOrRoute, route);    &#125;  &#125;  // 添加路由Tab2  function addRoute2() &#123;    removeRoute.value = router.addRoute(&#123;      name: &quot;tab2&quot;,      path: &quot;/tab2&quot;,      component: () =&gt; import(&quot;./views/Tab2.vue&quot;),    &#125;);  &#125;  // 移除路由Tab1  function removeRoute1(route) &#123;    router.removeRoute(route);  &#125;  // 删除路由2  function removeRoute2() &#123;    removeRoute.value();  &#125;  // 查看当前所有路由记录  function getRoutes() &#123;    console.log(router.getRoutes());  &#125;&lt;/script&gt;&lt;template&gt;  &lt;button    @click=&quot;addRoute1(&#123; name: &#39;tab1&#39;, path: &#39;/tab1&#39;, component: () =&gt; import(&#39;./views/Tab1.vue&#39;) &#125;)&quot;  &gt;    添加 / tab1路由  &lt;/button&gt;  |  &lt;button @click=&quot; addRoute2()&quot;&gt;添加/tab2路由&lt;/button&gt;  &lt;br /&gt;&lt;br /&gt;  &lt;button @click=&quot;removeRoute1(&#39;tab1&#39;)&quot;&gt;按名路由名删除/tab1路由&lt;/button&gt; |  &lt;button @click=&quot;removeRoute2()&quot;&gt;按addRoute回调删除/tab2路由&lt;/button&gt;  &lt;br /&gt;&lt;br /&gt;  &lt;button    @click=&quot;addRoute1(&#123; name: &#39;user&#39;, path: &#39;/user&#39;, component: () =&gt; import(&#39;./views/user.vue&#39;) &#125;)&quot;  &gt;    添加/user路由  &lt;/button&gt;  |  &lt;button    @click=&quot;addRoute1(&#39;user&#39;, &#123; path: &#39;info&#39;, name: &#39;info&#39;, component: () =&gt; import(&#39;./views/Info.vue&#39;) &#125;)&quot;  &gt;    添加user子路由  &lt;/button&gt;  &lt;button @click=&quot;getRoutes&quot;&gt;查看当前所有路由记录&lt;/button&gt;  &lt;br /&gt;&lt;br /&gt;  &lt;div class=&quot;menu&quot;&gt;    &lt;router-link to=&quot;/&quot;&gt; home &lt;/router-link&gt; |    &lt;router-link to=&quot;/tab1&quot;&gt; tab1 &lt;/router-link&gt; |    &lt;router-link to=&quot;/tab2&quot;&gt; tab2 &lt;/router-link&gt; |    &lt;router-link to=&quot;/user&quot;&gt; user &lt;/router-link&gt;  &lt;/div&gt;  &lt;div class=&quot;main&quot;&gt;    &lt;router-view&gt;&lt;/router-view&gt;  &lt;/div&gt;&lt;/template&gt;&lt;style&gt;  .main &#123;    margin-top: 30px;    display: flex;    justify-content: center;    align-items: center;  &#125;&lt;/style&gt;</code></pre><ul><li>User 组件中内容如下，其它路由子组件内容，大家可以自己随意添加</li></ul><pre><code>&lt;template&gt;  &lt;div&gt;    &lt;h3&gt;用户中心&lt;/h3&gt;    &lt;div class=&quot;menu&quot;&gt;      &lt;router-link to=&quot;/user/info&quot;&gt; Info &lt;/router-link&gt;    &lt;/div&gt;    &lt;div&gt;      &lt;router-view&gt;&lt;/router-view&gt;    &lt;/div&gt;  &lt;/div&gt;&lt;/template&gt;</code></pre><ul><li>刚开始，除了网站首页能访问，其它路由都不存在，则都无法访问，控制台抛出一堆警告</li><li>点击添加<code>/tab1</code>与<code>/tab2</code>路由后，两路由可正常访问</li><li>添加删除<code>/tab1</code>与<code>/tab2</code>路由后，两路由失效，无法访问</li><li>点击添加<code>/user</code>路由后，<code>/user</code>路由可访问，但其子路由<code>/user/info</code>还没法访问</li><li>点击添加<code>/user</code>子路由后，则<code>/user/info</code>路由可正常访问</li><li>最后点击查看当前所有路由记录</li></ul>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Vue </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Vue（六）</title>
      <link href="/2024/01/26/Vue%EF%BC%88%E5%85%AD%EF%BC%89/"/>
      <url>/2024/01/26/Vue%EF%BC%88%E5%85%AD%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<span id="more"></span><h3 id="一、Vue-描述-UI-的-2-种方式"><a href="#一、Vue-描述-UI-的-2-种方式" class="headerlink" title="一、Vue 描述 UI 的 2 种方式"></a>一、Vue 描述 UI 的 2 种方式</h3><blockquote><p>Vue 提供了以下两种方式来声明式描述 UI</p><ul><li>模板语法来描述 UI</li><li>虚拟 DOM 来描述 UI</li></ul></blockquote><ul><li>模板语法<ul><li>以下代码使用模板语法来描述 UI</li></ul></li></ul><pre><code>&lt;!-- 模板语法描述UI --&gt;&lt;button @click=&quot;count++&quot;&gt;&#123;&#123; count &#125;&#125;&lt;/button&gt;</code></pre><ul><li>虚拟 DOM<ul><li>以下代码使用虚拟 DOM 来描述 UI</li></ul></li></ul><pre><code>/*   h() 函数是Vue提供用来创建虚拟DOM ,函数的      第一个参数：元素的HTML标签名      第二个参数：标签元素的属性、事件等      第三个参数：标签元素的子元素内容*/h(&quot;button&quot;, &#123; onClick: () =&gt; count.value++ &#125;, count.value);</code></pre><blockquote><p>注：</p></blockquote><ul><li>以上两段代码采用了不同的方式描述 UI，但最终渲染出来的结果是一模一样，都是告诉 Vue：<ul><li>需要生成button元素，button元素的innerText值为count变量的值</li><li>为button元素绑定了click事件，点击按扭后，count变量的值 +1</li></ul></li></ul><h3 id="二、虚拟-DOM"><a href="#二、虚拟-DOM" class="headerlink" title="二、虚拟 DOM"></a>二、虚拟 DOM</h3><h4 id="虚拟-DOM-定义"><a href="#虚拟-DOM-定义" class="headerlink" title="虚拟 DOM 定义"></a>虚拟 DOM 定义</h4><blockquote><p>虚拟 DOM（Virtual DOM，简称 VDOM）是一种编程概念，意为将目标所需的 UI 通过数据结构“虚拟”地表示出来，保存在内存中，然后将真实的 DOM 与之保持同步。</p><ul><li>”虚拟 DOM“ 简单理解就是用一个纯 JavaScript 的对象来描述真实的 DOM 结构</li><li>”虚拟 DOM“ 这个概念是由 React 率先开拓，随后被许多不同的框架采用，当然也包括 Vue。</li></ul></blockquote><ul><li>以下为真实 DOM</li></ul><pre><code>&lt;div id=&quot;box&quot; class=&quot;active&quot;&gt;&lt;/div&gt;</code></pre><ul><li>转换成虚拟 DOM</li></ul><pre><code>const vnode = &#123;  // 标签名 &lt;div&gt;  tag: &quot;div&quot;,  // 标签上的属性  props: &#123;    id: &quot;box&quot;,    class: &quot;active&quot;,  &#125;,  children: null, // 可以是 null 空数组、&quot;&quot; 或 不存在 都可以  // .....&#125;;</code></pre><blockquote><p>注：上面代码用一个 JS 对象表达 DOM 结构</p></blockquote><ul><li><code>tag</code>：属性用来描述标签名称，所以tag:’div’ 描述的就是一个<div>标签</li><li><code>props</code>：属性值是一个对象，用来描述标签的属性、事件等内容。所以<code>props:&#123;id:&#39;box&#39;,class:&#39;active&#39;&#125;</code> 表示标签的属性，如：<div id='box' class='active'></div></li><li><code>children</code>：属性用来描述标签的子节点，没有子节点，所以值为 <code>null</code>，当然也可是空数组，空字符串都可以。</li><li>注意： JS 对象表示 vnode 的写法<strong>并不是固定的</strong>，对象中属性名可以自定义，也可以增加其它属性来表示元素的其它信息，没有规定说一定要如何写才是对，只要能用一个对象来表达出 DOM 的信息，就是合理的。<ul><li>与其说虚拟 DOM 是一种具体的技术，不如说是一种模式，所以并没有一个标准的实现。</li></ul></li></ul><h4 id="手动创建虚拟-DOM"><a href="#手动创建虚拟-DOM" class="headerlink" title="手动创建虚拟 DOM"></a>手动创建虚拟 DOM</h4><blockquote><p>将以下 DOM 结构转换为虚拟 DOM（vnode）</p></blockquote><pre><code>&lt;div id=&quot;box&quot; class=&quot;active&quot;&gt;  &lt;a href=&quot;xxx.html&quot; target=&quot;_blank&quot;&gt;    &lt;img src=&quot;xxx.png&quot; alt=&quot;图片&quot; /&gt;  &lt;/a&gt;  &lt;p&gt;图片描述&lt;/p&gt;&lt;/div&gt;</code></pre><ul><li>以上 DOM 结构转换为 vnode 如下</li></ul><pre><code>const vnode = &#123;  // 标签名 &lt;div&gt;  tag: &quot;div&quot;,  // 标签上的属性  props: &#123;    id: &quot;box&quot;,    class: &quot;active&quot;,  &#125;,  // 标签的子节点，数组中每一个对象用来描述一个子节点  children: [    // 第一个子节点，    &#123;      tag: &quot;a&quot;,      props: &#123;        href: &quot;xxx.html&quot;,        target: &quot;_blank&quot;,      &#125;,      children: [        &#123;          tag: &quot;img&quot;,          props: &#123;            src: &quot;xxx.png&quot;,            alt: &quot;图片&quot;,          &#125;,        &#125;,      ],    &#125;,    // 第二个子节点    &#123;      tag: &quot;p&quot;,      children: &quot;图片描述&quot;,    &#125;,  ],&#125;;</code></pre><ul><li>上面代码用一个 JS 对象表达 DOM 结构</li><li><code>tag</code>：属性用来描述标签名称，所以<code>tag:&#39;div&#39; </code>描述的就是一个<div>标签</li><li><code>props</code>：属性值是一个对象，用来描述标签的属性、事件等内容。所以<code>props:&#123;id:&#39;box&#39;,class:&#39;active&#39;&#125;</code> 表示标签的属性，如：<code>&lt;div id=&#39;box&#39; class=&#39;active&#39;&gt;&lt;/div&gt;</code></li><li><code>children</code>：属性用来描述标签的子节点<ul><li>值可以是一个数组，数组中的每一个对象表示一个子节点。</li><li>也可以是一个字符串，表示只有一个文本类的子节点。</li></ul></li></ul><h4 id="自动创建虚拟-DOM"><a href="#自动创建虚拟-DOM" class="headerlink" title="自动创建虚拟 DOM"></a>自动创建虚拟 DOM</h4><blockquote><p>如果真实 DOM 的结构非常复杂，我们还采用手动形式来书写虚拟 DOM 这肯定是不可行的。所以我们可以创建一个方法，用来将真实 DOM 转换成虚拟 DOM<br>实现原理</p><ul><li>创建一个函数，根据真实 DOM 节点返回 vnode</li><li>处理节点标签名</li><li>处理节点属性</li><li>处理节点的子节点</li></ul></blockquote><blockquote><p>实现步骤</p></blockquote><ul><li>创建一个函数<code>createNode</code>，该函数的第一个参数为真实 DOM 元素，然后返回该 DOM 元素的 <code>vnode</code></li></ul><pre><code>function createNode(el) &#123;  const vnode = &#123;&#125;;  // ....  return vnode;&#125;// 返回#box的vnodeconst vnode = createNode(document.getElementById(&quot;box&quot;));</code></pre><ul><li>判断 el 是否是元素节点，如果是元素节点，则获取该元素的标签名</li></ul><pre><code>// 1、判断el是否为元素节点，如果是，获取该元素的标签名if (el.nodeType === 1) &#123;  vnode.tag = el.tagName.toLowerCase();&#125;</code></pre><ul><li>用<code>attribute</code>获取元素节点的所有属性，然后将属性名与属性值作为 <code>props </code>的属性和属性值</li></ul><pre><code>// 2、获取元素节点的所有属性，然后将属性名与属性值作为props的属性和属性值const attrs = el.attributes;// 如果有属性if (attrs.length) &#123;  const props = &#123;&#125;;  vnode.props = props;  [...attrs].forEach((attr) =&gt; &#123;    // 取出对应属性的属性名与属性值    let &#123; name, value &#125; = attr;    props[name] = value;  &#125;);&#125;</code></pre><ul><li>用<code>childNodes</code>获取该元素节点的子节点，如果存在，创建<code>vnode.children=[]</code>,用来保存子节点。</li><li>在添加前，要判断子节点的类型。<ul><li>如果子节点为文本节点，则直接将文本节点的<code>nodeValue</code>添加到数组中</li><li>如果子节点为元素节点，则利用递归，获取子节点的 vnode，然后将 vnode 添加到数组中。</li></ul></li><li>注意：不能使用<code>children</code>来获取子节点，因为它拿不到文本节点</li></ul><pre><code>// 3、获取子节点const children = el.childNodes;// 如果存在子节点if (children.length) &#123;  vnode.children = [];  [...children].forEach((child) =&gt; &#123;    // 如果为文本节点    if (child.nodeType === 3) &#123;      // 如果不考虑空的文本节点      if (child.nodeValue.trim()) &#123;        //将不为空的文本节点push进vnode.children        vnode.children.push(child.nodeValue.trim());      &#125;      // 如果为元素节点，就进行递归    &#125; else if (child.nodeType === 1) &#123;      vnode.children.push(createNode(child));    &#125;  &#125;);&#125;</code></pre><ul><li>最终完整版代码如下：</li></ul><pre><code>export default function createNode(el) &#123;  const vnode = &#123;&#125;;  // 1、判断el是否为元素节点，如果是，获取该元素的标签名  if (el.nodeType === 1) &#123;    vnode.tag = el.tagName.toLowerCase();    // 2、获取元素的所有属性，然后遍历，将属性与属性对应值添加到props对象上    const attrs = el.attributes;    // 如果有属性    if (attrs.length) &#123;      const props = &#123;&#125;;      vnode.props = props;      [...attrs].forEach((attr) =&gt; &#123;        let &#123; name, value &#125; = attr;        props[name] = value;      &#125;);    &#125;    // 3、获取子节点    const children = el.childNodes;    // 如果存在子节点    if (children.length) &#123;      vnode.children = [];      [...children].forEach((child) =&gt; &#123;        // 如果为文本节点        if (child.nodeType === 3) &#123;          // 如果不考虑空的文本节点，可以加个判断          if (child.nodeValue.trim()) &#123;            vnode.children.push(child.nodeValue.trim());          &#125;          // 如果为元素节点        &#125; else if (child.nodeType === 1) &#123;          vnode.children.push(createNode(child));        &#125;      &#125;);    &#125;  &#125;  // ....  return vnode;&#125;</code></pre><blockquote><p>回顾知识点</p><table><thead><tr><th>节点类型</th><th>nodeName</th><th>nodeType</th><th>nodeVulue</th></tr></thead><tbody><tr><td>文档节点</td><td>#document</td><td>9</td><td>null</td></tr><tr><td>元素节点</td><td>标签名</td><td>1</td><td>null</td></tr><tr><td>属性节点</td><td>属性名</td><td>2</td><td>属性值</td></tr><tr><td>文本节点</td><td>#text</td><td>3</td><td>文本内容</td></tr></tbody></table></blockquote><blockquote><p>拿到子节点的方式有两种</p></blockquote><ul><li><code>childNodes</code>考虑所有节点</li><li><code>children</code>只考虑元素节点</li></ul><h3 id="三、Vue-渲染函数"><a href="#三、Vue-渲染函数" class="headerlink" title="三、Vue 渲染函数"></a>三、Vue 渲染函数</h3><blockquote><p>前面我们提到 Vue 提供了 模板语法 与 虚拟 DOM 两种方式来声明式的描述 UI，那 Vue 是如何将模板与虚拟 DOM 转换为真实的 DOM 节点呢 ？这就需要用到 Vue 提供的以下两个函数：</p></blockquote><ul><li><code>h()</code>函数：创建虚拟 DOM</li><li><code>render()</code>渲染函数：返回虚拟 DOM</li></ul><blockquote><p>代码示例</p></blockquote><ul><li>以下 Vue 代码利用<code>h()</code>函数来创建虚拟 DOM，然后利用<code>render</code>渲染函数返回虚拟 DOM。最终 Vue 会利用渲染器将虚拟 DOM 转换为真实 DOM 显示在页面中。</li></ul><pre><code>&lt;script&gt;  import &#123; h, ref &#125; from &quot;vue&quot;;  export default &#123;    setup() &#123;      let count = ref(10);      /*           h() 函数用来创建虚拟DOM ,函数的          第一个参数：元素的HTML标签名          第二个参数：标签元素的属性、事件等          第三个参数：标签元素的子元素内容          setup函数返回值为 render渲染函数  render函数返回用虚拟DOM树，最终Vue渲染器会将虚拟DOM渲染成真实DOM挂载到页面中。            */      return () =&gt; h(&quot;button&quot;, &#123; onClick: () =&gt; count.value++ &#125;, count.value);    &#125;,  &#125;;&lt;/script&gt;</code></pre><h4 id="h-函数的语法"><a href="#h-函数的语法" class="headerlink" title="h() 函数的语法"></a>h() 函数的语法</h4><ul><li><code>Vue</code>提供的<code>h()</code>函数是用来创建 <code>vnodes</code></li><li><code>h()</code>是 <code>hyperscript</code> 的简称 —— 意思是 “能生成 HTML（超文本标记语言）的 JavaScript”</li></ul><blockquote><p>语法</p></blockquote><pre><code>function h( type: string | Component, props?: object | null, children?: Children | Slot | Slots): VNode// children值的三种类型type Children = string | number | boolean | VNode | null | Children[]type Slot = () =&gt; Children  // 组件默认插槽内容type Slots = &#123; [name: string]: Slot &#125;  //  组件插槽内容</code></pre><blockquote><p>参数</p></blockquote><ul><li><code>type</code>：如果值为字符串，表示生成 DOM 元素的标签名。如果是一个 Vue 组件，表示将组件转换为 vnode</li><li><code>props</code>：可选参数，用于定义生成后标签元素或组件的属性、事件，值可以是一个对象也可以 null</li><li><code>children</code>：可选参数，用于生成标签元素的子节点或组件的插槽内容</li></ul><h4 id="h-函数的基本用法"><a href="#h-函数的基本用法" class="headerlink" title="h 函数的基本用法"></a>h 函数的基本用法</h4><blockquote><p>实际上h()函数的使用非常灵活。h函数可以</p></blockquote><ul><li>创建原生 HTML 元素的 vnode</li><li>也可以创建组件的 vnode</li></ul><ol><li>创建 HTML 元素的 vnode<blockquote><p>以下代码为测试示例，你可以更改以下代码的h()，来查看最终生成的 DOM，掌握h函数的用法</p></blockquote></li></ol><pre><code>&lt;script&gt;  import &#123; h &#125; from &quot;vue&quot;;  export default &#123;    setup() &#123;      return () =&gt; h(&quot;div&quot;);    &#125;,  &#125;;&lt;/script&gt;</code></pre><ul><li>h 函数被传入三个参数，第一个参数为标签名，第二个为标签属性，第三个为子节点</li></ul><pre><code>h(&quot;div&quot;, &#123; id: &quot;box&quot; &#125;, &quot;Hello Vue!!&quot;);// 以上代码，最终生成如下结构的vnodeconst vndoe = &#123;  type: &quot;div&quot;,  props: &#123; id: &quot;box&quot; &#125;,  children: &quot;Hello Vue!!&quot;,  //......&#125;;//  渲染后DOM :   &lt;div id=&#39;box&#39;&gt; Hello Vue!! &lt;/div&gt;</code></pre><ul><li>第一个参数必填，表示标签名，其它两个参数为可选项</li></ul><pre><code>h(&quot;div&quot;); // 渲染后DOM : &lt;div&gt;&lt;/div&gt;h(&quot;div&quot;, &#123; id: &quot;foo&quot; &#125;); // 渲染后DOM :&lt;div id=&#39;foo&#39;&gt;&lt;/div&gt;</code></pre><ul><li>没有 prop 时可以省略不写，<strong>第二个参数表示子节点</strong></li></ul><pre><code>h(&quot;div&quot;, &quot;hello&quot;); //  渲染后DOM :&lt;div&gt;hello&lt;/div&gt;h(&quot;div&quot;, [h(&quot;span&quot;, &quot;hello&quot;)]); // 渲染后DOM : &lt;div&gt;&lt;span&gt;hello&lt;/span&gt;&lt;/div&gt;</code></pre><ul><li>第三个参数children，可以是是以下任意类型</li></ul><pre><code>/* 字符串、数字、布尔值、虚拟DOM、null 、数组（成员为前面几种类型组成） */type Children = string | number | boolean | VNode | null | Children[];</code></pre><pre><code>h(&quot;div&quot;, &#123; id: &quot;foo&quot; &#125;, &quot;hello&quot;);// 渲染后DOM :&lt;div id=&quot;foo&quot;&gt;hello&lt;/div&gt;h(&quot;div&quot;, true);//  渲染后DOM:&lt;div&gt;true&lt;/div&gt;h(&quot;div&quot;, h(&quot;span&quot;, &#123; class: &quot;sp&quot; &#125;));// 渲染后DOM &lt;div&gt;&lt;span class=&quot;sp&quot;&gt;&lt;/span&gt;&lt;/div&gt;h(&quot;div&quot;, [&quot;hello&quot;, h(&quot;span&quot;, &quot;hello&quot;)]);// 渲染后DOM : &lt;div&gt;hello&lt;span&gt;hello&lt;/span&gt;&lt;/div&gt;</code></pre><ol start="2"><li>创建组件的 vnode<blockquote><p>当给组件创建 vnode 时，传入给h()函数的</p></blockquote></li></ol><ul><li>第一个参数应当是组件的定义</li><li>第二个参数是传递给组件的 prop 或 事件监听</li><li>第三个参数是传递给组件的插槽内容，如果组件只有默认槽，可以使用单个插槽函数进行传递。否则，必须以插槽函数的对象形式来传递。</li></ul><pre><code>type Slot = () =&gt; Children; // 只有一个默认插槽时，通过插槽函数传递插槽内容type Slots = &#123; [name: string]: Slot &#125;; // 多个插槽时，要通过插槽函数对象形式传递插槽内容</code></pre><blockquote><p>代码示例</p></blockquote><ul><li><code>App.vue</code></li></ul><pre><code>&lt;script&gt;  import &#123; h, ref &#125; from &#39;vue&#39;;  import A from &quot;./components/A.vue&quot;  export default &#123;      setup() &#123;          const title = ref(&quot;新闻标题&quot;);          const info = ref(&quot;新闻内容&quot;);          function update() &#123;              title.value = &quot;标题XXX&quot;;              info.value = &quot;内容XXX&quot;          // 渲染函数          return () =&gt; h(              // 组件定义              A,              // 组件属性与事件              &#123;                  title: title.value,  // prop属性                  info: info.value,  //  prop属性                  onUpdate: update  // 组件监听事件              &#125;,              // 只传递默认插槽内容              // () =&gt; h(&#39;div&#39;, &#123; class: &quot;header&quot; &#125;, &quot;最新动态&quot;),              // 传递多个插槽内容              &#123;                  default: () =&gt; h(&#39;div&#39;, &#123; class: &quot;header&quot; &#125;, &quot;最新动态&quot;),                  footer: () =&gt; h(&#39;div&#39;, &#123; class: &#39;footer&#39; &#125;, &quot;底部&quot;)              &#125;          )      &#125;  &#125;&#125;&lt;/script&gt;&lt;style scoped&gt;  .header,  .footer &#123;    margin: 20px 0;    background-color: skyblue;  &#125;&lt;/style&gt;</code></pre><ul><li>A.vue</li></ul><pre><code>&lt;script setup&gt;  // props  defineProps([&quot;title&quot;, &quot;info&quot;]);  // emit  defineEmits([&quot;update&quot;]);&lt;/script&gt;&lt;template&gt;  &lt;div class=&quot;com-a&quot;&gt;    &lt;!-- 默认插槽 --&gt;    &lt;slot&gt;&lt;/slot&gt;    &lt;div class=&quot;main&quot;&gt;      &lt;h3&gt;&#123;&#123; title &#125;&#125;&lt;/h3&gt;      &lt;p&gt;&#123;&#123; info &#125;&#125;&lt;/p&gt;      &lt;button @click=&quot;$emit(&#39;update&#39;)&quot;&gt;更新&lt;/button&gt;    &lt;/div&gt;    &lt;!-- 具名插槽 --&gt;    &lt;slot name=&quot;footer&quot;&gt;&lt;/slot&gt;  &lt;/div&gt;&lt;/template&gt;&lt;style scoped&gt;  .main &#123;    background-color: #ddd;  &#125;&lt;/style&gt;</code></pre><h4 id="渲染函数的基本用法"><a href="#渲染函数的基本用法" class="headerlink" title="渲染函数的基本用法"></a>渲染函数的基本用法</h4><blockquote><p><code>render()</code>用于编程式地创建组件虚拟 DOM 树的函数，返回值为 <code>VNodeChild</code> 类型。</p><ul><li>在以下三种情况会用到渲染函数</li></ul></blockquote><ul><li>选项式 API 中的<code>render </code>选项</li><li><code>setup()</code>函数直接返回<code>render </code>渲染函数</li><li><code>&lt;script setup&gt;</code>中使用<code>render </code>渲染函数</li></ul><ol><li>选项式 API</li></ol><ul><li>在选项式 API 中，我们可以使用 render 选项来声明渲染函数</li><li>render()函数中的 this 为当前组件实例，所以在render()函数中可以访问组件的属性和方法等</li></ul><pre><code>&lt;!-- App.vue --&gt;&lt;script&gt;  import &#123; h &#125; from &quot;vue&quot;;  export default &#123;    data() &#123;      return &#123;        message: &quot;Hello Vue!!&quot;,      &#125;;    &#125;,    render() &#123;      // 返回值为vnode      return h(&quot;div&quot;, &#123; id: &quot;box&quot; &#125;, this.message);    &#125;,  &#125;;&lt;/script&gt;</code></pre><p>以上 App 组件最终渲染后的真实 DOM 如下：</p><pre><code>&lt;div id=&quot;box&quot;&gt;Hello Vue!!&lt;/div&gt;</code></pre><ol start="2"><li>setup() 函数中</li></ol><ul><li>组合式 API 中，<code>setup()</code>钩子可以直接返回渲染函数。</li><li>在 <code>setup()</code>内部声明的渲染函数天生能够访问在同一范围内声明的 props 和许多响应式状态。</li></ul><pre><code>&lt;script&gt;  import &#123; h, ref &#125; from &quot;vue&quot;;  export default &#123;    props: [&quot;text&quot;], // props.text的值是 Vue!!    data() &#123;      return &#123;        message: &quot;Hello&quot;, // setup中访问不到      &#125;;    &#125;,    setup(props) &#123;      const msg = ref(&quot;Hello&quot;);      return () =&gt; &#123;        return h(&quot;div&quot;, &#123; id: &quot;box&quot; &#125;, msg.value + props.text);      &#125;;    &#125;,  &#125;;&lt;/script&gt;</code></pre><ul><li>以上 App 组件最终渲染后的真实 DOM 如下：</li></ul><pre><code>&lt;div id=&quot;box&quot;&gt;Hello Vue!!&lt;/div&gt;</code></pre><ol start="3"><li>在 <code>&lt;script setup&gt;</code> 中使用<blockquote><p>在 setup 中，一个带有 <code>render</code>选项的 JS 对象就会被当成组件渲染，可以直接在模板中使用。</p></blockquote></li></ol><pre><code>&lt;script setup&gt;  import &#123; h, ref &#125; from &quot;vue&quot;;  const info = ref(&quot;ComA&quot;);  const ComA = &#123;    render() &#123;      return h(&quot;div&quot;, info.value);    &#125;,  &#125;;&lt;/&gt;&lt;template&gt;  &lt;ComA&gt;&lt;/ComA&gt;&lt;/template&gt;</code></pre><h4 id="根渲染函数"><a href="#根渲染函数" class="headerlink" title="根渲染函数"></a>根渲染函数</h4><blockquote><p>根渲染函数是用于将一个 vnode 转换为真实 DOM 挂载到指定的 DOM 容器中。</p></blockquote><ul><li>语法：</li></ul><pre><code>function render(vnode, container, isSVG?: boolean) &#123;&#125;</code></pre><ul><li>代码示例</li></ul><pre><code>&lt;script setup&gt;  import &#123; h, render, ref, onMounted &#125; from &quot;vue&quot;;  // 创建vnode  const vnode = h(&quot;div&quot;, &#123; id: &quot;box&quot; &#125;, &quot;Hello Vue!!&quot;);  // 获取.container元素  const container = ref(null);  onMounted(() =&gt; &#123;    // 将vnode转换为真实DOM挂载到页面    // 第一个参数为vnode，第二个参数为挂载容器    render(vnode, container.value);    // render(vnode, document.body)  &#125;);&lt;/script&gt;&lt;template&gt;  &lt;div class=&quot;container&quot; ref=&quot;container&quot;&gt;&lt;/div&gt;&lt;/template&gt;</code></pre><h4 id="渲染函数-与-template-模板"><a href="#渲染函数-与-template-模板" class="headerlink" title="渲染函数 与 template 模板"></a>渲染函数 与 template 模板</h4><ul><li><code>render</code>函数是字符串模板的一种替代，所以不能一个组件中同时拥有<code>render</code>和<code>template</code>。</li><li>因为单文件组件中的<code>template</code>模板，会在构建时被编译为<code>render</code>函数，添加到组件实例上。</li></ul><blockquote><p>代码示例</p></blockquote><ul><li><code>A.vue</code>文件</li></ul><pre><code>&lt;script setup&gt;  import &#123; ref &#125; from &quot;vue&quot;;  const msg = ref(&quot;A组件&quot;);&lt;/script&gt;&lt;template&gt;  &lt;div&gt;A组件&lt;/div&gt;&lt;/template&gt;</code></pre><ul><li><code>App.vue</code></li></ul><pre><code>&lt;script setup&gt;  import A from &quot;./components/A.vue&quot;;  console.log(A);&lt;/script&gt;&lt;template&gt;&lt;/template&gt;</code></pre><h4 id="模板-VS-渲染函数"><a href="#模板-VS-渲染函数" class="headerlink" title="模板 VS 渲染函数"></a>模板 VS 渲染函数</h4><blockquote><p>Vue 提供了以下两种方式来声明式描述 UI</p></blockquote><ul><li>使用模板语法来描述 UI</li><li>使用虚拟 DOM 来描述 UI</li></ul><blockquote><p>在绝大多数情况下，Vue 推荐使用模板语法来创建应用，主要原因有：</p></blockquote><ul><li>模板更贴近实际的 HTML。这使得我们能够更方便地重用一些已有的 HTML 代码片段，能够带来更好的可访问性体验、能更方便地使用 CSS 应用样式，并且更容易使设计师理解和修改。</li><li>由于其确定的语法，更容易对模板做静态分析。这使得 Vue 的模板编译器能够应用许多编译时优化来提升虚拟 DOM 的性能表现 。具体内容参考 Vue 官网：带编译时信息的虚拟 DOM(opens new window)</li></ul><blockquote><p>在实践中，模板对大多数的应用场景都是够用且高效的。渲染函数一般只会在需要处理高度动态渲染逻辑的可重用组件中使用。</p></blockquote><ul><li>比如接下来要讲到的《动态生成带锚点标题》的案例，使用渲染函数要比使用模板语法来的更简洁高效易读。</li></ul><h4 id="实战应用：动态生成带锚点标题"><a href="#实战应用：动态生成带锚点标题" class="headerlink" title="实战应用：动态生成带锚点标题"></a>实战应用：动态生成带锚点标题</h4><blockquote><p>我们希望创建如下这样一个组件，这个组件可以根据传入的<code>level</code>属性值，动态生成带有链接的的 <code>h</code> 标签。</p></blockquote><pre><code>&lt;AnchoredHeading :level=&quot;3&quot; href=&quot;http://www.icodingedu.com&quot;  &gt;艾编程&lt;/AnchoredHeading&gt;&lt;!-- 以上代码最终编译后的真实DOM如下 --&gt;&lt;h3&gt;&lt;a href=&quot;http://www.icodingedu.com&quot;&gt;艾编程&lt;/a&gt;&lt;/h3&gt;</code></pre><blockquote><p>我们采用模板语法和虚拟 DOM 两种方式来描述 UI，通过对比来看那种方式更简洁</p></blockquote><ul><li>模板语法来描述 UI</li></ul><pre><code>&lt;script setup&gt;  defineProps([&quot;level&quot;, &quot;href&quot;]);&lt;/script&gt;&lt;template&gt;  &lt;h1 v-if=&quot;level === 1&quot;&gt;    &lt;a :href=&quot;href&quot;&gt;      &lt;slot&gt;&lt;/slot&gt;    &lt;/a&gt;  &lt;/h1&gt;  &lt;h2 v-else-if=&quot;level === 2&quot;&gt;    &lt;a :href=&quot;href&quot;&gt;      &lt;slot&gt;&lt;/slot&gt;    &lt;/a&gt;  &lt;/h2&gt;  &lt;h3 v-else-if=&quot;level === 3&quot;&gt;    &lt;a :href=&quot;href&quot;&gt;      &lt;slot&gt;&lt;/slot&gt;    &lt;/a&gt;  &lt;/h3&gt;  &lt;h4 v-else-if=&quot;level === 4&quot;&gt;    &lt;a :href=&quot;href&quot;&gt;      &lt;slot&gt;&lt;/slot&gt;    &lt;/a&gt;  &lt;/h4&gt;  &lt;h5 v-else-if=&quot;level === 5&quot;&gt;    &lt;a :href=&quot;href&quot;&gt;      &lt;slot&gt;&lt;/slot&gt;    &lt;/a&gt;  &lt;/h5&gt;  &lt;h6 v-else-if=&quot;level === 6&quot;&gt;    &lt;a :href=&quot;href&quot;&gt;      &lt;slot&gt;&lt;/slot&gt;    &lt;/a&gt;  &lt;/h6&gt;&lt;/template&gt;</code></pre><ul><li>虚拟 DOM 描述 UI</li></ul><pre><code>&lt;script&gt;  import &#123; h &#125; from &quot;vue&quot;;  export default &#123;    props: [&quot;level&quot;, &quot;href&quot;],    setup(props, &#123; slots &#125;) &#123;      return () =&gt;        h(&quot;h&quot; + props.level, h(&quot;a&quot;, &#123; href: props.href &#125;, slots.default()));    &#125;,  &#125;;&lt;/script&gt;</code></pre><ul><li>通过对比，明显采用虚拟 DOM 描述 UI 的方式在这里更合适，代码相对要简洁很多</li></ul><h3 id="四、Vue-渲染机制"><a href="#四、Vue-渲染机制" class="headerlink" title="四、Vue 渲染机制"></a>四、Vue 渲染机制</h3><blockquote><p>通过前面的学习，我知道 Vue 提供了<strong>模板语法</strong>与<strong>虚拟 DOM</strong>两种方式声明式描述 UI。</p><ul><li>如果 Vue 提供虚拟 DOM 来描述 UI，则需要用到 h 函数来创建虚拟 DOM，render 函数来返回虚拟 DOM。最终 vue 渲染器会将 vnode 转换为真实 DOM。但渲染器是如何将 vnode 转换为真实 DOM 的呢 ？</li><li>如果 Vue 采用模板语法来描述 UI，那模板最终会被编译成什么，又如何转换成真实 DOM 的呢？</li></ul><p>要回答面提到的两个问题，就需要先掌握以下几个知识点：</p><ul><li>编译器</li><li>虚拟 DOM</li><li>渲染器</li><li>渲染器渲染组件</li></ul><p>当我们了解了以上知识点后，我们就知道 Vue 的整个渲染流程和渲染机制了。</p></blockquote><h4 id="编译器"><a href="#编译器" class="headerlink" title="编译器"></a>编译器</h4><blockquote><p>Vue 中的编译器主要是将 Vue 的模板编译成渲染函数，该渲染函数会添加到组件实例上。这一步通常是通过构建步骤提前完成的，也可以使用运行时编译器即时完成。即：</p></blockquote><ul><li>如果我们采用<strong>虚拟 DOM</strong>来描述 UI，并不需要用到编译器，因为我们是直接通过<code>h()</code>函数来创建 vnode，然后在render渲染函数中返回 vnode。</li><li>只有采用<strong>模板语法</strong>来描述 UI 时，才需要用到编译器。</li></ul><blockquote><p>定义了一个 Vue 组件：</p></blockquote><pre><code>&lt;!--A组件--&gt;&lt;script setup&gt;  function handler() &#123;&#125;&lt;/script&gt;&lt;template&gt;  &lt;div @click=&quot;handler&quot;&gt;点我&lt;/div&gt;&lt;/template&gt;</code></pre><ul><li>在构建时，编译器会将上模板转换为一个与之功能相同的渲染函数，添加到组件实例上。</li><li>以上单文件组件最终被转换成如下代码：</li></ul><pre><code>function handler() &#123;&#125;const A = &#123;  __name: &quot;A&quot;, // 组件名  render() &#123;    //  h函数，用来生成vnode，    return h(&quot;div&quot;, &#123; onClick: handler &#125;, &quot;点我&quot;);  &#125;,  //......省略更多属性&#125;;</code></pre><h4 id="渲染器"><a href="#渲染器" class="headerlink" title="渲染器"></a>渲染器</h4><blockquote><p>通过前面的学习我知道，如果 Vue 项目采用的是模板语法来描述 UI，则在构建项目时首先会利用<strong>编译器</strong>将模板编译成render渲染函数，渲染函数的返回值为虚拟 DOM<br>那 Vue 是如何将一个虚拟 DOM 转换为一个真实的 DOM 并渲染到浏览器页面中呢 ？这就需要借助渲染器来实现。</p><ul><li>渲染器的作用就是把虚拟 DOM 渲染为真实 DOM</li></ul></blockquote><blockquote><p>代码示例</p></blockquote><ul><li>将以下 vnode 渲染成一个真实的 DOM</li></ul><pre><code>// 虚拟DOM中需要用到的事件处理函数function handler() &#123;  alert(&quot;我被点击了&quot;);&#125;// vnode为虚拟DOMconst vnode = &#123;  // html元素标签名  tag: &quot;div&quot;,  // 元素身上的属性  props: &#123;    id: &quot;box&quot;,  &#125;,  // 元素子节点  children: [    &#123;      tag: &quot;button&quot;,      props: &#123;        onClick: handler, // 绑定一个click事件，事件处理函数为handler      &#125;,      children: &quot;点我&quot;,    &#125;,  ],&#125;;</code></pre><blockquote><p>编写一个渲染器，将上面虚拟 DOM 转换为真实 DOM</p><ul><li>实现思路：</li></ul></blockquote><ul><li>创建 html 元素：把 <code>vnode.tag</code> 作为标签名来创建 DOM 元素</li><li>为元素添加属性和事件：遍历<code>vnode.props</code>对象，如果 key 以 <code>on</code> 字符开头，说明它是一个事件，事件名为on之后的字符，则从on之后截图字符并利用<code>toLowerCase</code>函数将事件名转换为小写，最终得到合法的事件名称。如：<code>onClick</code>变成<code>click</code>，最后调用<code>addEventListener</code>方法为元素添加事件监听。</li><li>创建子节点：首先判断 <code>children</code> 是否有内容，如果没有则不做任何处理，如果是一个字符串，则使用<code>createTextNode</code>方法创建一个文本节点，并将其加入到新创建的元素内。如果是一个数组，则遍历数组，然后递归<code>renderer</code>函数继续渲染子节点。</li><li>挂载：将<code>vnode.tag</code>作为标签名创建的元素挂载到真实的 DOM 容器<code>container</code>中</li></ul><blockquote><p>完整版代码</p></blockquote><pre><code>/** * 创建渲染器 renderer * vnode为需要渲染的虚拟DOM * container为一个真实DOM，渲染后的DOM需要挂载的容器 */function renderer(vnode, container) &#123;  // 获取tag属性，创建DOM元素  const el = document.createElement(vnode.tag);  // 遍历props，将属性与事件添加到元素身上  for (const key in vnode.props) &#123;    // 如果key为on开头，表示添加的事件    if (/^on/.test(key)) &#123;      // 将事件名，转换为小写，并去掉on      const eventName = key.substring(2).toLocaleLowerCase();      // 添加事件监听      el.addEventListener(eventName, vnode.props[key]);    &#125; else &#123;      el.setAttribute(key, vnode.props[key]);    &#125;  &#125;  // 判断是否有子节点,并判断是一个子节点还是多个，  // 如果是一个，则是一个字符串，如果是多个，则是一个数组  if (vnode.children &amp;&amp; typeof vnode.children === &quot;string&quot;) &#123;    // 创建文本类子节点    el.appendChild(document.createTextNode(vnode.children));  &#125; else if (Array.isArray(vnode.children)) &#123;    // 如果有多个子节点，则利用递归来处理    vnode.children.forEach((child) =&gt; &#123;      renderer(child, el);    &#125;);  &#125;  // 将元素添加到挂载容器中  container.appendChild(el);&#125;</code></pre><ul><li>我们上面只学习了渲染器如何在初始化时创建 DOM 节点，但渲染器的核心是 DOM 的更新，DOM 的更新涉及到 <code>diff</code> 算法与响应式，非常复杂，目前暂时不讲解。</li></ul><h4 id="渲染器渲染组件"><a href="#渲染器渲染组件" class="headerlink" title="渲染器渲染组件"></a>渲染器渲染组件</h4><blockquote><p>通过前面的学习我们知道</p><ul><li>组件最终编译成一个带有 <code>render</code> 函数的对象。<code>render</code> 函数返回值是一组 <code>vnode</code>，这里的 <code>vnode</code> 就是<code>template</code>模板中的内容被编译器编译成了虚拟 <code>DOM</code></li></ul></blockquote><ul><li>以下代码为编译后的组件实例</li></ul><pre><code>// A组件实例const A = &#123;  render() &#123;    //  h函数，用来生成vnode，    return h(&quot;div&quot;, &#123; onClick: handler &#125;, &quot;点我&quot;);  &#125;,  //......省略更多属性&#125;;</code></pre><ul><li><p>虚拟 DOM 是用一个纯 JavaScript 的对象来描述真实的 DOM 结构。其实虚拟 DOM 除了能描述真实 DOM 之外，还能够描述组件。只需要将 vnode 对象的 tag 属性定义为一个组件的定义就 ok。</p></li><li><p>以下为组件 A 的虚拟 DOM</p></li></ul><pre><code>const vnode=&#123;    tag：A  // A为组件实例&#125;</code></pre><ul><li>渲染器的作用就是把虚拟 DOM 渲染成一个真实 DOM。那渲染器在渲染时，他如何判断是要渲染一个 HTML 元素，还是渲染一个组件呢？</li><li>渲染器在渲染时会判断传入的第一个参数 vnode 的<code>tag</code>属性值是一个字符串还是一个对象<ul><li>如果是一个<strong>字符串</strong>则会渲染成 HTML 元素</li><li>如果是一个<strong>对象</strong>，则调用该对象的<code>render</code>方法得到<code>vnode</code>，然后递归调用用<code>renderer</code>渲染器来渲染 vnode。</li></ul></li></ul><blockquote><p>为了使渲染器能渲染组件，我们需要对renderer函数做修改，具体如下：</p></blockquote><pre><code>function renderer(vnode, container) &#123;  // 如果tag的值为字符串，则vnode描述的是标签元素  if (typeof vnode.tag === &quot;string&quot;) &#123;    // mountElement方法，就是原来的renderer方法    mountElement(vnode, container);    // 如果tag的值为对象，则vnode描述的是组件  &#125; else if (typeof vnode.tag === &quot;object&quot;) &#123;    mountComponent(vnode, container);  &#125;&#125;</code></pre><ul><li><code>mountElement</code>函数用来渲染标签元素，与前面提到的 <code>renderer</code>函数内容一致。</li></ul><pre><code>/** * 创建渲染器 * vnode为需要渲染的虚拟DOM * container为一个真实DOM，渲染后的DOM需要挂载的容器 */function mountElement(vnode, container) &#123;  // 获取tag属性，创建DOM元素  const el = document.createElement(vnode.tag);  // 遍历props，将属性与事件添加到元素身上  for (const key in vnode.props) &#123;    // 如果key为on开头，表示添加的事件    if (/^on/.test(key)) &#123;      // 将事件名，转换为小写，并去掉on      const eventName = key.substring(2).toLocaleLowerCase();      // 添加事件监听      window.addEventListener(eventName, vnode.props[key]);    &#125; else &#123;      el.setAttribute(key, vnode.props[key]);    &#125;  &#125;  // 判断是否有子节点,并判断是一个子节点还是多个，  // 如果是一个，则是一个字符串，如果是多个，则是一个数组  if (vnode.children &amp;&amp; typeof vnode.children === &quot;string&quot;) &#123;    // 创建文本类子节点    el.appendChild(document.createTextNode(vnode.children));  &#125; else if (Array.isArray(vnode.children)) &#123;    // 如果有多个子节点，则利用递归来处理    vnode.children.forEach((child) =&gt; &#123;      renderer(child, el);    &#125;);  &#125;  // 将元素添加到挂载容器中  container.appendChild(el);&#125;</code></pre><ul><li><code>mountComponent</code> 函数，用来渲染组件。内容如下：</li></ul><pre><code>function mountComponent(vnode, container) &#123;  // vnode.tag是组件对象，调用它的render函数得到组件要渲染的内容(vnode)  const subtree = vnode.tag.render();  mountElement(subtree, container);&#125;</code></pre><blockquote><p>测试代码</p></blockquote><pre><code>// A组件实例const A = &#123;  render() &#123;    return &#123;      tag: &quot;div&quot;,      props: &#123;        id: &quot;com&quot;,      &#125;,      children: [        &#123;          tag: &quot;p&quot;,          children: &quot;组件内容&quot;,        &#125;,      ],    &#125;;  &#125;,&#125;;// DOM元素的虚拟DOMconst vnode1 = &#123;  tag: &quot;div&quot;,  props: &#123;    class: &quot;box1&quot;,  &#125;,  children: &quot;div元素&quot;,&#125;;// 组件A的虚拟DOMconst vnode2 = &#123;  tag: A,&#125;;// 渲染 html元素，挂载到#app容器中renderer(vnode1, document.getElementById(&quot;app&quot;));// 渲染组件，最终将生成的html元素挂载到#app2容器中renderer(vnode2, document.getElementById(&quot;app2&quot;));</code></pre><ul><li>最终渲染后代码如下：</li></ul><pre><code>&lt;div id=&quot;app&quot;&gt;  &lt;div class=&quot;box1&quot;&gt;div元素&lt;/div&gt;&lt;/div&gt;&lt;div id=&quot;app2&quot;&gt;  &lt;div id=&quot;com&quot;&gt;    &lt;p&gt;组件内容&lt;/p&gt;  &lt;/div&gt;&lt;/div&gt;</code></pre><h4 id="Vue-渲染流程"><a href="#Vue-渲染流程" class="headerlink" title="Vue 渲染流程"></a>Vue 渲染流程</h4><blockquote><p>通过前面的学习，我们知道了 Vue 的渲染流程大致如下图：<br><img src="Vue%20渲染流程.png"></p></blockquote><blockquote><p>编译</p><ul><li>在项目构建阶段，会通过编译器将 Vue 模板编译为渲染函数，渲染函数用来返回虚拟 DOM 树</li></ul><p>挂载（渲染器）</p><ul><li>在运行项目时，渲染器会调用组件身上的渲染函数，遍历返回的虚拟 DOM 树，并基于它创建实际的 DOM 节点。当然内部还会做相关的响应式处理等更多优化。</li></ul><p>更新</p><ul><li>当某个响应式数据发生是变化时，会创建一个更新后的虚拟 DOM 树，然后渲染器遍历这棵新树，将它与旧树进行比较，然后将必要的更新应用到真实 DOM 上去。</li></ul></blockquote><h3 id="五、深入-h-函数"><a href="#五、深入-h-函数" class="headerlink" title="五、深入 h 函数"></a>五、深入 h 函数</h3><blockquote><p>前面我们对h函数的用法做了一定的了解，接下来我们针对没有讲到的一些内容做相关补充</p></blockquote><ul><li><code>attribute</code>和<code>property</code> 都可以用于 prop，Vue 会自动选择正确的方式来分配它</li></ul><pre><code>h(&quot;div&quot;, &#123; class: &quot;bar&quot;, innerHTML: &quot;hello&quot; &#125;);// 渲染后DOM : &lt;div class=&quot;bar&quot;&gt;hello&lt;/div&gt;</code></pre><ul><li>class 与 style 可以像在模板中一样，用数组或对象的形式书写</li></ul><pre><code>&lt;script&gt;  import &#123; h, ref &#125; from &quot;vue&quot;;  export default &#123;    setup() &#123;      const foo = ref(&quot;foo&quot;);      const bar = ref(true);      return () =&gt;        h(&quot;div&quot;, &#123; class: [foo.value, &#123; bar &#125;], style: &#123; color: &quot;red&quot; &#125; &#125;);    &#125;,  &#125;;&lt;/script&gt;&lt;!-- 渲染后DOM如下--&gt;&lt;div class=&quot;foo bar&quot; style=&quot;color: red;&quot;&gt;&lt;/div&gt;</code></pre><ul><li>给元素添加事件监听器以<code>onxxx</code>的形式书写</li></ul><pre><code>h(  &quot;div&quot;,  &#123;    onClick: () =&gt; &#123;      alert(&quot;点击了&quot;);    &#125;,  &#125;,  &quot;点我&quot;);// 渲染后DOM : &lt;div&gt;点我&lt;/div&gt;// 元素添加了点击事件，点击元素时，会弹出弹窗，显示&quot;点击了&quot;</code></pre><h4 id="vnodes-必须唯一"><a href="#vnodes-必须唯一" class="headerlink" title="vnodes 必须唯一"></a>vnodes 必须唯一</h4><blockquote><p>组件树中的 vnodes 必须是唯一的，以下为错误示范:</p></blockquote><pre><code>&lt;script&gt;  import &#123; h &#125; from &quot;vue&quot;;  const p = h(&quot;p&quot;, &quot;hi&quot;);  export default &#123;    setup() &#123;      return () =&gt; h(&quot;div&quot;, [p, p]);    &#125;,  &#125;;&lt;/script&gt;</code></pre><ul><li>如果 vnodes 是一样的，那后期操作 DOM 时，操作第一个 p 会影响到第二个 p</li><li>如果你真的非常想在页面上渲染多个重复的元素或者组件，你可以使用一个<strong>工厂函数</strong>来做这件事。</li></ul><blockquote><p>以下代码可以渲染出 10 个一样的 p 标签</p></blockquote><pre><code>&lt;script&gt;  import &#123; h &#125; from &quot;vue&quot;;  export default &#123;    setup() &#123;      return () =&gt;        h(          &quot;div&quot;,          Array.from(&#123; length: 20 &#125;).map(() =&gt; h(&quot;p&quot;, &quot;h1&quot;))        );    &#125;,  &#125;;&lt;/script&gt;</code></pre><h3 id="六、渲染函数案例"><a href="#六、渲染函数案例" class="headerlink" title="六、渲染函数案例"></a>六、渲染函数案例</h3><ol><li>v-on 事件</li></ol><ul><li>模板描述 UI</li></ul><pre><code>&lt;script setup&gt;  import &#123; ref &#125; from &quot;vue&quot;;  const count = ref(0);&lt;/script&gt;&lt;template&gt;  &lt;button @click=&quot;count++&quot;&gt;&#123;&#123; count &#125;&#125;&lt;/button&gt;&lt;/template&gt;</code></pre><ul><li>上面代码等价于下面代码</li></ul><pre><code>&lt;script&gt;  import &#123; h, ref &#125; from &quot;vue&quot;;  export default &#123;    setup() &#123;      const count = ref(0);      return () =&gt; h(&quot;button&quot;, &#123; onClick: () =&gt; count.value++ &#125;, count.value);    &#125;,  &#125;;&lt;/script&gt;</code></pre><ol start="2"><li>v-if 指令</li></ol><ul><li>模板描述 UI</li></ul><pre><code>&lt;script setup&gt;  import &#123; ref &#125; from &quot;vue&quot;;  const isShow = ref(true);&lt;/script&gt;&lt;template&gt;  &lt;!--模板语法--&gt;  &lt;div&gt;    &lt;button @click=&quot;isShow = !isShow&quot;&gt;切换&lt;/button&gt;    &lt;div v-if=&quot;isShow&quot;&gt;A内容&lt;/div&gt;    &lt;div v-else&gt;B内容&lt;/div&gt;  &lt;/div&gt;&lt;/template&gt;</code></pre><ul><li>上面代码等价于下面代码</li></ul><pre><code>&lt;script&gt;  import &#123; h, ref &#125; from &quot;vue&quot;;  export default &#123;    setup() &#123;      const isShow = ref(true);      // 渲染函数--------------      return () =&gt;        h(&quot;div&quot;, [          h(            &quot;button&quot;,            &#123; onClick: () =&gt; (isShow.value = !isShow.value) &#125;,            &quot;切换&quot;          ),          isShow.value ? h(&quot;div&quot;, &quot;A内容&quot;) : h(&quot;div&quot;, &quot; B内容&quot;),        ]);    &#125;,  &#125;;&lt;/script&gt;</code></pre><ol start="3"><li>v-for</li></ol><ul><li>模板描述 UI</li></ul><pre><code>&lt;script setup&gt;  import &#123; reactive &#125; from &quot;vue&quot;;  const list = reactive([1, 2, 3]);&lt;/script&gt;&lt;template&gt;  &lt;ul&gt;    &lt;li v-for=&quot;(item, index) in list&quot; :key=&quot;index&quot;&gt;&#123;&#123; item &#125;&#125;&lt;/li&gt;  &lt;/ul&gt;&lt;/template&gt;</code></pre><ul><li>上面代码等价于下面代码</li></ul><pre><code>&lt;script&gt;  import &#123; h, reactive &#125; from &quot;vue&quot;;  export default &#123;    setup() &#123;      const list = reactive([1, 2, 3]);      return () =&gt;        h(          &quot;ul&quot;,          list.map((item, index) =&gt; h(&quot;li&quot;, &#123; key: index &#125;, item))        );    &#125;,  &#125;;&lt;/script&gt;</code></pre><ol start="4"><li>事件修饰符<blockquote><p>对于 <code>.passive</code>、<code>.capture</code> 和 <code>.once</code> 事件修饰符，可以使用<strong>驼峰写法</strong>将他们拼接在事件名后面：</p></blockquote></li></ol><ul><li>模板描述 UI</li></ul><pre><code>&lt;script setup&gt;  import &#123; ref &#125; from &quot;vue&quot;;  const count = ref(1);&lt;/script&gt;&lt;template&gt;  &lt;!--只能点击一次，按下enter抬起键盘背景变红色--&gt;  &lt;button @click.once=&quot;count++&quot;&gt;&#123;&#123; count &#125;&#125;&lt;/button&gt;&lt;/template&gt;</code></pre><ul><li>上面代码等价于下面代码</li></ul><pre><code>&lt;script&gt;  import &#123; h, ref &#125; from &quot;vue&quot;;  export default &#123;    setup() &#123;      const count = ref(0);      return () =&gt;        h(          &quot;button&quot;,          &#123;            onClickOnce: () =&gt; count.value++,          &#125;,          count.value        );    &#125;,  &#125;;&lt;/script&gt;</code></pre><blockquote><p>对于事件和按键修饰符，可以使用<a href="https://cn.vuejs.org/api/render-function.html#withmodifiers"><code>withModifiers</code>函数</a>：</p></blockquote><ul><li>模板描述 UI</li></ul><pre><code>&lt;script setup&gt;  import &#123; h, ref &#125; from &quot;vue&quot;;  const count = ref(0);&lt;/script&gt;&lt;template&gt;  &lt;div @click.self=&quot;count++&quot;&gt;    &lt;span&gt;&#123;&#123; count &#125;&#125;&lt;/span&gt;  &lt;/div&gt;&lt;/template&gt;&lt;style scoped&gt;  div &#123;    width: 50px;    height: 50px;    padding: 50px;    background-color: skyblue;  &#125;  div span &#123;    display: block;    width: 50px;    height: 50px;    background-color: khaki;  &#125;&lt;/style&gt;</code></pre><ul><li>上面代码等价于下面代码</li></ul><pre><code>&lt;script&gt;  import &#123; h, ref, withModifiers &#125; from &quot;vue&quot;;  export default &#123;    setup() &#123;      const count = ref(0);      return () =&gt;        h(          &quot;div&quot;,          &#123;            onClick: withModifiers(() =&gt; count.value++, [&quot;self&quot;]),          &#125;,          [h(&quot;span&quot;, count.value)]        );    &#125;,  &#125;;&lt;/script&gt;&lt;style scoped&gt;  div &#123;    width: 50px;    height: 50px;    padding: 50px;    background-color: skyblue;  &#125;  div span &#123;    display: block;    width: 50px;    height: 50px;    background-color: khaki;  &#125;&lt;/style&gt;</code></pre><ol start="5"><li>组件</li></ol><ul><li>模板描述 UI</li></ul><pre><code>&lt;script setup&gt;  import &#123; shallowRef &#125; from &quot;vue&quot;;  import A from &quot;./components/A.vue&quot;;  import B from &quot;./components/B.vue&quot;;  const current = shallowRef(A);&lt;/script&gt;&lt;template&gt;  &lt;button @click=&quot;current = B&quot;&gt;切换到B&lt;/button&gt;  &lt;component :is=&quot;current&quot;&gt;&lt;/component&gt;&lt;/template&gt;</code></pre><ul><li>上面代码等价于下面代码</li></ul><pre><code>&lt;script&gt;  import &#123; h, shallowRef &#125; from &quot;vue&quot;;  import A from &quot;./components/A.vue&quot;;  import B from &quot;./components/B.vue&quot;;  export default &#123;    setup() &#123;      const current = shallowRef(A);      return () =&gt;        h(&quot;div&quot;, [          h(&quot;button&quot;, &#123; onClick: () =&gt; (current.value = B) &#125;, &quot;切换到B&quot;),          // 渲染组件的虚拟DOM          h(current.value),        ]);    &#125;,  &#125;;&lt;/script&gt;</code></pre><ol start="6"><li>内置组件<blockquote><p>诸如<code>&lt;KeepAlive&gt;</code>、<code>&lt;Transition&gt;</code>、<code>&lt;TransitionGroup&gt;</code>、<code>&lt;Teleport&gt;</code>和<code>&lt;Suspense&gt;</code>等内置组件在渲染函数中必须导入才能使用：</p></blockquote></li></ol><ul><li>模板描述 UI</li></ul><pre><code>&lt;script setup&gt;  import &#123; h, shallowRef &#125; from &quot;vue&quot;;  import A from &quot;./components/A.vue&quot;;  import B from &quot;./components/B.vue&quot;;  const current = shallowRef(A);&lt;/script&gt;&lt;template&gt;  &lt;button @click=&quot;current = B&quot;&gt;切换到B&lt;/button&gt;  &lt;button @click=&quot;current = A&quot;&gt;切换到A&lt;/button&gt;  &lt;KeepAlive&gt;    &lt;component :is=&quot;current&quot;&gt;&lt;/component&gt;  &lt;/KeepAlive&gt;&lt;/template&gt;</code></pre><ul><li>上面代码等价于下面代码</li></ul><pre><code>&lt;script&gt;  import &#123; h, shallowRef, resolveComponent, KeepAlive &#125; from &quot;vue&quot;;  import A from &quot;./components/A.vue&quot;;  import B from &quot;./components/B.vue&quot;;  export default &#123;    setup() &#123;      const current = shallowRef(A);      return () =&gt;        h(&quot;div&quot;, [          h(&quot;button&quot;, &#123; onClick: () =&gt; (current.value = B) &#125;, &quot;切换到B&quot;),          h(&quot;button&quot;, &#123; onClick: () =&gt; (current.value = A) &#125;, &quot;切换到A&quot;),          h(KeepAlive, [h(current.value)]),        ]);    &#125;,  &#125;;&lt;/script&gt;</code></pre><ol start="7"><li>渲染插槽<blockquote><p>在渲染函数中，插槽可以通过 <code>setup()</code> 的上下文来访问。</p><ul><li>每个<code>slots</code>对象中的插槽都是一个返回<code>vnodes</code>数组的函数：</li></ul></blockquote></li></ol><ul><li>模板描述 UI</li></ul><pre><code>&lt;template&gt;  &lt;div&gt;    &lt;!-- 具名插槽 --&gt;    &lt;slot name=&quot;header&quot;&gt;&lt;/slot&gt;    &lt;!-- 默认插槽 --&gt;    &lt;slot :info=&quot;&#123; a: 1&#125;&quot;&gt;&lt;/slot&gt;    &lt;!-- 具名插槽 --&gt;    &lt;slot name=&quot;footer&quot;&gt;&lt;/slot&gt;  &lt;/div&gt;&lt;/template&gt;</code></pre><ul><li>上面代码等价于下面代码</li></ul><pre><code>&lt;!--A组件--&gt;&lt;script&gt;  import &#123; h &#125; from &quot;vue&quot;;  export default &#123;    // slots用来接受传递的插槽内容，返回该插槽的vnodes数组    setup(props, &#123; slots &#125;) &#123;      return () =&gt;        h(&quot;div&quot;, [          // &lt;slot name=&quot;header&quot;&gt;&lt;/slot&gt;          slots.header(),          // &lt;slot info=&#123;a:1&#125;&gt;&lt;/slot&gt;          slots.default(&#123;            info: &#123; a: 1 &#125;,          &#125;),          // &lt;slot name=&quot;footer&quot;&gt;&lt;/slot&gt;          slots.footer(),        ]);    &#125;,  &#125;;&lt;/script&gt;</code></pre><ul><li>在组件中使用上面的 A 组件</li></ul><pre><code>&lt;script setup&gt;  import A from &quot;./components/A.vue&quot;;&lt;/script&gt;&lt;template&gt;  &lt;a&gt;    &lt;template #header&gt;      &lt;div class=&quot;header&quot;&gt;头部&lt;/div&gt;    &lt;/template&gt;    &lt;template #default=&quot;&#123; info &#125;&quot;&gt;      &lt;div class=&quot;main&quot;&gt;主体参数：&#123;&#123; info.a &#125;&#125;&lt;/div&gt;    &lt;/template&gt;    &lt;template #footer&gt;      &lt;div class=&quot;footer&quot;&gt;底部&lt;/div&gt;    &lt;/template&gt;  &lt;/a&gt;&lt;/template&gt;</code></pre><ol start="8"><li>传递插槽内容</li></ol><ul><li>在使用组件时，需要传递插槽内容，前面创建组件的 vnode 时讲过</li></ul><ol start="9"><li>组件 v-model<blockquote><p>当我们在使用 A 组件时，在组件上绑定<code>v-model</code>指令，如下：</p></blockquote></li></ol><pre><code>&lt;script setup&gt;  import &#123; ref &#125; from &quot;vue&quot;;  import A from &quot;./components/A.vue&quot;;  const isShow = ref(true);&lt;/script&gt;&lt;template&gt;  &lt;a v-model=&quot;isShow&quot;&gt;&lt;/a&gt;&lt;/template&gt;</code></pre><ul><li><p>在 A 组件中要接受传过来的 props 和 emits，并在需要的时候触发事件。</p></li><li><p>模板描述 UI</p></li></ul><pre><code>&lt;!--A组件--&gt;&lt;script&gt;  import &#123; h &#125; from &quot;vue&quot;;  export default &#123;    props: [&quot;modelValue&quot;],    emits: [&quot;update:modelValue&quot;],  &#125;;&lt;/script&gt;&lt;template&gt;  &lt;button @click=&quot;$emit(&#39;update:modelValue&#39;, !modelValue)&quot;&gt;切换&lt;/button&gt;  &lt;div class=&quot;box&quot; v-if=&quot;modelValue&quot;&gt;内容&lt;/div&gt;&lt;/template&gt;</code></pre><ul><li>上面代码等价于下面代码</li></ul><pre><code>&lt;script&gt;  import &#123; h &#125; from &quot;vue&quot;;  export default &#123;    props: [&quot;modelValue&quot;],    emits: [&quot;update:modelValue&quot;],    setup(props, &#123; emit &#125;) &#123;      return () =&gt;        h(&quot;div&quot;, [          h(            &quot;button&quot;,            &#123;              onClick: () =&gt; emit(&quot;update:modelValue&quot;, !props.modelValue),            &#125;,            &quot;切换&quot;          ),          props.modelValue ? h(&quot;div&quot;, &#123; class: &quot;box&quot; &#125;, &quot;内容&quot;) : &quot;&quot;,        ]);    &#125;,  &#125;;&lt;/script&gt;</code></pre><ol start="10"><li>自定义指令<blockquote><p>可以使用<a href="https://cn.vuejs.org/api/render-function.html#withdirectives"><code>withDirectives</code></a>将自定义指令应用于 vnode</p></blockquote></li></ol><ul><li>模板描述 UI</li></ul><pre><code>&lt;script setup&gt;  const vFocus = (el, binding) =&gt; &#123;    console.log(binding.value); // 指令值    console.log(binding.arg); // 指令参数    console.log(binding.modifiers); // 指令修饰符    el.focus();  &#125;;&lt;/script&gt;&lt;template&gt;  &lt;input type=&quot;text&quot; v-focus:color.enter=&quot;&#39;red&#39;&quot; value=&quot;123&quot; /&gt;&lt;/template&gt;</code></pre><ul><li>上面代码等价于下面代码</li></ul><pre><code>&lt;script&gt;  import &#123; h, withDirectives &#125; from &quot;vue&quot;;  export default &#123;    setup() &#123;      // 自定义指令      const focus = (el, binding) =&gt; &#123;        console.log(binding.value); // 指令值        console.log(binding.arg); // 指令参数        console.log(binding.modifiers); // 指令修饰符        el.focus();      &#125;;      return () =&gt;        withDirectives(          // html元素          h(&quot;input&quot;, &#123; type: &quot;text&quot;, value: &quot;123&quot; &#125;),          // 指令          [[focus, &quot;red&quot;, &quot;color&quot;, &#123; enter: true &#125;]]        );    &#125;,  &#125;;&lt;/script&gt;</code></pre><ol start="11"><li>模板引用<blockquote><p>在组合式 API 中，模板引用通过将 ref() 本身作为一个属性传递给 vnode 来创建</p></blockquote></li></ol><ul><li>模板描述 UI</li></ul><pre><code>&lt;script setup&gt;  import &#123; ref, onMounted &#125; from &quot;vue&quot;;  const box = ref(null);  onMounted(() =&gt; &#123;    console.log(box.value.innerText);  &#125;);&lt;/script&gt;&lt;template&gt;  &lt;div ref=&quot;box&quot;&gt;box内容&lt;/div&gt;&lt;/template&gt;</code></pre><ul><li>上面代码等价于下面代码</li></ul><pre><code>&lt;script&gt;  import &#123; ref, onMounted, h &#125; from &quot;vue&quot;;  export default &#123;    setup() &#123;      const box = ref(null);      onMounted(() =&gt; &#123;        console.log(box.value.innerText);      &#125;);      return () =&gt; h(&quot;div&quot;, &#123; ref: box &#125;, &quot;box内容&quot;);    &#125;,  &#125;;&lt;/script&gt;</code></pre><h3 id="七、函数式组件"><a href="#七、函数式组件" class="headerlink" title="七、函数式组件"></a>七、函数式组件</h3><blockquote><p>函数式组件是一种定义自身没有任何状态的组件的方式</p><p>它们很像纯函数：接收 <code>props</code>，返回 <code>vnodes</code>。函数式组件在渲染过程中不会创建组件实例（也就是说，没有 this），也不会触发常规的组件生命周期钩子。</p></blockquote><ul><li>函数式组件的写法与<code>setup()</code>函数类似，其返回值为<code>vnode</code>，</li></ul><pre><code>// 函数式组件 没有exposefunction MyComponent(props, &#123; slots, emit, attrs &#125;) &#123;  // ...  return h(&quot;div&quot;); // 返回vnode&#125;</code></pre><ul><li>大多数常规组件的配置选项在函数式组件中都不可用，除了 <code>props</code>和<code>emits</code>。我们可以给函数式组件添加对应的属性来声明它们：</li></ul><pre><code>MyComponent.props = [&quot;value&quot;];MyComponent.emits = [&quot;click&quot;];</code></pre><ol><li>函数式组件的基本用法<blockquote><p>函数式组件和普通函数一样被注册和使用</p></blockquote></li></ol><ul><li>在<code>&lt;script setup&gt;</code>中定义函数式组件，则在模板中可以直接使用</li></ul><pre><code>&lt;script setup&gt;  import &#123; h &#125; from &quot;vue&quot;;  function MyComponent(props, &#123; slots, emit, attrs &#125;) &#123;    // ...    return h(&quot;div&quot;, &#123; class: &quot;box&quot; &#125;, &quot;函数式组件&quot;);  &#125;&lt;/script&gt;&lt;template&gt;  &lt;MyComponent&gt;&lt;/MyComponent&gt;&lt;/template&gt;</code></pre><ul><li>在选项式 API 中，需要先注册，然后才能使用</li></ul><pre><code>&lt;script&gt;  import &#123; h &#125; from &quot;vue&quot;;  function MyComponent(props, &#123; slots, emit, attrs &#125;) &#123;    // ...    return h(&quot;div&quot;, &#123; class: &quot;box&quot; &#125;, &quot;函数式组件&quot;);  &#125;  export default &#123;    components: &#123;      MyComponent,    &#125;,  &#125;;&lt;/script&gt;&lt;template&gt;  &lt;MyComponent&gt;&lt;/MyComponent&gt;&lt;/template&gt;</code></pre><ol start="2"><li>函数式组件复杂应用<blockquote><p>利用函数式组件实现如下<code>MyComponent</code>组件</p></blockquote></li></ol><pre><code>&lt;script setup&gt;  defineProps([&quot;title&quot;]); // 声明接受的props  defineEmits([&quot;update&quot;]); // 声明接受的事件&lt;/script&gt;&lt;template&gt;  &lt;div class=&quot;box&quot;&gt;    &lt;!--update方法更新title标题内容--&gt;    &lt;button @click=&quot;$emit(&#39;update&#39;, &#39;xxxx函数式组件xxxx&#39;)&quot;&gt;更新&lt;/button&gt;    &lt;div&gt;&#123;&#123; title &#125;&#125;&lt;/div&gt;    &lt;slot&gt;&lt;/slot&gt;    &lt;slot name=&quot;main&quot;&gt;&lt;/slot&gt;  &lt;/div&gt;&lt;/template&gt;</code></pre><ul><li>在其它组件中使用MyComponent组件</li></ul><pre><code>&lt;script setup&gt;  import &#123; h, ref &#125; from &quot;vue&quot;;  //  import MyComponent from &quot;./components/MyComponent.js&quot;  import MyComponent from &quot;./components/MyComponent.vue&quot;;  const title = ref(&quot;函数式组件&quot;);  function update(value) &#123;    title.value = value;  &#125;&lt;/script&gt;&lt;template&gt;  &lt;MyComponent :title=&quot;title&quot; info=&quot;内容&quot; @update=&quot;update&quot;&gt;    &lt;template #default&gt;      &lt;div&gt;---默认插槽内容---&lt;/div&gt;    &lt;/template&gt;    &lt;template #main&gt;      &lt;div&gt;---具名插槽main内容---&lt;/div&gt;    &lt;/template&gt;  &lt;/MyComponent&gt;&lt;/template&gt;</code></pre><ul><li>上面代码等价下面的 函数式组件</li></ul><pre><code>import &#123; h &#125; from &quot;vue&quot;;// props属性  slots 插槽   emit 触发器   attrs 透传属性export default function MyComponent(props, &#123; slots, emit, attrs &#125;) &#123;  // 返回虚拟DOM  return h(&quot;div&quot;, &#123; class: &quot;box&quot; &#125;, [    h(      &quot;button&quot;,      &#123; onClick: () =&gt; emit(&quot;update&quot;, &quot;xxxx函数式组件xxxx&quot;) &#125;,      &quot;更新&quot;    ),    h(&quot;div&quot;, props.title),    slots.default(), // 默认插槽    slots.main(), // 具名插槽  ]);&#125;// 声明接受的propsMyComponent.props = [&quot;title&quot;];// 声明接受的事件MyComponent.emit = [&quot;update&quot;];</code></pre><blockquote><p>Vue 为我们提供了两个内置组件<code>&lt;Transition&gt;</code>和<code>&lt;TransitionGroup&gt;</code>，他们可以帮助我们制作基于状态变化的过渡和动画效果。</p><ul><li><code>&lt;Transition&gt;</code>会在一个元素或组件进入和离开 DOM 时应用动画</li><li><code>&lt;TransitionGroup&gt;</code>会在一个<code>v-for</code>列表中的元素或组件被插入，移动，或移除时应用动画</li></ul><p>除了以上两个组件，我们也可以通过其他技术手段来应用动画，比如切换 <code>CSS class</code> 或用状态绑定样式来驱动动画</p></blockquote><h3 id="八、内置组件"><a href="#八、内置组件" class="headerlink" title="八、&lt;Transition&gt;内置组件"></a>八、<code>&lt;Transition&gt;</code>内置组件</h3><h4 id="组件的基本用法"><a href="#组件的基本用法" class="headerlink" title="组件的基本用法"></a><Transition>组件的基本用法</h4><ul><li><code>&lt;Transition&gt;</code> 是一个内置组件，这意味着它在任意别的组件中都可以被使用，无需注册</li><li>将需要使现过渡和动画的单个根元素或单个单根组件作为<code>&lt;Transition&gt;</code>组件的默认插槽内容传入<ul><li><code>&lt;Transition&gt;</code>中只能有一个根元素，多个根元素会报错，所以传入的组件也只能是单个单根组件</li></ul></li></ul><blockquote><p>进入或离开的动画由以下条件之一触发</p></blockquote><ul><li>由 v-if 所触发的切换</li><li>由 v-show 所触发的切换</li><li>由特殊元素 <code>&lt;component&gt;</code> 切换的动态组件</li><li>改变特殊的 key 属性</li></ul><blockquote><p>实现淡入淡出过渡动画效果</p></blockquote><pre><code>&lt;script setup&gt;  import &#123; ref &#125; from &quot;vue&quot;;  const isShow = ref(true);&lt;/script&gt;&lt;template&gt;  &lt;button @click=&quot;isShow = !isShow&quot;&gt;淡出与淡入&lt;/button&gt;  &lt;!--Transition内置组件--&gt;  &lt;Transition&gt;    &lt;div class=&quot;box&quot; v-show=&quot;isShow&quot;&gt;&lt;/div&gt;  &lt;/Transition&gt;&lt;/template&gt;&lt;style&gt;  .box &#123;    width: 100px;    height: 100px;    background-color: skyblue;  &#125;&lt;/style&gt;</code></pre><ul><li>以上代码还不能使现元素在被插入或移除时有过渡与动画效果，还必须提供配套的 CSS 样式，如下：</li></ul><pre><code>/* 元素插入动画样式 */.v-enter-from &#123;  opacity: 0;&#125;.v-enter-active &#123;  transition: opacity 2s ease;&#125;.v-enter-to &#123;  opacity: 1;&#125;/* 元素移除动画样式 */.v-leave-from &#123;  opacity: 1;&#125;.v-leave-active &#123;  transition: opacity 2s ease;&#125;.v-leave-to &#123;  opacity: 0;&#125;</code></pre><h4 id="CSS-过渡-Class"><a href="#CSS-过渡-Class" class="headerlink" title="CSS 过渡 Class"></a>CSS 过渡 Class</h4><blockquote><p>在利用<code>&lt;Transition&gt;</code>内置组件实现过渡与动画时，会自动为元素在不同的时刻添加和移除对应的 <code>CSS class</code></p></blockquote><ul><li>如下图：<img src="Transition组件的class.png"></li></ul><blockquote><p>Enter 入场动画 （插入元素时动画）</p></blockquote><ul><li><code>v-enter-from</code>：进入动画的起始状态。在元素插入之前添加，在元素插入完成后的下一帧移除。</li><li><code>v-enter-active</code>：进入动画的生效状态。应用于整个进入动画阶段。在元素被插入之前添加，在过渡或动画完成之后移除。这个 class 可以被用来定义进入动画的持续时间、延迟与速度曲线类型。</li><li><code>v-enter-to</code>：进入动画的结束状态。在元素插入完成后的下一帧被添加 (也就是 <code>v-enter-from</code> 被移除的同时)，在过渡或动画完成之后移除。</li></ul><blockquote><p>Leave 出场动画（移除元素时动画）</p></blockquote><ul><li><code>v-leave-from</code>：离开动画的起始状态。在离开过渡效果被触发时立即添加，在一帧后被移除。</li><li><code>v-leave-active</code>：离开动画的生效状态。应用于整个离开动画阶段。在离开过渡效果被触发时立即添加，在过渡或动画完成之后移除。这个 class 可以被用来定义离开动画的持续时间、延迟与速度曲线类型。</li><li><code>v-leave-to</code>：离开动画的结束状态。在一个离开动画被触发后的下一帧被添加 (也就是 <code>v-leave-from</code> 被移除的同时)，在过渡或动画完成之后移除。</li></ul><blockquote><p>分析前面提到的淡出与淡入的效果的整个 Class 添加与移除的过程</p></blockquote><ul><li>点击按扭，方块淡出隐藏，Class 添加和移除过程如下：</li></ul><pre><code>&lt;!-- 1、淡出动画生效前 添加 v-leave-from 和 v-leave-active --&gt;&lt;div class=&quot;box v-leave-from v-leave-active&quot;&gt;&lt;/div&gt;&lt;!--  2、添加 v-leave-to 的同时（稍后）移除 v-leave-from 触发淡出动画- --&gt;&lt;div class=&quot;box v-leave-active  v-leave-to&quot;&gt;&lt;/div&gt;&lt;!-- 3、淡出动画结束后，移出 v-leave-active 和 v-leave-to --&gt;&lt;div class=&quot;box&quot;&gt;&lt;/div&gt;</code></pre><ul><li>点击按扭，方块淡出显示，Class 添加移除过程如下：</li></ul><pre><code>&lt;!-- 1、在淡入动画生效前 class --&gt;&lt;div class=&quot;box v-enter-from v-enter-active&quot;&gt;&lt;/div&gt;&lt;!-- 2、移除v-enter-from 添加v-enter-to 触发淡入动画--&gt;&lt;div class=&quot;box v-enter-active v-enter-to &quot;&gt;&lt;/div&gt;&lt;!--3、 动画结束后，移除v-enter-active 和 v-enter-to--&gt;&lt;div class=&quot;box&quot;&gt;&lt;/div&gt;</code></pre><blockquote><p>优化前面 “淡入与淡出” 动画的 CSS 样式</p><ul><li>其实不难发现，上面（一般情况下）过渡动画的</li></ul></blockquote><ul><li><code>v-enter-to</code>与<code>v-leave-from</code>中 CSS 样式是一样的，因为入场动画的结束状态就是出场动画的开始状态</li><li><code>v-enter-from</code>与<code>v-leave-to</code>中 CSS 样式是一样的，因为出场动画的结束状态就是入场动画的开始状态</li><li><code>v-enter-active</code>与<code>v-leave-active</code>中 CSS 样式是一样的，大多情况下，出场与入场动画执行相反效果，其动画代码是一样的。</li></ul><blockquote><ul><li>优化后的 CSS 样式</li></ul></blockquote><pre><code>/* 动画起始与离开动画的结束状态 */.v-enter-from,.v-leave-to &#123;  opacity: 0;&#125;/* 动画生效状态 */.v-enter-active,.v-leave-active &#123;  transition: opacity 2s ease;&#125;/* 动画结束与离开动画的起始状态*//* 以下代码写可以省略，因为元素没有调置opacity属性时，默认值为1.v-enter-to,.v-leave-from &#123;  opacity: 1;&#125;*/</code></pre><h4 id="元素初次渲染时过渡-（appear-属性）"><a href="#元素初次渲染时过渡-（appear-属性）" class="headerlink" title="元素初次渲染时过渡 （appear 属性）"></a>元素初次渲染时过渡 （appear 属性）</h4><blockquote><p>前面讲到的 “淡入与淡出” 动画，在页面初次渲染时并没有呈现一个淡入的动画效果，如果想在元素初次渲染时应用一个过渡效果，你可以为他添加<code>appear</code>属性。</p></blockquote><pre><code>&lt;Transition appear&gt; ... &lt;/Transition&gt;</code></pre><h4 id="元素间过渡"><a href="#元素间过渡" class="headerlink" title="元素间过渡"></a>元素间过渡</h4><blockquote><p>接下来，我们实现如下图所示的多个元素来回切换的过渡动画效果<br>&lt;img src&#x3D;”元素间过度—transiion组件.gif”</p></blockquote><ul><li>几个元素当中不同时刻只能有一个元素显示，所以我们可以利用<code>v-if</code>、<code>v-else</code>、<code>v-else-if</code>来确保每次<code>&lt;Transition&gt;</code>组件内只能有一个根元素或一个单根组件，如下：</li></ul><pre><code>&lt;Transition&gt;  &lt;div class=&quot;item&quot; v-if=&quot;index === 1&quot;&gt;1&lt;/div&gt;  &lt;div class=&quot;item&quot; v-else-if=&quot;index === 2&quot;&gt;2&lt;/div&gt;  &lt;div class=&quot;item&quot; v-else-if=&quot;index === 3&quot;&gt;3&lt;/div&gt;&lt;/Transition&gt;&lt;!-- 以下写法是错的 --&gt;&lt;Transition&gt;  &lt;div class=&quot;item&quot; v-if=&quot;index === 1&quot;&gt;1&lt;/div&gt;  &lt;div class=&quot;item&quot; v-if=&quot;index === 2&quot;&gt;2&lt;/div&gt;  &lt;div class=&quot;item&quot; v-if=&quot;index === 3&quot;&gt;3&lt;/div&gt;&lt;/Transition&gt;</code></pre><ul><li>每个元素在切换时的入场与出场动画都是一样的，所以我们只需为他们指定一套入场与出场的 CSS 样式即可</li></ul><pre><code>/* 入场动画开始前状态 */.v-enter-from &#123;  opacity: 0;  transform: translateX(100px);&#125;/* 入场与出场动画生效状态*/.v-enter-active,.v-leave-active &#123;  transition: all 1s ease;&#125;/* 出场动来结束后状态*/.v-leave-to &#123;  transform: translateX(-100px);  opacity: 0;&#125;/* 以下代码可省略 入场动画结束入出场动画开始状态一样，只需要采用默认值即可*//* .v-enter-to,.v-leave-from &#123;    transform: translateX(0);    opacity: 1;&#125;*/</code></pre><h4 id="过渡模式-mode-”out-in”"><a href="#过渡模式-mode-”out-in”" class="headerlink" title="过渡模式 mode&#x3D;”out-in”"></a>过渡模式 mode&#x3D;”out-in”</h4><blockquote><p>我们观察上面代码实现的多个元素切换的过渡动画（如下图），可以看到入场和出场的元素都是<strong>同时开始动画</strong>的。</p><ul><li>因此我们需要将它们设为<code>positions: absolute</code>以避免二者同时存在时出现的布局问题</li></ul><p>但在有些情况下，我可能希望在出场动画结束后，再开始执行入场动画。我们可以通过向<code>&lt;Transition&gt;</code>传入一个<code>mode </code>属性来实现这个行为。</p><ul><li><code>mode=&quot;out-in&quot;</code>表示，先执行出场（离开）动画，出场动画结束后，再执行入场动画</li><li><code>mode=&quot;in-out&quot;</code>表示，先执行入场（进入）动画，入场动画结束后，再执行出场动画 （基本不用）</li></ul></blockquote><pre><code>&lt;Transition mode=&quot;out-in&quot;&gt; ... &lt;/Transition&gt;</code></pre><h4 id="组件间过渡"><a href="#组件间过渡" class="headerlink" title="组件间过渡"></a><component>组件间过渡</h4><blockquote><p>我们前面提到过<code>&lt;Transition&gt;</code>也可以作用于由<code>&lt;component&gt;</code>切换的动态组件</p></blockquote><pre><code>&lt;Transition mode=&quot;out-in&quot;&gt;  &lt;component :is=&quot;activeComponent&quot;&gt;&lt;/component&gt;&lt;/Transition&gt;</code></pre><blockquote><p>接下来，我们实现如下多组件间切换的过渡效果<br><img src="多组件间切换.gif"></p></blockquote><ul><li>完整代码</li></ul><pre><code>&lt;!-- App根组件 --&gt;&lt;script setup&gt;  import &#123; shallowRef &#125; from &quot;vue&quot;;  import ComA from &quot;./components/ComA.vue&quot;;  import ComB from &quot;./components/ComB.vue&quot;;  const activeComponent = shallowRef(ComA); // 浅层响应性能更高&lt;/script&gt;&lt;template&gt;  &lt;!--单选按扭--&gt;  &lt;input type=&quot;radio&quot; v-model=&quot;activeComponent&quot; :value=&quot;ComA&quot; /&gt; comA  &lt;input type=&quot;radio&quot; v-model=&quot;activeComponent&quot; :value=&quot;ComB&quot; /&gt; comB  &lt;!--多组件间过渡--&gt;  &lt;Transition mode=&quot;out-in&quot;&gt;    &lt;component :is=&quot;activeComponent&quot; /&gt;  &lt;/Transition&gt;&lt;/template&gt;&lt;style&gt;  .v-enter-from,  .v-leave-to &#123;    opacity: 0;  &#125;  .v-enter-active,  .v-leave-active &#123;    transition: opacity 0.5s ease;  &#125;  /* .v-enter-to,    .v-leave-from &#123;    opacity: 1;    &#125; */&lt;/style&gt;&lt;!-- ComA 组件 --&gt;&lt;template&gt;  &lt;div class=&quot;com-a&quot;&gt;this is Component A&lt;/div&gt;&lt;/template&gt;&lt;!-- ComB 组件 --&gt;&lt;template&gt;  &lt;div class=&quot;com-b&quot;&gt;this is Component A&lt;/div&gt;&lt;/template&gt;</code></pre><h4 id="为过渡效果命名"><a href="#为过渡效果命名" class="headerlink" title="为过渡效果命名"></a>为过渡效果命名</h4><blockquote><p>当一个页面同时有多个不同的过渡动画时，则需要为不同的过渡动画取不同的过渡效果名。</p><ul><li>我们可以给<code>&lt;Transition&gt;</code>组件传一个<code>name</code>属性来声明一个过渡效果名</li></ul></blockquote><pre><code>&lt;Transition name=&quot;fade&quot;&gt; ... &lt;/Transition&gt;</code></pre><ul><li>当<code>&lt;Transition&gt;</code>有了<code>name</code>属性后，CSS 过渡 Class 的名字不再是以<code>v-</code>作为前缀，而是要以<code>name</code>属性的值作为前缀。</li></ul><blockquote><p>如果<code>name=fade</code>则对应的过渡<code>Class</code>名为<code>fade-enter-from</code>、<code>fade-enter-active</code>、<code>fade-enter-to</code>、<code>fade-leave-from</code>、<code>fade-leave-active</code>、<code>fade-leave-to</code></p></blockquote><ul><li>针对前面实现的 “淡出与淡入” 动画，我们给<code>&lt;Transition&gt;</code>组件添加<code>name=&quot;fade&quot;</code>属性，完整版代码如下：</li></ul><pre><code>&lt;script setup&gt;  import &#123; ref &#125; from &quot;vue&quot;;  const isShow = ref(true);&lt;/script&gt;&lt;template&gt;  &lt;button @click=&quot;isShow = !isShow&quot;&gt;淡出与淡入&lt;/button&gt;  &lt;Transition appear name=&quot;fade&quot;&gt;    &lt;div class=&quot;box&quot; v-show=&quot;isShow&quot;&gt;&lt;/div&gt;  &lt;/Transition&gt;&lt;/template&gt;&lt;style&gt;  .box &#123;    width: 100px;    height: 100px;    background-color: skyblue;  &#125;  /* 动画起始与离开动画的结束状态 */  .fade-enter-from,  .fade-leave-to &#123;    opacity: 0;  &#125;  /* 动画生效状态 */  .fade-enter-active,  .fade-leave-active &#123;    transition: opacity 2s ease;  &#125;&lt;/style&gt;</code></pre><h4 id="深层级过渡与显式指定过渡时长"><a href="#深层级过渡与显式指定过渡时长" class="headerlink" title="深层级过渡与显式指定过渡时长"></a>深层级过渡与显式指定过渡时长</h4><blockquote><p>通过前面的学习，我们知道过渡<code>class</code>仅能应用在<code>&lt;Transition&gt;</code>组件的根元素上，如果我们想使根元素的后代元素有过渡和动画效果</p></blockquote><ol><li>简单效果<blockquote><ul><li>如下图所示效果：<img src="深层级过渡与显式指定过渡时长.gif"></li></ul></blockquote></li></ol><ul><li>我们可以通过 CSS 后代选择器，在后代元素上触发过渡效果。</li></ul><blockquote><p>代码示例</p></blockquote><ul><li>以下代码，我们期望通过 CSS 后代选择器，使动画效果最终触发在<code>.box</code>元素上</li></ul><pre><code>&lt;script setup&gt;  import &#123; ref &#125; from &quot;vue&quot;;  const isShow = ref(true);&lt;/script&gt;&lt;template&gt;  &lt;div&gt;&lt;button @click=&quot;isShow = !isShow&quot;&gt;内层元素动画&lt;/button&gt;&lt;/div&gt;  &lt;!-- 自定义过渡Class名 --&gt;  &lt;Transition name=&quot;fade&quot;&gt;    &lt;div class=&quot;container&quot; v-if=&quot;isShow&quot;&gt;      &lt;div class=&quot;box&quot;&gt;&lt;/div&gt;    &lt;/div&gt;  &lt;/Transition&gt;&lt;/template&gt;&lt;style scoped&gt;  .container &#123;    width: 400px;    height: 200px;    background-color: khaki;    display: inline-block;  &#125;  .box &#123;    width: 200px;    height: 100px;    margin: 50px auto;    background-color: skyblue;  &#125;  /* 动画起始与离开动画的结束状态 */  .fade-enter-from .box,  .fade-leave-to .box &#123;    opacity: 0;  &#125;  /* 动画生效状态 */  .fade-enter-active .box,  .fade-leave-active .box &#123;    transition: opacity 2s ease;  &#125;&lt;/style&gt;</code></pre><ul><li>但实际上，以上代码并不没有实现我们想要的效果，不管是<code>.container</code>还是<code>.box</code>元素都没有动画效果。</li></ul><blockquote><p>没有过渡效果原因如下</p></blockquote><ul><li><code>&lt;Transition&gt;</code>组件之所以能清楚的知道<code>transition</code>动画在何时结束，是因为其内部监听了根元素上的<code>transitionend</code>事件。</li><li>通过<code>transitionend</code>事件 Vue 就可以知道动画何时结束。</li><li>在嵌套的过渡动画中，根元素很多时候本身并没有任何的过渡动画，所以会立即显示或隐藏，以致于看不到内部元素的过渡效果。</li></ul><blockquote><p>如何才能看到过渡效果</p></blockquote><ul><li>要实现以上效果，我们可以向<code>&lt;Transition&gt;</code>组件传入<code>duration</code>属性来显示指定根元素过渡的持续时间（以毫秒为单为）。然后就会按以下效果来完成动画。</li><li>在入场动画时，先显示根元素，然后再执行内部元素的动画</li><li>在出场动画时，需要先执行内部元素的动画，在动画结束后，再隐藏根元素</li></ul><pre><code>&lt;!-- 入场与出场动画持续是一样，均为2s--&gt;&lt;Transition name=&quot;fade&quot; duration=&quot;2000&quot;&gt;&lt;/Transition&gt;&lt;!-- 入场动画持续时间2s ，出场动画持续时间 3s --&gt;&lt;Transition :duration=&quot;&#123; enter: 2000, leave: 3000 &#125;&quot;&gt;...&lt;/Transition&gt;</code></pre><ul><li>温馨提示：持续时间不应该小于内部元素动画从开始到结束所需要的时间</li></ul><blockquote><p>优化上面案例代码</p></blockquote><ul><li>给以上代码的<code>&lt;Transition&gt;</code>组件添加<code>duration=&quot;2000&quot;</code>后，就能看到前面<code>gif</code>图片显示的动画效果了</li></ul><pre><code>&lt;Transition name=&quot;fade&quot; duration=&quot;2250&quot;&gt;&lt;/Transition&gt;</code></pre><p>为了使看到的动画更自然，可以添加以下代码，让<code>.box</code>元素的入场动画延迟<code>.25s</code>秒执行。</p><pre><code>.fade-enter-active .box &#123;  transition-delay: 0.25s;&#125;</code></pre><ul><li>以下是最终完整版代码：</li></ul><pre><code>&lt;script setup&gt;  import &#123; ref &#125; from &quot;vue&quot;;  const isShow = ref(true);&lt;/script&gt;&lt;template&gt;  &lt;div&gt;&lt;button @click=&quot;isShow = !isShow&quot;&gt;内层元素动画&lt;/button&gt;&lt;/div&gt;  &lt;!-- 自定义过渡Class名 --&gt;  &lt;Transition name=&quot;fade&quot; appear duration=&quot;2250&quot;&gt;    &lt;div class=&quot;container&quot; v-if=&quot;isShow&quot;&gt;      &lt;div class=&quot;box&quot;&gt;&lt;/div&gt;    &lt;/div&gt;  &lt;/Transition&gt;&lt;/template&gt;&lt;style scoped&gt;  .container &#123;    width: 400px;    height: 200px;    background-color: khaki;    display: inline-block;  &#125;  .box &#123;    width: 200px;    height: 100px;    margin: 50px auto;    background-color: skyblue;  &#125;  /* 动画起始与离开动画的结束状态 */  .fade-enter-from .box,  .fade-leave-to .box &#123;    opacity: 0;  &#125;  /* 动画生效状态 */  .fade-enter-active .box,  .fade-leave-active .box &#123;    transition: opacity 2s ease;  &#125;  .fade-enter-active .box &#123;    transition-delay: 0.25s;  &#125;&lt;/style&gt;</code></pre><ol start="2"><li>复杂动画应用<blockquote><p>我们在上面代码的基础上，做相关优化，最终实现如下动画效果</p></blockquote></li></ol><ul><li>入场动画：黄色盒子执行淡入动画，淡入动画结束后，内部的蓝色盒子再执行淡入动画</li><li>出场动画：蓝色盒子先执行淡出动画，淡出动画结束后，黄色盒子再执行淡出动画。</li></ul><img src="深层级过渡与显式指定过渡时长-复杂动画.gif"><blockquote><p>实现原理</p></blockquote><ul><li>假设黄色盒子与蓝色盒子的动画执行时间都<code>1s</code>，则我们可以将<code>duration = 2000</code></li><li>入场动画：给黄色盒子和蓝色盒子添加入场动画样式，同时控制黄色盒子的动画在延迟 <code>1s</code> 之后开始执行</li></ul><pre><code>/* 黄色盒子入场动画样式 */.fade-enter-from &#123;  opacity: 0;&#125;.fade-enter-active &#123;  transition: opacity 1s ease;&#125;/* 蓝色盒子入场动画样式*//* 动画起始与离开动画的结束状态 */.fade-enter-from .box &#123;  opacity: 0;&#125;.fade-enter-active .box &#123;  transition: opacity 1s ease;  transition-delay: 1s; /* 延迟 1s后开始动画 */&#125;</code></pre><ul><li>出场动画：给黄色盒子和蓝色盒子添加了出场动画样式，同时控制黄色盒子的动画在延迟 1s 之后开始执行</li></ul><pre><code>/* 黄色盒子出场动画样式 */.fade-leave-to &#123;  opacity: 0;&#125;.fade-leave-active &#123;  transition: opacity 1s ease;  transition-delay: 1s; /* 延迟 1s后开始动画 */&#125;/* 蓝色盒子出场动画样式 */.fade-leave-to .box &#123;  opacity: 0;&#125;.fade-leave-active .box &#123;  transition: opacity 1s ease;&#125;</code></pre><ul><li>完整版代码</li></ul><pre><code>&lt;script setup&gt;  import &#123; ref &#125; from &quot;vue&quot;;  const isShow = ref(true);&lt;/script&gt;&lt;template&gt;  &lt;div&gt;&lt;button @click=&quot;isShow = !isShow&quot;&gt;内层元素动画&lt;/button&gt;&lt;/div&gt;  &lt;!-- 自定义过渡Class名 --&gt;  &lt;Transition name=&quot;fade&quot; duration=&quot;2000&quot; appear&gt;    &lt;div class=&quot;container&quot; v-if=&quot;isShow&quot;&gt;      &lt;div class=&quot;box&quot;&gt;&lt;/div&gt;    &lt;/div&gt;  &lt;/Transition&gt;&lt;/template&gt;&lt;style scoped&gt;  button &#123;    margin: 50px;  &#125;  .container &#123;    width: 400px;    height: 200px;    background-color: khaki;    display: inline-block;    margin-left: 50px;  &#125;  .box &#123;    width: 200px;    height: 100px;    margin: 50px auto;    background-color: skyblue;  &#125;  /* 动画起始与离开动画的结束状态 */  .fade-enter-from,  .fade-leave-to,  .fade-enter-from .box,  .fade-leave-to .box &#123;    opacity: 0;  &#125;  /* 黄色盒子入场动画 */  .fade-enter-active &#123;    transition: opacity 1s ease;  &#125;  /* 黄色盒子出场动画 */  .fade-leave-active &#123;    transition: opacity 1s ease;    transition-delay: 1s;  &#125;  /* 动画生效状态 */  .fade-enter-active .box &#123;    transition: opacity 1s ease;    transition-delay: 1s;  &#125;  .fade-leave-active .box &#123;    transition: opacity 1s ease;  &#125;&lt;/style&gt;</code></pre><h4 id="CSS-的-animation-动画"><a href="#CSS-的-animation-动画" class="headerlink" title="CSS 的 animation 动画"></a>CSS 的 animation 动画</h4><blockquote><p>在<code>&lt;Transition&gt;</code>组件中，实现原生 CSS 的<code>animation</code>动画与原生 CSS 的<code>transition</code>动画的应用方式基本是相同的，只有一点不同，那就是<code>*-enter-from</code>不是在元素插入后立即移除，而是在一个<code>animationend</code>事件触发时被移除。</p><ul><li>对于大多数 CSS 的<code>animation</code>动画，我们只需要在<code>*-enter-active</code>和<code>*-leave-activeClass</code>下声明它们</li></ul></blockquote><blockquote><p>我们来看下面这样一个元素自动缩放的动画效果，如何来实现<br><img src="animation动画.gif"></p></blockquote><blockquote><p>我们先来分析下上面的效果</p></blockquote><ul><li>出场（离场）：元素从显示到隐藏，先是原大小，再是放大，最后缩小一直到看不见</li><li>入场：元素从隐藏到显示，先是从看不见一直放大，然后再缩小到原大小<ul><li>所以元素从隐藏到显示的<code>animation</code>动画定义如下，当从显示到隐藏时，只需要反着来执行该动画就好</li></ul></li></ul><pre><code>/* 定义动画  从隐藏到放大再缩放到原大小 */@keyframes scale &#123;  0% &#123;    transform: scale(0); /* 看不见*/  &#125;  50% &#123;    transform: scale(1.25);  &#125;  100% &#123;    transform: scale(1);  &#125;&#125;</code></pre><ul><li>完整版代码</li></ul><pre><code>&lt;script setup&gt;  import &#123; ref &#125; from &quot;vue&quot;;  const isShow = ref(true);&lt;/script&gt;&lt;template&gt;  &lt;button @click=&quot;isShow = !isShow&quot;&gt;缩放动画&lt;/button&gt;  &lt;Transition name=&quot;scale&quot; appear&gt;    &lt;div class=&quot;text&quot; v-if=&quot;isShow&quot;&gt;我是一段测试animation 缩放动画的文字&lt;/div&gt;  &lt;/Transition&gt;&lt;/template&gt;&lt;style scoped&gt;  .text &#123;    text-align: center;  &#125;  /* 入场动画*/  .scale-enter-active &#123;    /* 动画名  动画时间  时间函数   延迟时间  执行次数   执行方向（reverse 为反向播放） 动画不播放时模式  */    /* animation: name duration timing-function delay iteration-count direction fill-mode; */    animation: scale 1s ease;  &#125;  /* 出场动画 */  .scale-leave-active &#123;    /* 与入场动画相反的方式执行 */    animation: scale 1s ease reverse;  &#125;  /* 定义动画 */  @keyframes scale &#123;    0% &#123;      transform: scale(0);    &#125;    50% &#123;      transform: scale(1.25);    &#125;    100% &#123;      transform: scale(1);    &#125;  &#125;&lt;/style&gt;</code></pre><h4 id="自定义过渡-class"><a href="#自定义过渡-class" class="headerlink" title="自定义过渡 class"></a>自定义过渡 class</h4><blockquote><p>你也可以向 <code>&lt;Transition&gt;</code> 传递以下的 <code>props</code> 来指定自定义的过渡 <code>class</code>：</p></blockquote><pre><code>enter-from-classenter-active-classenter-to-classleave-from-classleave-active-classleave-to-class</code></pre><ul><li>你传入的这些 class 会覆盖相应阶段的默认 class 名。如下：</li></ul><pre><code>&lt;Transition enter-active-class=&quot;bounce-in a&quot; leave-active-class=&quot;bounce-out&quot;&gt;  &lt;div class=&quot;text&quot; v-if=&quot;isShow&quot;&gt;我是一段测试animation 缩放动画的文字&lt;/div&gt;&lt;/Transition&gt;</code></pre><ul><li>在没有自定义过渡 class 时，入场动画生效状态添加的 class 是 <code>v-enter-active</code>，自定义了 <code>enter-active-class</code> 后，添加的class是<code>bounce-in</code> 和 <code>a</code></li><li>在没有自定义过渡 class 时，出场动画生效状态添加的 class 是 <code>v-leave-active</code> ，自定义了<code>leave-active-class</code>后，添加的 class 是 <code>bounce-out</code></li><li>用上面代码替换前面 “缩放动画” 对应的<code>&lt;Transition&gt;</code>标签内容，则对应的 CSS 需要写成如下：</li></ul><pre><code>.bounce-in &#123;  animation: scale 1s ease;&#125;.a &#123;&#125;.bounce-out &#123;  animation: scale 1s ease reverse;&#125;</code></pre><ul><li>完整版代码</li></ul><pre><code>&lt;script setup&gt;  import &#123; ref &#125; from &quot;vue&quot;;  const isShow = ref(true);&lt;/script&gt;&lt;template&gt;  &lt;button @click=&quot;isShow = !isShow&quot;&gt;缩放动画&lt;/button&gt;  &lt;!-- 自定义过渡Class名 --&gt;  &lt;Transition enter-active-class=&quot;bounce-in&quot; leave-active-class=&quot;bounce-out&quot;&gt;    &lt;div class=&quot;text&quot; v-if=&quot;isShow&quot;&gt;我是一段测试animation 缩放动画的文字&lt;/div&gt;  &lt;/Transition&gt;&lt;/template&gt;&lt;style scoped&gt;  .text &#123;    text-align: center;  &#125;  /* 入场动画 */  .bounce-in &#123;    animation: scale 1s ease;  &#125;  /* 出场动画 */  .bounce-out &#123;    animation: scale 1s ease reverse;  &#125;  /* 定义动画 */  @keyframes scale &#123;    0% &#123;      transform: scale(0);    &#125;    50% &#123;      transform: scale(1.25);    &#125;    100% &#123;      transform: scale(1);    &#125;  &#125;&lt;/style&gt;</code></pre><h4 id="animate-css-与-组件结合应用"><a href="#animate-css-与-组件结合应用" class="headerlink" title="animate.css 与 组件结合应用"></a>animate.css 与 <Transition>组件结合应用</h4><blockquote><p>当我们想要在 Vue 的动画机制下集成其他的第三方 CSS 动画库时，自定义过渡 class 就显得非常有用。</p><ul><li>比如：常见的第三方 CSS 动画库：<a href="https://daneden.github.io/animate.css/">Animate.css</a></li></ul></blockquote><ol><li>如何使用 Animate 动画库</li></ol><ul><li>第一步：打开 Animate 动画库官网<ul><li>Animate 官网地址：<code>https://animate.style/</code></li></ul></li><li>第二步：安装<code>animate.css</code>包<ul><li>按官网首页的安装教程来安装<code>animate.css</code>包，命令如下：</li></ul></li></ul><pre><code>npm install animate.css --save</code></pre><ul><li>第三步：导入<code>animate.css</code>样式</li></ul><pre><code>import &quot;animate.css&quot;;</code></pre><ul><li>第四步：添加动画<ul><li>在需要执行相关动画的元素上，添加对应的动画的<code>class</code> 名，如下：<blockquote><ul><li>与Class结合</li></ul></blockquote></li></ul></li></ul><pre><code>&lt;!-- animate__animated 是必需要加的基础类，animate__bounce为所要实现动画效果的动画类 --&gt;&lt;div class=&quot;animate__animated animate__bounce&quot;&gt;An animated element&lt;/div&gt;</code></pre><blockquote><ul><li>与<code>&lt;Transition&gt;</code>结合</li></ul></blockquote><pre><code>&lt;Transition    enter-active-class=&quot;animate__animated animate__backInLeft&quot;    leave-active-class=&quot;animate__animated animate__backOutRight&quot;  &gt;  //...&lt;/Transition&gt;</code></pre><ul><li>不同的动画 Class 名，大家可以在动画名右侧显示的小方块上点击下，就可以复制到对应的 Class 名</li></ul><ol start="2"><li>应用：入场出场动画<blockquote><p>接下来，我们利用<code>Animate</code>与<code>&lt;Transition&gt;</code>实现以下酷炫动画效果<br><img src="入场出场动画.gif"></p></blockquote></li></ol><ul><li>完整版代码如下：</li></ul><pre><code>&lt;script setup&gt;  import &quot;animate.css&quot;;  import &#123; ref &#125; from &quot;vue&quot;;  const isShow = ref(true);&lt;/script&gt;&lt;template&gt;  &lt;button @click=&quot;isShow = true&quot; :disabled=&quot;isShow&quot;&gt;入场&lt;/button&gt;  &lt;button @click=&quot;isShow = false&quot; :disabled=&quot;!isShow&quot;&gt;出场&lt;/button&gt;  &lt;Transition    appear    name=&quot;custom-classes&quot;    enter-active-class=&quot;animate__animated animate__backInLeft&quot;    leave-active-class=&quot;animate__animated animate__backOutRight&quot;  &gt;    &lt;div class=&quot;text&quot; v-show=&quot;isShow&quot;&gt;An animated element&lt;/div&gt;  &lt;/Transition&gt;&lt;/template&gt;&lt;style&gt;  .text &#123;    text-align: center;  &#125;&lt;/style&gt;</code></pre><ul><li>注：以上代码中的<code>name</code>属性相对于自定义过渡 <code>class</code> 而言，是不生效的，但对于没有定义的过渡 <code>class</code> 是生效的</li><li>千完不要忘记加<code>animate__animated</code></li></ul><h4 id="同时使用-transition-和-animation"><a href="#同时使用-transition-和-animation" class="headerlink" title="同时使用 transition 和 animation"></a>同时使用 transition 和 animation</h4><blockquote><p>不管是<code>transition</code>动画还是<code>animation</code>动画，Vue 之所以能知道动画在何时结束，是因为内部监听了<code>transitionend</code>和<code>animationend</code>事件。</p><p>如果一个元素只运用了<code>transition</code>或<code>animation</code>中的一种动画，Vue 可以自动探测到正确的类型，然后监听对应的事件。</p><p>如果一个元素<strong>同时运用了这两种动画</strong>，则 Vue 就没有办法知道应该在那个动画结束时将元素移除。这时就需要我们显示的传入<code>type</code>属性来声明，告诉 Vue 需要关心哪种类型，传入的值是 <code>animation</code>或<code>transition</code></p></blockquote><blockquote><p>以下代码展示在执行<code>animation</code>动画的同时，执行了<code>transition</code>动画使文字变色。</p></blockquote><ul><li>如果我们显式指定了<code>type=&quot;animation&quot;</code>，相当于告诉 vue，帮我们监听<code>animationend</code>事件，动画会在1s后结束。</li><li>如果我们显式指定了<code>type=&quot;transition&quot;</code>，相当于告诉 Vue，帮我们监听<code>transitionend</code>事件，动画会在20s后结束</li></ul><pre><code>&lt;script setup&gt;  import &#123; ref &#125; from &quot;vue&quot;;  const isShow = ref(true);&lt;/script&gt;&lt;template&gt;  &lt;button @click=&quot;isShow = !isShow&quot;&gt;缩放动画&lt;/button&gt;  &lt;!-- 自定义过渡Class名 --&gt;  &lt;Transition    name=&quot;rotate&quot;    type=&quot;animation&quot;    enter-active-class=&quot;bounce-in rotate-in&quot;    leave-active-class=&quot;bounce-out rotate-out&quot;  &gt;    &lt;div class=&quot;text&quot; v-if=&quot;isShow&quot;&gt;我是一段测试animation 缩放动画的文字&lt;/div&gt;  &lt;/Transition&gt;&lt;/template&gt;&lt;style scoped&gt;  .text &#123;    text-align: center;  &#125;  .rotate-enter-from,  .rotate-leave-to &#123;    color: red;  &#125;  .rotate-in,  .rotate-out &#123;    transition: color 20s;  &#125;  /* 入场动画 */  .bounce-in &#123;    animation: scale 1s ease;  &#125;  /* 出场动画 */  .bounce-out &#123;    animation: scale 1s ease reverse;  &#125;  /* 定义动画 */  @keyframes scale &#123;    0% &#123;      transform: scale(0);    &#125;    50% &#123;      transform: scale(1.25);    &#125;    100% &#123;      transform: scale(1);    &#125;  &#125;&lt;/style&gt;</code></pre><h4 id="对比"><a href="#对比" class="headerlink" title="对比"></a>对比</h4><blockquote><p>使用CSS 过渡 Class</p><ul><li>使用<code>*-enter-from</code>等六种class</li><li>在<code>.*-enter/leave-active</code>中使用的是<code>transition</code></li></ul></blockquote><blockquote><p>使用animation动画</p><ul><li>使用<code>@keyframes name</code>定义动画</li><li>在<code>*-enter-active</code>和<code>*-leave-activeClass</code>下声明animation动画</li><li>在<code>*-*-active</code>样式中使用<code>animation</code></li></ul></blockquote><blockquote><p>使用自定义过渡时</p><ul><li>需要在<code>&lt;Transition&gt;</code>中指定自定义过渡的class</li><li>注意：此时name属性相对于自定义过渡 class 而言，是不生效的，只对于没有定义的过渡 class 是生效的</li></ul></blockquote><blockquote><p>animation+自定义过渡</p><ul><li>在<code>style</code>中，使用自定义样式替代<code>*-enter-active</code>和<code>*-leave-activeClass</code>中对动画的声明</li><li>如果使用<code>animation.css</code></li></ul></blockquote><ul><li>引入库后，只需在<code>&lt;Transition&gt;</code>的对应class中填上动画名</li><li>注意不能忘记基础的css样式<code>animate__animated</code></li><li><code>style</code>中不用再写<code>*-enter-active</code>和<code>*-leave-activeClass</code></li></ul><h4 id="动画的-JavaScript-钩子"><a href="#动画的-JavaScript-钩子" class="headerlink" title="动画的 JavaScript 钩子"></a>动画的 JavaScript 钩子</h4><blockquote><p>Vue 为<code>&lt;Transition&gt;</code>组件添加了一些事件，这些事件会在过渡不同生命阶段自被动调用。</p><ul><li>我们可以通过监听事件的方式在过渡过程中挂上钩子函数：</li></ul></blockquote><pre><code>&lt;Transition  @before-enter=&quot;onBeforeEnter&quot;  @enter=&quot;onEnter&quot;  @after-enter=&quot;onAfterEnter&quot;  @enter-cancelled=&quot;onEnterCancelled&quot;  @before-leave=&quot;onBeforeLeave&quot;  @leave=&quot;onLeave&quot;  @after-leave=&quot;onAfterLeave&quot;  @leave-cancelled=&quot;onLeaveCancelled&quot;&gt;  &lt;!-- ... --&gt;&lt;/Transition&gt;</code></pre><ul><li>以下为钩子函数的不同执行时机</li></ul><pre><code>// 在元素被插入到 DOM 之前被调用// 用这个来设置元素的 &quot;enter-from&quot; 状态function onBeforeEnter(el) &#123;&#125;// 在元素被插入到 DOM 之后的下一帧被调用// 用这个来开始进入动画function onEnter(el, done) &#123;  // 调用回调函数 done 表示过渡结束  // 如果与 CSS 结合使用，则这个回调是可选参数  done();&#125;// 当进入过渡完成时调用。function onAfterEnter(el) &#123;&#125;// 在 leave 钩子之前调用// 大多数时候，你应该只会用到 leave 钩子function onBeforeLeave(el) &#123;&#125;// 在离开过渡开始时调用// 用这个来开始离开动画function onLeave(el, done) &#123;  // 调用回调函数 done 表示过渡结束  // 如果与 CSS 结合使用，则这个回调是可选参数  done();&#125;// 在离开过渡完成、// 且元素已从 DOM 中移除时调用function onAfterLeave(el) &#123;&#125;// 仅在 v-show 过渡中可用function onLeaveCancelled(el) &#123;&#125;</code></pre><ul><li>注意：在调用回调函数<code>done</code>时，需要设置定时器，在动画结束后调用<code>done</code></li><li>在使用仅由 <code>JavaScript</code> 执行的动画时，最好是添加一个 <code>:css=&quot;false&quot;</code>属性。这显式地向 Vue 表明可以跳过对 CSS 过渡的自动探测。除了性能稍好一些之外，还可以防止 CSS 规则意外地干扰过渡效果</li></ul><pre><code>&lt;Transition :css=&quot;false&quot;&gt; ... &lt;/Transition&gt;</code></pre><ol><li><p>钩子函数功能</p><blockquote><p>各个钩子函数中具体实现的功能</p><ul><li>如下表：<table><thead><tr><th>钩子函数</th><th>功能</th></tr></thead><tbody><tr><td>@before-enter</td><td>用来设置入场动画的起始状态，即<code>enter-from</code> 状态，等同于<code>.v-enter-from</code></td></tr><tr><td>@enter</td><td>用来设置入场动画与动画的结束状态，即<code>enter-active</code>与<code>enter-to</code></td></tr><tr><td>@after-enter</td><td>入场动画结束后，移除添加到元素身上的动画样式 （还要移除：<code>v-leave-active</code>）</td></tr><tr><td>@enter-cancelled</td><td>入场动画中途被中断后，通常要移除<code>enter-to</code>状态</td></tr><tr><td>@before-leave</td><td>用来设置出场动画的起始状态，即<code>leave-from</code> 状态</td></tr><tr><td>@leave</td><td>用来设置出场动画与动画的结束状态，即<code>leave-active</code>与<code>leave-to</code></td></tr><tr><td>@after-leave</td><td>出场动画结束后，移除添加到元素身上的动画样式 (还要移除<code>v-enter-active</code>)</td></tr><tr><td>@leave-cancelled</td><td>出场动画中途被中断后，通常要移除<code>leave-to</code>状态</td></tr></tbody></table></li></ul></blockquote></li><li><p>案例：弹性动画</p><img src="弹性动画.gif"></li></ol><blockquote><p>以上动画中，入场动画和出场动画分别是用<code>transition</code>和<code>animation</code>来实现的</p><ul><li>不过，入场动画的开始状态并不是出场动画的结束状态</li><li>但是，入场动画的结束状态是出场动画的开始状态</li></ul></blockquote><ul><li>完整代码</li></ul><pre><code>&lt;script setup&gt;  import &#123; ref &#125; from &quot;vue&quot;;  const show = ref(true);  const timer = ref(null);  /* 入场动画状态 */  function onBeforeEnter(el) &#123;    el.classList.add(&quot;v-enter-from&quot;);  &#125;  /* 入场动画与动画结束状态 */  function onEnter(el, done) &#123;    setTimeout(() =&gt; &#123;      el.classList.add(&quot;v-enter-active&quot;, &quot;v-enter-to&quot;);      el.classList.remove(&quot;v-enter-from&quot;);    &#125;);    setTimeout(() =&gt; &#123;      done();    &#125;, 1200);  &#125;  // 入场动画结束后，将添加的动画样式删除  function onAfterEnter(el) &#123;    el.classList.remove(&quot;v-enter-to&quot;, &quot;v-enter-active&quot;);  &#125;  // 出场动画  function onLeave(el, done) &#123;    setTimeout(() =&gt; &#123;      el.classList.add(&quot;v-leave-active&quot;);    &#125;);    clearTimeout(timer.value);    timer.value = setTimeout(() =&gt; &#123;      done();    &#125;, 2000);  &#125;  // 出场动画结束后，将添加的动画样式移除  function onAfterLeave(el) &#123;    el.classList.remove(&quot;v-leave-active&quot;);  &#125;  function onLeaveCancelled(el) &#123;    el.classList.remove(&quot;v-leave-active&quot;);  &#125;&lt;/script&gt;&lt;template&gt;  &lt;button @click=&quot;show = !show&quot;&gt;切换&lt;/button&gt;  &lt;Transition    :css=&quot;false&quot;    @before-enter=&quot;onBeforeEnter&quot;    @enter=&quot;onEnter&quot;    @after-enter=&quot;onAfterEnter&quot;    @enter-cancelled=&quot;onAfterEnter&quot;    @leave=&quot;onLeave&quot;    @after-leave=&quot;onAfterLeave&quot;    @leave-cancelled=&quot;onLeaveCancelled&quot;  &gt;    &lt;div class=&quot;ball&quot; v-show=&quot;show&quot;&gt;&lt;/div&gt;  &lt;/Transition&gt;&lt;/template&gt;&lt;style&gt;  .ball &#123;    width: 50px;    height: 50px;    background-color: skyblue;    border-radius: 50%;  &#125;  .v-enter-from &#123;    transform: scale(0.25);    opacity: 1;  &#125;  .v-enter-active &#123;    transition: all 1s ease;    transition-delay: 200;  &#125;  .v-enter-to &#123;    transform: scale(1);  &#125;  .v-leave-active &#123;    /*         forwards 表示动画结束后将停止在最后结束的状态，以免产生回到原始位置的抖动效果    */    animation: move 2s ease forwards;  &#125;  @keyframes move &#123;    0% &#123;      transform: scale(1) translateX(0px);    &#125;    20% &#123;      transform: scale(1) translateX(-50px);    &#125;    100% &#123;      transform: translateX(300px) scale(0.25);      opacity: 0;    &#125;  &#125;&lt;/style&gt;</code></pre><h4 id="封装动画组件"><a href="#封装动画组件" class="headerlink" title="封装动画组件"></a>封装动画组件</h4><blockquote><p>接下来我们把淡出与淡入动画 和 左右滑动动画封装在<code>&lt;CustomTransiton&gt;</code>组件中，当我们传入以下不同<code>props</code> 时，显示不同的动画</p><ul><li>注意：</li></ul></blockquote><ul><li><p>在<code>style</code>中使用变量时，要使用<code>v-bind</code>才能实现</p></li><li><p>插槽的样式原本应该写在父组件中，但因为要封装组件，所以样式写在了子组件中，因此，子组件的<code>style</code>不能加<code>scope</code></p></li><li><p>完整版代码如下：</p></li></ul><pre><code>&lt;script setup&gt;  const props = defineProps([&quot;duration&quot;, &quot;animationName&quot;]);&lt;/script&gt;&lt;template&gt;  &lt;Transition :name=&quot;animationName&quot;&gt;    &lt;slot&gt;&lt;/slot&gt;  &lt;/Transition&gt;&lt;/template&gt;&lt;style&gt;  /* fade 淡入与淡出动画 */  .fade-enter-from,  .fade-leave-to &#123;    opacity: 0;  &#125;  .fade-enter-active,  .fade-leave-active &#123;    transition: opacity v-bind(duration) ease;  &#125;  /* 左右滑动动画 */  .slide-enter-from,  .slide-leave-to &#123;    transform: translateX(300px);    opacity: 0;  &#125;  .slide-enter-active,  .slide-leave-active &#123;    transition: transform v-bind(duration) ease, opacity v-bind(duration) ease;  &#125;&lt;/style&gt;</code></pre><ul><li>在其它组件中调用<CustomTransition>组件</li></ul><pre><code>&lt;script setup&gt;  import CustomTransition from &quot;./components/CustomTransition.vue&quot;;  import &#123; ref &#125; from &quot;vue&quot;;  const show = ref(true);&lt;/script&gt;&lt;template&gt;  &lt;button @click=&quot;show = !show&quot;&gt;切换动画&lt;/button&gt;  &lt;CustomTransition duration=&quot;5s&quot; animationName=&quot;fade&quot;&gt;    &lt;div class=&quot;box&quot; v-show=&quot;show&quot;&gt;&lt;/div&gt;  &lt;/CustomTransition&gt;  &lt;br /&gt;  &lt;CustomTransition duration=&quot;2s&quot; animationName=&quot;slide&quot;&gt;    &lt;div class=&quot;box&quot; v-show=&quot;show&quot;&gt;&lt;/div&gt;  &lt;/CustomTransition&gt;&lt;/template&gt;&lt;style&gt;  .box &#123;    width: 100px;    height: 100px;    background-color: khaki;  &#125;&lt;/style&gt;</code></pre><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a><Transition>总结</h4><ol><li><Transition> 的基本用法</li></ol><ul><li><Transition> 组件中只能是 单根元素 或 单根组件</li><li>进入或离开的动画由以下条件之一触发<ul><li>由 v-if 所触发的切换</li><li>由 v-show 所触发的切换</li><li>由特殊元素 <component> 切换的动态组件</li><li>改变特殊的 key 属性</li></ul></li></ul><ol start="2"><li>过渡与动画默认 class</li></ol><ul><li>入场动画<code>class</code>：<code>v-enter-from</code>、<code>v-enter-active</code>、<code>v-enter-to</code></li><li>出场动画<code>calss</code>：<code>v-leave-from</code>、<code>v-leave-active</code>、<code>v-leave-to</code></li></ul><ol start="3"><li><p><Transition> 组件 props</p><table><thead><tr><th>props</th><th>功能</th><th>值</th><th>说明</th></tr></thead><tbody><tr><td>appear</td><td>是否初次渲染</td><td>布尔属性</td><td>添加 appear 属性，表示元素初次渲染时添加动画效果</td></tr><tr><td>name</td><td>过渡效果命名</td><td>字符串类型</td><td>为不同的过渡动画取不同的过渡效果名，如果 name&#x3D;’fade‘，则 css 过渡 class 名为fade-enter-from&#x2F;active&#x2F;to 、fade-leave-from&#x2F;active&#x2F;to</td></tr><tr><td>mode</td><td>过渡模式</td><td>out-in &#x2F; in-out</td><td>out-in：先执行出场（离开）动画，出场动画结束后，再执行入场动画；in-out：先执行入场（进入）动画，入场动画结束后，再执行出场动画 （基本不用）</td></tr><tr><td>duration</td><td>过渡时长</td><td>整数</td><td>表示动画执行的时长，单位为毫秒</td></tr><tr><td>type</td><td>指定监听动画类型</td><td>“transition”&#x2F;“animation”</td><td>值为”transition”表示监听transitionend事件，当 tranition 动画结束后即元素身上所有动画结束；值为”animation”表示监听animationend事件，当animation动画结束后即元素身上所有动画结束</td></tr></tbody></table></li><li><p>自定义过渡 class</p><blockquote><p>你也可以向 <code>&lt;Transition&gt;</code> 传递以下的 props 来指定自定义的过渡 class：</p></blockquote></li></ol><ul><li><code>enter-from-class</code></li><li><code>enter-active-class</code></li><li><code>enter-to-class</code></li><li><code>leave-from-class</code></li><li><code>leave-active-class</code></li><li><code>leave-to-class</code></li></ul><ol start="5"><li>动画 Javascript 钩子</li></ol><pre><code>&lt;Transition  @before-enter=&quot;onBeforeEnter&quot;  @enter=&quot;onEnter&quot;  @after-enter=&quot;onAfterEnter&quot;  @enter-cancelled=&quot;onEnterCancelled&quot;  @before-leave=&quot;onBeforeLeave&quot;  @leave=&quot;onLeave&quot;  @after-leave=&quot;onAfterLeave&quot;  @leave-cancelled=&quot;onLeaveCancelled&quot;&gt;  &lt;!-- ... --&gt;&lt;/Transition&gt;</code></pre><h3 id="九、-内置组件"><a href="#九、-内置组件" class="headerlink" title="九、 内置组件"></a>九、<TransitionGroup> 内置组件</h3><blockquote><p>通过前面的学习，我们知道<code>&lt;Transition&gt;</code>组件只能应用单个元素或单个单根组件。</p><ul><li>如果要实现同时多个元素的过渡动画效果，如下图所示：<img src="多元素淡入淡出动画.gif"></li></ul></blockquote><ul><li>单个<code>&lt;Transition&gt;</code>是没有办法做到的，除非把上面四个元素，每个元素用一个<code>&lt;Transition&gt;</code>包裹，当然这样做是非常麻烦的，而<code>&lt;TransitionGroup&gt; </code>内置组件可以轻松帮我们做到。</li><li><code>&lt;TransitionGroup&gt;</code>是一个内置组件，他主要用于多个元素的过渡效果。</li><li>常用于对 <code>v-for</code> 列表中的元素或组件的插入、移除和顺序改变添加动画效果。</li><li><code>&lt;TransitionGroup&gt;</code> 支持和 <code>&lt;Transition&gt;</code> 基本相同的 props、CSS 过渡 class 和 JavaScript 钩子监听器，不过还存在一些不同点</li></ul><h4 id="与的不同"><a href="#与的不同" class="headerlink" title="与的不同"></a><TransitionGroup>与<Transition>的不同</h4><ol><li>可以为<code>&lt;TransitionGroup&gt;</code>组件传入&#96;tag prop&#96;&#96;来指定一个元素作为容器元素来渲染</li></ol><pre><code>&lt;div class=&quot;container&quot;&gt;  &lt;TransitionGroup tag=&quot;div&quot;&gt;&lt;/TransitionGroup&gt;&lt;/div&gt;&lt;!-- 以上代码，最终渲染成如下--&gt;&lt;div class=&quot;container&quot;&gt;  &lt;div&gt;&lt;/div&gt;&lt;/div&gt;&lt;!--如果没有加tag属性，则渲染如下--&gt;&lt;div class=&quot;container&quot;&gt;&lt;/div&gt;</code></pre><ol start="2"><li>过渡模式（<code>mode = &quot;out-in&quot;</code>） 在这里不可用，因为我们不再是在互斥的元素之间进行切换。</li></ol><pre><code>&lt;!--以下为错误写法，TransitionGroup 并不支持mode属性--&gt;&lt;TransitionGroup mode=&quot;out-in&quot;&gt;&lt;/TransitionGroup&gt;</code></pre><ol start="3"><li>列表中的每个元素都必须有一个独一无二的 <code>key attribute</code></li></ol><pre><code>&lt;!--如果div元素身上没有Key属性，或每个key不是唯一的，都是错误写法，在控制台会抛出警告--&gt;&lt;TransitionGroup&gt;  &lt;div :key=&quot;1&quot;&gt;1&lt;/div&gt;  &lt;div :key=&quot;2&quot;&gt;2&lt;/div&gt;  &lt;div :key=&quot;3&quot;&gt;3&lt;/div&gt;&lt;/TransitionGroup&gt;</code></pre><ol start="4"><li>CSS 过渡 class 会被应用在列表内的元素上，而不是容器元素上</li></ol><h4 id="实战应用：多元素延迟淡入淡出动画"><a href="#实战应用：多元素延迟淡入淡出动画" class="headerlink" title="实战应用：多元素延迟淡入淡出动画"></a>实战应用：多元素延迟淡入淡出动画</h4><ol><li>基础版</li></ol><ul><li>完整版代码</li></ul><pre><code>&lt;script setup&gt;  import &#123; ref &#125; from &quot;vue&quot;;  const show = ref(true);&lt;/script&gt;&lt;template&gt;  &lt;button @click=&quot;show = !show&quot;&gt;切换&lt;/button&gt;  &lt;div class=&quot;container&quot;&gt;    &lt;TransitionGroup :duration=&quot;2600&quot;&gt;      &lt;div class=&quot;item&quot; v-show=&quot;show&quot; :key=&quot;1&quot; style=&quot;--delay:0s&quot;&gt;&lt;/div&gt;      &lt;div class=&quot;item&quot; v-show=&quot;show&quot; :key=&quot;2&quot; style=&quot;--delay:0.2s&quot;&gt;&lt;/div&gt;      &lt;div class=&quot;item&quot; v-show=&quot;show&quot; :key=&quot;3&quot; style=&quot;--delay:0.4s&quot;&gt;&lt;/div&gt;      &lt;div class=&quot;item&quot; v-show=&quot;show&quot; :key=&quot;4&quot; style=&quot;--delay:0.6s&quot;&gt;&lt;/div&gt;    &lt;/TransitionGroup&gt;  &lt;/div&gt;&lt;/template&gt;&lt;style&gt;  .container &#123;    display: flex;    width: 600px;    height: 200px;    margin: 10px;    border: 2px dashed khaki;    background-color: rgb(249, 247, 228);    overflow: hidden;  &#125;  .container .item &#123;    flex: 1;    margin: 10px;    background-color: khaki;  &#125;  .v-enter-from,  .v-leave-to &#123;    opacity: 0;    transform: translateY(100px);  &#125;  .v-enter-active,  .v-leave-active &#123;    transition: all 2s ease var(--delay);  &#125;&lt;/style&gt;</code></pre><blockquote><p>代码解析：</p></blockquote><ul><li><code>duration=&quot;2600&quot;</code>属性一定要加（值为整个动画从开始到结束的时间）</li><li>如果不加，每个元素自身动画结束后，就会立即隐藏，这样会造成后面元素向前移动，引发布局混乱。</li><li><code>duration=&quot;2600&quot;</code>表示在 2.6s 后（所有动画都结束了）一次性隐藏所有元素</li><li>每个item元素的 <code>key</code> 属性一定要加，并且值还不能一样（这是 Vue 规定的）</li><li>item元素身上的<code>--delay</code>属性为自定义 css 属性，用来表示每个元素执行动画前的延迟时间。</li></ul><blockquote><p>重点观察</p></blockquote><ul><li>我们重点观察控制台中每个item元素身上 class 的变化</li><li>我们发现过渡 class 加在了每个元素身上，每个元素身上的过渡 class 是同一时间被加上的。</li><li>还有每个元素身上的 class 是在同一时间被删除，同一时间被删除主要是受<code>duration=&quot;2600&quot;</code>属性的影响</li></ul><ol start="2"><li>优化版</li></ol><ul><li>在实际的开发中，我们肯定是希望所有内部元素的动画执行完成后，再把外部元素也给隐藏或移除掉；因此<code>.container</code>在动画结束后也要隐藏</li><li>一般列表内容在实际开发中是通过<code>v-for</code>列表来渲染的，所以我们把内容改成通过<code>v-for</code>来渲染</li></ul><pre><code>&lt;script setup&gt;  import &#123; reactive, ref &#125; from &quot;vue&quot;;  const show = ref(true);  const list = reactive([1, 2, 3, 4]);&lt;/script&gt;&lt;template&gt;  &lt;button @click=&quot;show = !show&quot;&gt;切换&lt;/button&gt;  &lt;Transition :duration=&quot;2800&quot; name=&quot;fade&quot;&gt;    &lt;div class=&quot;container&quot; v-show=&quot;show&quot;&gt;      &lt;TransitionGroup :duration=&quot;2800&quot; appear&gt;        &lt;div          class=&quot;item&quot;          v-for=&quot;(item, index) in  list &quot;          v-show=&quot;show&quot;          :key=&quot;index&quot;          :style=&quot;&#123; &#39;--delay&#39;: 0.2 * index + &#39;s&#39; &#125;&quot;        &gt;&lt;/div&gt;      &lt;/TransitionGroup&gt;    &lt;/div&gt;  &lt;/Transition&gt;&lt;/template&gt;&lt;style&gt;  .container &#123;    width: 600px;    height: 200px;    overflow: hidden;    margin: 10px;    border: 2px dashed khaki;    background-color: rgb(249, 247, 228);    display: flex;  &#125;  .container .item &#123;    flex: 1;    margin: 10px;    background-color: khaki;  &#125;  .v-enter-from,  .v-leave-to &#123;    opacity: 0;    transform: translateY(100px);  &#125;  .v-enter-active,  .v-leave-active &#123;    transition: all 2s ease var(--delay);  &#125;&lt;/style&gt;</code></pre><ul><li>注意自定义属性<code>--delay</code></li></ul><ol start="3"><li>用JS 钩子函数与 css 过渡实现</li></ol><pre><code>  &lt;button @click=&quot;show = !show&quot;&gt;切换&lt;/button&gt;  &lt;Transition :duration=&quot;2800&quot; name=&quot;fade&quot;&gt;    &lt;div class=&quot;container&quot; v-show=&quot;show&quot;&gt;      &lt;!--添加 @leave=&quot;onLeave&quot; --&gt;      &lt;TransitionGroup :duration=&quot;2800&quot; @leave=&quot;onLeave&quot;&gt;        &lt;!-- data-index自定义属性--&gt;        &lt;div          class=&quot;item&quot;          v-for=&quot;(item, index) in  list &quot;          v-show=&quot;show&quot;          :key=&quot;index&quot;          :data-index=&quot;index&quot;        &gt;&lt;/div&gt;      &lt;/TransitionGroup&gt;    &lt;/div&gt;  &lt;/Transition&gt;&lt;/template&gt;&lt;style&gt;  .container &#123;    width: 600px;    height: 200px;    overflow: hidden;    margin: 10px;    border: 2px dashed khaki;    background-color: rgb(249, 247, 228);    display: flex;  &#125;  .container .item &#123;    flex: 1;    margin: 10px;    background-color: khaki;  &#125;  .v-enter-from,  .v-leave-to &#123;    opacity: 0;    transform: translateY(100px);  &#125;  .v-enter-active,  .v-leave-active &#123;    /* transition: all 2s ease var(--delay); */  &#125;&lt;/style&gt;</code></pre><h4 id="实战应用：列表添加、删除、排序元素时动画"><a href="#实战应用：列表添加、删除、排序元素时动画" class="headerlink" title="实战应用：列表添加、删除、排序元素时动画"></a>实战应用：列表添加、删除、排序元素时动画</h4><img src="列表添加删除排序时动画.gif"><ol><li>基础版</li></ol><pre><code>&lt;script setup&gt;  import &#123; ref, reactive &#125; from &quot;vue&quot;;  const list = reactive([1, 2, 3, 4]);  let len = list.length;  // 根据数组长度，产生0-小于数组长度内的随机整数，用来作为随机删除的元素下标  function randomIndex() &#123;    //注意：要使用list.length 要随时更新数组长度    return Math.floor(Math.random() * list.length);  &#125;  // 随机位置插入比当前数组长度&gt;1的整数  function add() &#123;    len++;    list.splice(randomIndex(), 0, len);  &#125;  // 根据随机生成的下标，随机删除数组中的一位元素  function remove() &#123;    list.splice(randomIndex(), 1);  &#125;  // 对数组中元素升序排序  function sort() &#123;    list.sort((a, b) =&gt; &#123;      return a - b;    &#125;);  &#125;&lt;/script&gt;&lt;template&gt;  &lt;button @click=&quot;add&quot;&gt;在任意位置添加一项&lt;/button&gt;&amp;nbsp;  &lt;button @click=&quot;remove&quot;&gt;在任意位置移除一项&lt;/button&gt;  &lt;button @click=&quot;sort&quot;&gt;升序排序&lt;/button&gt;  &lt;TransitionGroup tag=&quot;ul&quot;&gt;    &lt;li v-for=&quot;item in list&quot; :key=&quot;item&quot;&gt;&#123;&#123; item &#125;&#125;&lt;/li&gt;  &lt;/TransitionGroup&gt;&lt;/template&gt;&lt;style&gt;  .v-enter-from,  .v-leave-to &#123;    opacity: 0;    transform: translateX(30px);  &#125;  .v-enter-active,  .v-leave-active &#123;    transition: all 1s ease;  &#125;&lt;/style&gt;</code></pre><blockquote><p>以上效果与我们最终想要的效果，明显有很大的差异</p><ul><li>两处不同差异：</li></ul></blockquote><ul><li>当某一项被插入或移除时，它周围的元素会立即发生“跳跃”而不是平稳地移动</li><li>当我们对现有元素排序时，并没有看到动画效果，直接展示排序后效果</li></ul><blockquote><ul><li>差异产生的原因在于：</li></ul></blockquote><ul><li>vue 只给添加或移除的元素添加的过渡 class，对于排序的元素也没有加。（观察上图中控制台中元素 class 变化可以看到）</li><li>要解决以上问题，可以通过添加一些额外的 CSS 规则来解决这个问题</li><li>添加如下<code>.v-move</code> class ,<code>.v-move</code>将应用于所有（移动中）布局发生变化的元素，用来实现其过渡效果</li><li>针对离开的元素，在离开的一瞬间<code>v-leave-active</code>将其设置为<strong>绝对定位</strong>，脱离文档流，这样后面的元素就会发生布局上的变化，从而触发了过渡效果</li></ul><pre><code>.v-move,  /* 对移动中的元素应用的过渡 */.v-enter-active,.v-leave-active &#123;  transition: all 1s ease;&#125;/* 确保将离开的元素从布局流中删除  以便能够正确地计算移动的动画。 */.v-leave-active &#123;  position: absolute;&#125;</code></pre><ol start="2"><li>最终版</li></ol><pre><code>&lt;script setup&gt;  import &#123; ref, reactive &#125; from &quot;vue&quot;;  const list = reactive([1, 2, 3, 4]);  let len = list.length;  // 根据数组长度，产生0-小于数组长度内的随机整数，用来作为随机删除的元素下标  function randomIndex() &#123;    return Math.floor(Math.random() * list.length);  &#125;  // 随机位置插入比当前数组长度&gt;1的整数  function add() &#123;    len++;    list.splice(randomIndex(), 0, len);  &#125;  // 根据随机生成的下标，随机删除数组中的一位元素  function remove() &#123;    list.splice(randomIndex(), 1);  &#125;  // 对数组中元素升序排序  function sort() &#123;    list.sort((a, b) =&gt; &#123;      return a - b;    &#125;);  &#125;&lt;/script&gt;&lt;template&gt;  &lt;button @click=&quot;add&quot;&gt;在任意位置添加一项&lt;/button&gt;&amp;nbsp;  &lt;button @click=&quot;remove&quot;&gt;在任意位置移除一项&lt;/button&gt;  &lt;button @click=&quot;sort&quot;&gt;升序排序&lt;/button&gt;  &lt;TransitionGroup tag=&quot;ul&quot;&gt;    &lt;li v-for=&quot;item in list&quot; :key=&quot;item&quot;&gt;&#123;&#123; item &#125;&#125;&lt;/li&gt;  &lt;/TransitionGroup&gt;&lt;/template&gt;&lt;style&gt;  .v-enter-from,  .v-leave-to &#123;    opacity: 0;    transform: translateX(30px);  &#125;  .v-move,  .v-enter-active,  .v-leave-active &#123;    transition: all 1s ease;  &#125;  /* 确保将离开的元素从布局流中删除    以便能够正确地计算移动的动画。 */  .v-leave-active &#123;    position: absolute;  &#125;&lt;/style&gt;</code></pre><h4 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h4><blockquote><p><code>&lt;TransitionGroup&gt;</code> 支持和 <code>&lt;Transition&gt;</code> 基本相同的 <code>props</code>、<code>CSS</code> 过渡 <code>class</code> 和 <code>JavaScript</code> 钩子监听器，不过还存在以下不同：</p></blockquote><ul><li>可以为<code>&lt;TransitionGroup&gt;</code>组件传入tagprop 来指定一个元素作为容器元素来渲染</li><li><code>&lt;TransitionGroup&gt;</code>组件中列表的每个元素都必须有一个独一无二的 <code>key</code> attribute</li><li>CSS 过渡 class 会被应用在列表内的元素上，而不是容器元素上。<br>0 过渡模式（<code>mode = &quot;out-in&quot;</code>） 在这里不可用</li></ul><blockquote><p>列表元素被触发动画的机制</p></blockquote><ul><li>元素被移除或插入时会添加对应的 Class，触发动画</li><li>元素被显示与隐藏时会添加对应的 Class，触发动画</li><li>多个元素发生动画时，自身动画结束后就会被移除或隐藏，如果想所有元素动画都执行完再隐藏或移除，可以添加 durationprop 来指定动画结束时间<ul><li>在刚开始执行动画时，列表中的其它元素的位置发生如果发生改变，则会添加<code>.move</code> Class，可以在<code>.move</code>中添加过渡动画，让整个变化有动画效果</li></ul></li><li>在移除或隐藏元素时，要保证后面元素有过渡动画，可以<code>.v-leave-active</code>中添加<code>position:absolute</code>这样出场动画刚执行时后面的元素就会发生位移，然后被添加<code>.move</code> Class</li></ul><h3 id="十、其他动画"><a href="#十、其他动画" class="headerlink" title="十、其他动画"></a>十、其他动画</h3><h4 id="基于-css-class-的动画"><a href="#基于-css-class-的动画" class="headerlink" title="基于 css class 的动画"></a>基于 css class 的动画</h4><blockquote><p>元素颤抖效果：当点击某个元素时，元素会颤抖<br>颤抖动画的实现原理：</p><ul><li>在规定的时间内（比如 1s），让元素向按以下方式来移动</li></ul></blockquote><ul><li><p>10%：从原位置上，向上上移动到 2px 即：translateY(-2px)</p></li><li><p>20%：向下移动到 2px，即：translateY(2px)</p></li><li><p>30%：向上移动到 4px，即：translateY(-4px)</p></li><li><p>40%：向下移动到 4px，即：translateY(4px)</p></li><li><p>50%：同 30%时执行效果一样</p></li><li><p>60%：同 40%时执行效果一样</p></li><li><p>70%：同 30%时执行效果一样</p></li><li><p>80%：同 20%时执行效果一样</p></li><li><p>90%：同 10%时执行效果一样</p></li><li><p>100%：回到元素动画开始前的元位置 translateY(0px)</p></li><li><p>动画实现代码：</p></li></ul><pre><code>@keyframes shake &#123;  10%,  90% &#123;    transform: translateY(-2px);  &#125;  20%,  80% &#123;    transform: translateY(2px);  &#125;  30%,  50%,  70% &#123;    transform: translateY(-4px);  &#125;  40%,  60% &#123;    transform: translateY(4px);  &#125;&#125;</code></pre><ul><li>完整代码</li></ul><pre><code>&lt;script setup&gt;  import &#123; ref &#125; from &quot;vue&quot;;  const disabled = ref(false);  function shake() &#123;    disabled.value = true;    setTimeout(() =&gt; &#123;      disabled.value = false;    &#125;, 1000);  &#125;&lt;/script&gt;&lt;template&gt;  &lt;div class=&quot;box&quot; :class=&quot;&#123; shake: disabled &#125;&quot; @click=&quot;shake&quot;&gt;&lt;/div&gt;&lt;/template&gt;&lt;style scoped&gt;  .box &#123;    margin: 30px;    width: 200px;    height: 250px;    background-color: khaki;    position: absolute;  &#125;  .shake &#123;    animation: shake 1s;  &#125;  50% @keyframes shake &#123;    10%,    90% &#123;      transform: translateY(-2px);    &#125;    20%,    80% &#123;      transform: translateY(2px);    &#125;    30%,    50%,    70% &#123;      transform: translateY(-4px);    &#125;    40%,    60% &#123;      transform: translateY(4px);    &#125;  &#125;&lt;/style&gt;</code></pre><h4 id="基于侦听器的动画"><a href="#基于侦听器的动画" class="headerlink" title="基于侦听器的动画"></a>基于侦听器的动画</h4><blockquote><p>数字动画</p><ul><li>效果：根据起始数据和目标数据的值，快速从起始数据递增或者递减到目标数据</li></ul></blockquote><pre><code>&lt;script setup&gt;  import &#123; ref, watch &#125; from &quot;vue&quot;;  const num = ref(0); // 绑定表单输入的值  const timer = ref(null); // 保存定时器  const number = ref(0); // 绑定变化后的值  // 侦听器  watch(num, (newValue, oldValue) =&gt; &#123;    if (!oldValue) &#123;      oldValue = 0;    &#125;    if (!newValue) &#123;      newValue = 0;    &#125;    numberAnimate(      Math.ceil(oldValue),      Math.ceil(newValue),      (value) =&gt; (number.value = value),      20    );  &#125;);  /**   * numberAnimate 方法用来实现数字动画   * @param  start 起始数字   * @param  target 结束数字   * @param  delay  定时器每次间隔时长   * @param  result 保存起始数字到结束数字中间变化的状态值   *   */  function numberAnimate(start, target, callback, delay = 20) &#123;    // 动画的步长    let step = 0;    // 如果有定时器，先清定时器    if (timer.value) &#123;      clearInterval(timer.value);    &#125;    timer.value = setInterval(() =&gt; &#123;      // 计算每次运动的步长      step = (target - start) / 5;      // 目标值大于起始值，向上取整,否则向下取整      step = step &gt; 0 ? Math.ceil(step) : Math.floor(step);      // 起始值累加      start = step + start;      // 将数值中间的变化值作为参数传递给callback      callback(start);      // result.value = start;      // 当起始值=目标值，则暂停定时器      if (start === target) &#123;        clearInterval(timer.value);      &#125;    &#125;, delay);  &#125;&lt;/script&gt;&lt;template&gt;  &lt;input v-model.number=&quot;num&quot; type=&quot;number&quot; /&gt;  &lt;div&gt;&#123;&#123; number &#125;&#125;&lt;/div&gt;&lt;/template&gt;</code></pre>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Vue </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Vue（五）</title>
      <link href="/2024/01/25/Vue%EF%BC%88%E4%BA%94%EF%BC%89/"/>
      <url>/2024/01/25/Vue%EF%BC%88%E4%BA%94%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<span id="more"></span><h3 id="组合式API的简介"><a href="#组合式API的简介" class="headerlink" title="组合式API的简介"></a>组合式API的简介</h3><blockquote><p>组合式 API（Composition API）是一系列 API 的集合，使我们可以使用<strong>函数</strong>而不是声明选项的方式书写 Vue 组件。它是一个概括性的术语，涵盖了以下方面的 API：</p></blockquote><ul><li>响应式 API：使我们可以直接创建响应式状态、计算属性和侦听器，如： <code>ref()</code> 和 <code>reactive()</code></li><li>生命周期钩子：使我们可以在组件各个生命周期阶段添加逻辑，如： <code>onMounted()</code> 和 <code>onUnmounted()</code></li><li>依赖注入：使我们可以在使用响应式 API 时，利用 Vue 的依赖注入系统，如 <code>provide()</code> 和 <code>inject()</code><blockquote><p>组合式 API 是 Vue 3 及 Vue 2.7的内置功能。对于更老的 Vue 2 版本，可以使用官方维护的插件 @vue&#x2F;composition-api。</p><ul><li>在 Vue 3 中，组合式 API 基本上都会配合<code>&lt;script setup&gt;</code>语法在单文件组件中使用。</li></ul></blockquote></li></ul><blockquote><p>下面是一个使用组合式 API 的组件示例：</p></blockquote><pre><code>&lt;script setup&gt;  import &#123; ref, reactive, computed &#125; from &quot;vue&quot;;  // 创建响应式数据 相当于选项式API中 data中定义的属性  const msg = ref(&quot;Hello Composition API&quot;);  const num = ref(100);  // 定义一个方法，相当于选项式API中的methods选项中定义的方法  function update() &#123;    num.value = 200;  &#125;  // 创建一个计算属性，相当于选项式API中的computed选项中创建的计算属性  const price = computed(() =&gt; &#123;    return &quot;$&quot; + num.value;  &#125;);&lt;/script&gt;&lt;template&gt;  &lt;h3&gt;&#123;&#123; msg &#125;&#125;&lt;/h3&gt;  &lt;p&gt;价格：&#123;&#123; price &#125;&#125;&lt;/p&gt;  &lt;button @click=&quot;update&quot;&gt;更新&lt;/button&gt;&lt;/template&gt;</code></pre><ul><li>从上面代码中可以看到，创建的响应式数据，methods 方法，computed 计算属性都是基于函数来实现的。这些函数组合在一起就能完成一个具体的应用。</li><li>所谓组合式 API 就是指这些不同的 API（函数）组合在一起来实现一个完整的应用，和之前学习的选项式 API 风格完全不同</li></ul><h3 id="一、初识-setup-函数"><a href="#一、初识-setup-函数" class="headerlink" title="一、初识 setup() 函数"></a>一、初识 setup() 函数</h3><blockquote><p><code>setup()</code>函数是在组件中使用组合式 API 的入口（表演的舞台），所有组合式 API 代码都写在<code>setup()</code>函数中</p></blockquote><pre><code>&lt;script&gt;  export default &#123;    // setup函数是所有组合式API的入口（表演的舞台）    setup() &#123;      // .....所有代码在此书写    &#125;,  &#125;;&lt;/script&gt;</code></pre><ol><li>setup() 函数的返回值<blockquote><p><code>setup()</code>函数的返回值通常是一个对象，这个对象的所有属性会暴露给组件模板和组件实例，所以</p></blockquote></li></ol><ul><li>在组件的<strong>模板</strong>中可以直接访问<code>setup()</code>返回对象的属性</li><li>在组件的<strong>选项式 API</strong>中可通过组件实例可以访问<code>setup()</code>返回对象身上的属性。</li><li>以下代码展示了，在模板中和组件实例上访问到setup()函数返回的对象身上的属性和方法。<ul><li>提示：选项式 API 与组合式 API 是可以共存的。</li></ul></li></ul><pre><code>&lt;script&gt;  export default &#123;    setup() &#123;      // 返回值会暴露给模板和其他的选项式 API 钩子      return &#123;        message: &quot;Hello Vue!!&quot;,        sayHello: () =&gt; console.log(&quot;sayHello&quot;),      &#125;;    &#125;,    beforeCreate() &#123;      console.log(this.message); // 组件实例可以直接获取message属性    &#125;,  &#125;;&lt;/script&gt;&lt;template&gt;  &lt;button @click=&quot;sayHello&quot;&gt;sayHello&lt;/button&gt;  &lt;!--模板中可以直接使用message属性--&gt;  &lt;div&gt;&#123;&#123; message &#125;&#125;&lt;/div&gt;&lt;/template&gt;</code></pre><ol start="2"><li>setup() 函数中 this 指向</li></ol><ul><li>setup()函数自身并不含对组件实例的访问权，在setup()中访问<code>this</code>会是<code>undefind</code></li><li>所以setup()函数内是<strong>没有办法</strong>访问到选项式 API 中的属性、方法、计算属性等。</li></ul><pre><code>&lt;!-- 以下代码是错的 --&gt;&lt;script&gt;  export default &#123;    data() &#123;      return &#123;        message: &quot;Hello Vue!!&quot;,      &#125;;    &#125;,    setup() &#123;      console.log(this); // undefined      console.log(this.message); // 抛出错误，因为this为undefined    &#125;,  &#125;;&lt;/script&gt;</code></pre><ol start="3"><li>setup() 函数执行时机</li></ol><ul><li>setup()函数是在 Vue 生命周期函数<code>beforeCreate()</code>之前被自动调用的。</li><li>所以在<code>beforeCreate()</code>函数和选项式 API 中可以访问到setup()函数对外暴露的属性</li></ul><pre><code>&lt;script&gt;  export default &#123;    data() &#123;      return &#123;        text: this.message,      &#125;;    &#125;,    setup() &#123;      return &#123;        message: &quot;Hello Vue!!&quot;,      &#125;;    &#125;,    beforeCreate() &#123;      // 在控制台输出 ： beforeCreate： Hello Vue!!      console.log(&quot;beforeCreate：&quot;, this.message);    &#125;,  &#125;;&lt;/script&gt;&lt;template&gt;  &lt;!--以下代码渲染后效果: &lt;div&gt; Hello Vue!! &lt;/div&gt;--&gt;  &lt;div&gt;&#123;&#123; text &#125;&#125;&lt;/div&gt;&lt;/template&gt;</code></pre><ol start="4"><li>setup() 函数暴露非响应式属性</li></ol><ul><li>以下方式setup()函数对外暴露的属性<strong>非响应式</strong>的，当属性的值发生变化时，页面并不会同步更新。</li></ul><pre><code>&lt;script&gt;  export default &#123;    setup() &#123;      let a = 1;      let b = 2;      function update() &#123;        a = 10;        b = 20;      &#125;      return &#123;        a,        b,        update,      &#125;;    &#125;,  &#125;;&lt;/script&gt;&lt;template&gt;  &lt;div&gt;a的值：&#123;&#123; a &#125;&#125;&lt;/div&gt;  &lt;div&gt;b的值：&#123;&#123; b &#125;&#125;&lt;/div&gt;  &lt;button @click=&quot;update&quot;&gt;更新a,b的值&lt;/button&gt;&lt;/template&gt;</code></pre><ul><li>以上的 a,b 属性都是非响应式的，所以当我们点击按扭时，页面中 a,b 的值并没有变化</li><li>如果想要对外暴露的属性支持响应式，需要用到响应式 API 中的<code>reactive()</code>或<code>ref()</code>方法来实现</li></ul><ol start="5"><li>总结</li></ol><ul><li><code>setup()</code>函数返回值通常是一个对象，这个对象的所有属性会暴露给组件模板和组件实例</li><li><code>setup()</code>函数中的<code>this</code>指向<code>undefined</code></li><li><code>setup()</code>函数会在所有生命周期函数<code>beforeCreate</code>之前被执行。</li><li><code>setup()</code>函数内定义的变量默认为非响应式的，所以对外暴露该属性为非响应式</li></ul><h3 id="二、初始-reactive-与-ref-响应式-API"><a href="#二、初始-reactive-与-ref-响应式-API" class="headerlink" title="二、初始 reactive 与 ref 响应式 API"></a>二、初始 reactive 与 ref 响应式 API</h3><blockquote><p>本小节我们将会初步认识<code>reactive</code>与<code>ref</code>两个响应式 API，掌握他们的基本用法。</p></blockquote><h4 id="初识-reactive-方法"><a href="#初识-reactive-方法" class="headerlink" title="初识 reactive() 方法"></a>初识 reactive() 方法</h4><blockquote><p><code>reactive()</code>方法用来返回一个对象的响应式代理。</p></blockquote><pre><code>const objProxy = reactive(obj); // objProxy为obj对象的响应式代理</code></pre><ul><li>我们通过响应式代理来操作对象的属性，当属性的值发生变化时也会驱动页面视图的更新</li></ul><pre><code>&lt;script&gt;  // 导入reactive方法  import &#123; reactive &#125; from &quot;vue&quot;;  export default &#123;    setup() &#123;      const obj = &#123; a: 1, b: 2 &#125;;      // objProxy 为响应式代理对象      const objProxy = reactive(obj);      console.log(objProxy); // Proxy(Object) &#123;a: 1, b: 2&#125;      function update() &#123;        // 修改对象属性的值        objProxy.a = 10;        objProxy.b = 20;      &#125;      // 将属性暴露给组件实例      return &#123;        objProxy,        update,      &#125;;    &#125;,  &#125;;&lt;/script&gt;&lt;template&gt;  &lt;div&gt;a的值：&#123;&#123; objProxy.a &#125;&#125;&lt;/div&gt;  &lt;div&gt;b的值：&#123;&#123; objProxy.b &#125;&#125;&lt;/div&gt;  &lt;button @click=&quot;update&quot;&gt;更新a,b的值&lt;/button&gt;&lt;/template&gt;</code></pre><blockquote><p>代码分析</p></blockquote><ul><li>以上代码中的<code>objProxy</code>为<code>obj</code>对象的响应式代理对象。</li><li>我们可以通过<code>objProxy.a=10</code> 和<code>objProxy.b=20</code>来为obj对象的 a、b 属性赋值。</li><li>当点击按扭后，会调用 <code>update</code> 方法，更新对象的属性的值。最终 a、b 属性的值从 1，2 修改成 10，20。因为数据是响应式的，所以数据更新后页面视图也发生了更新</li><li>以上过程证明<code>objProxy</code>代理对象具有响应性，所以<code>objProxy</code>为响应式代理对象</li></ul><ol><li>深层响应性<blockquote><p>通过<code>reactive()</code>方法转换的响应式对象是 “深层响应” 的。</p></blockquote></li></ol><ul><li>即不管对象的属性嵌套有多深，都具有响应性，其值发生变化时，页面视图会同步更新。</li></ul><ol start="2"><li>reactive() 无法转换基本数据类型</li></ol><ul><li><code>reactive()</code>方法只能将一个对象转换为一个响应式对象，而不能将一个基本数据类型转换为响应式对象。</li><li>因为<code>reactive()</code>方法的底层采用的是<code>Proxy</code>来实现的，而<code>Proxy</code>只能创建<strong>对象的代理</strong>。</li></ul><ol start="3"><li>reactive() 方法底层实现原理<blockquote><p><code>reactive()</code>方法返回的响应式代理对象本质是<code>Proxy()</code>的实例。</p></blockquote></li></ol><pre><code>const objProxy = reactive(obj);</code></pre><ul><li>以上代码的内部实现如下：（以下为极简版， 主要帮助大家理解响应式代理）</li></ul><pre><code>function reactive(obj) &#123;  // 判断obj是不是对象，是对象才可以利有Proxy实现代理  if (obj !== null &amp;&amp; typeof obj === &quot;object&quot;) &#123;    // objProxy响应式代理对象    return new Proxy(obj, &#123;      // 当访问objProxy对象身上的属性时,get方法会被调用      get(target, key, receiver) &#123;        const res = Reflect.get(target, key, receiver);        track(); // 响应式依赖收集 ,收集属性对应的DOM更新代码        return res;      &#125;,      // 当给objProxy对象向上的属性赋值时，set方法会被调用      set(target, key, value, receiver) &#123;        Reflect.set(target, key, value, receiver);        trigger(); // 触发响应式依赖 更新DOM      &#125;,      // ....    &#125;);  &#125;&#125;</code></pre><h4 id="初识-ref-方法"><a href="#初识-ref-方法" class="headerlink" title="初识 ref() 方法"></a>初识 ref() 方法</h4><blockquote><p>接受一个内部值，返回一个<strong>响应式的</strong>、<strong>可更改的</strong> ref 对象，此对象只有一个指向其内部值的属性<code>.value</code></p></blockquote><ul><li>可更改是指你可以为<code>ref</code>对象的<code>value</code>属性赋予新的值</li><li>响应式是指所有对 <code>.value</code> 的操作都将被追踪，并且写操作会触发与之相关的副作用（DOM 更新）</li></ul><pre><code>&lt;script&gt;  import &#123; ref &#125; from &quot;vue&quot;;  export default &#123;    setup() &#123;      // msg为一个ref对象，并且是响应式的      const msg = ref(&quot;Hello Vue!!&quot;); // &#123;value: &quot;Hello Vue!!&quot;&#125;      // 修改ref对象value属性的值      msg.value = &quot;Hello ref!!&quot;;      return &#123;        msg,      &#125;;    &#125;,  &#125;;&lt;/script&gt;&lt;template&gt; &#123;&#123; msg &#125;&#125; &lt;/template&gt;</code></pre><ul><li>以上代码中的字符串<code>&quot;Hello Vue!!&quot;</code>被<code>ref()</code>方法转换成了一个 <code>ref </code>对象<code>&#123;value: &quot;Hello Vue!!&quot;&#125;</code>。</li><li>当我们修改这 value 属性的值时，页面视图中用到该数据的地方会同步更新</li></ul><ol><li>访问 ref 对象的 value 属性</li></ol><ul><li>在<code>setup()</code>中访问ref对象的value值时，需要<code>.value</code>的形式来访问</li><li>在<strong>组件模板</strong>中访问ref对象的value值时，它会自动<strong>浅层解包</strong>（会自动调用<code>ref.value</code>），因此你无须再在模板中为它写 .value。</li><li>在<strong>选项式 API <strong>中，通过 this 访问 ref 时也会自动</strong>浅层解包</strong></li></ul><table><thead><tr><th>使用场景</th><th>是否自动浅层解包</th></tr></thead><tbody><tr><td>setup()函数</td><td>否</td></tr><tr><td>组件模板</td><td>是</td></tr><tr><td>选项式 API</td><td>是</td></tr></tbody></table><pre><code>&lt;script&gt;  // 导入 ref 方法  import &#123; ref &#125; from &quot;vue&quot;;  export default &#123;    setup() &#123;      // 将&quot;Hello Vue!!&quot; 转换为响应式，可更改的ref对象      const msg = ref(&quot;Hello Vue!!&quot;);      console.log(msg);      console.log(&quot;setup--&quot;, msg.value);      // 更新msg方法      function update() &#123;        // 修改msg的值        msg.value = &quot;Hello ref!!!&quot;;      &#125;      return &#123;        msg,        update,      &#125;;    &#125;,    mounted() &#123;      // msg是一个ref对象，但会自动解包,所以不需要通过this.msg.value来获取值      console.log(&quot;mounted&quot;, this.msg);    &#125;,  &#125;;&lt;/script&gt;&lt;template&gt;  &lt;button @click=&quot;update&quot;&gt;更新&lt;/button&gt;  &lt;!--msg会自动解包，不需要使用 msg.value--&gt;  &lt;div&gt;&#123;&#123; msg &#125;&#125;&lt;/div&gt;&lt;/template&gt;</code></pre><ol start="2"><li>ref() 方法转换对象<blockquote><p><code>ref()</code>方法的参数如果为一个对象（引用类型），则最终返回的<code>ref</code>对象的<code>value</code>属性值为该对象的响应式代理对象。</p></blockquote></li></ol><ul><li>该 ref 对象是一具有<strong>深层响应式</strong>，可更改的ref对象。</li></ul><pre><code>&lt;script&gt;  import &#123; ref &#125; from &quot;vue&quot;;  export default &#123;    setup() &#123;      const obj = &#123; msg: &quot;Hello ref!!&quot; &#125;;      /*        ref的参数为一个对象，先用reactive()方法返回obj的响应式代理对象        然后将该响应式代理对象赋值给到ref对象的value属性。        */      const refProxyObj = ref(obj);      console.log(refProxyObj);      console.log(refProxyObj.value);    &#125;,  &#125;;&lt;/script&gt;</code></pre><blockquote><p>ref()方法的参数如果为一个对象，其内部相当于经历了以下两步：</p></blockquote><ul><li>先用<code>reactive(obj)</code>方法返回obj的响应式代理对象 <code>proxyObj</code></li><li>然后将该响应式代理对象赋值给到 ref 对象的 value 属性，即<code>&#123;value:proxyObj&#125;</code><ul><li>所以最终得到的 ref 对象是一个深层响应式，可更改的ref对象</li></ul></li></ul><blockquote><p>当数据的结构比较深时，深层响应式是非常消耗性能的，因为需要对对象进行深度递归，将每一个被嵌套的属性都转换为响应式。</p></blockquote><ul><li>若要避免这种深层次的转换，请使用<code>shallowRef()</code>来替代。</li></ul><ol start="3"><li>ref() 方法的底层实现<blockquote><p>以上代码中的ref()方法，返回的ref对象，底层实现如下（极简版，不完整，仅供了解思路）</p></blockquote></li></ol><pre><code>function ref(value) &#123;  const refObject = &#123;    get value() &#123;      // 响应式依赖收集 ,收集属性对应的DOM更新代码      track(refObject, &quot;value&quot;);      return value;    &#125;,    set value(newValue) &#123;      value = newValue;      // 触发响应式依赖 更新DOM      trigger(refObject, &quot;value&quot;);    &#125;,  &#125;;  return refObject;&#125;</code></pre><ul><li>当我们访问 ref 对象的 value 属性时，本质是触发了 value 属性的 get 方法。</li><li>当我们给 ref 对象赋值时，本质是触发了 value 属性的 set 方法</li></ul><h3 id="三、深入响应式-API-工具函数（一）"><a href="#三、深入响应式-API-工具函数（一）" class="headerlink" title="三、深入响应式 API - 工具函数（一）"></a>三、深入响应式 API - 工具函数（一）</h3><blockquote><p>通过前面的学习我们知道<code>reactive()</code>方法的返回值为一个对象的<strong>响应式代理</strong></p><ul><li>注：我们将响应式代理对象简称为响应式对象</li></ul></blockquote><h4 id="响应式对象会自动解包-ref-属性"><a href="#响应式对象会自动解包-ref-属性" class="headerlink" title="响应式对象会自动解包 ref 属性"></a>响应式对象会自动解包 ref 属性</h4><blockquote><p>一个响应式对象的属性及嵌套属性的值如果为<code>ref</code>属性，在模板或<code>setup()</code>中使用时，会自动解包，同时保持响应性</p></blockquote><pre><code>&lt;script&gt;  import &#123; reactive, ref &#125; from &quot;vue&quot;;  export default &#123;    setup() &#123;      const age = ref(33);      const userInfo = reactive(&#123;        age, // ref对象        sex: &quot;男&quot;,        test: &#123;          a: &#123;            b: ref(3), // ref对象          &#125;,        &#125;,      &#125;);      function update() &#123;        userInfo.age = 44;         userInfo.sex = &quot;女&quot;;        userInfo.test.a.b = 100; // 深层响应式      &#125;      return &#123;        userInfo,        update,      &#125;;    &#125;,  &#125;;&lt;/script&gt;&lt;template&gt;  &lt;button @click=&quot;update&quot;&gt;更新数据&lt;/button&gt;  &lt;!--userInfo的属性为ref对象时，会自动解包--&gt;  &lt;div&gt;&#123;&#123; userInfo.userName &#125;&#125; -&#123;&#123; userInfo.age &#125;&#125;--&#123;&#123; userInfo.sex &#125;&#125;&lt;/div&gt;  &lt;div&gt;&#123;&#123; userInfo.test.a.b &#125;&#125;&lt;/div&gt;&lt;/template&gt;</code></pre><ul><li><code>reactive()</code>方法用来返回一个对象的响应式代理，想要拿到参数的值，就需要用 <strong>响应式对象打点属性</strong> 的方式获取</li><li>而<code>ref()</code>方法返回一个响应式的、可更改的 <code>ref</code> 对象，其属性为<code>value</code>，<code>ref()</code>的参数变成<code>value</code>的属性值；<code>setup()</code>中获取属性值：<ul><li>参数是基本数据类型：<code>ref对象.value</code></li><li>如果参数是一个对象：<code>ref对象.value.属性名</code></li></ul></li><li>但是，如果一个对象，它的某个属性值为<code>ref</code>类型，那么当这个对象被<code>reactive()</code>后，访问它的<code>ref</code>类型属性值，在模板或<code>setup()</code>中使用时，采取 <strong>响应式对象打点属性</strong> 的方式获取属性值，因为会自动解包</li></ul><h4 id="不能被自动解包的集合"><a href="#不能被自动解包的集合" class="headerlink" title="不能被自动解包的集合"></a>不能被自动解包的集合</h4><blockquote><p>当访问到某个响应式数组或<code>Map</code>这样的原生集合类型中的 ref 元素时，<strong>不会</strong>执行 ref 的解包。</p></blockquote><pre><code>const hobbies = reactive([ref(&quot;音乐&quot;), ref(&quot;阅读&quot;), ref(&quot;跳舞&quot;)]);// 这里需要 .valueconsole.log(hobbies[0].value);const map = reactive(new Map([[&quot;count&quot;, ref(0)]]));// 这里需要 .valueconsole.log(map.get(&quot;count&quot;).value);</code></pre><h4 id="解构响应式对象"><a href="#解构响应式对象" class="headerlink" title="解构响应式对象"></a>解构响应式对象</h4><blockquote><p>如果我们直接利用解构赋值来解构响应式对象</p></blockquote><ul><li>当属性值为基本数据类型或<code>ref</code>对象（解包后为<strong>基本</strong>数据类型）时，解构后会失去响应性</li><li>当属性值为引用数据类型或<code>ref</code>对象（解包后为<strong>引用</strong>数据类型）时，解构后仍保持响应性<ul><li>主要看它解包后的状态</li></ul></li></ul><pre><code>&lt;script&gt;  import &#123; reactive, ref &#125; from &quot;vue&quot;;  export default &#123;    setup() &#123;      // 解构响应式对象      let &#123; a, b, c, d &#125; = reactive(&#123;        a: ref(&quot;a&quot;),        b: ref([&quot;b&quot;]),        c: [&quot;c&quot;],        d: &quot;d&quot;,      &#125;);      console.log(a); // &#39;a&#39; 基本数据类型，失去响应式      console.log(b); // Proxy(Array) &#123;0: &#39;b&#39;&#125; 响应式对象，具有响应性      console.log(c); // Proxy(Array) &#123;0: &#39;c&#39;&#125; 响应式对象，具有响      console.log(d); // &#39;d&#39;  基本数据类型，失去响应式      // 更新数据      function update() &#123;        a = &quot;aa&quot;;        b[0] = &quot;bb&quot;;        c[0] = &quot;cc&quot;;        d = &quot;dd&quot;;      &#125;      return &#123;        a,        b,        c,        d,        update,      &#125;;    &#125;,  &#125;;&lt;/script&gt;&lt;template&gt;  &lt;div&gt;a:&#123;&#123; a &#125;&#125;--b:&#123;&#123; b[0] &#125;&#125;--c:&#123;&#123; c[0] &#125;&#125;--&#123;&#123; d &#125;&#125;&lt;/div&gt;  &lt;button @click=&quot;update&quot;&gt;更新&lt;/button&gt;&lt;/template&gt;</code></pre><blockquote><p>如果解构的响应式对象为数组或 Map 等原生集合类型</p></blockquote><ul><li>只有集合中成员为基本数据类型时会失去响应性</li><li>集合成员为ref类型与引用类型都不会失去响应性，因为ref成员不会自动解包</li></ul><pre><code>&lt;script&gt;  import &#123; reactive, ref &#125; from &quot;vue&quot;;  export default &#123;    setup() &#123;      // 解构响应式对象      let [a, b, c, d] = reactive([ref(&quot;a&quot;), ref([&quot;b&quot;]), [&quot;c&quot;], &quot;d&quot;]);      console.log(a); // &#123;value:&#39;a&#39;&#125; ref对象，具有响应性      console.log(b);       // &#123;value:Proxy(Array)&#123;0:&#39;b&#39;&#125;&#125; ref对象，具有响应性      console.log(c); // Proxy(Array) &#123;0: &#39;c&#39;&#125; 响应式对象，具有响性      console.log(d); // &#39;d&#39;  基本数据类型，失去响应式      // 更新数据      function update() &#123;        a.value = &quot;aa&quot;;        b.value[0] = &quot;bb&quot;;        c[0] = &quot;cc&quot;;        d = &quot;dd&quot;;      &#125;      return &#123;        a,        b,        c,        d,        update,      &#125;    &#125;   &#125;;  &#125;,&#125;;&lt;/script&gt;&lt;template&gt;  &lt;div&gt;a:&#123;&#123; a &#125;&#125;--b:&#123;&#123; b[0] &#125;&#125;--c:&#123;&#123; c[0] &#125;&#125;--&#123;&#123; d &#125;&#125;&lt;/div&gt;  &lt;button @click=&quot;update&quot;&gt;更新&lt;/button&gt;&lt;/template&gt;</code></pre><ul><li>变量 a，b 为 ref 对象，具有响应性</li><li>变量 c 为 proxy 代理对象，具有响应性</li><li>d 变量为基本数据类型，不具有响应性</li><li>所以点击更新按扭后，a,b,c 变量的值更新后，页面也同步更新了<ul><li>那我们如何保持解构后的变量都具有响应性呢 ？这就需要用到接下来讲到的<code>toRef()</code>和&#96;&#96;toRefs<code>()</code>方法</li></ul></li></ul><h4 id="toRef-方法"><a href="#toRef-方法" class="headerlink" title="toRef() 方法"></a>toRef() 方法</h4><blockquote><p>toRef()方法可以<strong>基于响应式对象</strong>上的一个属性，创建一个对应的 ref</p></blockquote><ul><li>这样创建的 ref 与其源属性保持同步：改变源属性的值将更新 ref 的值，反之亦然</li></ul><blockquote><p>语法：</p></blockquote><pre><code>const variable = toRef(proxyObject, key, defaultValue);</code></pre><ul><li><code>proxyObject</code>为响应式对象</li><li><code>key</code>为 响应式对象对应的原对象的属性</li><li><code>defaultValue</code>默认值，当转换对象身上不存在的值是会返回 <code>undefined</code>，如果有默认值，则会使用默认值</li></ul><blockquote><p>代码演示</p></blockquote><pre><code>&lt;script&gt;  import &#123; reactive, toRef &#125; from &quot;vue&quot;;  export default &#123;    setup() &#123;      const obj = &#123; a: 1, b: 2 &#125;;      // objProxy 为响应式代理对象      const objProxy = reactive(obj);      // toRef()方法将对象obj的属性a转换为一个响应式的ref对象 &#123;value:1&#125;      let a = toRef(objProxy, &quot;a&quot;);      console.log(a); // &#123;value:1&#125;      console.log(a.value); // 1      // objProxy.a=10 时，对应a.value的值也变成了10，两者保持同步      objProxy.a = 10;      setTimeout(() =&gt; &#123;        // a.value=100时，对应objProxy.a的值也变成100，两者保持同步        a.value = 100;      &#125;, 2000);      return &#123;        a,      &#125;;    &#125;,  &#125;;&lt;/script&gt;&lt;template&gt;  &lt;div&gt;&#123;&#123; a &#125;&#125;&lt;/div&gt;&lt;/template&gt;</code></pre><ul><li><code>objProxy</code>为<code>obj</code>对象的响应式代理对象；我们要通过<code>objProxy.属性名</code>的方式来获取属性值或者赋值</li><li>但<code>toRef()</code>方法将对象<code>obj</code>的属性<code>a</code>转换为一个响应式的<code>ref</code>对象，可以通过<code>.value</code>的方式取值或赋值</li><li>因此：<code>objProxy.a = 10</code>与<code>a.value = 100</code>最终都会影响到 <code>a</code> 变量的值，也可以说影响到<code>objProxy.a</code>的值，同时都具有响应性</li></ul><ol><li>toRef() 注意事项<blockquote><p><code>toRef()</code>如果传入的对象非响应式的，则返回该对象上指定属性的ref对象。（只做了解）</p></blockquote></li></ol><pre><code>let a = toRef(&#123; a: 1 &#125;, &quot;a&quot;); // &#123;value:1&#125;// 访问a的值console.log(a.value); // 1</code></pre><blockquote><p>当toRef()转换一个对象身上<strong>不存在</strong>的属性时，返回的 ref 对象的 value 值为<code>undefind</code>，可以为其指定默认值</p></blockquote><pre><code>const objProxy = reactive(&#123; a: 1, b: 2 &#125;);let c = toRef(objProxy, &quot;c&quot;);// 访问a的值console.log(c.value); // undefinedc = toRef(objProxy, &quot;c&quot;, &quot;默认值&quot;);console.log(c.value); // 默认值</code></pre><blockquote><p>利用toRef()也可以返回一个只读的ref对象，当我们想创建一个只读的变量时可以使用</p></blockquote><pre><code>import &#123; reactive, toRef &#125; from &quot;vue&quot;;const obj = &#123; a: 1, b: 2 &#125;;// obj为响应式代理对象const objProxy = reactive(obj);// 返回值为只读的ref对象let a = toRef(() =&gt; objProxy);// 访问a的值console.log(a.value);// 以下赋值操作将抛出错误// a.value = &quot;ssss&quot;</code></pre><h4 id="toRefs-方法"><a href="#toRefs-方法" class="headerlink" title="toRefs() 方法"></a>toRefs() 方法</h4><ul><li>将一个响应式对象转换为一个普通对象，这个普通对象的每个属性都是指向源对象相应属性的 ref。</li><li>每个单独的 ref 都是使用<code>toRef()</code>创建的。</li></ul><blockquote><p>语法</p></blockquote><pre><code>toRefs(object); // object为响应式对象</code></pre><ul><li>如果我们想要一次性解构一个响应式对象的所有属性，则可以使用<code>toRefs()</code></li></ul><pre><code>import &#123; reactive, ref, toRefs &#125; from &quot;vue&quot;;export default &#123;  setup() &#123;    const objProxy = reactive(&#123; a: 1, b: 2 &#125;);    const obj = toRefs(objProxy);    console.log(obj); // &#123;a:toRef(objProxy,&quot;a&quot;),b:toRef(objProxy,&quot;b&quot;)&#125;    const &#123; a, b &#125; = obj;    // a,b为ref对象，所以访问需要.value    console.log(a.value, b.value); // 1  2  &#125;,&#125;;</code></pre><blockquote><p>注意事项</p></blockquote><ul><li><code>toRefs</code> 在调用时只会为源对象上可以枚举的属性创建 ref。如果要为可能还不存在的属性创建 ref，请改用 <code>toRef</code></li></ul><h4 id="shallowReactive-方法"><a href="#shallowReactive-方法" class="headerlink" title="shallowReactive() 方法"></a>shallowReactive() 方法</h4><ul><li><code>shallowReactive()</code>相当于是<code>reactive()</code>的浅层作用形式</li><li>也就是<code>shallowReactive()</code>转换的响应式对象只有根级别的属性是响应式的。属性的值会被原样存储和暴露，这也意味着值为 <code>ref</code> 的属性不会被自动解包了</li></ul><h4 id="readonly-方法"><a href="#readonly-方法" class="headerlink" title="readonly() 方法"></a>readonly() 方法</h4><ul><li>接受一个对象 (不论是响应式还是普通的) 或是一个 ref，返回一个原值的只读代理。</li><li>只读代理是深层的：对任何嵌套属性的访问都将是只读的。它的 <code>ref</code> 解包行为与 <code>reactive()</code> 相同，会自动解包，但解包得到的值是只读的。</li><li>要避免深层级的转换行为，请使用 <code>shallowReadonly()</code>作替代</li></ul><pre><code>&lt;script&gt;  import &#123; reactive, readonly &#125; from &quot;vue&quot;;  export default &#123;    setup() &#123;      const proxyObj = reactive(&#123; a: 1, b: &#123; c: 2 &#125; &#125;);      const readonlyObj = readonly(proxyObj);      // 对象属性可读      console.log(readonlyObj.a); // `      console.log(readonlyObj.b.c); // 2      // 以下对象属性赋值失败，同时在控制台抛出错误      readonlyObj.a = 100;      readonlyObj.b.c = 200;    &#125;,  &#125;;&lt;/script&gt;</code></pre><h4 id="isReactive-方法"><a href="#isReactive-方法" class="headerlink" title="isReactive() 方法"></a>isReactive() 方法</h4><blockquote><p>检查一个对象是否是由<code>reactive()</code>或<code>shallowReactive()</code>创建的代理。</p></blockquote><ul><li>返回值为<code>boolean</code>布尔类型值，<code>true</code>表示是，<code>false</code>表示否</li></ul><pre><code>&lt;script&gt;  import &#123; reactive, isReactive, shallowReactive &#125; from &quot;vue&quot;;  export default &#123;    setup() &#123;      const obj = &#123; a: 1 &#125;;      console.log(isReactive(obj)); // false      console.log(isReactive(reactive(obj))); // true      console.log(isReactive(shallowReactive(obj))); // true    &#125;,  &#125;;&lt;/script&gt;</code></pre><h3 id="四、深入响应式-API-工具函数（二）"><a href="#四、深入响应式-API-工具函数（二）" class="headerlink" title="四、深入响应式 API - 工具函数（二）"></a>四、深入响应式 API - 工具函数（二）</h3><h4 id="shallowRef-方法"><a href="#shallowRef-方法" class="headerlink" title="shallowRef() 方法"></a>shallowRef() 方法</h4><ul><li><code>shallowRef()</code>方法相当于<code>ref()</code>的浅层作用形式，只对<code>.value</code>的访问是响应式的，对对象的其它属性值的写操作不支持响应式</li><li>针对大型的数据结构，如果我们确实只需要浅层次的响应式，则可以利用<code>shallowRef()</code>帮助我们提升性能，因为减小了深层次的递归操作。</li></ul><pre><code>&lt;script&gt;  import &#123; ref, shallowRef &#125; from &quot;vue&quot;;  export default &#123;    setup() &#123;      const state = shallowRef(&#123; count: 1 &#125;);      function update1() &#123;        // 不会触发页面的更新        state.value.count = 100;      &#125;      function update2() &#123;        // 会触发页面的更新        state.value = &#123; count: 200 &#125;;      &#125;      return &#123;        state,        update1,        update2,      &#125;;    &#125;,  &#125;;&lt;/script&gt;&lt;template&gt;  &lt;button @click=&quot;update1&quot;&gt;更新1&lt;/button&gt;  &lt;button @click=&quot;update2&quot;&gt;更新2&lt;/button&gt;  &lt;div&gt;&#123;&#123; state.count &#125;&#125;&lt;/div&gt;&lt;/template&gt;</code></pre><ul><li>点击更新 1 并不会触发页面的更新，只有点击更新 2 时，才会触发页面的更新。</li><li>因为 <code>state</code> 是被<code>shallowRef</code>转换的的一个浅层的响应式对象，所以<code>state.value.count = 100</code>并不会触发页面的更新，而<code>state.value = &#123; count: 200 &#125;</code>会触发页面的更新</li></ul><h4 id="isRef-方法"><a href="#isRef-方法" class="headerlink" title="isRef() 方法"></a>isRef() 方法</h4><blockquote><p>检查某个值是否为 ref 对象，如果是返回 true，否则返回 false</p></blockquote><pre><code>import &#123; isRef, ref &#125; from &quot;vue&quot;;export default &#123;  setup() &#123;    console.log(isRef(ref(0))); // true    console.log(isRef(0)); // false  &#125;,&#125;;</code></pre><h4 id="unref-方法"><a href="#unref-方法" class="headerlink" title="unref() 方法"></a>unref() 方法</h4><blockquote><p><code>unref()</code>方法的参数是 ref，则返回 ref 对象的 value 属性值，否则返回参数本身。</p></blockquote><ul><li><code>unref()</code>方法是<code>val = isRef(val) ? val.value : val</code>计算的一个语法糖</li></ul><pre><code>import &#123; isRef, unref, ref &#125; from &quot;vue&quot;;export default &#123;  setup() &#123;    console.log(unref(ref(&quot;Hello&quot;))); // Hello    console.log(unref(&quot;Hello&quot;)); // Hello    console.log(unref(ref(&#123; a: 1, b: 2 &#125;))); // Proxy(Object) &#123;a: 1, b: 2&#125;    console.log(unref(&#123; a: 1, b: 2 &#125;)); // &#123;a: 1, b: 2&#125;  &#125;,&#125;;</code></pre><h4 id="customRef-自定义-ref"><a href="#customRef-自定义-ref" class="headerlink" title="customRef() 自定义 ref"></a>customRef() 自定义 ref</h4><blockquote><p><code>customRef()</code>方法用来创建一个自定义的<code>ref</code>，显式声明对其依赖追踪和更新触发的控制方式。</p></blockquote><ul><li>语法</li></ul><pre><code>let value=0;// 返回值为ref对象const refObj=customRef((track,trigger)=&gt;&#123;    // 返回一个对象    return &#123;        get()&#123;            // 获取ref的值时，会调用get方法            return value;        &#125;,        set(newValue)&#123;            // 修改ref的值时，会调用set方法            value=newValue        &#125;    &#125;&#125;);</code></pre><ul><li>为了帮助大家更好的理解<code>customRef()</code>的用法，大家可以先按以下思路来创建一个自定义的 ref，实现数据与视图的同步更新。</li></ul><blockquote><p>第一步：创建 <code>createRef()</code>函数</p></blockquote><ul><li><code>customRef()</code>方法的返回值为一个<code>ref</code>，该方法接受一个回调函数作为参数。</li><li><code>createRef(value)</code>方法直接将<code>customRef()</code>方法的返回值返回，即返回值为<code>ref</code></li><li>参数<code>value</code>为需要转换为<code>ref</code>的原始值</li><li>以下代码中<code>count</code>为原始值 <code>0</code> 转换后的 <code>ref</code> 对象</li></ul><pre><code>// createRef为自定义创建ref的方法，接受一个参数value，value为需要转换为ref的原始值function createRef(value) &#123;  return customRef(() =&gt; &#123;&#125;);&#125;// 使用createRef将原始值 0 创建成 ref，即count为ref对象const count = createRef(0);</code></pre><blockquote><p>第二步：<code>customRef()</code>回调函数的返回值</p></blockquote><ul><li><code>customRef()</code>方法的回调函数返回一个带 get 和 set 的对象</li><li>当访问 count 的值（<code>count.vaue</code>）时，会调用 get 方法获取到对应的值</li><li>当修改 count 的值（<code>count.value=100</code>）时，会调用 set 方法来更新对应的值</li></ul><pre><code>function createRef(value) &#123;  return customRef(() =&gt; &#123;    return &#123;      // 当访问ref对象的value值时，会调用get方法      get() &#123;        console.log(`get被调用了，此时返回的value值为：$&#123;value&#125;`);        return value;      &#125;,      // 当给ref对象的value重新赋值时，会调用set方法      set(newValue) &#123;        value = newValue;        console.log(`set被调用了，此时value的值更新为：$&#123;value&#125;`);      &#125;,    &#125;;  &#125;);&#125;// 使用createRef将原始值 0 创建成 ref，即count为ref对象const count = createRef(0);// 读取ref中的值console.log(count.value);// 更新ref的value值count.value = 100;</code></pre><blockquote><p>第三步：在组件模板中使用 count</p></blockquote><ul><li>在组件模板中使用自定义的 ref 对象 count</li><li>定义 update 方法，当点击更新按扭时，调用该方法更新 count 的值</li></ul><pre><code>&lt;script&gt;  import &#123; customRef &#125; from &quot;vue&quot;;  export default &#123;    setup() &#123;      function createRef(value) &#123;        return customRef(() =&gt; &#123;          return &#123;            // 当访问ref对象的value值时，会调用get方法            get() &#123;              console.log(`get被调用了，此时返回的value值为：$&#123;value&#125;`);              return value;            &#125;,            // 当给ref对象的value重新赋值时，会调用set方法            set(newValue) &#123;              value = newValue;              console.log(`set被调用了，此时value的值更新为：$&#123;value&#125;`);            &#125;,          &#125;;        &#125;);      &#125;      // 使用createRef将原始值 0 创建成 ref，即count为ref对象      const count = createRef(0);      // 读取ref中的值      console.log(count.value);      function update() &#123;        // 更新ref的value值        count.value = 100;      &#125;      // 对外暴露属性与方法      return &#123;        count,        update,      &#125;;    &#125;,  &#125;;&lt;/script&gt;&lt;template&gt;  &lt;button @click=&quot;update&quot;&gt;更新myRef的值&lt;/button&gt;  &lt;div&gt;myRef的值:&#123;&#123; count &#125;&#125;&lt;/div&gt;&lt;/template&gt;</code></pre><ul><li>当我们点击对应的更新按扭更新count的值为 100 时，set 方法被调用了，<strong>但页面视图并没有同步更新</strong>。</li><li>因为我们并没有在get 中收集依赖（建立对应属性与相关 DOM 的依赖，让 Vue 知道数据更新后要更新那些 DOM）</li><li>也没有在set 方法中触发依赖（根据 get 方法中建立的依赖关系，触发 DOM 的更新）</li></ul><blockquote><p>第四步：customRef()回调函数的track与trigger参数</p></blockquote><ul><li><code>customRef((track, trigger) =&gt; &#123; &#125;)</code>回调函数的两个参数</li><li><code>track()</code>方法用来在 get 方法被调用时，收集依赖</li><li><code>trigger()</code>方法用来在 set 方法被调用时，触发依赖</li></ul><pre><code>&lt;script&gt;  import &#123; customRef &#125; from &quot;vue&quot;;  export default &#123;    setup() &#123;      function createRef(value) &#123;        return customRef((track, trigger) =&gt; &#123;          return &#123;            // 当访问ref对象的value值时，会调用get方法            get() &#123;              console.log(`get被调用了，此时返回的value值为：$&#123;value&#125;`);              track();              return value;            &#125;,            // 当给ref对象的value重新赋值时，会调用set方法            set(newValue) &#123;              value = newValue;              trigger();              console.log(`set被调用了，此时value的值更新为：$&#123;value&#125;`);            &#125;,          &#125;;        &#125;);      &#125;      // 使用createRef将原始值 0 创建成 ref，即count为ref对象      const count = createRef(0);      // 读取ref中的值      console.log(count.value);      function update() &#123;        // 更新ref的value值        count.value = 100;      &#125;      return &#123;        count,        update,      &#125;;    &#125;,  &#125;;&lt;/script&gt;&lt;template&gt;  &lt;button @click=&quot;update&quot;&gt;更新myRef的值&lt;/button&gt;  &lt;div&gt;myRef的值:&#123;&#123; count &#125;&#125;&lt;/div&gt;&lt;/template&gt;</code></pre><blockquote><p>总结：customRef() 方法使用流程</p></blockquote><ul><li>第一步：<ul><li>创建一个自定义函数，该函数接受一个参数，这个参数为需要转换为 ref 的原始值</li><li>函数的返回值为customRef()方法的返回值 ref</li></ul></li></ul><pre><code>function createRef(value) &#123;  return customRef(() =&gt; &#123;&#125;);&#125;</code></pre><ul><li>第二步：<ul><li>创建 customRef 回调函数的返回值，返回值为一个带有 get 和 set 的对象。</li><li>当访问 ref 的 value 值时调用 get 方法，所有在此时需要处理的相关逻辑都可以写在 get 中</li><li>当修改 ref 的 value 值时调用 set 方法，所有在此时需要处理的相关逻辑都可以写在 set 中</li></ul></li></ul><pre><code>function createRef(value) &#123;  return customRef(() =&gt; &#123;    return &#123;      get() &#123;        return value;      &#125;,      set(newValue) &#123;        value = newValue;      &#125;,    &#125;;  &#125;);&#125;</code></pre><ul><li>第三步：<ul><li>在 get 方法返回值前调用track()方法，收集依赖</li><li>在 set 方法更新值之后调用trigger()方法，触发依赖</li></ul></li></ul><pre><code>function createRef(value) &#123;  return customRef((track, trigger) =&gt; &#123;    return &#123;      get() &#123;        track();        return value;      &#125;,      set(newValue) &#123;        value = newValue;        trigger();      &#125;,    &#125;;  &#125;);&#125;</code></pre><blockquote><p>自定义 ref 使用场景</p></blockquote><ul><li>当我们在获取数据或更新数据时需要做一些<strong>额外的操作</strong>，就可以用自定义 ref。</li><li>比如：页面视图的更新并不需要同步更新，而是数据在 200ms 内如果没有连续更新，则再更新视图</li></ul><h4 id="实战应用：自定义防抖-ref"><a href="#实战应用：自定义防抖-ref" class="headerlink" title="实战应用：自定义防抖 ref"></a>实战应用：自定义防抖 ref</h4><blockquote><p>当在输入框中连续输入内容的间隔时间超过500ms，则更新 h3 标签显示的内容，否则不更新</p></blockquote><pre><code>&lt;script&gt;  import &#123; customRef &#125; from &quot;vue&quot;;  export default &#123;    setup() &#123;      function useDebouncedRef(value, delay = 500) &#123;        let timer = null; // 用来保存定时器        return customRef((track, trigger) =&gt; &#123;          return &#123;            get() &#123;              track();              return value;            &#125;,            set(newValue) &#123;              // 间隔时间不够500ms,则清除上一次定时器，重新计时              clearTimeout(timer);              timer = setTimeout(() =&gt; &#123;                value = newValue;                trigger();              &#125;, delay);            &#125;,          &#125;;        &#125;);      &#125;      // 创建 ref      const text = useDebouncedRef(&quot;hello&quot;);      // 对外暴露text      return &#123;        text,      &#125;;    &#125;,  &#125;;&lt;/script&gt;&lt;template&gt;  &lt;input v-model=&quot;text&quot; /&gt;  &lt;h3&gt;&#123;&#123; text &#125;&#125;&lt;/h3&gt;&lt;/template&gt;</code></pre><h3 id="五、setup-函数参数"><a href="#五、setup-函数参数" class="headerlink" title="五、setup() 函数参数"></a>五、setup() 函数参数</h3><h4 id="参数-props"><a href="#参数-props" class="headerlink" title="参数 props"></a>参数 props</h4><ul><li>setup()函数有两个参数，第一个参数是组件的props，和标准的组件一致。</li><li>一个 setup 函数的 props 是响应式的，并且会在传入新的props 时同步更新。</li></ul><pre><code>export default &#123;  props: [&quot;list&quot;, &quot;title&quot;],  setup(props) &#123;    console.log(props.title); // 访问传递的title属性    console.log(props.list); // 访问传递的list属性  &#125;,&#125;;</code></pre><blockquote><p>代码示例</p></blockquote><ul><li>App.vue</li></ul><pre><code>&lt;script&gt;  import &#123; reactive, ref &#125; from &quot;vue&quot;;  import List from &quot;./components/List.vue&quot;;  export default &#123;    setup() &#123;      const list = reactive([&quot;新闻1..&quot;, &quot;新闻2..&quot;, &quot;新闻3..&quot;]);      const title = ref(&quot;新闻标题&quot;);      // 更新方法      function update() &#123;        (title.value = &quot;更新后--标题&quot;), list.push(&quot;新加内容一条&quot;);      &#125;      return &#123;        list,        title,        update,      &#125;;    &#125;,    components: &#123;      List,    &#125;,  &#125;;&lt;/script&gt;&lt;template&gt;  &lt;List :list=&quot;list&quot; :title=&quot;title&quot; @event-update=&quot;update&quot;&gt;&lt;/List&gt;&lt;/template&gt;</code></pre><ul><li>List.vue</li></ul><pre><code>&lt;script&gt;  export default &#123;    props: [&quot;list&quot;, &quot;title&quot;],    emits: [&quot;eventUpdate&quot;],    setup(props) &#123;      setTimeout(() =&gt; &#123;        console.log(props.title); // 访问传递的title属性        console.log(props.list); // 访问传递的list属性      &#125;, 3000);    &#125;,  &#125;;&lt;/script&gt;&lt;template&gt;  &lt;button @click=&quot;$emit(&#39;eventUpdate&#39;)&quot;&gt;更新&lt;/button&gt;  &lt;h3&gt;&#123;&#123; title &#125;&#125;&lt;/h3&gt;  &lt;ul&gt;    &lt;li v-for=&quot;item in list&quot;&gt;&#123;&#123; item &#125;&#125;&lt;/li&gt;  &lt;/ul&gt;&lt;/template&gt;</code></pre><ol><li>解构 props<blockquote><p>通过上面案例我们知道 props 参数的值为一个响应式代理对象，但如果直接解构props部分属性<strong>将失去响应性</strong>。因此推荐通过<code>props.xxx</code>的形式来使用 props</p></blockquote></li></ol><ul><li>如果我们确实需要解构props，但解构后对应变量仍需保持响应性，可以利用<code>toRefs()</code>工具函数来实现</li></ul><pre><code>setup(props) &#123;    let &#123; title, list &#125; = toRefs(props)&#125;</code></pre><ul><li>如果我们需要将 props 中的某一个 prop 传递到外部，并保持其响应性，则可以利用toRef()工具函数来实现</li></ul><pre><code>setup(props) &#123;    let title = toRef(props, &#39;title&#39;)&#125;</code></pre><h4 id="参数-context"><a href="#参数-context" class="headerlink" title="参数 context"></a>参数 context</h4><blockquote><p>传入 setup 函数的第二个参数 context 是一个 Setup 上下文对象。上下文对象暴露了其他一些在 setup 中可能会用到的值。</p><ul><li>如下：</li></ul></blockquote><pre><code>setup(props, context) &#123;    // context是非响应式的普通对象    console.log(&quot;context&quot;, context)    // 透传 Attributes（非响应式的对象（只读），等价于 $attrs）    console.log(&quot;attrs&quot;, context.attrs)    // 插槽（非响应式的对象，等价于 $slots）    console.log(&quot;slots&quot;, context.slots)    // 触发事件（函数）等价于 $emit）    console.log(&quot;emit&quot;, context.emit)    // 暴露组件公共属性（函数）    console.log(&quot;expose&quot;, context.expose)&#125;</code></pre><ul><li>context上下文对象是非响应式的，可以安全地解构</li></ul><pre><code>export default &#123;    // props是响应式的    // attrs,slots非响应式（只读的） emit、expose为函数    setup(props, &#123; attrs, slots, emit, expose &#125;) &#123;        ...    &#125;&#125;</code></pre><ul><li>attrs 和 slots 都是有状态的对象，它们总是会随着组件自身的更新而更新<ul><li>这意味着你应当避免解构它们，并始终通过 <code>attrs.x</code> 或 <code>slots.x</code> 的形式使用其中的属性</li></ul></li></ul><pre><code>/* 不应该解构他们 */setup(props, &#123; attrs, slots, emit, expose &#125;) &#123;    const &#123;xx,xxx&#125;=attrs;    const &#123;xx,xxx&#125;=slots    &#125;</code></pre><h4 id="什么情况下会使用-setup-函数"><a href="#什么情况下会使用-setup-函数" class="headerlink" title="什么情况下会使用 setup() 函数"></a>什么情况下会使用 setup() 函数</h4><blockquote><p>通过前面的学习，我们知道组合式 API 可以与选项式 API 共存，也就是说，我们可以在选项式 API 中使用setup()函数。<br>但在实际开发中，我们并不推荐两种方式混合使用，更希望在项目中选择其中的一种方式来开发。但在以下情况，选项式 API 会与组合式 API 共存。</p></blockquote><ul><li>旧项目改造： 我们在改造旧项目时，旧项目使用的是选项式 API 书写的，但是我们现在想在原来的基础上集成基于组合式 API 的代码。</li><li>非单文件组件： 在非单文件组件中我们想要使用组合使 API 时，就必需要使用到setup()函数。</li></ul><pre><code>// App.jsimport &#123; ref &#125; from &quot;https://unpkg.com/vue@3/dist/vue.esm-browser.js&quot;;export default &#123;  setup() &#123;    const msg = ref(&quot;Hello Vue!!&quot;);    return &#123;      msg,    &#125;;  &#125;,  template: `&lt;div&gt;&#123;&#123;msg&#125;&#125;&lt;/div&gt;`,&#125;;</code></pre><ul><li>对于单文件组件开发中想要使用组合式 API，我们更推荐在<code>&lt;script setup&gt;....&lt;/script&gt;</code>标签中来书写，代码更加简加及符合程序员编写代码的习惯</li></ul><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><blockquote><p>组合式API包括响应式API、生命周期钩子函数、依赖与注入</p></blockquote><h5 id="setup-函数"><a href="#setup-函数" class="headerlink" title="setup()函数"></a>setup()函数</h5><ul><li>所有组合式API都写在<code>setup()</code>函数中</li><li>它的返回值是一个对象<ul><li>组件的模板中可以直接访问该对象的属性</li><li>组件的选项式API中可以通过<code>this</code>打点访问该对象的属性</li></ul></li><li><code>this</code>指向<code>undefined</code>；因此无法访问选项式API中的属性和方法</li><li>执行时机：在<code>beforeCreate()</code>之前自动调用；</li><li>在默认情况下，<code>setup()</code>函数定义的属性都没有响应性</li></ul><h5 id="reactive"><a href="#reactive" class="headerlink" title="reactive()"></a>reactive()</h5><ul><li>用来返回一个<strong>对象</strong>的响应式代理对象，无法转换基本数据类型</li><li>只能通过<code>代理对象.属性名</code>来操作原对象的属性</li><li>返回的响应式代理对象是<strong>深层响应</strong>的</li><li>底层实现：代理对象是<code>Proxy()</code>的实例，该实例上有get和set方法</li><li>如果该参数或者该参数的嵌套属性为<code>ref</code>属性，那么<ul><li>在模板或<code>setup()</code>中使用时会自动解包，可直接通过<code>对象.属性名</code>访问</li><li>同时保持响应性 </li><li>不能自动解包成员为ref属性的响应式数组或者Map，需要通过<code>.value</code>访问</li></ul></li><li>在setup函数中解构响应式对象<ul><li>解包后为基本数据类型的属性值，解构后会失去响应性</li><li>解包后为引用数据类型的属性值，解构后为引用数据类型</li><li>因为ref在setup函数中不会自动解包</li></ul></li></ul><blockquote><p>shallowReactive()方法</p></blockquote><ul><li>相当于是<code>reactive()</code>的浅层作用形式，只有根级别的属性才是响应式的</li><li>因此ref类型的属性值不会自动解包，需要使用<code>.value</code>调用</li></ul><blockquote><p>readonly()</p></blockquote><ul><li>接收一个对象(普通&#x2F;响应式&#x2F;ref)，返回一个原值的只读代理</li><li>只读代理是深层的，对任何嵌套属性的访问都是只读的</li><li>ref解包行为与<code>reactive()</code>相同</li></ul><blockquote><p>isReactive() </p></blockquote><ul><li>检查一个对象是否由<code>reactive()</code>或<code>shallowReactive()</code>创建了代理</li><li>返回值为true时表示是false为不是</li></ul><h5 id="ref-方法"><a href="#ref-方法" class="headerlink" title="ref()方法"></a>ref()方法</h5><ul><li>用来返回一个响应式的、可更改的ref对象，该对象只有一个属性<code>value</code></li><li>访问value属性：<ul><li>在<code>setup()</code>函数内：<code>.value</code></li><li>在模板中：直接使用return出的属性名</li><li>在选项式API中：<code>this.属性名</code></li><li>后两种方式都会自动浅层解包</li></ul></li><li>参数是对象时：<code>&#123;value:reactive(obj)&#125;</code><ul><li>返回的<code>ref</code>对象是一个深层响应的、可更改的ref对象</li><li>返回的<code>ref</code>对象的属性值是一个响应式代理对象</li></ul></li><li>底层实现：创建一个具有get和set属性的对象</li></ul><blockquote><p>toRef()方法</p></blockquote><ul><li><code>const variable = toRef(proxyObject, key, defaultValue);</code></li><li>用于创建一个基于响应式对象的ref属性，并与原属性保持同步</li><li>如果传入的对象不具有响应性，则返回该对象上指定属性的ref对象</li><li>如果指定的属性不存在，将返回undefined或指定的默认值</li><li>如果想创建一个只读的ref对象，就使用箭头函数，将其返回</li></ul><blockquote><p>toRefs() 方法</p></blockquote><ul><li>将一个响应式对象转为成每个成员都是ref属性的普通对象</li></ul><blockquote><p>shallowRef()方法</p></blockquote><ul><li>相当于是ref()的浅层作用形式，只对<code>.value</code>的访问是响应式的，对深层的属性值(<code>.value.属性</code>)不支持响应式</li></ul><blockquote><p>isRef()方法</p></blockquote><ul><li>检查某个值是否为ref对象</li><li>是的话返回true</li></ul><blockquote><p>unref() 方法</p></blockquote><ul><li>unref()方法的参数是 ref，则返回 ref 对象的 <code>value</code> 属性值，否则返回参数本身。</li><li>unref()方法是<code>val = isRef(val) ? val.value : val</code>计算的一个语法糖</li></ul><blockquote><p>customRef()自定义ref</p></blockquote><ul><li>用来创建一个自定义的ref，显示声明对其依赖追踪和更新触发的控制方式</li><li>使用场景：获取数据或更新数据时需要做一些额外操作</li></ul><h5 id="setup-函数参数"><a href="#setup-函数参数" class="headerlink" title="setup()函数参数"></a>setup()函数参数</h5><ul><li><p>第一个参数是组件的<code>props</code>，并且是一个响应式代理对象，会在传入新<code>props</code>时同步更新</p></li><li><p>解构<code>props</code>：使用<code>toRefs()</code>&#x2F;<code>toRef()</code>以保持响应性</p></li><li><p>第二个参数是setup上下文对象<code>context</code>，它是一个非响应式的普通对象</p></li><li><p><code>context</code>暴露了一些值：</p><ul><li><code>context.attrs</code>等价于<code>$attrs</code>，透传属性</li><li><code>context.slots</code>等价于<code>$slots</code>，插槽</li><li><code>context.emit</code>等价于<code>$emit</code>，自定义事件</li><li><code>context.expose</code>用来暴露组件公共属性</li></ul></li><li><p><code>attrs</code>和<code>slots</code>都是代理对象，因此不能解构他们，应当通过打点属性的方式使用其中的属性</p></li></ul><h5 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h5><ul><li>旧项目改造：在选项式API基础上集成组合式API的代码</li><li>非单文件组件</li></ul><h3 id="六、"><a href="#六、" class="headerlink" title="六、"></a>六、<script setup></h3><blockquote><p>在单文件组件中使用组合式 API，需要在<code>&lt;script&gt;</code>标签上添加<code>setup</code>属性。 此时写在<code>&lt;script setup&gt;</code>标签中的代码会被编译成组件<code>setup()</code>函数的内容。</p><ul><li><code>&lt;script setup&gt;</code>是在单文件组件（SFC）中使用组合式 API 的编译时语法糖</li></ul></blockquote><h4 id="的基本用法"><a href="#的基本用法" class="headerlink" title="&lt;script setup&gt;的基本用法"></a><code>&lt;script setup&gt;</code>的基本用法</h4><blockquote><p><code>&lt;script setup&gt;</code>中的<code>this</code>指向与<code>setup()</code>方法中的一样，都指向<code>undefined</code></p></blockquote><pre><code>&lt;script setup&gt;  const count = 0;  console.log(this); // undefined&lt;/script&gt;</code></pre><ul><li>在 <code>&lt;script setup&gt; </code>声明的顶层的绑定（包括变量，函数声明，以及 <code>import</code> 导入的内容）都能在模板中直接使用</li></ul><pre><code>&lt;script setup&gt;  // 导入求和的方法 sum(2,3) 输出5  import sum from &quot;./sum.js&quot;;  // 变量  const count = 0;  // 方法  function sayHello() &#123;    return &quot;Hello Vue~~&quot;;  &#125;&lt;/script&gt;&lt;template&gt;  &lt;div&gt;count:&#123;&#123; count &#125;&#125;&lt;/div&gt;  &lt;div&gt;&#123;&#123; sayHello() &#125;&#125;&lt;/div&gt;  &lt;div&gt;2+3=&#123;&#123; sum(2, 3) &#125;&#125;&lt;/div&gt;&lt;/template&gt;</code></pre><blockquote><p>注意事项</p><ul><li>在 <code>&lt;script setup&gt;</code> 中创建的变量<strong>不会</strong>作为属性添加到组件实例中。</li><li>如果在某些情况下确实需要从选项式 API 中访问到<code>&lt;script setup&gt;</code>中的变量，建议切换到<code>setup()</code>函数写法</li></ul></blockquote><h4 id="响应式数据"><a href="#响应式数据" class="headerlink" title="响应式数据"></a>响应式数据</h4><ul><li>在 <code>&lt;script setup&gt;</code> 中声明的顶层变量并不是响应式的，需要借助响应式 API（如<code>ref()</code>或<code>reactive()</code>）方法来创建响应式变量</li><li>如果变量为<code>ref</code>对象，在模板中直接使用时会自动解包，这一特点与<code>setup()</code>函数中是一样的</li></ul><pre><code>&lt;script setup&gt;  import &#123; ref &#125; from &quot;vue&quot;;  // 导入求和的方法 sum(2,3) 输出5  import sum from &quot;./sum.js&quot;;  // 变量  const count = ref(0);  // 函数  function add() &#123;    count.value++; // ref对象需要打点vaule属性访问值  &#125;&lt;/script&gt;&lt;template&gt;  &lt;button @click=&quot;add&quot;&gt;count+1&lt;/button&gt;  &lt;!--count会自动解包--&gt;  &lt;div&gt;&#123;&#123; count &#125;&#125; --&#123;&#123; sum(2, 3) &#125;&#125;&lt;/div&gt;&lt;/template&gt;</code></pre><h4 id="使用组件"><a href="#使用组件" class="headerlink" title="使用组件"></a>使用组件</h4><blockquote><p>在<code>&lt;script setup&gt;</code>中直接通过<code>import</code>导入需要的组件，然后该组件就可以直接在模板中通过标签名使用</p></blockquote><pre><code>&lt;script setup&gt;  import &#123; defineAsyncComponent &#125; from &quot;vue&quot;;  // 导入组件  import List from &quot;./components/List.vue&quot;;  // 定义一个异步组件  const AsyncComp = defineAsyncComponent(() =&gt;    import(&quot;./components/AsyncComp.vue&quot;)  );&lt;/script&gt;&lt;template&gt;  &lt;!--使用组件--&gt;  &lt;List /&gt;  &lt;AsyncComp /&gt;&lt;/template&gt;</code></pre><ul><li>对于全局组件可以通过组件名直接在模板中使用</li></ul><h4 id="动态组件"><a href="#动态组件" class="headerlink" title="动态组件"></a>动态组件</h4><blockquote><p>在<code>&lt;script setup&gt;</code>中组件是通过变量引用而不是基于字符串组件名注册<br>所在模板中使用<code>&lt;component&gt;</code>动态组件时，<code>:is</code>的值可以直接是组件定义。</p></blockquote><pre><code>&lt;script setup&gt;  import &#123; shallowRef &#125; from &quot;vue&quot;;  import A from &quot;./components/A.vue&quot;;  import B from &quot;./components/B.vue&quot;;  /*    我们在更新currentComp的值时，只会用一个新的组件替换现有组件，并不会去更新组件中的内容,    即currentComp只需要做浅层响应性,并不需要做深层响应性，所以选择用shallowRef而不是ref，    */  const currentComp = shallowRef(A);&lt;/script&gt;&lt;template&gt;  &lt;button @click=&quot;currentComp = A&quot;&gt;A组件&lt;/button&gt;  &lt;button @click=&quot;currentComp = B&quot;&gt;B组件&lt;/button&gt;  &lt;br /&gt;  &lt;br /&gt;  &lt;component :is=&quot;currentComp&quot;&gt;&lt;/component&gt;&lt;/template&gt;</code></pre><h4 id="计算属性-computed"><a href="#计算属性-computed" class="headerlink" title="计算属性 computed"></a>计算属性 computed</h4><ul><li>在组合式 API 中使用计算属性，需要借助 Vue 为我们提供的<code>computed()</code>方法</li><li><code>computed()</code>方法接受一个 <code>getter</code> 函数，返回值为一个计算属性 ref，计算属性在模板中使用时会自动解包</li></ul><pre><code>&lt;script setup&gt;  import &#123; computed, ref &#125; from &quot;vue&quot;;  const price = ref(10.0);  // newPrice为计算属性，是一个ref对象  const newPrice = computed(() =&gt; &#123;    return price.value + &quot;元&quot;;  &#125;);  console.log(newPrice.value); // 10元&lt;/script&gt;&lt;template&gt;  &lt;!--newPrice 会自动解包，所以不用newPrice.value--&gt;  &lt;div&gt;&#123;&#123; newPrice &#125;&#125;&lt;/div&gt;&lt;/template&gt;</code></pre><ul><li>如果计算属性需要可写，则<code>computed()</code>方法接受一个带有<code>getter</code>和<code>setter</code>的对象作为参数。</li><li>当读取计算属性时会调用<code>getter</code>方法，为计算属性赋值时，会调用<code>setter</code>方法</li></ul><pre><code>&lt;script setup&gt;  import &#123; computed, ref &#125; from &quot;vue&quot;;  // tip为计算属性  const tip = computed(&#123;    get() &#123;      console.log(&quot;读取了内容&quot;);    &#125;,    set(value) &#123;      console.log(&quot;更新了内容&quot;);    &#125;,  &#125;);&lt;/script&gt;&lt;template&gt;  &lt;input type=&quot;text&quot; v-model=&quot;tip&quot; /&gt;&lt;/template&gt;</code></pre><h3 id="七、侦听器-watch"><a href="#七、侦听器-watch" class="headerlink" title="七、侦听器 watch"></a>七、侦听器 watch</h3><ol><li>watch 方法的基本使用<blockquote><p>在组合式 API 中，我们需要使用 Vue 提供的watch()函数来侦听一个或多个响应式数据源的变化，并在数据源变化时调用所给的回调函数。</p></blockquote></li></ol><ul><li>语法</li></ul><pre><code>watch(source, callback, options);</code></pre><blockquote><p>参数详解</p></blockquote><ul><li><code>source</code>： 侦听的 “数据源”，他可以是以下几种形式<ul><li>一个响应式对象（reactive()创建的对象）</li><li>一个 ref 对象（ref()方法创建的对象）</li><li>一个 getter 函数，返回一个值（可以用来监听一个对象属性）</li><li>或以上类型值组成的一个数组</li></ul></li><li><code>callback</code>：侦听的数据源发生变化时要调用的回调函数。这个回调函数接受三个参数<ul><li>第一个参数<code>newValue</code>，表示数据源的新值</li><li>第二个参数<code>oldValue</code>，表示数据源的旧值</li><li>第三个参数<code>onCleanup</code> ，一个用于注册副作用清理的回函数，该回调会在下一次数据源变化调用 callback 函数前调用<br>-<code> options</code>: 是一个可选的配置参数对象，支持以下选项</li><li><code>immediate</code>当值为 true 时，在侦听器创建时立即触发回调 ，默认情况下是 false</li><li><code>deep</code>如果数据源是对象，强制深度遍历，以便在深层级变更时触发回调</li><li><code>flush</code>：调整回调函数的刷新时机，<code>flush:&#39;post&#39;</code>表示在 Vue 更新之后 DOM 之后调用侦听器回调，可以侦听器回调中访问到 Vue 更新之后的 DOM</li></ul></li></ul><ol start="2"><li>侦听数据源<blockquote><p>侦听的 “数据源”，他可以是以下几种形式</p></blockquote></li></ol><ul><li>一个响应式对象 （reactive()创建的对象）</li><li>一个 getter 函数，返回一个值 （可以用来监听一个对象属性）</li><li>一个 ref 对象（ref()方法创建的对象）</li><li>或以上类型值组成的一个数组</li></ul><blockquote><p>侦听响应式对象</p></blockquote><ul><li>数据源是一个响应式对象，默认是<strong>深层侦听器</strong></li></ul><pre><code>&lt;script setup&gt;  import &#123; reactive, watch &#125; from &quot;vue&quot;;  const state = reactive(&#123;    count: &#123;      a: &#123;        c: 0,      &#125;,    &#125;,  &#125;);  setTimeout(() =&gt; &#123;    // 只要是该对象的属性（或嵌套属性）的值变化了，侦听器都能侦听到    state.count.a.c = 100;  &#125;, 3000);  // 侦听state响应式对象 默认是深层侦听  watch(state, (newValue, oldValue) =&gt; &#123;    console.log(&quot;count的值更新为&quot;, newValue);  &#125;);&lt;/script&gt;&lt;template&gt;  &lt;div&gt;&#123;&#123; state.count.a.c &#125;&#125;&lt;/div&gt;&lt;/template&gt;</code></pre><blockquote><p>侦听 ref 对象</p></blockquote><ul><li>数据源是一个 ref 对象，默认是浅层侦听，添加<code>deep:true</code>配置可以开启深侦听</li></ul><pre><code>&lt;script setup&gt;  import &#123; reactive, watch, ref &#125; from &quot;vue&quot;;  const state = ref(&#123;    count: &#123;      a: &#123;        c: 0,      &#125;,    &#125;,  &#125;);  // 如果watch中不添加deep:true配置，则以下修改没有办法被侦听到  setTimeout(() =&gt; &#123;    state.value.count.a.c = 100;  &#125;, 3000);  // 以下修改可以被正常侦听到  setTimeout(() =&gt; &#123;    state.value = 100;  &#125;, 4000);  watch(    state,    (newValue, oldValue) =&gt; &#123;      console.log(&quot;c的值更新为&quot;, newValue);    &#125;,    &#123; deep: true &#125;  );&lt;/script&gt;</code></pre><blockquote><p>侦听响应式对象的属性</p></blockquote><ul><li>你不能直接侦听响应式对象的属性值，需要通过 <code>getter</code> 函数返回该响应式对象的属性才可以。</li></ul><pre><code>import &#123; reactive, watch &#125; from &quot;vue&quot;;const state = reactive(&#123; count: &#123; a: 1 &#125; &#125;);// 下面为错误写法，无法侦听到state的count属性watch(state.count, (newValue, oldValue) =&gt; &#123;  // .....&#125;);// 以下为正确写法  侦听state对象的count属性watch(  () =&gt; state.count,  (newValue, oldValue) =&gt; &#123;    // .....  &#125;);</code></pre><ul><li>以上方式默认是浅侦听，侦听的回调函数只在对象的该属性值发生变化时才会触发。添加<code>deep:true</code>配置可以开启深侦听</li></ul><pre><code>&lt;script setup&gt;  import &#123; reactive, watch &#125; from &quot;vue&quot;;  const state = reactive(&#123; count: &#123; a: 1 &#125; &#125;);  // 添加 deep: true 配置时，以下修改可以被侦听器侦听到，否则侦听不到  setTimeout(() =&gt; &#123;    state.count.a = 100;  &#125;, 3000);  // 侦听state对象的count属性  watch(    () =&gt; state.count,    (newValue, oldValue) =&gt; &#123;      console.log(&quot;count的值更新为&quot;, newValue);    &#125;,    &#123;      deep: true, // 开启深层侦听    &#125;  );&lt;/script&gt;&lt;template&gt;  &lt;div&gt;&#123;&#123; state.count.a &#125;&#125;&lt;/div&gt;&lt;/template&gt;</code></pre><ul><li>以上代码，如果不添加<code>deep:true</code>配置项，当通过<code>state.count.a=100</code>来修改 a 的值时，侦听器是没有办法侦听到的。</li></ul><blockquote><p>侦听一个数组</p></blockquote><ul><li>数据源是由<code>getter</code>函数、<code>ref</code>对象、<code>reactive</code>对象 类型值组成的一个数组，会侦听该数组中的每个成员的变化。</li><li>如果成员是getter函数和ref对象，默认是浅侦听</li><li>如果是响应式对象，默认是深层侦听</li><li>侦听器回调函数的参数 newValue 和 oldValue 值为一个数组，数组中的每个成员对应数据源中每个成员的当前值和变化前值。</li></ul><pre><code>&lt;script setup&gt;  import &#123; reactive, watch, ref &#125; from &quot;vue&quot;;  const msg = ref(&quot;Hello Vue&quot;);  const state = reactive(&#123; count: &#123; a: 1 &#125; &#125;);  let num = ref(&#123; a: 1 &#125;);  const obj = reactive(&#123; a: &#123; b: 2 &#125; &#125;);  setTimeout(() =&gt; &#123;    num.value.a = 100; // 侦听器侦听不到    num.value = &#123; a: 100 &#125;; // 侦听器能侦听到  &#125;, 2000);  setTimeout(() =&gt; &#123;    msg.value = &quot;Hello watch&quot;; // 侦听器能侦听到  &#125;, 3000);  setTimeout(() =&gt; &#123;    state.count.a = 100; // 侦听器能侦听到  &#125;, 4000);  setTimeout(() =&gt; &#123;    obj.a = &#123; b: 100 &#125;; // 侦听器能侦听到    obj.a.b = 200; // 侦听器侦听不到  &#125;, 4000);  /**   *  num.value 是浅侦听  只有num.value的值变化才能侦听到   *  msg 是浅侦听，只有msg.value的值变化才能侦听到   *  state 深侦听，state的属性或嵌套属性都能侦听到   *  obj.a是浅侦听，只有obj.a的值变化才能侦听到，其内部属性变化不能侦听   */  watch([() =&gt; num.value, msg, state, () =&gt; obj.a], (newValue, oldValue) =&gt; &#123;    console.log(&quot;数组的值更新为&quot;, newValue);  &#125;);&lt;/script&gt;&lt;template&gt;&lt;/template&gt;</code></pre><ol start="3"><li>副作用清理</li></ol><ul><li>在某些场景下，当监听的数据源发生变化时，就会向后台发起请求，如果数据在请求还没有回来时，数据源变化了 5 次，那就会向后台发送 5 次请求，完全是没有必要的。</li><li>所以我们需要在上一次请求没有回来前，如果数据又发生了变化，则把上一次的请求取消，再重新发送一次请求。</li></ul><pre><code>&lt;script setup&gt;  import &#123; watch, ref &#125; from &quot;vue&quot;;  const count = ref(0);  // 侦听器，侦听属性count  watch(count, (newValue, oldValue, onCleanup) =&gt; &#123;    console.log(`数据变化了从$&#123;oldValue&#125; ==&gt; $&#123;newValue&#125;`);    // 模拟发送请求    let timer = setTimeout(() =&gt; &#123;      console.log(&quot;发起请求......&quot;);    &#125;, 3000);    // 取消请求的方法    function cancle() &#123;      console.log(&quot;取消请求&quot;);      clearTimeout(timer);    &#125;    // 清理副作用的回调函数    onCleanup(cancle);  &#125;);&lt;/script&gt;&lt;template&gt;  &lt;button @click=&quot;count++&quot;&gt;更新&lt;/button&gt;&lt;/template&gt;</code></pre><ol start="4"><li>options 配置项<blockquote><p>关于options配置项中每一项配置的含义，与前面讲的项选项式 API 中watch是一样的。</p></blockquote></li></ol><ul><li>immediate 当值为 true 时，在侦听器创建时立即触发回调 ，默认情况下是 false</li><li>deep 如果数据源是对象，强制深度遍历，以便在深层级变更时触发回调</li><li>flush：调整回调函数的刷新时机，flush:'post'表示在 Vue 更新之后 DOM 之后调用侦听器回调，可以侦听器回调中访问到 Vue 更新之后的 DOM<ul><li>具体用法可以参考选项式 API：侦听器配置选项</li></ul></li></ul><ol start="5"><li>停止侦听器<blockquote><p>在<code>setup()</code>或<code>&lt;script setup&gt;</code>中用<strong>同步语句</strong>创建的侦听器，会自动绑定到宿主组件实例上，并且会在宿主组件卸载时自动停止。因此，在大多数情况下，你无需关心怎么停止一个侦听器。</p><p>如果用<strong>异步回调</strong>创建一个侦听器，那么它不会绑定到当前组件上，你必须手动停止它，以防内存泄漏</p></blockquote></li></ol><ul><li>同步语句中创建的侦听器，在组件实例被销毁时自动停止</li></ul><pre><code>watch(count, (newValue, oldValue) =&gt; &#123;  // ...&#125;);异步回调创建一个侦听器，在组件实例即将销毁前，手动停止let unwatch = null;setTimeout(() =&gt; &#123;  unwatch = watch(count, (newValue, oldValue) =&gt; &#123;    // ....  &#125;);&#125;);// 在组件实例即将销毁前，停止候听器onBeforeUnmount(() =&gt; &#123;  console.log(&quot;组件即将销毁&quot;);  // 停止侦听器  unwatch();&#125;);</code></pre><h3 id="八、watchEffect-方法"><a href="#八、watchEffect-方法" class="headerlink" title="八、watchEffect() 方法"></a>八、watchEffect() 方法</h3><ol><li>watchEffect() 的基本使用<blockquote><p><code>watchEffect()</code>方法一旦被调用，会<strong>立即</strong>运行其回调函数，同时响应式地追踪其依赖，并在依赖更改时重新执行。</p></blockquote></li></ol><pre><code>function watchEffect(  effect: (onCleanup: OnCleanup) =&gt; void, //  运行副作用函数  options?: WatchEffectOptions // 可选的配置选项): StopHandle;interface WatchEffectOptions &#123;  flush?: &quot;pre&quot; | &quot;post&quot; | &quot;sync&quot;; // 默认：&#39;pre&#39;  onTrack?: (event: DebuggerEvent) =&gt; void;  onTrigger?: (event: DebuggerEvent) =&gt; void;&#125;</code></pre><blockquote><p>参数详解</p></blockquote><ul><li>第一个参数是要运行的副作用函数。这个副作用函数的参数也是一个函数，用来注册清理回调。清理回调会在该副作用下一次执行前被调用，可以用来清理无效的副作用，例如等待中的异步请求</li><li>第二个参数是一个可选的选项，可以用来调整副作用的刷新时机或调试副作用的依赖。<ul><li><code>flush:&#39;post&#39;</code>默认情况下，侦听器将在组件渲染之前执行。设置<code>flush: &#39;post&#39;</code>将会使侦听器延迟到组件渲染之后再执行</li><li><code>onTrack</code>将在响应属性或引用作为依赖项被跟踪时被调用。</li><li><code>onTrigger</code>将在侦听器回调被依赖项的变更触发时被调用</li></ul></li></ul><blockquote><p>注意与watch对比：</p></blockquote><ul><li><code>watch()</code>方法是惰执行的，只在数据更新时才会执行，即第一次初始化时并不会侦听，除非添加了<code>immediate: true</code>配置</li></ul><ol start="2"><li>侦听器调试<blockquote><p>如果我们想要对侦听器做调试，可以向 <code>watchEffect()</code> 传入第二个参数，是一个包含了 <code>onTrack</code> 和 <code>onTrigger</code> 两个回调函数的对象。</p></blockquote></li></ol><ul><li><code>onTrack</code>将在响应属性或引用作为依赖项被跟踪时被调用。</li><li><code>onTrigger</code>将在侦听器回调被依赖项的变更触发时被调用。</li><li>侦听器的 <code>onTrack</code> 和 <code>onTrigger</code> 选项仅会在开发模式下工作。</li></ul><pre><code>&lt;script setup&gt;  import &#123; ref, watchEffect &#125; from &quot;vue&quot;;  const a = ref(2);  const b = ref(3);  watchEffect(    () =&gt; &#123;      console.log(`$&#123;a.value&#125;+$&#123;b.value&#125;=$&#123;a.value + b.value&#125;`);    &#125;,    &#123;      onTrack(e) &#123;        // 当读取a和b的值时触发，即： a.value  b.value        console.log(&quot;track&quot;);        debugger;      &#125;,      onTrigger(e) &#123;        // 当a和b的值发生变化时触发 即 a.value=20 b.value=20        console.log(&quot;trigger&quot;);        debugger;      &#125;,    &#125;  );&lt;/script&gt;&lt;template&gt;  &lt;div&gt;a: &lt;input type=&quot;text&quot; v-model.number=&quot;a&quot; /&gt;&lt;/div&gt;  &lt;div&gt;b: &lt;input type=&quot;text&quot; v-model.number=&quot;b&quot; /&gt;&lt;/div&gt;&lt;/template&gt;</code></pre><ul><li>更多响应性调试，查阅 Vue 官方文档：<a href="https://cn.vuejs.org/guide/extras/reactivity-in-depth.html#reactivity-debugging">响应性调试</a></li></ul><ol start="3"><li>副作用清除</li></ol><ul><li><code>watchEffect</code>回调函数的第一个参数<code>onCleanup</code>为副作用清除函数，<code>onCleanup</code>函数接收一个函数作为参数，该参数会在下一次回调函数调用前执行。</li></ul><pre><code>watchEffect((onCleanup) =&gt; &#123;  // 取消定时器或取消请求等操作  function cancle() &#123;&#125;  // cancle 函数会在下一次回调函数调用前执行  onCleanup(cancle);&#125;);</code></pre><ol start="4"><li>停止侦听器<blockquote><p>停止侦听器的方式和watch方法一样。</p></blockquote></li></ol><ul><li>具体如下：</li></ul><pre><code>const stop = watchEffect(() =&gt; &#123;&#125;);// 停止侦听器stop();</code></pre><ol start="5"><li>watch() 与 watchEffect() 对比<blockquote><p>watch()侦听器特点</p></blockquote></li></ol><ul><li>默认是懒侦听的，即仅在侦听源发生变化时才执行回调函数，设置<code>immediate: true</code>时可以变为非惰性，页面首次加载就会执行</li><li>需要指定侦听的数据源，并且只在该数据源发生变化时，才会执行</li><li>可以获取数据变化前后的值</li></ul><blockquote><p><code>watchEffect()</code>侦听器特点</p></blockquote><ul><li><code>watchEffect()</code>立即执行，没有惰性，页面首次加载就会执行</li><li><code>watchEffect()</code>不需要指定侦听的数据源，会自动收集依赖数据，依赖数据更新时重新执行自身</li><li>无法获取到变化前的原始值，只能得到变化后的值</li></ul><ol start="6"><li>axios 取消请求<blockquote><p>副作用清理函数常用来取消上一次请求，所以接下来，我们先来学习下如何在 axios 中取消上一次请求。</p></blockquote></li></ol><ul><li>在 axios 中取消上一次请求相关代码，具体参考：<a href="https://www.axios-http.cn/docs/cancellation">axios 取消请求</a>与 AbortController - <a href="https://developer.mozilla.org/zh-CN/docs/Web/API/AbortController">Web API 接口参考 | MDN (mozilla.org)</a></li><li>从 v0.22.0 开始，Axios 支持以 fetch API 方式 —— <code>AbortController</code>取消请求，该请求一旦被取消将不能被再发起。</li></ul><pre><code>// controller表示一个控制器对象，允许你根据需要中止一个或多个 Web 请求。const controller = new AbortController();axios  .get(&quot;/foo/bar&quot;, &#123;    // controller的只读属性signal 返回一个 AbortSignal 实例对象，该对象可以根据需要处理 DOM 请求通信，既可以建立通信，也可以终止通信。    signal: controller.signal,  &#125;)  .then(function (response) &#123;    //...  &#125;)  .catch(() =&gt; &#123;    console.log(&quot;请求失败&quot;);  &#125;);// 中止一个尚未完成的 Web（网络）请求controller.abort();</code></pre><blockquote><p>代码示例</p></blockquote><ul><li>当点击发送请求按扭后，会开始发起两个请求，如果请求还没有回来时，点击了取消请求按扭，则会同时把两个请求都取消。</li></ul><pre><code>&lt;script setup&gt;  import axios from &quot;axios&quot;;  import &#123; ref &#125; from &quot;vue&quot;;  // 请求地址  const url =    &quot;https://www.fastmock.site/mock/6ec78e345df340241e1f5043f0167833/icode/menu/&quot;;  // 请求ID  const paramId = ref(1001);  let controller = null;  // 发送请求  function onSend() &#123;    controller = new AbortController();    axios      .get(`$&#123;url&#125;+$&#123;paramId.value&#125;`, &#123;        signal: controller.signal,      &#125;)      .then((res) =&gt; &#123;        console.log(&quot;请求成功内容：&quot;);        // 处理请求回来的内容        console.log(res.data);      &#125;)      .catch(() =&gt; &#123;        console.log(&quot;请求失败&quot;);      &#125;);    axios      .get(`$&#123;url&#125;+$&#123;paramId.value&#125;`, &#123;        signal: controller.signal,      &#125;)      .then((res) =&gt; &#123;        console.log(&quot;请求成功内容：&quot;);        // 处理请求回来的内容        console.log(res.data);      &#125;)      .catch(() =&gt; &#123;        console.log(&quot;请求失败&quot;);      &#125;);  &#125;  function onAbort() &#123;    // 取消请求 （多个请求）    controller.abort();  &#125;&lt;/script&gt;&lt;template&gt;  &lt;button @click=&quot;onSend&quot;&gt;发起请求&lt;/button&gt;  &lt;button @click=&quot;onAbort&quot;&gt;取消请求&lt;/button&gt;&lt;/template&gt;</code></pre><ol start="7"><li>实战应用</li></ol><ul><li>以下示例展示了 paramId 变量的数据发生变化时，会发送 Ajax 请求。</li><li>但是在请求数据还没有回来前 paramId 变值的值再次发生变化时，就会把上一次请求取消，然后重新发送一次请求。</li></ul><pre><code>&lt;script setup&gt;  import axios from &quot;axios&quot;;  import &#123; reactive, ref, watch, watchEffect &#125; from &quot;vue&quot;;  // 请求地址  const url =    &quot;https://www.fastmock.site/mock/6ec78e345df340241e1f5043f0167833/icode/menu/&quot;;  // 请求参数  const paramId = ref(1001);  // 接受请求回来的数据 (数组)  const list = ref(null);  let controller = null;  // 一上来，就发一个请求获取数据  watchEffect((onCleanup) =&gt; &#123;    // AbortController 接口表示一个控制器对象，允许你根据需要中止一个或多个 Web 请求。    controller = new AbortController();    // 可以发请求    axios      .get(`$&#123;url&#125;$&#123;paramId.value&#125;`, &#123;        // 配置取消请求        signal: controller.signal,      &#125;)      .then((res) =&gt; &#123;        list.value = res.data.data;        console.log(list.value);      &#125;)      .catch((error) =&gt; &#123;        console.log(&quot;请求失败&quot;);      &#125;);    // 取消请求    function cancel() &#123;      console.log(&quot;用户取消请求&quot;);      controller.abort();    &#125;    // 在下一次执行前，会调用传入的cancle取消上一次请求    onCleanup(cancel);  &#125;);&lt;/script&gt;&lt;template&gt;  &lt;!-- 菜单 --&gt;  &lt;button @click=&quot;paramId = 1001&quot;&gt;菜单1&lt;/button&gt; |  &lt;button @click=&quot;paramId = 1002&quot;&gt;菜单2&lt;/button&gt; |  &lt;button @click=&quot;paramId = 1003&quot;&gt;菜单3&lt;/button&gt;  &lt;ul&gt;    &lt;li v-for=&quot;item in list&quot; :key=&quot;item.id&quot;&gt;&#123;&#123; item.productName &#125;&#125;&lt;/li&gt;  &lt;/ul&gt;&lt;/template&gt;</code></pre><h3 id="九、自定义指令"><a href="#九、自定义指令" class="headerlink" title="九、自定义指令"></a>九、自定义指令</h3><ul><li>在全局注册的自定义指令，在任意组件的模板中可以直接使用。</li><li>在<code>&lt;script setup&gt;</code>中不需要显式注册局部指令，如果一个变量的命名遵循<code>vNameOfDirective</code>这样的规范，Vue 会自动把他当作一条指令来执行。</li><li>指令的值和用法与选项式 API 中一模一样，具体可参考选项式 API</li></ul><pre><code>&lt;script setup&gt;  // 定义一条指令 v-my-directive  ,以下是对象的完整写法  const vMyDirective = &#123;    mounted(el, binding) &#123;&#125;,    updated(el, binding) &#123;&#125;,  &#125;;  // 定义一条指令v-focus,以下是函数简写形式  const vFocus = (el, binding) =&gt; &#123;&#125;;&lt;/script&gt;&lt;template&gt;  &lt;!--使用指令--&gt;  &lt;div v-my-directive&gt;&lt;/div&gt;  &lt;input type=&quot;text&quot; v-focus /&gt;&lt;/template&gt;</code></pre><ul><li>如果指令是从别处导入的，可以通过重命名来使其符合命名规范</li></ul><pre><code>import &#123; focus as vFocus &#125; from &quot;./focus.js&quot;;// focus.js内容如下const focus = (el, binding) =&gt; &#123;  /* ...... */&#125;;export &#123; focus &#125;;</code></pre><blockquote><p>代码示例</p></blockquote><ul><li>自定义<code>v-focus</code>指令，单行文本框在添加该指令后，会自获取焦点同时背景色变蓝色。</li></ul><pre><code>&lt;script setup&gt;  import &#123; ref &#125; from &quot;vue&quot;;  const msg = ref(&quot;Hello&quot;);  const vFocus = &#123;    mounted(el, binding) &#123;      el.focus();      el.style.border = &quot;none&quot;;      el.style.backgroundColor = &quot;skyblue&quot;;    &#125;,  &#125;;  // 以下是函数简写形式,当 mounted 与 updated 效果一样时，可采用函数简写形式  /*    const vFocus = (el, binding) =&gt; &#123;      el.focus();      el.style.border = &quot;none&quot;;      el.style.backgroundColor = &quot;skyblue&quot;    &#125;    */&lt;/script&gt;&lt;template&gt;  &lt;input type=&quot;text&quot; v-focus v-model=&quot;msg&quot; /&gt;&lt;/template&gt;</code></pre><h3 id="十、模板引用"><a href="#十、模板引用" class="headerlink" title="十、模板引用"></a>十、模板引用</h3><ol><li>ref 模板引用<blockquote><p>在组合式 API 中要获得对模板的引用，我们需要声明一个同名的 ref 变量。</p></blockquote></li></ol><pre><code>&lt;script setup&gt;  import &#123; ref, onMounted &#125; from &quot;vue&quot;;  // 声明一个ref变量来存放该元素的引用  // 变量名必须与模板里 ref同名  const box = ref(null);  // 组件挂载成功后，才能访问到该元素的引用  onMounted(() =&gt; &#123;    console.log(box.value.innerHTML);  &#125;);&lt;/script&gt;&lt;template&gt;  &lt;div class=&quot;box&quot; ref=&quot;box&quot;&gt;box内容&lt;/div&gt;&lt;/template&gt;</code></pre><ul><li>注意：你只可以在组件挂载后才能访问模板引用，在没有挂载前模板引用的 ref 值是一个 null。</li></ul><ol start="2"><li>v-for 中的模板引用<blockquote><p>当在 v-for 中使用模板引用时，对应的 ref 中包含的值是一个数组，它将在元素被挂载后包含对应整个列表的所有元素</p></blockquote></li></ol><pre><code>&lt;script setup&gt;  import &#123; ref, onMounted &#125; from &quot;vue&quot;;  const list = [1, 2, 3, 4];  // 声明一个ref变量来存放该元素的引用  // 变量名必须与模板里 ref同名  const items = ref([]);  // 组件挂载成功后，才能访问到该元素的引用  onMounted(() =&gt; &#123;    console.log(items.value);  &#125;);&lt;/script&gt;&lt;template&gt;  &lt;ul&gt;    &lt;li v-for=&quot;item in list&quot; ref=&quot;items&quot;&gt;&#123;&#123; item &#125;&#125;&lt;/li&gt;  &lt;/ul&gt;&lt;/template&gt;</code></pre><ol start="3"><li>组件上的 ref<blockquote><p>在组合式 API<code>&lt;script setup&gt;</code>中，模板引用中获得的值是组件实例。</p></blockquote></li></ol><ul><li>不过使用了 <code>&lt;script setup&gt;</code> 的组件是默认私有的：一个父组件无法访问到一个使用了 <code>&lt;script setup&gt;</code> 的子组件中的任何东西，除非子组件在其中通过 <code>defineExpose</code> 宏显式暴露</li></ul><blockquote><p>代码示例</p></blockquote><ul><li>App.vue</li></ul><pre><code>&lt;script setup&gt;  import A from &quot;./components/A.vue&quot;;  import &#123; ref, onMounted &#125; from &quot;vue&quot;;  const child = ref(null);  onMounted(() =&gt; &#123;    console.log(child.value.msg); //  undefined  如果A组件中对外暴露了该属性，则能获取值  &#125;);&lt;/script&gt;&lt;template&gt;  &lt;a ref=&quot;child&quot;&gt;&lt;/a&gt;&lt;/template&gt;</code></pre><ul><li>A.vue</li></ul><pre><code>&lt;script setup&gt;  import &#123; ref &#125; from &quot;vue&quot;;  const msg = ref(&quot;A组件&quot;);  // 对外暴露属性  // defineExpose(&#123;  //     msg  // &#125;)&lt;/script&gt;&lt;template&gt;  &lt;div&gt;&#123;&#123; msg &#125;&#125;&lt;/div&gt;&lt;/template&gt;</code></pre><h3 id="十一、组合式-API-组件通信-API"><a href="#十一、组合式-API-组件通信-API" class="headerlink" title="十一、组合式 API - 组件通信 API"></a>十一、组合式 API - 组件通信 API</h3><ol><li>defineProps()</li></ol><ul><li><p>在选项式 API 中，通过 props 选项来声明父组件传递的 props</p></li><li><p>在组合式 API 中，通过<code>defineProps()</code>方法来声明 props。</p></li><li><p><code>defineProps()</code>方法接收与 props 选项相同的值<br><code>defineProps()</code>方法被称为编译器宏，在组合式 API 中不需要导入，可以直接使用</p></li><li><p>数组简写形式</p></li></ul><pre><code>&lt;script setup&gt;  // 参数是一个数组  const props = defineProps([&quot;userName&quot;, &quot;age&quot;]);  // props是由声明的属性名与属性值组成的对象  console.log(props); //  &#123;userName: 1, age: 19&#125;&lt;/script&gt;</code></pre><ul><li>对象写法，对 props 做校验，</li></ul><pre><code>&lt;script setup&gt;  // 参数是一个对象，可以对prop做相关的校验  const props = defineProps(&#123;    userName: String,    age: &#123;      // 数据类型      type: Number,      // 属性是否为必传，true表示必传      required: true,      // 表示未传该属性时，属性的默认值，如果没有配置default选项      // 对于没有传的非bool类型属性，默认值为undefind，bool类型属性为false      // required与default 不能同时出现，因为必传，就决定了不会启用默认值      default: 17,      // 数据校验函数，如果返回值为false，表示校验失败，控制台会抛出禁告      validator(value) &#123;        // ....        return true;      &#125;,    &#125;,  &#125;);  // props是由声明的属性名与属性值组成的对象  console.log(props); //  &#123;userName: 1, age: 19&#125;&lt;/script&gt;</code></pre><ol start="2"><li>defineEmits() 方法<blockquote><p>在选项式 API 中，通过<code>emits</code>来声明父组件传递的事件监听器，在组合式 API 中，通过<code>defineEmits()</code>方法来声明。<code>defineEmits()</code>方法接收与 emits 选项相同的值</p></blockquote></li></ol><ul><li><code>defineEmits()</code>方法被称为编译器宏，在组合式 API 中不需要导入，可以直接使用</li></ul><pre><code>import &#123; onMounted &#125; from &quot;vue&quot;;// emit 相当于选项式API中的 this.$emit 用来触发自定义事件const emit = defineEmits([&quot;addEvent&quot;, &quot;delEvent&quot;]);// 生命周期函数中触发事件onMounted(() =&gt; &#123;  emit(&quot;addEvent&quot;);&#125;);</code></pre><blockquote><p>代码演示</p></blockquote><ul><li>App.vue</li></ul><pre><code>&lt;script setup&gt;  import &#123; ref &#125; from &quot;vue&quot;;  import Count from &quot;./components/Count.vue&quot;;  const count = ref(0);  function add() &#123;    count.value++;  &#125;&lt;/script&gt;&lt;template&gt;  &lt;!--@add-event  绑定事件监听器--&gt;  &lt;Count :count=&quot;count&quot; @add-event=&quot;add&quot; /&gt;&lt;/template&gt;</code></pre><ul><li>Count.vue</li></ul><pre><code>&lt;script setup&gt;  import &#123; onMounted &#125; from &quot;vue&quot;;  defineProps([&quot;count&quot;]);  // emit 相当于选项式API中的 this.$emit,可以用来触发事件  const emit = defineEmits([&quot;addEvent&quot;, &quot;delEvent&quot;]);  // 生命周期函数中触发事件  onMounted(() =&gt; &#123;    setTimeout(() =&gt; &#123;      emit(&quot;addEvent&quot;);    &#125;, 2000);  &#125;);&lt;/script&gt;&lt;template&gt;  &lt;div&gt;&#123;&#123; count &#125;&#125;&lt;/div&gt;  &lt;button @click=&quot;$emit(&#39;addEvent&#39;)&quot;&gt;count++&lt;/button&gt;&lt;/template&gt;</code></pre><ol start="3"><li>useAttrs() 方法</li></ol><ul><li>在选项式 API 中，可以通过<code>this.$attrs</code>来访问透传属性。</li><li>在组合式 API 中，我们需要用 Vue 提供的<code>useAttrs()</code>方法来获取所有透传属性，该方法的返回值与选项式 API 中<code>this.$attrs</code>的值是一样的</li><li>注意：透传属性会自动绑定到子组件上，即使不使用<code>useAttrs()</code>方法，子组件模板也可以通过<code>$attrs</code>来使用透传属性；但在<code>script</code>中使用透传属性必须用<code>useAttrs()</code>方法</li></ul><pre><code>&lt;!--父组件中调用Count--&gt;&lt;template&gt;  &lt;Count :class=&quot;[&#39;active&#39;]&quot; id=&quot;box&quot; /&gt;&lt;/template&gt;&lt;!--Count.vue 代码--&gt;&lt;script setup&gt;  import &#123; ref, useAttrs &#125; from &quot;vue&quot;;  // attrs 相当于选项式API中的this.$attrs  const attrs = useAttrs();  console.log(attrs.class); // active  console.log(attrs.id); // box&lt;/script&gt;&lt;template&gt;  &lt;div&gt;&#123;&#123; attrs.class &#125;&#125; --- &#123;&#123; attrs.id &#125;&#125;&lt;/div&gt;  &lt;!-- 不使用useAttrs()方法时 --&gt;  &lt;div&gt;&#123;&#123; $attrs.class &#125;&#125; --- &#123;&#123; $attrs.id &#125;&#125;&lt;/div&gt;&lt;/template&gt;</code></pre><ul><li>以上代码最终渲染后代码如下：</li></ul><pre><code>&lt;div class=&quot;active&quot; id=&quot;box&quot;&gt;active --- box&lt;/div&gt;</code></pre><blockquote><p>禁用透传行为</p></blockquote><ul><li>在选项式 API 中，我们通过<code>inheritAttrs</code>选项来禁用透传行为。</li><li>在组合式 API 中，我们可以让<code>&lt;script setup&gt;</code>与<code>&lt;script&gt;</code>标签一起共存，在<code>&lt;script&gt;</code>标签的选项式 API 中来书写<code>inheritAttrs</code>选项禁用透传行为。</li><li>在 <code>Vue3.3+</code>以上版本，也可以通过<code>defineOptions()</code>方法来实现</li></ul><pre><code>&lt;!--父组件中调用Count--&gt;&lt;template&gt;  &lt;Count :class=&quot;[&#39;active&#39;]&quot; id=&quot;box&quot; /&gt;&lt;/template&gt;&lt;!--Count.vue 代码--&gt;&lt;script&gt;  export default &#123;    inheritAttrs: false,  &#125;;&lt;/script&gt;&lt;script setup&gt;  import &#123; ref, useAttrs &#125; from &quot;vue&quot;;  // attrs 相当于选项式API中的this.$attrs  const attrs = useAttrs();  console.log(attrs.class);  console.log(attrs.id);&lt;/script&gt;&lt;template&gt;  &lt;div&gt;&#123;&#123; attrs.class &#125;&#125; --- &#123;&#123; attrs.id &#125;&#125;&lt;/div&gt;&lt;/template&gt;</code></pre><ul><li>以上代码，最终渲染后效果如下：</li></ul><pre><code>&lt;div&gt;active --- box&lt;/div&gt;</code></pre><ul><li>class与id属性并没有自动透传绑定 div 元素身上</li></ul><ol start="4"><li>defineOptions() 方法</li></ol><ul><li>在 <code>Vue3.3+</code> 以上版本，<code>defineOptions</code> 这个宏可以用来直接在 <code>&lt;script setup&gt;</code> 中声明组件选项，而不必使用单独的 <code>&lt;script&gt;</code> 块</li><li><code>defineOptions()</code>方法被称为编译器宏，在组合式 API 中不需要导入，可以直接使用</li><li><code>defineOptions</code>相当于选项式<code>script</code>块，可以禁止透传，也可以写选项式语法</li></ul><pre><code>&lt;!--父组件中调用Count--&gt;&lt;template&gt;  &lt;Count :class=&quot;[&#39;active&#39;]&quot; id=&quot;box&quot; /&gt;&lt;/template&gt;&lt;!--Count.vue 代码--&gt;&lt;script setup&gt;  import &#123; useAttrs &#125; from &quot;vue&quot;;  // attrs 相当于选项式API中的this.$attrs  const attrs = useAttrs();  //defineOptions相当于选项式script  defineOptions(&#123;    inheritAttrs: false,    data() &#123;      return &#123;        msg: &quot;Hello Vue&quot;,      &#125;;    &#125;,  &#125;);&lt;/script&gt;&lt;template&gt;  &lt;div&gt;&#123;&#123; msg &#125;&#125;&lt;/div&gt;  &lt;div&gt;&#123;&#123; attrs.class &#125;&#125; --- &#123;&#123; attrs.id &#125;&#125;&lt;/div&gt;&lt;/template&gt;</code></pre><ul><li>以上代码最终渲染结果如下：</li></ul><pre><code>&lt;div&gt;  &lt;div&gt;Hello Vue&lt;/div&gt;  &lt;div&gt;active --- box&lt;/div&gt;&lt;/div&gt;</code></pre><ul><li>属性自动透传行为被禁止，msg被正确的在模板中解析出来了</li></ul><ol start="5"><li>defineExpose() 方法</li></ol><ul><li>使用<code>&lt;script setup&gt;</code>的组件是默认关闭的——即通过模板引用或者<code>$parent</code>链获取到的组件的公开实例，不会暴露任何在 <code>&lt;script setup&gt;</code> 中声明的绑定。</li><li>可以通过 <code>defineExpose</code> 编译器宏来显式指定在 <code>&lt;script setup&gt;</code> 组件中要暴露出去的属性</li></ul><pre><code>&lt;script setup&gt;  import &#123; ref &#125; from &quot;vue&quot;;  const msg = ref(&quot;Hello Count&quot;);  const count = ref(1);  // 对外暴露以下属性  defineExpose(&#123;    msg,    count,  &#125;);&lt;/script&gt;</code></pre><blockquote><p>代码演示</p></blockquote><ul><li>App.vue</li></ul><pre><code>&lt;script setup&gt;  import Count from &quot;./components/Count.vue&quot;;  import &#123; ref, onMounted &#125; from &quot;vue&quot;;  const box = ref(null);  const comp = ref(null);  onMounted(() =&gt; &#123;    console.log(box.value); // &lt;div&gt;App.vue&lt;/div&gt;    console.log(comp.value.msg); // Hello Count    console.log(comp.value.count); // 1    console.log(comp.value.num); // undefined  &#125;);&lt;/script&gt;&lt;template&gt;  &lt;div ref=&quot;box&quot;&gt;App.vue&lt;/div&gt;  &lt;Count ref=&quot;comp&quot; /&gt;&lt;/template&gt;</code></pre><ul><li>Count.vue</li></ul><pre><code>&lt;script setup&gt;  import &#123; ref &#125; from &quot;vue&quot;;  const msg = ref(&quot;Hello Count&quot;);  const count = ref(1);  const num = ref(100);  defineExpose(&#123;    msg,    count,  &#125;);&lt;/script&gt;&lt;template&gt;  &lt;div&gt;&#123;&#123; msg &#125;&#125;&lt;/div&gt;  &lt;div&gt;&#123;&#123; count &#125;&#125;&lt;/div&gt;  &lt;div&gt;&#123;&#123; num&#125;&#125;&lt;/div&gt;&lt;/template&gt;</code></pre><h3 id="十二、依赖与注入"><a href="#十二、依赖与注入" class="headerlink" title="十二、依赖与注入"></a>十二、依赖与注入</h3><blockquote><p>在组合式 API 中，组件要为后代组件提供数据，后代组件要能使用上层组件提供的数据，需要经过以下两步：</p></blockquote><ul><li>上层组件通过<code>provide()</code>函数向后代组件提供数据</li><li>后代组件通过<code>inject()</code>函数注入上层组件提供的数据</li></ul><ol><li>provide() 函数<blockquote><p><code>provide()</code>函数用于在组合式 API 中为后代组件提供数据</p></blockquote></li></ol><pre><code>&lt;script setup&gt;  import &#123; provide &#125; from &quot;vue&quot;;  provide(/* 注入名 */ &quot;message&quot;, /* 值 */ &quot;hello!&quot;);&lt;/script&gt;</code></pre><blockquote><p>参数详解</p></blockquote><ul><li>第一个参数为注入名，可以是一个字符串或一个 <code>Symbol</code> 类型，后代组件会用该注入名来查找期望的注入值</li><li>第二个参数是提供的值，值可以是任意类型，如果值是一个响应式的（如比 <code>ref</code> 或 <code>reactive</code>），则后代组件可以由此和提供者建立响应式的联系。</li><li>一个组件可以多次调用 <code>provide()</code>，使用不同的注入名，注入不同的依赖值。</li></ul><ol start="2"><li>inject() 函数<blockquote><p>inject()函数用于在组合式 API 中，后代组件要注入上层组件提供的数据</p></blockquote></li></ol><pre><code>&lt;script setup&gt;  import &#123; inject &#125; from &quot;vue&quot;;  const msg = inject(&quot;message&quot;, &quot;默认值&quot;);&lt;/script&gt;</code></pre><blockquote><p>参数详解</p></blockquote><ul><li>第一个参数为注入名，通过注入名访问到上层组件提供的对应数据</li><li>第二个参数为默认值，如果上传组件没有提供该注入名，则会启用默认值</li><li>上层组件提供的数据如果是一个 ref 对象，注入进来的会是该 ref 对象，而不会自动解包，这使得注入方组件能够通过 ref 对象保持了和供给方的响应性链接。不过在模板中使用时会自动解包。</li></ul><blockquote><p>代码演示</p></blockquote><ul><li>App.vue</li></ul><pre><code>&lt;script setup&gt;  import Main from &quot;./components/Main.vue&quot;;  import &#123; ref, reactive, provide &#125; from &quot;vue&quot;;  // 响应式数据  const userInfo = reactive(&#123;    userName: &quot;艾编程&quot;,    age: 12,    hobbies: [&quot;画画&quot;, &quot;唱歌&quot;, &quot;音乐&quot;],  &#125;);  function update() &#123;    userInfo.userName = &quot;清心&quot;;    userInfo.age = 30;    userInfo.hobbies = [&quot;写代码&quot;, &quot;跑步&quot;, &quot;阅读&quot;];  &#125;  // 提供数据  provide(&quot;userInfo&quot;, userInfo);  provide(&quot;update&quot;, update);&lt;/script&gt;&lt;template&gt;  &lt;main /&gt;&lt;/template&gt;</code></pre><ul><li>Main.vue</li></ul><pre><code>&lt;script setup&gt;  import Item from &quot;./Item.vue&quot;;&lt;/script&gt;&lt;template&gt;  &lt;Item /&gt;&lt;/template&gt;</code></pre><ul><li>Item.vue</li></ul><pre><code>&lt;script setup&gt;  import &#123; inject, reactive, toRefs &#125; from &quot;vue&quot;;  // 注入数据  const &#123; userName, age, hobbies &#125; = toRefs(inject(&quot;userInfo&quot;));  // 以下写法，解构后，将会失去响应性  // const &#123; userName, age, hobbies &#125; = inject(&quot;userInfo&quot;)  const update = inject(&quot;update&quot;);&lt;/script&gt;&lt;template&gt;  &lt;button @click.once=&quot;update&quot;&gt;更新数据&lt;/button&gt;  &lt;div&gt;姓名：&#123;&#123; userName &#125;&#125;&lt;/div&gt;  &lt;div&gt;年龄：&#123;&#123; age &#125;&#125;&lt;/div&gt;  &lt;div&gt;爱好：&#123;&#123; hobbies &#125;&#125;&lt;/div&gt;&lt;/template&gt;</code></pre><h3 id="十三、生命周期钩子"><a href="#十三、生命周期钩子" class="headerlink" title="十三、生命周期钩子"></a>十三、生命周期钩子</h3><ol><li>生命周期函数示图</li></ol><ul><li>我们再来回顾之前讲到的生命周期函数示图<img src="生命周期函数.png"></li></ul><blockquote><p>组合式 API 中的生命周期函数与选项式 API 中是几乎是一一对应的，只是存在以下两点不同：</p><ul><li>两者函数名写法上有所不同，组合式 API 生命周函数都以 <code>on</code> 开头，并采用驼峰命名，如下表。</li><li>组合式 API 中没有与之对应的<code>onBeforeCreate</code>与<code>onCreated</code>函数，所有期望在<code>beforeCreate</code>与<code>created</code>生命周期函数阶段执行的代码都可以写在在<code>setup()</code>函数或<code>&lt;script setup&gt;</code>标签中。<br>因为<code>setup()</code>与<code>&lt;script setup&gt;</code>中的代码会在<code>beforeCreate</code>生命周期函数之前被处理</li><li>因此组合式 API 中所有写在<code>setup()</code>函数或<code>&lt;script setup&gt;</code>中的顶层变量或方法相当于选项式 API 中<code>data()</code>方法与<code>methods</code>选项等其它选项对外暴露的属性和方法。</li></ul></blockquote><ul><li>组合式 API 与选项式 API 中生命周期函数的对比表</li></ul><table><thead><tr><th>选项式 API</th><th>组合式 API</th><th>说明</th></tr></thead><tbody><tr><td>beforeCreate</td><td>setup</td><td>在组件实例初始化完成之后立即调用</td></tr><tr><td>created</td><td>setup</td><td>在组件实例处理完所有与状态相关的选项后调用</td></tr><tr><td>beforeMount</td><td>onBeforeMount</td><td>组件被挂载之前被调</td></tr><tr><td>mounted</td><td>onMounted</td><td>用组件挂载完成后执行</td></tr><tr><td>beforeUpdate</td><td>onBeforeUpdate</td><td>组件即将因为响应式状态变更而更新其 DOM 树之前调用</td></tr><tr><td>updated</td><td>onUpdated</td><td>组件因为响应式状态变更而更新其 DOM 树之后调用</td></tr><tr><td>beforeUnmount</td><td>onBeforeUnmount</td><td>组件实例被卸载之前调用</td></tr><tr><td>unmounted</td><td>onUnmounted</td><td>组件实例被卸载之后调用</td></tr></tbody></table><ol start="2"><li>生命周期函数使用</li></ol><ul><li>组合式 API 中生命周期函数需要先导入，然后才能使用。</li><li>每个生命周期函数的第一个参数是一个回调函数，在组件或应用执行到此阶段时，会触发该回调函数</li></ul><pre><code>&lt;script setup&gt;  // 导入生命周期函数  import &#123; onMounted &#125; from &quot;vue&quot;;  // 只会在组件或应用执行到此生命阶段时，才会触发其回调函数  onMounted(() =&gt; &#123;    console.log(&quot;DOM挂载完毕&quot;);  &#125;);&lt;/script&gt;</code></pre><ul><li>如果在同一个 setup 中，同一个生命周期函数出现多次，则每个生命周期函数的回调都会触发，<strong>不存在覆盖的情况</strong></li></ul><pre><code>&lt;script setup&gt;  // 导入生命周期函数  import &#123; onMounted &#125; from &quot;vue&quot;;  // 只会在组件或应用执行到此生命阶段时，才会触发其回调函数  onMounted(() =&gt; &#123;    console.log(&quot;111&quot;);  &#125;);  onMounted(() =&gt; &#123;    console.log(&quot;222&quot;);  &#125;);&lt;/script&gt;</code></pre><h3 id="十四、组合式-API-常见疑问"><a href="#十四、组合式-API-常见疑问" class="headerlink" title="十四、组合式 API 常见疑问"></a>十四、组合式 API 常见疑问</h3><ul><li>组合式 API 的常见疑问，大家可以参 Vue 官方文档：<a href="https://cn.vuejs.org/guide/extras/composition-api-faq.html">组合式 API 常见问题</a></li></ul><blockquote><p>为什么要有组合式 API？</p></blockquote><ul><li>更好的逻辑复用</li><li>更灵活的代码组织</li><li>更好的类型推导</li><li>更小的生产包体积</li></ul>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Vue </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Vue（四）</title>
      <link href="/2024/01/24/Vue%EF%BC%88%E5%9B%9B%EF%BC%89/"/>
      <url>/2024/01/24/Vue%EF%BC%88%E5%9B%9B%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<span id="more"></span><h3 id="一、插槽-Slots"><a href="#一、插槽-Slots" class="headerlink" title="一、插槽 Slots"></a>一、插槽 Slots</h3><blockquote><p>插槽主要用来实现父组件向子组件传递模板内容，且使用起来非常方便</p></blockquote><h4 id="为什么需要插槽"><a href="#为什么需要插槽" class="headerlink" title="为什么需要插槽"></a>为什么需要插槽</h4><blockquote><p>在实际的开发中，父组件经常需要向子组件传递模板内容</p></blockquote><ul><li>比如在父组件<code>App</code>中调用了同一个子组件<code>&lt;List&gt;</code>2 次，子组件的外观样式一样，但展示的主体内容模板和样式都不一样，这时候主体中需要展示的模板内容就需要通过父组件来传递。</li><li>也就是说子组件在定义时，并不知道使用该组件的父组件需要在子组件中显示什么模板内容，所以把需要显示的模板内容权限交给了使用他的父组件，父组件想要显示什么内容，直接传递给子组件就好。</li></ul><blockquote><p>父组件向子组件传递模板内容有以下两种方式：</p><table><thead><tr><th>方式</th><th>优缺点</th></tr></thead><tbody><tr><td>通过 props 来传递模板内容</td><td>如果模板内容较复杂，使用起来会非常麻烦</td></tr><tr><td>通过插槽来传递模板内容</td><td>不管模板内容简单还是复杂，使用起来都非常简单和方便</td></tr></tbody></table></blockquote><h4 id="通过-props-来传递模板内容"><a href="#通过-props-来传递模板内容" class="headerlink" title="通过 props 来传递模板内容"></a>通过 props 来传递模板内容</h4><ul><li>父组件中调用子组件，通过 <code>Prop</code> 传递模板内容</li></ul><pre><code>&lt;!--通过prop传递模板内容--&gt;&lt;List :content=&quot;&lt;h3&gt;新闻动态&lt;/h3&gt; &lt;div&gt;新闻内容&lt;/div &gt;&quot; /&gt;</code></pre><ul><li>子组件中使用传递的 <code>prop</code> 数据</li></ul><pre><code>&lt;div class=&quot;list&quot; v-html=&quot;content&quot;&gt;&lt;/div&gt;</code></pre><ul><li>渲染后代码如下</li></ul><pre><code>&lt;div class=&quot;list&quot;&gt;  &lt;h3&gt;新闻动态&lt;/h3&gt;  &lt;div&gt;新闻内容&lt;/div&gt;&lt;/div&gt;</code></pre><ul><li>如果传递的模板内容比较简单还好，如果传递的模板数据较复杂，使用 props 来传递就会非常麻烦。</li><li>如果使用Prop来传递模板内容，所有html标签等内容都要写到字符串中，又回到操作 DOM 和子符串拼接的时代，这肯定不是 Vue 框架设计的初衷</li></ul><h4 id="插槽的分类"><a href="#插槽的分类" class="headerlink" title="插槽的分类"></a>插槽的分类</h4><blockquote><p>Vue 为我们提供了以下三种插槽</p></blockquote><ul><li>默认插槽</li><li>具名插槽</li><li>作用域插槽</li></ul><h4 id="默认插槽"><a href="#默认插槽" class="headerlink" title="默认插槽"></a>默认插槽</h4><ol><li>默认插槽的使用<blockquote><p>默认插槽的使用分为以下两步：</p></blockquote></li></ol><ul><li>①、定义插槽内容（slot content）：在父组件中，把需要传入给默认插槽的模板内容，直接写在子组件标签中间，如下：</li></ul><pre><code>&lt;!--App 父组件--&gt;&lt;List&gt;  &lt;!-- 插槽内容，以下内容会替换子组件中的&lt;solt&gt;&lt;/slot&gt;元素 --&gt;  &lt;h3&gt;新闻动态&lt;/h3&gt;  &lt;div&gt;新闻内容&lt;/div&gt;&lt;/List&gt;</code></pre><ul><li>②、定义插槽出口（slot outlet）： 在子组件中，我们想把传入的模板内容插入到模板的哪个位置，我们就可以在对应位置插入<code>&lt;slot&gt;&lt;/slot&gt;</code></li></ul><pre><code>&lt;!--List子组件--&gt;&lt;!--在子组件使用插槽传递的模板内容--&gt;&lt;div class=&quot;list&quot;&gt;  &lt;!-- slot为插槽出口，上面插槽内容最终会替换这里的slot标签 --&gt;  &lt;slot&gt;&lt;/slot&gt;&lt;/div&gt;</code></pre><ul><li><code>&lt;slot&gt;</code>元素是一个插槽出口（slot outlet），标示了父元素提供的插槽内容（slot content）将在哪里被渲染。</li><li>以上代码最终渲染后效果如下：</li></ul><pre><code>&lt;!--渲染后模板代码如下--&gt;&lt;div class=&quot;list&quot;&gt;  &lt;h3&gt;新闻动态&lt;/h3&gt;  &lt;div&gt;新闻内容&lt;/div&gt;&lt;/div&gt;</code></pre><ol start="2"><li>插槽的渲染作用域</li></ol><ul><li><strong>渲染作用域</strong>：插槽内容可以访问到父组件的数据作用域，而无法访问子组件的数据，因为插槽内容本身是在父组件模板中定义的</li><li><strong>插槽内容</strong>：可以是任意合法的模板内容，例如：模板内容可以是多个 HTML 元素，也可以是组件</li></ul><ol start="3"><li>插槽默认内容<blockquote><p>我们可以为插槽指定默认内容，当父组件中没有提供任何插槽内容时，显示插槽的默认内容。如果指定了，就显示指定的内容。</p></blockquote></li></ol><ul><li>在<code>Person</code>组件中定义插槽出口，并为插槽指定默认内容</li></ul><pre><code>&lt;!--Person组件--&gt;&lt;div class=&quot;container&quot;&gt;  &lt;slot&gt;    &lt;!--以下内容为默认内容，如果父组件中没有指定插槽内容，则显示以下内容--&gt;    &lt;button&gt;登录&lt;/button&gt;    &lt;button&gt;注册&lt;/button&gt;  &lt;/slot&gt;&lt;/div&gt;</code></pre><ol start="4"><li>插槽内容的 CSS 样式</li></ol><ul><li>在子组件中不会渲染插槽出口的内容，其内容由<strong>父组件</strong>的插槽内容<strong>渲染后</strong>提供。</li><li>这一点决定了插槽内容的 CSS 样式应该写在父组件中，而不能写在子组件中</li><li>总结：插槽内容对应的 CSS 样式和数据都要写在父组件中，不能写在子组件，因为插槽内容是在父组件中渲染后提供给子组件的</li></ul><ol start="5"><li>插槽选择器</li></ol><ul><li>如果我们想在子组件中通过<code>css</code>选择器选择插槽内容，可以借助<code>:slotted</code>伪类。</li><li>这样就能实现在子组件里给插槽内容添加样式</li></ul><pre><code>:slotted(.list .title) &#123;  background-color: skyblue;&#125;</code></pre><blockquote><p>示例</p></blockquote><ul><li><code>App.vue</code>文件内容</li></ul><pre><code>&lt;script&gt;  import List from &quot;./components/List.vue&quot;;  export default &#123;    components: &#123;      List,    &#125;,  &#125;;&lt;/script&gt;&lt;template&gt;  &lt;List&gt;    &lt;div class=&quot;title&quot;&gt;插槽内容&lt;/div&gt;  &lt;/List&gt;&lt;/template&gt;</code></pre><ul><li><code>List.vue</code> 文件内容</li></ul><pre><code>&lt;template&gt;  &lt;div class=&quot;list&quot;&gt;    &lt;slot&gt;&lt;/slot&gt;  &lt;/div&gt;&lt;/template&gt;&lt;style scoped&gt;  .list &#123;    width: 300px;    height: 200px;    border: 1px solid skyblue;  &#125;  :slotted(.list .title) &#123;    background-color: skyblue;  &#125;&lt;/style&gt;</code></pre><ul><li>最终渲染后的 HTML 与 CSS 代码，如下：</li></ul><pre><code>&lt;div data-v-b7ac1dbf=&quot;&quot; class=&quot;list&quot;&gt;  &lt;!--加上了唯一data-v-xx-s属性--&gt;  &lt;div data-v-b7ac1dbf-s=&quot;&quot; class=&quot;title&quot;&gt;插槽内容&lt;/div&gt;&lt;/div&gt;&lt;style&gt;  .list[data-v-b7ac1dbf] &#123;    width: 300px;    height: 200px;    border: 1px solid skyblue;  &#125;  /* 通过唯一属性来选择 */  .list .title[data-v-b7ac1dbf-s] &#123;    background-color: skyblue;  &#125;&lt;/style&gt;</code></pre><ul><li>观察以上代码发现，<code>.title</code>元素添加上了唯一<code>data-v-b7ac1dbf-s</code>属性，同时 <code>css</code> 选择器也添加上了属性选择，即：<code>.list .title[data-v-b7ac1dbf-s]</code></li></ul><ol start="6"><li>案例演示</li></ol><ul><li><code>App.vue</code>根组件</li></ul><pre><code>&lt;script&gt;import List from &quot;./components/List.vue&quot;;export default &#123;  data() &#123;    return &#123;      imgUrl:        &quot;https://sce7a2b9c9d95a-sb-qn.qiqiuyun.net/files/course/2022/08-29/210311f40bcf290736.jpg&quot;,      courseTitle: &quot;推荐课程&quot;,      newsTitle: &quot;最新动态&quot;,      newsList: [&quot;动态1&quot;, &quot;最新动态2&quot;, &quot;最新动态3&quot;],    &#125;;  &#125;,  components: &#123;    List,  &#125;,&#125;;&lt;/script&gt;&lt;template&gt;  &lt;List :title=&quot;courseTitle&quot;&gt;    &lt;img class=&quot;img&quot; :src=&quot;imgUrl&quot; width=&quot;300&quot; /&gt;  &lt;/List&gt;  &lt;List :title=&quot;newsTitle&quot;&gt;    &lt;ul class=&quot;list&quot;&gt;      &lt;li v-for=&quot;item in newsList&quot;&gt;&#123;&#123; item &#125;&#125;&lt;/li&gt;    &lt;/ul&gt;  &lt;/List&gt;&lt;/template&gt;&lt;style&gt;* &#123;  margin: 0;  padding: 0;&#125;ul &#123;  list-style: none;&#125;&lt;/style&gt;&lt;style scoped&gt;.img &#123;  margin: 30px auto;&#125;.list &#123;  padding: 0 5px;&#125;.list li &#123;  height: 30px;  line-height: 30px;  border-bottom: 1px solid #ddd;&#125;&lt;/style&gt;</code></pre><ul><li><code>List.vue</code>子组件</li></ul><pre><code>&lt;script&gt;export default &#123;  props: [&quot;title&quot;],&#125;;&lt;/script&gt;&lt;template&gt;  &lt;div class=&quot;box&quot;&gt;    &lt;div class=&quot;title&quot;&gt;&#123;&#123; title &#125;&#125;&lt;/div&gt;    &lt;slot&gt;&lt;/slot&gt;  &lt;/div&gt;&lt;/template&gt;&lt;style scoped&gt;.box &#123;  width: 300px;  height: 300px;  border: 1px solid #000;  margin: 20px;&#125;.title &#123;  width: 100%;  height: 30px;  background-color: khaki;&#125;&lt;/style&gt;</code></pre><h4 id="具名插槽"><a href="#具名插槽" class="headerlink" title="具名插槽"></a>具名插槽</h4><blockquote><p>有时候我们需要在一个组件中包含多个插槽出口，同时为每个插槽出口指定对应的插槽内容，也就是用同一个组件实现不同效果，就可以用具名插槽</p></blockquote><ol><li>具名插槽与默认插槽区别</li></ol><ul><li>相对于前面讲到的默认插槽而言，具名插槽的<code>&lt;slot&gt;</code>元素上有一个特殊的<code>name</code>属性，用来给各个插槽分配唯一的 ID，以确定每一处要渲染的内容。</li></ul><pre><code>&lt;!-- 具名插槽 --&gt;&lt;slot name=&quot;header&quot;&gt; &lt;/slot&gt;&lt;!--默认插槽--&gt;&lt;slot&gt; &lt;/slot&gt;</code></pre><ul><li>实际上默认插槽<code>&lt;slot&gt;</code>元素也有<code>name</code>属性，<code>name</code>属性为<code>default</code>，通常情况下该<code>name</code>属性可以省略不写</li></ul><pre><code>&lt;!--默认插槽--&gt;&lt;slot&gt;&lt;/slot&gt;&lt;!--默认插槽，和上面写法表示的是一个意思--&gt;&lt;slot name=&quot;default&quot;&gt;&lt;/slot&gt;</code></pre><ol start="2"><li>具名插槽的使用<blockquote><p>使用具名插槽，需要分以下两步：</p></blockquote></li></ol><ul><li>①、指定插槽出口：在子组件模板中，在需要显示插槽内容的位置添加<code>&lt;slot&gt;</code>标签指定插槽出口，同时为具名插槽添加<code>name</code>属性，如下</li></ul><pre><code>&lt;!-- Layout组件 --&gt;&lt;div class=&quot;container&quot;&gt;  &lt;header&gt;    &lt;!-- 具名插槽 --&gt;    &lt;slot name=&quot;header&quot;&gt; &lt;/slot&gt;  &lt;/header&gt;  &lt;main&gt;    &lt;!--默认插槽 --&gt;    &lt;slot&gt;&lt;/slot&gt;  &lt;/main&gt;  &lt;footer&gt;    &lt;!-- 具名插槽--&gt;    &lt;slot name=&quot;footer&quot;&gt; &lt;/slot&gt;  &lt;/footer&gt;&lt;/div&gt;</code></pre><ul><li>②、指定插槽内容：要为具名插槽传入对应的内容，我们需要使用一个含<code>v-slot</code>指令的<code>&lt;template&gt;</code>元素，并将目标插槽的名字传给该指令</li></ul><pre><code>&lt;Layout&gt;  &lt;template v-slot:default&gt;    &lt;!--默认插槽内容放这里--&gt;  &lt;/template&gt;  &lt;template v-slot:header&gt;    &lt;!--header插槽内容放这里--&gt;  &lt;/template&gt;  &lt;template v-slot:footer&gt;    &lt;!--footer插槽内容放这里--&gt;  &lt;/template&gt;&lt;/Layout&gt;</code></pre><ul><li>以下为对应的插槽出口指定插槽内容</li></ul><pre><code>&lt;Layout&gt;  &lt;!--默认插槽内容--&gt;  &lt;template v-slot:default&gt;    &lt;div class=&quot;main&quot;&gt;我是主体内容&lt;/div&gt;  &lt;/template&gt;  &lt;template v-slot:header&gt;    &lt;!--header插槽内容--&gt;    &lt;div class=&quot;header&quot;&gt;我是头部内容&lt;/div&gt;  &lt;/template&gt;  &lt;template v-slot:footer&gt;    &lt;!--footer插槽内容--&gt;    &lt;div class=&quot;footer&quot;&gt;我是底部内容&lt;/div&gt;  &lt;/template&gt;&lt;/Layout&gt;</code></pre><ul><li>最终所有插槽内容都被传递到了相应的插槽出口，渲染后的效果如下：</li></ul><pre><code>&lt;div class=&quot;container&quot;&gt;  &lt;header&gt;    &lt;div class=&quot;header&quot;&gt;我是头部内容&lt;/div&gt;  &lt;/header&gt;  &lt;main&gt;    &lt;div class=&quot;main&quot;&gt;我是主体内容&lt;/div&gt;  &lt;/main&gt;  &lt;footer&gt;    &lt;div class=&quot;footer&quot;&gt;我是底部内容&lt;/div&gt;  &lt;/footer&gt;&lt;/div&gt;</code></pre><ol start="3"><li>注意事项<blockquote><p>当一个组件同时接收默认插槽和具名插槽时，所有位于顶级的非 <code>&lt;template&gt;</code>节点都被<strong>隐式地视为默认插槽</strong>的内容，所以上面内容也可以写成</p></blockquote></li></ol><pre><code>&lt;Layout&gt;  &lt;!--Layout标签中，所有没有写在template模板中的内容，都为默认插槽内容--&gt;  &lt;div class=&quot;main&quot;&gt;我是主体内容&lt;/div&gt;  &lt;template v-slot:header&gt;    &lt;!--header插槽内容--&gt;    &lt;div class=&quot;header&quot;&gt;我是头部内容&lt;/div&gt;  &lt;/template&gt;  &lt;template v-slot:footer&gt;    &lt;!--footer插槽内容--&gt;    &lt;div class=&quot;footer&quot;&gt;我是底部内容&lt;/div&gt;  &lt;/template&gt;&lt;/Layout&gt;</code></pre><ul><li><code>v-slot</code>指令可以简写成<code>#</code>，因此<code>&lt;template v-slot:header&gt;</code>可以简写成<code>&lt;template #header&gt;</code> ，所以上面内容也可以简写成</li></ul><pre><code>&lt;Layout&gt;  &lt;!--Layout标签中，所有没有写在template模板中的内容，都为默认插槽内容--&gt;  &lt;div class=&quot;main&quot;&gt;我是主体内容&lt;/div&gt;  &lt;template #header&gt;    &lt;!--header插槽内容--&gt;    &lt;div class=&quot;header&quot;&gt;我是头部内容&lt;/div&gt;  &lt;/template&gt;  &lt;template #footer&gt;    &lt;!--footer插槽内容--&gt;    &lt;div class=&quot;footer&quot;&gt;我是底部内容&lt;/div&gt;  &lt;/template&gt;&lt;/Layout&gt;</code></pre><ul><li>可以为插槽指定动态的插槽名</li></ul><pre><code>&lt;script&gt;...省略  export default &#123;    data() &#123;      return &#123;        header: &quot;header&quot;,      &#125;;    &#125;,...省略  &#125;&lt;/script&gt;&lt;template v-slot:[header]&gt; .... &lt;/template&gt;&lt;!--上面简写形式--&gt;&lt;template #[header]&gt; ..... &lt;/template&gt;</code></pre><h4 id="实战应用：自定义-Dialog-弹窗组件"><a href="#实战应用：自定义-Dialog-弹窗组件" class="headerlink" title="实战应用：自定义 Dialog 弹窗组件"></a>实战应用：自定义 Dialog 弹窗组件</h4><ul><li>点击显示弹窗按扭，会弹出对应的弹窗</li><li>点击弹窗中的取消与确认按扭，都会关闭弹窗。</li><li>点击右上角的关闭按扭会弹出一个提示框，询问是确定关闭弹窗吗？点击确定就会关才，点击取消，就不关闭</li></ul><ol><li>思路</li></ol><ul><li>在父组件没有使用插槽 与 父组件使用插槽 这两种情况：<ul><li>相同的部分是：关闭按钮、底部的取消和确定按钮</li><li>不同的部分是中间的内容</li></ul></li><li>添加两个插槽，一个用于内容部分，一个用于底部的按钮<ul><li>底部按钮做插槽的原因是：插槽可以让按钮的点击事件写在父组件里，这比使用自定义事件更加方便</li><li>关闭按钮仍使用的是自定义事件的方式，如果想让父组件自己定义关闭按钮的样式，也可以把它开放出去</li></ul></li><li>顶部标题和中间的内容都要设置默认值</li><li>在父组件中定义<code>isVisible</code>变量来关闭和显示弹窗</li></ul><ol start="2"><li>实现步骤</li></ol><ul><li>第一步： 首先定义一个子组件<code>Dialog</code>，在父组件中引入</li><li>第二步： 在子组件<code>Dialog</code>中添加两个插槽出口</li><li>第三步： 在父组件中使用<code>Dialog</code>子组件<ul><li>在组件上添加<code>title</code>属性、<code>visible</code>属性、自定义事件<code>close-event</code></li><li>在<code>methods</code>里面定义自定义事件<code>close-event</code>，接收子组件传过来的值，修改<code>visible</code>属性</li><li>分别给插槽添加对应内容</li></ul></li><li>第四步：在子组件中<ul><li>在子组件中接受传过来的<code>props</code>属性，标题<code>title</code>要设置默认值，并在模板中使用</li><li>在关闭按钮上绑定方法，在组件实例上以<code>this.$emit()</code>的方式触发自定义事件，并且如果提示框选择的是确定，就关闭弹窗<ul><li>使用<code>confirm</code></li></ul></li></ul></li><li>第五步：添加CSS样式</li></ul><blockquote><p><code>App.vue</code>根组件</p></blockquote><pre><code>&lt;script&gt;import Dialog from &quot;./components/Dialog.vue&quot;;export default &#123;  data() &#123;    return &#123;      title: &quot;收货地址&quot;,      isVisible: false, // 弹窗显示      // 弹窗主体显示数据      gridData: [        &#123;          date: &quot;2027-07-02&quot;,          name: &quot;王小花&quot;,          address: &quot;xxx普陀区金沙江路 12345 &quot;,        &#125;,        &#123;          date: &quot;2027-07-04&quot;,          name: &quot;刘晓冉&quot;,          address: &quot;xxx普陀区金沙江路 12345&quot;,        &#125;,        &#123;          date: &quot;2027-07-01&quot;,          name: &quot;小心心&quot;,          address: &quot;xxx普陀区金沙江路 12345&quot;,        &#125;,        &#123;          date: &quot;2027-07-03&quot;,          name: &quot;王小虎&quot;,          address: &quot;xxx普陀区金沙江路 12345&quot;,        &#125;,      ],    &#125;;  &#125;,  components: &#123;    Dialog,  &#125;,  methods: &#123;    close(value) &#123;      this.isVisible = value;    &#125;,  &#125;,&#125;;&lt;/script&gt;&lt;template&gt;  &lt;button class=&quot;show&quot; @click=&quot;isVisible = true&quot;&gt;显示&lt;/button&gt;  &lt;Dialog :visible=&quot;isVisible&quot; :title=&quot;title&quot; @close-event=&quot;close&quot;&gt;    &lt;template v-slot:main&gt;      &lt;table&gt;        &lt;tr&gt;          &lt;th&gt;日期&lt;/th&gt;          &lt;th&gt;姓名&lt;/th&gt;          &lt;th&gt;收货地址&lt;/th&gt;        &lt;/tr&gt;        &lt;tr v-for=&quot;(item, index) in gridData&quot; :key=&quot;index&quot;&gt;          &lt;td&gt;&#123;&#123; item.date &#125;&#125;&lt;/td&gt;          &lt;td&gt;&#123;&#123; item.name &#125;&#125;&lt;/td&gt;          &lt;td&gt;&#123;&#123; item.address &#125;&#125;&lt;/td&gt;        &lt;/tr&gt;      &lt;/table&gt;    &lt;/template&gt;    &lt;template v-slot:footer&gt;      &lt;div class=&quot;btn&quot;&gt;        &lt;button class=&quot;cancle&quot; @click=&quot;isVisible = false&quot;&gt;取消&lt;/button&gt;        &lt;button class=&quot;confirm&quot; @click=&quot;isVisible = false&quot;&gt;确定&lt;/button&gt;      &lt;/div&gt;    &lt;/template&gt;  &lt;/Dialog&gt;&lt;/template&gt;&lt;style&gt;* &#123;  padding: 0;  margin: 0;&#125;button &#123;  cursor: pointer;&#125;&lt;/style&gt;&lt;style scoped&gt;.show &#123;  margin: 50px;  padding: 10px;&#125;/* 插槽 main */table &#123;  margin: 10px 0;  width: 100%;  border-collapse: collapse;&#125;tr th,tr td &#123;  height: 40px;  text-align: center;  border: 1px solid #ddd;&#125;/* 插槽 footer */.btn &#123;  margin: 30px 0;  display: flex;  justify-content: space-around;  width: 100%;  height: 40px;&#125;.btn button &#123;  display: inline-block;  width: 80px;  border: none;&#125;.confirm &#123;  background-color: skyblue;&#125;&lt;/style&gt;</code></pre><blockquote><p><code>Dialog.vue</code>弹窗组件</p></blockquote><pre><code>&lt;script&gt;export default &#123;  props: &#123;    visible: Boolean,    title: &#123;      default: &quot;提示内容&quot;,    &#125;,  &#125;,  emits: [&quot;closeEvent&quot;],  methods: &#123;    closeEvent() &#123;      const bool = confirm(&quot;确认关闭吗&quot;);      console.log(bool);      this.$emit(&quot;closeEvent&quot;, false);    &#125;,  &#125;,&#125;;&lt;/script&gt;&lt;template&gt;  &lt;div class=&quot;mask&quot; v-if=&quot;visible&quot;&gt;&lt;/div&gt;  &lt;div class=&quot;content&quot; v-if=&quot;visible&quot;&gt;    &lt;div class=&quot;head&quot;&gt;      &lt;div class=&quot;title&quot;&gt;&#123;&#123; title &#125;&#125;&lt;/div&gt;      &lt;div class=&quot;close&quot; @click=&quot;closeEvent&quot;&gt;X&lt;/div&gt;    &lt;/div&gt;    &lt;slot name=&quot;main&quot;&gt;&lt;div class=&quot;text&quot;&gt;这是一段提示信息&lt;/div&gt;&lt;/slot&gt;    &lt;slot name=&quot;footer&quot;&gt; &lt;/slot&gt;  &lt;/div&gt;&lt;/template&gt;&lt;style&gt;.mask &#123;  position: fixed;  top: 0;  left: 0;  width: 100%;  height: 100%;  background-color: rgba(0, 0, 0, 0.5);&#125;.content &#123;  position: fixed;  top: 50%;  left: 50%;  transform: translate(-50%, -50%);  width: 450px;  /* height: 350px; */  border: 1px solid #000;  z-index: 99;  background-color: #fff;&#125;.head &#123;  display: flex;  height: 50px;  justify-content: space-between;&#125;.title &#123;  text-indent: 1em;  font-size: 24px;  line-height: 50px;&#125;.close &#123;  width: 30px;  height: 30px;  background-color: #ddd;  cursor: pointer;  font-size: 26px;  line-height: 30px;  text-align: center;&#125;.text &#123;  margin: 30px 20px;&#125;&lt;/style&gt;</code></pre><h4 id="作用域插槽"><a href="#作用域插槽" class="headerlink" title="作用域插槽"></a>作用域插槽</h4><ul><li>在上面插槽的渲染中我们提到，插槽的内容可以访问父组件数据作用域（即父组件状态），但无法访问到子组件的状态</li><li>然而在某些场景下，插槽的内容可能想要同时使用父组件域内和子组件域内的数据。要做到这一点，我们需要一种方法来让子组件在渲染时将一部分数据提供给插槽。</li><li>Vue 框架也为我们考虑到了这一点，我们可以像对组件传递 props 那样，向一个插槽的出口上传递属性</li></ul><pre><code>&lt;!-- &lt;MyComponent&gt; 的模板 --&gt;&lt;div&gt;  &lt;slot :msg=&quot;message&quot; :count=&quot;1&quot;&gt;&lt;/slot&gt;&lt;/div&gt;</code></pre><ul><li>当需要接受插槽 props 时，默认插槽和具名插槽的使用方式有一些小区别，我们分开来讲解。</li></ul><ol><li>默认作用域插槽<blockquote><p>在默认插槽中，我们需要通过子组件标签（如：<code>&lt;MyComponent&gt;</code>）上的<code>v-slot</code>指令，直接接受一个插槽 <code>props</code>对象</p></blockquote></li></ol><ul><li>子组件传出的属性会被放入一个对象中，对象名可自定义</li><li>这个对象可以直接在插槽内容的表达式中访问，可以定义一个对象，然后打点调用；也可以直接解构赋值</li></ul><pre><code>&lt;!-- slotProps 名字可自定义 --&gt;&lt;MyComponent v-slot=&quot;slotProps&quot;&gt;  &#123;&#123; slotProps.msg &#125;&#125; &#123;&#123; slotProps.count &#125;&#125;&lt;/MyComponent&gt;</code></pre><ol start="2"><li>具名作用域插槽</li></ol><ul><li>我们要在父组件中接受对应具名插槽传过来的<code>props</code>，可以在插槽内容对应的<code>&lt;template&gt;</code>标签上的<code>v-slot</code>指令的值中被访问到。</li><li>如果一个组件中同时使用了默认插槽和具名插槽，则默认插槽内容一定要写在<code>&lt;template #default&gt;</code>标签中,然后以 <code>#default=&quot;defaultProps&quot;</code>方式来接受值。如果直接在子组件的<code>v-slot</code>中来接受，会导致编译错误。这是为了避免因默认插槽的 <code>props</code> 的作用域而困惑</li></ul><pre><code>&lt;MyComponent&gt;  &lt;template #header=&quot;headerProps&quot;&gt; &#123;&#123; headerProps &#125;&#125; &lt;/template&gt;  &lt;!--这里是用来接受默认插槽传过来的props--&gt;  &lt;template #default=&quot;defaultProps&quot;&gt; &#123;&#123; defaultProps &#125;&#125; &lt;/template&gt;  &lt;template #footer=&quot;footerProps&quot;&gt; &#123;&#123; footerProps &#125;&#125; &lt;/template&gt;&lt;/MyComponent&gt;</code></pre><ul><li>以下写法是错的</li></ul><pre><code>&lt;MyComponent v-slot=&quot;defaultProps&quot;&gt;  &lt;template #header=&quot;headerProps&quot;&gt; &#123;&#123; headerProps &#125;&#125; &lt;/template&gt;  &lt;template #footer=&quot;footerProps&quot;&gt; &#123;&#123; footerProps &#125;&#125; &lt;/template&gt;&lt;/MyComponent&gt;</code></pre><ul><li>以下方式向具名插槽出口中传入 props</li></ul><pre><code>&lt;slot name=&quot;header&quot; msg=&quot;hello&quot; count=&quot;1&quot;&gt;&lt;/slot&gt;</code></pre><blockquote><p>插槽上的<code>name</code>属性是一个 Vue 特别保留的<code>attribute</code>，不会作为<code>props</code>传递给插槽。</p></blockquote><ul><li><p>因此，最终<code>headerProps</code>的结果是<code>&#123; msg: &#39;hello&#39; ,count:1&#125;</code></p></li><li><p>每个插槽出口对外传递的 props，只能在当前插槽对应的插槽内容中使用</p></li></ul><ol start="3"><li>作用域插槽的应用场景</li></ol><ul><li>如果某个组件同时封装了逻辑和视图，然而又希望把一部视图的输出交给父组件来实现，这时子组件需要将一部分数据供给给到插槽让父组件来使用。就好比上面讲到高级列表组件。</li><li>当然还有一部分组件只封装了逻辑，没有视图，我们在使用这部分组件时，子组件也需把数据提供给到插槽 供父组件来使用</li></ul><ol start="4"><li>案例：获取鼠标坐标<blockquote><p>我们期望实现一个组件，这个组件内部主要封装了获取鼠标坐标的功能。当我们在使用这些组件时，我们希望拿在父组件中拿到当前鼠标的坐标，然后显示在页面中</p></blockquote></li></ol><ul><li><code>&lt;MouseTracker&gt;</code>组件代码实现逻辑</li></ul><pre><code>&lt;script&gt;export default &#123;  data() &#123;    return &#123;      X: 0,      Y: 0,    &#125;;  &#125;,  methods: &#123;    updata(e) &#123;      this.X = e.pageX;      this.Y = e.pageY;    &#125;,  &#125;,  mounted() &#123;    window.addEventListener(&quot;mousemove&quot;, this.updata);  &#125;,  unmounted() &#123;    window.removeEventListener(&quot;mousemove&quot;, this.updata);  &#125;,&#125;;&lt;/script&gt;&lt;template&gt;  &lt;slot :x=&quot;X&quot; :y=&quot;Y&quot;&gt;&lt;/slot&gt;&lt;/template&gt;</code></pre><ul><li><code>App.vue</code>根组件</li></ul><pre><code>&lt;script&gt;import Mouse from &quot;./components/Mouse.vue&quot;;export default &#123;  components: &#123;    Mouse,  &#125;,&#125;;&lt;/script&gt;&lt;template&gt;  &lt;Mouse v-slot=&quot;&#123; x, y &#125;&quot;&gt;Mouse is at:&#123;&#123; x &#125;&#125;,&#123;&#123; y &#125;&#125;&lt;/Mouse&gt;&lt;/template&gt;</code></pre><h3 id="二、祖先组件向孙组件传值-依赖与注入"><a href="#二、祖先组件向孙组件传值-依赖与注入" class="headerlink" title="二、祖先组件向孙组件传值 - 依赖与注入"></a>二、祖先组件向孙组件传值 - 依赖与注入</h3><h4 id="Prop-逐级透传问题"><a href="#Prop-逐级透传问题" class="headerlink" title="Prop 逐级透传问题"></a>Prop 逐级透传问题</h4><blockquote><p>通常情况下，当我们需要从父组件向子组件传递数据时，会使用<code>props</code></p></blockquote><ul><li>但如果出现如下图所示情况，我们需要将组件<code>&lt;Root&gt;</code>中的数据传递给到孙组件<code>&lt;Item&gt;</code>或后代组件<code>&lt;ListChild&gt;</code>时要如何传呢 ？<img src="props逐级透传问题1.png"></li></ul><blockquote><p>如果用之前讲到的<code>props</code>来实现，传递方式如下图：</p></blockquote><ul><li>数据从<code>&lt;Root&gt;</code>组件传到<code>&lt;Item&gt;</code>组件：需要先将数据传递给到<code>&lt;Aside&gt;</code>组件，再通过<code>&lt;Aside&gt;</code>组件传递给到<code>&lt;Item&gt;</code>组件。</li><li>数据从<code>&lt;Root&gt;</code>组件传到<code>&lt;ListChild&gt;</code>组件：需要先将数据传递给到<code>&lt;Main&gt;</code>组件，再通过<code>&lt;Main&gt;</code>组件传递给到<code>&lt;List&gt;</code>组件，最后通过<code>&lt;List&gt;</code>组件传递给到<code>&lt;ListChild&gt;</code>组件<img src="props逐级透传问题2.png"></li></ul><blockquote><p>Prop 逐级透传问题：</p></blockquote><ul><li>利用<code>props</code>将<code>&lt;Root&gt;</code>中的数据传递给到<code>&lt;Item&gt;</code>组件时，需要先把数据传递给到<code>&lt;Aside&gt;</code>组件。</li><li>但<code>&lt;Aside&gt;</code>组件可能根本不关心这些<code>props</code>，但为了使<code>&lt;Item&gt;</code>能访问到它们，他需要接受并继续向下传递，<strong>造成当前组件数据管理的混乱</strong></li><li>如果组件链路非常长，一层一层传递非常麻烦，同时会影响到这条链路上的其它组件。这一问题被称为“prop 逐级透传”，显然是我们希望尽量避免的情况</li></ul><h4 id="依赖与注入定义"><a href="#依赖与注入定义" class="headerlink" title="依赖与注入定义"></a>依赖与注入定义</h4><ul><li>一个父组件相对于其所有的后代组件而言，他是数据提供者，我们称为<strong>依赖提供（Provide）者</strong>。</li><li>所有该组件的后代组件，无论层级有多深，都可以<strong>注入（Inject）</strong>由祖先组件提供给整条链路的数据（依赖）<img src="依赖与注入.png"></li></ul><h4 id="依赖注入的基本使用"><a href="#依赖注入的基本使用" class="headerlink" title="依赖注入的基本使用"></a>依赖注入的基本使用</h4><blockquote><p>祖先组件向后代组件提供数据，后代组件能接受到数据。</p></blockquote><ul><li>需要经过以下两步：<blockquote><p>①、Provider （提供）</p></blockquote></li><li>祖先组件要为后代组件提供数据，需要用到<code>provide</code>选项</li><li><code>provide</code>对象上的每一个属性，后代组件会用其<code>key</code>为注入名查找期望注入的值，属性的值就是要提供的数据。</li></ul><pre><code>export default &#123;  provide: &#123;    message: &quot;Hello props&quot;,  &#125;,&#125;;</code></pre><blockquote><p>②、Inject （注入）</p></blockquote><ul><li>要注入上层组件提供的数据，需使用<code>inject</code>选项来声明：</li></ul><pre><code>export default &#123;  inject: [&quot;message&quot;],&#125;;</code></pre><h4 id="provide-选项"><a href="#provide-选项" class="headerlink" title="provide 选项"></a>provide 选项</h4><blockquote><p>关于<code>provide</code>选项在提供数据时，有以下几个需要特别注意的点</p></blockquote><ul><li>如何提供组件实例的状态（如：<code>data()</code>定义的数据属性）</li><li>如何保证<code>inject</code>注入数据时保持响应性</li><li>如何修改<code>inject</code>注入的数据<ul><li>接下来，我们就针对这三个点分别展开讲解</li></ul></li></ul><ol><li>提供组件实例的状态<blockquote><p>如果我们需要提供依赖当前组件实例的状态（比如：那些由<code>data()</code>定义的数据属性），<code>provide</code>选项的值必需改写成函数形式。</p></blockquote></li></ol><pre><code>export default &#123;  data() &#123;    return &#123;      message: &quot;Hello props&quot;,    &#125;;  &#125;,  provide() &#123;    return &#123;      msg: this.message, // 访问data中的属性    &#125;;  &#125;,&#125;;</code></pre><ul><li>这种方式提供的数据，在注入时不会保持响应性，如在子组件中通过<code>this.msg=&#39;Hello update</code>更新<code>msg</code>的值，页面并不会同步更新。</li></ul><ol start="2"><li>inject 注入数据时保持响应性<blockquote><p>如果需要使提供的数据在注入时保持响应性，我们需要使用<code>computed()</code>函数提供一个计算属性</p></blockquote></li></ol><pre><code>//导入computed()函数import &#123; computed &#125; from &quot;vue&quot;;export default &#123;  data() &#123;    return &#123;      message: &quot;Hello props&quot;,    &#125;;  &#125;,  provide() &#123;    return &#123;      // msg的值是一个计算属性      msg: computed(() =&gt; this.message),    &#125;;  &#125;,&#125;;</code></pre><blockquote><p>临时配置要求</p></blockquote><ul><li>上面的用例需要设置 <code>app.config.unwrapInjectedRef = true</code> 以保证注入会自动解包这个计算属性。</li><li>这将会在 <code>Vue 3.3</code> 后成为一个默认行为，而我们暂时在此告知此项配置以避免后续升级对代码的破坏性。在 <code>3.3</code> 后就不需要这样做了</li></ul><pre><code>// main.js中添加以下配置app.config.unwrapInjectedRef = true;</code></pre><ol start="3"><li>如何操作 inject 注入的数据<blockquote><p>如果我们需要在后代组件中操作<code>inject</code>注入的数据，推荐在上层组件提供数据时，顺带提供操作此数据的方法。</p></blockquote></li></ol><ul><li><code>App.vue</code>根组件</li></ul><pre><code>import &#123; computed &#125; from &quot;vue&quot;;export default &#123;  data() &#123;    return &#123;      message: &quot;Hello props&quot;,    &#125;;  &#125;,  // 提供了message数据和更新该数据的update方法  provide() &#123;    return &#123;      message: computed(() =&gt; this.message),      update: this.update,    &#125;;  &#125;,  methods: &#123;    update() &#123;      console.log(&quot;更新&quot;);      this.message = &quot;Hello update!!&quot;;    &#125;,  &#125;,&#125;;</code></pre><ul><li><code>Item.vue</code>孙组件</li></ul><pre><code>&lt;script&gt;  export default &#123;    inject: [&quot;msg&quot;, &quot;update&quot;],  &#125;;&lt;/script&gt;&lt;template&gt;  &lt;button @click=&quot;update&quot;&gt;更新&lt;/button&gt;  &lt;div class=&quot;item&quot;&gt;Item组件中显示：&#123;&#123; msg &#125;&#125;&lt;/div&gt;&lt;/template&gt;</code></pre><h4 id="应用层-Provide"><a href="#应用层-Provide" class="headerlink" title="应用层 Provide"></a>应用层 Provide</h4><blockquote><p>除了在一个组件中提供依赖，我们还可以在整个应用层面提供依赖</p></blockquote><pre><code>import &#123; createApp &#125; from &quot;vue&quot;;const app = createApp(&#123;&#125;);app.provide(&quot;msg&quot;, &quot;hello!&quot;); // msg 为注入名   hello 为值</code></pre><ul><li>在应用级别提供（provide）的数据在该应用内的所有组件中都可以注入（inject）。这在你编写插件时会特别有用，因为插件一般都不会使用组件形式来提供值。</li></ul><h4 id="注入（Inject）"><a href="#注入（Inject）" class="headerlink" title="注入（Inject）"></a>注入（Inject）</h4><blockquote><p>在子组件中注入上层组件提供的数据时，有以下几个需要注意的点</p></blockquote><ul><li>注入被解析时机</li><li>注入别名</li><li>注入默认值<ul><li>接下来，我们就针对这三个点分别展开讲解。</li></ul></li></ul><ol><li>注入被解析时机<blockquote><p><code>inject</code>（注入）会在组件自身的状态<strong>之前</strong>被解析，你可以在</p></blockquote></li></ol><ul><li><code>data()</code>、<code>method</code>、<code>computed</code>等中访问到注入的属性</li><li>在<code>created</code>生命周期函数中访问到。</li><li>在<code>beforeCreate</code>生命周期函数中是访问不到的</li></ul><pre><code>export default &#123;  inject: [&quot;msg&quot;],  data() &#123;    return &#123;      text: this.msg,    &#125;;  &#125;,  methods: &#123;    print() &#123;      console.log(&quot;打印msg&quot;, this.msg);    &#125;,  &#125;,  computed: &#123;    newMsg() &#123;      return this.msg + &quot; computed&quot;;    &#125;,  &#125;,&#125;;</code></pre><ol start="2"><li>注入别名<blockquote><p>如果我们想在子组件中用一个不同的本地属性名注入上层组件提供的属性时，<code>inject</code>选项需要采用以下对象写法</p></blockquote></li></ol><pre><code>&lt;script&gt;  export default &#123;    // 必须使用对象形式    inject: &#123;      // text 为本地属性名      text: &#123;        from: &quot;msg&quot;, // 注入来源名，msg为上层组件提供的属性（注入名）      &#125;,    &#125;,  &#125;;&lt;/script&gt;&lt;template&gt;  &lt;!--使用注入的属性--&gt;  &lt;div&gt;&#123;&#123; text &#125;&#125;&lt;/div&gt;&lt;/template&gt;</code></pre><ol start="3"><li>注入默认值<blockquote><p>如果<code>inject</code>选项中声明的注入名没有被提供，则会抛出一个运行时警告。所以在注入一个值时不要求必须有提供者，那么我们应该声明一个默认值</p></blockquote></li></ol><ul><li>这样在注入名没有被提供时，会采用默认值，如果有被提供，则采用提供的值。</li><li>不过此时<code>inject</code>选项必须使用对象形式来书写</li></ul><pre><code>export default &#123;  // 当声明注入的默认值时  // 必须使用对象形式  inject: &#123;    text: &#123;      from: &quot;msg&quot;, // 注入来源，如果本地属性名与原注入名相同，这个属性是可选的      default: &quot;default value&quot;, // 默认值    &#125;,    count: &#123;      from: &quot;count&quot;, // 当与原注入名同名时，这个属性是可选的      // 如果默认值需要经过复杂的计算，则可以写成函数      default() &#123;        //....        return 0;      &#125;,    &#125;,  &#125;,&#125;;</code></pre><ul><li>当本地属性名与原注入名同名时，可以只写默认值，不写<code>from</code></li><li>注意：<code>count</code>和<code>&quot;count&quot;</code>才是同名的；如果<code>from</code>后面的值不带引号，就是变量</li></ul><ol start="4"><li>代码演示</li></ol><ul><li><code>App.vue</code>根组件</li></ul><pre><code>&lt;script&gt;  import Aside from &quot;./components/Aside.vue&quot;;  import &#123; computed &#125; from &quot;vue&quot;;  export default &#123;    data() &#123;      return &#123;        count: 10,        message: &quot;Hello props&quot;,      &#125;;    &#125;,    // 提供数据    provide() &#123;      return &#123;        msg: computed(() =&gt; this.message),        count: computed(() =&gt; this.count),        countAdd: this.add,      &#125;;    &#125;,    methods: &#123;      // 更新count的方法      add() &#123;        this.count++;      &#125;,    &#125;,    components: &#123;      Aside,    &#125;,  &#125;;&lt;/script&gt;&lt;template&gt;  &lt;aside /&gt;&lt;/template&gt;</code></pre><ul><li><code>Aside.vue</code>子组件</li></ul><pre><code>&lt;script&gt;  import Item from &quot;./Item.vue&quot;;  export default &#123;    components: &#123;      Item,    &#125;,  &#125;;&lt;/script&gt;&lt;template&gt;  &lt;div class=&quot;aside&quot;&gt;    &lt;Item&gt;&lt;/Item&gt;  &lt;/div&gt;&lt;/template&gt;</code></pre><ul><li><code>Item.vue</code>孙组件</li></ul><pre><code>&lt;script&gt;  export default &#123;    // 注入数据    inject: &#123;      text: &#123;        from: &quot;msg&quot;,        default: &quot;default value&quot;,      &#125;,      count: &#123;        // 如果默认值需要经过复杂的计算，则可以写成函数        default() &#123;          //....          return 0;        &#125;,      &#125;,      countAdd: &#123;        from: &quot;countAdd&quot;,      &#125;,    &#125;,    data() &#123;      return &#123;        // 基本数据类型，count的值更新了，newCount的值不会更新        newCount: this.count,      &#125;;    &#125;,  &#125;;&lt;/script&gt;&lt;template&gt;  &lt;button @click=&quot;countAdd&quot;&gt;count++&lt;/button&gt;  &lt;div&gt;text的值：&#123;&#123; text &#125;&#125;&lt;/div&gt;  &lt;div&gt;count的值：&#123;&#123; count &#125;&#125;&lt;/div&gt;  &lt;div&gt;newCount的值 &#123;&#123; newCount &#125;&#125;&lt;/div&gt;&lt;/template&gt;</code></pre><h4 id="使用-Symbol-作为注入名"><a href="#使用-Symbol-作为注入名" class="headerlink" title="使用 Symbol 作为注入名"></a>使用 Symbol 作为注入名</h4><blockquote><p>但如果你正在构建大型的应用，包含非常多的依赖提供，或者你正在编写提供给其他开发者使用的组件库。</p></blockquote><ul><li>建议最好使用<code>Symbol</code>来作为注入名以避免潜在的冲突。</li><li>我们通常推荐在一个单独的文件中导出这些注入名<code>Symbol</code>：</li></ul><blockquote><p><code>keys.js</code></p></blockquote><ul><li>注意在提供依赖时，要使用方括号</li></ul><pre><code>export const count = Symbol(&quot;count&quot;);export const msg = Symbol(&quot;msg&quot;);</code></pre><ul><li>在供给方组件</li></ul><pre><code>import &#123; computed &#125; from &quot;vue&quot;;import &#123; count, msg &#125; from &quot;./keys.js&quot;;export default &#123;  data() &#123;    return &#123;      count: 10,      message: &quot;Hello props&quot;,    &#125;;  &#125;,  provide() &#123;    return &#123;      /* msgt 和 count 为Symbol类型，则需要采用[]方括号写法*/      [msg]: computed(() =&gt; this.message),      [count]: computed(() =&gt; this.count),    &#125;;  &#125;,&#125;;</code></pre><blockquote><p>注入方组件</p></blockquote><ul><li>注意，此时导入的是<code>Symbol</code>类型的变量，本地属性名和注入来源名 看起来一样但并不同名，注入时不能省略</li></ul><pre><code>// 导入keysimport &#123; count, msg &#125; from &quot;../keys.js&quot;;export default &#123;  // 注入数据  inject: &#123;    text: &#123;      from: msg,      default: &quot;default value&quot;,    &#125;,    count: &#123;      from: count,      // 如果默认值需要经过复杂的计算，则可以写成函数      default() &#123;        //....        return 0;      &#125;,    &#125;,  &#125;,&#125;;</code></pre><blockquote><p>注意事项</p></blockquote><ul><li>依赖注入主要用来实现上层组件向后代组件传递数据，所以父子间传递数据也是可行的。</li><li>但是父子组件间传递数据，更推荐使用<code>props</code>来实现。</li></ul><h3 id="三、兄弟组件间通信-发布与订阅"><a href="#三、兄弟组件间通信-发布与订阅" class="headerlink" title="三、兄弟组件间通信 - 发布与订阅"></a>三、兄弟组件间通信 - 发布与订阅</h3><h4 id="借助父组件完成兄弟组件通信"><a href="#借助父组件完成兄弟组件通信" class="headerlink" title="借助父组件完成兄弟组件通信"></a>借助父组件完成兄弟组件通信</h4><ul><li>下图中的组件 A 与组件 B 为兄弟组件，组件 App 为他们共同的父组件<img src="兄弟组件通信.png"></li></ul><blockquote><p>注：</p></blockquote><ul><li>如果组件 A 需要把变量 state 的值传递给到组件 B，可以先把 state 的值传递给到父组件 App，然后父组件 App 再把 state 的值传递给到 B 组件。<blockquote><p>实现原理</p></blockquote></li><li>把变量 state 定义在 App 组件中，然后通过<strong>自定义属性</strong>递给到 B 组件。</li><li>在 App 组件中监听<strong>自定义事件</strong><code>on-state</code>，当事件触发时修改 state 的值。</li><li>在 A 组件中触发<code>onState</code>事件，来修改 state 的值</li></ul><blockquote><p>代码示例</p></blockquote><ul><li><code>App.vue</code>文件</li></ul><pre><code>&lt;script&gt;  import A from &quot;./components/A.vue&quot;;  import B from &quot;./components/B.vue&quot;;  export default &#123;    data() &#123;      return &#123;        state: 1,      &#125;;    &#125;,    components: &#123;      A,      B,    &#125;,    methods: &#123;      setState(value) &#123;        this.state = value;      &#125;,    &#125;,  &#125;;&lt;/script&gt;&lt;template&gt;  &lt;a @on-state=&quot;setState&quot;&gt;&lt;/a&gt;  &lt;b :state=&quot;state&quot;&gt;&lt;/b&gt;&lt;/template&gt;</code></pre><ul><li>A.vue文件，在A组件中，触发<code>onState</code>事件，修改<code>state</code>的值</li></ul><pre><code>&lt;script&gt;  export default &#123;    emits: [&quot;onState&quot;],  &#125;;&lt;/script&gt;&lt;template&gt;  &lt;button @click=&quot;$emit(&#39;onState&#39;, 10)&quot;&gt;A组件中修改state的值&lt;/button&gt;&lt;/template&gt;</code></pre><ul><li>B.vue文件，在 B 组件中接受传递过的 state 属性值，并显示</li></ul><pre><code>&lt;script&gt;  export default &#123;    props: [&quot;state&quot;],  &#125;;&lt;/script&gt;&lt;template&gt;  &lt;div&gt;B组件中state的值：&#123;&#123; state &#125;&#125;&lt;/div&gt;&lt;/template&gt;</code></pre><h4 id="借助父组件通信的问题"><a href="#借助父组件通信的问题" class="headerlink" title="借助父组件通信的问题"></a>借助父组件通信的问题</h4><blockquote><p>通过前面例子，我们知道借助父组件完成兄弟组件间通信显然是非常麻烦的，原本属于 A 组件的 state 属性需要定义在 App 组件中，造成了数据管理的混乱。</p></blockquote><ul><li><p>如果通信的两个组件层级较深，如下图</p><img src="兄弟组件通信-层级较深.png"></li><li><p>A1 组件需要与 B1 组件通信，则数据传递链接从<code>A1 -&gt; A -&gt; App -&gt; B -&gt; B1</code>。这显然是非常麻烦，而且数据的管理将会变得更加混乱</p></li><li><p>接下来讲到的发布与订阅模式是一种非常好的兄弟组件间通信的方式，他可以让 A1 组件直接与 B1 组件通信，不需要借助其它组件</p></li></ul><h4 id="发布与订阅模式"><a href="#发布与订阅模式" class="headerlink" title="发布与订阅模式"></a>发布与订阅模式</h4><ul><li>发布与订阅模式其实是对象间的一种一对多的依赖关系，当一个对象的状态发生改变时，所有依赖于它的对象都将得到通知。<blockquote><p>真实的发布者与订阅者</p><ul><li>在实际生活中，我们知道售楼部其实是一个一中介，他负责给房地产公司发布售楼相关的消息，同时购买者通过售数部订阅售楼消息。所以</li></ul></blockquote></li><li><strong>发布者</strong>：是房产公司，因为真正要对外发布售楼信息的是房产公司，而售楼部只是代替房产公司对外发布消息。</li><li><strong>订阅者</strong>：是购买房子的用户，他需要向售楼部订阅房产公司的售楼消息</li><li><strong>发布订阅中心</strong>：是售楼中心，房产公司找售楼部发布售楼消息，购房者找售楼部订阅售楼消息<ul><li>由此可以知道，发布消息与订阅消息的接口都是发布订阅中心提供的。</li></ul></li></ul><blockquote><p>发布订阅的本质</p></blockquote><ul><li>发布订阅核心基于一个中心来建立整个体系。其中发布者和订阅者不直接进行通信，而是发布者将要发布的消息交由中心管理，订阅者也是根据自己的情况，按需订阅订阅中心的消息</li><li>我们用下面一张图来描述发布订阅模式<img src="发布订阅模式.png"></li><li>发布订阅中心提供了发布消息和订阅消息的接口（API 方法），发布者调用发布消息接口即可发布消息，订阅者调用订阅消息接口就可以订阅消息</li></ul><h4 id="简单版：发布与订阅"><a href="#简单版：发布与订阅" class="headerlink" title="简单版：发布与订阅"></a>简单版：发布与订阅</h4><ul><li>我们以上面售楼的故事为例子，利用 JS 实现简单版的发布与订阅。<blockquote><p>实现思路</p></blockquote></li><li>①、定义一个对象，充当售楼部（发布订阅中心）</li><li>②、在该对象上创建一个缓存列表，存放订阅的事件（消息），相当于存放订阅者微信号</li><li>③、在对象上添加 on 方法，用于订阅消息，调用 on 方法把订阅的事件都添加到缓存列表中，相当于注册（监听）事件</li><li>④、在对象上添加 emit 方法，用于发布消息，调用 emit 方法来触发事件（相当于发布消息）</li></ul><pre><code>// 1、定义一个对象，充当售楼部（发布订阅中心）let salesOffices = &#123;&#125;;// 2、在该对象上创建一缓存列表，存放订阅的事件（消息），相当于存放订阅者微信号salesOffices.clientList = [];// 3、添加订阅方法，将订阅的事件（消息）添加进缓存列表salesOffices.on = function (fn) &#123;  // 订阅的消息添加进缓存列表  this.clientList.push(fn);&#125;;// 4、添加emit方法，用于发布消息// 发布消息时，会去遍历缓存列表中的回调函数，并执行。相当于触发事件的事件处理函数salesOffices.emit = function () &#123;  for (let i = 0; i &lt; this.clientList.length; i++) &#123;    // 修改订阅者回调内的this    // 发布消息时会带上一些消息相关的信息，这些信息做为参数传入即：arguments    this.clientList[i].apply(this, arguments);  &#125;&#125;;</code></pre><ul><li>测试以上代码</li></ul><pre><code>// 小明订阅消息salesOffices.on((area, price) =&gt; &#123;  console.log(`当前房子面积是:$&#123;area&#125;平方米，价格为:$&#123;price&#125;万`);&#125;);// 小花订阅消息salesOffices.on((area, price) =&gt; &#123;  console.log(`当前房子面积是:$&#123;area&#125;平方米，价格为:$&#123;price&#125;万`);&#125;);// 售楼部发布消息salesOffices.emit(2000000, 110);salesOffices.emit(1000000, 55);</code></pre><img src="简单版发布与订阅结果.png">- 根据结果可知：每一次发布消息，都会将消息发给所有订阅者<h4 id="按主题发布与订阅"><a href="#按主题发布与订阅" class="headerlink" title="按主题发布与订阅"></a>按主题发布与订阅</h4><ul><li>上面我们已经实现了一个简单的发布与订阅模式，但还存在一些问题。我们看到订阅者接收到了发布者的每一个消息。如果小明只想买 55 平方米的房子，那发布者就不应该把 110 平方米房子的信息推送给小明，因为这对小明来说是一种困扰。</li><li>所以订阅者在订阅消息时应该要<strong>根据主题来订阅</strong>，发布者在发布消息时也要<strong>根据主题来发布</strong>，只有订阅了该主题的订阅者才能收到该主题发布的消息。</li><li>我们需要把缓存列表，修改成一个<strong>对象</strong>，根据订阅的主题来存放订阅者的回调函数</li></ul><pre><code>salesOffices.clientList = &#123;&#125;;</code></pre><ul><li>以下代码实现了按主题订阅和发布消息</li></ul><pre><code>// 1、定义一个对象，充当售楼部（发布订阅中心）let salesOffices = &#123;&#125;;// 2、在该对象上创建一缓存列表，存放订阅的事件（消息）// 订阅的事件（消息）分为：事件名与事件处理函数，所以我们用一个对象来存放salesOffices.clientList = &#123;&#125;;// 3、增加订阅事件，key为事件名，fn为事件名对应的事件处理函数salesOffices.on = function (key, fn) &#123;  // 如果没有订阅此事件名，给该事件名创建一个缓存事件处理函数的列表  if (!this.clientList[key]) &#123;    this.clientList[key] = [];  &#125;  // 将事件处理函数添加到事件名对应的事件处理函数缓存列表  this.clientList[key].push(fn);&#125;;// 4、售楼处发布消息// 发布消息时，会根据事件名去遍历对应缓存列表中的事件处理函数，并执行。相当于触发事件的事件处理函数salesOffices.emit = function () &#123;  // 取出事件名  let key = Array.prototype.shift.call(arguments);  // 根据事件名取出对应的缓存列表  const fns = this.clientList[key];  // 如果没有订阅  if (!fns || fns.length === 0) &#123;    return false;  &#125;  for (let i = 0; i &lt; fns.length; i++) &#123;    // 修改订阅者回调内的this    // 发布者在发布消息时会带上一些消息相关的信息，这些信息做为参数传入即：arguments    fns[i].apply(this, arguments);  &#125;&#125;;</code></pre><ul><li>测试以上代码</li></ul><pre><code>// 小明订阅消息salesOffices.on(&quot;area110&quot;, (area, price) =&gt; &#123;  console.log(`当前房子面积是:$&#123;area&#125;平方米，价格为:$&#123;price&#125;万`);&#125;);// 小花订阅消息salesOffices.on(&quot;area80&quot;, (area, price) =&gt; &#123;  console.log(`当前房子面积是:$&#123;area&#125;平方米，价格为:$&#123;price&#125;万`);&#125;);// 售楼部发布消息salesOffices.emit(&quot;area110&quot;, 2000000, 110);salesOffices.emit(&quot;area80&quot;, 1000000, 55);</code></pre><img src="按主题发布订阅结果.png"><h4 id="完整版：发布与订阅"><a href="#完整版：发布与订阅" class="headerlink" title="完整版：发布与订阅"></a>完整版：发布与订阅</h4><blockquote><p>一个完整的发布订阅应该包含以下 4 个方法</p></blockquote><ul><li><code>on</code>方法：用来订阅事件，即根据事件名添加对应的事件处理回调函数到对应缓存列表</li><li><code>emit</code>方法：用来触发事件，即根据事件名查询缓存列表中的事件处理函数，并执行。</li><li><code>off</code>方法：用来取消订阅事件，即根据事件名查询缓存列表中的事件处理函数，并从列表中移除。</li><li><code>once</code>方法：用来订阅事件，但只订阅一次，即事件触发后，就会取消该事件的订阅</li></ul><pre><code>// 1、定义一个对象，充当售楼部（发布订阅中心）let salesOffices = &#123;&#125;;// 2、在该对象上创建一缓存列表，存放订阅的事件（消息）// 订阅的事件（消息）分为：事件名与事件处理函数，所以我们用一个对象来存放salesOffices.clientList = &#123;&#125;;// 3、增加订阅事件，key为事件名，fn为事件名对应的事件处理函数salesOffices.on = function (key, fn) &#123;  // 如果没有订阅此事件名，给该事件名创建一个缓存事件处理函数的列表  if (!this.clientList[key]) &#123;    this.clientList[key] = [];  &#125;  // 将事件处理函数添加到事件名对应的事件处理函数缓存列表  // this.clientList[key].push(fn)  this.clientList[key].unshift(fn);&#125;;// 4、售楼处发布消息// 发布消息时，会根据事件名去遍历对应缓存列表中的事件处理函数，并执行。相当于触发事件的事件处理函数salesOffices.emit = function () &#123;  // 取出事件名  let key = Array.prototype.shift.call(arguments);  // 根据事件名取出对应的缓存列表  const fns = this.clientList[key];  // 如果没有订阅  if (!fns || fns.length === 0) &#123;    return false;  &#125;  // 注意，这里要从后放前遍历，因为once的事件会执行一次后被取消  for (let i = fns.length - 1; i &gt;= 0; i--) &#123;    // 修改订阅者回调内的this    // 发布者在发布消息时会带上一些消息相关的信息，这些信息做为参数传入即：arguments    fns[i].apply(this, arguments);  &#125;&#125;;// 5、取消订阅salesOffices.off = function (key, fn) &#123;  // 根据事件名取出对应的缓存列表  const fns = this.clientList[key];  // 如果没有订阅  if (!fns || fns.length === 0) &#123;    return false;  &#125;  // 不传订阅事件处理函数，意味着取消所有订阅  !fn &amp;&amp; fns &amp;&amp; (fns.length = 0);  // 传了事件处理函数，取消事件对应的事件处理函数  for (let i = 0; i &lt; fns.length; i++) &#123;    // 注意要判断 fns[i].fn===fn,主要用来判断once绑定时    if (fns[i] === fn || fns[i].fn === fn) &#123;      fns.splice(i, 1);      break;    &#125;  &#125;&#125;;// 6、只订阅一次salesOffices.once = function (key, fn) &#123;  const _that = this;  // emit触发时，执行的是on这个方法  function on() &#123;    // 先执行一次，再取消    fn.apply(_that, arguments);    // 先取消    _that.off(key, on);  &#125;  // 取消时，要判断on.fn===fn，如果等于，则移除该项  on.fn = fn;  // 订阅  this.on(key, on);&#125;;</code></pre><blockquote><p>以上代码有几个需要注意的点</p></blockquote><ul><li>emit 方法中，遍历事件名对应的缓存列表，改成<strong>从后往前</strong>遍历。因为 once 订阅事件只订阅一次，触发一次后就会从列表中删除，造成数组长度变短，后续事件处理函数无法被执行</li></ul><pre><code>/*for (let i =0 ; i &lt; fns.length; i++) &#123;    fns[i].apply(this, arguments)&#125;*/for (let i = fns.length - 1; i &gt;= 0; i--) &#123;  fns[i].apply(this, arguments);&#125;</code></pre><ul><li>on 方法中，将事件处理函数添加到事件名对应的缓存列表，改成<strong>从前往后</strong>加入。这样做的目的是保证从后往前遍历缓存列表时，先触发的是先订阅的事件。</li></ul><pre><code>// this.clientList[key].push(fn)this.clientList[key].unshift(fn);</code></pre><ul><li>off 方法中，在移除事件名对应的事件处理函数时，要考虑 once 绑定的情况。</li></ul><pre><code>/*    for (let i = 0; i &lt; fns.length; i++) &#123;        // 注意要判断 fns[i].fn===fn , 主要用来判断once绑定时        if (fns[i] === fn) &#123;            fns.splice(i, 1);            break;        &#125;    &#125;*/for (let i = 0; i &lt; fns.length; i++) &#123;  // 注意要判断 fns[i].fn===fn , 主要用来判断once绑定时  if (fns[i] === fn || fns[i].fn === fn) &#123;    fns.splice(i, 1);    break;  &#125;&#125;</code></pre><h4 id="发布与订阅模式实现组件间通信"><a href="#发布与订阅模式实现组件间通信" class="headerlink" title="发布与订阅模式实现组件间通信"></a>发布与订阅模式实现组件间通信</h4><ul><li><p>接下来我们利用发布与订阅来实现 A 组件与 B 组件间的通信，实现原理如下图：</p><img src="用发布与订阅模式实现组件间通信.png"></li><li><p>在<code>main.js</code>中将订阅发布对象<code>pubsub</code>（相当前面说的 <code>salesOffices</code>）绑定到全局<code>$event</code>变量上，这样在任意组件内部就可以通过<code>this.$event</code>访问到<code>pubsub</code>对象</p></li></ul><pre><code>app.config.globalProperties.$event = pubsub;</code></pre><blockquote><ul><li>注意：这里的<code>$event</code>与之前学过的不一样；这个全局变量的名字可以随便取</li></ul></blockquote><ul><li>在 B 组件中订阅<code>setState</code>事件，在事件回调函数中接受传过来的值<code>state</code>值</li></ul><pre><code>// $event 为订阅发布中心this.$event.on(&quot;setState&quot;, (state) =&gt; &#123;  this.state = state;&#125;);</code></pre><ul><li>当组件 A 中 state 变量值发生变化时，触发<code>setState</code>事件，将 state 变量的值做为 emit 方法参数传入</li></ul><pre><code>this.state = 10;this.$event.emit(&quot;setState&quot;, this.state);</code></pre><blockquote><p>完整代码</p></blockquote><ul><li><code>src/common/pubsub.js</code>文件内容如下：</li></ul><pre><code>// 1、定义一个对象，充当售楼部（发布订阅中心）let event = &#123;&#125;;// 2、在该对象上创建一缓存列表，存放订阅的事件（消息）// 订阅的事件（消息）分为：事件名与事件处理函数，所以我们用一个对象来存放event.clientList = &#123;&#125;;// 3、增加订阅事件，key为事件名，fn为事件名对应的事件处理函数event.on = function (key, fn) &#123;  // 如果没有订阅此事件名，给该事件名创建一个缓存事件处理函数的列表  if (!this.clientList[key]) &#123;    this.clientList[key] = [];  &#125;  // 将事件处理函数添加到事件名对应的事件处理函数缓存列表  // this.clientList[key].push(fn)  this.clientList[key].unshift(fn);&#125;;// 4、售楼处发布消息// 发布消息时，会根据事件名去遍历对应缓存列表中的事件处理函数，并执行。相当于触发事件的事件处理函数event.emit = function () &#123;  // 根据事件名取出对应的缓存列表  let key = Array.prototype.shift.call(arguments);  const fns = this.clientList[key];  // 如果没有订阅  if (!fns || fns.length === 0) &#123;    return false;  &#125;  // 注意，这里要从后放前遍历，因为once的事件会执行一次后被取消  for (let i = fns.length - 1; i &gt;= 0; i--) &#123;    // 修改订阅者回调内的this    // 发布者在发布消息时会带上一些消息相关的信息，这些信息做为参数传入即：arguments    fns[i].apply(this, arguments);  &#125;&#125;;// 5、取消订阅event.off = function (key, fn) &#123;  // 根据事件名取出对应的缓存列表  const fns = this.clientList[key];  // 如果没有订阅  if (!fns || fns.length === 0) &#123;    return false;  &#125;  // 不传订阅事件处理函数，意味着取消所有订阅  !fn &amp;&amp; fns &amp;&amp; (fns.length = 0);  // 传了事件处理函数，取消事件对应的事件处理函数  for (let i = 0; i &lt; fns.length; i++) &#123;    // 注意要判断 fns[i].fn===fn,主要用来判断once绑定时    if (fns[i] === fn || fns[i].fn === fn) &#123;      fns.splice(i, 1);      break;    &#125;  &#125;&#125;;// 6、只订阅一次event.once = function (key, fn) &#123;  const _that = this;  // emit触发时，执行的是on这个方法  function on() &#123;    // 先执行一次，再取消    fn.apply(_that, arguments);    // 先取消    _that.off(key, on);  &#125;  // 取消时，要判断on.fn===fn，如果等于，则移除该项  on.fn = fn;  // 订阅  this.on(key, on);&#125;;export default event;src/main.js文件内容import &#123; createApp &#125; from &quot;vue&quot;;import App from &quot;./App.vue&quot;;// 导入 pubsub 对象import pubsub from &quot;./common/pubsub.js&quot;;const app = createApp(App);// 将pubsub对象绑定到全局$event变量上，这样在组件内部就可以通过this.$event访问到pubsub对象app.config.globalProperties.$event = pubsub;app.mount(&quot;#app&quot;);</code></pre><ul><li><code>App.vue</code>文件内容</li></ul><pre><code>&lt;script&gt;  import A from &quot;./components/A.vue&quot;;  import B from &quot;./components/B.vue&quot;;  export default &#123;    components: &#123;      A,      B,    &#125;,  &#125;;&lt;/script&gt;&lt;template&gt;  &lt;a&gt;&lt;/a&gt;  &lt;b&gt;&lt;/b&gt;&lt;/template&gt;A.vue文件内容&lt;script&gt;  export default &#123;    data() &#123;      return &#123;        state: 1,      &#125;;    &#125;,    methods: &#123;      update() &#123;        this.state = 10; // 修改 state的值        // 在A组件中发布消息（即触发事件），将this.state的值传递给到B组件        this.$event.emit(&quot;setState&quot;, this.state);      &#125;,    &#125;,  &#125;;&lt;/script&gt;&lt;template&gt;  &lt;button @click=&quot;update&quot;&gt;更改state的值&lt;/button&gt;&lt;/template&gt;</code></pre><ul><li><code>B.vue</code>文件内容</li></ul><pre><code>&lt;script&gt;  export default &#123;    data() &#123;      return &#123;        state: 0,      &#125;;    &#125;,    created() &#123;      // 订阅（监听）setState事件      // 在事件处理函数中接受传过来的state的值，并将其赋值给B组件中的state变量      this.$event.on(&quot;setState&quot;, (value) =&gt; &#123;        console.log(value);        this.state = value;      &#125;);    &#125;,  &#125;;&lt;/script&gt;&lt;template&gt;  &lt;div&gt;B组件中state的值：&#123;&#123; state &#125;&#125;&lt;/div&gt;&lt;/template&gt;</code></pre><h4 id="mitt-插件"><a href="#mitt-插件" class="headerlink" title="mitt 插件"></a>mitt 插件</h4><blockquote><p><a href="https://www.npmjs.com/package/mitt">mitt 插件</a>就是一款实现发布与订阅功能的插件。</p></blockquote><ul><li>如果我们不想自己手写发布与订阅，在 Vue3 中就可以借助 mitt 插件来帮我们实现。</li></ul><blockquote><p>在 Vue3 中使用 mitt 插件的步骤如下：</p></blockquote><ul><li>执行以下命令在项目中安装 mitt 插件</li></ul><pre><code>npm install --save mitt</code></pre><ul><li>在<code>main.js</code>中导入 <code>mitt</code> 对象，并注册为全局变量，这样就可以任意组件中通过<code>this.$event</code>来访问</li></ul><pre><code>// 导入 mittimport mitt from &quot;mitt&quot;;const app = createApp(App);// 注册为全局变量 $eventapp.config.globalProperties.$event = mitt();app.mount(&quot;#app&quot;);</code></pre><ul><li>mitt 插件提供了以下方法来实现订阅与发布。</li></ul><pre><code>// 添加事件监听this.$event.on(&quot;foo1&quot;, fn);this.$event.on(&quot;foo2&quot;, fn);// 移除事件监听this.$event.off(&quot;foo1&quot;, fn);// 移除所有事件监听this.$event.all.clear();// 触发事件this.$event.emit(&quot;foo1&quot;, 1);this.$event.emit(&quot;foo2&quot;, 2);</code></pre><blockquote><p>注：</p></blockquote><ul><li>该插件没有 <code>once</code> 方法，如果需要 <code>once</code> 方法，推荐大家使用 <a href="https://www.npmjs.com/package/tiny-emitter"><code>tiny-emitter</code>插件</a>，用法一样</li><li>针对前面提到的 A 组件与 B 组件通信的案例，你只需要安装好 <code>mitt</code> 插件，然后把<code>main.js</code>内容替换成以上内容，其实现效果如前面一样</li></ul><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><ul><li><p>兄弟组件间通信可以采用以下两种方式：</p><blockquote><ul><li>借助父组件完成兄弟组件间通信</li></ul></blockquote></li><li><p>这种方式并不是最适合的方式，其中最大的问题就是使用起来较复杂，而且数据管理混乱。所以实际开发中很少用</p><blockquote><ul><li>利用发布订阅模式实现兄弟组件间通信</li></ul></blockquote></li><li><p>这种方式使用起来比较方便，如果自己不会手动实现订阅与发布可以借助<code>mitt</code>或<code>tiny-emitter</code>插件来实现。</p></li><li><p>不过这种方式也有一定的缺陷，<strong>对于代码的根踪和维护不方便</strong>。我们在一个组件中使用了<code>on</code>方法订阅事件，我们很难追踪到该事件是由哪个组件触发的，所以在使用时一定要加好注释。</p></li><li><p>在触发事件的组件中要备注好订阅该事件的组件</p></li><li><p>在订阅事件的组件中要备注好触发事件的组件</p></li><li><p>发布与订阅模式不仅可以用来实现兄弟组件间通信，其实也可以用来实现任意组件间通信。</p></li><li><p>后面我们还会讲到pinia全局状态管理，他可以实现任意组件间通信，并且他在代码维护和跟踪上都较方便。</p></li></ul><h3 id="四、动态组件"><a href="#四、动态组件" class="headerlink" title="四、动态组件"></a>四、动态组件</h3><blockquote><p>在有些场景下，我们需要在两个或多个组件间来回切换，比如Tab 选项卡</p></blockquote><ul><li>我们就可以利用本小节讲到的<code>&lt;component&gt;</code>内置组件来帮助我们实现动态渲染组件。当然我们也可以用前面学过的<code>v-if</code>或<code>v-show</code>来实现。</li><li>我们先用<code>v-if</code>或<code>v-show</code>来实现这个效果，然后再用<code>&lt;component&gt;</code>内置组件来实现，通过两者对比，看那种方式更简单</li></ul><h4 id="v-if-或-v-show-实现选项卡效果"><a href="#v-if-或-v-show-实现选项卡效果" class="headerlink" title="v-if 或 v-show 实现选项卡效果"></a>v-if 或 v-show 实现选项卡效果</h4><ul><li><code>App.vue</code>根组件</li></ul><pre><code>&lt;script&gt;  import Tab1 from &quot;./components/Tab1.vue&quot;;  import Tab2 from &quot;./components/Tab2.vue&quot;;  import Tab3 from &quot;./components/Tab3.vue&quot;;  export default &#123;    data() &#123;      return &#123;        currentTab: &quot;Tab1&quot;,      &#125;;    &#125;,    components: &#123;      Tab1,      Tab2,      Tab3,    &#125;,  &#125;;&lt;/script&gt;&lt;template&gt;  &lt;div class=&quot;container&quot;&gt;    &lt;div class=&quot;tab-title&quot;&gt;      &lt;button        @click=&quot;currentTab = &#39;Tab1&#39;&quot;        :class=&quot;&#123; active: currentTab === &#39;Tab1&#39; &#125;&quot;      &gt;        Tab1      &lt;/button&gt;      &lt;button        @click=&quot;currentTab = &#39;Tab2&#39;&quot;        :class=&quot;&#123; active: currentTab === &#39;Tab2&#39; &#125;&quot;      &gt;        Tab2      &lt;/button&gt;      &lt;button        @click=&quot;currentTab = &#39;Tab3&#39;&quot;        :class=&quot;&#123; active: currentTab === &#39;Tab3&#39; &#125;&quot;      &gt;        Tab3      &lt;/button&gt;    &lt;/div&gt;    &lt;div class=&quot;tab-content&quot;&gt;      &lt;Tab1 v-show=&quot;currentTab === &#39;Tab1&#39;&quot; /&gt;      &lt;Tab2 v-show=&quot;currentTab === &#39;Tab2&#39;&quot; /&gt;      &lt;Tab3 v-show=&quot;currentTab === &#39;Tab3&#39;&quot; /&gt;    &lt;/div&gt;  &lt;/div&gt;&lt;/template&gt;&lt;style&gt;  button &#123;    width: 80px;    height: 40px;    border: none;    margin-right: 10px;    cursor: pointer;  &#125;  .active &#123;    background-color: skyblue;  &#125;  .tab &#123;    width: 400px;    min-height: 100px;    background-color: #ddd;    margin-top: 10px;  &#125;&lt;/style&gt;</code></pre><ul><li><code>Tab1.vue、Tab2.vue、Tab3.vue</code> 内容如下</li></ul><pre><code>&lt;!--Tab1.vue--&gt;&lt;script&gt;&lt;/script&gt;&lt;template&gt;  &lt;div class=&quot;tab tab1&quot;&gt;    &lt;input type=&quot;text&quot; /&gt;    Tab1111.....内容....  &lt;/div&gt;&lt;/template&gt;&lt;!--Tab2.vue--&gt;&lt;script&gt;&lt;/script&gt;&lt;template&gt;  &lt;div class=&quot;tab tab1&quot;&gt;Tab2222.....内容....&lt;/div&gt;&lt;/template&gt;&lt;!--Tab3.vue--&gt;&lt;script&gt;&lt;/script&gt;&lt;template&gt;  &lt;div class=&quot;tab tab1&quot;&gt;Tab3333.....内容....&lt;/div&gt;&lt;/template&gt;</code></pre><h4 id="动态组件-component"><a href="#动态组件-component" class="headerlink" title="动态组件 component"></a>动态组件 component</h4><ul><li><code>&lt;component&gt;</code>是一个内置组件，用来渲染动态组件或元素的”元组件”。</li><li>该组件的<code>is</code>属性决定了最终要渲染的实际组件。</li></ul><pre><code>&lt;component is=&quot;Tab1&quot; /&gt;&lt;!--最终要渲染的是Tab1组件--&gt;</code></pre><blockquote><p>is 属性值</p></blockquote><ul><li>当<code>is</code>的值是<strong>字符串</strong>时，他既可以是 HTML 标签名也可以是组件的注册名。<ul><li>如果为HTML标签，则最终渲染出对应的 HTML 元素。</li><li>如果为注册的组件名，则最终渲染这个组件</li></ul></li><li>在组合式 API 中，<code>:is</code>也可以直接绑定到组件的定义</li></ul><blockquote><p>示例</p></blockquote><ul><li>按 HTML 元素的标签名，来渲染 HTML 元素</li></ul><pre><code>&lt;component is=&quot;a&quot; href=&quot;http://www.icodingedu.com&quot;&gt;艾编程&lt;/component&gt;&lt;!--最终渲染结果如下--&gt;&lt;a href=&quot;http://www.icodingedu.com&quot;&gt;艾编程&lt;/a&gt;</code></pre><ul><li>按组件名来渲染组件</li></ul><pre><code>&lt;script&gt;  import List from &quot;./components/List.vue&quot;;  export default &#123;    components: &#123;      List,    &#125;,  &#125;;&lt;/script&gt;&lt;template&gt;  &lt;!--List为组件名--&gt;  &lt;component is=&quot;List&quot;&gt;&lt;/component&gt;&lt;/template&gt;</code></pre><ul><li>按组件的定义来渲染组件</li></ul><pre><code>&lt;script setup&gt;  import &#123; h &#125; from &quot;vue&quot;;  // 自定义组件  const MyComponent = &#123;    render: () =&gt; &#123;      return h(&quot;div&quot;, &quot;组件定义对象&quot;);    &#125;,  &#125;;&lt;/script&gt;&lt;template&gt;  &lt;component :is=&quot;MyComponent&quot;&gt;&lt;/component&gt;&lt;/template&gt;&lt;script setup&gt;  import A from &quot;./components/A.vue&quot;;&lt;/script&gt;&lt;template&gt;  &lt;component :is=&quot;A&quot;&gt;&lt;/component&gt;&lt;/template&gt;</code></pre><h4 id="component-实现-Tab-选项卡"><a href="#component-实现-Tab-选项卡" class="headerlink" title="component 实现 Tab 选项卡"></a>component 实现 Tab 选项卡</h4><blockquote><p>同比上面用<code>v-if</code>实现 <code>Tab</code> 选项卡，内容只需要做如下变动</p></blockquote><ul><li>把<code>App.vue</code>文件中<code>tab-conent</code>元素中内容</li></ul><pre><code>&lt;div class=&quot;tab-content&quot;&gt;  &lt;Tab1 v-show=&quot;currentTab === &#39;Tab1&#39;&quot; /&gt;  &lt;Tab2 v-show=&quot;currentTab === &#39;Tab2&#39;&quot; /&gt;  &lt;Tab3 v-show=&quot;currentTab === &#39;Tab3&#39;&quot; /&gt;&lt;/div&gt;</code></pre><ul><li>替换成如下内容</li></ul><pre><code>&lt;div class=&quot;tab-content&quot;&gt;  &lt;component :is=&quot;currentTab&quot;&gt;&lt;/component&gt;&lt;/div&gt;</code></pre><ul><li>观察修改后的代码可以得出，使用动态组件来实现，代码相对要简洁。</li></ul><h4 id="动态渲染-Tab-选项卡"><a href="#动态渲染-Tab-选项卡" class="headerlink" title="动态渲染 Tab 选项卡"></a>动态渲染 Tab 选项卡</h4><pre><code>&lt;script&gt;  import Tab1 from &quot;./components/Tab1.vue&quot;;  import Tab2 from &quot;./components/Tab2.vue&quot;;  import Tab3 from &quot;./components/Tab3.vue&quot;;  export default &#123;    data() &#123;      return &#123;        currentTab: &quot;Tab1&quot;, // 当前渲染的组件        active: 0, // 被激活的下标        tab: [          &#123;            name: &quot;Tab1组件&quot;,            com: &quot;Tab1&quot;,          &#125;,          &#123;            name: &quot;Tab2组件&quot;,            com: &quot;Tab2&quot;,          &#125;,          &#123;            name: &quot;Tab3组件&quot;,            com: &quot;Tab3&quot;,          &#125;,        ],      &#125;;    &#125;,    components: &#123;      Tab1,      Tab2,      Tab3,    &#125;,    methods: &#123;      change(index, item) &#123;        this.active = index;        this.currentTab = item.com;      &#125;,    &#125;,  &#125;;&lt;/script&gt;&lt;template&gt;  &lt;div class=&quot;container&quot;&gt;    &lt;div class=&quot;tab-title&quot;&gt;      &lt;button        v-for=&quot;(item, index) in tab&quot;        :class=&quot;[active === index ? &#39;active&#39; : &#39;&#39;]&quot;        @click=&quot;change(index, item)&quot;      &gt;        &#123;&#123;item.name &#125;&#125;      &lt;/button&gt;    &lt;/div&gt;    &lt;div class=&quot;tab-content&quot;&gt;      &lt;component :is=&quot;currentTab&quot;&gt;&lt;/component&gt;    &lt;/div&gt;  &lt;/div&gt;&lt;/template&gt;&lt;style&gt;  button &#123;    width: 80px;    height: 40px;    border: none;    margin-right: 10px;    cursor: pointer;  &#125;  .active &#123;    background-color: skyblue;  &#125;  .tab &#123;    width: 400px;    min-height: 100px;    background-color: #ddd;    margin-top: 10px;  &#125;&lt;/style&gt;</code></pre><h4 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h4><ul><li>当使用<code>&lt;component :is=&quot;...&quot;&gt;</code>来在多个组件间作切换时，被切换掉的组件会<strong>被卸载</strong>，这会导致丢失其中所有已变化的状态——当这个组件再一次被显示时，会创建一个只带有初始状态的新实例</li><li>但在实际开发中，我们希望组件被“切走”的时候保留言它们的状态。要解决这个问题，我们可以用<code>&lt;KeepAlive&gt;</code>内置组件将这些动态组件包装起来，这样被切换掉的组件仍然保持“存活”的状态(不会被卸载)</li><li><code>&lt;KeepAlive&gt;</code>是一个内置组件，它的功能是在多个组件间动态切换时缓存被移除的组件实例。</li></ul><pre><code>&lt;KeepAlive&gt;  &lt;component :is=&quot;currentTab&quot;&gt;&lt;/component&gt;&lt;/KeepAlive&gt;</code></pre><h3 id="五、异步组件"><a href="#五、异步组件" class="headerlink" title="五、异步组件"></a>五、异步组件</h3><blockquote><p>在大型项目中，我们可能需要拆分应用为更小的块，并仅在需要时再从服务器加载相关组件，这时候就可以使用异步组件。Vue 提供了 <code>defineAsyncComponent</code>方法来定义一个异步组件</p></blockquote><h4 id="方法定义一个异步组件"><a href="#方法定义一个异步组件" class="headerlink" title="方法定义一个异步组件"></a>方法定义一个异步组件</h4><blockquote><p><code>defineAsyncComponent</code>方法用来定义一个异步组件，该方法接受一个参数，参数可以是一个返回<code>Promise</code>的加载函数。</p></blockquote><ul><li>在组件加载成功后调用<code>resolve</code>方法，把获取到的组件作为<code>resolve</code>方法的参数传入。</li><li>在组件加载失败后调用<code>reject</code>方法，可以传入一个错误对象，对外告知组件加载失败</li></ul><pre><code>import &#123; defineAsyncComponent &#125; from &quot;vue&quot;;// 定义一个异步组件const AsyncComp = defineAsyncComponent(() =&gt; &#123;  return new Promise((resolve, reject) =&gt; &#123;    // ...从服务器获取组件    resolve(/* 获取到的组件 */);  &#125;);&#125;);</code></pre><ul><li>在实际开发中我们会利用<code>import()</code>方法来导入一个组件，因为<code>import()</code>方法返回的也是一个 <code>Promise</code> 对象，所以我们通常会使用以下方式来定义一个异步组件</li></ul><pre><code>import &#123; defineAsyncComponent &#125; from &quot;vue&quot;;// 定义一个异步组件const AsyncComp = defineAsyncComponent(() =&gt;  import(&quot;./components/AsyncComp.vue&quot;));</code></pre><ul><li>最后得到的 <code>AsyncComp</code> 是一个外层包装过的组件，仅在页面需要它渲染时才会调用加载内部实际组件的函数。</li></ul><h4 id="异步组件的基本使用"><a href="#异步组件的基本使用" class="headerlink" title="异步组件的基本使用"></a>异步组件的基本使用</h4><ul><li>异步组件即可以注册为全局的，也可以组册为局部的，其方式与普通组件一样。<blockquote><p>将异步组件注册为<strong>局部</strong>组件，并使用，需要经过以下三步</p></blockquote></li><li>先利用<code>defineAsyncComponent</code>方法定义一个异步组件</li><li>再在使用该异步组件的组件<code>components</code>选项中注册该组件</li><li>最后就可以直接在父组件模板中通过注册名来使用组件</li></ul><pre><code>&lt;script&gt;  import &#123; defineAsyncComponent &#125; from &quot;vue&quot;;  // 第一步： 定义一个异步组件  const AsyncComp = defineAsyncComponent(() =&gt;    import(&quot;./components/AsyncComp.vue&quot;)  );  export default &#123;    // 第二步：注册成局部组件    components: &#123;      AsyncComp: AsyncComp,    &#125;,  &#125;;&lt;/script&gt;&lt;template&gt;  &lt;!--第三步：使用组件--&gt;  &lt;AsyncComp /&gt;&lt;/template&gt;</code></pre><blockquote><p>将异步组件注册为<strong>全局</strong>组件，并使用，需要经过以下三步：</p></blockquote><ul><li>先利用<code>defineAsyncComponent</code>方法定义一个异步组件</li><li>使用<code>app.component()</code>方法将组件全局注册，注册后的异步组件在整个应用中全局可用</li><li>在需要使用该组件的组件模板中通过注册名来使用组件</li></ul><pre><code>// 导入defineAsyncComponent方法，定义异步组件import &#123; defineAsyncComponent &#125; from &quot;vue&quot;;// 第一步：定义异步组件const AsyncComp = defineAsyncComponent(() =&gt;  import(&quot;./components/AsyncComp.vue&quot;));// 第二步：全局注册app.component(&quot;AsyncComp&quot;, AsyncComp);&lt;!-- 任意组件中使用 --&gt;&lt;template&gt;  &lt;!--第三步：使用组件--&gt;  &lt;AsyncComp /&gt;&lt;/template&gt;</code></pre><h4 id="异步组件按需加载"><a href="#异步组件按需加载" class="headerlink" title="异步组件按需加载"></a>异步组件按需加载</h4><ul><li>异步组件在运行时是懒加载的，即在需要用到时才加载，不用不加载，正是这个特性，可以提高应用首次的加载速度。</li><li>如果一个较大的项目，所有组件都是同步的，那一开始需要加载的组件较多，页面打开速度会变慢，体验会变差。所以需要将应用拆分成更多的异步组件，使现按需加载。<blockquote><p>代码演示</p></blockquote></li><li><code>App.vue</code></li></ul><pre><code>&lt;script&gt;  import &#123; defineAsyncComponent &#125; from &quot;vue&quot;;  // 定义异步组件  const AsyncCompA = defineAsyncComponent(() =&gt;    import(&quot;./components/AsyncCompA.vue&quot;)  );  const AsyncCompB = defineAsyncComponent(() =&gt;    import(&quot;./components/AsyncCompB.vue&quot;)  );  export default &#123;    data() &#123;      return &#123;        currentComp: &quot;AsyncCompA&quot;,      &#125;;    &#125;,    components: &#123;      AsyncCompA,      AsyncCompB,    &#125;,  &#125;;&lt;/script&gt;&lt;template&gt;  &lt;button @click=&quot;currentComp = &#39;AsyncCompA&#39;&quot;&gt;加载A组件&lt;/button&gt;  &lt;button @click=&quot;currentComp = &#39;AsyncCompB&#39;&quot;&gt;加载B组件&lt;/button&gt;  &lt;!--KeepAlive将被切换掉的组件缓存起来--&gt;  &lt;KeepAlive&gt;    &lt;component :is=&quot;currentComp&quot;&gt;&lt;/component&gt;  &lt;/KeepAlive&gt;&lt;/template&gt;</code></pre><ul><li>AsyncCompA.vue</li></ul><pre><code>&lt;template&gt;  &lt;div&gt;AsyncCompAAAA 组件中内容&lt;/div&gt;&lt;/template&gt;</code></pre><ul><li>AsyncCompB.vue</li></ul><pre><code>&lt;template&gt;  &lt;div&gt;AsyncCompBBBBB 组件中内容&lt;/div&gt;  &lt;input type=&quot;text&quot; name=&quot;&quot; id=&quot;&quot; /&gt;&lt;/template&gt;</code></pre><ul><li>项目首次加载时，页面中只加载了<code>AsyncCompA</code>组件，当我们点击加载 B 组件时，才会去加载<code>AsyncCompB</code>组件。</li></ul><h4 id="异步组件加载与错误状态"><a href="#异步组件加载与错误状态" class="headerlink" title="异步组件加载与错误状态"></a>异步组件加载与错误状态</h4><blockquote><p>当我们在加载一个异步组件时，可能会因为组件比较大或网速等原因，需要等待一定的时间才能加载成功，所以在加载成功之前页面是空白的状态，这非常影响用户体验。</p></blockquote><ul><li>针对这种情况，我们可以在真正的组件被加载之前，先显示一些其它的内容，在组件加载成功后，再替换掉就好</li><li>如果在加载一个组件时没有加载成功，我们同样需要对错误的状态做相关处理，比如告诉用户内容加载失败等</li></ul><blockquote><p>针对以上两种情况，我们想要在加载组件时做相关的状态处理，需要将<code>defineAsyncComponent</code>的参数定义成如下<strong>对象</strong></p></blockquote><pre><code>import &#123; defineAsyncComponent &#125; from &quot;vue&quot;;// 内容正在加载中显示的组件import LoadingComponent from &quot;./components/LoadingComponent.vue&quot;;// 内容加载失败后显示的组件import ErrorComponent from &quot;./components/ErrorComponent.vue&quot;;const AsyncCompB = defineAsyncComponent(&#123;  // 加载函数，用来加载真正要显示的组件  loader: () =&gt; import(&quot;./components/AsyncCompB.vue&quot;),  // 在真正要显示的组件被加成功前，会先加载这个组件来显示内容  loadingComponent: LoadingComponent,  // 展示加载组件前的延迟时间，默认为 200ms  delay: 200,  // 加载失败后展示的组件  errorComponent: ErrorComponent,  // 如果提供了一个 timeout 时间限制，并超时了  // 也会显示这里配置的报错组件，默认值是：Infinity  timeout: 1000,&#125;);</code></pre><blockquote><p>以下是完整的代码示例</p></blockquote><ul><li><code>App.vue</code></li></ul><pre><code>&lt;script&gt;  import &#123; defineAsyncComponent &#125; from &quot;vue&quot;;  import LoadingComponent from &quot;./components/LoadingComponent.vue&quot;;  import ErrorComponent from &quot;./components/ErrorComponent.vue&quot;;  const AsyncCompA = defineAsyncComponent(() =&gt;    import(&quot;./components/AsyncCompA.vue&quot;)  );  const AsyncCompB = defineAsyncComponent(&#123;    // 加载函数，用来加载真正要显示的组件    loader: () =&gt; import(&quot;./components/AsyncCompB.vue&quot;),    // 在真正要显示的组件被加成功前，会先加载这个组件来显示内容    loadingComponent: LoadingComponent,    // 展示加载组件前的延迟时间，默认为 200ms    delay: 200,    // 加载失败后展示的组件    errorComponent: ErrorComponent,    // 如果提供了一个 timeout 时间限制，并超时了    // 也会显示这里配置的报错组件，默认值是：Infinity    timeout: 1000,  &#125;);  export default &#123;    data() &#123;      return &#123;        currentComp: &quot;AsyncCompA&quot;,      &#125;;    &#125;,    components: &#123;      AsyncCompA,      AsyncCompB,    &#125;,  &#125;;&lt;/script&gt;&lt;template&gt;  &lt;button @click=&quot;currentComp = &#39;AsyncCompA&#39;&quot;&gt;加载A组件&lt;/button&gt;  &lt;button @click=&quot;currentComp = &#39;AsyncCompB&#39;&quot;&gt;加载B组件&lt;/button&gt;  &lt;KeepAlive&gt;    &lt;component :is=&quot;currentComp&quot;&gt;&lt;/component&gt;  &lt;/KeepAlive&gt;&lt;/template&gt;</code></pre><ul><li><code>AsyncCompA.vue</code> 与 <code>AsyncCompB.vue</code></li></ul><pre><code>&lt;!--AsyncCompA.vue--&gt;&lt;template&gt;  &lt;div&gt;AsyncCompAAAA 组件中内容&lt;/div&gt;&lt;/template&gt;&lt;!--AsyncCompB.vue--&gt;&lt;template&gt;  &lt;div&gt;AsyncCompBBBBB 组件中内容&lt;/div&gt;  &lt;input type=&quot;text&quot; name=&quot;&quot; id=&quot;&quot; /&gt;&lt;/template&gt;LoadingComponent.vue&lt;template&gt;  &lt;div class=&quot;loading&quot;&gt;正在拼命加载中.....&lt;/div&gt;&lt;/template&gt;ErrorComponent.vue&lt;template&gt;  &lt;div class=&quot;error&quot;&gt;内容加载失败....&lt;/div&gt;&lt;/template&gt;</code></pre><ul><li>在点击加载 B 组件时，会先显示正在拼命加载中…..，因为设置了超时1000ms</li><li>所以在1s后组件还没有加载成功时显示了内容加载失败….，（一般超时会设置在 3s），最后加载成功则显示真正组件的内容</li></ul>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Vue </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Vue（三）</title>
      <link href="/2024/01/23/Vue%EF%BC%88%E4%B8%89%EF%BC%89/"/>
      <url>/2024/01/23/Vue%EF%BC%88%E4%B8%89%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<span id="more"></span><h3 id="一、Vue-组件的生命周期"><a href="#一、Vue-组件的生命周期" class="headerlink" title="一、Vue 组件的生命周期"></a>一、Vue 组件的生命周期</h3><h4 id="什么是生命周期"><a href="#什么是生命周期" class="headerlink" title="什么是生命周期"></a>什么是生命周期</h4><blockquote><p>在 Vue 中每个以<code>.vue</code>结尾的文件就是一个组件，每个组件都有自己的生命周期</p><p>生命周期（Life Cycle）是指一个对象从<strong>创建 -&gt; 运行 -&gt; 销毁</strong>的整个阶段，强调的是一个时间段。</p></blockquote><ul><li>我们将 Vue 程序从创建到销毁的整个过程，称为 Vue 的生命周期<ul><li><code>Vue</code>程序的创建，表示 Vue 生命周期的开始</li><li><code>Vue</code>程序的销毁，表示 Vue 生命周期的结束</li><li><code>Vue</code>程序从创建到销毁的整个过程，就是 Vue 的生命周期</li></ul></li></ul><h4 id="什么是生命周期函数（钩子）"><a href="#什么是生命周期函数（钩子）" class="headerlink" title="什么是生命周期函数（钩子）"></a>什么是生命周期函数（钩子）</h4><blockquote><p>每个 Vue 组件实例在被创建时都要经过一系列的初始化过程，如：</p></blockquote><ul><li>设置数据监听</li><li>编译模板</li><li>将实例挂载到 DOM</li><li>数据变化时更新 DOM</li><li>…..等</li></ul><blockquote><p>这个过程中会<strong>在特定时间点运行</strong>一些叫做生命周期钩子的函数，让开发者有机会在特定阶段运行自己的代码。<br>总结</p></blockquote><ul><li>生命周期函数（钩子）：是由 Vue 框架提供的内置函数，会伴随着生命周期，自动按次序执行</li><li>生命周期函数的作用：允许开发者在特定的时间点，执行某些特定的操作。</li></ul><h4 id="Vue-生命周期函数（钩子）"><a href="#Vue-生命周期函数（钩子）" class="headerlink" title="Vue 生命周期函数（钩子）"></a>Vue 生命周期函数（钩子）</h4><blockquote><p>以下是 Vue 组件的生命周期图示，图中从上到下完整的展示了 Vue 组件生命周期的完整过程：</p></blockquote><ul><li><strong>创建</strong>：设置数据监听（data 数据、计算属性、方法和侦听器）等、编译模板</li><li><strong>挂载</strong>：实例挂载到 DOM</li><li><strong>更新</strong>：数据变化时更新 DOM</li><li><strong>销毁</strong>：组件被卸载<ul><li>图中红色箭头所指向的函数为 Vue 提供的生命周期函数（钩子），这些不同的钩子函数，分别在不同的时期执行。</li></ul></li></ul><table><thead><tr><th>生命周期函数</th><th>执行阶段</th><th>说明</th></tr></thead><tbody><tr><td>beforeCreate</td><td>组件创建</td><td>会在实例初始化完成、props 解析之后、data() 和 computed、methods 等选项处理之前立即调用</td></tr><tr><td>created</td><td>组件创建</td><td>在组件实例处理完所有与状态（数据）相关的选项后调用</td></tr><tr><td>beforeMount</td><td>DOM 挂载前</td><td>在组件（DOM）被挂载到页面（或父容器）之前调用。</td></tr><tr><td>mounted</td><td>DOM 挂载后</td><td>在组件（本质是 DOM）被挂载到页面（或父容器）之后调用</td></tr><tr><td>beforeUpdate</td><td>DOM 更新前</td><td>在响应式数据发生改变后，DOM 被更新之前调用</td></tr><tr><td>updated</td><td>DOM 更新后</td><td>在响应式数据发生改变后，导致的虚拟 DOM 重新渲染，并被挂载到页面后调用</td></tr><tr><td>beforeUnmount</td><td>组件销毁前</td><td>在一个组件实例被卸载之前调用</td></tr><tr><td>unmounted</td><td>组件销毁后</td><td>在一个组件实例被卸载之后调用</td></tr></tbody></table><img src="生命周期函数.png"><ol><li>生命周期函数的基本使用<blockquote><p>使用生命周期函数分以下 2 步：</p></blockquote></li></ol><ul><li>在组件实例中注册对应的生命周期函数</li><li>把需要执行的代码写在对应的生命周函数内<ul><li>这样 Vue 就会在对应的时间点自动帮我们调用这些生命周期函数执行相应的代码</li></ul></li><li>注意： 生命周期函数内部的this指向当前组件实例</li></ul><pre><code>&lt;script&gt;export default &#123;  data() &#123;    return &#123;      message: &quot;Hello Vue!&quot;,    &#125;;  &#125;,  // 在实例初始化之后,进行数据侦听和事件/侦听器的配置之前同步调用  beforeCreate() &#123;    console.log(&quot;beforeCreate&quot;);  &#125;,  // ....&#125;;&lt;/script&gt;</code></pre><ol start="2"><li>beforeCreate</li></ol><ul><li>会在实例初始化完成、<code>props</code> 解析<strong>之后</strong>、<code>data()</code> 和 <code>computed</code>、<code>methods</code> 等选项处理<strong>之前</strong>立即调用。</li><li>在这个生命周期函数中，我们是没有办法访问到<code>data</code>中的属性，以及<code>methods</code>中的方法等其它选项的数据</li></ul><ol start="3"><li>created</li></ol><ul><li><code>created</code>生命周期函数会在在组件实例处理完所有与状态（数据）相关的选项后调用。</li><li><code>created</code>生命周期函数调用时，响应式数据、计算属性、方法和侦听器等内容已经设置完成。所以我们可以在这个函数中访问到组件的数据，计算属性，方法等。</li><li>此阶段<strong>挂载</strong>还未开始，所以这个阶段我们没有办法访问组件实例的 <code>DOM</code>（如：$el属性还不可用）<blockquote><ul><li><code>$el</code>为组件实例的属性，用来获取该组件实例管理的<code>DOM</code>根节点</li></ul></blockquote></li></ul><pre><code>&lt;script&gt;  export default &#123;    data() &#123;      return &#123;        message: &quot;Hello Vue&quot;,        arr: [1, 2, 3, 4],      &#125;;    &#125;,    methods: &#123;      update() &#123;        console.log(&quot;Hello Vue3&quot;);      &#125;,    &#125;,    created() &#123;      // -----以下内容可以正常访问到-----      // 访问组件实例的属性      console.log(this.message); // Hello Vue      // 访组件实例的方法      this.update(); // Hello Vue3      // ------以下内容访问不到 -----      // 此时虚拟DOM还没有挂载到页面变成真实DOM，所以访问不到      const div = document.querySelectorAll(&quot;.box&quot;);      console.log(div); // [ ]      // 此时挂载阶段还未开始，因此 $el 属性仍不可用      console.log(this.$el); // null    &#125;,  &#125;;&lt;/script&gt;&lt;template&gt;  &lt;div class=&quot;box&quot;&gt;    &lt;ul&gt;      &lt;li v-for=&quot;item in arr&quot;&gt;&#123;&#123; item &#125;&#125;&lt;/li&gt;    &lt;/ul&gt;  &lt;/div&gt;&lt;/template&gt;</code></pre><ol start="4"><li>beforeMount</li></ol><ul><li><code>beforeMount</code>函数会在组件首次被挂载到页面之前调用。</li><li><code>beforeMount</code>函数被调用时，组件已经完成了其响应式状态的设置，但还没有创建 DOM 节点。它即将首次执行 DOM 渲染过程。</li><li>他与<code>created</code>函数相比，这个阶段Vue<strong>对模板做了编译</strong>。<blockquote><p>如果我们想在 DOM 挂载到页面前做一些相关的操作，就可以在这里执行。不过实际开发中这种需求较少。因为，如果我们想要更改数据，最好的方式是在<code>beforeCreate</code>或<code>created</code>中来处理。这样就不会因为数据的变更，再次对模板进行编译。</p></blockquote></li></ul><ol start="5"><li>mounted<blockquote><p>mounted函数在组件被挂载到页面之后调用<br>以下情况下视为已挂载：</p></blockquote></li></ol><ul><li>所有同步子组件都已经被挂载。(不包含异步组件或 <code>&lt;Suspense&gt;</code>树内的组件)</li><li>其自身的 DOM 树已经创建完成并插入了父容器中（注意仅当根容器在文档中时，才可以保证组件 DOM 树也在文档中）。</li><li>如果我们想在访问组件所渲染的 DOM，做相关的 DOM 操作，则可以在这里执行。此阶段，可以访问到$el</li></ul><pre><code>&lt;script&gt;export default &#123;  data() &#123;    return &#123;      arr: [1, 2, 3, 4],    &#125;;  &#125;,  mounted() &#123;    const div = document.querySelectorAll(&quot;.box&quot;);    const list = document.querySelectorAll(&quot;.box ul li&quot;);    console.log(div);    console.log(list);    console.log(this.$el);  &#125;,&#125;;&lt;/script&gt;&lt;template&gt;  &lt;div class=&quot;box&quot;&gt;    &lt;ul&gt;      &lt;li v-for=&quot;item in arr&quot;&gt;&#123;&#123; item &#125;&#125;&lt;/li&gt;    &lt;/ul&gt;  &lt;/div&gt;&lt;/template&gt;</code></pre><img src="mounted函数结果.png"><ol start="6"><li>beforeUpdate</li></ol><ul><li><code>beforeUpdate</code>在响应式数据发生改变后，DOM 被更新<strong>之前</strong>调用</li><li>如果想在 Vue 更新 DOM 之前对 DOM 做相关的操作，可以把相关操作代码写在<code>beforeUpdate</code>函数中</li></ul><pre><code>&lt;script&gt;export default &#123;  data() &#123;    return &#123;      arr: [1, 2, 3],    &#125;;  &#125;,  beforeUpdate() &#123;    console.log(&quot;访问数据为更新后数据&quot;, this.arr);    const list = document.querySelectorAll(&quot;.box ul li&quot;);    console.log(list);  &#125;,&#125;;&lt;/script&gt;&lt;template&gt;  &lt;button @click=&quot;arr = [1, 2, 3, 4, 5]&quot;&gt;更新数据&lt;/button&gt;  &lt;div class=&quot;box&quot;&gt;    &lt;ul&gt;      &lt;li v-for=&quot;item in arr&quot;&gt;&#123;&#123; item &#125;&#125;&lt;/li&gt;    &lt;/ul&gt;  &lt;/div&gt;&lt;/template&gt;</code></pre><ul><li>点击更新数据按扭后，观察控制台的输出内容，发现获取的数据是最新的，但 DOM 元素是更新前的，也就是此时 DOM 还没有挂载到页面中</li></ul><ol start="7"><li>updated</li></ol><ul><li>响应式数据发生改变后，会重新更新 DOM 树，update方法会在 DOM 树更新之后调用</li><li>如果你想对更新后的 DOM 做相关的操作，则可以在此函数中执行。<blockquote><p>注意：一定要避免在此期间更改状态（响应式数据），这可能会导致无限的更新循环！</p></blockquote></li></ul><ol start="8"><li>beforeUnmount 与 unmounted</li></ol><ul><li><code>beforeUnmount</code>钩子函数，在一个组件实例被卸载之前调用。当这个钩子被调用时，组件实例依然还保有全部的功能。</li><li><code>unmounted</code>在一个组件实例被卸载之后调用。</li></ul><blockquote><p>一个组件在以下情况下被视为已卸载：</p></blockquote><ul><li>其所有子组件都已经被卸载。</li><li>所有相关的响应式作用 (渲染作用以及 <code>setup()</code> 时创建的计算属性和侦听器) 都已经停止。</li></ul><blockquote><p>应用：</p></blockquote><ul><li>可以在这个<code>beforeUnmount</code>钩子中手动清理一些副作用，例如计时器、DOM 事件监听器或者与服务器的连接</li></ul><h3 id="二、自定义指令"><a href="#二、自定义指令" class="headerlink" title="二、自定义指令"></a>二、自定义指令</h3><ul><li>通过前面的学习，我们知道指令的作用就是帮助我们简化 DOM 元素的操作。如果 Vue 内置的指令不能满足我们的需求时，Vue 允许我们注册自定义指令（<code>Custom Directives</code>）。</li><li>当我们需要直接对 DOM 元素做相关的重复性操作时，我们可以将这些重复性的操作定义成指令，实现复用。在需要执行相关操作的元素上，添加相关指令即可</li></ul><h4 id="如何定义自定义指令"><a href="#如何定义自定义指令" class="headerlink" title="如何定义自定义指令"></a>如何定义自定义指令</h4><ul><li>所有的自定义指令都需要定义在组件的<code>directives</code>选项中。</li><li>一个自定义指令由一个包含类似组件生命周期钩子的对象来定义，这些钩子函数分别会在不同的时间点被自动调用</li><li>每个钩子函数，都有 4 个参数，4 个参数的详细介绍在下面会介绍</li></ul><blockquote><p>指令命名规范</p></blockquote><ul><li>指令<strong>定义时</strong>采用驼峰命名，并且不需要加<code>v-</code>前缀，在<strong>调用时</strong>需要加上<code>v-</code>前缀，并且需采用-分隔形式，如：<code>v-my-directive</code></li></ul><blockquote><p>创建自定义指令</p></blockquote><ul><li>以下代码中的<code>myDirective</code>为自定义指令</li></ul><pre><code>&lt;script&gt;  export default &#123;    data() &#123;      return &#123;        n: 10,        bool: true,        msg: &quot;update&quot;,      &#125;;    &#125;,    // 所有自定义指令需在此处注册    directives: &#123;      // myDirective为自定义指令名，定义时采用驼峰命名，      // 调用时，采用-分隔形式,且要加上v-前缀，如：v-my-directive      myDirective: &#123;        // 在绑定元素的 attribute 前        // 或事件监听器应用前调用        created(el, binding, vnode, prevVnode) &#123;          console.log(&quot;created&quot;);        &#125;,        // 初次渲染，在该元素被插入到 DOM 前调用        beforeMount(el, binding, vnode, prevVnode) &#123;          console.log(&quot;beforeMount&quot;);        &#125;,        // 在绑定元素的父组件，及他自己的所有子节点都挂载完成后调用        mounted(el, binding, vnode, prevVnode) &#123;          console.log(&quot;mounted&quot;);        &#125;,        // 绑定元素的父组件更新前调用 （元素更新，相当于父组件更新，父件其它内容更新，本质整个DOM会重新渲染)        beforeUpdate(el, binding, vnode, prevVnode) &#123;          console.log(&quot;beforeUpdate&quot;);        &#125;,        // 在绑定元素的父组件，及他自己的所有子节点都更新后调用        updated(el, binding, vnode, prevVnode) &#123;          console.log(&quot;updated&quot;);        &#125;,        // 绑定元素的或其父组件卸载前调用        beforeUnmount(el, binding, vnode, prevVnode) &#123;          console.log(&quot;beforeUnmount&quot;);        &#125;,        // 绑定元素或其父组件卸载后调用        unmounted(el, binding, vnode, prevVnode) &#123;          console.log(&quot;unmounted&quot;);        &#125;,      &#125;,    &#125;,  &#125;;&lt;/script&gt;&lt;template&gt;  &lt;button @click.once=&quot;bool = !bool&quot;&gt;卸载元素&lt;/button&gt; |  &lt;button @click=&quot;msg = &#39;updated&#39;&quot;&gt;更新msg的值&lt;/button&gt;  &lt;div&gt;msg的值:&#123;&#123; msg &#125;&#125;&lt;/div&gt;  &lt;!-- 指令定义时不用加v-,使用时需要加上v-前缀 --&gt;  &lt;div v-my-directive v-if=&quot;bool&quot;&gt;n的值: &#123;&#123; n &#125;&#125;&lt;/div&gt;&lt;/template&gt;</code></pre><blockquote><p>注：观察控制台结果，可以看到</p></blockquote><ul><li>初始渲染时，只有<code>created</code>、<code>beforeMount</code>、<code>mounted</code>三个钩子被调用了</li><li>当点击按扭更新<code>msg</code>的值时，会触发<code>DOM</code>的重新渲染，则<code>beforeUpdate</code>、<code>updated</code>两个钩子被调用</li><li>当点击按扭卸载元素时，<code>beforeUnmount</code>与<code>unmounted</code>两个钩子被调用</li></ul><h4 id="自定义指令钩子"><a href="#自定义指令钩子" class="headerlink" title="自定义指令钩子"></a>自定义指令钩子</h4><blockquote><p>指令的钩子中的<code>created</code>、<code>beforeMount</code>、<code>mounted</code>钩子有以下需要注意的点：</p></blockquote><ul><li><code>created</code>与<code>beforeMount</code>钩子函数中，是没有办法访问到<strong>当前元素之后的元素</strong>，但可以访问该元素之前的元素。因为在该元素插入页面前，他前面的元素已经插入到页面，而后面的元素还没有</li><li><code>mounted</code>钩子中可以访问到当前元素父元素中的所有子元素，因为此时<code>DOM</code>元素已插入到了页面中。</li></ul><blockquote><p>总结：指令钩子执行时机</p><ul><li>自定义指令钩子的执行时期大概分为以下 4 个阶段</li></ul></blockquote><ul><li><strong>元素创建阶段</strong>：此阶段指令与元素成功绑定，此阶段会执行<code>created</code>与<code>beforeMount</code>钩子。不过此阶段不能访问到该元素之后的元素，因为此时该元素与之后的元素还没有插入到页面中。</li><li><strong>挂载阶段</strong>：此阶段元素及子元素和父组件都被挂载到页面中。此阶段会执行<code>mounted</code>钩子。在此阶段可以访问到该组件的所有元素。</li><li><strong>更新阶段</strong>：当响应式数据更新后（该数据可以与当前指令绑定元素无关），会重新渲染模板。此阶段会执行<code>beforeUpdate</code>与<code>updated</code>钩子。</li><li><strong>销毁阶段</strong>：元素或其父元素即将销毁。此阶段会执行<code>beforeUnmount</code>与<code>unmounted</code>钩子</li></ul><blockquote><p>指令钩子中 this</p></blockquote><ul><li>在自定义指令钩子中，<code>this</code> 最终指向的是<code>undefined</code>。</li><li>因为在钩子函数中，我们并不需要使用<code>this</code>。只需要知道当前绑定指令的元素和指令相关信息，而这些信息都通过钩子的前两个参数传递给到我们了。</li></ul><blockquote><p>注意区分：</p></blockquote><ul><li>前面学习的的<code>methods</code>、<code>computed</code>、<code>watch</code>选项中函数的<code>this</code>指向当前组件实例。</li></ul><h4 id="案例1：自定义-v-focus-指令"><a href="#案例1：自定义-v-focus-指令" class="headerlink" title="案例1：自定义 v-focus 指令"></a>案例1：自定义 v-focus 指令</h4><ul><li>定义<code>v-focus</code>指令，该指令用来实现当一个 <code>input</code> 元素被 Vue 插入到 DOM 中后，它会被自动获取焦点，同时边框变红。</li><li>注意：<code>input</code> 元素只有被插入到 <code>DOM</code> 后才能能获取焦点，所以相关逻辑需要写在 <code>mounted</code> 钩子中。</li></ul><pre><code>&lt;script&gt;export default &#123;  directives: &#123;    // 自定义v-focus指令    focus: &#123;      /*            // 指令与元素绑定前             created(el) &#123;              el.focus();              el.style.outline = &quot;none&quot;              el.style.border = &quot;1px solid red&quot;            &#125;,            // DOM元素被添加到页面前            beforeMount(el) &#123;              el.focus()              el.style.outline = &quot;none&quot;              el.style.border = &quot;1px solid red&quot;            &#125;,            */      mounted(el) &#123;        // el 为绑定指令的元素        el.style.outline = &quot;none&quot;;        el.focus();        el.style.border = &quot;1px solid red&quot;;      &#125;,    &#125;,  &#125;,&#125;;&lt;/script&gt;&lt;template&gt;  &lt;input type=&quot;text&quot; v-focus /&gt;&lt;/template&gt;</code></pre><ul><li>代码写在<code>created</code>或<code>beforeMount</code>钩子中，<code>input</code>元素边框确实变红的，但是没有获取到焦点。</li><li>代码写在<code>mounted</code>钩子中，<code>input</code>元素边框变红，同时获取到了焦点</li></ul><h4 id="指令钩子的参数"><a href="#指令钩子的参数" class="headerlink" title="指令钩子的参数"></a>指令钩子的参数</h4><blockquote><p>指令的钩子会传递以下几种参数</p></blockquote><pre><code>// 指令钩子mounted(el,binding,vnode,prevNode) &#123;   &#125;</code></pre><ul><li><code> el</code>：指令绑定到的元素。可以用于直接操作绑定指令的 DOM 元素</li><li><code>binding</code>：一个对象，包含以下属性<ul><li><code>value</code>：传递给指令的值，如：<code>v-focus=&quot;n&quot;</code>指令中，<code>n</code> 的值为 <code>30</code>，则 <code>value</code> 值就是 <code>30</code></li><li><code>oldValue</code>：指令之前的值，仅在 <code>beforeUpdate</code> 和 <code>updated</code> 中可用。无论值是否更改，它都可用。</li><li><code>arg</code>：传递给指令的参数 (如果有的话) 如：<code>v-focus:input=&#39;n&#39;</code> 指令中，<code>input</code>为指令的参数，</li><li><code>modifiers</code>:一个包含修饰符的对象 (如果有的话)。 如 <code>v-focus.radius=&#39;n&#39;</code>指令中，<code>.radius</code>为指令的修饰符，最终<code>modifiers</code>的值是<code>&#123;radius:true&#125;</code></li><li><code>instance</code>: 使用该指令的组件实例</li><li><code>dir</code>：指令的定义对象，如：<code>&#123; mounted()&#123; &#125;&#125;</code></li></ul></li><li><code>vnode</code>：代表绑定元素的底层<code>VNode</code></li><li><code>prevNode</code>：之前的渲染中代表指令所绑定元素的<code>VNode</code>。仅在 <code>beforeUpdate</code> 和 <code>updated</code> 钩子中可用</li></ul><blockquote><p>注意事项</p></blockquote><ul><li>并不是更新与自定义指令相关的数据才会调用自定义指令钩子，只要是响应式数据更新，需要重新渲染模板，就会调用自定义指令对应的 <code>beforeUpdate</code> 和 <code>updated</code> 钩子</li></ul><h4 id="案例2：v-focus-指令添加参数与修饰符"><a href="#案例2：v-focus-指令添加参数与修饰符" class="headerlink" title="案例2：v-focus 指令添加参数与修饰符"></a>案例2：v-focus 指令添加参数与修饰符</h4><blockquote><p>自定义<code>v-focus:input.radius=n</code>指令</p></blockquote><ul><li>参数如果为<code>input</code>，元素要获取焦点，然后背景变成<code>skyblue</code>色</li><li>如果参数为<code>button</code>，元素背景变为<code>orange</code>橘色</li><li>修饰符<code>radius</code>表示给元素边框添加圆角效果，指令后面的值<code>n</code>为边框圆角的半径</li></ul><pre><code>&lt;script&gt;export default &#123;  data() &#123;    return &#123;      n: 5,    &#125;;  &#125;,  // 所有指令，都需要在这里定义(注册)  directives: &#123;    focus: &#123;      // 在绑定元素的父组件      // 及他自己的所有子节点都挂载完成后调用      mounted(el, binding, vnode, prevVnode) &#123;        if (binding.arg === &quot;input&quot;) &#123;          el.focus();          el.style.backgroundColor = &quot;skyblue&quot;;        &#125;        if (binding.arg === &quot;button&quot;) &#123;          el.style.backgroundColor = &quot;orange&quot;;        &#125;        if (binding.modifiers.radius) &#123;          el.style.borderRadius = binding.value + &quot;px&quot;;        &#125;      &#125;,    &#125;,  &#125;,&#125;;&lt;/script&gt;&lt;template&gt;  &lt;button @click=&quot;n = 30&quot;&gt;圆角变大&lt;/button&gt;  &lt;button type=&quot;text&quot; v-focus:button.radius=&quot;n&quot;&gt;提交按扭&lt;/button&gt;  &lt;input type=&quot;text&quot; v-focus:input.radius=&quot;n&quot; /&gt;&lt;/template&gt;</code></pre><ul><li>当我们点击按扭，想让圆角变小时，发现并没有效果，但是数据<code>num</code>确实变成了<code>30</code>。为什么数据变了，元素没有同步更新呢 ？</li><li>原因在于我们要执行的指令代码，定义在<code>v-focus</code>指令的<code>mounted</code>钩子函数中，<code>mounted</code>钩子函数只会在初次渲染 <code>DOM</code> 挂载成功后才会被执行，后面数据更新，并不会执行。<ul><li>所以想要数据更新后，执行对应的代码，让圆角变小，需要在<code>beforeUpdate</code>或<code>updated</code>中执行相关代码</li></ul></li></ul><pre><code>&lt;script&gt;export default &#123;  data() &#123;    return &#123;      n: 5,    &#125;;  &#125;,  // 所有指令，都需要在这里定义(注册)  directives: &#123;    focus: &#123;      // 在绑定元素的父组件      // 及他自己的所有子节点都挂载完成后调用      mounted(el, binding, vnode, prevVnode) &#123;        if (binding.arg === &quot;input&quot;) &#123;          el.focus();          el.style.backgroundColor = &quot;skyblue&quot;;        &#125;        if (binding.arg === &quot;button&quot;) &#123;          el.style.backgroundColor = &quot;orange&quot;;        &#125;        if (binding.modifiers.radius) &#123;          el.style.borderRadius = binding.value + &quot;px&quot;;        &#125;      &#125;,      updated(el, binding) &#123;        if (binding.arg === &quot;input&quot;) &#123;          el.focus();          el.style.backgroundColor = &quot;skyblue&quot;;        &#125;        if (binding.arg === &quot;button&quot;) &#123;          el.style.backgroundColor = &quot;orange&quot;;        &#125;        if (binding.modifiers.radius) &#123;          el.style.borderRadius = binding.value + &quot;px&quot;;        &#125;      &#125;,    &#125;,  &#125;,&#125;;&lt;/script&gt;&lt;template&gt;  &lt;button @click=&quot;n = 30&quot;&gt;圆角变大&lt;/button&gt; |  &lt;button type=&quot;text&quot; v-focus:button.radius=&quot;n&quot;&gt;提交按扭&lt;/button&gt; |  &lt;input type=&quot;text&quot; v-focus:input.radius=&quot;n&quot; /&gt;&lt;/template&gt;</code></pre><ul><li>以上代码最终渲染效果如下，点击圆角变大按扭后，元素的圆角确实变大了</li></ul><h4 id="自定义指令函数写法"><a href="#自定义指令函数写法" class="headerlink" title="自定义指令函数写法"></a>自定义指令函数写法</h4><blockquote><p>对于自定义指令来说，一个很常见的情况是仅仅需要在<code>mounted</code>和<code>updated</code>上实现相同的行为，除此之外并不需要其他钩子，这种情况下我们可以直接用一个函数来定义指令。</p></blockquote><ul><li>如下：</li></ul><pre><code> directives: &#123;     // 以下函数式写法，就相当于focus函数中代码会在mounted与updated钩子中被调用。    focus(el, binding,vnode, prevVnode) &#123;&#125;  &#125;</code></pre><ul><li>用简写形式来优化上面<code>v-focus</code>指令的代码，如下：</li></ul><pre><code>&lt;script&gt;export default &#123;  data() &#123;    return &#123;      n: 5,    &#125;;  &#125;,  // 所有指令，都需要在这里定义(注册)  directives: &#123;    focus(el, binding, vnode, prevVnode) &#123;      if (binding.arg === &quot;input&quot;) &#123;        el.focus();        el.style.backgroundColor = &quot;skyblue&quot;;      &#125;      if (binding.arg === &quot;button&quot;) &#123;        el.style.backgroundColor = &quot;orange&quot;;      &#125;      if (binding.modifiers.radius) &#123;        el.style.borderRadius = binding.value + &quot;px&quot;;      &#125;    &#125;,  &#125;,&#125;;&lt;/script&gt;&lt;template&gt;  &lt;button @click=&quot;n = 30&quot;&gt;圆角变大&lt;/button&gt; |  &lt;button type=&quot;text&quot; v-focus:button.radius=&quot;n&quot;&gt;提交按扭&lt;/button&gt; |  &lt;input type=&quot;text&quot; v-focus:input.radius=&quot;n&quot; /&gt;&lt;/template&gt;</code></pre><h4 id="案例3：自定义-v-style-和-v-display-指令"><a href="#案例3：自定义-v-style-和-v-display-指令" class="headerlink" title="案例3：自定义 v-style 和 v-display 指令"></a>案例3：自定义 v-style 和 v-display 指令</h4><ul><li><code>v-style</code>指令后面的值为一个 CSS 样式对象，用来给元素添加对应的 style 样式</li><li><code>v-display</code>指令的效果同 Vue 内置的<code>v-show</code>指令效果一样，当值为 true 时，元素显示，值为 false 时，隐藏元素。</li></ul><blockquote><p>指令绑定的值</p></blockquote><ul><li>如果你的指令需要多个值，你可以向它传递一个 <code>JavaScript</code> 对象字面量</li><li>指令也可以接收任何合法的 <code>JavaScript</code> 表达式</li></ul><pre><code>&lt;script&gt;export default &#123;  data() &#123;    return &#123;      n: 0,      show: true,    &#125;;  &#125;,  methods: &#123;      getType(x) &#123;        var originType = Object.prototype.toString.call(x); //&#39;[object Object]&#39;        var spaceIndex = originType.indexOf(&quot; &quot;); // 查找空隙所在下标        var type = originType.slice(spaceIndex + 1, -1); //从空格下标+1位位置查询字符串，查询到字符串最后一位        return type.toLowerCase(); //将分格出来的类型，统一转成小写字      &#125;,    &#125;,  directives: &#123;    display(el, binding) &#123;      if (binding.value) &#123;        el.style.display = &quot;block&quot;;      &#125; else &#123;        el.style.display = &quot;none&quot;;      &#125;    &#125;,    style(el, binding) &#123;      const that = binding.instance; // 组件实例        // 判断传递的参数是否存在，如果存在，再判断值是否是一个对象      if (        binding.value &amp;&amp;        that.getType(binding.value) === &quot;object&quot;      ) &#123;        for (let key in binding.value) &#123;          console.log(key);          el.style[key] = binding.value[key];        &#125;      &#125;    &#125;,  &#125;,&#125;;&lt;/script&gt;&lt;template&gt;  &lt;p&gt;模拟v-show&lt;/p&gt;  &lt;button @click=&quot;show = !show&quot;&gt;开关&lt;/button&gt;  &lt;div v-display=&quot;show&quot;&gt;显示了吗&lt;/div&gt;  &lt;div&gt;----------&lt;/div&gt;  &lt;p&gt;更新样式&lt;/p&gt;  &lt;div v-style=&quot;&#123; fontSize: &#39;30px&#39;, backgroundColor: &#39;red&#39; &#125;&quot;&gt;文字文字&lt;/div&gt;&lt;/template&gt;</code></pre><ul><li>注意：<code>v-style</code>指令，先遍历<code>binding.value</code>，再用<code>el.style[key] = binding.value[key];</code>的方式添加样式</li></ul><h4 id="自定义全局指令"><a href="#自定义全局指令" class="headerlink" title="自定义全局指令"></a>自定义全局指令</h4><blockquote><p>Vue 中的指令分为局部指令和全局指令。</p></blockquote><ul><li><strong>局部指令</strong>：我们在组件的<code>directives</code>选项中注册的指令为局部指令，这种方式注册的指令只能供当前组件使用</li><li><strong>全局指令</strong>：调用<code>app.directive()</code>方法来注册的指令称为全局指令。这种方式注册的指令可以在任意的组件中使用。</li></ul><ol><li>app.directive方法<blockquote><p><code>app.directive()</code>方法可以用来注册一个全局指令，也可以根据指令名返回注册的指令（如果存在的话）<br><strong>注册一个全局指令</strong></p></blockquote></li></ol><pre><code>/*    name：指令的名字    directive：指令定义，值是一个对象或一个函数，写法与局部指令的对象和函数写法一模一样    返回值应用实例 app，则支持链式调用*/app.directive(name: string, directive: Directive): this</code></pre><p><strong>根据指令名返回该指令</strong></p><pre><code>// name：已注册的全局指令的名字，最终返回该名字注册的指令，如果不存在返回undefinedapp.directive(name: string): Directive | undefined</code></pre><ul><li>示例</li></ul><pre><code>import &#123; createApp &#125; from &quot;vue&quot;;import App from &quot;./App.vue&quot;;const app = createApp(App);// 注册全局指令v-focus （对象形式的指令）app.directive(&quot;focus&quot;, &#123;  /*  自定义钩子  */&#125;);// 注册全局指令 v-display （函数形式的写法）app.directive(&quot;display&quot;, (el, binding) =&gt; &#123;  /*  执行代码  */&#125;);// 得到一个已注册的指令const myDirective = app.directive(&quot;focus&quot;);app.mount(&quot;#app&quot;);</code></pre><ol start="2"><li>注册全局指令<code>v-focus</code><blockquote><p><code>v-focus</code>指令用于实现当<code>input</code>输入框插入页面后获取焦点同时背景颜色变为<code>skyblue</code></p></blockquote></li></ol><ul><li>在<code>/src/commont/directive.js</code>文件创建注册指令的<code>directives</code>方法</li></ul><pre><code>export const directives = (app) =&gt; &#123;  // 注册全局指令 （函数形式的写法） app.directive(&#39;focus&#39;, (el, binding) =&gt; &#123;     el.focus();     el.style.backgroundColor = &quot;skyblue&quot; &#125;) // 注册全局指令 （对象形式的指令） // app.directive(&quot;focus&quot;, &#123; //     mounted(el, binding) &#123; //         el.focus(); //         el.style.backgroundColor = &quot;skyblue&quot; //     &#125;, //     updated(el, binding) &#123; //         el.focus(); //         el.style.backgroundColor = &quot;skyblue&quot; //     &#125; // &#125;)&#125;</code></pre><ul><li>在<code>main.js</code>中调用<code>directives</code>方法，注册全局指令</li></ul><pre><code>import &#123; createApp &#125; from &quot;vue&quot;;import App from &quot;./App.vue&quot;;// 导入 directives方法import &#123; directives &#125; from &quot;./commont/directive&quot;;const app = createApp(App);// 注册全局指令directives(app);app.mount(&quot;#app&quot;);</code></pre><ul><li>在<code>App.vue</code>组件中使用全局指令</li></ul><pre><code>&lt;script&gt;import Hello from &quot;./components/Hello.vue&quot;;export default &#123;  components: &#123;    Hello,  &#125;,&#125;;&lt;/script&gt;&lt;template&gt;  &lt;h3&gt;App根组件&lt;/h3&gt;  &lt;input type=&quot;text&quot; v-focus /&gt;  &lt;Hello&gt;&lt;/Hello&gt;&lt;/template&gt;</code></pre><ul><li><code>Hello.vue</code>子组件中使用全局指令</li></ul><pre><code>&lt;script&gt;&lt;/script&gt;&lt;template&gt;  &lt;h3&gt;Hello 子组件中&lt;/h3&gt;  &lt;input type=&quot;text&quot; v-focus /&gt;&lt;/template&gt;</code></pre><ul><li>一个页面中，只能有一个元素获取到焦点，所以这里只能是子组件中的<code>input</code>获取到焦点</li></ul><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><blockquote><p>关于自定义指令，以下内容是我们需要重点掌握的。<br><strong>自定义指令的分类</strong></p></blockquote><ul><li>自定义指令分为全局指令与局部指令。</li><li>直接在<code>directives</code>选项中注册的指令为局部指令，只能用于注册该指令的组件</li><li>通过<code>app.directive</code>方法注册的指令为局部指令，可以在任意的组件中使用</li></ul><blockquote><p>注册局部指令</p><ul><li>局部指令有对象与函数两种写法</li></ul></blockquote><ul><li>对象写法：根据需要添加对应的钩子函数</li><li>函数简写形式：写在函数中的代码相当于定义在<code>mounted</code>与<code>updated</code>钩子中</li></ul><pre><code>// 注册局部指令，对象形式的写法directives:&#123;    myDirective:&#123;        /* 自定义钩子 */        mounted()&#123; &#125;,        // .....    &#125;&#125;// 注册局部指令，函数形式的写法directives:&#123;    myDirective()&#123;        /* 自定义代码 */    &#125;&#125;</code></pre><blockquote><p>注册全局指令</p><ul><li>自定义全局指令，也包含对象与函数两种写法</li></ul></blockquote><pre><code>// 注册全局指令 （对象形式的写法）app.directive(&quot;my-focus&quot;, &#123;  /*  自定义钩子  */&#125;);// 注册全局指令 （函数形式的写法）app.directive(&quot;my-focus&quot;, (el, binding) =&gt; &#123;  /*  执行代码  */&#125;);</code></pre><blockquote><p>指令钩子参数</p></blockquote><pre><code>mounted(el,binding,vnode,prevNode) &#123;   &#125;</code></pre><blockquote><p>注意事项</p></blockquote><ul><li>自定义指令钩子中<code>this</code>指向<code>undefined</code></li><li>自定义指令的值可以是一个表达式，如果有多个值可以写成对象形式</li></ul><h3 id="三、自定义指令：实战应用"><a href="#三、自定义指令：实战应用" class="headerlink" title="三、自定义指令：实战应用"></a>三、自定义指令：实战应用</h3><h4 id="自定义v-debounce防抖指令"><a href="#自定义v-debounce防抖指令" class="headerlink" title="自定义v-debounce防抖指令"></a>自定义<code>v-debounce</code>防抖指令</h4><blockquote><p>什么是防抖</p></blockquote><ul><li>是指只有在间隔时间达到规定时间后才会执行一次真正的事件处理函数</li><li>如果在规定时间内再次触发事件，则会重新计时。</li></ul><blockquote><p><code>v-debounce</code>防抖指令</p></blockquote><ul><li>指令参数用来指定绑定的事件类型，如：<code>input</code>事件<code>click</code> 事件</li><li>指令值是一个对象，对象的<code>eventName</code>属性值为事件处理函数 <code>delay</code>为防抖时间，单位为<code>ms</code>，如果没有该属性默认值为 <code>300ms</code><blockquote><p>完整代码</p></blockquote></li><li>在<code>main.js</code>中调用<code>directives</code>方法，注册全局指令</li></ul><pre><code>import &#123; createApp &#125; from &quot;vue&quot;;import App from &quot;./App.vue&quot;;// 导入 directives方法import &#123; directives &#125; from &quot;./commont/directive&quot;;const app = createApp(App);// 注册全局指令directives(app);app.mount(&quot;#app&quot;);</code></pre><ul><li>在<code>App.vue</code>组件中使用<code>v-debounce</code>指令</li></ul><pre><code>&lt;script&gt;export default &#123;  methods: &#123;    search(e) &#123;      console.log(e);      //拿到输入的值      console.log(this.$refs.myInput.value);    &#125;,  &#125;,&#125;;&lt;/script&gt;&lt;template&gt;  &lt;h3&gt;App根组件&lt;/h3&gt;  &lt;input    type=&quot;text&quot;    ref=&quot;myInput&quot;    v-debounce:input=&quot;&#123; event: search, delay: 1000 &#125;&quot;  /&gt;  &lt;!-- &lt;input type=&quot;text&quot; v-focus /&gt; --&gt;&lt;/template&gt;</code></pre><ul><li>在<code>/src/commont/directive.js</code>文件创建注册指令的<code>directives</code>方法</li></ul><pre><code>export const directives = (app) =&gt; &#123;  app.directive(&quot;debounce&quot;, &#123;    created(el, binding) &#123;      if (typeof binding.value.event !== &quot;function&quot;) return;      el.timer = null;      el.handler = function () &#123;        //如果上一个还没结束，就先清除它        if (el.timer) &#123;          clearTimeout(el.timer);        &#125;        el.timer = setTimeout(() =&gt; &#123;          el.timer = null;          // binding.value.event();          binding.value.event.apply(this, arguments);        &#125;, binding.value.delay || 300);      &#125;;      el.addEventListener(binding.arg, el.handler);    &#125;,    beforeUnmount() &#123;      //在销毁前 解除事件监听      el.removeEventListener(binding.arg, el.handler);    &#125;,  &#125;);&#125;;</code></pre><h4 id="自定义-v-drag-元素拖拽指令"><a href="#自定义-v-drag-元素拖拽指令" class="headerlink" title="自定义 v-drag 元素拖拽指令"></a>自定义 v-drag 元素拖拽指令</h4><blockquote><p>自定义<code>v-drag</code>拖拽指令</p></blockquote><ul><li>修饰符<code>self</code>表示添加<code>v-drag</code>指令元素为被拖拽的元素</li><li>拖拽动画的实现原理如下图：<img src="拖拽动画.png"></li></ul><blockquote><p>实现步骤：</p></blockquote><ul><li><code>dragEl</code>为被拖拽的元素，当没有添加<code>self</code>修饰符时，<code>dragEl</code>为被点击元素的父元素；否则被拖拽元素就是被点击元素</li><li>在鼠标按下时，即 <code>onmousedown</code> 事件<ul><li>记录鼠标按下时与浏览器可视区左边和上边距离，即 <code>e.clientX</code>和<code>e.clientY</code></li><li>同时记录被拖拽元素与定义父元素(<code>parent=dragEl.parentNode</code>)左边的距离，即<code>parent.offsetLeft</code>和<code>parent.offsetTop</code></li></ul></li><li>在鼠标标移动时，即 <code>onmousemove</code> 事件<ul><li>记录鼠标此时与浏览器可视区左边和上边距离，即 <code>e.clientX</code> 和 <code>e.clientY</code></li><li>计算鼠标移动的距离：用移动后的<code>e.clientX</code> - 鼠标按下时<code>e.clientX</code></li><li>计算被拖拽元素的<code>left</code>、<code>top</code>值：鼠标移动的距离+移动前元素的<code>offsetLeft</code>，就得到了此时被拖拽元素的<code>left</code>值。同得理得 <code>top</code> 值</li></ul></li><li>还要添加<code>onmouseup</code>事件，在鼠标抬起时，要解绑 <code>onmousemove</code>和<code>onmouseup</code>事件<blockquote><p>以上步骤实现了元素可以自由的被拖拽，但是并不能控制元素只能在定位父元素容器中移动</p></blockquote></li><li>控制被拖拽元素移动时不能超出父容器，我们只需要控制被拖拽元素的 left 和 top 值的大小</li><li>如果 <code>left &lt; 0</code>，表示超出了父容器左边界，此时设置 <code>left = 0</code>，强行拉回</li><li>如果 <code>left &gt; 父容器宽 - 元素宽</code> ，表示超出了父容器右边界，此时设置 <code>left = 父容器宽 - 元素宽</code> ,强行拉回</li><li>如果 <code>top &lt; 0</code>，表示超出了父容器上边界，此时设置 <code>top = 0</code>，强行拉回</li><li>如果 <code>top &gt; 父容器高 - 元素高</code> ，表示超出了父容器下边界，此时设置 <code>top = 父容器宽 - 元素宽</code> ,强行拉回<ul><li>以上步骤，实现了控制元素只能在父容器中移动</li></ul></li></ul><blockquote><p>兼容性处理：如果被拖拽的元素是一个图片，或元素中有文字，被拖拽时就会出现卡顿</p></blockquote><ul><li>处理办法，就是禁止掉鼠标按下时,图片和被选中的文字默认的拖拽行为</li></ul><pre><code>e.preventDefault();</code></pre><ul><li>在<code>/src/commont/directive.js</code>文件创建注册指令的<code>directives</code>方法</li></ul><pre><code>export const directives = (app) =&gt; &#123;  app.directive(&quot;drag&quot;, &#123;    mounted(el, binding) &#123;      //鼠标按下      el.mouseDown = function (event) &#123;        //取消默认行为        const e = event || window.event;        e.preventDefault();        //当元素没有self修饰符时，被拖动的是按下元素的父元素        const dragEl = binding.modifiers.self ? e.target : e.target.parentNode;        //获得被拖拽元素的父元素        const parent = dragEl.offsetParent;        //鼠标按下时 与浏览器左边和上边的的距离        let _clientX = e.clientX;        let _clientY = e.clientY;        //鼠标按下时 该元素与父容器左边和上边的距离        let _offsetLeft = dragEl.offsetLeft;        let _offsetTop = dragEl.offsetTop;        //被拖拽元素的宽高        let dragWidth = dragEl.offsetWidth;        let dragHeight = dragEl.offsetHeight;        //父元素的宽高        let parentWidth = parent.clientWidth;        let parentHeight = parent.clientHeight;        //能够移动的最大距离        const maxY = parentHeight - dragHeight;        const maxX = parentWidth - dragWidth;        document.onmousemove = function (e) &#123;          //鼠标移动时 与浏览器左边和上边的的距离          let clientX = e.clientX;          let clientY = e.clientY;          //该元素的left和top          let left = clientX - _clientX + _offsetLeft;          let top = clientY - _clientY + _offsetTop;          //控制移动的范围          left = left &lt; 0 ? 0 : left;          left = left &gt; maxX ? maxX : left;          top = top &lt; 0 ? 0 : top;          top = top &gt; maxY ? maxY : top;          dragEl.style.left = left + &quot;px&quot;;          dragEl.style.top = top + &quot;px&quot;;        &#125;;        document.onmouseup = function () &#123;          document.onmousemove = null;          document.onmouseup = null;        &#125;;      &#125;;      el.addEventListener(&quot;mousedown&quot;, el.mouseDown);    &#125;,  &#125;);&#125;;</code></pre><ul><li>在<code>main.js</code>中调用<code>directives</code>方法，注册全局指令<code>v-drag</code>指令</li></ul><pre><code>import &#123; createApp &#125; from &quot;vue&quot;;import App from &quot;./App.vue&quot;;// 导入 directives方法import &#123; directives &#125; from &quot;./commont/directive&quot;;const app = createApp(App);// 注册全局指令directives(app);app.mount(&quot;#app&quot;);</code></pre><ul><li>在<code>App.vue</code>组件中使用</li></ul><pre><code>&lt;script&gt;export default &#123;&#125;;&lt;/script&gt;&lt;template&gt;  &lt;div class=&quot;box&quot;&gt;    &lt;div class=&quot;drag1&quot; v-drag&gt;drag&lt;/div&gt;    &lt;div class=&quot;drag2&quot; v-drag.self&gt;drag-self&lt;/div&gt;  &lt;/div&gt;&lt;/template&gt;&lt;style&gt;* &#123;  margin: 0;  padding: 0;&#125;html,body &#123;  width: 100%;  height: 100%;&#125;.box &#123;  position: absolute;  width: 300px;  height: 300px;  border: 1px solid #000;&#125;.drag1 &#123;  width: 100%;  height: 40px;  background-color: skyblue;&#125;.drag2 &#123;  position: absolute;  top: 50px;  width: 100%;  height: 40px;  background-color: tomato;&#125;&lt;/style&gt;</code></pre><h4 id="自定义-v-LazyLoad-图片懒加载指令"><a href="#自定义-v-LazyLoad-图片懒加载指令" class="headerlink" title="自定义 v-LazyLoad 图片懒加载指令"></a>自定义 v-LazyLoad 图片懒加载指令</h4><blockquote><p>实现图片懒加载有很多种方式，最常见的就是以下两种</p></blockquote><ul><li>监听到<code>scroll</code>事件后，调用目标元素的<code>getBoundingClientRect()</code>方法来实现。</li><li>通过<code>IntersectionObserver</code>API来实现，他可以自动”观察”元素是否可见。由于可见（visible）的本质是，目标元素与视口产生一个交叉区，所以这个 API 叫做”交叉口观测器”。<ul><li>本次我们采用第二种方式，利用IntersectionObserver构造函数来实现</li></ul></li></ul><ol><li>IntersectionObserver 构造函数<blockquote><p><code>IntersectionObserver</code>是浏览器原生提供的构造函数，可以自动”观察”元素是否可见</p></blockquote></li></ol><pre><code>// 观察器实例const io = new IntersectionObserver(callback, options);</code></pre><blockquote><p>参数</p></blockquote><ul><li><code>callback</code>：是可见性变化时的回调函数。<code>callback</code>一般会触发<strong>两次</strong>，一次是目标元素刚刚进入视口（开始可见），另一次是完全离开视口（开始不可见）</li><li><code>option</code>：是配置对象（该参数可选）</li></ul><blockquote><p>返回值</p></blockquote><ul><li>构造函数的返回值是一个观察器实例</li></ul><blockquote><p>观察器实例方法</p></blockquote><ul><li>实例的<code>observe</code>方法可以指定观察哪个 DOM 节点，如果需要观察多个节点，就需要多次调用<code>observe</code>方法</li><li>实例的<code>unobserve</code>方法用于停止对某个元素的观察</li><li>实例的<code>disconnect</code>方法用于关闭观察器</li></ul><pre><code>// 开始观察 box元素和containerio.observe(document.getElementById(&#39;box&#39;));io.observe(document.getElementById(&#39;container&#39;));// 停止观察 box元素io.unobserve(document.getElementById(&#39;box&#39;));// 关闭观察器io.disconnect();</code></pre><blockquote><p>代码示例</p></blockquote><pre><code>&lt;script&gt;  export default &#123;    data() &#123;      return &#123;        io: null, // 观察实例      &#125;;    &#125;,    methods: &#123;      stop() &#123;        this.io.unobserve(document.getElementById(&quot;box&quot;));      &#125;,    &#125;,    mounted() &#123;      // 创建观察者实例      this.io = new IntersectionObserver(() =&gt; &#123;        console.log(&quot;元素进入或离开可视区，我就会被打印&quot;);      &#125;);      // 开始观察 #box元素      this.io.observe(document.getElementById(&quot;box&quot;));    &#125;,  &#125;;&lt;/script&gt;&lt;template&gt;  &lt;button @click=&quot;stop&quot;&gt;停止&lt;/button&gt;  &lt;div class=&quot;h1000&quot;&gt;&lt;/div&gt;  &lt;div id=&quot;box&quot;&gt;    &lt;img src=&quot;./assets/images/01.png&quot; alt=&quot;&quot; /&gt;  &lt;/div&gt;  &lt;div class=&quot;h1000&quot;&gt;&lt;/div&gt;&lt;/template&gt;&lt;style&gt;  .h1000 &#123;    height: 1000px;  &#125;&lt;/style&gt;</code></pre><ul><li>注意观察图下右边控制台的打印输出，当元素进入或离开可视区时<code>callback</code>回调函数都会被调用，右边控制台输出对应信息。</li><li>当点击停止按扭停止侦听时，不管元素进入还是离开可视区，图下右边的控制台都不会有新的输出</li></ul><ol start="2"><li><code>IntersectionObserverEntry</code> 对象<blockquote><p><code>callback</code>函数的第一个参数是一个数组，数组中的每个成员是一个<code>IntersectionObserverEntry</code>对象。如果同时有两个被观察的对象的可见性发生变化，<code>entries</code>数组就会有两个成员</p><ul><li><code>IntersectionObserverEntry</code>对象提供目标元素的信息，他主要有以下 7 个属性</li></ul></blockquote></li></ol><ul><li><code>time</code>：可见性发生变化的时间（从可见到不可见的时间间隔），是一个高精度时间戳，单位为毫秒</li><li><code>target</code>：被观察的目标元素，是一个 DOM 节点对象</li><li><code>rootBounds</code>：根元素的矩形区域的信息，<code>getBoundingClientRect()</code>方法的返回值，如果没有根元素（即直接相对于视口滚动），则返回<code>null</code></li><li><code>boundingClientRect</code>：目标元素的矩形区域的信息</li><li><code>intersectionRect</code>：目标元素与视口（或根元素）的交叉区域的信息</li><li><code>intersectionRatio</code>：目标元素的可见比例，即<code>intersectionRect</code>占<code>boundingClientRect</code>的比例，完全可见时为1，完全不可见时小于等于0</li><li><code>isIntersecting</code>：返回一个布尔值，如果目标元素与交叉区域观察者对象（intersection observer）的根相交，则返回 <code>true</code>。如果返回<code>true</code>, 则<code>IntersectionObserverEntry</code>描述了变换到交叉时的状态; 如果返回<code>false</code>, 那么可以由此判断，变换是从交叉状态到非交叉状态。</li></ul><pre><code>&lt;script&gt;  export default &#123;    data() &#123;      return &#123;        io: null, // 观察实例      &#125;;    &#125;,    mounted() &#123;      this.io = new IntersectionObserver((entries) =&gt; &#123;        console.log(entries);      &#125;);      // 开始观察  多个元素      const imgList = document.querySelectorAll(&quot;#box img&quot;);      imgList.forEach((img) =&gt; &#123;        this.io.observe(img);      &#125;);    &#125;,  &#125;;&lt;/script&gt;&lt;template&gt;  &lt;div class=&quot;h1000&quot;&gt;&lt;/div&gt;  &lt;div id=&quot;box&quot;&gt;    &lt;img src=&quot;./assets/images/01.png&quot; alt=&quot;&quot; /&gt;    &lt;img src=&quot;./assets/images/02.png&quot; alt=&quot;&quot; /&gt;  &lt;/div&gt;&lt;/template&gt;&lt;style&gt;  #box &#123;    display: flex;  &#125;  #box img &#123;    width: 200px;  &#125;  .h1000 &#123;    height: 1000px;  &#125;&lt;/style&gt;</code></pre><ol start="3"><li>IntersectionObserver 实现图片懒加载</li></ol><pre><code>&lt;script&gt;export default &#123;  data() &#123;    return &#123;      io: null, // 观察实例      imgList: [        &quot;/src/assets/images/1.png&quot;,        &quot;/src/assets/images/2.png&quot;,        &quot;/src/assets/images/3.png&quot;,        &quot;/src/assets/images/4.png&quot;,        &quot;/src/assets/images/5.png&quot;,        &quot;/src/assets/images/6.png&quot;,        &quot;/src/assets/images/7.png&quot;,        &quot;/src/assets/images/8.png&quot;,      ],    &#125;;  &#125;,  mounted() &#123;    //创建观察者实例    this.io = new IntersectionObserver((entries) =&gt; &#123;      for (let i = 0; i &lt; entries.length; i++) &#123;        //如果元素没有出现在可视区 则不做任何处理        if (entries[i].intersectionRatio &lt;= 0) continue;        const img = entries[i].target;        //定时器模拟开发效果，实际开发中去掉        setTimeout(() =&gt; &#123;          img.src = img.dataset.src;        &#125;, 500);        //图片加载出来后 就停止观察        this.io.unobserve(img);      &#125;    &#125;);    // 开始观察  多个元素    const imgList = document.querySelectorAll(&quot;#box img&quot;);    imgList.forEach((img) =&gt; &#123;      this.io.observe(img);    &#125;);  &#125;,&#125;;&lt;/script&gt;&lt;template&gt;  &lt;div class=&quot;h1000&quot;&gt;&lt;/div&gt;  &lt;ul id=&quot;box&quot;&gt;    &lt;li v-for=&quot;item in imgList&quot;&gt;      &lt;img :data-src=&quot;item&quot; /&gt;    &lt;/li&gt;  &lt;/ul&gt;  &lt;div class=&quot;h1000&quot;&gt;&lt;/div&gt;&lt;/template&gt;&lt;style&gt;* &#123;  margin: 0;  padding: 0;&#125;#box &#123;  max-width: 600px;  margin: 0px auto;  list-style: none;&#125;#box li &#123;  width: 290px;  height: 189px;  margin: 5px;  background-color: #ddd;  float: left;&#125;#box li img &#123;  width: inherit;  height: inherit;&#125;.h1000 &#123;  height: 1000px;&#125;&lt;/style&gt;</code></pre><ol start="4"><li>options 选项</li></ol><ul><li><code>root</code>：指定根元素，用于检查目标的可见性。必须是目标元素的父级元素。如果未指定或者为 null，则默认为浏览器视窗。</li><li><code>rootMargin</code>：根元素的外边距，类似于 CSS 中的 <code>margin</code> 属性，如：<code>“200px 200px 200px 200px&quot;</code>。 如果 <code>margin-left</code> 值为 <code>200px</code>，则<code>rootBounds</code>的矩形区的宽度会变大 <code>200px</code>。</li><li><code>threshold</code>：目标元素与根元素的交叉比例，可以是单一的 <code>number</code> 也可以是<code> number</code> 数组，比如，<code>[0, 0.25, 0.5, 0.75, 1]</code>就表示当目标元素<code>0%、25%、50%、75%、100%</code>可见时，会触发回调函数</li></ul><pre><code>&#123;    // options配置    // 指定根元素，  目标元素的可见性是相对于根元素而言    root: document.getElementById(&#39;box&#39;),    // 根元素的外边距 如果为正，相当根元素矩形区外扩，否则相当于内缩    rootMargin: &quot;-200px 0px 0px 0px&quot;,    // 目标元素与根元素的交叉比例    threshold: 1,&#125;</code></pre><ol start="5"><li>v-lazy 指令实现图片懒加载</li></ol><ul><li>在<code>/src/commont/directive.js</code>文件中创建注册指令的<code>directives</code>方法</li></ul><pre><code>export const directives = (app) =&gt; &#123;  app.directive(&quot;lazy&quot;, (el, binding) =&gt; &#123;    //创建观察者实例    const io = new IntersectionObserver((entries) =&gt; &#123;      //如果元素没有出现在可视区 则不做任何处理      if (entries[0].intersectionRatio &lt;= 0) return;      //定时器模拟开发效果，实际开发中去掉      setTimeout(() =&gt; &#123;        el.src = el.dataset.src;      &#125;, 500);      //图片加载出来后 就取消观察      io.unobserve(el);      //关闭观察器      io.disconnect();    &#125;);    // 开始观察    io.observe(el);  &#125;);&#125;;</code></pre><ul><li>在<code>main.js</code>中调用<code>directives</code>方法，注册全局指令<code>v-lazy</code>指令</li></ul><pre><code>import &#123; createApp &#125; from &quot;vue&quot;;import App from &quot;./App.vue&quot;;// 导入 directives方法import &#123; directives &#125; from &quot;./commont/directive&quot;;const app = createApp(App);// 注册全局指令directives(app);app.mount(&quot;#app&quot;);</code></pre><ul><li><code>App.vue</code>组件中应用</li></ul><pre><code>&lt;script&gt;export default &#123;  data() &#123;    return &#123;      imgList: [        &quot;/src/assets/images/1.png&quot;,        &quot;/src/assets/images/2.png&quot;,        &quot;/src/assets/images/3.png&quot;,        &quot;/src/assets/images/4.png&quot;,        &quot;/src/assets/images/5.png&quot;,        &quot;/src/assets/images/6.png&quot;,        &quot;/src/assets/images/7.png&quot;,        &quot;/src/assets/images/8.png&quot;,      ],    &#125;;  &#125;,&#125;;&lt;/script&gt;&lt;template&gt;  &lt;div class=&quot;h1000&quot;&gt;&lt;/div&gt;  &lt;ul id=&quot;box&quot;&gt;    &lt;li v-for=&quot;item in imgList&quot;&gt;      &lt;img v-lazy :data-src=&quot;item&quot; /&gt;    &lt;/li&gt;  &lt;/ul&gt;  &lt;div class=&quot;h1000&quot;&gt;&lt;/div&gt;&lt;/template&gt;&lt;style&gt;* &#123;  margin: 0;  padding: 0;&#125;#box &#123;  max-width: 600px;  margin: 0px auto;  list-style: none;&#125;#box li &#123;  width: 290px;  height: 189px;  margin: 5px;  background-color: #ddd;  float: left;&#125;#box li img &#123;  width: inherit;  height: inherit;&#125;.h1000 &#123;  height: 1000px;&#125;&lt;/style&gt;</code></pre><h3 id="四、模板引用-ref-属性"><a href="#四、模板引用-ref-属性" class="headerlink" title="四、模板引用 - ref 属性"></a>四、模板引用 - ref 属性</h3><blockquote><p>我们之所以会选择 Vue 框架，是因为 Vue 框架帮我们做了大部分的 DOM 操作，我们只需要关注逻辑层的处理。但在某些情况下，我们仍然需要直接访问底层的 DOM 元素。</p><ul><li>在 Vue 中访问底层的 DOM 元素，我们有以下两种办法：</li></ul></blockquote><ul><li>通过原生 JS 访问 DOM，比如：<code>document.getElementById()</code>或 <code>document.querySelectorAll()</code> 等更多方法</li><li>通过 Vue 为我们提供了一个特殊的<code>ref</code>属性，它允许我们在一个特定的 DOM 元素或子组件实例被挂载后，获得对它的直接引用。</li></ul><h4 id="原生-JS-访问-DOM"><a href="#原生-JS-访问-DOM" class="headerlink" title="原生 JS 访问 DOM"></a>原生 JS 访问 DOM</h4><blockquote><p>在生命周期函数<code>mounted</code>中获取<code>id = box</code>的元素，然后在控制台输出。</p></blockquote><pre><code>&lt;script&gt;export default &#123;  data() &#123;    return &#123;      message: &quot;Hello Vue!!&quot;,    &#125;;  &#125;,  mounted() &#123;    const box = document.getElementById(&quot;box&quot;);    console.log(box);  &#125;,&#125;;&lt;/script&gt;&lt;template&gt;  &lt;div id=&quot;box&quot;&gt;&#123;&#123; message &#125;&#125;&lt;/div&gt;&lt;/template&gt;</code></pre><ul><li>不过 Vue 框架本身是希望我们不要去关注 DOM 的操作，如果我们又用原生 JS 的方式来获取 DOM 是违背了 Vue 框架的初衷。</li><li>所以在 Vue 中要获取对 DOM 的引用，主要还是通过<code>ref</code>属性来实现。</li></ul><h4 id="ref-属性"><a href="#ref-属性" class="headerlink" title="ref 属性"></a>ref 属性</h4><blockquote><p>当我们需要访问某个 DOM 元素时，我们可以在该元素上添加<code>ref</code>属性，如：<code>ref=&#39;box&#39;</code>，然后就可以通过<code>this.$refs.box</code>访问到该 DOM 元素。<br>注意：</p></blockquote><ul><li>只有在 DOM 元素或子组件实例被挂载后，才能通过<code>this.$refs.xxx</code>方式访问到该元素或子组件实例</li></ul><pre><code>&lt;script&gt;  export default &#123;    data() &#123;      return &#123;        message: &quot;Hello Vue!!&quot;,      &#125;;    &#125;,    mounted() &#123;      console.log(this.$refs.box);    &#125;,  &#125;;&lt;/script&gt;&lt;template&gt;  &lt;div ref=&quot;box&quot;&gt;&#123;&#123; message &#125;&#125;&lt;/div&gt;&lt;/template&gt;</code></pre><h4 id="ref-的唯一性"><a href="#ref-的唯一性" class="headerlink" title="ref 的唯一性"></a>ref 的唯一性</h4><blockquote><p><code>ref</code>属性更像是<code>id</code>属性的替代者，页面中不同出现相同的<code>ref</code>值。如果出现相同的，则以后面的为主。</p></blockquote><pre><code>&lt;script&gt;  export default &#123;    data() &#123;      return &#123;        message: &quot;Hello Vue!!&quot;,      &#125;;    &#125;,    mounted() &#123;      console.log(this.$refs);      console.log(this.$refs.box);      console.log(this.$refs.main);    &#125;,  &#125;;&lt;/script&gt;&lt;template&gt;  &lt;div ref=&quot;box&quot; class=&quot;box1&quot;&gt;box1内容&lt;/div&gt;  &lt;div ref=&quot;box&quot; class=&quot;box2&quot;&gt;box2内容&lt;/div&gt;  &lt;div ref=&quot;main&quot;&gt;main内容&lt;/div&gt;&lt;/template&gt;</code></pre><img src="ref的唯一性.png">- 通过上面打印结果，我们知道`this.$refs`是一个包含 DOM 元素的**对象**，对象的属性名为`ref`对应的值，属性值为`ref`所绑定的 DOM 元素<h4 id="v-for中的模板引用"><a href="#v-for中的模板引用" class="headerlink" title="v-for中的模板引用"></a>v-for中的模板引用</h4><blockquote><p>当我们在一个包含<code>v-for</code>指令的元素上，添加了<code>ref=&#39;xxx&#39;</code>属性时，最终<code>this.$refs.xxx</code>得到的值是一个<strong>数组</strong>，数组中每一项为<code>v-for</code>指令遍历后生成的<code>DOM</code>元素。</p></blockquote><pre><code>&lt;script&gt;  export default &#123;    data() &#123;      return &#123;        arr: [1, 2, 3, 4],      &#125;;    &#125;,    mounted() &#123;      console.log(this.$refs.items);    &#125;,  &#125;;&lt;/script&gt;&lt;template&gt;  &lt;ul&gt;    &lt;li v-for=&quot;item in arr&quot; ref=&quot;items&quot;&gt;&#123;&#123; item &#125;&#125;&lt;/li&gt;  &lt;/ul&gt;&lt;/template&gt;</code></pre><img src="v-for中的模板引用.png">- 注意：上面`this.$refs.items`得到的数组并不保证与源数组相同的顺序<h4 id="组件上的-ref"><a href="#组件上的-ref" class="headerlink" title="组件上的 ref"></a>组件上的 ref</h4><ul><li>当我们在一个子组件上添加<code>ref = xxx</code>属性时，最终通过<code>this.$refs.xxx</code>得到的值是<strong>组件实例</strong>。</li><li>如果我们给子组件添加<code>id</code>属性，通过原生 JS 方式获取该组件，得到的是组件的 <strong>DOM 元素</strong>。（该组件的根元素必需为<strong>单个元素</strong>时才可以，否则不行，这涉及到透传属性，后面会讲到，这里暂不介绍）。</li></ul><blockquote><p><code>App.vue</code>文件内容</p></blockquote><pre><code>&lt;script&gt;  import Hello from &quot;./components/Hello.vue&quot;;  export default &#123;    components: &#123;      Hello,    &#125;,    data() &#123;      return &#123;        arr: [1, 2, 3, 4],      &#125;;    &#125;,    mounted() &#123;      console.log(&quot;ref方式：&quot;, this.$refs.text);      console.log(&quot;id方式：&quot;, document.getElementById(&quot;box&quot;));    &#125;,  &#125;;&lt;/script&gt;&lt;template&gt;  &lt;Hello ref=&quot;text&quot; id=&quot;box&quot;&gt;&lt;/Hello&gt;&lt;/template&gt;</code></pre><blockquote><p><code>Hello.vue</code>文件内容</p></blockquote><pre><code>&lt;script&gt;  export default &#123;    data() &#123;      return &#123;        message: &quot;Hello 子组件&quot;,      &#125;;    &#125;,  &#125;;&lt;/script&gt;&lt;template&gt;  &lt;div&gt;    &lt;h3&gt;&#123;&#123; message &#125;&#125;&lt;/h3&gt;    &lt;div&gt;子组件中div&lt;/div&gt;  &lt;/div&gt;&lt;/template&gt;</code></pre><img src="组件上的ref.png">- 通过上面代码，我们知道在子组件上添加`ref = xxx`属性，则在父组件中，可以通过`this.$refs.xxx`得到子组件实例。也就意味着在父组件中可以访问到子组件实例上的**所有属性**，这显然不是我们希望看到的。- 如果我们只希望在父组件中访问子组件中允许我们访问的一些属性，那我们可以通过`expose`选项来对外暴露一些公共属性<h4 id="expose-选项"><a href="#expose-选项" class="headerlink" title="expose 选项"></a>expose 选项</h4><ul><li>如果没有<code>expose</code>选项，默认在父组件中可以通过模板引用访问子组件实例的所有方法和属性</li><li><code>expose</code>选项用于声明当组件实例被父组件通过模板引用访问时暴露的公共属性。只有出现在<code>expose</code>选项中的属性和方法才能在父组件中访问到。</li><li><code>expose</code>选项值应当是一个包含要暴露的属性名称字符串的数组</li></ul><pre><code>export default &#123;  // 子组件对外暴露的公开属性  expose: [&quot;publicData&quot;, &quot;publicMethod&quot;],&#125;;</code></pre><blockquote><p>应用场景</p></blockquote><ul><li>如果你创建了某个组件，而这个组件需要对外暴露一些公开的属性和方法，但又希望组件其它的属性和方法是私有的，则把公开属性在<code>expose</code>选项中声明</li></ul><h4 id="实战应用：计数器"><a href="#实战应用：计数器" class="headerlink" title="实战应用：计数器"></a>实战应用：计数器</h4><ul><li><p>组件实例的和属性</p><table><thead><tr><th>实例属性</th><th>描述</th><th>私有或公开</th></tr></thead><tbody><tr><td>n</td><td>用来保存当前计数</td><td>公开</td></tr><tr><td>timer</td><td>用来保存定时器</td><td>私有</td></tr></tbody></table></li><li><p>组件实例的方法</p><table><thead><tr><th>实例方法</th><th>描述</th><th>私有或公开</th></tr></thead><tbody><tr><td>方法</td><td>addInterval</td><td>添加定时器</td></tr><tr><td>方法</td><td>removeInterval</td><td>移除定时器</td></tr><tr><td>方法</td><td>start</td><td>开始计数</td></tr><tr><td>方法</td><td>end</td><td>暂停计数</td></tr><tr><td>方法</td><td>reset</td><td>重置计数</td></tr></tbody></table></li><li><p><code>Count.vue</code>子组件</p></li></ul><pre><code>&lt;script&gt;export default &#123;  data() &#123;    return &#123;      n: 0,      timer: null,    &#125;;  &#125;,  methods: &#123;    // 公开    start() &#123;      this.addInterval();    &#125;,    end() &#123;      //关闭定时器      this.removeInterval();    &#125;,    reset() &#123;      //关闭定时器      this.removeInterval();      //将n置为0      this.n = 0;    &#125;,    // 私有    addInterval() &#123;      //如果有定时器 就什么也不做      if (this.timer) return;      this.timer = setInterval(() =&gt; &#123;        this.n++;      &#125;, 1000);    &#125;,    removeInterval() &#123;      //如果有定时器 就清理掉      if (this.timer) &#123;        clearInterval(this.timer);        //重置定时器        this.timer = null;      &#125;    &#125;,  &#125;,  expose: [&quot;start&quot;, &quot;end&quot;, &quot;reset&quot;],&#125;;&lt;/script&gt;&lt;template&gt;  &lt;div class=&quot;count&quot;&gt;当前计数：&#123;&#123; n &#125;&#125;&lt;/div&gt;&lt;/template&gt;</code></pre><ul><li><code>App.vues</code>根组件内容</li></ul><pre><code>&lt;script&gt;import count from &quot;./components/count.vue&quot;;export default &#123;  data() &#123;    return &#123;&#125;;  &#125;,  components: &#123;    count,  &#125;,  methods: &#123;    start() &#123;      this.$refs.count.start();    &#125;,    end() &#123;      this.$refs.count.end();    &#125;,    reset() &#123;      this.$refs.count.reset();    &#125;,  &#125;,&#125;;&lt;/script&gt;&lt;template&gt;  &lt;count ref=&quot;count&quot; /&gt;  &lt;button @click=&quot;start&quot;&gt;开始计数&lt;/button&gt;  &lt;button @click=&quot;end&quot;&gt;暂停计数&lt;/button&gt;  &lt;button @click=&quot;reset&quot;&gt;重置&lt;/button&gt;&lt;/template&gt;</code></pre><h3 id="五、nextTick-与-nextTick"><a href="#五、nextTick-与-nextTick" class="headerlink" title="五、nextTick 与 $nextTick"></a>五、nextTick 与 $nextTick</h3><blockquote><p>Vue 中 DOM 的更新是<strong>异步</strong>的，如果你想在数据更新后，获取到数据更新后的 DOM，你可以把相关的代码写在<code>nextTick</code>的回调函数中。</p></blockquote><pre><code>function nextTick(callback?: () =&gt; void): Promise&lt;void&gt;</code></pre><ul><li>当你在 Vue 中更改响应式状态时，最终的 DOM 更新并不是同步生效的，而是由 Vue 将它们缓存在一个队列中，直到下一个<code>“tick”</code>才一起执行。这样是为了确保每个组件无论发生多少状态改变，<strong>都仅执行一次更新</strong>。</li><li>要理解上面这段话，需要回答以下两个问题<ul><li>如何理解 DOM 更新是异步的</li><li>下一次tick指的是什么时候</li></ul></li></ul><h4 id="DOM-更新是异步的"><a href="#DOM-更新是异步的" class="headerlink" title="DOM 更新是异步的"></a>DOM 更新是异步的</h4><blockquote><p>在 Vue 中，当响应式数据发生变化时，页面用到数据的地方也会发生变化，但并不是同步的，DOM 的更新是异步的。</p></blockquote><ul><li>也就是说，如果你一次更新多个数据，最终 DOM 只会更新一次，并不会在每个数据更新时，都更新下对应的 DOM。<ul><li>代码示例</li></ul></li></ul><pre><code>&lt;script&gt;  export default &#123;    data() &#123;      return &#123;        n: 0,      &#125;;    &#125;,    methods: &#123;      add() &#123;        for (let i = 1; i &lt;= 100; i++) &#123;          this.n++;        &#125;      &#125;,    &#125;,    watch: &#123;      n(newValue) &#123;        console.log(newValue);      &#125;,    &#125;,  &#125;;&lt;/script&gt;&lt;template&gt;  &lt;div&gt;n的值:&#123;&#123; n &#125;&#125;&lt;/div&gt;  &lt;button @click=&quot;add&quot;&gt;自增&lt;/button&gt;&lt;/template&gt;</code></pre><ul><li>以上代码中，我们为创建了<code>watch</code>侦听器来侦听<code>n</code>值的变化，当点击按扭时，n的值会按1,2,3,4…形式递增到 100。</li><li>如果说数据更新后，DOM 就要同步更新的话，那 DOM 要更新 100，同时侦听器回调函数也会被调用 100 次。<strong>但实际上 DOM 只更新了一次，并且侦听器也只调用了一次，侦听到的 n 值为 100</strong></li></ul><ol><li>DOM 更新是异步，带来的问题</li></ol><ul><li>因为 DOM 更新是异步的，所以我们想在数据更新后，立刻获取到更新后的 DOM，是没有办法获取到的。</li></ul><pre><code>&lt;script&gt;  export default &#123;    data() &#123;      return &#123;        n: 0,      &#125;;    &#125;,    methods: &#123;      add() &#123;        for (let i = 1; i &lt;= 100; i++) &#123;          this.n++;        &#125;        //  以下代码是在DOM更新前被执行        console.log(this.$refs.box.innerHTML); // n的值:0      &#125;,    &#125;,    watch: &#123;      n(newValue) &#123;        console.log(newValue);      &#125;,    &#125;,  &#125;;&lt;/script&gt;&lt;template&gt;  &lt;div ref=&quot;box&quot;&gt;n的值:&#123;&#123; n &#125;&#125;&lt;/div&gt;  &lt;button @click=&quot;add&quot;&gt;自增&lt;/button&gt;&lt;/template&gt;</code></pre><ol start="2"><li>nextTick 中获取数据更新后 DOM</li></ol><ul><li>如果想在数据更新后，获取到更新后的 DOM，可以把相关代码放在在<code>nextTick</code>的回调函数中来执行，<code>nextTick</code>的回调函数会在 DOM 更新后调用。</li></ul><pre><code>&lt;script&gt;  import &#123; nextTick &#125; from &quot;vue&quot;;  export default &#123;    data() &#123;      return &#123;        n: 0,      &#125;;    &#125;,    methods: &#123;      add() &#123;        for (let i = 1; i &lt;= 100; i++) &#123;          this.n++;        &#125;        // nextTick中的代码是在DOM更新后执行        nextTick(() =&gt; &#123;          console.log(this.$refs.box.innerHTML); //  n的值:100        &#125;);      &#125;,    &#125;,    watch: &#123;      n(newValue) &#123;        console.log(newValue);      &#125;,    &#125;,  &#125;;&lt;/script&gt;&lt;template&gt;  &lt;div ref=&quot;box&quot;&gt;n的值:&#123;&#123; n &#125;&#125;&lt;/div&gt;  &lt;button @click=&quot;add&quot;&gt;自增&lt;/button&gt;&lt;/template&gt;</code></pre><ul><li>接下来深入下来<code>nextTick</code>的原理</li></ul><ol start="2"><li>下一次 tick 指的是什么时候<blockquote><p>要了解下一次tick是什么时候，我们需要知道何为一次<code>tick</code>，这就需要我们了解 JS 中的事件循环机制（Event Loop）<br><strong>事件循环机制</strong></p></blockquote></li></ol><ul><li>JS 中的任务分为同步与异步，其中异步任务又分为：宏任务（Macro-take）和微任务（Micro-take）<img src="js任务机制.png"></li></ul><table><thead><tr><th>宏任务</th><th>微任务</th></tr></thead><tbody><tr><td>script 标签(JS 整体代码)、setTimeout、setInterval、Ajax、DOM 事件 等</td><td>Promise 的 then 和 catch 方法、MutaionObserver、async&#x2F;await 等</td></tr></tbody></table><blockquote><p>JS 是单线程的，它是基于事件循环的，事件循环大致分为以下几个步骤</p></blockquote><ul><li>1、刚开始，调用栈空。微任务队列空，宏任务队列里有且只有一个 Script 脚本（整体 JS 代码）。这时首先执行的就是这个宏任务。(所以一开始程序执行时是没有微任务的)</li><li>2、整体代码作为宏任务进入调用栈，先执行同步代码，在执行的过程中遇到宏任务或微任务，就将他们加入分别加入到宏任务队列或微任务队列。</li><li>3、上一步的同步代码执行完后出栈，接着从微任务队列中取出微任务（先添加到微任务队列的先执行）并执行，在执行微任务过程中产生新的微任务，会添加到微任务队列，等微任务中的任务全部完成后，并不会马上执行宏任务，而是会进行 DOM 渲染</li><li>4、开始 DOM 渲染，把内容呈现在页面中,DOM 渲染结束。</li><li>5、接着从宏任务队列中取出宏任务（先加入到宏任务队列的先执行），并压入栈中执行。在执行宏任务时，也可能会产生新的宏任务和微任务。其执行过程重复上面操作。<ul><li>以上不断重复的过程就叫做<code>Event Loop</code>（事件循环）</li></ul></li></ul><blockquote><p>何为一次 tick</p></blockquote><ul><li>上面 1-3 的过程就算是一个tick，从 5 开始又是一次新的tick，即为下一次tick。</li><li>上一tick和下一次tick之间隔着一个 DOM 渲染。</li></ul><blockquote><p>nextTick 的执行时机</p></blockquote><ul><li>因为响应式状态发生变化时，DOM 并不是同步更新的，而是由Vue将它们缓存在一个队列中，所以在下一次<code>tick</code>时，先执行的是更新 DOM 的微任务，然后再执行<code>nextTick</code>的回调，<code>nextTick</code>的回调函数本质是在<code>Promise</code>的<code>then</code>方法中调用的，执行也的是一个微任务。</li><li>实际上这里提到的下一次tick是在步骤 4 前面执行的，因为他执行的是微任务。</li><li>所以 Vue 内部本质是同步的方式更新数据，DOM 更新在微任务中执行，<code>nextTick</code>的回调也是在微任务中执行，只是在 DOM 更新后执行。</li></ul><ol start="3"><li>nextTick 的两种用法<blockquote><p>nextTick 是一个全局方法，本质是创建一个异步任务，那么它自然要等到同步任务执行完成后才执行。</p></blockquote></li></ol><ul><li><code>nextTick</code>没有传递回调时，返回的是一个成功的<code>Promise</code></li><li><code>nextTick</code>传入了回调函数，返回值是<code>void</code>，本质上回调函数会被传入<code>promise</code>的<code>then</code>方法中</li></ul><pre><code>// 以下是 nextTick的部分源码const resolvedPromise = /*#__PURE__*/ Promise.resolve();let currentFlushPromise = null;function nextTick(fn) &#123;  const p = currentFlushPromise || resolvedPromise;  return fn ? p.then(this ? fn.bind(this) : fn) : p;&#125;</code></pre><ul><li>所以我们可以通过以下两种方式来使用nextTick方法</li></ul><pre><code>// 方法一await nextTick();// 所有需要在数据更新后获取更新的DOM操作都可以写在这里// 方法二nextTick(() =&gt; &#123;  // 所有需要在数据更新后获取更新的DOM操作都可以写在这里&#125;);</code></pre><h4 id="nextTick"><a href="#nextTick" class="headerlink" title="$nextTick"></a>$nextTick</h4><blockquote><p>绑定在实例上的 nextTick()函数</p></blockquote><pre><code>$nextTick(callback?: (this: ComponentPublicInstance) =&gt; void): Promise&lt;void&gt;</code></pre><ul><li>和全局版本的 <code>nextTick()</code> 的唯一区别就是组件传递给 <code>this.$nextTick()</code> 的回调函数会带上 <code>this</code> 上下文，其绑定了当前组件实例</li></ul><pre><code>await this.$nextTick(function () &#123;  console.log(this); // 当前组件实例&#125;);await nextTick(function () &#123;  console.log(this); // undefined&#125;);</code></pre><blockquote><p>为什么同时需要<code>$nextTick</code>和<code>nextTick</code></p></blockquote><ul><li>在指令的钩子函数中是没有办法访问<code>this.$nextTick</code>，因为其内部的<code>this</code>指向<code>undefined</code></li></ul><pre><code>&lt;script&gt;  import &#123; nextTick &#125; from &quot;vue&quot;;  export default &#123;    directives: &#123;      focus: &#123;        created(el, binding) &#123;          /* 错误写法，因为this指向                this.$nextTick(() =&gt; &#123;                    el.focus()                &#125;)                */          /* 这种方式可以，不过写法上较复杂                 binding.instance.$nextTick(() =&gt; &#123;                     el.focus()                 &#125;)                 */          // 以下是最简单写法          nextTick(() =&gt; &#123;            el.focus();          &#125;);        &#125;,      &#125;,    &#125;,  &#125;;&lt;/script&gt;&lt;template&gt;  &lt;input type=&quot;text&quot; v-focus /&gt;&lt;/template&gt;</code></pre><ul><li>在实际开发中可以根据需要来选择，能用<code>$nextTick</code>的尽量用他，因为不需要再导入全局的<code>nextTick</code></li></ul><h3 id="六、组件实例属性"><a href="#六、组件实例属性" class="headerlink" title="六、组件实例属性"></a>六、组件实例属性</h3><blockquote><p>本小节我们来学习组件实例相关的属性，如下表：</p><table><thead><tr><th>组件实例属性</th><th>说明</th></tr></thead><tbody><tr><td>$el</td><td>获取该组件实例管理的 DOM 根节点</td></tr><tr><td>$parent</td><td>获取该组件对应的父组件实例。如果当前组件是顶层组件，则为 null</td></tr><tr><td>$root</td><td>当前组件树的根组件实例。如果当前实例没有父组件，这个值就是它自己</td></tr></tbody></table></blockquote><ul><li><code>/src/App.vue</code>根组件内容</li></ul><pre><code>&lt;script&gt;  import Header from &quot;./components/Header.vue&quot;;  export default &#123;    components: &#123;      Header,    &#125;,  &#125;;&lt;/script&gt;&lt;template&gt;  &lt;div class=&quot;main&quot;&gt;    &lt;div class=&quot;top&quot;&gt;顶部小导航&lt;/div&gt;    &lt;header /&gt;  &lt;/div&gt;&lt;/template&gt;</code></pre><ul><li><code>/src/components/Header.vue</code> 组件内容</li></ul><pre><code>&lt;script&gt;  import Count from &quot;./Count.vue&quot;;  export default &#123;    components: &#123;      Count,    &#125;,  &#125;;&lt;/script&gt;&lt;template&gt;  &lt;div class=&quot;header&quot;&gt;    &lt;Count /&gt;  &lt;/div&gt;&lt;/template&gt;</code></pre><ul><li><code>/src/components/Count.vue</code>组件内容</li></ul><pre><code>&lt;script&gt;  export default &#123;    mounted() &#123;      console.log(&quot;组件本身的DOM根节点：&quot;, this.$el);      console.log(&quot;组件对应父组件实例&quot;, this.$parent.$el);      console.log(&quot;根组件的DOM根节点&quot;, this.$root.$el);    &#125;,  &#125;;&lt;/script&gt;&lt;template&gt;  &lt;div&gt;count&lt;/div&gt;&lt;/template&gt;</code></pre><img src="组件实例属性.png"><h3 id="七、单文件组件-CSS-功能"><a href="#七、单文件组件-CSS-功能" class="headerlink" title="七、单文件组件 CSS 功能"></a>七、单文件组件 CSS 功能</h3><h4 id="CSS-的默认处理行为"><a href="#CSS-的默认处理行为" class="headerlink" title="CSS 的默认处理行为"></a>CSS 的默认处理行为</h4><blockquote><p>默认情况下<code>&lt;style&gt;</code>标签中的样式会作用于所有组件的元素。因为<code>vite</code></p></blockquote><ul><li>在启动开发服务时，会所有的单文件组件中<code>&lt;style&gt;</code>标签中的样式添加到<code>index.html</code>入口文件的<code>&lt;style&gt;</code>标签中，所以相同的类名，写在后面的会覆盖前面的。</li><li>在生产环境下打包时，所有单文件组件<code>&lt;style&gt;</code>标签中的样式会被打包到一个<code>*.css</code>的文件中，所以相同的类名，写在后面的会覆盖前面的</li><li>不管是开发环境还是生产环境下，<code>App.vue</code>的样式都在子组件样式后面(子组件按照引入顺序)</li></ul><h4 id="scoped-属性"><a href="#scoped-属性" class="headerlink" title="scoped 属性"></a>scoped 属性</h4><blockquote><p>当<code>&lt;style&gt;</code>标签带有<code>scoped attribute</code>的时候，它的 CSS 只会影响当前组件的元素。因为<code>vite</code>：</p></blockquote><ul><li>在构建项目时，不管生产还是开发环境，都会给当前组件的 html 元素添加<code>data-v-xxx</code>的自定义属性</li><li>同时组件中<code>&lt;style&gt;</code>标签中的选择器后会加上对应的<code>data-v-xxx</code>的属性选择。</li><li>以上处理后，就达到了两个组件中的 CSS 样式只能应用于当前组件中的元素，从实现了样式的隔离</li></ul><blockquote><p>注意事项</p></blockquote><ul><li>使用<code>scoped</code>后，父组件的样式将不会渗透到子组件中。不过，<strong>单根子组件</strong>的根节点会同时被父组件的作用域样式和子组件的作用域样式影响。因为<code>vite</code>在构建时，会给单根子组件的根节点元素上加上父组件对应的<code>data-v-xxx</code>的属性。</li><li>注意：只有当子组件是单根组件时，才会在根节点元素上添加父组件的<code>data-v-xx</code>属性。</li></ul><p><strong>设计初衷</strong></p><ul><li>这样设计是为了让父组件可以从布局的角度出发，调整其子组件根元素的样式。常用于调整应用的第三方子组件的样式。</li></ul><h4 id="deep-伪类"><a href="#deep-伪类" class="headerlink" title=":deep() 伪类"></a>:deep() 伪类</h4><blockquote><p>处于<code>scoped</code>样式中的选择器，如果想做更“深度”的。比如：在父组件中调整子组件中根元素之外的其它元素的样式，可以借助<code>:deep()</code>这个伪类</p></blockquote><ul><li><code>App.vue</code></li></ul><pre><code>&lt;script&gt;  import A from &quot;./components/A.vue&quot;;  export default &#123;    components: &#123;      A,    &#125;,  &#125;;&lt;/script&gt;&lt;template&gt;  &lt;div class=&quot;main&quot;&gt;    &lt;A&gt;&lt;/A&gt;  &lt;/div&gt;&lt;/template&gt;&lt;style&gt;  * &#123;    margin: 0px;    padding: 0px;  &#125;&lt;/style&gt;&lt;!--style标签上添加了 scoped --&gt;&lt;style scoped&gt;  .box &#123;    border: 1px solid khaki;  &#125;  .box h3 &#123;    background-color: khaki;  &#125;&lt;/style&gt;</code></pre><ul><li><code>/src/components/A.vue</code>组件内容</li></ul><pre><code>&lt;template&gt;  &lt;div class=&quot;box&quot;&gt;    &lt;h3&gt;组件A&lt;/h3&gt;  &lt;/div&gt;&lt;/template&gt;&lt;!-- style标签上添加了 scoped属性 --&gt;&lt;style scoped&gt;  .box &#123;    width: 300px;    height: 300px;    margin: 10px;    border: 1px solid skyblue;  &#125;  .box h3 &#123;    height: 30px;    text-indent: 1em;    background-color: skyblue;  &#125;&lt;/style&gt;</code></pre><ul><li>打包后生成的html结构如下：</li></ul><pre><code>&lt;div data-v-7a7a37b1=&quot;&quot; class=&quot;main&quot;&gt;  &lt;!--A start--&gt;  &lt;div data-v-65097ce7 data-v-7a7a37b1 class=&quot;box&quot;&gt;    &lt;h3 data-v-65097ce7=&quot;&quot;&gt;组件A&lt;/h3&gt;  &lt;/div&gt;  &lt;!--A end--&gt;&lt;/div&gt;</code></pre><ul><li>打包后生产的*.css文件内容如下：</li></ul><pre><code>/* A组件样式 */.box[data-v-65097ce7] &#123;  width: 300px;  height: 300px;  margin: 10px;  border: 1px solid skyblue;&#125;.box h3[data-v-65097ce7] &#123;  height: 30px;  text-indent: 1em;  background-color: #87ceeb;&#125;/* App 组件样式 */* &#123;  margin: 0;  padding: 0;&#125;.box[data-v-7a7a37b1] &#123;  border: 1px solid khaki;&#125;.box h3[data-v-7a7a37b1] &#123;  background-color: khaki;&#125;</code></pre><ul><li>通过观察html结构与css，我们发现<code>.box h3[data-v-7a7a37b1]</code>选择器并没有生效，因为页面中 h3 标签并没有<code>data-v-7a7a37b1</code>属性。</li><li>如果我们就是想在根组件App中调整 A 子组件中h3标签的样式，App根组件中控制 h3 标签的 CSS 样式应该是如下写法</li></ul><pre><code>.box[data-v-7a7a37b1] h3 &#123;  background-color: khaki;&#125;</code></pre><ul><li>这需要借助<code>:deep()</code>伪类，修改后<code>App.vue</code>中的<code>CSS</code> 样式：</li></ul><pre><code>.box :deep(h3) &#123;  background-color: khaki;&#125;</code></pre><ul><li>上面修改后的 CSS 代码最终会被编译成</li></ul><pre><code>.box[data-v-7a7a37b1] h3 &#123;  background-color: khaki;&#125;</code></pre><ul><li>这样就实现了在App组件中调整A组件中h3标签的样式</li></ul><h4 id="global-伪类"><a href="#global-伪类" class="headerlink" title=":global() 伪类"></a>:global() 伪类</h4><blockquote><p>如果想让某个样式规则应用于全局</p><ul><li>有以下两种方式：</li></ul></blockquote><ul><li>写在不带<code>scoped</code>属性的<code>&lt;style&gt;</code>标签中的样式全局可用。注意：<code>&lt;style&gt;</code>标签与<code>&lt;style scoped&gt;</code>标签可以在一个组件中共存</li></ul><pre><code>&lt;style&gt;  /* 写在这里的样式，全局可用 */&lt;/style&gt;&lt;style scoped&gt;  /* 写在这里的样式，如果没有使用:global()，只能当前组件内可用 */&lt;/style&gt;</code></pre><ul><li>使用<code>:global</code>伪类来，在<code>scoped</code>中被<code>:global()</code>选中的选择器，最终编译后原样输出，不会加上<code>data-v-xx</code>属性选择</li></ul><pre><code>&lt;style scoped&gt;  /* scoped 中写在 :global()中的 css 选择器全局可用*/  :global(.box) &#123;    width: 200px;    height: 200px;    border: 1px solid khaki;    margin: 10px;  &#125;  :global(.box h3) &#123;    height: 30px;    background-color: khaki;  &#125;&lt;/style&gt;</code></pre><ul><li>以上代码最终编译后代码如下：</li></ul><pre><code>&lt;style&gt;  .box &#123;    width: 200px;    height: 200px;    border: 1px solid khaki;    margin: 10px;  &#125;  .box h3 &#123;    height: 30px;    background-color: khaki;  &#125;&lt;/style&gt;</code></pre><h4 id="CSS-Modules"><a href="#CSS-Modules" class="headerlink" title="CSS Modules"></a>CSS Modules</h4><blockquote><p>一个<code>&lt;style module&gt;</code>标签会被编译为<code>CSS Modules</code>并且将生成的<code>CSS class</code>作为<code>$style</code>对象暴露给组件。</p></blockquote><ul><li>代码示例</li></ul><pre><code>&lt;template&gt;  &lt;div :class=&quot;$style.main&quot;&gt;    &lt;div&gt;$style对象值:&#123;&#123; $style &#125;&#125;&lt;/div&gt;    div    &lt;div :class=&quot;$style.box&quot;&gt;      &lt;h3&gt;App组件&lt;/h3&gt;    &lt;/div&gt;  &lt;/div&gt;&lt;/template&gt;&lt;style module&gt;* &#123;  margin: 0px;  padding: 0px;&#125;.main &#123;  margin: 20px;&#125;.box &#123;  width: 200px;  height: 200px;  border: 1px solid skyblue;  margin: 20px;&#125;.box h3 &#123;  height: 30px;  background-color: skyblue;  color: #fff;&#125;&lt;/style&gt;</code></pre><ul><li>以上代码，最终渲染后效果如下：<img src="CSS-Module示例.png"></li></ul><blockquote><p>自定义注入名称</p></blockquote><ul><li>你可以通过给 <code>module attribute</code> 一个值来自定义注入 <code>class</code> 对象的属性名：</li></ul><pre><code>&lt;template&gt;  &lt;!--注意使用时，不要加$符--&gt;  &lt;div :class=&quot;root.main&quot;&gt;    &lt;h3&gt;$style对象值:&#123;&#123; root &#125;&#125;&lt;/h3&gt;    &lt;div :class=&quot;root.box&quot;&gt;&lt;/div&gt;  &lt;/div&gt;&lt;/template&gt;&lt;!--root为注入名--&gt;&lt;style module=&quot;root&quot;&gt;  * &#123;    margin: 0px;    padding: 0px;  &#125;  .main &#123;    margin: 20px;  &#125;  .main h3 &#123;    font-weight: 400;    line-height: 40px;    border-bottom: 1px solid skyblue;  &#125;  .box &#123;    width: 100px;    height: 100px;    background-color: skyblue;    margin: 20px;  &#125;&lt;/style&gt;</code></pre><ul><li>最终渲染后效果与前面的$style效果一模一样。</li></ul><h4 id="CSS-中的-v-bind"><a href="#CSS-中的-v-bind" class="headerlink" title="CSS 中的 v-bind()"></a>CSS 中的 v-bind()</h4><blockquote><p>单文件组件的<code>&lt;style&gt;</code>标签中支持使用<code>v-bind</code>，CSS 函数将 CSS 的值链接到动态的组件状态。</p></blockquote><ul><li><code>v-bind()</code>常用于接受父组件传递给子组件的 <code>CSS</code> 属性的值</li></ul><pre><code>&lt;script&gt;  export default &#123;    data() &#123;      return &#123;        color: &quot;red&quot;,      &#125;;    &#125;,  &#125;;&lt;/script&gt;&lt;template&gt;  &lt;div class=&quot;box&quot;&gt;Hello Vue!!&lt;/div&gt;&lt;/template&gt;&lt;style scoped&gt;  .box &#123;    color: v-bind(color);  &#125;&lt;/style&gt;</code></pre><img src="css中的v-bind().png"><ul><li><code>v-bind()</code>函数中的变量最终被转换成哈希化的 CSS 自定义属性，然后在内联样式中通过<code>CSSvar()</code>函数使用自定义属性的值</li><li>当前组件中通过<code>v-bind()</code>形式绑定的 CSS，最终会转换成哈希化的 CSS 自定义属性添加到当前组件的根元素上，同时会在源值变更的时候响应式地更新</li></ul><h4 id="CSS-预处理器"><a href="#CSS-预处理器" class="headerlink" title="CSS 预处理器"></a>CSS 预处理器</h4><blockquote><p>在<code>&lt;style&gt;</code>标签上可以使用<code>lang</code>这个属性来声明 CSS 的预处理器语言。</p><ul><li>比如：<code>&lt;style lange=&#39;scss&#39;&gt; </code>，表示可以使用 sass 来编写 CSS。</li></ul></blockquote><pre><code>&lt;template&gt;  &lt;div class=&quot;box&quot;&gt;    &lt;p&gt;Hello Vue!!&lt;/p&gt;  &lt;/div&gt;&lt;/template&gt;&lt;style scoped lang=&quot;scss&quot;&gt;  .box &#123;    width: 100px;    height: 100px;    border: 1px solid skyblue;    p &#123;      color: red;    &#125;  &#125;&lt;/style&gt;</code></pre><ul><li>要使sass最终能被成功编译成 CSS，还需要执行以下命令安装Sass的预处理器依赖</li></ul><pre><code>npm i sass -D # 安装sass 依赖包</code></pre><ul><li>最终上面<code>&lt;style&gt;</code>标签中的 Sass 编译成如下 CSS 样式</li></ul><pre><code>.box[data-v-7a7a37b1] &#123;  width: 100px;  height: 100px;  border: 1px solid skyblue;&#125;.box p[data-v-7a7a37b1] &#123;  color: red;&#125;</code></pre><h3 id="八、组件间通信"><a href="#八、组件间通信" class="headerlink" title="八、组件间通信"></a>八、组件间通信</h3><blockquote><p>组件间通信是指各个组件之间可以相互传递数据，实现数据的共享。</p><ul><li>比如：</li></ul></blockquote><ul><li>父组件可以给子组件传数据，子组件也可以给父组件传数据，各个兄弟组件之间也可以互相传递数据。</li></ul><blockquote><p>我们将会学习以下几种组件间通信的方式：</p></blockquote><ul><li>父子组件之间的通信</li><li>兄弟组件之间的通信</li><li>祖孙与后代组件之间的通信</li><li>非关系组件之间的通信</li></ul><h3 id="九、父组件向子组件传值-props"><a href="#九、父组件向子组件传值-props" class="headerlink" title="九、父组件向子组件传值 - props"></a>九、父组件向子组件传值 - props</h3><h4 id="props-选项"><a href="#props-选项" class="headerlink" title="props 选项"></a>props 选项</h4><blockquote><p>父组件向子组件传递数据，可以通过自定义 Prop（属性）来传递。</p></blockquote><ul><li>在使用子组件的时候，在子组件标签上添加自定义属性（Prop），把需要传递的数据做为属性的值就可以，如下：</li></ul><pre><code>&lt;!--List子组件  title与 info 属性用来实现在父组件中传递数据给到子组件--&gt;&lt;List title=&quot;新闻标题&quot; info=&quot;新闻内容&quot; /&gt;</code></pre><ul><li>子组件需要通过<code>prpos</code>选项来接受父组件传递过来的 Prop（属性）。然后就可以在模板标签中通过插值语法使用接受的属性，也可以通过组件实例直接访问。</li></ul><pre><code>&lt;!--List组件--&gt;&lt;script&gt;  export default &#123;    // 通过props选项接受父组件通过Prop传递的数据    props: [&quot;title&quot;, &quot;info&quot;],    created() &#123;      console.log(this.title); // 新闻标题      console.log(this.info); // 新闻内容    &#125;,  &#125;;&lt;/script&gt;&lt;template&gt;  &lt;!--对于接受过来的数据，可以直接在模板中使用--&gt;  &lt;h3&gt;&#123;&#123; title &#125;&#125;&lt;/h3&gt;  &lt;div&gt;&#123;&#123; info &#125;&#125;&lt;/div&gt;&lt;/template&gt;</code></pre><h4 id="Prop-名字格式"><a href="#Prop-名字格式" class="headerlink" title="Prop 名字格式"></a>Prop 名字格式</h4><blockquote><p>定义属性： 如果在传递数据时，属性的名字很长，由两个以上单词组成，建议在<code>HTML</code>标签上使用<code>kebab-case</code>形式来定义属性名。</p><ul><li>主要目标是为了与 HTML 原生的属性对齐。如下：</li></ul></blockquote><pre><code>&lt;List data-title=&quot;新闻标题&quot; data-info=&quot;新闻内容&quot; /&gt;</code></pre><blockquote><p>接受属性：</p></blockquote><ul><li>在子组件的<code>props</code>选项来接受属性时，推荐使用<code>camelCase</code>形式，因为他是一个合法的 JS 标识符，而<code>kebab-case</code>形式并不是合法的 JS 标识符，在插值语法中没有办法使用。</li></ul><pre><code>&lt;!--data-title为不合法标识符，Vue没办法解析--&gt;&lt;div&gt;&#123;&#123; data-title &#125;&#125;&lt;/div&gt;&lt;!--正确写法--&gt;&lt;div&gt;&#123;&#123; dataTitle &#125;&#125;&lt;/div&gt;</code></pre><blockquote><p>代码演示</p></blockquote><ul><li><code>App.vue</code>根组件</li></ul><pre><code>&lt;script&gt;  // 导入组件  import List from &quot;./components/List.vue&quot;;  export default &#123;    // 注册组件    components: &#123;      List,    &#125;,  &#125;;&lt;/script&gt;&lt;template&gt;  &lt;!-- 使用组件，title与info属性值为父组件向子组件传入的数据--&gt;  &lt;List data-title=&quot;新闻标题&quot; data-info=&quot;新闻内容&quot; /&gt;  &lt;List data-title=&quot;最新动态&quot; data-info=&quot;动态内容&quot;&gt;&lt;/List&gt;&lt;/template&gt;</code></pre><ul><li><code>List.vue</code>根组件</li></ul><pre><code>&lt;script&gt;  export default &#123;    data() &#123;      return &#123;&#125;;    &#125;,    // 以下两种props写法都可以，但在模板中使用时需要采用 dataTitle与dataInfo写法    // props: [&quot;data-title&quot;, &quot;data-info&quot;],    props: [&quot;dataTitle&quot;, &quot;dataInfo&quot;],  &#125;;&lt;/script&gt;&lt;template&gt;  &lt;h3&gt;&#123;&#123; dataTitle &#125;&#125;&lt;/h3&gt;  &lt;div&gt;&#123;&#123; dataInfo &#125;&#125;&lt;/div&gt;  &lt;!--以下为错误写法--&gt;  &lt;!--    &lt;h3&gt;&#123;&#123; data-title &#125;&#125;&lt;/h3&gt;    &lt;div&gt;&#123;&#123; data-info &#125;&#125;&lt;/div&gt;    --&gt;&lt;/template&gt;</code></pre><h4 id="静态-VS-动态-Prop"><a href="#静态-VS-动态-Prop" class="headerlink" title="静态 VS 动态 Prop"></a>静态 VS 动态 Prop</h4><blockquote><p>组件在进行 prop 传值时，属性的值可以是一个静态值，也可以是一个动态值。</p></blockquote><ul><li>以下写法的属性为静态属性，其属性值在被接受时，类型永远是字符串</li></ul><pre><code>&lt;List title=&quot;新闻标题&quot; info=&quot;&#123;a:1,b:2&#125;&quot; num=&quot;10&quot; /&gt;</code></pre><ul><li>使用<code>v-bind</code>或缩写<code>:</code>绑定的属性为动态属性，他可以传递任意类型的值，值在被接受时，可以区分不同类型。</li></ul><pre><code>&lt;List :title=&quot;news.title&quot; :info=&quot;&#123;a:1,b:2&#125;&quot; :num=&quot;10&quot; /&gt;</code></pre><h4 id="props-对象写法"><a href="#props-对象写法" class="headerlink" title="props 对象写法"></a>props 对象写法</h4><blockquote><p>props 选项的值可以是一个字符串类型的数组，也可以是一个对象。</p></blockquote><ul><li>如果 props 接受的属性值不需要做类型的校验，可以采用前面讲到的数组写法</li><li>如果 props 对于传过来的属性值有严格的类型要求，我们可以采用对象的形式来声明 props<ul><li>如：</li></ul></li></ul><pre><code>export default &#123;  props: &#123;    title: String, // title值必需为子符串类型    age: Number, // num值必需为数字类型    bool: Boolean, // bool 值必需为数字类型    address: [Object, String], // info值可以是字符串类型，也可以是对象类型  &#125;,&#125;;</code></pre><ul><li>如果传递的值类型不符合要求，控制台会抛出警告</li></ul><ol><li>属性支持的检测类型<blockquote><p>属性支持的检测类型可以是以下这些原生的构造函数：</p></blockquote></li></ol><ul><li>String</li><li>Number</li><li>Boolean</li><li>Array</li><li>Object</li><li>Date</li><li>Function</li><li>Symbol</li></ul><blockquote><p>也可以是自定义的类或构造函数，Vue 将会通过<code>instanceof</code>来检查类型是否匹配。</p></blockquote><ul><li>例如下面这个类：</li></ul><pre><code>class Person &#123;  constructor(name, age) &#123;    this.name = name;    this.age = age;  &#125;&#125;</code></pre><ul><li>你可以将其作为一个 Prop 的类型</li></ul><pre><code>&lt;script&gt;  export default &#123;    props: &#123;      userInfo: Person,    &#125;,  &#125;;&lt;/script&gt;</code></pre><blockquote><p>代码演示</p></blockquote><ul><li><code>Person.js</code> 中定义 <code>Person</code> 类</li></ul><pre><code>export class Person &#123;  constructor(name, age) &#123;    this.name = name;    this.age = age;  &#125;&#125;</code></pre><ul><li><code>App.vue</code> 根组件<ul><li>直接在<code>data</code>里面<code>new</code>实例</li></ul></li></ul><pre><code>&lt;script&gt;  // 导入People组件  import People from &quot;./components/People.vue&quot;;  // 导入 Person类  import &#123; Person &#125; from &quot;./common/Person.js&quot;;  export default &#123;    data() &#123;      return &#123;        // userInfo 数据类型为 Person类的实例        userInfo: new Person(&quot;hermia&quot;, 13),      &#125;;    &#125;,    components: &#123;      People,    &#125;,  &#125;;&lt;/script&gt;&lt;template&gt;  &lt;People :user-info=&quot;userInfo&quot; /&gt;&lt;/template&gt;</code></pre><ul><li><code>People.vue</code> 子组件</li></ul><pre><code>&lt;script&gt;  import &#123; Person &#125; from &quot;../common/Person.js&quot;;  export default &#123;    props: &#123;      userInfo: Person,    &#125;,  &#125;;&lt;/script&gt;&lt;template&gt;  &lt;div&gt;&#123;&#123; userInfo.name &#125;&#125; -- &#123;&#123; userInfo.age &#125;&#125;&lt;/div&gt;&lt;/template&gt;</code></pre><h4 id="Prop-校验"><a href="#Prop-校验" class="headerlink" title="Prop 校验"></a>Prop 校验</h4><blockquote><p>如果我们需要对传过来的值做更严格的校验，可以将 props 选项对象的属性值写成一个带有校验选项的对象。</p><ul><li>如下：</li></ul></blockquote><ul><li><code>type</code>：数据类型</li><li><code>required</code>：属性是否为必传，true表示必传</li><li><code>default</code>：属性的默认值</li><li><code>validator</code>：数据校验函数，注意<code>validator</code>没有办法访问到组件实例，<code>validator</code>方法中<code>this</code>为<code>undefined</code></li></ul><pre><code>&lt;script&gt;  export default &#123;    props: &#123;      myProps: &#123;        // 数据类型        type: Number,        // 属性是否为必传，true表示必传        required: true,        // 表示未传该属性时，属性的默认值，如果没有配置default选项        default: 17,        /* default可以是一个函数，函数返回值属性默认值                default(rawProps)&#123;                    return 28                    &#125;                */        // 数据校验函数，如果返回值为false，表示校验失败，控制台会抛出警告        validator(value) &#123;          // ....          return true;        &#125;,      &#125;,    &#125;,  &#125;;&lt;/script&gt;</code></pre><ul><li><code>required</code>与<code>default</code>不能同时出现，因为必传，就决定了不会启用默认值</li><li>这两种方式效果是一样的</li></ul><pre><code>props: &#123;    title: String, &#125; props: &#123;      title: &#123;        // 数据类型        type: String,      &#125; &#125;</code></pre><ul><li>这两种方式对于没有传的非<code>bool</code>类型属性，默认值都为<code>undefind</code>，不会在页面显示；<code>bool</code>类型属性为<code>false</code>，会显示在页面</li></ul><h4 id="Boolean-类型-Prop-简写形式"><a href="#Boolean-类型-Prop-简写形式" class="headerlink" title="Boolean 类型 Prop 简写形式"></a>Boolean 类型 Prop 简写形式</h4><blockquote><p>当父组件向子组件通过<code>Prop</code>传值时，传递的属性值为<code>Boolean</code>类型时，可以支持以下简写形式</p></blockquote><pre><code>&lt;!--完整写法--&gt;&lt;Person :bool=&quot;true&quot; /&gt;&lt;Person :bool=&quot;false&quot; /&gt;&lt;!--以下为简写形式--&gt;&lt;Person bool /&gt;&lt;!-- 等同于传入 :bool=&quot;true&quot; --&gt;&lt;Person /&gt;&lt;!-- 等同于传入 :bool=&quot;false&quot; --&gt;</code></pre><ul><li>注意：在子组件的<code>props</code>选项中必须要指定该属性值的类型为<code>Boolean</code>类型，多类型的时候要写在最前面</li></ul><pre><code>export default &#123;  props: &#123;    bool: Boolean, // 或 [Boolean, String]  Boolean一定要出现在第一位，以下简写形式才支持  &#125;,&#125;;</code></pre><h4 id="使用一个对象绑定多个-Prop"><a href="#使用一个对象绑定多个-Prop" class="headerlink" title="使用一个对象绑定多个 Prop"></a>使用一个对象绑定多个 Prop</h4><blockquote><p>如果你想要将一个对象的所有属性都当作 props 传入，你可以使用没有参数的<code>v-bind</code>。</p></blockquote><pre><code>&lt;script&gt;  import Person from &quot;./components/Person.vue&quot;;  export default &#123;    data() &#123;      return &#123;        userInfo: &#123;          username: &quot;清心&quot;,          age: 33,          tel: 13523456543,        &#125;,      &#125;;    &#125;,    components: &#123;      Person,    &#125;,  &#125;;&lt;/script&gt;&lt;template&gt;  &lt;Person v-bind=&quot;userInfo&quot; /&gt;  &lt;!--以上方式等价于--&gt;  &lt;Person    :username=&quot;userInfo.username&quot;    :age=&quot;userInfo.age&quot;    :tel=&quot;userInfo.tel&quot;  /&gt;&lt;/template&gt;</code></pre><h4 id="Props-选项被处理的时机"><a href="#Props-选项被处理的时机" class="headerlink" title="Props 选项被处理的时机"></a>Props 选项被处理的时机</h4><blockquote><p><code>Props</code>选项是在生命周期函数<code>beforeCreate</code>之前被解析，且<code>prop</code>的校验是在组件实例被创建之前处理的。</p></blockquote><ul><li>所以在<code>data、computed、method</code>选项中可以访问到<code>Props</code>选项中的属性。</li><li>但<code>Props</code>选项中没有办法访问到<code>data、computed、method</code>等选项中的属性</li></ul><h4 id="更新-prop-的值"><a href="#更新-prop-的值" class="headerlink" title="更新 prop 的值"></a>更新 prop 的值</h4><blockquote><p>如果需要更新 prop 的值，推荐在<strong>父组件</strong>中更新，每次父组件中的数据更新后，所有子组件中对应的 props 都会被更新到最新值</p></blockquote><ol><li>单向数据流</li></ol><ul><li>所有的 props 都遵循着单向绑定原则，子组件中可以使用父组件传过来的数据，但这些数据是<strong>只读</strong>的，在子组件中不能去修改这些数据。这避免了子组件意外修改父组件的状态的情况，不然应用的数据流将很容易变得混乱而难以理解。</li><li>如果在子组件中更改了 prop 的值，会在控制台抛出警告，这就意味着我们不应该这样做</li></ul><blockquote><p>但在某些情况下，我们确实需要在子组件中更改 props 中属性的值，比如以下两个场景：</p></blockquote><ul><li>场景一： prop 用来传入初始值，而子组件想在之后将其作为一个局部数据属性</li><li>场景二： 需要对传入的 prop 值做进一步的转换<ul><li>那应该如何操作呢 ？</li></ul></li></ul><ol start="2"><li>更改<strong>基本数据类型</strong>的 prop 值<blockquote><p>针对场景一： prop 用来传入初始值，而子组件想在之后将其作为一个局部数据属性。</p></blockquote></li></ol><ul><li>如果属性的值是基本数据类型，在这种情况下，最好是<strong>新定义</strong>一个局部数据属性，从 props 上获取初始值即可</li></ul><blockquote><p>代码演示</p></blockquote><ul><li>App.vue</li></ul><pre><code>&lt;script&gt;  import Person from &quot;./components/Person.vue&quot;;  export default &#123;    data() &#123;      return &#123;        money: 1000,      &#125;;    &#125;,    components: &#123;      Person,    &#125;,  &#125;;&lt;/script&gt;&lt;template&gt;  &lt;Person :money=&quot;money&quot; /&gt;&lt;/template&gt;</code></pre><ul><li>Person.vue</li></ul><pre><code>&lt;script&gt;  export default &#123;    props: [&quot;money&quot;],    data() &#123;      return &#123;        // 只是将money作为初始值        // 然后将其赋值给到一个新的属性，这样后期更新就和money无关了        newMoney: this.money,      &#125;;    &#125;,  &#125;;&lt;/script&gt;&lt;template&gt;  &lt;!--子组件中，绑定newMoney属性--&gt;  &lt;div&gt;当前账户初始金额：&#123;&#123; newMoney &#125;&#125;&lt;/div&gt;  &lt;button @click=&quot;newMoney = newMoney - 200&quot;&gt;消费200&lt;/button&gt;&lt;/template&gt;</code></pre><blockquote><p>针对场景二：</p></blockquote><ul><li>需要对传入的 prop 值做进一步的转换</li><li>如果属性的值是基本数据类型，在这种情况中，最好是基于该 prop 值定义一个<strong>计算属性</strong></li></ul><pre><code>&lt;script&gt;  export default &#123;    props: [&quot;money&quot;],    data() &#123;      return &#123;        // 只是将money作为初始值        // 然后将其赋值给到一个新的属性，这样后期更新就和money无关了        newMoney: this.money,      &#125;;    &#125;,    computed: &#123;      myMoney() &#123;        return &quot;￥&quot; + this.newMoney + &quot;元&quot;;      &#125;,    &#125;,  &#125;;&lt;/script&gt;&lt;template&gt;  &lt;!--子组件中，绑定newMoney属性--&gt;  &lt;div&gt;当前账户初始金额：&#123;&#123; myMoney &#125;&#125;&lt;/div&gt;  &lt;button @click=&quot;newMoney = newMoney - 200&quot;&gt;消费200&lt;/button&gt;&lt;/template&gt;</code></pre><ol start="3"><li>更改<strong>对象&#x2F;数组类型</strong>的 prop 值</li></ol><ul><li>如果 prop 的值是数组或对象，我们虽然不能直接修改属性的值（重新给属性赋值），但我们依然可以更改数组和对象内部的值。</li><li>因为对象和数组是引用数据类型，所以修改对象的值，会修改父组件中的数据</li><li>但官方非常不推荐我们这样做，因为这种更改的主要缺陷是它允许了子组件以某种不明显的方式影响父组件的状态，可能会使数据流在将来变得更难以理解。</li><li>假设父组件中的某个数据传递给了 10 个子组件，然后每个子组件内部都有一套修改该数据的方法，那最后数据的管理将会变得非常的混乱。如何所有修改数据的方法都交组父组件来管理，那对数据的管理将会更清淅。</li><li>所以，针对 prop 的值是对象或数组，而我们又想在子组件中更改这些数据时，官方给我们提供了一种最佳的实现方式：子组件抛出一个事件来通知父组件做出改变：<code>emits</code></li></ul><h3 id="十、子组件向父组件传值-emits"><a href="#十、子组件向父组件传值-emits" class="headerlink" title="十、子组件向父组件传值 - emits"></a>十、子组件向父组件传值 - emits</h3><h4 id="监听与触发自定义事件"><a href="#监听与触发自定义事件" class="headerlink" title="监听与触发自定义事件"></a>监听与触发自定义事件</h4><blockquote><p>自定义事件也可以称为组件事件，因为自定义事件主要是绑定在组件身上，用来解决子组件向父组件传递数据或修改父组件中数据。</p></blockquote><ul><li>所以这里要与原生 JS 事件做区分，原生 JS 事件主要是绑定在原生的 HTML 元素身上。</li></ul><blockquote><p>监听事件</p></blockquote><ul><li>在父组件中可以通过<code>v-on</code>(缩写为<code>@</code>)来监听事件：</li></ul><pre><code>&lt;script&gt;  methods: &#123;      // 下面的update-event事件触发后，就会调用update更新数据      update() &#123; /* ... */&#125;  &#125;&lt;/script&gt;&lt;!--     update-event为事件名,类似于原生JS中click，mouseover等事件名    update为事件处理函数，即事件触发后调用的函数--&gt;&lt;MyComponent @update-event=&quot;update&quot; /&gt;</code></pre><blockquote><p>触发事件</p></blockquote><ul><li>方法1：在子组件的模板表达式中，可以直接使用<code>$emit(事件名)</code>方法触发自定义事件</li></ul><pre><code>&lt;!--MyComponent 子组件--&gt;&lt;!--updateEvent是触发的事件名，事件名在这里要采用驼峰命名--&gt;&lt;!--button绑定了click事件，点击按扭后，通过$emit方法触发了updateEvent自定义事件，事件触发后，就会调用事件绑定的update方法，更新数据--&gt;&lt;button @click=&quot;$emit(updateEvent)&quot;&gt;更新数据&lt;/button&gt;</code></pre><ul><li>方法2：在组件实例上以<code>this.$emit()</code>的方式触发自定义事件</li></ul><pre><code>// MyComponent 子组件&lt;script&gt;export default &#123;    methods: &#123;        updateData() &#123;            &lt;!--updateEvent是触发的事件名，事件名在这里要采用驼峰命名--&gt;            this.$emit(&#39;updateEvent&#39;)        &#125;    &#125;&#125;&lt;/script&gt;&lt;template&gt;  &lt;div&gt;    &lt;!--点击按扭，会调用updateDate方法，在此方法中通过this.$emit方法，触发了updateEvent自定义事件，事件触发后，就会调用事件绑定的update方法，更新数据--&gt;     &lt;button @click=&quot;updateDate&quot;&gt;更新数据2&lt;/button&gt;  &lt;/div&gt;&lt;/template&gt;</code></pre><blockquote><p>总结：自定义事件监听与触发</p></blockquote><ul><li>监听：在父组件中通过<code>v-on</code>（缩写为<code>@</code>）监听自定义事件，同时添加事件处理回调函数</li><li>触发：<ul><li>在子组件模板中通过<code>$emit</code>方法触发自定义事件；</li><li>在子组件实例上通过<code>this.$emit()</code>方式触发自定义事件</li></ul></li></ul><h4 id="emits-选项"><a href="#emits-选项" class="headerlink" title="emits 选项"></a>emits 选项</h4><blockquote><p><code>emits</code>选项用来显示声明子组件需要触发的事件，他支持数组与对象两种写法。</p></blockquote><blockquote><p>以下是数组写法</p></blockquote><pre><code>export default &#123;  emits: [&quot;updateEvent&quot;, &quot;delEvent&quot;],&#125;;</code></pre><ul><li>在单根组件中，不用<code>emits</code>选项来声明子组件要触发的事件，好像对我们执行代码没有什么影响，控制台也不报警告。</li><li>但在多根组件中不用<code>emits</code>选项来声明子组件要触发的事件，控制台就会抛出警告<blockquote><p>不管子组件是单根组件还是多根组件，我们都推荐使用<code>emits</code>选项来完整声明所有要触发的自定义事件。这样有两个好处：</p></blockquote></li><li>通过emits选项，一眼就能知道当前组件中需要触发那些自定义事件</li><li>可以让 Vue 更好的将事件与<strong>透传属性</strong>作出区分</li></ul><blockquote><p>如果需要对触发事件的参数作校验，则需要采用对象写法。</p></blockquote><h4 id="自定义事件名格式"><a href="#自定义事件名格式" class="headerlink" title="自定义事件名格式"></a>自定义事件名格式</h4><blockquote><p>与 prop 名一样，事件的名字也提供了自动的格式转换</p></blockquote><ul><li>在父组件中监听自定义事件时，推荐采用<code>kebab-case</code>形式为自定义事件命名。</li><li>在组子件中触发自定义事件时，推荐采用<code>camelCase</code>形式书写自定义事件名。</li></ul><pre><code>&lt;!-- 父组件中监听事件，事件名以kebab-case形式命令 --&gt;&lt;List @update-event=&quot;update&quot; /&gt;&lt;!-- 在子组件中触发事件时，采用camelCase形式书写自定义事件名 --&gt;&lt;button @click=&quot;$emit(&#39;updateEvent&#39;)&quot;&gt;更新数据1&lt;/button&gt;</code></pre><h4 id="自定义事件参数"><a href="#自定义事件参数" class="headerlink" title="自定义事件参数"></a>自定义事件参数</h4><blockquote><p>有时候我们需要子组件在触发自定义事件时传一些数据给到父组件，则可以将需要传递的数据作为<code>$emit()</code>方法的第二个及之后的参数传入。</p></blockquote><pre><code>&lt;!--$emit的第一个参数为自定义事件名，之后的每个参数为需要传放的数据--&gt;&lt;button @click=&quot;$emit(&#39;updateEvent&#39;,5,6,7)&quot;&gt;更新数据1&lt;/button&gt;</code></pre><ul><li><p>在父组件中监听事件，传递过来的数据可以通过事件处理回调函数的参数接受到。事件处理函数可以采用以下两种写法</p></li><li><p>事件处理回调函数，写成一个箭头函数</p></li></ul><pre><code>&lt;List @update-event=&quot;(a,b,c)=&gt;sum=a+b+c&quot; /&gt;</code></pre><ul><li>事件处理函数为组件的方法，定义在<code>methods</code>选项中</li></ul><pre><code>&lt;List @update-event=&quot;update&quot; /&gt;methods: &#123;    //方式1：    update(a, b, c) &#123;        // a b c对应传过来的数据 5 6 7        console.log(a, b, c);    &#125;    // 方式2：或通过arguments来接收    update() &#123;        Array.from(arguments).forEach((item) =&gt; &#123;            this.arr.push(item)        &#125;)        this.num=arguments[0]    &#125;        // 方式3：或通过剩余参数来接收    update(...arg) &#123;        this.num=arg[0]    &#125;&#125;</code></pre><h4 id="自定义事件校验"><a href="#自定义事件校验" class="headerlink" title="自定义事件校验"></a>自定义事件校验</h4><ul><li>如果我们想要对触发的自定义事件的参数进行验证，可以将<code>emits</code>选项写成一个<strong>对象</strong></li><li>对象中每个事件被赋值为一个函数，函数可接受的参数为<code>this.$emit</code>触发事件时传入的参数（除第一个参数之外的所有参数）</li></ul><pre><code>export default &#123;  emits: &#123;    // 事件没有校验    updateEvent: null,    // 校验delEvent事件    // ...params 剩余参数，用来接受传过来的所有参数    delEvent(...params) &#123;      // 通过返回值为 `true` 还是为 `false` 来判断事件是否合法      // 如果返回值为fasle，则事件不合法，控制台会抛出警告      // 如果返回值为true，则事件合法      return true; // 或false    &#125;,  &#125;,&#125;;</code></pre><h4 id="自定义事件注意事项"><a href="#自定义事件注意事项" class="headerlink" title="自定义事件注意事项"></a>自定义事件注意事项</h4><blockquote><p>以下是我们在使用自定义事件时，需要注意的相关事项：</p></blockquote><ul><li>自定义事件只能用来实现子组件向父组件传递数据或修改父组件中数据，<strong>不能实现兄弟组件间通信</strong>。因为事件需要在父组件中被监听，然后在子组件中触发。</li><li>自定义事件本身也支持<code>.once</code>修饰符，添加了<code>.once</code>修饰符后，自定义事件只能被触发一次。</li><li>在组件上监听 JS <strong>原生</strong>的事件，可以直接透传到单根组件的根元素上，但多根组件就没办法接收。</li><li>在<code>$emit</code>选项中不要声明一个 JS 原生的事件名（例如：click），如果click出现在<code>$emit</code>选项中，则监听器只会监听组件触发的 click 事件而不会再响应原生的 click 事件</li></ul><h3 id="十一、组件-v-model"><a href="#十一、组件-v-model" class="headerlink" title="十一、组件 v-model"></a>十一、组件 v-model</h3><blockquote><p><code>v-model</code>指令不仅可以用在输入元素上，用来实现双向数据绑定，也可以用在组件上实现双向绑定。</p></blockquote><h4 id="v-model-绑定输入元素"><a href="#v-model-绑定输入元素" class="headerlink" title="v-model 绑定输入元素"></a>v-model 绑定输入元素</h4><blockquote><p>以下是v-model指令应用在输入元素上，实现双向数据绑定</p></blockquote><pre><code>&lt;input v-model=&quot;searchText&quot; /&gt;</code></pre><blockquote><p>以上v-model指令背后的实现原理：</p></blockquote><ul><li>通过<code>v-bind</code>指令绑定将<code>searchText</code>变量的值绑定到输入框的 <code>value</code> 值</li><li>通过监听<code>@input</code>事件，在表单中输入内容时触发<code>input</code>事件，把表单 <code>value</code> 的值绑定到<code>searchText</code>变量</li></ul><pre><code>&lt;input :value=&quot;searchText&quot; @input=&quot;searchText = $event.target.value&quot; /&gt;</code></pre><ul><li>本质上<code>v-model</code>是一个语法糖，帮我们简化了以上代码的书写。</li></ul><h4 id="v-model-绑定组件"><a href="#v-model-绑定组件" class="headerlink" title="v-model 绑定组件"></a>v-model 绑定组件</h4><blockquote><p>以下是v-model指令应用于一个自定义弹窗组件，用来实现双向绑定</p></blockquote><pre><code>&lt;Popup v-model=&quot;show&quot; /&gt;</code></pre><blockquote><p>以上v-model指令背后的实现原理：</p></blockquote><ul><li>将变量<code>show</code>的值绑定到属性<code>modelValue</code>传递给到子组件<code>&lt;Popup&gt;</code></li><li>父组件监听<code>update:modelValue</code>事件，事件接受一个参数，该参数用来修改变量<code>show</code>的值。</li><li>注意：默认情况下属性名<code>modelValue</code>和事件<code>update:modelValue</code>是固定写法，不能修改</li></ul><pre><code>&lt;Popup  :modelValue=&quot;show&quot;  @update:modelValue=&quot;(newValue) =&gt; &#123; show = newValue &#125;&quot;/&gt;</code></pre><ul><li>本质上<code>v-model</code>是一个语法糖，帮我们简化了以上代码的书写</li><li>无论采用哪种方式，子组件触发事件的方式都是一样的</li></ul><pre><code>&lt;script&gt;  export default &#123;    // 1：接受父组件传递的属性    props: [&quot;modelValue&quot;],    // 2：接受父组件传递的事件    emits: [&quot;update:modelValue&quot;],  &#125;;&lt;/script&gt;&lt;template&gt;  &lt;!-- 3: 使用父组件传来的值 modelValue --&gt;  &lt;div class=&quot;popup&quot; v-show=&quot;modelValue&quot;&gt;    &lt;!-- 4：通过$emit方法触发了update:modelValue自定义事件将modelValue的值更新为false--&gt;    &lt;div class=&quot;close&quot; @click=&quot;$emit(&#39;update:modelValue&#39;, false)&quot;&gt;确认&lt;/div&gt;  &lt;/div&gt;&lt;/template&gt;</code></pre><h4 id="v-model-实战应用：点击弹窗"><a href="#v-model-实战应用：点击弹窗" class="headerlink" title="v-model 实战应用：点击弹窗"></a>v-model 实战应用：点击弹窗</h4><blockquote><p>利用<code>v-model</code>指令实现如下弹窗效果，点击显示按扭时会弹出弹窗，点击弹窗关闭按扭时会关闭弹窗</p><ul><li>实现步骤</li></ul></blockquote><blockquote><p>父组件</p></blockquote><ul><li>创建弹窗子组件<code>&lt;Popup&gt;</code>，并实现弹窗的布局</li><li>在根组件<code>&lt;App&gt;</code>中创建一个按扭，点击按扭时就会显示弹窗。</li><li>在<code>&lt;App&gt;</code>组件中定义一个布尔类型变量<code>show</code>用来控制弹窗的显示与隐藏，默认弹窗隐藏，则默认值为<code>false</code></li><li>点击显示按扭，显示弹窗，则<code>show=true</code></li></ul><pre><code>&lt;script&gt;  // 引入组件  import Popup from &quot;./components/Popup.vue&quot;;  export default &#123;    data() &#123;      return &#123;        show: false, // 用来控制弹窗的显示与隐藏      &#125;;    &#125;,    components: &#123;      Popup,    &#125;,  &#125;;&lt;/script&gt;&lt;template&gt;  &lt;button @click=&quot;show = true&quot;&gt;显示&lt;/button&gt;  &lt;Popup /&gt;&lt;/template&gt;</code></pre><ul><li>弹窗的显示与隐藏，本质是控制<code>.popup</code>和<code>.mask</code>元素的显示与隐藏。所以父组件需要把<code>show</code>变量的值通过<code>props</code>方式传递给到子组件，并且还需要传递操作<code>show</code>变量值的方法。</li><li>这里我们把<code>show</code>变量做为<code>modelValue</code>属性的值传递给到子组件，同时监听操作<code>show</code>变量的方法<code>update:modelValue</code></li></ul><pre><code>&lt;Popup  :modelValue=&quot;show&quot;  @update:modelValue=&quot;(newValue) =&gt; &#123; show = newValue &#125;&quot;/&gt;&lt;!--  或以下为简这与形式 v-model指令实现 --&gt;&lt;Popup v-model=&quot;show&quot; /&gt;</code></pre><blockquote><p>在子组件<code>&lt;Popup&gt;</code>中需要做以下 4 步处理</p></blockquote><ul><li>在<code>props</code>选项中接收父组件传过来的<code>modelValue</code>属性的值</li><li>在<code>emits</code>选项中接收父组件传过来的事件<code>update:modelValue</code></li><li>将<code>modelValue</code>作为<code>v-show</code>指令的值，用来控制<code>.popup</code>元素与<code>.mask</code>元素的显示与隐藏</li><li>点击确认按扭时，在<code>click</code>事件中通过<code>$emit</code>方法来触发<code>update:modelValue</code>方法，实现关闭弹窗</li></ul><pre><code>&lt;script&gt;  export default &#123;    // 1：接受父组件传递的属性    props: [&quot;modelValue&quot;],    // 2：接受父组件传递的事件    emits: [&quot;update:modelValue&quot;],  &#125;;&lt;/script&gt;&lt;template&gt;  &lt;!-- 3: v-show 控制元素显示与隐藏--&gt;  &lt;div class=&quot;popup&quot; v-show=&quot;modelValue&quot;&gt;    &lt;!-- 4：        点击确定按扭，触发update:modelValue事件将modelValue的值更新为false，关闭弹窗       --&gt;    &lt;div class=&quot;close&quot; @click=&quot;$emit(&#39;update:modelValue&#39;, false)&quot;&gt;确认&lt;/div&gt;  &lt;/div&gt;  &lt;!-- 3: v-show 控制元素显示与隐藏--&gt;  &lt;div class=&quot;mask&quot; v-show=&quot;modelValue&quot;&gt;&lt;/div&gt;&lt;/template&gt;</code></pre><h4 id="组件-v-model-参数"><a href="#组件-v-model-参数" class="headerlink" title="组件 v-model 参数"></a>组件 v-model 参数</h4><blockquote><p>默认情况下，<code>v-model</code>底层在组件上绑定的是<code>modelValue</code>属性，并且监听<code>update:modelValue</code>事件。</p></blockquote><ul><li>我们可以通过给<code>v-model</code>指定一个参数来更改绑定的属性名和事件名。</li></ul><pre><code>&lt;Popup v-model:bool=&quot;show&quot; /&gt;</code></pre><ul><li>上面<code>v-model</code>底层绑定的是<code>bool</code>属性，监听的是<code>update:bool</code>事件，如下代码</li></ul><pre><code>&lt;Popup :bool=&quot;show&quot; @update:bool=&quot;(newValue) =&gt; &#123; show = newValue &#125;&quot; /&gt;</code></pre><blockquote><p>代码示例</p><ul><li>在上面弹窗案例的基础上，为<code>v-model</code>指定<code>bool</code>参数，实现效果不变，对应代码修改如下：</li></ul></blockquote><ul><li><code>App.vue</code>中其它代码不变，模板代码修改如下</li></ul><pre><code>&lt;template&gt;  &lt;button @click=&quot;show = true&quot;&gt;显示&lt;/button&gt;  &lt;Popup :bool=&quot;show&quot; @update:bool=&quot;(newValue) =&gt; &#123; show = newValue &#125;&quot; /&gt;  &lt;Popup v-model:bool=&quot;show&quot; /&gt;&lt;/template&gt;</code></pre><ul><li><code>Popup.vue</code>文件中<ul><li>所有<code>modelValue</code>修改成<code>bool</code></li><li>所有<code>update:modelValue</code>修改成<code>update:bool</code></li></ul></li></ul><pre><code>&lt;script&gt;  export default &#123;    // 接受传递的属性与事件    props: [&quot;bool&quot;],    emits: [&quot;update:bool&quot;],  &#125;;&lt;/script&gt;&lt;template&gt;  &lt;div class=&quot;popup&quot; v-show=&quot;bool&quot;&gt;    &lt;div class=&quot;close&quot; @click=&quot;$emit(&#39;update:bool&#39;, false)&quot;&gt;确认&lt;/div&gt;  &lt;/div&gt;  &lt;div class=&quot;mask&quot; v-show=&quot;bool&quot;&gt;&lt;/div&gt;&lt;/template&gt;</code></pre><h4 id="多个-v-model-绑定"><a href="#多个-v-model-绑定" class="headerlink" title="多个 v-model 绑定"></a>多个 v-model 绑定</h4><blockquote><p>通过给<code>v-model</code>指定一个参数可以更改绑定的属性名和事件名，所以我们可以同时为一个组件绑定多个<code>v-model</code></p></blockquote><pre><code>&lt;Popup v-model:bool=&quot;show&quot; v-model:title=&quot;title&quot; /&gt;</code></pre><ul><li>以上代码等价于以下写法</li></ul><pre><code>&lt;Popup  :bool=&quot;show&quot;  @update:bool=&quot;(newValue) =&gt; &#123; show = newValue &#125;&quot;  :title=&quot;title&quot;  @update:title=&quot;(newValue) =&gt; &#123; title = newValue &#125;&quot;/&gt;</code></pre><blockquote><p>我们在之前弹窗的基础之上做了相关优化，在弹出的框中可以输入内容，将输入的内容显示到父组件中</p></blockquote><ul><li><code>App.vue</code>文件内容</li></ul><pre><code>&lt;script&gt;  import Popup from &quot;./components/Popup.vue&quot;;  export default &#123;    data() &#123;      return &#123;        show: false, //        title: &quot;&quot;,      &#125;;    &#125;,    components: &#123;      Popup,    &#125;,  &#125;;&lt;/script&gt;&lt;template&gt;  &lt;button @click=&quot;show = true&quot;&gt;显示&lt;/button&gt;  &lt;div&gt;弹窗输入内容：&#123;&#123; title &#125;&#125;&lt;/div&gt;  &lt;!--     &lt;Popup         :bool=&quot;show&quot;         @update:bool=&quot;(newValue) =&gt; &#123; show = newValue &#125;&quot;         :title=&quot;title&quot;        @update:title=&quot;(newValue) =&gt; &#123; title = newValue &#125;&quot;     /&gt;     --&gt;  &lt;Popup v-model:bool=&quot;show&quot; v-model:title=&quot;title&quot; /&gt;&lt;/template&gt;</code></pre><ul><li><code>Popup.vue</code>文件内容</li></ul><pre><code>&lt;script&gt;  export default &#123;    // 接受传递的属性与事件    props: [&quot;bool&quot;, &quot;title&quot;],    emits: [&quot;update:bool&quot;, &quot;update:title&quot;],  &#125;;&lt;/script&gt;&lt;template&gt;  &lt;div class=&quot;popup&quot; v-show=&quot;bool&quot;&gt;    &lt;textarea      :value=&quot;title&quot;      @input=&quot;$emit(&#39;update:title&#39;, $event.target.value)&quot;    &gt;&lt;/textarea&gt;    &lt;div class=&quot;close&quot; @click=&quot;$emit(&#39;update:bool&#39;, false)&quot;&gt;确认&lt;/div&gt;  &lt;/div&gt;  &lt;div class=&quot;mask&quot; v-show=&quot;bool&quot;&gt;&lt;/div&gt;&lt;/template&gt;&lt;style&gt;&lt;!-- 省略 --&gt;&lt;/style&gt;</code></pre><h4 id="v-model-修饰符"><a href="#v-model-修饰符" class="headerlink" title="v-model 修饰符"></a>v-model 修饰符</h4><blockquote><p><code>v-model</code>指令绑定表单输入元素时可以使用一些内置的修饰符，如：<code>.trim、.number、.lazy</code>。</p><p>在自定义组件上的<code>v-model</code>不支持以上修饰符，但允许我们自定义修饰符</p><ul><li>注意：子组件在<code>props</code>里，<code>modelModifiers</code>或<code>参数Modifiers</code>接收修饰符，像其他非bool类型的<code>props</code>属性一样，如果没传，默认值为<code>undefined</code></li><li>像下面这种情况，需要根据修饰符分情况处理，则要给它一个默认值<code>&#123;&#125;</code></li></ul></blockquote><ul><li>只有修饰符</li></ul><pre><code>&lt;MyComponent v-model.capitalize=&quot;msg&quot; /&gt;</code></pre><ul><li>上面组件<code>v-model</code>上添加的修饰符，在子组件的<code>props</code>选项中通过<code>modelModifiers</code>来接受</li><li><code>modelModifiers</code>属性的值是一个<code>&#123;capitalize:true&#125;</code>对象</li></ul><pre><code>// MyComponent 组件export default &#123;  props: &#123;    // v-model指令的修饰符    modelModifiers: &#123;      //  默认值为一个空对象      default: () =&gt; (&#123;&#125;),    &#125;,  &#125;,  created() &#123;    console.log(this.modelModifiers); //  &#123; capitalize: true &#125;  &#125;,&#125;;</code></pre><ul><li>同时具有修饰符和参数</li></ul><pre><code>&lt;MyComponent v-model:text.capitalize=&quot;msg&quot; /&gt;</code></pre><ul><li>上面组件<code>v-modle</code>上同时添加了参数与修饰符，在子组件中可以通过<code>textModifiers</code>属性在组件内访问到</li><li><code>textModifiers</code>属性的值是一个<code>&#123;capitalize:true&#125;</code>对象</li></ul><pre><code>// MyComponent 组件export default &#123;  props: &#123;    text: String,    // v-model:text 指令的修饰符    textModifiers: &#123;      default: () =&gt; (&#123;&#125;),    &#125;,  &#125;,  created() &#123;    console.log(this.textModifiers);  &#125;,&#125;;</code></pre><h4 id="实战应用：输入内容首字母大写"><a href="#实战应用：输入内容首字母大写" class="headerlink" title="实战应用：输入内容首字母大写"></a>实战应用：输入内容首字母大写</h4><blockquote><p>如果<code>&lt;MyComponent&gt;</code>组件上的<code>v-modle</code>添加<code>capitalize</code>修饰符，则返回的内容首字母大小，否则正常输出</p></blockquote><pre><code>&lt;MyComponent v-model.capitalize=&quot;msg&quot; /&gt;</code></pre><ul><li><code>App.vue</code>组件内容</li></ul><pre><code>&lt;script&gt;import Popup from &quot;./components/Popup.vue&quot;;export default &#123;  data() &#123;    return &#123;      show: false,      text: &quot;sss&quot;,    &#125;;  &#125;,  components: &#123;    Popup,  &#125;,&#125;;&lt;/script&gt;&lt;template&gt;  &lt;button @click=&quot;show = true&quot;&gt;显示&lt;/button&gt;  &lt;div class=&quot;text&quot;&gt;&#123;&#123; text &#125;&#125;&lt;/div&gt;  &lt;Popup v-model:bool=&quot;show&quot; v-model:text.capitalize=&quot;text&quot; /&gt;&lt;/template&gt;</code></pre><ul><li><code>Popup.vue</code>文件内容</li></ul><pre><code>&lt;script&gt;export default &#123;  props: &#123;    bool: Boolean,    text: String,    textModifiers: &#123;      default: () =&gt; (&#123;&#125;),    &#125;,  &#125;,  emits: [&quot;update:bool&quot;, &quot;update:text&quot;],  methods: &#123;    onInput(e) &#123;      let value = e.target.value;      if (this.textModifiers.capitalize) &#123;        value = value.charAt(0).toUpperCase() + value.slice(1);      &#125;      this.$emit(&quot;update:text&quot;, value);    &#125;,  &#125;,&#125;;&lt;/script&gt;&lt;template&gt;  &lt;div class=&quot;mask&quot; v-show=&quot;bool&quot;&gt;&lt;/div&gt;  &lt;div class=&quot;box&quot; v-show=&quot;bool&quot;&gt;    &lt;textarea @input=&quot;onInput&quot; :value=&quot;text&quot; cols=&quot;30&quot; rows=&quot;10&quot;&gt;&lt;/textarea&gt;    &lt;div class=&quot;close&quot; @click=&quot;$emit(&#39;update:bool&#39;, false)&quot;&gt;确定&lt;/div&gt;  &lt;/div&gt;&lt;/template&gt;&lt;style&gt;&lt;!-- 省略 --&gt;&lt;/style&gt;</code></pre><h3 id="十二、透传属性（Attributes）"><a href="#十二、透传属性（Attributes）" class="headerlink" title="十二、透传属性（Attributes）"></a>十二、透传属性（Attributes）</h3><h4 id="透传属性定义"><a href="#透传属性定义" class="headerlink" title="透传属性定义"></a>透传属性定义</h4><blockquote><p>当我们给一个组件传递的<code>Prop</code>或<code>v-on</code>事件监听器，没有出现在该组件的<code>props</code>或<code>emits</code>选项中，那这些<code>Prop</code>和<code>v-on</code>事件监听被称为透传属性（Attributes）。</p></blockquote><ul><li>在<code>App.vue</code>根组件中调用<code>&lt;List /&gt;</code>子组件，并传递了两个<code>Prop</code>和两个<code>v-on</code>事件监听器</li></ul><pre><code>&lt;List :a=&quot;1&quot; :b=&quot;2&quot; @click=&quot;fn&quot; @add-event=&quot;add&quot; /&gt;</code></pre><ul><li>在子组件<code>&lt;List /&gt;</code>中通过<code>props</code>与<code>emits</code>选项来显示声明接受的属性与需要触发的事件</li></ul><pre><code>export default &#123;  props: [&quot;a&quot;],  emits: [&quot;addEvent&quot;],&#125;;</code></pre><ul><li>上面代码中的<code>b</code>属性和<code>@click</code>事件监听器就可称为透传属性（Attributes）。</li><li>因为：<ul><li>传递给子组件<code>&lt;List&gt;</code>的<code>Prop</code>有a，b两个，传递的<code>v-on</code>事件监听器有<code>click</code>,<code>add-event</code>两个。</li><li>但在子组件的<code>props</code>选项中只声明了a，在<code>emits</code>选项中只声明了<code>addEvent</code>，没有声明的b属性和<code>click</code>事件就可以称为透传属性（Attributes）。</li></ul></li></ul><h4 id="单根组件透传属性的继承"><a href="#单根组件透传属性的继承" class="headerlink" title="单根组件透传属性的继承"></a><strong>单根</strong>组件透传属性的继承</h4><blockquote><p>当组件是一个单根组件时，透传的属性（Attributes）会被自动被添加到组件的<strong>根元素</strong>上。相当于根元素自动继承组件的属性。</p><ul><li>温馨提示： 透传属性常用来传递<code>class</code>，<code>style</code>和<code>id</code>这样的属性。</li></ul></blockquote><ul><li>因为很多时候，我们希望把传递给组件的<code>class</code>、<code>style</code>和<code>id</code>能直接应用到组件的根元素上，在某此特殊的需求下，我们可以利用这个特性修改子组件最终呈现的样式。</li></ul><h4 id="透传属性继承的注意事项"><a href="#透传属性继承的注意事项" class="headerlink" title="透传属性继承的注意事项"></a>透传属性继承的注意事项</h4><blockquote><p>如果组件是一个单根组件，透传属性的自动继承有以下两个需要注意的点：</p></blockquote><ul><li>对 <code>class</code> 和 <code>style</code> 的合并</li><li><code>v-on</code> 监听器继承</li></ul><blockquote><p>对 class 和 style 的合并</p></blockquote><ul><li>如果组件的根元素上的属性与透传属性同名，则会以透传属性为主，<strong>覆盖</strong>根元素自身的属性</li><li>但如果组件的根元素上已有属性为<code>class</code>或<code>style</code>，它会和透传属性<code>class</code>或<code>style</code>的值进行<strong>合并</strong></li></ul><pre><code>&lt;!--父组件中调用子组件List--&gt;&lt;List :class=&quot;&#123; active: true &#125;&quot; :style=&quot;&#123; color: color &#125;&quot; title=&quot;透传属性&quot; /&gt;&lt;!--以下为List子组件根元素,在List组件的props选项中没有声明 class  style  title--&gt;&lt;div class=&quot;list&quot; style=&quot;&#123;font-size:&#39;30px&#39;&#125;&quot; title=&quot;组件自身属性&quot;&gt;  List组件，是一个单根组件&lt;/div&gt;</code></pre><ul><li>以上代码最终渲染效果如下</li></ul><pre><code>&lt;div class=&quot;list active&quot; style=&quot;color: red;&quot; title=&quot;透传属性&quot;&gt;  List组件，是一个单根组件&lt;/div&gt;</code></pre><blockquote><p>v-on 监听器继承</p></blockquote><ul><li>如果组件的根元素自身通过<code>v-on</code>绑定了一个与透传的<code>v-on</code>同名的事件监听器，则最终两个事件监听器<strong>都会被触发</strong>。</li></ul><pre><code>&lt;!--父组件中调用子组件List--&gt;&lt;List @click=&quot;fn&quot; /&gt;&lt;!--以下为List子组件根元素,在List组件的emits选项中没有声明 click--&gt;&lt;div @click=&quot;add&quot;&gt;List组件，是一个单根组件&lt;/div&gt;</code></pre><ul><li>以上代码，在点击div元素时，两个事件监听都会触发，即fn与add两个方法都会被调用</li></ul><h4 id="禁用透传属性自动继承"><a href="#禁用透传属性自动继承" class="headerlink" title="禁用透传属性自动继承"></a>禁用透传属性自动继承</h4><blockquote><p>在某些场景下我们并不希望透传属性自动继承到单根组件的根元素上，而是想把透传的属性按需要添加到<strong>根节点以外</strong>的其他元素上，这时我们就需要禁用透传属性的自动继承行为。</p></blockquote><ul><li>你只需要在子组件中添加以下<code>inheritAttrs: false</code>配置，这样透传属性就不会自动继承到根元素上。</li></ul><pre><code>&lt;script&gt;  export default &#123;    inheritAttrs: false, // 禁用透传属性的自动继承  &#125;;&lt;/script&gt;&lt;template&gt;  &lt;div&gt;List组件，是一个单根组件&lt;/div&gt;&lt;/template&gt;</code></pre><ul><li>那我们如何访问到透传进来的所有属性呢 ？这就需要用到<code>$attr</code>属性，接下来我们就来学习下<code>$attr</code>属性。</li></ul><h4 id="attr-属性"><a href="#attr-属性" class="headerlink" title="$attr 属性"></a>$attr 属性</h4><ol><li>$attr 属性的使用方法<blockquote><p>如果我们想在一个组件中访问到所有透传的属性，可以通过以下两种方式来实现</p></blockquote></li></ol><ul><li>在子组件的模板表达式中，你可以直接使用<code>$attrs</code>对象访问到所有透传的属性。</li></ul><pre><code>&lt;!--通过 $attrs.class 和 $attrs.style 访问透传属性class与style--&gt;&lt;div :class=&quot;$attrs.class&quot; :style=&quot;$attrs.style&quot;&gt;&lt;/div&gt;</code></pre><ul><li>在 JS 中你可以通过子组件实例的<code>this.$attrs</code>方法来访问所有透传的属性。</li></ul><pre><code>export default &#123;  beforeCreate() &#123;    console.log(&quot;class&quot;, this.$attrs.class); // 访问透传属性 class    console.log(&quot;style&quot;, this.$attrs.style); // 访问透传属性 style  &#125;,&#125;;</code></pre><ul><li>不管子组件中是否添加<code>inheritAttrs: false</code>选项，<code>$attrs</code>属性都可以访问到所有的透传属性</li></ul><ol start="2"><li>$attrs 属性的注意事项</li></ol><ul><li>与<code>props</code>有所不同，透传属性在 JS 中<strong>保留了它们原始的大小写</strong>，所以在父组件中通过<code>kebab-case</code>方式命名的属性，需要通过<code>$attrs[&quot;kebab-case&quot;]</code>形式来访问。</li><li>所有<code>v-on</code>绑定的事件监听器，在<code>$attrs</code>对象下被暴露为一个函数。如果父组件中添加<code>@add-event=&#39;add&#39;</code>事件监听听，在<code>$attrs</code>对象上要通过<code>$attrs.onAdd</code>形式来访问</li></ul><h4 id="多根组件透传属性的继承"><a href="#多根组件透传属性的继承" class="headerlink" title="多根组件透传属性的继承"></a><strong>多根</strong>组件透传属性的继承</h4><blockquote><p>和单根组件有所不同，多根组件的透传属性不会自动继承到组件的根元素上，所以我们需要显示绑定<code>$attrs</code></p></blockquote><ul><li>如果<code>$attrs</code>没有显示绑定，会在控制台将会抛出警告，因为根元素有多个，Vue 不知道要将透传属性放到那个元素上。</li></ul><pre><code>&lt;List data-title=&quot;新闻标题&quot; :data-num=&quot;1&quot; /&gt;</code></pre><ul><li>如果<code>&lt;List&gt;</code>组件中的模板内容如下，则会在控制台抛出错误，因为没有显示绑定<code>$attrs</code></li></ul><pre><code>&lt;template&gt;  &lt;h3&gt;.....&lt;/h3&gt;  &lt;div&gt;.....&lt;/div&gt;&lt;/template&gt;</code></pre><ul><li>如果<code>&lt;List&gt;</code>组件中的模板内容如下，则不会在控制台抛出错误提示，因为显示绑定了<code>$attrs</code></li></ul><pre><code>&lt;template&gt;  &lt;h3&gt;.....&lt;/h3&gt;  &lt;div v-bind=&quot;$attrs&quot;&gt;.....&lt;/div&gt;   &lt;!--以上写法为以下写法的简写--&gt;  &lt;!--     &lt;div :title=&quot;$attrs[&#39;data-title&#39;]&quot; :num=&quot;$attrs[&#39;data-num&#39;]&quot;&gt;    .....    &lt;/div&gt;     --&gt;&lt;/template&gt;</code></pre><h4 id="深层组件继承"><a href="#深层组件继承" class="headerlink" title="深层组件继承"></a>深层组件继承</h4><blockquote><p>有些情况下一个组件会在根节点上渲染另一个组件，如下：</p></blockquote><pre><code>&lt;!--以为下为List组件，在List组件中，只是渲染另一个组件 &lt;Item/&gt;--&gt;&lt;template&gt;  &lt;List /&gt;&lt;/template&gt;</code></pre><ul><li>此时，<code>&lt;List&gt;</code>组件接收的透传属性会直接继承传给<code>&lt;Item/&gt;</code>组件</li></ul>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Vue </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Vue（二）</title>
      <link href="/2024/01/22/Vue%EF%BC%88%E4%BA%8C%EF%BC%89/"/>
      <url>/2024/01/22/Vue%EF%BC%88%E4%BA%8C%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<span id="more"></span><h3 id="一、模板语法"><a href="#一、模板语法" class="headerlink" title="一、模板语法"></a>一、模板语法</h3><blockquote><p>Vue 使用一种基于 HTML 的模板语法，使我们能够<strong>声明式</strong>地将其<strong>组件实例的数据</strong>绑定到呈现的 DOM 上。</p><ul><li>最基本的数据绑定形式是文本插值，其次是内置的指令。</li></ul></blockquote><h4 id="文本插值"><a href="#文本插值" class="headerlink" title="文本插值"></a>文本插值</h4><blockquote><p>文本插值语法，使用的是 “Mustache” 语法（即双大括号）</p></blockquote><pre><code>&lt;div&gt;&#123;&#123;message&#125;&#125;&lt;/div&gt;</code></pre><ul><li>以上代码中<code>&#123;&#123;&#125;&#125;</code>语法，最终会被替换为对应组件实例中 <code>message</code>属性的值。同时每次<code>message</code>属性值更改时，页面也会同步更新。</li></ul><pre><code>&lt;script&gt;  export default &#123;    data() &#123;      return &#123;        message: &quot;Hello Vue&quot;,      &#125;;    &#125;,  &#125;;&lt;/script&gt;&lt;template&gt;  &lt;div&gt;&#123;&#123; message &#125;&#125;&lt;/div&gt;&lt;/template&gt;</code></pre><p>渲染后，对应 HTML 代码如下</p><pre><code>&lt;div&gt;Hello Vue&lt;/div&gt;</code></pre><ol><li>文本插值使用范围<blockquote><p>文本插值用于解析标签体内容，所以只能出现在<strong>标签体内</strong>。</p></blockquote></li></ol><pre><code>&lt;!--以下写法是错误的 ， 因为文本插值语法出现在标签属性中--&gt;&lt;div title=&quot;&#123;&#123;message&#125;&#125;&quot;&gt;&lt;/div&gt;</code></pre><ul><li>代码演示</li></ul><pre><code>&lt;script&gt;export default &#123;  data() &#123;    return &#123;      message: &quot;Hello Vue&quot;,    &#125;;  &#125;,&#125;;&lt;/script&gt;&lt;template&gt;  &lt;div title=&quot;&#123;&#123; message &#125;&#125;&quot;&gt;&#123;&#123; message &#125;&#125;&lt;/div&gt;&lt;/template&gt;</code></pre><ul><li>渲染后，对应 HTML 代码如下</li></ul><pre><code>&lt;div title=&quot;&#123;&#123;message&#125;&#125;&quot;&gt;Hello Vue&lt;/div&gt;</code></pre><ul><li>注：我们发现title属性中的并没有被解析，而是原样输出了。</li><li>要动态绑定一个属性值，需要用到<code>v-bind</code>指令，后面会讲到</li></ul><ol start="2"><li>绑定数据格式</li></ol><ul><li><code>&#123;&#123;&#125;&#125;</code>中绑定的数据只支持<strong>单一表达式</strong>，也就是一段能够被求值的 <code>JavaScript</code> 代码</li><li>是否为单一表达式，最简单的判断方法是，是否可以合法地写在 <code>return</code> 后面<blockquote><ul><li>以下写法，都可以看做是一个单一表达式</li></ul></blockquote></li></ul><pre><code>&lt;!-- message是一个变量 --&gt;&lt;div&gt;&#123;&#123; message &#125;&#125;&lt;/div&gt;&lt;!--a + b 数学运算 或 1 &gt; 2 --&gt;&lt;div&gt;&#123;&#123; a + b &#125;&#125;&lt;/div&gt;&lt;!-- fn() 函数调用 --&gt;&lt;div&gt;&#123;&#123; fn() &#125;&#125;&lt;/div&gt;&lt;!--三元表达式 --&gt;&lt;div&gt;&#123;&#123; ok ? 'YES' : 'NO' &#125;&#125;&lt;/div&gt;&lt;!--对象.方法()--&gt;&lt;div&gt;&#123;&#123; message.split('').reverse().join('') &#125;&#125;&lt;/div&gt;</code></pre><blockquote><ul><li>以下写法，不是表达式，是属于<code>JS</code>语句，不能出现在<code>&#123;&#123;&#125;&#125;</code>中</li></ul></blockquote><pre><code>if()&#123;&#125;for(var i=0;i&lt;5;i++)&#123;&#125;switch()&#123; &#125;</code></pre><ol start="3"><li>受限的全局访问</li></ol><ul><li>在模板中，通过文本插值<code>&#123;&#123;&#125;&#125;</code>，还可以访问一些全局对象，如：<code>Math</code>、<code>Date</code>、<code>RegExp</code> ……</li><li>点击<a href="https://github.com/vuejs/core/blob/main/packages/shared/src/globalsAllowList.ts#L3">有限的全局对象列表</a>，可以查看到哪些全局对象我们可以在<code>&#123;&#123;&#125;&#125;</code>中访问，</li></ul><pre><code>&#39;Infinity,undefined,NaN,isFinite,isNaN,parseFloat,parseInt,decodeURI,&#39; +  &#39;decodeURIComponent,encodeURI,encodeURIComponent,Math,Number,Date,Array,&#39; +  &#39;Object,Boolean,String,RegExp,Map,Set,JSON,Intl,BigInt,console&#39;</code></pre><blockquote><ul><li>这里都是可以在<code>&#123;&#123;&#125;&#125;</code>中访问的</li></ul></blockquote><ul><li>代码演示</li></ul><pre><code>&lt;!-- 显示日期 结果：当前日期 --&gt;&lt;div&gt;&#123;&#123; new Date() &#125;&#125;&lt;/div&gt;&lt;!-- 开平方 结果： 2--&gt;&lt;div&gt;&#123;&#123; Math.sqrt(4) &#125;&#125;&lt;/div&gt;&lt;!-- 正则测试，结果：true--&gt;&lt;div&gt;&#123;&#123; /^\d&#123;5&#125;$/.test("12345") &#125;&#125;&lt;/div&gt;</code></pre><ol start="4"><li>访问自定义全局属性</li></ol><ul><li><code>app.config.globalProperties</code>一个用于注册能够被应用内所有组件实例访问到的全局属性的对象</li><li>在模板中，通过文本插值<code>&#123;&#123;&#125;&#125;</code>可以访问到全局属性</li></ul><pre><code>// 注册自定义全局属性app.config.globalProperties.username = &quot;hermia&quot;;</code></pre><ul><li>在<code>main.js</code>中通过<code>app.config.globalProperties.username</code>添加全局<code>username</code>属性</li></ul><pre><code>import &#123; createApp &#125; from &quot;vue&quot;;import App from &quot;./App.vue&quot;;const app = createApp(App);app.config.globalProperties.username = &quot;hermia&quot;;app.mount(&quot;#app&quot;);</code></pre><ul><li>在<code>App.vue</code>文件的模板中，可以使用文本插值访问该属性值，如下：</li></ul><pre><code>&lt;template&gt;  &lt;div&gt;&#123;&#123; username &#125;&#125;&lt;/div&gt;&lt;/template&gt;</code></pre><ul><li>渲染后，对应 HTML 代码如下：</li></ul><pre><code>&lt;div&gt;her&lt;/div&gt;</code></pre><ol start="5"><li>总结：文本插值</li></ol><ul><li>在 Vue 模板中，需要访问到组件实例属性，可以采用文本插值 <code>&#123;&#123;&#125;&#125;</code>语法</li><li>文本插值使用范围<ul><li>文本插值语法用于解析标签体内容，所以<code>&#123;&#123;&#125;&#125;</code>只能出现在标签体内，出现在其它地方不会被解析</li></ul></li><li>绑定数据格式<ul><li>文本插值<code>&#123;&#123;&#125;&#125;</code>大括号中只支持单一的 JS 表达式</li><li>判断是否为单一表达式，最简单的方法是，是否可以合法地写在 <code>return</code> 后面</li></ul></li><li>在文本插值<code>&#123;&#123;&#125;&#125;</code>中可以访问到以下内容<ul><li>组件实例属性</li><li>有限的全局对象</li><li>自定义全局属性</li></ul></li></ul><h4 id="指令语法"><a href="#指令语法" class="headerlink" title="指令语法"></a>指令语法</h4><ul><li>在 Vue 中，指令是带有<code>v-</code>前缀的特殊<code>attribute</code>（属性）</li><li>Vue 提供了许多内置指令，如：<code>v-bind</code>、<code>v-model</code>、<code>v-html</code>、<code>v-text</code>、<code>v-on</code>、<code>v-if</code>、<code>v-show</code>、<code>v-for</code>等。</li></ul><h4 id="v-bind-指令"><a href="#v-bind-指令" class="headerlink" title="v-bind 指令"></a>v-bind 指令</h4><blockquote><p><code>v-bind</code>指令，用于动态的绑定一个 或 多个属性</p></blockquote><pre><code>&lt;div v-bind:title=&quot;message&quot;&gt;&lt;/div&gt;</code></pre><ul><li>以上<code>v-bind</code>命令指示 Vue 将div元素的<code>title</code>属性值与组件的<code>message</code>属性值保持一致</li><li>如果<code>message</code>的值是 <code>null</code> 或者 <code>undefined</code>，那么title属性将会从渲染的元素上<strong>移除</strong><br>代码演示</li></ul><pre><code>&lt;script&gt;export default &#123;  data() &#123;    return &#123;      message: &quot;Hello Vue&quot;,      id: null,    &#125;;  &#125;,&#125;;&lt;/script&gt;&lt;template&gt;  &lt;div v-bind:title=&quot;message&quot; v-bind:id=&quot;id&quot;&gt;&#123;&#123; message &#125;&#125;&lt;/div&gt;&lt;/template&gt;</code></pre><ul><li>最终渲染后生成的 HTML 代码如下：</li></ul><pre><code>&lt;div title=&quot;Hello Vue&quot;&gt;Hello Vue&lt;/div&gt;因为id属性的值为 null，所以该属性最终不会出现在渲染的元素上。</code></pre><ol><li>v-bind 简写<blockquote><p>v-bind的应用非常多，所以官方为<code>v-bind</code>提供了特定的简写语法</p></blockquote></li></ol><ul><li>如：<code>v-bind:title=&quot;&quot;</code>简写为<code>:title=&quot;&quot;</code></li></ul><pre><code>&lt;div v-bind:title=&quot;message&quot;&gt;&lt;/div&gt;&lt;!-- 以上 v-bind:title 简写成 :title --&gt;&lt;div :title=&quot;message&quot;&gt;&lt;/div&gt;</code></pre><ol start="2"><li>v-bind 绑定布尔型属性<blockquote><p>如果元素原生支持某些布尔类型的属性，<code>v-bind</code>针对布尔类型属性，依据<code>true / false</code>值来决定属性是否应该存在于该元素上</p><p>如果不是元素原生支持的，则<code>v-bind</code>绑定的自定义属性的值为布尔类型，则正常显示该布尔值。</p></blockquote></li></ol><pre><code>&lt;!--isButtonDisabled属性的值，如果为false 表示移除这个属性，true表示按扭禁用 --&gt;&lt;button :disabled=&quot;isButtonDisabled&quot;&gt;Button&lt;/button&gt;&lt;!--isChecked属性的值，如果为false表示不选中，true表示选中--&gt;&lt;input type=&quot;checkbox&quot; :checked=&quot;isChecked&quot; /&gt;&lt;!--isInputDisable属性的值，如果为false表示可输入，true表示禁用，不能输入--&gt;&lt;input type=&quot;text&quot; :disabled=&quot;isInputDisabled&quot; /&gt;</code></pre><ul><li>代码演示</li></ul><pre><code>&lt;script&gt;export default &#123;  data() &#123;    return &#123;      isButtonDisabled: false,      isChecked: true,      isInputDisabled: true,      bool: true,    &#125;;  &#125;,&#125;;&lt;/script&gt;&lt;template&gt;  &lt;!--原生支持的布尔类型属性--&gt;  &lt;button :disabled=&quot;isButtonDisabled&quot;&gt;Button&lt;/button&gt;  &lt;input type=&quot;checkbox&quot; :checked=&quot;isChecked&quot; /&gt;  &lt;input type=&quot;text&quot; :disabled=&quot;isInputDisabled&quot; /&gt;  &lt;!--自定义布尔类型属性--&gt;  &lt;div :bool=&quot;bool&quot;&gt;&lt;/div&gt;&lt;/template&gt;</code></pre><ul><li>扩展知识：<ul><li>如果元素的某个自定义属性是布尔属性，则一般会采用如下简写<code>&lt;div bool&gt;&lt;/div&gt;</code>表示有bool属性，<code>&lt;div&gt;&lt;/div&gt;</code>表示没有bool属性</li></ul></li></ul><ol start="3"><li>v-bind 动态绑定多个属性<blockquote><p>如果你有像这样的一个包含多个属性的 JavaScript 对象</p></blockquote></li></ol><pre><code>data() &#123;  return &#123;    objectOfAttrs: &#123;      id: &#39;container&#39;,      class: &#39;wrapper&#39;    &#125;  &#125;&#125;</code></pre><blockquote><p>可以通过不带参数的<code>v-bind</code>，将他们一次性绑定到某个元素上。</p></blockquote><pre><code>&lt;div v-bind=&quot;objectOfAttrs&quot;&gt;&lt;/div&gt;</code></pre><blockquote><p>以<code>v-bind</code>绑定方式，编译后的 html 结构如下：</p></blockquote><pre><code>&lt;div id=&quot;container&quot; class=&quot;wrapper&quot;&gt;&lt;/div&gt;</code></pre><ol start="4"><li>绑定数据格式</li></ol><ul><li><code>v-bind</code>绑定的数据格式与上面提到的文本插值<code>&#123;&#123;&#125;&#125;</code>是一样，只支持<strong>单一表达式</strong></li><li>大部分指令属性后面的期望值是为一个表达式（除了少数几个例外，如：<code>v-for</code>、<code>v-on</code>、<code>v-slot</code>）</li></ul><pre><code>&lt;div :title=&quot;1 + 3&quot; :data-date=&quot;new Date().getTime()&quot;&gt;&lt;/div&gt;&lt;button :disabled=&quot;3 &gt; 2 ? true : false&quot;&gt;提交&lt;/button&gt;</code></pre><ol start="5"><li>动态参数</li></ol><ul><li><code>v-bind</code>:后面跟着的标识，我们管他叫指令的参数，比如上面提到<code>title</code>, <code>id</code>, <code>class</code>属性都可以看做是参数。</li><li>如果需要动态指定参数，则需要把参数放在一对方括号内，方括内可以使用一个 JS 表达式，表达式最终返回一个值。</li></ul><pre><code>&lt;a v-bind:[attributeName]=&quot;url&quot;&gt; ... &lt;/a&gt;&lt;!--简写--&gt;&lt;a :[attributeName]=&quot;url&quot;&gt; ... &lt;/a&gt;</code></pre><ul><li><code>App.vue</code>文件内容如下</li></ul><pre><code>&lt;script&gt;export default &#123;  data() &#123;    return &#123;      attributeName: &quot;href&quot;,      url: &quot;http://www.icoding.com&quot;,    &#125;;  &#125;,&#125;;&lt;/script&gt;&lt;template&gt;  &lt;a :[attributeName]=&quot;url&quot;&gt;艾编程&lt;/a&gt;&lt;/template&gt;</code></pre><ul><li>编译成后，生成如下 HTML，插入到<code>#app</code>容器中</li></ul><pre><code>&lt;a href=&quot;http://www.icoding.com&quot;&gt;艾编程&lt;/a&gt;</code></pre><ol start="6"><li>动态参数注意事项</li></ol><ul><li>动态参数值的限制<ul><li>动态参数中表达式的值应当是一个字符串，或者是<code>null</code>。特殊值<code>null</code>意为显式移除该绑定。其他非字符串的值会触发警告。</li></ul></li><li>以下代码是不合法的，会抛出一个错误，因为参数中表达式的值是一个数字类型。</li></ul><pre><code>&lt;script&gt;  export default &#123;    data() &#123;      return &#123;        attributeName: 123,        url: &quot;http://www.icoding.com&quot;,      &#125;;    &#125;,  &#125;;&lt;/script&gt;&lt;template&gt;  &lt;a :[attributeName]=&quot;url&quot;&gt;艾编程&lt;/a&gt;&lt;/template&gt;</code></pre><ul><li>动态参数语法的限制<ul><li>动态参数表达式因为某些字符的缘故有一些语法限制，比如空格和引号，在<code>HTML attribute</code>名称中都是不合法的。例如下面的示例：</li></ul></li></ul><pre><code>&lt;!-- 以下写法都会抛出一个编译器警告 --&gt;&lt;a :[&#39;foo&#39; + bar]=&quot;value&quot;&gt; ... &lt;/a&gt;</code></pre><blockquote><ul><li>如果你需要传入一个复杂的动态参数，推荐使用<strong>计算属性</strong>替换复杂的表达式，也是 Vue 最基础的概念之一，我们很快就会讲到。</li></ul></blockquote><ol start="7"><li>总结：v-bind 指令<blockquote><p>v-bind 指令用于动态绑定一个或多个属性，v-bind指令的可以简写成<code>:</code></p></blockquote></li></ol><ul><li><code>v-bind</code>绑定属性的值为<code>null</code>，最终该属性不会出现在元素上</li><li><code>v-bind</code>针对原生布尔类型属性， 依据<code>true / false</code>值来决定属性是否应该存在于该元素上</li><li><code>v-bind</code>绑定数据格式只支持<strong>单一表达式</strong></li><li><code>v-bind</code>指令可以动态指定参数，参数支持单一表达式，但有以下两个限制<ul><li>动态参数中表达式的值应当是一个字符串，或者是<code>null</code></li><li>动态参数表达式因为某些字符的缘故有一些语法限制，比如<strong>空格</strong>和<strong>引号</strong></li></ul></li></ul><h3 id="二、事件处理-与-methods"><a href="#二、事件处理-与-methods" class="headerlink" title="二、事件处理 与 methods"></a>二、事件处理 与 methods</h3><h4 id="监听事件"><a href="#监听事件" class="headerlink" title="监听事件"></a>监听事件</h4><blockquote><p>我们可以使用<code>v-on</code>指令（简写为<code>@</code>）来监听 DOM 事件，并在事件触发时执行对应的 JavaScript。<br>用法：</p><ul><li>监听事件：<code>v-on:click=&quot;handler&quot;</code>或<code>@click=&quot;handler&quot;</code></li><li><code>handler</code>为事件处理器，事件触发后，就会触发事件处理器来执行 JS 代码</li></ul></blockquote><pre><code>&lt;script&gt;  export default &#123;    data() &#123;      return &#123;        count: 0,      &#125;;    &#125;,  &#125;;&lt;/script&gt;&lt;template&gt;  &lt;div&gt;&#123;&#123; count &#125;&#125;&lt;/div&gt;  &lt;!-- 点击按扭，属性 count 的值加1 --&gt;  &lt;button v-on:click=&quot;count++&quot;&gt;Add 1&lt;/button&gt;  &lt;button @click=&quot;count++&quot;&gt;Add 1&lt;/button&gt;&lt;/template&gt;</code></pre><h4 id="事件处理器"><a href="#事件处理器" class="headerlink" title="事件处理器"></a>事件处理器</h4><blockquote><p>事件处理器（handler）的值可以是：</p></blockquote><ul><li>内联事件处理器：事件被触发时执行的内联 JavaScript 语句</li><li>方法事件处理器：一个指向组件上定义的方法的属性名或是路径（如：<code>obj.fn</code>）</li></ul><ol><li>内联事件处理器<blockquote><p>当我们在触发事件时，只需要执行一些简单的 JS 语句时，可以采用内联事件处理器</p></blockquote></li></ol><pre><code>&lt;script&gt;export default &#123;  data() &#123;    return &#123;      count: 0,      isShow: true,    &#125;;  &#125;,&#125;;&lt;/script&gt;&lt;template&gt;  &lt;!-- 点击按扭 count+1 --&gt;  &lt;button @click=&quot;count++&quot;&gt;Add 1&lt;/button&gt;  &lt;p&gt;Count is: &#123;&#123; count &#125;&#125;&lt;/p&gt;  &lt;!-- 点击按扭，对isShow属性值取反 false变true，true变false--&gt;  &lt;button @click=&quot;isShow = !isShow&quot;&gt;&#123;&#123; isShow &#125;&#125;&lt;/button&gt;&lt;/template&gt;</code></pre><ul><li>效果<blockquote><ul><li>点击第一个<code>button</code>按扭时，会执行<code>count++</code></li><li>点击第二个按扭时，会对变量<code>isShow</code>的值取反</li></ul></blockquote></li></ul><ol start="2"><li>方法事件处理器<blockquote><p>方法事件处理器：一个指向组件上定义的方法的属性名或路径</p></blockquote></li></ol><pre><code>&lt;script&gt;export default &#123;  data() &#123;    return &#123;      state: &#123;        show() &#123;          console.log(&quot;Hello Vue3!!&quot;);        &#125;,      &#125;,    &#125;;  &#125;,  // methods选项  methods: &#123;    // 这里的方法，可以直接在模板中使用    sayHello() &#123;      console.log(&quot;Hello Vue&quot;);    &#125;,  &#125;,&#125;;&lt;/script&gt;&lt;template&gt;  &lt;!--方法事件处理器:  指向组件上定义的方法的属性名--&gt;  &lt;button class=&quot;box&quot; @click=&quot;sayHello&quot;&gt;sayHello&lt;/button&gt;  &lt;!-- 方法事件处理器: 指向路径 --&gt;  &lt;button @click=&quot;state.show&quot;&gt;show&lt;/button&gt;&lt;/template&gt;</code></pre><ul><li>效果<blockquote><ul><li>当点击<code>sayHello</code>按扭时，会触发<code>click</code>事件，然后执行<code>methods</code>选项中的<code>sayHello</code>方法。</li><li>当点击<code>show</code>按扭时，会触发<code>click</code>事件，然后执行<code>state.show</code>方法</li></ul></blockquote></li></ul><h4 id="methods-方法"><a href="#methods-方法" class="headerlink" title="methods 方法"></a>methods 方法</h4><blockquote><p><code>methods</code>方法，用于声明要混入到组件实例中的方法</p></blockquote><ul><li><p>声明的方法可以直接通过<strong>组件实例访问</strong>，或者在<strong>模板语法表达式</strong>中使用。</p></li><li><p>声明的方法（非箭头函数）内部的<code>this</code>指向为组件实例。</p></li><li><p>即：<code>methods</code>选项中声明的方法内可以通<code>this.属性</code>的方式，访问<code>methods</code>选项中的其它方法和<code>data</code>方法返回对象中的属性</p><blockquote><p>注意</p><ul><li><code>methods</code>选项中声明的方法时避免使用箭头函数，因为它们不能通过 <code>this</code> 访问组件实例。</li></ul></blockquote></li><li><p>代码演示</p></li></ul><pre><code>&lt;script&gt;export default &#123;  data() &#123;    return &#123;      message: &quot;Hello Vue&quot;,    &#125;;  &#125;,  // 组件实例需要用到的方法在methods选项中声明  methods: &#123;    showMessage() &#123;      return this.message;    &#125;,    sayHello() &#123;      // this指向组件实例      console.log(this);      // 访问 data中属性      console.log(this.message);      // 访问methods中声明的方法      console.log(this.sshoMessage());    &#125;,  &#125;,&#125;;&lt;/script&gt;&lt;template&gt;  //在模板语法表达式中使用  &lt;div&gt;&#123;&#123; showMessage() &#125;&#125;&lt;/div&gt;  &lt;div class=&quot;box&quot; @click=&quot;sayHello&quot;&gt;&lt;/div&gt;&lt;/template&gt;&lt;style&gt;.box &#123;  width: 100px;  height: 100px;  background-color: skyblue;&#125;&lt;/style&gt;</code></pre><h4 id="区分方法与内联事件处理器"><a href="#区分方法与内联事件处理器" class="headerlink" title="区分方法与内联事件处理器"></a>区分方法与内联事件处理器</h4><blockquote><p>Vue 内部模板编译器会通过检查<code>v-on</code>的值来断定是何种形式的事件处理器。</p></blockquote><ul><li>值是合法的 JS 标识符或属性访问路径，会被视为<strong>方法</strong>事件处理器，如：<code>foo</code>、<code>foo.bar</code> 和 <code>foo[&#39;bar&#39;]</code></li><li>值不是合法标识符，会被视为<strong>内联</strong>事件处理器，如：而 <code>foo()</code> 和 <code>count++</code></li></ul><pre><code>&lt;!--方法事件处理器--&gt;&lt;div class=&quot;box&quot; @click=&quot;sayHello&quot;&gt;&lt;/div&gt;&lt;!--内联事件处理器--&gt;&lt;div class=&quot;box&quot; @click=&quot;sayHello()&quot;&gt;&lt;/div&gt;</code></pre><h4 id="内联事件处理器中访问-event-事件对象"><a href="#内联事件处理器中访问-event-事件对象" class="headerlink" title="内联事件处理器中访问 event 事件对象"></a>内联事件处理器中访问 event 事件对象</h4><blockquote><p>有时我们需要在内联事件处理器中访问原生 DOM 事件，你可以向该处理器方法传入一个特殊的<code>$event</code>变量。</p></blockquote><pre><code>&lt;div class=&quot;box box1&quot; @click=&quot;print(`$event为事件对象`, $event)&quot;&gt;&lt;/div&gt;</code></pre><blockquote><p>注：</p><ul><li><code>$event</code>变量，相当于原生事件处理函数中的第一个参数<code>event</code>（事件对象）</li><li><code>$evnet</code>变量的书写位置没要求，但名字是固定的。</li></ul></blockquote><ul><li>代码演示</li></ul><pre><code>&lt;script&gt;  export default &#123;    methods: &#123;      print(message, event) &#123;        // event 为原生的JS事件对象        console.log(message, event);        // event.target 触发事件的目标元素        console.log(&quot;触发事件的目标元素&quot;, event.target);      &#125;,    &#125;,  &#125;;&lt;/script&gt;&lt;template&gt;  &lt;div class=&quot;box&quot; @click=&quot;print(`鼠标事件对象`, $event)&quot;&gt;&lt;/div&gt;&lt;/template&gt;&lt;style&gt;  .box &#123;    width: 100px;    height: 100px;    background-color: skyblue;  &#125;&lt;/style&gt;</code></pre><h4 id="方法事件处理器中访问-event-事件对象"><a href="#方法事件处理器中访问-event-事件对象" class="headerlink" title="方法事件处理器中访问 event 事件对象"></a>方法事件处理器中访问 event 事件对象</h4><blockquote><p>对于方法事件处理器，处理器方法默认会把event事件对象作为方法的第一个参数传入</p></blockquote><pre><code>&lt;!-- print 方法调用后，他的第一个参数就是evnet事件对象--&gt;&lt;div class=&quot;box box1&quot; @click=&quot;print&quot;&gt;&lt;/div&gt;</code></pre><ul><li>代码演示</li></ul><pre><code>&lt;script&gt;  export default &#123;    methods: &#123;      print(event) &#123;        // event 为原生的JS事件对象        console.log(event);        // event.target 触发事件的目标元素        console.log(&quot;触发事件的目标元素&quot;, event.target);      &#125;,    &#125;,  &#125;;&lt;/script&gt;&lt;template&gt;  &lt;div class=&quot;box&quot; @click=&quot;print&quot;&gt;&lt;/div&gt;&lt;/template&gt;&lt;style&gt;  .box &#123;    width: 100px;    height: 100px;    background-color: skyblue;  &#125;&lt;/style&gt;</code></pre><h4 id="事件绑定对象写法"><a href="#事件绑定对象写法" class="headerlink" title="事件绑定对象写法"></a>事件绑定对象写法</h4><blockquote><p>如果我们想在一个元素上绑定多个事件，我们可以写多个<code>v-on</code>或<code>@</code>来监听不同事件</p></blockquote><pre><code>&lt;!-- 普通写法，绑定多个事件 --&gt;&lt;div @click=&quot;scale&quot; @mouseover=&quot;bgcolor&quot;&gt;&lt;/div&gt;也可以采用如下对象的写法&lt;!-- 对象语法  绑定多个事件 click与 mouseover事件--&gt;&lt;div v-on=&quot;&#123; click: scale, mouseover: bgcolor &#125;&quot;&gt;&lt;/div&gt;</code></pre><blockquote><p>注意：</p><ul><li>当使用对象语法时，不支持后面讲的任何事件修饰符</li></ul></blockquote><ul><li>代码演示</li></ul><pre><code>&lt;script&gt;export default &#123;  methods: &#123;    scale(e) &#123;      e.target.style.transform = &quot;scale(1.2)&quot;;    &#125;,    bgcolor(e) &#123;      e.target.style.backgroundColor = &quot;red&quot;;    &#125;,  &#125;,&#125;;&lt;/script&gt;&lt;template&gt;  &lt;!-- 普通写法，绑定多个事件 --&gt;  &lt;div class=&quot;box&quot; @click=&quot;scale&quot; @mouseover=&quot;bgcolor&quot;&gt;&lt;/div&gt;  &lt;!-- 对象语法，绑定多个事件 --&gt;  &lt;div class=&quot;box&quot; v-on=&quot;&#123; click: scale, mouseover: bgcolor &#125;&quot;&gt;&lt;/div&gt;&lt;/template&gt;&lt;style&gt;.box &#123;  width: 100px;  height: 100px;  margin: 50px;  background-color: skyblue;&#125;&lt;/style&gt;</code></pre><h4 id="鼠标-事件修饰符"><a href="#鼠标-事件修饰符" class="headerlink" title="(鼠标)事件修饰符"></a>(鼠标)事件修饰符</h4><blockquote><p>Vue 为<code>v-on</code>指令提供了事件修饰符，修饰符帮我们处理了许多 DOM 事件的细节，让我们有更多的精力专注于数据的逻辑处理。</p></blockquote><ul><li><p>修饰符是用 <code>.</code> 表示的指令后缀，事件修饰符包含以下这些：</p><table><thead><tr><th>事件修饰符</th><th>说明</th></tr></thead><tbody><tr><td>.stop</td><td>阻止事件冒泡</td></tr><tr><td>.prevent</td><td>阻止事件的默认行为</td></tr><tr><td>.self</td><td>只有<code>event.target</code>是元素本身时才会触发事件处理器。即事件是由元素本身触发，而非冒泡触发</td></tr><tr><td>.capture</td><td>添加事件监听器时，使用<code>capture</code>捕获模式</td></tr><tr><td>.once</td><td>最多触发一次处理函数</td></tr><tr><td>.passive</td><td>并未阻止事件的默认行为</td></tr></tbody></table></li><li><p>用法</p></li></ul><pre><code>&lt;!--阻止事件冒泡--&gt;&lt;div class=&quot;box&quot; @click.stop=&quot;doThis&quot;&gt;box&lt;/div&gt;&lt;!-- 提交事件将不再重新加载页面 --&gt;&lt;form @submit.prevent=&quot;onSubmit&quot;&gt;&lt;/form&gt;&lt;!-- 仅当 event.target 是元素本身时才会触发事件处理器 --&gt;&lt;div @click.self=&quot;doThat&quot;&gt;...&lt;/div&gt;&lt;!-- 修饰语可以使用链式书写 --&gt;&lt;a @click.stop.prevent=&quot;doThat&quot;&gt;&lt;/a&gt;&lt;!-- 也可以只有修饰符 --&gt;&lt;form @submit.prevent&gt;&lt;/form&gt;</code></pre><blockquote><p>注：</p></blockquote><ul><li>修饰符可以使用链式书写</li><li>可以只有修饰符，不写<code>handler</code></li><li>使用修饰符时需要注意调用顺序，因为相关代码是以相同的顺序生成的。<ul><li>因此使用<code>@click.prevent.self</code>会阻止元素及其子元素的所有点击事件的默认行为，而<code>@click.self.prevent</code>则只会阻止对元素本身的点击事件的默认行为。</li></ul></li></ul><blockquote><p><code>once</code>修饰符</p></blockquote><ul><li>相当于先通过<code>addEventListener</code>添加事件监听，执行一次后，再通过<code>removeEventListener</code>方法取消了事件监听</li></ul><blockquote><p><code>passive</code>修饰符</p></blockquote><ul><li><code>.passive</code>修饰符，是用来告诉浏览器你没有阻止事件的默认行为<blockquote><ul><li>你可能会想，不阻止事件的默认行为不加<code>.prevent</code> 修饰符就好了，为什么要加<code>.passiv</code>e修饰符呢 ？</li></ul></blockquote></li><li>这里，不想阻止事件的默认行为，真正的目的是告诉浏览器，你可以<strong>不用去查询</strong>程序有没有阻止默认事件，也就是提前告诉浏览器程序不会阻止。</li><li>如果不提前告知，每次事件产生，浏览器都会去查询是否由<code>preventDefault()</code>阻止该次事件的默认动作。每次使用内核线程查询<code>preventDefault()</code>会使滑动卡顿，使用<code>.passive</code>修饰符跳过内核线程查询，可以大大的提高流畅度。</li><li><code>.passive</code>提前告诉浏览器不想阻止事件默认行为的目的是提高性能，<strong>减少移动端滑动卡顿问题</strong></li><li>一般用于触摸事件的监听器，可以用来改善移动端设备的滚屏性能</li></ul><blockquote><p>注意：</p></blockquote><ul><li>请勿同时使用 <code>.passive</code> 和 <code>.prevent</code>，因为 .<code>passive</code> 已经向浏览器表明了你不想阻止事件的默认行为。</li><li>如果你这么做了，则<code>.prevent</code>会被忽略，并且浏览器会抛出警告。</li></ul><h4 id="按键修饰符"><a href="#按键修饰符" class="headerlink" title="按键修饰符"></a>按键修饰符</h4><blockquote><p>在监听<strong>键盘事件</strong>时，我们经常需要检查我们按下了键盘上的那个键，Vue 允许在<code>v-on</code>或<code>@</code>监听按键事件时添加按键修饰符。</p><ul><li>以下是常用的按键修饰符<table><thead><tr><th>按键修饰符</th><th>说明</th></tr></thead><tbody><tr><td>.enter</td><td>当按下enter回车键时，才调用事件处理函数</td></tr><tr><td>.tab</td><td>当按下tab键时，才调用事件处理函数</td></tr><tr><td>.delete</td><td>当按下delete键时，才调用事件处理函数</td></tr><tr><td>.esc</td><td>当按下esc键时，才调用事件处理函数</td></tr><tr><td>.space</td><td>当按下backspace退格键时，才调用事件处理函数</td></tr><tr><td>.up</td><td>当按下↑向上方向键时，才调用事件处理函数</td></tr><tr><td>.down</td><td>当按下↓向下方向键时，才调用事件处理函数</td></tr><tr><td>.left</td><td>当按下←向上方向键时，才调用事件处理函数</td></tr><tr><td>.right</td><td>当按下→向上方向键时，才调用事件处理函数</td></tr></tbody></table></li></ul></blockquote><ol><li>复习：键盘事件</li></ol><ul><li>常用的键盘事件有<code>keyup</code>与<code>keydown</code></li><li>我们通过键盘事件的<code>event.key</code>属性来获取当前按下的键。</li><li>一般使用键盘事件都是<code>document</code>和<code>input</code> 元素</li></ul><ol start="2"><li>tab 键</li></ol><ul><li>tab 键相对比较特殊，当我们在<code>input</code>框中，按下<code>tab</code>键时，会使<code>input</code>失去焦点，所以<code>tab</code>修鉓一般都是与<code>keydown</code>事件结合使用</li></ul><ol start="3"><li>其它修饰符<blockquote><p>对于以上没有提到的一些功能，我们可以使用<code>KeyboardEvent.key</code>暴露的按键名称作为修饰符，但需要转为 <code>kebab-case</code> 形式。</p><ul><li><code>KeyboardEvent.key</code>有哪些值，详细查阅-<a href="https://developer.mozilla.org/zh-CN/docs/Web/API/UI_Events/Keyboard_event_key_values">MDN 官方文档-按键名</a></li></ul></blockquote></li></ol><pre><code>&lt;script&gt;  export default &#123;    methods: &#123;      message(e) &#123;        console.log(e.target.value);      &#125;,    &#125;,  &#125;;&lt;/script&gt;&lt;template&gt;  &lt;!--当按下按盘上的home键时，才触发事件的处理函数--&gt;  &lt;input type=&quot;text&quot; @keydown.home=&quot;message&quot; /&gt;  &lt;!--当按下按盘上的pagedown （简写 pg dn）键时，才触发事件的处理函数--&gt;  &lt;input type=&quot;text&quot; @keydown.page-down=&quot;message&quot; /&gt;&lt;/template&gt;</code></pre><h4 id="系统按键修饰符"><a href="#系统按键修饰符" class="headerlink" title="系统按键修饰符"></a>系统按键修饰符</h4><blockquote><p>以下是常用的系统按键修饰符</p><table><thead><tr><th>系统按键修饰符</th><th>说明</th></tr></thead><tbody><tr><td>.ctrl</td><td>当按下ctrl键时，才会触发事件处理函数</td></tr><tr><td>.alt</td><td>当按下alt键时，才会触发事件处理函数</td></tr><tr><td>.shift</td><td>当按下shift键时，才会触发事件处理函数</td></tr><tr><td>.meta</td><td>当按下meta键时，才会触发事件处理函数</td></tr></tbody></table></blockquote><ul><li>JS中通过<code>e.ctrlKey</code>、<code>e.altKey</code>、<code>e.shiftKey</code>识别<blockquote><p>系统按键修饰符使用</p><ul><li>系统按键修饰符通常配<code>keyup</code>、<code>keydown</code>、<code>mousedown</code>、<code>mouseup</code>使用</li></ul></blockquote></li><li>配合<code>keyup</code>使用：按下系统按键的同时，再按下其他键，随后释放其它键，事件才被触发</li><li>配合<code>keydown</code>使用，只要按下系统按键，事件就可以触发</li><li>配合<code>mousedown</code>使用，需要先按下系统按键，再按下鼠标，才能触发事件</li><li>配合<code>mouseup</code>使用，按下系统按键的同时再按鼠标，随后松开鼠标，事件才被触发</li></ul><h4 id="exact-修饰符"><a href="#exact-修饰符" class="headerlink" title=".exact 修饰符"></a><code>.exact</code> 修饰符</h4><blockquote><p><code>.exact</code>修饰符允许控制触发一个事件所需的<strong>确定组合</strong>的<strong>系统按键</strong>修饰符</p></blockquote><pre><code>&lt;!-- 当按下 Ctrl 时，即使同时按下 Alt 或 Shift 也会触发 --&gt;&lt;button @click.ctrl=&quot;onClick&quot;&gt;A&lt;/button&gt;&lt;!-- 仅当按下 Ctrl 且未按任何其他键时才会触发 --&gt;&lt;button @click.ctrl.exact=&quot;onCtrlClick&quot;&gt;A&lt;/button&gt;&lt;!-- 仅当没有按下任何系统按键时触发 --&gt;&lt;button @click.exact=&quot;onClick&quot;&gt;A&lt;/button&gt;</code></pre><h4 id="鼠标按键修饰符"><a href="#鼠标按键修饰符" class="headerlink" title="鼠标按键修饰符"></a>鼠标按键修饰符</h4><blockquote><p>以下修饰符将处理程序限定为由特定鼠标按键触发的事件。</p><table><thead><tr><th>鼠标按键修饰符</th><th>说明</th></tr></thead><tbody><tr><td>.left</td><td>当鼠标左键被按下时，才会触发事件处理函数</td></tr><tr><td>.right</td><td>当鼠标右键被按下时，才会触发事件处理函数</td></tr><tr><td>.middle</td><td>当鼠标中间滚轮被按下时，才会触发事件处理函数</td></tr></tbody></table></blockquote><h3 id="三、计算属性-computed"><a href="#三、计算属性-computed" class="headerlink" title="三、计算属性 computed"></a>三、计算属性 computed</h3><ol><li>为什么需要计算属性</li></ol><ul><li>虽然在模板的插值语法<code>&#123;&#123;&#125;&#125;</code>和<code>v-bind</code>指令中可以使用表达式，但如果涉及的逻辑太多，会让模板变得臃肿，难以维护。</li><li>同时，如果需要在多个地方用到处理后的值，我们需要在多个地方重复书写此代码，这肯定不是我们想要的。</li><li>计算属性就可以帮我们解决这个问题，能让模板中的代码更简洁，当然计算属性还有其它的优点，后面会讲到。</li></ul><ol start="2"><li>计算属性的基本使用</li></ol><ul><li>计算属性的本质是根据其它的属性值计算得到另一个值，使用方式与一般属性的使用方式一样，可以直接在模板中调用。</li><li>计算属性需要书写在组件的<code>computed</code>选项中，同时支持以下两种写法<ul><li>简写形式：用于创建只读的计算属性（常用）</li><li>完整写法：用于创建可读可写的计算属性（了解）</li></ul></li></ul><blockquote><p>简写形式：创建只读计算属性</p></blockquote><ul><li>如果我们只需要读取一个计算属性的值，而不用修改他的值。可以采用如下简写形式</li></ul><pre><code>// 简写形式computed:&#123;    // myComputed 为计算属性,当读取计算属性值时，会调用该函数    myComputed()&#123; &#125;&#125;</code></pre><ul><li>案例</li></ul><pre><code>&lt;script&gt;export default &#123;  data() &#123;    return &#123;      css: 80,      js: 90,      vue: 99,    &#125;;  &#125;,  // 所有计算属性都写在computed这个选项中  computed: &#123;    // 一个计算属性。    average() &#123;      return ((this.css + this.js + this.vue) / 3).toFixed(2);    &#125;,  &#125;,&#125;;&lt;/script&gt;&lt;template&gt;  &lt;div&gt;    &lt;!-- 直接在模板中使用计算属性 --&gt;    &lt;div&gt;平均分: &#123;&#123; average &#125;&#125;&lt;/div&gt;  &lt;/div&gt;&lt;/template&gt;</code></pre><ul><li>以上代码中的<code>average</code>是一个只读的计算属性，属性的值不能直接被修改的</li><li>不过他的值会根据他所依赖的<strong>响应式数据</strong>而发生更改。比如<code>css、js、vue</code>中，只要有一个属性的值发生了变化，那<code>average</code>的值就会被重新计算。</li></ul><blockquote><p>完整写法：创建可读可写计算属性</p></blockquote><ul><li>如果一个计算属性需要支持可读可写，则需要采用如下完整写法，同时创建<code>get</code>和<code>set</code>方法。</li></ul><pre><code>computed:&#123;    // myComputed 为计算属性    myComputed:&#123;        // 当获取计算属性的值时，get方法会被调用        get()&#123;&#125;,         //  当修改计算属性的值时，set方法会被调用，newValue为myComputed的最新值        set(newValue)&#123; &#125;    &#125;&#125;</code></pre><ol start="3"><li>计算属性注意事项</li></ol><ul><li>计算属性的<code>get</code>方法不应有<strong>副作用</strong><ul><li>这里的副作用是指：<code>get</code>方法应该只能用来计算返回具体的值，而不应该在内部做其它的操作，比如：异步请求或更改 DOM。</li></ul></li><li>计算属性最好是<strong>只读</strong>的<ul><li>因为计算属性的值是通过其它的属性计算后得到的，所以计算属性可以看做是一个“临时快照”，每当源数据发生变化时，就会创建一个新的快照。</li></ul></li><li>如果想要更新计算属性值，应该去更新它所依赖的源数据，以触发<code>get</code>方法来重新计算，得到新的值。</li></ul><ol start="4"><li>计算属性与 methods 方法对比<blockquote><p>计算属性能实现的功能，在<code>methods</code>选项中定义一个方法，也可以做到，那为什么还需要弄出一个计算属性呢 ？</p></blockquote></li></ol><ul><li>是因为计算属性与<code>methods</code>方法之间还存在以下细微的区别：</li></ul><p><strong>计算属性值会基于其响应式依赖被缓存</strong></p><ul><li>也就是一个计算属性<strong>仅</strong>会在其依赖的响应式数据发生更新时才会重新计算值，否则无论页面中读取多少次计算属性，他都是直接返回之前计算得到的结果，而不会去重复执行<code>get</code>函数来重新计算值。</li><li>后面模板重新渲染时，也是直接读取之前计算得到的结果<br><strong>methods 中定义的方法无缓存</strong></li><li><code>methods</code>中定义的方法调用多少次，就会执行多少次。同时还会在模板重新渲染时再次调用。</li></ul><ol start="5"><li>计算属性总结<blockquote><p>计算属性定义</p></blockquote></li></ol><ul><li>计算属性是通过现有属性重新计算而来。计算属性与普通属性一样，可以直接在模板中使用。<blockquote><p>计算属性的基本使用</p></blockquote></li><li>如果计算属性为一个只读的，可以采用以下简写形式（相当只定义了 <code>get</code> 方法）</li></ul><pre><code>computed: &#123;    // myComputed为计算属性，myComputed()方法相当于计算属性的get方法    myComputed()&#123;      // 省略复杂计算步骤      return xxx;    &#125;  &#125;</code></pre><ul><li>如果计算属性为可读可写的，则需要采用以下完整写法</li></ul><pre><code>computed: &#123;    // myComputed为计算属性，同时书写get与set方法    myComputed:&#123;        // 读取计算属性，get方法被调用        get()&#123;            // 省略复杂计算步骤            return xxx;        &#125;,        // 修改计算属性值，set方法被调用        set(newValue)&#123;           // 省略内部赋值细节        &#125;    &#125;&#125;</code></pre><blockquote><p>计算属性的 get 方法什么时候执行</p></blockquote><ul><li>当<strong>初次</strong>读取计算属性时，<code>get</code>方法会被执行</li><li>当计算属性依赖的<strong>响应式数据发生改变</strong>时，会再次调用<code>get</code>方法更新值。<blockquote><p>计算属性注意事项</p></blockquote></li><li>计算属性的get方法不应该有副作用，只参于计算并返回值，并应该有异步请求与 DOM 操作等</li><li>计算属性应该被定义为只读的，最好不要直接修改计算属性值<blockquote><p>计算属性于<code>methods</code>方法对比</p></blockquote></li><li>计算属性值会基于其响应式依赖被缓存，并且模板重新渲染也不会重新求值</li><li><code>methods</code>方法调用多少次，就会执行多少次。同时还会在模板重新渲染时再次调<blockquote><p>计算属性的优点</p></blockquote></li><li>可以<strong>简化</strong>模板中的代码，对于相对复杂的逻辑，可以直接用计算属性来代替</li><li>因为计算结果会基于其响应式依赖被缓存，所以性能比较高，也更适合<strong>复用</strong></li></ul><h3 id="四、侦听器-watch"><a href="#四、侦听器-watch" class="headerlink" title="四、侦听器 watch"></a>四、侦听器 watch</h3><blockquote><p>侦听器主要是用来监视某个响应式属性，当这个属性的值发生变化时我们可以作一些额外的操作，比如：发送异步请求或执行 DOM 操作等</p></blockquote><h4 id="侦听器的创建与使用"><a href="#侦听器的创建与使用" class="headerlink" title="侦听器的创建与使用"></a>侦听器的创建与使用</h4><blockquote><p>当我们需要侦听某个响应式属性的变化时，我们可以在<code>watch</code>选项中来监听该属性。<br><code>watch</code> 侦听器有以下两种写法：</p><ul><li>完整版：对象写法</li><li>简化版：函数写法</li></ul></blockquote><ol><li>侦听器：完整版-对象写法</li></ol><ul><li>如果侦听器除了<code>handler</code>回调函数，还需要有其它额外的配置，则需要采用以下完整写法</li></ul><pre><code>watch:&#123;   // key 为监听的响应式属性    key:&#123;        // newValue 为属性变化后值  oldValue 为属性变化后值        handler(newValue,oldValue)&#123; &#125;        // options 相关配置可以直接写在这个后面        // .....    &#125;&#125;</code></pre><ul><li>以上代码中的<code>key</code>为监听的响应式属性，当<code>key</code>的属性值发生变化时，<code>handler</code>方法就会被调用</li></ul><ol start="2"><li>侦听器：简化版-函数写法</li></ol><ul><li>如果侦听器除了handler回调函数，<strong>没有其它额外的配置项</strong>，则可以采用如下简写形式</li></ul><pre><code>watch:&#123;    // key方法相当于 对象写法中的handler方法    // 当侦听的属性key的值发生了变化，就会调用key方法，来执行相关后续操作    key(newValue,oldValue)&#123;        //.....    &#125;&#125;</code></pre><h4 id="侦听器配置选项"><a href="#侦听器配置选项" class="headerlink" title="侦听器配置选项"></a>侦听器配置选项</h4><ul><li>watch侦听器侦听某个响应式属性时，允许我们添加以下相关配置选项</li></ul><pre><code>&lt;script&gt;  export default &#123;    watch: &#123;      key: &#123;        // 侦听器回调        handler(newValue, oldValue) &#123;&#125;,        immediate: true, // 侦听器回调函数立即执行        deep: true, // 深层侦听器        flush: &quot;post&quot;, // 在Vue组件更新后调用侦听器回调      &#125;,    &#125;,  &#125;;&lt;/script&gt;</code></pre><ol><li>即时回调的侦听器（immediate:true）</li></ol><ul><li>watch 默认是<strong>懒执行</strong>的，仅当数据源变化时，才会执行回调。</li><li>但在某些场景中，我们希望在创建侦听器(页面初始渲染)时，立即执行一遍回调，我们可以添加<code>immediate: true</code>配置项实现</li></ul><ol start="2"><li>深层侦听器（deep:true）</li></ol><ul><li>watch 默认是<strong>浅层</strong>的：被侦听的属性（也包括计算属性），仅在被赋新值时，才会触发回调函数——但嵌套属性的变化不会触发</li><li>如果想侦听所有嵌套的变更，你需要配置<code>deep:true</code>开启深层侦听器</li><li>因此如果被侦听的属性是对象时，只有整个对象重新赋值时才会触发回调，其中某个属性的变化是不会触发的；如果向侦听其中所有属性的变更，那就给对象配置<code>deep:true</code></li></ul><blockquote><p>谨慎使用：</p></blockquote><ul><li>深度侦听需要遍历被侦听对象中的所有嵌套的属性，当用于大型数据结构时，<strong>开销很大</strong>。因此请只在必要时才使用它，并且要留意性能。</li></ul><ol start="3"><li>侦听对象某个属性</li></ol><ul><li>如果为了侦听对象身上的某个属性而开启深度侦听，显然是非常消耗性能的。针对这种情况，我们可以只侦听对象的某个属性。</li><li>在watch里打点调用对象的属性。进行侦听，注意要加<code>&quot;&quot;</code>，在该属性的配置下开启深度侦听</li></ul><ol start="4"><li>回调的触发时机（flush 选项）</li></ol><ul><li>当我们侦听的响应式属性的值发生更改时，默认情况下，侦听器回调都会在 Vue 组件<strong>更新之前</strong>被调用。这意味着你在侦听器回调中访问的 DOM 将是被 Vue 更新之前的状态。</li><li>如果想在侦听器回调中能访问被 Vue 更新之后的 DOM，你需要指明 <code>flush: &#39;post&#39;</code> 选项<table><thead><tr><th>flush选项的值</th><th>侦听器回调执行时机</th></tr></thead><tbody><tr><td>pre</td><td>组件更新前执行</td></tr><tr><td>sync</td><td>组件更新和侦听器回调同步触发</td></tr><tr><td>post</td><td>组件更新后执行</td></tr></tbody></table></li></ul><h4 id="副作用清理"><a href="#副作用清理" class="headerlink" title="副作用清理"></a>副作用清理</h4><blockquote><p>watch侦听器的回调函数实际上接受 3 个参数</p></blockquote><ul><li><code>newValue</code>属性更新后值</li><li><code>oldValue</code>属性更新前值</li><li><code>onCleanup</code>注册副作用清理的回调函数:该函数接受一个回调函数，回调函数会在副作用下一次重新执行前调用，可以用来清除无效的副作用，例如等待中的异步请求</li></ul><pre><code>watch: &#123;    key: &#123;        handler(newValue, oldValue, onCleanup) &#123;            //取消定时器            function cancle()&#123;&#125;            // 在下次handler被调用前，会执行cancle            onCleanup(cancle)        &#125;    &#125;&#125;</code></pre><blockquote><p>代码演示</p></blockquote><ul><li>监听某个 id 属性的变化，当 id 变化时，就会发请求获取内容</li><li>如果 id 变化时，上一次请求的结果还没有回来，则把上一次请求取消，重新发送一个新请求。</li></ul><pre><code>&lt;script&gt;  export default &#123;    data() &#123;      return &#123;        id: 0,      &#125;;    &#125;,    watch: &#123;      id: &#123;        handler(newValue, oldValue, onCleanup) &#123;          // 模拟发请求          let timer = setTimeout(() =&gt; &#123;            console.log(&quot;请求成功&quot;);            timer = null;          &#125;, 2000);          // 清除定时器, 模拟请除上一次请求          function cancle() &#123;            // 如果上一次请求还没成功，则取消上一次请求            if (timer) &#123;              clearTimeout(timer);              console.log(&quot;取消上一次请求&quot;);            &#125;          &#125;          // 注册清理定时器的回调函数          // 当id值发生改变时，上一次请求还没有成功，就取消重新发一个请求          onCleanup(cancle);        &#125;,      &#125;,    &#125;,  &#125;;&lt;/script&gt;&lt;template&gt;  &lt;div&gt;当前id：&#123;&#123; id &#125;&#125;&lt;/div&gt;  &lt;button @click=&quot;id++&quot;&gt;发请求&lt;/button&gt;&lt;/template&gt;</code></pre><h4 id="watch-方法创建侦听器"><a href="#watch-方法创建侦听器" class="headerlink" title="$watch()方法创建侦听器"></a>$watch()方法创建侦听器</h4><ul><li>我们还可以使用组件实例的<code>$watch()</code>方法来命令式地创建一个侦听器。</li></ul><pre><code>$watch(string, handler, options);</code></pre><ul><li><code>string</code>: 侦听的属性名，可以是组件的属性名的字符串，也可以是一个由点分隔的路径字符串，或一个<code>getter</code>函数（返回一个字符串，针对属性名需要经过复杂计算的情况）</li><li><code>handler</code>：属性值改变时需要触发的回调函数。函数有 3 个参数：<code>newValue、oldValue、onCleanup</code>，与 watch 侦听器回调函数参数一致</li><li><code>options</code>：一个对象，用来指定相关的配置。如：<code>deep、immediate、flush</code>等</li></ul><ol><li>$watch() 基本用法</li></ol><ul><li>利用<code>$watch()</code>方法命令式创建一个侦听器，用来监听<code>person.temperature</code>属性的变化。</li><li>以下代码中的<code>created</code>函数为生命周期函数，组件实例处理完所有与状态相关的选项后调用。</li><li>当这个钩子被调用时，以下内容已经设置完成：响应式数据、计算属性、方法和侦听器。然而，此时挂载阶段还未开始</li></ul><pre><code>&lt;script&gt;export default &#123;  data() &#123;    return &#123;      person: &#123;        username: &quot;清心&quot;,        temperature: 37,      &#125;,      info: &quot;&quot;,    &#125;;  &#125;,  // 生命周期函数  created() &#123;    this.$watch(      &quot;person.temperature&quot;,      function (newValue, oldValue) &#123;        if (newValue &gt;= 38) &#123;          this.info = &quot;发烧高，建议前往医院就医&quot;;        &#125; else if (newValue &gt; 37) &#123;          this.info = &quot;有点发烧，建议在家采用物理降温&quot;;        &#125; else &#123;          this.info = &quot;体温正常&quot;;        &#125;      &#125;,      &#123;        immediate: true,        deep: true,      &#125;    );  &#125;,&#125;;&lt;/script&gt;&lt;template&gt;&#123;&#123; person.username &#125;&#125;---&#123;&#123; info &#125;&#125;&lt;/template&gt;</code></pre><ol start="2"><li>停止侦听器</li></ol><ul><li>用<code>watch</code>选项或者<code>$watch()</code>实例方法声明的侦听器，会在宿主组件卸载时<strong>自动停止</strong>。因此，在大多数场景下，你无需关心怎么停止它。</li><li>在少数情况下，你的确需要在<strong>组件卸载之前</strong>就停止一个侦听器，这时可以调用 <code>$watch()</code> API 返回的函数</li></ul><pre><code>const unwatch = this.$watch(string, handler, options);// 停止侦听器unwatch();</code></pre><h4 id="watch-与-computed-的对比"><a href="#watch-与-computed-的对比" class="headerlink" title="watch 与 computed 的对比"></a>watch 与 computed 的对比</h4><ul><li>在学习<code>computed</code>时，我们专门强调过，<code>computed</code>计算属性最好是只读的，并且<code>get</code>中不能有副作用也就是不要有异步请求或 <code>DOM</code> 相关的额外操作。</li><li><code>watch</code>侦听器允许我们在某个属性发生变化时，可以执行相关的“副作用”，也就可以执行异步请求或 <code>DOM</code> 相关的额外操作。<ul><li>以上是<code>watch</code>与<code>compted</code>两者最大的不同。如果我们想要在某个属性变化时，执行相关的副作用（DOM 操作或异步请求），则选用<code>watch</code>来实现。</li></ul></li><li>有些情况<code>watch</code>能实现的，<code>computed</code>计算属性也能实现，且<code>computed</code>的实现方式更简洁，则选用<code>computed</code></li></ul><blockquote><p>总结：</p></blockquote><ul><li><code>watch</code>相比<code>computed</code>功能更强大，<code>watch</code>能实现<code>computed</code>不一定能实现，比如<code>watch</code>允许执行一些<strong>“副作用”</strong>，而<code>computed</code>是不建议的。</li><li>不过<code>computed</code>和<code>watch</code>都能实现的功能，建议使用<code>computed</code>，因为<code>computed</code>实现更简洁</li></ul><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><h4 id="模板语法"><a href="#模板语法" class="headerlink" title="模板语法"></a>模板语法</h4><blockquote><p>文本插值和内置指令是两种将组件实例的数据绑定到DOM上的方法</p></blockquote><blockquote><p>文本插值</p></blockquote><ul><li>使用双大括号</li><li>只能出现在标签体内，不能出现在属性中(要与小程序区分)</li><li>数据格式：单一表达式，能写在<code>return</code>后面</li><li>能访问到的内容<ul><li>组件实例属性</li><li>有限的全局对象，如Math、Data、RegExp</li><li>自定义全局属性：通过<code>app.config.globalProperties</code>注册的属性</li></ul></li></ul><blockquote><p>指令语法</p></blockquote><ul><li>指令是带有<code>v-</code>前缀的特殊属性</li></ul><p><code>v-bind</code></p><ul><li>用于动态的绑定一个 或 多个属性</li><li>单个属性：<code>v-bind:属性名=&quot;&quot;</code>，可以简写成<code>:属性名=&quot;&quot;</code></li><li>多个属性：<code>v-bind=&quot;对象&quot;</code>，不带参数</li><li>布尔属性  <ul><li>原生支持：决定属性是否存在在该元素上</li><li>非原生：正常显示布尔值</li></ul></li><li>数据格式：单一表达式，能写在<code>return</code>后面</li><li>动态参数：<code>v-bind:[变量]=&quot;&quot;</code>，变量必须是字符串类型，不能使用空格和引号</li></ul><h4 id="事件处理-与-methods"><a href="#事件处理-与-methods" class="headerlink" title="事件处理 与 methods"></a>事件处理 与 methods</h4><blockquote><p>监听事件</p></blockquote><ul><li><code>v-on:事件=&quot;handler&quot;</code>或<code>@事件=&quot;handler&quot;</code></li><li><code>handler</code>可以是：<ul><li>内联事件处理器：JS语句直接写在标签里</li><li>方法事件处理器：把方法写在<code>methods</code>里</li></ul></li><li>event 事件对象<ul><li>内联事件处理器可自行传入<code>$event</code>变量</li><li>方法事件处理器的第一个参数默认是<code>event</code></li></ul></li><li>绑定多个事件<ul><li><code>v-on=&quot;对象&quot;</code>，键是事件，值是方法</li><li>注意：绑定对象时，不支持事件修饰符</li></ul></li></ul><blockquote><p>修饰符</p></blockquote><ul><li>修饰符是用<code>.</code>表示的指令后缀</li><li>可以链式调用，但注意顺序</li><li>可以接在事件后面，也可以接在参数后面</li></ul><blockquote><p>事件修饰符</p></blockquote><ul><li>不要同时使用<code>.passive</code>和<code>.prevent</code></li></ul><table><thead><tr><th>事件修饰符</th><th>说明</th></tr></thead><tbody><tr><td>.stop</td><td>阻止事件冒泡</td></tr><tr><td>.prevent</td><td>阻止事件的默认行为</td></tr><tr><td>.self</td><td>只有 event.target是元素本身时才会触发事件处理器</td></tr><tr><td>.capture</td><td>添加事件监听器时，使用 capture 捕获模式</td></tr><tr><td>.once</td><td>最多触发一次处理函数</td></tr><tr><td>.passive</td><td>告诉浏览器没有阻止事件的默认行为</td></tr></tbody></table><blockquote><p>按键修饰符</p></blockquote><ul><li>表示只有在按下修饰符表示的键时，才调用事件处理函数</li><li>键盘按键：配合<code>keyup、keydown、mousedown、mouseup</code>使用<ul><li><code>.enter</code></li><li><code>.tab</code></li><li><code>.delete</code></li><li><code>.esc</code></li><li><code>.space</code></li><li><code>.up</code></li><li><code>.down</code></li><li><code>.left</code></li><li><code>.right</code></li><li><code>.ctrl</code></li><li><code>.alt</code></li><li><code>.shift</code></li><li><code>.meta</code></li></ul></li><li><code>.exact</code>：只能在按下确定组合的系统按键时触发</li><li>鼠标按键：配合<code>mousedown、mouseup</code>使用<ul><li><code>.left</code></li><li><code>.right</code></li><li><code>middle</code></li></ul></li></ul><h4 id="计算属性"><a href="#计算属性" class="headerlink" title="计算属性"></a>计算属性</h4><ul><li>根据其他属性值计算得到另一个值</li><li>写法：<ul><li>简写：只读 </li><li>完整写法：可读可写，需要创建get和set方法</li><li>注意：最好是只读的，并且get中不要有副作用</li></ul></li><li>与methods方法对比<ul><li>计算属性会缓存，只有在其以来的响应式数据更新时才会重新计算</li><li>methods定义的方法不会缓存，每次调用都会执行</li></ul></li><li>优点<ul><li>简化模板中的代码</li><li>因为会被缓存，所以性能较高，适合复用</li></ul></li></ul><h4 id="侦听器"><a href="#侦听器" class="headerlink" title="侦听器"></a>侦听器</h4><ul><li>主要用来监视某个响应式属性</li><li>写法：<ul><li>完整版：写成对象，包括回调函数及相关配置</li><li>简化版：写成函数</li></ul></li><li>相关配置<ul><li>immediate：侦听器回调函数是否立即执行</li><li>deep：是否开启深层侦听</li><li>flush：设置回调函数的执行时机</li></ul></li><li>侦听对象的某个属性<ul><li>侦听器中的属性名写成”对象.属性”的形式</li></ul></li><li>侦听器的参数<ul><li>第一个是newValue：属性更新后的值</li><li>第二个是oldValue：属性更新前的值</li><li>第三个是onCleanup：接收副作用清理函数，并在下次handler执行前调用</li></ul></li><li><code>$watch</code>方法创建侦听器：<ul><li><code>$watch(string, handler, options);</code></li></ul></li><li>停止侦听器<ul><li>用<code>watch</code>选项或者<code>$watch()</code>实例方法声明的侦听器，会在宿主组件卸载时自动停止 </li><li>如需在组件卸载前停止侦听器，可以通过调用<code>$watch() API</code>返回的函数来停止</li></ul></li><li>watch与computed的对比<ul><li>computed最好是只读的，并且get中不能有副作用</li><li>watch可以有副作用，也就是可以执行异步请求和DOM相关的额外操作</li><li>在二者都能实现的情况下，computed会更加简洁</li></ul></li></ul><h3 id="五、表单输入绑定"><a href="#五、表单输入绑定" class="headerlink" title="五、表单输入绑定"></a>五、表单输入绑定</h3><h4 id="数据绑定的两种形式"><a href="#数据绑定的两种形式" class="headerlink" title="数据绑定的两种形式"></a>数据绑定的两种形式</h4><blockquote><p>数据绑定分为以下两种形式：</p></blockquote><ul><li>单向数据绑定</li><li>双向数据绑定</li></ul><ol><li>单向数据绑定（v-bind）</li></ol><ul><li>单向数据绑定是指：数据只能从 data 流向页面。<ul><li>当我们更新data中数据时，页面中对应的数据也会跟着发生变化。但页面中数据发生变化时，data中对应的数据并不会有任何变化</li></ul></li><li>v-bind指令属于单向数据绑定，用于给元素动态的绑定一个或多个属性</li></ul><pre><code>&lt;script&gt;export default &#123;  data() &#123;    return &#123;      text: &quot;用户名&quot;,    &#125;;  &#125;,&#125;;&lt;/script&gt;&lt;template&gt;  &lt;input :value=&quot;text&quot; /&gt;&lt;/template&gt;</code></pre><ul><li>当data中数据发生变化时，页面中数据会同步更新，但页面中数据发生变化时，data中数据不会变</li></ul><ol start="2"><li>双向数据绑定（v-model）</li></ol><ul><li>双向数据绑定是指：数据不仅能从 data 流向页面，还可以从页面流向 data<ul><li>在处理表数据时，当data中的数据发生变化时，表单中的内容也要同步更新。当输入框中的内容发生变化时，data中的数据也要跟着更新为最新的。</li></ul></li><li>v-model指令为双向数据绑定，常用于动态绑定表单元素的属性（如：value 属性）</li></ul><pre><code>&lt;script&gt;export default &#123;  data() &#123;    return &#123;      text: &quot;用户名&quot;,    &#125;;  &#125;,&#125;;&lt;/script&gt;&lt;template&gt;  &lt;input v-model=&quot;text&quot; /&gt;&lt;/template&gt;</code></pre><h4 id="2、手动实现-input-元素双向数据绑定"><a href="#2、手动实现-input-元素双向数据绑定" class="headerlink" title="2、手动实现 input 元素双向数据绑定"></a>2、手动实现 input 元素双向数据绑定</h4><blockquote><p>如果没有<code>v-model</code>指令，我们用前面学过的<code>v-bind</code>指令与<code>@input</code>事件也可以轻松实现<code>&lt;input&gt;</code>元素的双向数据绑定。</p><ul><li>实现原理：</li></ul></blockquote><ul><li><code>v-bind</code>指令用于实现将data中数据呈现到输入框中，当data中数据发生变化时，文本框中内容同步变化</li><li><code>@input</code>事件绑定，用来实现当输入框中的内容发生改变时，将输入框中的内容赋值给到data中对应的属性</li></ul><blockquote><p>代码示例</p><ul><li>使用v-bind指令与@input事件，实现<input>元素的双向数据绑定</li></ul></blockquote><pre><code>&lt;script&gt;export default &#123;  data() &#123;    return &#123;      text: &quot;用户名&quot;,    &#125;;  &#125;,&#125;;&lt;/script&gt;&lt;template&gt;  &lt;!--        v-bind 指令动态绑定输入框的value属性，当text属性值变化时，文本框中的内容发生变化        @input事件用于在输入框内容改变时，把data中的text属性值更改变文本框中的值        以上两步实现了v-model的双向数据绑定效果    --&gt;  &lt;input :value=&quot;text&quot; @input=&quot;(event) =&gt; (text = event.target.value)&quot; /&gt;&lt;/template&gt;</code></pre><ul><li><code>v-model</code>指令，帮我们简化了<code>v-bind</code>指令与<code>@input</code>事件结合的复杂操作，以后我们需要实现双向数据绑定时，只需要使用<code>v-model</code>指令即可</li></ul><h4 id="v-model-的基本用法"><a href="#v-model-的基本用法" class="headerlink" title="v-model 的基本用法"></a>v-model 的基本用法</h4><blockquote><p>v-model可以用于各种不同类型的输入元素，实现双向数据绑定。它会根据所使用的元素自动使用对应的 DOM 属性和事件组合：</p></blockquote><ul><li>单行文本<code>&lt;input&gt;</code>与多行文本<code>&lt;textarea&gt;</code>输入框，<code>v-model</code>会绑定 <code>value</code> 属性 并侦听 <code>input</code> 事件</li><li>单选按扭<code>&lt;input type=&quot;radio&quot;&gt;</code>与复选框<code>&lt;input type=&quot;checkbox&quot; &gt;</code>，v-model会绑定 <code>checked</code> 属性并侦听 <code>change</code> 事件；</li><li>下拉列表<code>&lt;select&gt;</code>元素，v-model会绑定 <code>value</code> 属性 并侦听 <code>change</code> 事件</li></ul><ol><li>多行文本<blockquote><p>多行文本框的绑定方式和原理与单行文本框<input>的是一模一样。</p></blockquote></li></ol><ul><li>写法如下：</li></ul><pre><code>&lt;script&gt;export default &#123;  data() &#123;    return &#123;      message: &quot;多行文本框&quot;,    &#125;;  &#125;,&#125;;&lt;/script&gt;&lt;template&gt;  &lt;textarea v-model=&quot;message&quot;&gt;&lt;/textarea&gt;&lt;/template&gt;</code></pre><ol start="2"><li>单选按扭<blockquote><p>想要收集单选按扭的选中的值，需要在单选按扭上添加<code>value</code>属性，这样<code>v-mode</code>l指令后的变量才能收集到选中按扭的值。</p></blockquote></li></ol><ul><li>代码示例</li></ul><pre><code>&lt;script&gt;  export default &#123;    data() &#123;      return &#123;        /*            一开始选中粉色主题，则skinTheme的值为 pinkTheme            一开始选中蓝色主题，则skinTheme的值为 skyblueTheme            一开始没有任何一个被选中，则skinTheme的值为 &quot;&quot;         */        skinTheme: &quot;pinkTheme&quot;,      &#125;;    &#125;,  &#125;;&lt;/script&gt;&lt;template&gt;  &lt;h3&gt;皮肤主题：&#123;&#123; skinTheme &#125;&#125;&lt;/h3&gt;  &lt;input type=&quot;radio&quot; v-model=&quot;skinTheme&quot; value=&quot;pinkTheme&quot; /&gt; 粉色  &lt;input type=&quot;radio&quot; v-model=&quot;skinTheme&quot; value=&quot;skyblueTheme&quot; /&gt; 蓝色&lt;/template&gt;</code></pre><ul><li>也可动态绑定单选按扭 value 的属性值</li></ul><pre><code>&lt;script&gt;export default &#123;  data() &#123;    return &#123;      pink: &quot;pinkTheme&quot;, // 粉色主题      skyblue: &quot;skyblueTheme&quot;, // 蓝色主题      skinTheme: &quot;pinkTheme&quot;,    &#125;;  &#125;,&#125;;&lt;/script&gt;&lt;template&gt;  &lt;h3&gt;皮肤主题：&#123;&#123; skinTheme &#125;&#125;&lt;/h3&gt;  &lt;input type=&quot;radio&quot; v-model=&quot;skinTheme&quot; :value=&quot;pink&quot; /&gt; 粉色  &lt;input type=&quot;radio&quot; v-model=&quot;skinTheme&quot; :value=&quot;skyblue&quot; /&gt; 蓝色&lt;/template&gt;</code></pre><ol start="3"><li>单一复选框</li></ol><ul><li>针对只有一个复选框的情况，我们通常需要收集的是布尔值：<code>true</code>或<code>false</code>。 比如：对于阅读的协议只需要勾选同意或不勾选。</li><li>针对单一复选框，我们要收集的是布尔值，则<code>v-modle</code>绑定的变量只能是布尔类型。</li></ul><pre><code>&lt;script&gt;export default &#123;  data() &#123;    return &#123;      checked: false, // false表示未选中 true表示选中    &#125;;  &#125;,&#125;;&lt;/script&gt;&lt;template&gt;  &lt;div&gt;&#123;&#123; checked &#125;&#125;&lt;/div&gt;  &lt;input type=&quot;checkbox&quot; name=&quot;sex&quot; v-model=&quot;checked&quot; /&gt; 同意&lt;/template&gt;</code></pre><ul><li>如果我们希望复选框选中时与未选中时分别给出不同的值，并且值可以为<strong>非布尔值</strong></li><li>则可以在复选框上添加<code>true-value</code>和<code>false-value</code>两个属性，这两个属性是 Vue 特有，仅支持和<code>v-model</code>配套使用。</li></ul><pre><code>&lt;script&gt;export default &#123;  data() &#123;    return &#123;      skin: &quot;skyblueTheme&quot;, // 默认主题    &#125;;  &#125;,&#125;;&lt;/script&gt;&lt;template&gt;  &lt;h3&gt;皮肤主题：&#123;&#123; skin &#125;&#125;&lt;/h3&gt;  &lt;!--选中皮肤主题为：pinkTheme  未选中采用默认主题 skyblueTheme--&gt;  &lt;input    type=&quot;checkbox&quot;    v-model=&quot;skin&quot;    true-value=&quot;pinkTheme&quot;    false-value=&quot;skyblueTheme&quot;  /&gt;  粉色&lt;/template&gt;</code></pre><ul><li>也可以使用<code>v-bind</code>来动态绑定<code>true-value</code>和 <code>false-value</code>属性的值</li></ul><ol start="4"><li>多个复选框</li></ol><ul><li><code>v-model</code>收集的是被选中的多个复选框的值时，默认将收集到的多个值放到一个数组中保存。所以<code>v-model</code>绑定的变量需要是一个数组。默认没有一个被选中，则变量对应的是一个<code>[]</code>空数组。</li><li>收集时，要知道每个复选框的值，则需要在复选框上添加<code>vaule</code>属性，被选中选项的<code>value</code>值会被添加到数组里</li></ul><pre><code>&lt;script&gt;export default &#123;  data() &#123;    return &#123;      hobbies: [], // 没有默认被勾选的项      // hobbies: [&quot;桃子&quot;]  // 默认桃子被勾选    &#125;;  &#125;,&#125;;&lt;/script&gt;&lt;template&gt;  &lt;h3&gt;你喜欢的水果有：&#123;&#123; hobbies &#125;&#125;&lt;/h3&gt;  &lt;input type=&quot;checkbox&quot; value=&quot;苹果&quot; v-model=&quot;hobbies&quot; /&gt;苹果  &lt;input type=&quot;checkbox&quot; value=&quot;香蕉&quot; v-model=&quot;hobbies&quot; /&gt;香蕉  &lt;input type=&quot;checkbox&quot; value=&quot;梨子&quot; v-model=&quot;hobbies&quot; /&gt;梨子  &lt;input type=&quot;checkbox&quot; value=&quot;桃子&quot; v-model=&quot;hobbies&quot; /&gt;桃子  &lt;input type=&quot;checkbox&quot; value=&quot;菠萝&quot; v-model=&quot;hobbies&quot; /&gt;菠萝&lt;/template&gt;</code></pre><ol start="5"><li>下拉列表：单个选择器<blockquote><p>如果下拉列表为单个选择器，也就是每次只能选择下拉列表中的一项。</p></blockquote></li></ol><ul><li><code>v-model</code>指令后变量为一个<strong>字符串</strong>类型，用来收集选中的<code>&lt;option&gt;</code>元素的<code>value</code>值，而非text的值。</li><li>不过<code>v-model</code>指令要写在<code>&lt;select&gt;</code>元素上</li></ul><pre><code>&lt;script&gt;export default &#123;  data() &#123;    return &#123;      province: &quot;湖南&quot;, // 表示最开始选中湖南，如果不写或写的值与&lt;select&gt;中的任何一项不匹配，则最终渲染效没有一个被选中    &#125;;  &#125;,&#125;;&lt;/script&gt;&lt;template&gt;  &lt;h3&gt;你所在的省份为：&#123;&#123; province &#125;&#125;&lt;/h3&gt;  &lt;select v-model=&quot;province&quot;&gt;    &lt;option value=&quot;湖南&quot;&gt;湖南省&lt;/option&gt;    &lt;option value=&quot;陕西&quot;&gt;陕西省&lt;/option&gt;    &lt;option value=&quot;海南&quot;&gt;海南省&lt;/option&gt;    &lt;option value=&quot;广东&quot;&gt;广东省&lt;/option&gt;    &lt;option value=&quot;湖北&quot;&gt;湖北省&lt;/option&gt;    &lt;option value=&quot;河南&quot;&gt;河南省&lt;/option&gt;  &lt;/select&gt;&lt;/template&gt;</code></pre><blockquote><p>注意事项：</p></blockquote><ul><li>如果 v-model 表达式的初始值不匹配任何一个选择项，<code>&lt;select&gt;</code> 元素会渲染成一个“未选择”的状态。</li><li>在 <code>iOS</code> 上，这将导致用户无法选择第一项，因为 <code>iOS</code> 在这种情况下不会触发一个 <code>change</code> 事件。</li><li>因此，我们建议提供一个空值的禁用选项</li></ul><pre><code>&lt;script&gt;export default &#123;  data() &#123;    return &#123;      province: &quot;&quot;,    &#125;;  &#125;,&#125;;&lt;/script&gt;&lt;template&gt;  &lt;h3&gt;你所在的省份为：&#123;&#123; province &#125;&#125;&lt;/h3&gt;  &lt;select v-model=&quot;province&quot;&gt;    &lt;option value=&quot;&quot; disabled&gt;----选择你所在省份----&lt;/option&gt;    &lt;option value=&quot;湖南&quot;&gt;湖南省&lt;/option&gt;    &lt;option value=&quot;陕西&quot;&gt;陕西省&lt;/option&gt;    &lt;option value=&quot;海南&quot;&gt;海南省&lt;/option&gt;    &lt;option value=&quot;广东&quot;&gt;广东省&lt;/option&gt;    &lt;option value=&quot;湖北&quot;&gt;湖北省&lt;/option&gt;    &lt;option value=&quot;河南&quot;&gt;河南省&lt;/option&gt;  &lt;/select&gt;&lt;/template&gt;</code></pre><ol start="6"><li>下拉列表：多选择器<blockquote><p>如果下拉列表为多选择器，也就是每次可以选择多个列表项。</p></blockquote></li></ol><ul><li><code>v-model</code>指令后变量的类型为一个<strong>数组</strong>，用来收集多个<code>&lt;option&gt;</code>选项的<code>value</code>值，而非<code>text</code>的值。</li><li>默认刚开始没有选中任何一项，则<code>v-model</code>指令后变量的值为一个<code>[]</code>空数组</li></ul><pre><code>&lt;script&gt;export default &#123;  data() &#123;    return &#123;      // fruit: [&quot;苹果&quot;]  默认选中苹果      fruit: [],    &#125;;  &#125;,&#125;;&lt;/script&gt;&lt;template&gt;  &lt;h3&gt;你喜欢的水果：&#123;&#123; fruit &#125;&#125;&lt;/h3&gt;  &lt;select v-model=&quot;fruit&quot; multiple&gt;    &lt;option value=&quot;苹果&quot;&gt;苹果&lt;/option&gt;    &lt;option value=&quot;香蕉&quot;&gt;香蕉&lt;/option&gt;    &lt;option value=&quot;草莓&quot;&gt;草莓&lt;/option&gt;    &lt;option value=&quot;橘子&quot;&gt;橘子&lt;/option&gt;    &lt;option value=&quot;樱桃&quot;&gt;樱桃&lt;/option&gt;    &lt;option value=&quot;菠萝&quot;&gt;菠萝&lt;/option&gt;  &lt;/select&gt;&lt;/template&gt;</code></pre><h4 id="v-model-指令修饰符"><a href="#v-model-指令修饰符" class="headerlink" title="v-model 指令修饰符"></a>v-model 指令修饰符</h4><blockquote><p>为了方便收集表单中的数据，Vue 为<code>v-model</code>指令提供了以下 3 个修饰符。</p><table><thead><tr><th>修饰符</th><th>功能</th></tr></thead><tbody><tr><td>.lazy</td><td>默认情况下，v-model 会在每次 input 事件后更新数据，添加了.lazy修鉓符后会改为在每次 change 事件后更新数据</td></tr><tr><td>.number</td><td>可以让用户输入的内容自动转换为数字，不加.number修鉓符，内容默认为字符串</td></tr><tr><td>.trim</td><td>自动去除用户输入内容两端的空格 画画 跳舞 唱歌</td></tr></tbody></table></blockquote><blockquote><p>change 事件</p></blockquote><ul><li>在<code>select</code>元素上，<code>change</code>事件会在<strong>选择某个选项</strong>时发生。</li><li>当用于<code>&lt;input&gt;</code>或<code>&lt;textarea&gt;</code>元素时，<code>change</code>事件会在元素<strong>失去焦点</strong>时发生。</li></ul><pre><code>&lt;script&gt;export default &#123;  data() &#123;    return &#123;      username: &quot;&quot;,      age: 0,      hobbies: &quot;&quot;,    &#125;;  &#125;,&#125;;&lt;/script&gt;&lt;template&gt;  &lt;!--当input元素失去焦点后，更新msg变量的值--&gt;  &lt;div&gt;姓 名：&lt;input v-model.lazy=&quot;username&quot; /&gt; &#123;&#123; username &#125;&#125;&lt;/div&gt;  &lt;!--最终age的值为数字类型--&gt;  &lt;div&gt;年 龄：&lt;input v-model.number=&quot;age&quot; /&gt; &#123;&#123; typeof age &#125;&#125;&lt;/div&gt;  &lt;!--如果输入的内容前后有空格，会自动去除--&gt;  &lt;div&gt;    爱 好：&lt;input v-model.trim=&quot;hobbies&quot; /&gt; &#123;&#123; hobbies.length &#125;&#125;--&#123;&#123; hobbies &#125;&#125;  &lt;/div&gt;&lt;/template&gt;</code></pre><h3 id="六、class-类-与-style-样式绑定"><a href="#六、class-类-与-style-样式绑定" class="headerlink" title="六、class 类 与 style 样式绑定"></a>六、class 类 与 style 样式绑定</h3><blockquote><p>在实际的项目开发中，对于元素的<code>class</code>属性与<code>style</code>属性的操作是非常常见的需求。因为<code>class</code>与<code>style</code>都属于元素的属性，所以我们同样是利用<code>v-bind</code>来将他们与动态的字符串绑定。</p><p>因为<code>class</code>与<code>style</code>属性在操作时相对较复杂，所以<code>v-bind</code>指令在动态绑定<code>class</code>与<code>style</code>属性值时，其表达式的值除了”字符串”外，还可以是”对象或数组”</p></blockquote><h4 id="动态绑定-class-类"><a href="#动态绑定-class-类" class="headerlink" title="动态绑定 class 类"></a>动态绑定 class 类</h4><blockquote><p>我们可以使用<code>v-bind:class</code>（简写<code>:class</code>）为元素动态绑定<code>class</code>的值，<code>:class</code>绑定的值可以是：</p><ul><li>字符串</li><li>对象</li><li>数组<br>三者中的一种</li></ul></blockquote><ol><li>绑定字符串<blockquote><p>我们可以给<code>v-bind:class</code>（缩写:class）传递一个字符串类型的变量，为元素动态添加<code>class</code>属性值</p></blockquote></li></ol><pre><code>&lt;script&gt;export default &#123;  data() &#123;    return &#123;      className: &quot;bg-red&quot;,    &#125;;  &#125;,&#125;;&lt;/script&gt;&lt;template&gt;  &lt;!--最终渲染后元素的 class=&#39;bg-red&#39;--&gt;  &lt;div :class=&quot;className&quot;&gt;box&lt;/div&gt;&lt;/template&gt;</code></pre><ul><li>以下写法，vue最终自动:class 与class中的值合并在一起</li></ul><pre><code>&lt;div :class=&quot;className&quot; class=&quot;basic&quot;&gt;&lt;/div&gt;&lt;!--以上写法，最终渲染后结果如下--&gt;&lt;div class=&quot;bg-red baisc&quot;&gt;&lt;/div&gt;</code></pre><ol start="2"><li>绑定对象<blockquote><p>如果<code>:class</code>绑定的值为一个对象</p></blockquote></li></ol><ul><li>对象属性的值为<code>true</code>时，则对象的属性名会渲染成元素<code>class</code>属性中的值</li><li>如果对象属性的值为<code>false</code>，则该属性名不会出现在<code>class</code>属性中。</li></ul><pre><code>&lt;div class=&quot;basic&quot; :class=&quot;&#123; bgColor: true, radius: false &#125;&quot;&gt;box&lt;/div&gt;&lt;!--以上写法，最终渲染结果如下--&gt;&lt;div class=&quot;basic bgColor&quot;&gt;box&lt;/div&gt;</code></pre><ul><li>我们还可以将对象属性后面值改为变量，这样就可以通过 JS 来动态操作是否添加对应的<code>class</code></li></ul><pre><code>&lt;script&gt;export default &#123;  data() &#123;    return &#123;      isColor: true,      isRadius: false,    &#125;;  &#125;,  methods: &#123;    changeClass() &#123;      this.isRadius = true;    &#125;,  &#125;,&#125;;&lt;/script&gt;&lt;template&gt;  &lt;div    class=&quot;basic&quot;    :class=&quot;&#123; bgColor: isColor, radius: isRadius &#125;&quot;    @click=&quot;changeClass&quot;  &gt;    box  &lt;/div&gt;&lt;/template&gt;</code></pre><ul><li>我们也可以将<code>:class</code>后面字面量形式的对象，改为一个变量，这个变量的值是一个对象</li></ul><pre><code>&lt;script&gt;export default &#123;  data() &#123;    return &#123;      className: &#123;        bgColor: true,        radius: false,      &#125;,    &#125;;  &#125;,  methods: &#123;    changeClass() &#123;      this.className.radius = true;    &#125;,  &#125;,&#125;;&lt;/script&gt;&lt;template&gt;  &lt;div class=&quot;basic&quot; :class=&quot;className&quot; @click=&quot;changeClass&quot;&gt;box&lt;/div&gt;&lt;/template&gt;</code></pre><ol start="3"><li>绑定数组<blockquote><p>如果<code>:class</code>绑定的值为一个数组，数组中的每个成员都是一个字符串，那数组中的每个成员都会渲染成<code>class</code>属性的值</p></blockquote></li></ol><pre><code>&lt;div class=&quot;basic&quot; :class=&#39;[&quot;bgColor&quot;, &quot;radius&quot;]&#39;&gt;&lt;/div&gt;&lt;!--以上写法，最终渲染后效果如下--&gt;&lt;div class=&quot;basic bgColor radius&quot;&gt;&lt;/div&gt;</code></pre><ul><li>如果想通过 JS 来动态操作 class 的属性值，我们可以将数组中的每个成员，改成变量，如下：</li></ul><pre><code>&lt;script&gt;  export default &#123;    data() &#123;      return &#123;        isBgColor: &quot;bgColor&quot;,        isRadius: &quot;radius&quot;,      &#125;;    &#125;,  &#125;;&lt;/script&gt;&lt;template&gt;  &lt;div class=&quot;basic&quot; :class=&quot;[isBgColor, isRadius]&quot;&gt;&lt;/div&gt;&lt;/template&gt;</code></pre><ul><li>在实际开发中，上面这种方式还不是最优的，我们还可以直接绑定一个<strong>数组类型的变量</strong>，这样我们就可以通过 JS 操作数组中的成员来实现对 class 的新增、删除、更新。</li></ul><pre><code>&lt;script&gt;  export default &#123;    data() &#123;      return &#123;        arrClass: [&quot;bgColor&quot;, &quot;radius&quot;],      &#125;;    &#125;,    methods: &#123;      removeClass() &#123;        // 删除数组中最后一个元素        this.arrClass.pop();      &#125;,    &#125;,  &#125;;&lt;/script&gt;&lt;template&gt;  &lt;div class=&quot;basic&quot; :class=&quot;arrClass&quot; @click=&quot;removeClass&quot;&gt;&lt;/div&gt;&lt;/template&gt;</code></pre><ul><li>也可以在数组中通过三元表达式有条件的渲染某个 class</li></ul><pre><code>&lt;!--以下写法表示：    如果 isRadius为true,则向class中添加radius和bgColor，否则只添加bgColor--&gt;&lt;div class=&quot;basic&quot; :class=&quot;[isRadius ? &#39;radius&#39; : &#39;&#39;, &#39;bgColor&#39;]&quot;&gt;&lt;/div&gt;</code></pre><ul><li>如果有多个依赖条件的class,则代码显的有些冗长，因此也可以在数组中嵌套对象</li></ul><pre><code>&lt;div class=&quot;basic&quot; :class=&quot;[&#123; radius: isRadius &#125;, &#39;bgColor&#39;]&quot;&gt;&lt;/div&gt;</code></pre><h4 id="动态绑定-style-样式"><a href="#动态绑定-style-样式" class="headerlink" title="动态绑定 style 样式"></a>动态绑定 style 样式</h4><blockquote><p>我们可以通过<code>v-bind:style</code>（简写:style）来动态为元素添加<code>style</code>样式属性。</p><ul><li><code>:style</code>绑定的值可以是：</li></ul></blockquote><ul><li>样式字符串</li><li>样式对象</li><li>样式数组（数组中每个成员是一个样式类型的对象）</li></ul><ol><li>绑定样式字符串</li></ol><ul><li><code>:style</code>后的值为一个标准的 CSS 样式字符串</li></ul><pre><code>&lt;script&gt;export default &#123;  data() &#123;    return &#123;      styleCss: &quot;color:red;font-size:30px&quot;,    &#125;;  &#125;,&#125;;&lt;/script&gt;&lt;template&gt;  &lt;div :style=&quot;styleCss&quot;&gt;style样式绑定&lt;/div&gt;&lt;/template&gt;</code></pre><ol start="2"><li>绑定样式对象<blockquote><p><code>:style</code>后绑定的值为一个样式对象，即：对象中属性为 CSS 属性名，属性名推荐<code>camelCase</code>写法(驼峰命名法)，但也支持<code>kebab-cased</code>(短线连接命名法)写法。</p><ul><li>短线命名法，需要用单引号包裹</li></ul></blockquote></li></ol><pre><code>&lt;script&gt;  export default &#123;    data() &#123;      return &#123;        activeColor: &quot;red&quot;,        fontSize: &quot;30px&quot;,      &#125;;    &#125;,  &#125;;&lt;/script&gt;&lt;template&gt;  &lt;!-- 短线命名法，因为不符合规范，所以需要用单引号包裹--&gt;  &lt;div :style=&quot;&#123; color: activeColor, &#39;font-size&#39;: fontSize &#125;&quot;&gt;    style样式绑定  &lt;/div&gt;  &lt;!--以下写法为官方推荐写法，属性名采用 camelCase 写法--&gt;  &lt;div :style=&quot;&#123; color: activeColor, fontSize: fontSize &#125;&quot;&gt;style样式绑定&lt;/div&gt;&lt;/template&gt;</code></pre><ul><li><code>:style</code>后直接绑定一个变量，变量的值是一个样式对象。（此方式为最优绑定方式）</li></ul><pre><code>&lt;script&gt;export default &#123;  data() &#123;    return &#123;      styleObject: &#123;        color: &quot;red&quot;,        fontSize: &quot;30px&quot;,      &#125;,    &#125;;  &#125;,&#125;;&lt;/script&gt;&lt;template&gt;  &lt;div :style=&quot;styleObject&quot;&gt;style样式绑定&lt;/div&gt;&lt;/template&gt;</code></pre><ol start="3"><li>绑定样式数组<blockquote><p><code>:style</code>后绑定的值为一个数组，数组中的成员可以是一个样式<strong>对象</strong>，也可以是一个样式<strong>字符串</strong>，最终这些样式都会合并渲染到同一元素上。</p></blockquote></li></ol><pre><code>&lt;script&gt;export default &#123;  data() &#123;    return &#123;      // 基础样式      baseStyles: &#123;        width: &quot;100px&quot;,        height: &quot;100px&quot;,        backgroundColor: &quot;skyblue&quot;,      &#125;,      // 激活后样式      activeStyles: &#123;        fontSize: &quot;20px&quot;,        color: &quot;red&quot;,      &#125;,    &#125;;  &#125;,&#125;;&lt;/script&gt;&lt;template&gt;  &lt;div :style=&quot;[baseStyles, activeStyles, &#39;border-radius:50%&#39;]&quot;&gt;    style样式绑定  &lt;/div&gt;&lt;/template&gt;</code></pre><h4 id="class-与-style-与-计算属性"><a href="#class-与-style-与-计算属性" class="headerlink" title=":class 与 :style 与 计算属性"></a>:class 与 :style 与 计算属性</h4><ul><li>如果<code>:class</code>或<code>:style</code>后绑定的值需要经过相对复杂的逻辑运算才能得到，可以利用计算属性来实现。</li><li><code>:class</code>或<code>:style</code>后面直接绑定计算属性，计算属性的值为一个合格的**”字符串 或 对象或数组”**</li></ul><pre><code>&lt;script&gt;export default &#123;  data() &#123;    return &#123;      skinTheme: &quot;skyblue&quot;,    &#125;;  &#125;,  computed: &#123;    // 计算属性    skinStyle() &#123;      if (this.skinTheme === &quot;skyblue&quot;) &#123;        return [&quot;skyblue-bg&quot;, &quot;border-radius&quot;];      &#125; else if (this.skinTheme === &quot;yellow&quot;) &#123;        return [&quot;yellow-bg&quot;, &quot;border10&quot;];      &#125; else &#123;        return [&quot;pink-bg&quot;];      &#125;    &#125;,  &#125;,&#125;;&lt;/script&gt;&lt;template&gt;  &lt;select v-model=&quot;skinTheme&quot;&gt;    &lt;option&gt;skyblue&lt;/option&gt;    &lt;option&gt;yellow&lt;/option&gt;    &lt;option&gt;pink&lt;/option&gt;  &lt;/select&gt;  &lt;div :class=&quot;skinStyle&quot; class=&quot;basic&quot;&gt;&lt;/div&gt;&lt;/template&gt;</code></pre><h4 id="案例：开关效果"><a href="#案例：开关效果" class="headerlink" title="案例：开关效果"></a>案例：开关效果</h4><pre><code>&lt;script&gt;  export default &#123;    data() &#123;      return &#123;        isActive: false,      &#125;;    &#125;,  &#125;;&lt;/script&gt;&lt;template&gt;  &lt;div class=&quot;switch&quot; :class=&quot;&#123; active: isActive &#125;&quot;&gt;    &lt;span @click=&quot;isActive = !isActive&quot;&gt;&lt;/span&gt;  &lt;/div&gt;&lt;/template&gt;&lt;style scoped&gt;  .switch &#123;    width: 60px;    height: 30px;    border: 2px solid #ddd;    border-radius: 30px;    cursor: pointer;  &#125;  .switch span &#123;    width: 24px;    height: 24px;    display: block;    border-radius: 50%;    background-color: #ddd;    margin: 3px;    transition: all ease 1s;  &#125;  .switch.active &#123;    border: 2px solid skyblue;  &#125;  .switch.active span &#123;    background-color: skyblue;    transform: translateX(30px);  &#125;&lt;/style&gt;</code></pre><h4 id="案例：项目进度条"><a href="#案例：项目进度条" class="headerlink" title="案例：项目进度条"></a>案例：项目进度条</h4><blockquote><p>假设一个项目分四个阶段完成，我们会对项目每个阶段的完成进度进行评估。</p><ul><li>以下为项目各阶段的进度评估数据</li></ul></blockquote><pre><code>state: &#123;    /*        当前项目分四个阶段，0-4表示每个阶段的完成情况        0-此阶段还没开始   进度条显示灰色        1-提前完成    进度条显示 skyblue 天蓝色        2-正常完成   进度条显示  green 绿色        3-超时     进度条显示 orange 橘色        4-严重超时  进度条显示 red 红色    */    I_state: 1,    II_state: 3,    III_state: 2,    IIII_state: 0&#125;</code></pre><ul><li>我们需要根据每个阶段的完成进度，将进度条渲染成不同的颜色</li></ul><pre><code>&lt;script&gt;  export default &#123;    data() &#123;      return &#123;        state: &#123;          I_state: 1,          II_state: 3,          III_state: 2,          IIII_state: 4,        &#125;,        // 数组        arr: [&quot;&quot;, &quot;skyblue&quot;, &quot;green&quot;, &quot;orange&quot;, &quot;red&quot;],        // map        map: new Map([          [0, &quot;&quot;],          [1, &quot;skyblue&quot;],          [2, &quot;green&quot;],          [3, &quot;orange&quot;],          [4, &quot;red&quot;],        ]),      &#125;;    &#125;,  &#125;;&lt;/script&gt;&lt;template&gt;  &lt;!-- 方法1 --&gt;  &lt;div class=&quot;wrap&quot;&gt;    &lt;h3&gt;项目每个阶段的完成情况&lt;/h3&gt;    &lt;div class=&quot;progress-bar&quot;&gt;      &lt;span :class=&quot;arr[state.I_state]&quot;&gt;&lt;/span&gt;      &lt;span :class=&quot;arr[state.II_state]&quot;&gt;&lt;/span&gt;      &lt;span :class=&quot;arr[state.III_state]&quot;&gt;&lt;/span&gt;      &lt;span :class=&quot;arr[state.IIII_state]&quot;&gt;&lt;/span&gt;    &lt;/div&gt;  &lt;/div&gt;    &lt;!-- 方法2 --&gt;  &lt;div class=&quot;wrap&quot;&gt;    &lt;h3&gt;项目每个阶段的完成情况&lt;/h3&gt;    &lt;div class=&quot;progress-bar&quot;&gt;      &lt;span :class=&quot;map.get(state.I_state)&quot;&gt;&lt;/span&gt;      &lt;span :class=&quot;map.get(state.II_state)&quot;&gt;&lt;/span&gt;      &lt;span :class=&quot;map.get(state.III_state)&quot;&gt;&lt;/span&gt;      &lt;span :class=&quot;map.get(state.IIII_state)&quot;&gt;&lt;/span&gt;    &lt;/div&gt;  &lt;/div&gt;&lt;/template&gt;&lt;style&gt;  .wrap &#123;    width: 80%;    margin: 50px auto;  &#125;  .progress-bar &#123;    height: 10px;    display: flex;  &#125;  .progress-bar span &#123;    height: inherit;    flex: 1;    margin-right: 5px;    background-color: #ddd;  &#125;  .progress-bar span.skyblue &#123;    background-color: skyblue;  &#125;  .progress-bar span.green &#123;    background-color: green;  &#125;  .progress-bar span.orange &#123;    background-color: orange;  &#125;  .progress-bar span.red &#123;    background-color: red;  &#125;&lt;/style&gt;</code></pre><h3 id="七、条件渲染"><a href="#七、条件渲染" class="headerlink" title="七、条件渲染"></a>七、条件渲染</h3><blockquote><p>条件渲染是指根据条件来渲染一块内容，条件渲染指令有：<code>v-if</code>、<code>v-else</code>、<code>v-else-if</code>、<code>v-show</code></p></blockquote><ol><li>v-if 指令<blockquote><p><code>v-if</code>指令用于条件性地渲染一块内容。这块内容只会在指令的表达式返回真值时才被渲染。</p></blockquote></li></ol><pre><code>&lt;div v-if=&quot;true&quot;&gt;此处内容显示&lt;/div&gt;&lt;div v-if=&quot;false&quot;&gt;此处将不会渲染在页面中&lt;/div&gt;</code></pre><ol start="2"><li>v-else<blockquote><p><code>v-else</code>指令需要和<code>v-if</code>指令配合一起使用，其用法和功能与 JS 中的<code>if ...else</code> 一样</p></blockquote></li></ol><pre><code>&lt;!--v-if的值为false，则渲染v-else指令绑定的元素--&gt;&lt;div class=&quot;box1&quot; v-if=&quot;false&quot;&gt;此内容不会渲染在页面中&lt;/div&gt;&lt;div class=&quot;box2&quot; v-else&gt;此处内容显示&lt;/div&gt;&lt;!--v-if的值为true，则渲染v-if指令绑定的元素,v-else指令绑定的元素不会被渲染--&gt;&lt;div class=&quot;box1&quot; v-if=&quot;true&quot;&gt;此内容显示&lt;/div&gt;&lt;div class=&quot;box2&quot; v-else&gt;些内容不会渲染在页面中&lt;/div&gt;</code></pre><ol start="3"><li>v-else-if</li></ol><ul><li><code>v-else-if</code>需要与<code>v-if</code>指令配合，其的用法和功能与 JS 中的<code>if ...else if</code>一样，所以<code>v-else-if</code>指令可以连续多次重复使用。</li><li><code>v-if</code>、<code>v-else-if</code>、<code>v-else</code>可以组合一起使用，与JS中的<code>if..else if... else</code>用法和功能一样。</li></ul><pre><code>&lt;script&gt;  export default &#123;    data() &#123;      return &#123;        age: 40,      &#125;;    &#125;,  &#125;;&lt;/script&gt;&lt;template&gt;  &lt;div class=&quot;box1&quot; v-if=&quot;age &gt;= 60&quot;&gt;老年&lt;/div&gt;  &lt;div class=&quot;box2&quot; v-else-if=&quot;age &gt;= 30&quot;&gt;中年&lt;/div&gt;  &lt;div class=&quot;box3&quot; v-else-if=&quot;age &gt;= 18&quot;&gt;青年&lt;/div&gt;  &lt;div class=&quot;box3&quot; v-else-if=&quot;age &gt;= 12&quot;&gt;少年&lt;/div&gt;  &lt;div class=&quot;box4&quot; v-else&gt;儿童&lt;/div&gt;&lt;/template&gt;</code></pre><ol start="5"><li>注意事项<blockquote><p><code>v-if</code>、<code>v-else-if</code>、<code>v-else</code>这些指令之间必需紧跟的，中间不能有其它元素间隔着。</p></blockquote></li></ol><ul><li>如下写法将会抛出错误，代码无法正常运行</li></ul><pre><code>&lt;!--因为`.box`元素打断了`v-else-if`指令的连续性--&gt;&lt;div class=&quot;box1&quot; v-if=&quot;age &gt;= 60&quot;&gt;老年&lt;/div&gt;&lt;div class=&quot;box2&quot; v-else-if=&quot;age &gt;= 30&quot;&gt;中年&lt;/div&gt;&lt;div class=&quot;box&quot;&gt;这种写法将会报错，因为他打断了if指令的连续性&lt;/div&gt;&lt;div class=&quot;box3&quot; v-else-if=&quot;age &gt;= 18&quot;&gt;青年&lt;/div&gt;&lt;div class=&quot;box3&quot; v-else-if=&quot;age &gt;= 12&quot;&gt;少年&lt;/div&gt;&lt;div class=&quot;box4&quot; v-else&gt;儿童&lt;/div&gt;</code></pre><ol start="6"><li><code>v-if</code> 与 <code>&lt;template&gt;</code><blockquote><p>如果我们想在<code>v-if</code>指令为真时，显示<strong>一组</strong>元素，而不是单个元素，那要如何实现呢 ？</p></blockquote></li></ol><ul><li>方案一：显然代码写起来不够优雅</li></ul><pre><code>&lt;h3 v-if=&quot;person.age &gt; 30&quot;&gt;&#123;&#123; person.username &#125;&#125;相关信息如下&lt;/h3&gt;&lt;div v-if=&quot;person.age &gt; 30&quot;&gt;年龄：&#123;&#123; person.age &#125;&#125;&lt;/div&gt;&lt;div v-if=&quot;person.age &gt; 30&quot;&gt;年龄：&#123;&#123; person.sex &#125;&#125;&lt;/div&gt;</code></pre><ul><li>方案二：这种方案相比第一种要好些，但是让代码的层级变的更深了</li></ul><pre><code>&lt;div class=&quot;box1&quot; v-if=&quot;person.age &gt; 30&quot;&gt;  &lt;h3&gt;&#123;&#123; person.username &#125;&#125;相关信息如下&lt;/h3&gt;  &lt;div&gt;年龄：&#123;&#123; person.age &#125;&#125;&lt;/div&gt;  &lt;div&gt;年龄：&#123;&#123; person.sex &#125;&#125;&lt;/div&gt;&lt;/div&gt;</code></pre><ul><li>方案三：v-if指令与<template>标签配合，最终<template>不会被渲染到页面中。</li></ul><pre><code>&lt;!--最佳方案--&gt;&lt;template class=&quot;box1&quot; v-if=&quot;person.age &gt; 30&quot;&gt;  &lt;h3&gt;&#123;&#123; person.username &#125;&#125;相关信息如下&lt;/h3&gt;  &lt;div&gt;年龄：&#123;&#123; person.age &#125;&#125;&lt;/div&gt;  &lt;div&gt;年龄：&#123;&#123; person.sex &#125;&#125;&lt;/div&gt;&lt;/template&gt;</code></pre><ol start="7"><li>v-show<blockquote><p><code>v-show</code>指令用来按条件显示一个元素，其用法与<code>v-if</code>一样，但他与<code>v-if</code>有以下<strong>不同</strong>：</p></blockquote></li></ol><blockquote><p><code>v-if</code>指令</p></blockquote><ul><li><code>v-if</code>指令是将元素从 <code>DOM</code> 中移除来实现显示与隐藏</li><li><code>v-if</code>指令可以在<code>&lt;template&gt;</code>元素上使用</li><li><code>v-if</code>指令可以与<code>v-else</code>、<code>v-else-if</code>指令搭配使用</li></ul><blockquote><p><code>v-show</code>指令</p></blockquote><ul><li><code>v-show</code> 会在 DOM 渲染中保留该元素；<code>v-show</code>实现显示与隐藏，本质是通过操作元素的<code>display</code>属性来实现。</li><li><code>v-show</code> 不支持在 <code>&lt;template&gt;</code> 元素上使用</li><li><code>v-show</code>指令只能单独用，不能 <code>v-else</code> 等指令搭配使用</li></ul><pre><code>&lt;div v-show=&quot;true&quot;&gt;该元素最终显示在页面中&lt;/div&gt;</code></pre><ol start="8"><li>对比 v-if 与 v-show<blockquote><p><code>v-if</code>与<code>v-show</code>都可以用来控制元素的显示与隐藏，那实际开发中，我们应该如何选择呢？<br>我们通过对比<code>v-if</code>与<code>v-show</code>在性能上的细微差别来确定，我们应该在什么场景下使用他们更合理</p></blockquote></li></ol><blockquote><p><code>v-if</code> 的特点</p></blockquote><ul><li><code>v-if</code> 是“真实的”按条件渲染，因为它确保了在切换时，条件区块内的事件监听器和子组件都会被销毁与重建，所以每次切换时的开销会很大。</li><li><code>v-if</code> 也是惰性的，如果在初次渲染时条件值为 false，则不会做任何事，所以初次渲染时速度会很快。</li></ul><blockquote><p><code>v-show</code> 的特点</p></blockquote><ul><li>首次渲染时开销会很大，因为<code>v-show</code>元素无论初始条件如何，始终会被渲染，只是根据CSS的<code>display</code>属性来决定显示与隐藏。</li><li>后期切换时，性能消耗较小，因为切换只是在更改 css 的 <code>display</code> 属性值。</li></ul><blockquote><p>总结</p></blockquote><ul><li><code>v-if</code> 初次渲染开销少，而后期切换开销会更高； <code>v-show</code> 有更高的初始渲染开销，后期切换开销少</li><li>如果后期需要频繁切换，则使用 <code>v-show</code> 较好；如果在运行时绑定条件很少改变，则 <code>v-if</code> 会更合适。</li></ul><blockquote><p>注意</p></blockquote><ul><li>如果我们追求网站首屏的加载速度，即使后期切换开销高，在渲染首屏内容时，也要考虑使用<code>v-if</code></li></ul><h3 id="八、列表渲染"><a href="#八、列表渲染" class="headerlink" title="八、列表渲染"></a>八、列表渲染</h3><ol><li>v-for 基本用法<blockquote><p><code>v-for</code>指令本质就是通过循环方式来遍历数组或对象等，并将其渲染成一个列表。<br><code>v-for</code>指令的值需要使用<code>item in arr</code> 形式的特殊语法</p></blockquote></li></ol><ul><li><code>arr</code>是源数据的数组</li><li><code>item</code>是迭代项的别名（别名可以自定义）</li></ul><pre><code>&lt;script&gt;  export default &#123;    data() &#123;      return &#123;        arr: [&quot;人气TOP&quot;, &quot;爆款套餐&quot;, &quot;咖啡&quot;, &quot;奶茶&quot;, &quot;甜品小点&quot;],      &#125;;    &#125;,  &#125;;&lt;/script&gt;&lt;template&gt;  &lt;ul&gt;    &lt;!-- 以下方式相当于对数组arr进行迭代，item为迭代项--&gt;    &lt;li v-for=&quot;item in arr&quot;&gt;&#123;&#123; item &#125;&#125;&lt;/li&gt;  &lt;/ul&gt;&lt;/template&gt;</code></pre><blockquote><p>获取数组每项索引</p></blockquote><ul><li>如果我们想要在<code>v-for</code>遍历数组时拿到数组中每一项的索引，可以采取以下写法</li></ul><pre><code>&lt;ul&gt;  &lt;!-- 以下方式相当于对数组arr进行迭代，item为迭代项,index为每一项的索引--&gt;  &lt;li v-for=&quot;(item，index) in arr&quot;&gt;&#123;&#123; item &#125;&#125;&lt;/li&gt;&lt;/ul&gt;</code></pre><blockquote><p>用 of 作为分隔符来替代 in</p></blockquote><ul><li>我们也可以把<code>item in arr</code>中的<code>in</code>用<code>of</code>来代替，写成：<code>item of arr</code>，</li></ul><pre><code>&lt;li v-for=&quot;(item，index) of arr&quot;&gt;&#123;&#123; item &#125;&#125;&lt;/li&gt;</code></pre><ol start="2"><li>v-for 遍历对象<blockquote><p>v-for指令可以用来遍历一个对象的所有属性值，属性名，位置索引</p></blockquote></li></ol><ul><li>只遍历对象的属性值</li></ul><pre><code>&lt;!--以下方式相当于遍历对象myObject, value为属性值, 名字可自定义--&gt;&lt;li v-for=&quot;value in myObject&quot;&gt;&#123;&#123; value &#125;&#125;&lt;/li&gt;</code></pre><ul><li>同时遍历对象的属性值和属性名</li></ul><pre><code>&lt;!--value为对象属性值，key为对象的属性名--&gt;&lt;li v-for=&quot;(value,key) in myObject&quot;&gt;&#123;&#123; value &#125;&#125;&lt;/li&gt;</code></pre><ul><li>同时遍历对象的属性值、属性名、位置索引</li></ul><pre><code>&lt;!--value为对象属性值，key为对象的属性名,index为位置索引--&gt;&lt;li v-for=&quot;(value,key,index) in myObject&quot;&gt;&#123;&#123; value &#125;&#125;&lt;/li&gt;</code></pre><ol start="3"><li>v-for 与 整数<blockquote><p>v-for 可以直接接受一个整数值，如下：</p></blockquote></li></ol><pre><code>&lt;div v-for=&quot;n in 10&quot;&gt;&#123;&#123; n &#125;&#125;&lt;/div&gt;</code></pre><ul><li>以上代码相当于把div这个模板重复5次，最终渲染后效果如下：</li></ul><pre><code>&lt;div&gt;1&lt;/div&gt;&lt;div&gt;2&lt;/div&gt;&lt;div&gt;3&lt;/div&gt;&lt;div&gt;4&lt;/div&gt;&lt;div&gt;5&lt;/div&gt;</code></pre><ul><li>注意： n 的初始值是从 1 开始，而非 0</li></ul><ol start="4"><li>v-for 多层嵌套循环<blockquote><p>v-for与 JS 中使用 for 循环一样，可以嵌套使用。</p><ul><li>如下：</li></ul></blockquote></li></ol><pre><code>&lt;script&gt;export default &#123;  data() &#123;    return &#123;      dataInfo: [        [1, 2, 3],        [&quot;A&quot;, &quot;B&quot;, &quot;C&quot;],      ],    &#125;;  &#125;,&#125;;&lt;/script&gt;&lt;template&gt;  &lt;ul v-for=&quot;arr in dataInfo&quot;&gt;    &lt;li v-for=&quot;item in arr&quot;&gt;&#123;&#123; item &#125;&#125;&lt;/li&gt;  &lt;/ul&gt;&lt;/template&gt;</code></pre><ul><li>以上代码，最终编译后结果如下：</li></ul><pre><code>&lt;ul&gt;  &lt;li&gt;1&lt;/li&gt;  &lt;li&gt;2&lt;/li&gt;  &lt;li&gt;3&lt;/li&gt;&lt;/ul&gt;&lt;ul&gt;  &lt;li&gt;A&lt;/li&gt;  &lt;li&gt;B&lt;/li&gt;  &lt;li&gt;C&lt;/li&gt;&lt;/ul&gt;</code></pre><ol start="5"><li><code>v-for</code>与<code>&lt;template&gt;</code><blockquote><p>当需要使用<code>v-for</code>指令来渲染一个包含多个元素的块时，可以将多个元素包裹在<code>&lt;template&gt;</code>标签里。</p></blockquote></li></ol><ul><li>最终<code>&lt;template&gt;</code>标签不会出现在最终编译后的结果中</li></ul><ol start="6"><li>v-for 与 v-if 结合<blockquote><p>当一个元素节点上同时出现<code>v-if</code>与<code>v-for</code>时 ，<code>v-if</code>比<code>v-for</code>的优先级会<strong>更高</strong>。</p></blockquote></li></ol><ul><li>这就意味着<code>v-if</code>的条件中无法访问到 <code>v-for</code> 作用域内定义的变量别名。</li><li>以下代码会抛出一个错误，因为在<code>v-if</code>中是不能使用<code>v-for</code>中的<code>item</code></li></ul><pre><code>&lt;div  class=&quot;tr&quot;  v-for=&quot;(item, index) in productList&quot;  v-if=&quot;item.price &gt; 100&quot;&gt;&lt;/div&gt;</code></pre><ul><li>如果我们确实需要在<code>v-if</code>中访问到<code>v-for</code>中的变量，则可以在外新包装一层<code>&lt;template&gt;</code>标签，并将<code>v-for</code>移到<code>&lt;template&gt;</code>标签上。这样不但解决了这个问题，而且可读性也更高。</li></ul><pre><code>&lt;template v-for=&quot;(item, index) in productList&quot;&gt;  &lt;div class=&quot;tr&quot; v-if=&quot;item.price &gt; 100&quot;&gt;&lt;/div&gt;&lt;/template&gt;</code></pre><ol start="7"><li>v-for 与 解构赋值</li></ol><ul><li>v-for指令后的表达式中可以使用解构赋值。</li><li>如下：</li></ul><pre><code>&lt;script&gt;export default &#123;  data() &#123;    return &#123;      productList: [        &#123;          title: &quot;短袖T恤男夏季新款印花宽松休闲&quot;,          price: 39,        &#125;,      ],    &#125;;  &#125;,&#125;;&lt;/script&gt;&lt;template&gt;  &lt;ul&gt;    &lt;!--采用解构赋值，取出title与price--&gt;    &lt;li v-for=&quot;(&#123; title, price &#125;, index) in productList&quot; :key=&quot;index&quot;&gt;      &#123;&#123; index &#125;&#125;: &#123;&#123; title &#125;&#125; -- &#123;&#123; price &#125;&#125;    &lt;/li&gt;  &lt;/ul&gt;&lt;/template&gt;</code></pre><ol start="8"><li>key 属性</li></ol><ul><li><p>在利用<code>v-for</code>指令渲染元素列表示，官方推荐我们为每个元素添加一个特殊的<code>key</code>属性。</p></li><li><p>并且要求<strong>同一个父元素下的子元素</strong>的<code>key</code>属性的值是唯一的，重复的 <code>key</code> 将导致渲染异常</p></li><li><p><code>key</code>是一个特殊的属性，最终页面被渲染后，<code>key</code>不会出现在元素的身上</p></li><li><p><code>key</code> 属性主要作为 Vue 的虚拟 DOM 算法提示，在比较新旧节点列表时用于识别<code>vnode</code>。</p></li><li><p>在没有<code>key</code>的情况下，Vue 将使用一种最小化元素移动的算法，并尽可能地就地更新&#x2F;复用相同类型的元素。</p></li><li><p>如果传了 <code>key</code>，则将根据 <code>key</code> 的变化顺序来重新排列元素，并且将始终移除&#x2F;销毁 <code>key</code> 已经不存在的元素。</p></li><li><p>在利用<code>v-for</code>渲染列表时，添加<code>key</code>属性有利于提高后期渲染的速度，因为在后期渲染时，针对相同<code>key</code>的元素，如果内容没有变化则不会重新渲染而是<strong>复用</strong>之前的 DOM。</p></li><li><p>不过在使用<code>key</code>属性时，有两点要注意：</p><ul><li>属于同一父元素下的子元素的<code>key</code>必需是唯一的</li><li>如果<code>v-for</code>中是用来渲染列表，后期并<strong>不会对数据做增、删除操作</strong>，则<code>key</code>的值可以是每一项的索引</li><li>如果<strong>需要做增删除</strong>，则唯一值不能是<code>index</code>索引，而必需是其它唯一值</li></ul></li></ul><blockquote><p>注意：</p></blockquote><ul><li>在操作数组时，尽量不要更改原数组，可用展开运算符创建副本<ul><li><code>sort()</code>方法会更改原始数组</li></ul></li></ul><pre><code>// 错误写法 ，这样原数组会被修改this.productList.sort()// 正确写法 创建一个副本，利用这个副本来操作数据[...this.productList].sort()</code></pre><h3 id="九、其它内置指令"><a href="#九、其它内置指令" class="headerlink" title="九、其它内置指令"></a>九、其它内置指令</h3><blockquote><p>在前面我们学习了 Vue 相关的内置指令，如：</p><table><thead><tr><th>内置指令</th><th>说明</th></tr></thead><tbody><tr><td>v-bind</td><td>单向数据绑定，用来动态绑定元素的属性，简写成<code>:</code></td></tr><tr><td>v-model</td><td>双向数据绑定，常用在表单输入元素上</td></tr><tr><td>v-on</td><td>给元素绑定事件监听器，简写成：<code>@</code></td></tr><tr><td>v-if与v-else与v-else-if</td><td>根据表达式的真假性，来条件性地渲染元素</td></tr><tr><td>v-show</td><td>根据表达式的真假性，来改变元素的显示与隐藏</td></tr><tr><td>v-for</td><td>基于原始数据（数组、对象等）来渲染元素</td></tr></tbody></table></blockquote><ul><li>本小节，我们继续来学习 Vue 相关的其它内部指令：<code>v-text</code>、<code>v-html</code>、<code>v-once</code>、<code>v-cloak</code>、<code>v-pre</code></li></ul><ol><li>v-text 指令</li></ol><ul><li><code>v-text</code>指令用于更新元素的<code>innerText</code>文本内容，他会替换当前元素内的所有节点内容。</li><li><code>v-text</code>指令中的内容如果包含<code>html</code>标签，<code>html</code>标签并不会被编译，而是会当前字符串原样输出</li></ul><ol start="2"><li>v-html 指令<blockquote><p>v-html指令用于更新元素的<code>innerHTML</code>内容</p></blockquote></li></ol><ul><li>如果内容中包含<code>html</code>标签，会被正常显示</li><li>如果内容中包含 <code>Vue</code> 模板语法，则<strong>不会</strong>被解析</li></ul><blockquote><p>安全说明</p></blockquote><ul><li>在你的站点上动态渲染任意的 <code>HTML</code> 是非常危险的，因为它很容易导致 <code>XSS</code> 攻击。请只对可信任内容使用 <code>HTML</code> 插值，绝不要将用户提供的内容作为插值</li></ul><ol start="3"><li>v-once 指令</li></ol><ul><li><code>v-once</code>指令用来告诉<code>Vue</code>，当前元素只渲染一次，即初次渲染后，就不会再渲染了。</li><li>如果有些数据只需要初始渲染，后面不需要再维护这些数据，则可以添加<code>v-once</code>来提高性能</li></ul><ol start="4"><li>v-cloak 指令<blockquote><p><code>v-cloak</code>指令仅作为了解即可，该指令只在没有构建步骤的环境下需要使用</p></blockquote></li></ol><ul><li>当使用直接在 DOM 中书写的模板时，可能会出现一种叫做<strong>“未编译模板闪现”</strong>的情况：用户可能先看到的是还没编译完成的双大括号标签，直到挂载的组件将它们替换为实际渲染的内容。</li><li><code>v-cloak</code>指令本质是在元素身上添加了<code>v-cloak</code>这样一个自定义属性。不过这个属性在组件实例被挂后就会移除。</li><li><code>v-cloak</code>指令需要与<code>[v-cloak]&#123;display:none&#125;</code>这样的 CSS 规则配合使用，这样就可以在组件编译前被隐藏，编译后因为<code>v-cloak</code>属性移出，则元素显示。</li></ul><pre><code>&lt;style&gt;  [v-cloak] &#123;    display: none;  &#125;&lt;/style&gt;&lt;div id=&quot;app&quot;&gt;  &lt;div v-cloak&gt;&#123;&#123; message &#125;&#125;&lt;/div&gt;&lt;/div&gt;&lt;!-- 这里故意把js引入放在当前这个位置，这样网速很慢时，会先看到上面没有编译的DOM元素呈现在页面，Vue接管后，组件被挂载成功，看到的是编译后的内容，为了防止组件没有被编译挂载前，不要呈现在页面中，则需要加v-cloak指令，同时加上[v-cloak]&#123;display:none&#125; css样式--&gt;&lt;script src=&quot;https://unpkg.com/vue@3/dist/vue.global.js&quot;&gt;&lt;/script&gt;&lt;script&gt;  const &#123; createApp &#125; = Vue;  const app = createApp(&#123;    data() &#123;      return &#123;        message: &quot;Hello Vue!&quot;,      &#125;;    &#125;,  &#125;);  const vm = app.mount(&quot;#app&quot;);&lt;/script&gt;</code></pre><ol start="5"><li>v-pre 指令<blockquote><p><code>v-pre</code>指令用于告诉 Vue，可以跳过该元素及其所有子元素的编译。也就是当前元素及其子元素写成什么样就按<strong>原样输出</strong>，并不会对内部的模板语法做任何解析。</p></blockquote></li></ol><blockquote><p><code>v-pre</code>指令应用场景</p></blockquote><ul><li>如果在项目中有些节点确实不需要编译（即节点中没有使用 Vue 语法），可以添加<code>v-pre</code>指令，能提高编译的速度</li></ul>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Vue </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Vue（一）</title>
      <link href="/2024/01/21/Vue%EF%BC%88%E4%B8%80%EF%BC%89/"/>
      <url>/2024/01/21/Vue%EF%BC%88%E4%B8%80%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<span id="more"></span><h2 id="Vue快速入门"><a href="#Vue快速入门" class="headerlink" title="Vue快速入门"></a>Vue快速入门</h2><h3 id="一、为什么需要-Vue-框架"><a href="#一、为什么需要-Vue-框架" class="headerlink" title="一、为什么需要 Vue 框架"></a>一、为什么需要 Vue 框架</h3><blockquote><p>首先，仅凭HTML5+CSS3+JS+HTTP 协议+Ajax，已经可以与后端开发配合，开发一个完整 Web 应用了</p><p>那为什么我们还需要学习 Vue 框架呢 ？要解决这个疑问，我们就得先从 Web 前端技术的发展历程讲起</p></blockquote><h4 id="Web-前端技术的发展"><a href="#Web-前端技术的发展" class="headerlink" title="Web 前端技术的发展"></a>Web 前端技术的发展</h4><blockquote><p>关于 Web 前端技术的发展，我们从 Web 应用开发的三个阶段来展开学习：</p><ul><li>前后端不分离</li><li>前后端分离</li><li>前端工程化<img src="前端技术的发展.png"></li></ul></blockquote><h5 id="前后端不分离"><a href="#前后端不分离" class="headerlink" title="前后端不分离"></a>前后端不分离</h5><ul><li>早期（1995 年）以前，Web 应用主要是静态网页的浏览，技术主要以 HTML+CSS 为主</li><li>在 1995 年，网景公司的工程师 Brendan Eich（布兰登·艾奇） 用 10 天时间设计了 JavaScript，随后的网页中开始诞生了动画特效。但是，Web 的应用主要还是静态网页的浏览，只是比之前多了些特效罢了。</li><li>再之后，更多的应用需要根据用户的请求动态生成页面信息，复杂一点的还需要从数据库中查询数据，经过一定的运算，生成一个 HTML 页面返回给用户。</li><li>在 2004 年以前，前端工作主要交由美工来负责。美工利用 HTML+CSS+JS 来编写静态网页，然后后端开发人员利用服务端技术从服务器的数据库中把数据查出来，绑定到 HTML 页面中，实现根据用户的请求动态生成 HTML 页面信息。这个时候，浏览器拿到的是服务端渲染好的 HTML 页面，然后展示在浏览器端</li></ul><blockquote><p>前后端不分离，带来的问题</p></blockquote><ul><li>HTML 页面由服务端渲染，每一次数据的交互都要全局刷新，影响用户体验</li><li>前后端串行开发，开发时间相对较长</li><li>前后端代码揉在一起，开发维护成本高</li></ul><h5 id="前后端分离"><a href="#前后端分离" class="headerlink" title="前后端分离"></a>前后端分离</h5><ul><li>在 2004，Google 发布了 Gmail（一款电子邮件应用），其利用的就是 Ajax 技术，用户可以在不刷新页面的情况下进行复杂的交互，之后，Ajax 逐渐成为网页开发的技术标准，也不断地被应用于各种网站。</li><li>2005 年，<code>XMLHttpRequest</code>对象发请求的技术正式取名为<code>AJAX</code></li><li>Ajax 这个技术让我们可以异步的获取数据并且刷新页面，从此前端不再受限于后端的模板，这也宣告了 Web2.0 时代正式到来。至此，前端工程师也正式作为一个独立工种出现。</li><li>在之后的一段时间里，前端的工作主要在于利用 <code>HTML+CSS+Jquery+JS+BootStrap</code> 等开发网页，同时利用 <code>Ajax</code> 向后端发送请求，拿到后端返回的(XML 或 JSON)等格式的数据做渲染，在渲染时，要做大量的 <code>DOM</code> 操作。而后端只需要专注于业务逻辑的处理，返回（XML 或 JSON）格式的数据</li><li>同时前后端可以并行开发，开发的时间成本降低了。同时前后端分离，维护成本降低，当布局需要变动，内容不变时，只需要变动前端布局就好，后端就可以不动</li></ul><blockquote><p>前后端分离，带来的新问题</p></blockquote><ul><li>前端开发在数据渲染时，需要大量的 DOM 操作，非常繁琐和耗时。所以那个时候 JQuery 非常流行，虽然他可以帮助我们简化 DOM 的操作，但依然还是需要大量操作 DOM</li><li>因为数据都是在浏览器端通过 Ajax 请求获取的，然后渲染在页面中。所以爬虫在爬取页面内容时，没有什么有用的实质性内容可获取，页面只有一些简单的 HTML 结构，所以对 SEO 优化非常不友好</li></ul><h5 id="前端工程化"><a href="#前端工程化" class="headerlink" title="前端工程化"></a>前端工程化</h5><ul><li>在 2009 年 <code>AngularJS</code> 和 <code>Node.js</code> 的诞生，也宣告前端工程化时代的到来。<ul><li><code>AngularJS</code> 的诞生，引领了前端 MVVM 模式的潮流。</li><li><code>Node.js</code> 的诞生，让前端有了入侵后端的能力，也加速了前端工程化的诞生。</li></ul></li><li>2013 年 <code>Vue</code> 框架诞生了。</li><li><code>Vue</code>、<code>Angular</code>、<code>React</code> 这类前端框架，可以帮助我们解决在前端数据渲染时，不需要再关注于 DOM 的操作，而只需要关注于业务逻辑的处理。</li><li>Vue 等前端框架让前端工程师从大量的 DOM 操作中解放出来，但依然对 SEO 不友好，因为他本质也是通过 Ajax 请求，向后台拿到数据，在前端渲染。</li><li>不过，现在 Vue 提供了<code>@vue/server-renderer</code>插件，可以在服务器端解析 Vue 的组件，直接把渲染结果返回给浏览器。这样 SEO 不友好的问题也就解决了</li></ul><h4 id="前端框架介绍"><a href="#前端框架介绍" class="headerlink" title="前端框架介绍"></a>前端框架介绍</h4><h4 id="什么是框架"><a href="#什么是框架" class="headerlink" title="什么是框架"></a>什么是框架</h4><ul><li>如果，你想要有一个自己的房子，按正常流程，你得自己从 0 开始一点一点的修建，至少需要一年的时间，但这样太费时了。如果有人把房子的框架都搭好了，（比如：开房商提供的毛坯房），你只需要按自己喜欢的风格来装修就好，这样是不是 2-3 个月就能入住了，大大的缩减了建房子的时间。</li><li>上面例子中毛坯房相比装修好的房子，毛坯房就是房子的框架，有了毛坯房，就不需要再从 0 开始搭建房子了，直接进入装修环节就好，这样省时有省力。</li></ul><h5 id="框架帮我们做了什么"><a href="#框架帮我们做了什么" class="headerlink" title="框架帮我们做了什么"></a>框架帮我们做了什么</h5><ul><li>从上面的例子中，我们知道，如果直接选用毛坯房，那我们就不需要再从 0 开始修建房子了，直接装修就好。所以框架帮我们把原来属于我们自己要做的那一部分工作给做掉了，我们只需要在这个基础之上，做其它的后续工作就可以。</li><li>同理，前端框架就是帮开发人员把原本属于开发人员的一部分工作给做掉了，开发人员只需要在这个基础之上，做其它工作。</li></ul><h5 id="前端流行框架有那些"><a href="#前端流行框架有那些" class="headerlink" title="前端流行框架有那些"></a>前端流行框架有那些</h5><ul><li>目前前端流行的框架主要有<code>Vue、React、Angular</code>。这些框架的目标都是为了帮助开发者高效地开发 Web 应用，只不过走的路线略显不同<blockquote><ul><li><code>React</code>注重数据不可变、虚拟 DOM 和运行时。</li><li><code>Angular</code>则在抽象这个维度又走向一个极致，生来就是为了复杂项目</li><li><code>Vue</code>相比前两种框架要简单多了，简单到大部分前端开发者都能学得会。<code>Vue</code> 在每个维度之间，做了非常好的权衡和取舍，算是一个非常中庸且优雅的框架，兼顾响应式、虚拟 DOM、运行时和编译优化</li></ul></blockquote></li></ul><h5 id="Vue-框架帮我们做了什么"><a href="#Vue-框架帮我们做了什么" class="headerlink" title="Vue 框架帮我们做了什么"></a>Vue 框架帮我们做了什么</h5><blockquote><p>作为前端开发人员，如果你想配合后端，开发出一个完整的 Web 网站或应用等。</p></blockquote><ul><li>在没有应用 Vue 框架前，你需要利用 <code>HTML+CSS+JS</code> 来开发 <code>HTML</code> 网页，同时利用 <code>Ajax</code> 请求向后端获取 <code>JSON</code> 数据，然后利用 <code>JS</code> 操作 <code>DOM</code> 将数据渲染到 <code>HTML</code> 中。</li><li>如果有了 Vue 框架，就不再需要利用 JS 操作 DOM 将数据渲染到 HTML 中，<strong>因为 Vue 框架帮你做了这部分工作</strong></li><li>Vue 框架本质就是帮我们把 JS 操作 DOM 的这一套逻辑业务代码写好了，我们只需在这个基础做后续开发。</li></ul><h4 id="MVVM-模式"><a href="#MVVM-模式" class="headerlink" title="MVVM 模式"></a>MVVM 模式</h4><blockquote><p>前端框架几乎都是采用典型的 MVVM 设计模型，那 Vue 也不例外。MVVM 是 <code>Model-View-ViewModel</code> 的简写。</p></blockquote><table><thead><tr><th>MVVM</th><th>模式</th><th>说明</th></tr></thead><tbody><tr><td>Model 模型</td><td>用于封装应用的业务逻辑和数据。在 Vue 框架中书写在<code>&lt;script&gt;</code>标签中的代码</td><td></td></tr><tr><td>View 视图</td><td>用于封装 UI 和 UI 逻辑，也就是我们常写的 HTML 与 CSS 相关的代码。就好比上面的 HTML 模块</td><td></td></tr><tr><td>ViewModel 视图模型</td><td>他主要是将 Model 与 View 结合到一起，封装了将他们结合到一起的底层逻辑；Vue 框架负责的就是 VM 的工作，通过 Vue 可以将视图和模型相关联，省去了开发人员手动操作 DOM 的工作</td><td></td></tr></tbody></table><ul><li>我们可以把上面的 <code>VM</code> 看作<code>Vue</code>框架，那<code>Vue</code>负责 VM（视图模型）的工作，通过<code>Vue</code>可以将视图和模型相关联。</li><li>当<code>Model</code>模型（JS 数据）发生变化时，会通知<code>ViewModel</code>，<code>ViewModel</code>会控制视图自动更新</li><li>当 <code>View</code> 视图（如：表单数据）发生变化时，也会通知 <code>ViewModel</code>，<code>ViewModel</code>会控制<code>Model</code>自动更新数据。<blockquote><ul><li>以上工作模式，也是 <code>Vue</code> 框架的一个核心特点：响应式</li></ul></blockquote></li></ul><h3 id="二、Vue-简介"><a href="#二、Vue-简介" class="headerlink" title="二、Vue 简介"></a>二、Vue 简介</h3><h4 id="什么是-Vue"><a href="#什么是-Vue" class="headerlink" title="什么是 Vue"></a>什么是 Vue</h4><ul><li>Vue 是一款用于构建<strong>用户界面</strong>的 JavaScript 框架。它基于标准 HTML、CSS 和 JavaScript 构建，并提供了一套<strong>声明式</strong>的、<strong>组件化</strong>的编程模型，帮助你高效地开发用户界面。无论是简单还是复杂的界面，Vue 都可以胜任。</li><li>用户界面：是指系统和用户之间进行交互和信息交换的媒介。比如：电脑屏幕，手机等电子设备屏幕。这里你可以理解为，客户端界面要呈现的内容，可以用 Vue 来构建。</li></ul><h5 id="1-声明式与命令式"><a href="#1-声明式与命令式" class="headerlink" title="1. 声明式与命令式"></a>1. 声明式与命令式</h5><blockquote><p>要了解什么是声明式，最好与命令式结合在一起来学习，这样能帮助我们更好的理解声明式。</p></blockquote><ul><li>命令式：更关注过程</li><li>声明式：更关注结果</li></ul><blockquote><p>我们先用一个生活中的例子，来帮助我们理解。比如，你想要你男朋友帮你倒杯水<br><strong>如果用命令式：</strong></p><ul><li>你要对他说：“先到餐桌 -&gt; 拿起我的水杯 -&gt; 转身 -&gt; 向前走 -&gt; 把杯子放在饮水机下 -&gt; 按下开关 -&gt; 端水 -&gt; 走到我面前”，然后才能喝到水。</li></ul><p><strong>如果用声明式：</strong></p><ul><li>你只需要对他说：“我口渴了 -&gt; 想喝水”，他就会把水端到你面前，你就能喝到水了。</li></ul></blockquote><h5 id="2-命令式框架与声明式框架"><a href="#2-命令式框架与声明式框架" class="headerlink" title="2. 命令式框架与声明式框架"></a>2. 命令式框架与声明式框架</h5><blockquote><p>视图层框架通常分为命令式和声明式，JQuery 就是典型的命令式框架，Vue 就是典型的声明式框架</p></blockquote><ul><li>命令式框架（JQuery 框架）</li></ul><pre><code>&lt;!--引入Jquery框架(插件)--&gt;&lt;script src=&quot;https://cdn.bootcdn.net/ajax/libs/jquery/3.6.4/jquery.min.js&quot;&gt;&lt;/script&gt;&lt;div id=&quot;app&quot;&gt;  &lt;div class=&quot;box&quot;&gt;&lt;/div&gt;&lt;/div&gt;&lt;!--JQuery代码--&gt;&lt;script&gt;  $(&quot;.box&quot;).on(&quot;click&quot;, function () &#123;    $(this).text(&quot;Hello&quot;);  &#125;);&lt;/script&gt;&lt;!--    上面代码，相当于在执行以下几个步骤        1、获取.box元素        2、给.box元素绑定click事件        3、当click事件触发后，为.box元素添加内容为&quot;hello&quot;--&gt;</code></pre><ul><li>命令式编程(原生 JS 代码)</li></ul><pre><code>// 1、获取.box元素const box = document.querySelector(&quot;.box&quot;);// 2、.box绑定click事件box.onclick = function () &#123;  // 3、将box的内容更新为Hello  this.innerText = &quot;Hello&quot;;&#125;;</code></pre><blockquote><p>通过上面 <code>JQuery</code> 和 原生 <code>JS</code> 代码 代码可以看到，代码描述的是实现最终效果要经过的<strong>具体步骤</strong>，更关注“做事的过程”，当然这更符合我们的逻辑，只是代码写起来比较麻烦。</p></blockquote><ul><li>声明式框架 （采用 Vue）</li></ul><pre><code>&lt;!---引入Vue框架--&gt;&lt;script src=&quot;https://unpkg.com/vue@3/dist/vue.global.js&quot;&gt;&lt;/script&gt;&lt;!--声明式--&gt;&lt;div id=&quot;app&quot;&gt;  &lt;div @click=&quot;show&quot; class=&quot;box&quot;&gt;&#123;&#123;message&#125;&#125;&lt;/div&gt;&lt;/div&gt;&lt;!--Vue代码--&gt;&lt;script&gt;  const &#123; createApp &#125; = Vue;  createApp(&#123;    data() &#123;      return &#123;        message: &quot;&quot;,      &#125;;    &#125;,    methods: &#123;      show() &#123;        this.message = &quot;Hello&quot;;      &#125;,    &#125;,  &#125;).mount(&quot;#app&quot;);&lt;/script&gt;</code></pre><blockquote><p>以上代码，重点关注 <code>HTML</code> 部分代码，这就是 Vue 帮我们实现以上功能的方式。可以看到，我们提供的是一个“结果”。</p><p>至于具体的实现过程，我们不需要关注，Vue.js 会帮我们完成。换句话说，Vue.js 帮我们封装了整个 JS 操作 DOM 的过程，因此，我们可以猜想，Vue.js 的内部实现一定是命令式的，而暴露给用户的却是声明式的</p></blockquote><h5 id="3-组件化"><a href="#3-组件化" class="headerlink" title="3. 组件化"></a>3. 组件化</h5><blockquote><p>组件允许我们将<code>UI</code>划分为独立的、可重用的部分，并且可以对每个部分进行单独的思考。</p></blockquote><ul><li><p>在实际应用中，组件常常被组织成层层嵌套的树状结构</p><img src="组件化树状结构.png"></li><li><p>上图左侧的网页，由一个根组件 <code>Root</code> 开始，在根组件 <code>Root</code> 中包含 <code>Header、Main、Aside</code> 子组件，在 <code>Main</code> 和 <code>Aside</code> 组件中，又可以放很多的子组件。</p></li></ul><blockquote><p>在 Vue 中：</p></blockquote><ul><li>组件本质就是一组 DOM 的封装，用来显示具体功能的 UI 界面。</li><li>一个完整的 Vue 组件包含 <code>HTML、CSS、JS</code> 三部分。当我们需要在多个页面实现相同的功能的 UI 时，就可以把这部分功能的(CSS、HTML、JS)抽离出去，做成一个单独的组件，然后实现复用。</li></ul><blockquote><p>注：区分模块化与组件化</p></blockquote><ul><li>模块化强调的是把一个大的 JS 文件拆分成许多具有独立功能的小的 JS 文件，从而实现代码复用</li><li>组件化强调的把一个大的 UI 界面，拆分成许多具有独立功能的小 UI，从而实现 UI 界面的复用</li></ul><h5 id="4-渐进式"><a href="#4-渐进式" class="headerlink" title="4. 渐进式"></a>4. 渐进式</h5><blockquote><p>在 Vue 的官网，开篇就提到，Vue 是一个 <code>Javascript</code> 渐进式框架，那什么是渐进式呢？</p></blockquote><ul><li><p>所谓渐进式，就是把框架进行分层设计，每层都是<strong>可选</strong>的，不同层可以灵活地替换为其他的方案。</p></li><li><p>Vue 渐进式框架分层结构下如图：</p><img src="Vue%20渐进式框架分层结构.png"></li><li><p>Vue <strong>最核心</strong>的部分就是他的声明式渲染，向外是组件系统，在这个基础上再加入路由系统和状态管理，最外层是构建系统。</p></li></ul><table><thead><tr><th></th><th>组合</th><th>说明</th></tr></thead><tbody><tr><td>组合一</td><td>声明式渲染</td><td>当我们开发的页面很简单，可以把<code>Vue.js</code>作为一个<code>JS</code>库来使用，只使用他的声明式渲染来帮我们轻松地操作<code>DOM</code>，实现数据变化的自动视图渲染</td></tr><tr><td>组合二</td><td>声明式渲染+组件系统</td><td>当我们开发的页面较复杂，想要把界面元素组件化，就可以在组合一的基础上加入<code>Vue</code>的组件系统，将界面的部分功能开发成一个组件，采用分而治之的策略，而且还可以实现功能的复用。</td></tr><tr><td>组合三</td><td>声明式渲染+组件系统+路由系统</td><td>如果想要将前端做成单页面应用程序，可以在组合二的基础上加入<code>Vue</code>的路由系统<code>VueRouter</code>,实现单页面应用。</td></tr><tr><td>组合四</td><td>声明式渲染+组件系统+路由系统+状态管理</td><td>如果我们的项目较复杂，应用中有很多数据需要在多个组件间共享，就可以在组合二或三的基础上引入<code>Vuex</code>或<code>Pinia</code>统一对状态（数据）进行管理</td></tr><tr><td>组合五</td><td>声明式渲染+组件系统+路由系统+状态管理+构建系统</td><td>如果你不想手动的从0开始搭建一个<code>Vue</code>项目，可以引入<code>Vue</code>的构建系统，他可以轻松地帮你搭建一个脚手架项目。然后在这个基础上开发你的Web应用</td></tr></tbody></table><ul><li>注：在实际开发中，我们的项目都不会太小，所以我们通常会选择组合五来开发我们的项目</li></ul><h4 id="Vue-发展历程简介"><a href="#Vue-发展历程简介" class="headerlink" title="Vue 发展历程简介"></a>Vue 发展历程简介</h4><blockquote><p>最开始尤雨溪在 Google 公司工作，在工作中用到 Angular 框架，他觉得 Angular 框架太重了，然后慢慢就萌芽出一个想法，想自己开发出一个轻量级的框架出来。最开始他开发的这个框架叫 Seed，后来更名为 Vue，版本 0.6.0</p></blockquote><ul><li>2013 年 12 月 7 日发布了 Vue 的 0.6.0 版本，也就是 Vue 框架诞生了。</li><li>2014 年 Vue 正式对外发布，版本号 0.8.0</li><li>2015 年 10 月 27 日，正式发布 Vue1.0.0 Evangellon（新世纪福音战士）</li><li>2016 年 10 月 1 日，正式发布 Vue2.0.0 Ghost in the Shell （攻壳机动队）</li><li>2020 年 9 月 18 日，正式发布 Vue3.0.0 One Piece（海赋王）</li></ul><blockquote><p>题外话</p></blockquote><ul><li>Vue 之所以能火起来，除了它本身确实好用之外，还有一个重要的原因就是<code>Taylor Otwell</code> 的推荐。<code>Taylor Otwel</code>是 <code>PHP Web</code> 开发框架 <code>Laravel</code> 之父，他在圈里面非常有名气，而且粉丝量特别庞大。</li><li>在 2014 年的某一天，他在 Twitter 上发表动态，说自己正在学习 <code>Vue.js</code>，觉得还不错。他这一说，就相当于给 Vue 在程序员圈子里打了个广告，所以更多的人知道了 Vue，并学习他，慢慢的就火起来了。</li></ul><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><blockquote><p>Vue 框架的三大特点：</p></blockquote><ul><li><code>Vue</code>框架为典型的声明式框架，借助<code>Vue</code>框架我们不再需要手动操作 DOM</li><li><code>Vue</code>支持组件化开发，可以将 UI 抽离成单独的组件，从页实现 UI 的复用</li><li><code>Vue</code>是一个渐进式框架，我们可以根据项目的需要来选择使用<code>Vue</code>的五大核心功能：声明式渲染、组件系统、路由系统、状态管理、构建系统</li></ul><h3 id="三、创建一个-Vue-应用"><a href="#三、创建一个-Vue-应用" class="headerlink" title="三、创建一个 Vue 应用"></a>三、创建一个 Vue 应用</h3><blockquote><p>在项目中使用 Vue，方式有如下三种：</p><ul><li>在实际的开发中，主要用到的是第三种方式，前两种方式在实际的开发中几乎不用。</li></ul></blockquote><ul><li>通过 CDN 来使用 Vue</li><li>通过原生的 ES 模块使用 Vue</li><li>通过 Vue 脚手架来使用 Vue</li></ul><h4 id="通过-CDN-来使用-Vue"><a href="#通过-CDN-来使用-Vue" class="headerlink" title="通过 CDN 来使用 Vue"></a>通过 CDN 来使用 Vue</h4><blockquote><p>借助 script 标签直接通过 CDN 来使用 Vue</p></blockquote><ul><li>使用全局构建版本<blockquote><ul><li>以下代码就相当添加了全局变量 <code>Vue</code></li></ul></blockquote></li></ul><pre><code>&lt;script src=&quot;https://unpkg.com/vue@3/dist/vue.global.js&quot;&gt;&lt;/script&gt;&lt;div id=&quot;app&quot;&gt;&#123;&#123; message &#125;&#125;&lt;/div&gt;&lt;script&gt;  const &#123; createApp &#125; = Vue    createApp(&#123;    data() &#123;      return &#123;        message: &#39;Hello Vue!&#39;      &#125;    &#125;  &#125;).mount(&#39;#app&#39;)&lt;/script&gt;</code></pre><ul><li>通过原生的 ES 模块使用 Vue</li></ul><pre><code>&lt;div id=&quot;app&quot;&gt;&#123;&#123; message &#125;&#125;&lt;/div&gt;&lt;script type=&quot;module&quot;&gt;  import &#123; createApp &#125; from &#39;https://unpkg.com/vue@3/dist/vue.esm-browser.js&#39;    createApp(&#123;    data() &#123;      return &#123;        message: &#39;Hello Vue!&#39;      &#125;    &#125;  &#125;).mount(&#39;#app&#39;)&lt;/script&gt;</code></pre><h4 id="创建应用实例"><a href="#创建应用实例" class="headerlink" title="创建应用实例"></a>创建应用实例</h4><ul><li>首先要解构 Vue 对象中的的<code>createApp</code>方法<ul><li>上面两种方法分别使用了不同的方式来解构</li></ul></li><li>然后使用<code>createApp</code>方法<ul><li>如果本页面就是根组件，就直接传入由属性组成的对象</li></ul></li></ul><pre><code>createApp(&#123;    data() &#123;      return &#123;        message: &#39;Hello Vue!&#39;      &#125;    &#125;  &#125;)</code></pre><ul><li>如果根组件是单文件组件，先导入根组件，再使用：</li></ul><pre><code>import App from &quot;./app.js&quot;;const app = createApp(App);</code></pre><h4 id="template-属性"><a href="#template-属性" class="headerlink" title="template 属性"></a>template 属性</h4><ul><li>根组件对象身上有一个<code>template</code>属性<strong>（可选）</strong>，用于声明组件的<strong>字符串模板</strong>。</li><li><code>template</code>属性中的html字符串最终会被 Vue 编译成真实的 HTML 元素），添加到页面中</li></ul><pre><code>const app = createApp(&#123;  template: &quot;&lt;div&gt;Hello Vue&lt;/div&gt;&quot;,&#125;);</code></pre><ul><li>上面的根组件最终被渲染成如下html代码</li></ul><pre><code>&lt;div&gt;Hello Vue&lt;/div&gt;</code></pre><ul><li>不过此时，它还是<strong>虚拟DOM</strong>，需要用<code>mount</code>方法挂载到页面上</li></ul><blockquote><p>如果没有<code>template</code>属性，组件会以<code>mount()</code>方法传入的参数（CSS 选择器）选择的元素的<code>innerHTML</code>作为渲染的模板。</p></blockquote><pre><code>&lt;div id=&quot;app&quot;&gt;//这就是 app 元素的`innerHTML`  &lt;div&gt;&#123;&#123;message&#125;&#125;&lt;/div&gt;&lt;/div&gt;</code></pre><ul><li>以上方式仅做了解，在实际项目中几乎不用，因为后期开发主要采用的是组件化开发</li></ul><h4 id="mount-方法"><a href="#mount-方法" class="headerlink" title="mount 方法"></a>mount 方法</h4><ul><li>调用<code>createApp()</code>方法创建的应用实例 <code>app</code> 身上的<code>mount()</code>方法，来实现<strong>挂载</strong>。</li><li>挂载：是指将生成的HTML元素，添加到真实的页面中去。</li><li><code>mount()</code>方法需要传一个的<strong>css 选择器</strong>字符串作为参数，用来告诉 Vue，把<code>template</code>模块中渲染后的内容添加到页面的那个 HTML 元素（容器）内。</li><li><code>mount()</code>方法的返回值为根组件实例对象</li></ul><pre><code>const app = createApp(&#123;  template: &quot;&lt;div&gt;Hello Vue&lt;/div&gt;&quot;,&#125;);// root为根组件实例对象const root = app.mount(&quot;#app&quot;);// mount的方法，就相当于把template中的内容赋值给到#app元素的innerHTML属性。</code></pre><ul><li>以上代码，最终在浏览器显示的 HTML 结构如下</li></ul><pre><code>&lt;div id=&quot;app&quot;&gt;  &lt;div&gt;Hello Vue&lt;/div&gt;&lt;/div&gt;</code></pre><h4 id="data-属性"><a href="#data-属性" class="headerlink" title="data 属性"></a>data 属性</h4><ul><li><p>在根组件对象上，还可以添加一个<code>data</code>函数，用于声明组件初始<strong>响应式状态</strong>的函数。</p></li><li><p>data 的值是一个函数，该函数应当返回一个普通 JavaScript 对象，Vue 会将它转换为<strong>响应式对象</strong>。</p></li><li><p>根组件实例创建后，可以通过 <code>root.$data</code> 访问该响应式对象，同时组件实例也代理了该数据对象上所有的属性，因此 <code>root.message</code> 等价于 <code>root.$data.message</code></p></li><li><p>演示代码</p></li></ul><pre><code>&lt;script src=&quot;https://unpkg.com/vue@3/dist/vue.global.js&quot;&gt;&lt;/script&gt;&lt;div id=&quot;app&quot;&gt;&lt;/div&gt;&lt;script&gt;  const &#123; createApp &#125; = Vue;  // app 为创建的应用实例，指代上面的this  const app = createApp(&#123;    data() &#123;      return &#123;        message: &quot;Hello Vue&quot;,      &#125;;    &#125;,    template: &quot;&lt;div&gt;Hello Vue&lt;/div&gt;&quot;,  &#125;);  const root = app.mount(&quot;#app&quot;);&lt;/script&gt;</code></pre><ul><li><p>在浏览器中打开当前页面，然后在控制台输入<code>root</code>，查看输出结果如下：</p><img src="data--root代理对象.png"></li><li><p>接下，我们在控制台输入对应代码，输出结果如下：</p><img src="访问响应式对象.png"></li></ul><blockquote><p>结果分析</p><ul><li>因为<code>root.$data</code>代理了 data 函数返回的那个对象，所以可以通过<code>root.$data.message</code>访问到 message 属性。</li><li>因为 <code>root</code> 对象代理了 data 函数返回的那个对象的所有属性，所以可以通过<code>root.message</code>访问到 message 属性。</li><li>当执行<code>root.message=&quot;更改Hello vue&quot;</code>，本质上是通过代理更改 data 函数返回的那个对象身上的 message 属性。所以通过<code>root.$data.message</code>再次访问 message 属性时，得到结果也为<code>&quot;更改Hello vue&quot; </code></li></ul></blockquote><h5 id="模板中访问-data-属性"><a href="#模板中访问-data-属性" class="headerlink" title="模板中访问 data 属性"></a>模板中访问 data 属性</h5><ul><li>我们可以在<code>template</code>模板中，使用插值语法<code>&#123;&#123;&#125;&#125;</code>等方式访问 data 函数返回的对象身上的属性。</li></ul><pre><code>&lt;script src=&quot;https://unpkg.com/vue@3/dist/vue.global.js&quot;&gt;&lt;/script&gt;&lt;div id=&quot;app&quot;&gt;&lt;/div&gt;&lt;script&gt;  const &#123; createApp &#125; = Vue;  const app = createApp(&#123;    data() &#123;      return &#123;        message: &quot;Hello Vue&quot;,      &#125;;    &#125;,    template: &quot;&lt;div&gt;&#123;&#123;message&#125;&#125;&lt;/div&gt;&quot;,  &#125;);  const root = app.mount(&quot;#app&quot;);&lt;/script&gt;</code></pre><ul><li>以上代码，最终在浏览器显示的 HTML 结构如下</li></ul><pre><code>&lt;div id=&quot;app&quot;&gt;  &lt;div&gt;Hello Vue&lt;/div&gt;&lt;/div&gt;</code></pre><h5 id="data-的响应性"><a href="#data-的响应性" class="headerlink" title="data 的响应性"></a>data 的响应性</h5><blockquote><p>上面提到：data函数返回一个普通 JavaScript 对象，Vue 会将它转换为响应式对象。<br><strong>响应式对象特点</strong></p></blockquote><ul><li>当我们更改<strong>该对象属性的值</strong>时，页面 DOM 中展示的数据会更新为更改后的值。</li><li>当我们更改了<strong>页面中的数据</strong>时，JS 对象身上的属性值也会更新为更改后的值。</li></ul><h5 id="data-为什么被设置成一个函数，而不是一个对象"><a href="#data-为什么被设置成一个函数，而不是一个对象" class="headerlink" title="data 为什么被设置成一个函数，而不是一个对象"></a>data 为什么被设置成一个函数，而不是一个对象</h5><ul><li>之所以每个子组件的数据不会产生相互干扰，是因为每个子组件使用的数据都是通过<code>data()</code>函数返回的一个新的响应式对象，所以在操作数据时，每个组件操作的是与他对应的响应式对象。</li><li>而对象本身是引用数据类型，指向同一地址，数据之间会互相影响</li></ul><h4 id="Vue-调试工具-Devtools"><a href="#Vue-调试工具-Devtools" class="headerlink" title="Vue 调试工具 Devtools"></a>Vue 调试工具 Devtools</h4><blockquote><p>安装 Devtools 调试工具有两种方案</p></blockquote><ul><li>①、Google 应用商店安装<ul><li>点击 Google 浏览器的右上角 …</li><li>点击扩展程序</li><li>访问 Google 应用商店</li><li>在搜索框搜索需要的插件，即可安装</li></ul></li><li>②、下载 Devtools 插件，然后再安装<ul><li>点击 Google 浏览器的右上角 …</li><li>点击扩展程序</li><li>点击管理扩展程序，打开浏览器右上角开发者模式</li><li>把下载好的<code>vue.jsdevtools.crx</code>拖到扩展程序页面，弹出是否安装，点击确认即可</li></ul></li></ul><h4 id="模块化开发"><a href="#模块化开发" class="headerlink" title="模块化开发"></a>模块化开发</h4><ul><li>以下<code>index.html</code>页面中代码，大部分是固定写法，只有<strong>根组件</strong>中的代码需要经常变动。</li></ul><pre><code>&lt;script src=&quot;https://unpkg.com/vue@3/dist/vue.global.js&quot;&gt;&lt;/script&gt;&lt;div id=&quot;app&quot;&gt;&lt;/div&gt;&lt;script&gt;  const &#123; createApp &#125; = Vue;  const app = createApp(&#123;    data() &#123;      return &#123;        message: &quot;Hello Vue&quot;,      &#125;;    &#125;,    template: &quot;&lt;div&gt;&#123;&#123;message&#125;&#125;&lt;/div&gt;&quot;,  &#125;).mount(&quot;#app&quot;);&lt;/script&gt;</code></pre><ul><li>将<code>index.html</code>页面中<code>&lt;script&gt;</code>标签中的代码抽离出来，放到一个单独的<code>main.js</code>文件中，然后在<code>index.html</code>页面，通过<strong>模块化</strong>的方式引入</li></ul><pre><code>&lt;script src=&quot;https://unpkg.com/vue@3/dist/vue.global.js&quot;&gt;&lt;/script&gt;&lt;div id=&quot;app&quot;&gt;&lt;/div&gt;&lt;!-- 注意，需要添加type=&quot;module&quot; --&gt;&lt;script type=&quot;module&quot; src=&quot;./main.js&quot;&gt;&lt;/script&gt;</code></pre><ul><li>把<code>main.js</code>中的根组件抽离出去，放在一个单独的<code>app.js</code>文件中，然后对外默认导出，最后在<code>main.js</code>中通过模块化的方式导入。</li></ul><pre><code>// main.jsconst &#123; createApp &#125; = Vue;import App from &quot;./app.js&quot;;const app = createApp(App);app.mount(&quot;#app&quot;);</code></pre><ul><li>以下是App.js文件中代码，定义根组件</li></ul><pre><code>export default &#123;  data() &#123;    return &#123;      message: &quot;Hello Vue&quot;,    &#125;;  &#125;,  template: &quot;&lt;div&gt;&#123;&#123;message&#125;&#125;&lt;/div&gt;&quot;,&#125;;</code></pre><h3 id="四、Vue-组件基础"><a href="#四、Vue-组件基础" class="headerlink" title="四、Vue 组件基础"></a>四、Vue 组件基础</h3><ul><li>组件是用一个包含特定选项（属性）的 JS 对象来表示，比如：有<code>data</code>、<code>template</code>等更多属性。</li><li>组件最终会被渲染成一个 DOM 元素插入到页面中。</li><li>Vue 组件又分为根组件和子组件，一个应用一般是由一个根组件与多个子组件组成。</li></ul><h4 id="如何创建根组件"><a href="#如何创建根组件" class="headerlink" title="如何创建根组件"></a>如何创建根组件</h4><ul><li>一个页面可以有多个根组件，但正常情况下，一个单页面应用只有一个根组件，其它组件作为根组件的子组件，然后嵌套组合成一个完整的应用。</li><li>根组件需要通过<code>createApp()</code>方法来渲染，最终调用<code>mount()</code>方法，将渲染后的 DOM 添加到页面中对应容器。</li></ul><h4 id="如何创建子组件"><a href="#如何创建子组件" class="headerlink" title="如何创建子组件"></a>如何创建子组件</h4><ul><li>子组件本身也是组件，所以也是用一个 JS 对象表示，其写法与根组件的写法一模一样，只是不需要通过<code>createApp()</code>方法来渲染</li><li>使用子组件<ul><li>子组件不能单独使用，需要被嵌套在根组件或其它子组件中使用。</li><li>多个子组件层层嵌套组合在一起，配合根组件最终实现一个完整的应用。</li><li>子组件在使用前需要先被 <strong>“注册”</strong> ，这样 Vue 才能在渲染模板时找到对应子组件并渲染成 DOM。</li></ul></li></ul><h4 id="组件注册"><a href="#组件注册" class="headerlink" title="组件注册"></a>组件注册</h4><ul><li>组件注册有两种方式<ul><li>全局注册</li><li>局部注册</li></ul></li></ul><h5 id="注册全局组件"><a href="#注册全局组件" class="headerlink" title="注册全局组件"></a>注册全局组件</h5><ul><li>我们可以使用 <code>Vue</code> 应用实例的<code>app.component()</code> 方法来注册一个全局组件，该组件可以在当前 <code>Vue</code> 应用中全局可用</li></ul><pre><code>/*    name :  为注册成功的全局组件的组件名    component : 为注册为全局组件的子组件（*/component(name: string, component: Component): this</code></pre><ul><li>以下定义了一个全局组件<code>global-component</code></li></ul><pre><code>// 定义子组件const MyComponent = &#123;  template: &quot;&lt;div&gt;Hello Vue&lt;/div&gt;&quot;,&#125;;// 将子组件MyComponent注册为全局组件，全局组件名为 &quot;global-component&quot;app.component(&quot;global-component&quot;, MyComponent);</code></pre><ul><li>全局组件在整个应用中全局可用，我们可以直接在其它组件的template模板中使用</li></ul><pre><code>&lt;script src=&quot;https://unpkg.com/vue@3/dist/vue.global.js&quot;&gt;&lt;/script&gt;&lt;div id=&quot;app&quot;&gt;&lt;/div&gt;&lt;script&gt;  const &#123; createApp &#125; = Vue;  // 创建应用实例  const app = createApp(&#123;    // 使用全局组件    template: `&lt;global-component /&gt;`,  &#125;);  // 定义子组件  const MyComponent = &#123;    template: &quot;&lt;div&gt;Hello Vue&lt;/div&gt;&quot;,  &#125;;  // 将子组件注册为全局组件，在整个应用中全局可用,全局组件名自定义  app.component(&quot;global-component&quot;, MyComponent);  // 挂载  app.mount(&quot;#app&quot;);&lt;/script&gt;</code></pre><ul><li>以上代码，最终渲染后的 HTML 代码如下</li></ul><pre><code>&lt;div id=&quot;app&quot; data-v-app=&quot;&quot;&gt;&lt;div&gt;Hello Vue!!&lt;/div&gt;&lt;/div&gt;</code></pre><ul><li>总结：把组件注册为全局组件并使用分为以下三步<ul><li>定义子组件 <code>const MyComponent=&#123; /* */ &#125;</code></li><li>调用<code>app.component(name,component)</code>方法，将组件注册为全局组件</li><li>在其它组件的<code>template</code>模板中使用全局组件</li></ul></li></ul><blockquote><p><code>app.component()</code> 链式调用</p></blockquote><ul><li><code>app.component()</code> 方法返回值为 <code>app</code> 应用实例，所以该方法支持链式调用</li></ul><pre><code>// 注册全局 my-list组件，并在组件中调用my-item组件app  .component(&quot;my-list&quot;, &#123;    template: `&lt;div class=&quot;list&quot;&gt;my-list组件中调用my-item组件 &lt;my-item/&gt;&lt;/div&gt;`,  &#125;)  .component(&quot;my-item&quot;, &#123;    template: `&lt;div class=&quot;item&quot;&gt;my-item组件内容&lt;/div&gt;`,  &#125;);</code></pre><h5 id="注册局部组件"><a href="#注册局部组件" class="headerlink" title="注册局部组件"></a>注册局部组件</h5><ul><li>局部组件只能在使用它的父组件中显示导入才能使用，并且只能在导入的父组件中使用</li><li>在父组件中显示导入需要使用的子组件，需要使用<code>components</code>属性</li><li>注意：需要使用的子组件，需写在<code>const app = createApp(&#123;&#125;)</code>代码之前，否则会出现找不到组件的错误</li></ul><pre><code>&lt;script src=&quot;https://unpkg.com/vue@3/dist/vue.global.js&quot;&gt;&lt;/script&gt;&lt;div id=&quot;app&quot;&gt;&lt;/div&gt;&lt;script&gt;  const &#123; createApp &#125; = Vue;  // 创建子组件 ComponentA  const ComponentA = &#123;    data() &#123;      return &#123;        message: &quot;ComponentA&quot;,      &#125;;    &#125;,    template: &quot;&lt;div&gt;&#123;&#123;message&#125;&#125;&lt;/div&gt;&quot;,  &#125;;  // 创建应用  const app = createApp(&#123;    // 在父组件中显示导入要使用的子组件    components: &#123;      ComponentA    &#125;,    // 在根组件中使用子组件    template: &quot;&lt;ComponentA /&gt;&quot;  &#125;);  // 挂载  app.mount(&quot;#app&quot;);&lt;/script&gt;</code></pre><blockquote><p>抽离子组件</p></blockquote><ul><li><p>以上代码，子组件全写在一个页面看起来代码混乱，可以把</p></li><li><p>子组件抽离出去，放在单独的 JS 文件中，通过<code>export default</code>来默认导出</p></li><li><p>需要使用该子组件的父组件中，通过<code>import</code>导入对应子组件</p></li><li><p><code>ComponentA.js</code> 文件，对外默认暴露本组件</p></li></ul><pre><code>// 创建子组件export default &#123;  data() &#123;    return &#123;      message: &quot;ComponentA&quot;,    &#125;;  &#125;,  template: &quot;&lt;div&gt;&#123;&#123;message&#125;&#125;&lt;/div&gt;&quot;,&#125;;</code></pre><ul><li><code>index.html</code>页面，项目入口</li></ul><pre><code>&lt;script src=&quot;https://unpkg.com/vue@3/dist/vue.global.js&quot;&gt;&lt;/script&gt;&lt;div id=&quot;app&quot;&gt;&lt;/div&gt;&lt;!--注意要加入 type=&quot;module&quot;--&gt;&lt;script type=&quot;module&quot;&gt;  const &#123; createApp &#125; = Vue;  // 导入子组件  import ComponentA from &quot;./src/components/ComponentA.js&quot;;  // 创建应用  const app = createApp(&#123;    // 在父组件中显示导入要使用的子组件    components: &#123;      ComponentA: ComponentA,    &#125;,    // 在根组件中使用子组件    template: &quot;&lt;ComponentA /&gt;&quot;,  &#125;);  // 挂载  app.mount(&quot;#app&quot;);&lt;/script&gt;</code></pre><h4 id="组件的复用性"><a href="#组件的复用性" class="headerlink" title="组件的复用性"></a>组件的复用性</h4><ul><li>全局或局部 组件最大的优势就是可以复用，所以我们可以在一个页面重复使用同一个组件多次，他们的数据互不干扰</li></ul><h4 id="组件命名"><a href="#组件命名" class="headerlink" title="组件命名"></a>组件命名</h4><ul><li>组件名如果为单个单词，首字母推荐大写，这样在定义时可以与变量区分，在使用时可以与原生的 html 区分。如：组件名为<code>Counter</code> ，在模板中使用写法<code>&lt;Counter/&gt;</code>。</li><li>组件名如果为多个单词组成，推荐采用 <code>PascalCase</code> 格式，每个单字首字母大写（如：MyComponent ） 但在模板中使用时，可以采用以下三种写法</li><li><code>&lt;MyComponent /&gt;</code>、<code>&lt;MyComponent&gt;&lt;/MyComponent&gt;</code>、<code>&lt;my-component&gt;&lt;/my-component&gt;</code></li></ul><blockquote><p>温馨提示：</p></blockquote><ul><li>如果你想区分全局组件与局部组件，全局组件命采用多个单词，并使用-短横分隔（如：<code>my-component</code>）。</li><li>在模板中使用时，采用<code>&lt;my-component&gt;&lt;/my-component&gt;</code> 或<code>&lt;my-component/&gt;</code>简写<blockquote><ul><li>一般引用的第三方组件库，都是全局组件，组件名采用多个单词，并用-短横线分隔</li></ul></blockquote></li></ul><h4 id="全局组件-VS-局部组件"><a href="#全局组件-VS-局部组件" class="headerlink" title="全局组件 VS 局部组件"></a>全局组件 VS 局部组件</h4><blockquote><p>全局注册虽然很方便，但有以下几个问题：</p></blockquote><ul><li>①、全局注册，但并没有被使用的组件无法在生产打包时被自动移除（也叫“<code>tree-shaking</code>”）。如果你全局注册了一个组件，即使它并没有被实际使用，它仍然会出现在打包后的 JS 文件中。</li><li>②、全局注册，在大型项目中使项目的依赖关系变得不那么明确。在父组件中使用子组件时，不太容易定位子组件的实现。和使用过多的全局变量一样，这可能会影响应用长期的可维护性。</li><li>相比之下，局部注册的组件需要在使用它的父组件中显式导入，并且只能在该父组件中使用。它的优点是使组件之间的依赖关系更加明确，并且对 <code>tree-shaking </code>更加友好。</li></ul><h3 id="五、非单文件组件开发"><a href="#五、非单文件组件开发" class="headerlink" title="五、非单文件组件开发"></a>五、非单文件组件开发</h3><ul><li>利用组件化来实现以下布局<img src="组件化树状结构.png"></li></ul><h4 id="如果我们把所有代码写在一个页面中"><a href="#如果我们把所有代码写在一个页面中" class="headerlink" title="如果我们把所有代码写在一个页面中"></a>如果我们把所有代码写在一个页面中</h4><pre><code>&lt;style&gt;  html,  body &#123;    padding: 0;    margin: 0;    background-color: #ddd;  &#125;  #app &#123;    width: 80%;    height: 100%;    margin: 0 auto;  &#125;  .header &#123;    width: 100%;    height: 100px;    background-color: tomato;  &#125;  .container &#123;    width: 100%;    display: flex;    justify-content: space-between;  &#125;  .main &#123;    width: 60%;    min-height: 700px;  &#125;  .article1 &#123;    height: 310px;    background-color: khaki;    margin-top: 20px;  &#125;  .article2 &#123;    height: 310px;    background-color: palevioletred;    margin-top: 20px;  &#125;  .aside &#123;    width: 35%;  &#125;  .item &#123;    height: 200px;    margin-top: 20px;  &#125;  .item:nth-child(1) &#123;    background-color: lightblue;  &#125;  .item:nth-child(2) &#123;    background-color: lightcoral;  &#125;  .item:nth-child(3) &#123;    background-color: lightseagreen;  &#125;&lt;/style&gt;&lt;body&gt;  &lt;!--app应用 相当于根组件App--&gt;  &lt;div id=&quot;app&quot;&gt;    &lt;!--头部，相当于子组件Header--&gt;    &lt;div class=&quot;header&quot;&gt;&#123;&#123;header&#125;&#125;&lt;/div&gt;    &lt;!--container start--&gt;    &lt;div class=&quot;container&quot;&gt;      &lt;!--main start--&gt;      &lt;!--main，相当于子组件Main--&gt;      &lt;div class=&quot;main&quot;&gt;        &lt;div class=&quot;article1&quot;&gt;&#123;&#123;article1&#125;&#125;&lt;/div&gt;        &lt;div class=&quot;article2&quot;&gt;&#123;&#123;article2&#125;&#125;&lt;/div&gt;      &lt;/div&gt;      &lt;!--aside start--&gt;      &lt;!--aside，相当于子组件Aside--&gt;      &lt;div class=&quot;aside&quot;&gt;        &lt;div class=&quot;item item1&quot;&gt;&#123;&#123;item1&#125;&#125;&lt;/div&gt;        &lt;div class=&quot;item item2&quot;&gt;&#123;&#123;item2&#125;&#125;&lt;/div&gt;        &lt;div class=&quot;item item3&quot;&gt;&#123;&#123;item3&#125;&#125;&lt;/div&gt;      &lt;/div&gt;    &lt;/div&gt;    &lt;!--container end--&gt;  &lt;/div&gt;  &lt;script type=&quot;module&quot;&gt;    import &#123; createApp &#125; from &quot;https://unpkg.com/vue@3/dist/vue.esm-browser.js&quot;;    const app = createApp(&#123;      data() &#123;        return &#123;          header: &quot;网站头部&quot;,          article1: &quot;文章版块一&quot;,          article2: &quot;文章版块二&quot;,          item1: &quot;侧边栏一&quot;,          item2: &quot;侧边栏一&quot;,          item3: &quot;侧边栏一&quot;,        &#125;;      &#125;,    &#125;).mount(&quot;#app&quot;);  &lt;/script&gt;&lt;/body&gt;</code></pre><h4 id="模块化、组件化"><a href="#模块化、组件化" class="headerlink" title="模块化、组件化"></a>模块化、组件化</h4><ul><li>利用模块化思想<ul><li>把html标签和data拆分给<code>App.js</code></li><li>创建Vue应用实例的入口：<code>major.js</code></li></ul></li><li>利用组件化思想，抽离三个或更多子组件<img src="非单文件组件.png"></li></ul><blockquote><p>index.html</p></blockquote><pre><code>&lt;head&gt;  &lt;style&gt;  ....省略css样式  &lt;/style&gt;&lt;/head&gt;&lt;body&gt;  &lt;div id=&quot;app&quot;&gt;&lt;/div&gt;&lt;/body&gt;&lt;script type=&quot;module&quot; src=&quot;./major.js&quot;&gt;&lt;/script&gt;</code></pre><blockquote><p>major.js</p></blockquote><pre><code>import &#123; createApp &#125; from &quot;https://unpkg.com/vue@3/dist/vue.esm-browser.js&quot;;//导入根组件import App from &quot;./App.js&quot;;//创建应用实例 并挂载到页面const app = createApp(App).mount(&quot;#app&quot;);</code></pre><blockquote><p>App.js</p></blockquote><pre><code>//导入子组件import Header from &quot;./Header.js&quot;;import Main from &quot;./Main.js&quot;;import Aside from &quot;./Aside.js&quot;;export default &#123;  data() &#123;    return &#123;&#125;;  &#125;,  components: &#123;    Header,    Main,    Aside,  &#125;,  template: `  &lt;Header/&gt;  &lt;div class=&quot;container&quot;&gt;    &lt;Main/&gt;    &lt;Aside/&gt;  &lt;/div&gt;  `,&#125;;</code></pre><blockquote><p>Header.js</p></blockquote><pre><code>export default &#123;  data() &#123;    return &#123;      header: &quot;网站头部&quot;,    &#125;;  &#125;,  template: `      &lt;div class=&quot;header&quot;&gt;&#123;&#123;header&#125;&#125;&lt;/div&gt;    `,&#125;;</code></pre><blockquote><p>Main.js</p></blockquote><pre><code>export default &#123;  data() &#123;    return &#123;      article1: &quot;文章板块一&quot;,      article2: &quot;文章板块二&quot;,    &#125;;  &#125;,  template: `  &lt;div class=&quot;main&quot;&gt;     &lt;div class=&quot;article1&quot;&gt;&#123;&#123;article1&#125;&#125;&lt;/div&gt;     &lt;div class=&quot;article2&quot;&gt;&#123;&#123;article2&#125;&#125;&lt;/div&gt;  &lt;/div&gt;`,&#125;;</code></pre><blockquote><p>Aside.js</p></blockquote><pre><code>export default &#123;  data() &#123;    return &#123;      item1: &quot;侧边栏一&quot;,      item2: &quot;侧边栏二&quot;,      item3: &quot;侧边栏三&quot;,    &#125;;  &#125;,  template: `  &lt;div class=&quot;aside&quot;&gt;    &lt;div class=&quot;item item1&quot;&gt;&#123;&#123;item1&#125;&#125;&lt;/div&gt;    &lt;div class=&quot;item item2&quot;&gt;&#123;&#123;item2&#125;&#125;&lt;/div&gt;    &lt;div class=&quot;item item3&quot;&gt;&#123;&#123;item3&#125;&#125;&lt;/div&gt;  &lt;/div&gt;  `,&#125;;</code></pre><h4 id="非单文件组件产生问题"><a href="#非单文件组件产生问题" class="headerlink" title="非单文件组件产生问题"></a>非单文件组件产生问题</h4><blockquote><p>显然以上方式存在以下两个严重的问题：</p></blockquote><ul><li>不支持 CSS，CSS 样式没有拆分出去，本质上是没有完全实现组件化的，因为一个完整的组件需要HTML，CSS，JS三部分</li><li>在 JS 中通过<code>template</code>字符串模板来书写 HTML 非常不方便，代码显得很丑陋，缺乏语法高亮和代码提示。<ul><li>非单文件组件在实际开发中并几乎不用，这里只是借用他来了解组件，并引出单文件组件</li></ul></li></ul><h3 id="六、单文件组件开发（SFC）"><a href="#六、单文件组件开发（SFC）" class="headerlink" title="六、单文件组件开发（SFC）"></a>六、单文件组件开发（SFC）</h3><ul><li>我们一般会将 <code>Vue</code> 组件定义在一个单独的 <code>.vue</code>结尾的文件中，这被叫做单文件组件 (英文 <code>Single-File Component</code>，简称 <code>SFC</code>)。</li><li>他是一种特殊的文件格式，使我们能够将一个 <code>Vue</code> 组件的模板、逻辑与样式封装在单个文件中</li></ul><h4 id="定义一个单文件组件"><a href="#定义一个单文件组件" class="headerlink" title="定义一个单文件组件"></a>定义一个单文件组件</h4><blockquote><p>下面是一个单文件组件的示例</p></blockquote><ul><li>组件的逻辑，即 JS 代码写在<code>&lt;script&gt;</code>标签中，通过export default对外暴露组件选项对象</li><li>组件的模板，即 HTML 模板代码，写在<code>&lt;template&gt;</code>标签中</li><li>组件的样式，即 CSS 样式，写在<code>&lt;style&gt;</code>标签中</li></ul><pre><code>&lt;!--App.vue文件内容--&gt;&lt;!--逻辑--&gt;&lt;script&gt;export default &#123;  data() &#123;    return &#123;      message: &quot;Hello World!&quot;,    &#125;;  &#125;,&#125;;&lt;/script&gt;&lt;!--模板--&gt;&lt;template&gt;  &lt;div class=&quot;box&quot;&gt;&#123;&#123; message &#125;&#125;&lt;/div&gt;&lt;/template&gt;&lt;!--样式--&gt;&lt;style&gt;.box &#123;  width: 100px;  height: 100px;  background-color: skyblue;&#125;&lt;/style&gt;</code></pre><blockquote><p>注意事项</p></blockquote><ul><li>每个<code>*.vue</code>文件最多可以包含一个顶层 <code>&lt;template&gt;</code> 块</li><li>每个<code>*.vue</code>文件最多可以包含一个 <code>&lt;script&gt;</code> 块。(使用<code>&lt;script setup&gt;</code>的情况除外)</li><li>每个<code>*.vue</code>文件可以包含多个 <code>&lt;style&gt;</code> 标签</li></ul><h4 id="使用单文件组件改造项目"><a href="#使用单文件组件改造项目" class="headerlink" title="使用单文件组件改造项目"></a>使用单文件组件改造项目</h4><ul><li>调整项目结构<ul><li>将子组件都放入<code>components</code>文件夹里</li><li>将<code>js</code>文件改成<code>.vue</code>文件，分离出<code>CSS</code>样式</li></ul></li><li>因为单文件组件是将 <code>Vue</code> 组件定义在一个以<code>.vue</code>结尾的文件，而浏览器是没有办法识别<code>.vue</code>结尾的文件。<ul><li>所以我们需要借助构建工具来完成项目的构建，这里我们借助<code>Vite</code>构建工具。</li></ul></li><li>安装插件，<code>Vue Language Features (Volar)</code>插件是 <code>Vscode</code>开发<code>vue3</code>必备插件，针对<code>.vue</code>文件提供语法高亮提示，非常好用</li></ul><p><strong>利用 Vite 打包 Vue 项目</strong></p><blockquote><p>Vite 官网地址：<code>https://cn.vitejs.dev/</code></p></blockquote><ul><li>使用终端，在当前项目根目录下，执行<code>npm init -y</code>初始化项目的<code>package.json</code>文件</li><li>执行以下命令安装 <code>Vite</code> 前端构建工具</li></ul><pre><code>npm i vite -D</code></pre><ul><li>构建工具打包时，默认是不识别<code>.vue</code>文件，所以需要安装<code>@vitejs/plugin-vue</code>插件来对<code>.vue</code>文件解析<ul><li>安装以上插件，会自动帮我们安装好 <code>vue3.0</code> 以上的包，不需要再手动执行<code>npm i vue</code>命令安装 Vue 包。</li></ul></li></ul><pre><code>npm i -D @vitejs/plugin-vue</code></pre><ul><li>在项目的根目录下新建<code>vite.config.js</code>文件，此文件为 Vite 的配置文件，我们需要配置 Vite 的插件，告诉 Vite 在构建打包时，启用插件来识别.vue的文件。<br><code>vite.config.js</code>文件内容如下</li></ul><pre><code>// 导入vue插件包import vue from &quot;@vitejs/plugin-vue&quot;;// defineConfig方法，让配置文件有智能提示功能import &#123; defineConfig &#125; from &quot;vite&quot;;export default defineConfig(&#123;  // 配置vue插件。  plugins: [vue()],&#125;);</code></pre><ul><li>最后，我们可以执行以下命令，启动开发服务</li></ul><pre><code>npx vite # 启动开发服务</code></pre><ul><li>命令执行后，会在终端显示以下信息</li></ul><pre><code>  ➜  Local:   http://localhost:5173/  ➜  Network: use --host to expose  ➜  press h to show help</code></pre><blockquote><ul><li>点击上面的<strong>网址</strong>，就可以查看到开发的项目</li></ul></blockquote><ul><li>如果想要对生产环境打包，并预览项目，可以执行以下两个命令</li></ul><pre><code>npx vite build # 生产环境打包npx vite preview # 预览生产环境打包后的项目</code></pre><h4 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h4><blockquote><p>单文件组件</p></blockquote><ul><li>单文件组件本质上是一个特殊的文件格式，使我们能够将一个 Vue 组件的<strong>模板、逻辑与样式</strong>封装在单个文件中。</li><li>单文件组件开发必需配合<strong>打包工具</strong>才能使用，因为浏览器本身不能识别<code>.vue</code>的文件。</li><li>Vite 打包工具，需要安装<code>@vitejs/plugin-vue</code>插件，并在配置文件中配置好该插件，在打包时才能正确识别<code>.vue</code>文件。<blockquote><p>组件的拆分</p></blockquote></li><li>了解并尝试把一个大的项目拆分成多个组件，你可以自己尝试把上面项目的Aside与Main组件再进一步的拆分成多个子组件。<blockquote><p>单文件组件的优点</p></blockquote></li><li>组件最大的特点就是可以实现复用</li><li>为什么需要使用 SFC，可以查阅<a href="https://cn.vuejs.org/guide/scaling-up/sfc.html">官方说明</a></li></ul><h3 id="Vue-脚手架创建-Vue-项目"><a href="#Vue-脚手架创建-Vue-项目" class="headerlink" title="Vue 脚手架创建 Vue 项目"></a>Vue 脚手架创建 Vue 项目</h3><blockquote><p>通过 Vue 脚手架来使用 Vue，是我们需要重点掌握的，在实际开发中，这是我们首选的开发方式，同时他支持 Vue 的单文件组件（SFC）化开发。</p><p>这种方式，需要我们先安装node，同时了解 npm 包管理工具的使用。因为前面我们学习过 node 和 npm，所以这里就不再做相关介绍<br>在本节中将介绍如何在本地搭建 Vue 单页应用。创建的项目将使用基于 Vite 的构建设置，并允许我们使用 Vue 的单文件组件 (SFC)。</p></blockquote><h4 id="安装-Vue"><a href="#安装-Vue" class="headerlink" title="安装 Vue"></a>安装 Vue</h4><blockquote><p>官方安装教程地址：<a href="https://cn.vuejs.org/guide/quick-start.html%EF%BC%8C%E5%BB%BA%E8%AE%AE%E5%A4%A7%E5%AE%B6%E4%BB%A5%E5%90%8E%E5%9C%A8%E5%AE%89%E8%A3%85">https://cn.vuejs.org/guide/quick-start.html，建议大家以后在安装</a> Vue 时，以官方教程为主。</p></blockquote><ul><li>执行以下命令，进行安装</li></ul><pre><code>npm init vue@latest</code></pre><blockquote><p>这一指令将会安装并执行<code>create-vue</code>，它是 Vue 官方的项目脚手架工具。会帮我们把开发项目时每次都需要做的一些重复的繁琐的工作给做掉，从而提高我们的开发效率。</p></blockquote><ul><li>你将会看到一些诸如<code>TypeScript</code>和测试支持之类的可选功能提示：</li></ul><pre><code>✔ Project name: … &lt;your-project-name&gt;✔ Add TypeScript? … No / Yes        # 是否使用 TypeScript✔ Add JSX Support? … No / Yes# 是否使用 JSX✔ Add Vue Router for Single Page Application development? … No / Yes   # 是否安装 Vue Router开发一个单页面应用✔ Add Pinia for state management? … No / Yes    # 是否添加Pinia组件来进行状态管理✔ Add Vitest for Unit testing? … No / Yes      # 是否添加Vitest来进行单元测试✔ Add Cypress for both Unit and End-to-End testing? … No / Yes # 是否添加Cypress来进行单元测试和端到端测试✔ Add ESLint for code quality? … No / Yes  # 是否添加ESLint来进行代码质量检查✔ Add Prettier for code formatting? … No / Yes   # 为代码格式添加 Prettier  (格式化代码插件)Scaffolding project in ./&lt;your-project-name&gt;...Done.</code></pre><blockquote><p>在这里，我们在执行<code>npm init vue@latest</code>命令后，全部选择<code>No</code>就好。因为我们刚开始学习，对于安装的第三方依赖是什么以及有什么用，都不了解。等后我们学完 Vue 后，大家就明白这些第三方依赖是什么，根据需要选择安装就好。</p></blockquote><ul><li>安装好后，会出现以下内容。</li></ul><pre><code>cd vue-project   # 进入到项目目录 vue-projectnpm install   # 安装package.json中的开发和生产依赖npm run dev  # 在开发环境下运行vue项目</code></pre><blockquote><p>项目创建后，并没有给我们安装相应的依赖包，所以需要我们通过执行<code>cd vue-project</code>命令进到项目根目录，然后执行<code>npm install</code>安装<code>package.json</code>文件中提供的开发和生产依赖包。</p></blockquote><ul><li><code>package.json</code>文件内容如下，帮我们配置好了<code>scripts</code>命令脚本、开发与生产依赖需要的包。</li></ul><pre><code>&#123;  &quot;name&quot;: &quot;vue-project&quot;,  &quot;version&quot;: &quot;0.0.0&quot;,  &quot;private&quot;: true,  &quot;scripts&quot;: &#123;    &quot;dev&quot;: &quot;vite&quot;,    &quot;build&quot;: &quot;vite build&quot;,    &quot;preview&quot;: &quot;vite preview&quot;  &#125;,  &quot;dependencies&quot;: &#123;    &quot;vue&quot;: &quot;^3.2.47&quot;  &#125;,  &quot;devDependencies&quot;: &#123;    &quot;@vitejs/plugin-vue&quot;: &quot;^4.0.0&quot;,    &quot;vite&quot;: &quot;^4.1.4&quot;  &#125;&#125;</code></pre><ul><li>最后，我们再执行<code>npm run dev</code>命令，会出现如下内容</li></ul><pre><code>➜  Local:   http://localhost:5173/➜  Network: use --host to expose➜  press h to show help</code></pre><ul><li>我们在浏览器中打开上面 Local字段后面对应的<code>http://localhost:5173/</code>地址，就可以看创建好的 Vue 项目，说明 Vue 启动成功。</li></ul><h4 id="项目目录结构"><a href="#项目目录结构" class="headerlink" title="项目目录结构"></a>项目目录结构</h4><blockquote><p>通过<code>npm init vue@latest</code>命令创建好的项目的目录结构<br><img src="vue脚手架基础项目目录.png"></p></blockquote><ul><li>以下表格中序号对应上图中标出来的序号，我们针对标出来的文件或文件夹做相关说明<table><thead><tr><th>文件编号</th><th>文件或文件夹名</th><th>说明</th></tr></thead><tbody><tr><td>1</td><td>.vscode</td><td>针对当前项目，.vscode目录存放当前项目相关的 VSCode 配置文件的目录</td></tr><tr><td>2</td><td>extensions.json</td><td>推荐当前项目使用的 VSCode 插件</td></tr><tr><td>3</td><td>public</td><td>public下的资源会在项目生产环境打包时，被完整复制到目标目录的根目录下。如果你有以下资源，应该放在 public 目录下：不会被源码引用（例如 robots.txt）；必须保持原有文件名（没有经过 hash）… 或者你压根不想引入该资源，只是想得到其 URL</td></tr><tr><td>4</td><td>src</td><td>源码资源目录，开发阶段的源码都是放在这个目录下</td></tr><tr><td>5</td><td>assets</td><td>静态资源目录，默认存放图片、CSS、JS 等</td></tr><tr><td>6</td><td>components</td><td>公共组件目录，用来存放 Vue 子组件</td></tr><tr><td>7</td><td>.vue文件</td><td>vue 的单文件组件（简单 SFC）</td></tr><tr><td>8</td><td>App.vue</td><td>Vue 的根组件</td></tr><tr><td>9</td><td>main.js</td><td>创建 Vue 应用实例的入口 JS</td></tr><tr><td>10</td><td>.gitignore</td><td>在用 git 提交项目时，需要过滤掉的一些文件</td></tr><tr><td>11</td><td>index.html</td><td>项目的主页（也是打包的入口文件）</td></tr><tr><td>12</td><td>README.md</td><td>项目的说明文档</td></tr><tr><td>13</td><td>vite.config.js</td><td>Vite 前端构建工具的配置文件。</td></tr></tbody></table></li></ul><h4 id="vite-config-js配置文件"><a href="#vite-config-js配置文件" class="headerlink" title="vite.config.js配置文件"></a><code>vite.config.js</code>配置文件</h4><blockquote><p>针对<code>vite.config.js</code>配置文件中相关内容，给大家做个简单的介绍</p></blockquote><pre><code>// 导入node:url模块，这个模块是用来处理路径的import &#123; fileURLToPath, URL &#125; from &quot;node:url&quot;;import &#123; defineConfig &#125; from &quot;vite&quot;;import vue from &quot;@vitejs/plugin-vue&quot;;// https://vitejs.dev/config/export default defineConfig(&#123;  plugins: [vue()],  resolve: &#123;    // 配置路径别名    alias: &#123;      &quot;@&quot;: fileURLToPath(new URL(&quot;./src&quot;, import.meta.url)),    &#125;,  &#125;,&#125;);</code></pre><ul><li><code>import.meta.url</code><ul><li><code>import.meta</code>是一个给<code>JavaScript</code> 模块暴露特定上下文的元数据属性的对象。它包含了这个模块的信息，比如说这个模块的 URL。</li><li><code>import.meta.url</code>为当前模块的完整 url 地址，如<code>C:\Users\EDY\Desktop\vue\vue-project\vite.config.js</code></li></ul></li><li><code>new URL()</code> 创建路径</li></ul><pre><code>new URL(input[, base])</code></pre><ul><li><code>input&lt;string&gt;</code>要解析的绝对&#x2F;相对的<code>URL</code>，如果<code>input</code>是相对路径，则需要<code>base</code>。如果是绝对路径，则忽略<code>base</code></li><li><code>base&lt;string&gt;|&lt;URL&gt;</code>如果<code>input</code>不是绝对路径，则为要解析的基本URL</li></ul><pre><code>new URL(&#39;./src&#39;, import.meta.url)// 得到一个URL对象，对象的结构如下URL &#123;  href: &#39;file:///C:/Users/EDY/Desktop/vue/vue-project/src&#39;,  origin: &#39;null&#39;,  protocol: &#39;file:&#39;,  username: &#39;&#39;,  password: &#39;&#39;,  host: &#39;&#39;,  hostname: &#39;&#39;,  port: &#39;&#39;,  pathname: &#39;/C:/Users/EDY/Desktop/vue/vue-project/src&#39;,  search: &#39;&#39;,  searchParams: URLSearchParams &#123;&#125;,  hash: &#39;&#39;&#125;</code></pre><ul><li><code>fileURLToPath</code>文件将url 转换为 本地文件路径，其参数可以是 url 也可以是 url 对象。</li></ul><pre><code>fileURLToPath(new URL(&quot;./src&quot;, import.meta.url));// 最后输出的结果为：// C:\Users\EDY\Desktop\vue\vue-project\src</code></pre><blockquote><p>在<code>alias</code>里为路径配置取别名时</p><ul><li>原本是不能使用绝对路径，而<code>fileURLToPath()</code>里面的配置是为了使绝对路径变成相对路径</li><li>因此，在配置了这个之后，两种路径都能被解析</li><li>不过要注意：在<code>index.html</code>文件加载的 JS 和 CSS，不要使用别名，因为在开发服务下，并不会去解析别名</li></ul></blockquote><h4 id="项目核心代码分析"><a href="#项目核心代码分析" class="headerlink" title="项目核心代码分析"></a>项目核心代码分析</h4><ul><li><code>index.html</code>文件<blockquote><ul><li>作为项目的入口文件，里面通过 ES 模块化的方式加载了<code>main.js</code>，同时提供了 Vue 项目根组件容器<code>#app</code>，即：后续所有组件（本质是 DOM）都会被添加到<code>#app</code>容器内。</li></ul></blockquote></li></ul><pre><code>&lt;div id=&quot;app&quot;&gt;&lt;/div&gt;&lt;script type=&quot;module&quot; src=&quot;/src/main.js&quot;&gt;&lt;/script&gt;</code></pre><ul><li><code>main.js</code> 文件</li></ul><pre><code>// 导入vue的 createApp方法import &#123; createApp &#125; from &quot;vue&quot;;// 导入 Vue的根组件import App from &quot;./App.vue&quot;;// 导入main.css，最终main.css中内容，会被添加到index.html页面的&lt;style&gt;标签中import &quot;./assets/main.css&quot;;// 创建应用实例，将应用实例挂载到#app 容器中createApp(App).mount(&quot;#app&quot;);</code></pre><ul><li><code>App.vue</code> 文件（最终被转换成 DOM）添加到<code>#app</code>容器中</li></ul><pre><code>&lt;!--组件逻辑，以下采用的是Vue3支持的组合式写法--&gt;&lt;script setup&gt;// 导入子组件import HelloWorld from &quot;./components/HelloWorld.vue&quot;;import TheWelcome from &quot;./components/TheWelcome.vue&quot;;&lt;/script&gt;&lt;!--组件模板--&gt;&lt;template&gt;  &lt;header&gt;    &lt;img      alt=&quot;Vue logo&quot;      class=&quot;logo&quot;      src=&quot;./assets/logo.svg&quot;      width=&quot;125&quot;      height=&quot;125&quot;    /&gt;    &lt;div class=&quot;wrapper&quot;&gt;      &lt;!--添加子组件  本质是DOM--&gt;      &lt;HelloWorld msg=&quot;You did it!&quot; /&gt;    &lt;/div&gt;  &lt;/header&gt;  &lt;main&gt;    &lt;!--添加子组件 本质是DOM--&gt;    &lt;TheWelcome /&gt;  &lt;/main&gt;&lt;/template&gt;&lt;style scoped&gt;/* 组件的css样式,内容省略*/&lt;/style&gt;</code></pre><h2 id="Vite"><a href="#Vite" class="headerlink" title="Vite"></a>Vite</h2><blockquote><p>Vite（法语意为 “快速的”，发音 &#x2F;vit&#x2F;，发音同 “veet”）是一种新型前端构建工具，能够显著提升前端开发体验，其最大的特点就是快 ！</p></blockquote><ul><li>Vite 官方文档：<a href="https://cn.vitejs.dev/">https://cn.vitejs.dev/</a></li></ul><h3 id="一、构建工具和打包工具区别"><a href="#一、构建工具和打包工具区别" class="headerlink" title="一、构建工具和打包工具区别"></a>一、构建工具和打包工具区别</h3><ul><li>在 Vite 之前，我们学习过 <code>WebPack</code>，我们说 <code>WebPack</code> 是静态模块打包器。而我们这里提到的 Vite 称为前端构建工具。那构建工具和打包工具有什么区别呢 ？</li><li>要了解什么是构建工具，就得了解构建工具在我们的项目中具体做了什么工作</li></ul><h4 id="前端构建工具负责的工作"><a href="#前端构建工具负责的工作" class="headerlink" title="前端构建工具负责的工作"></a>前端构建工具负责的工作</h4><blockquote><p>前端构建工具，在我们打包项目时，通常会帮我们做以下工作：</p><table><thead><tr><th>前端构建工具常负责的工作</th><th>说明</th></tr></thead><tbody><tr><td>代码转换</td><td>比如将 SCSS 编译成 CSS，将 TypeScript 编译成 JS 等。将浏览器不能识别的文件或代码，转换成浏览器能识别的文件或代码</td></tr><tr><td>兼容性处理</td><td>利用 babel 将 ES6 代码转换成 ES5 或 ES3 等</td></tr><tr><td>文件优化</td><td>对代码和图进行压缩，比如压缩 JS、CSS、HTML 代码</td></tr><tr><td>代码分割</td><td>提取多个页面的公共代码，提取首屏不需要执行部分的代码让其异步加载</td></tr><tr><td>自动刷新</td><td>自动监听本地源代码的变化，自动重新构建，刷新浏览器。比如：HMR（热更新）</td></tr><tr><td>……</td><td>…….</td></tr></tbody></table></blockquote><blockquote><p>注：</p><ul><li>以上构建工具做的工作，通常是在打包一个项目的过程中需要去做的事情。</li><li>也就是说，在对项目打包时，会<strong>先</strong>利用构建工具进行构建，然后<strong>再</strong>根据他们的依赖关系，最终打包成一个或多个 JS 文件。</li></ul></blockquote><p><strong>构建工具终极目标</strong></p><ul><li>将我们在开发环境写的代码，转换成生产环境的代码。（项目生产上线需要考虑的那些因素，在构建工具都会帮我们实现）</li></ul><h4 id="构建工具与打包工具有什么区别"><a href="#构建工具与打包工具有什么区别" class="headerlink" title="构建工具与打包工具有什么区别"></a>构建工具与打包工具有什么区别</h4><blockquote><ul><li>构建工具，更注重的是前端的自动化流程。开发好的代码，通过自动化流程转换成<strong>生产环境</strong>代码。</li><li>打包工具，更注重打包这一过程，主要包括<strong>依赖管理</strong>和<strong>版本管理</strong>。</li></ul></blockquote><h4 id="为什么-Webpack-称打包工具，而-Vite-称构建工具"><a href="#为什么-Webpack-称打包工具，而-Vite-称构建工具" class="headerlink" title="为什么 Webpack 称打包工具，而 Vite 称构建工具"></a>为什么 Webpack 称打包工具，而 Vite 称构建工具</h4><blockquote><ul><li><code>WebPack</code>在打包过程中，会调用构建工具完成构建工作，但是 <code>WebPack</code>更注重打包这一过程。<strong>他的构建工作，主要依赖第三方插件来完成</strong>，所以我们需要通过配置插件来实现相关的构建工作。</li><li><code>Vite</code>更测重于项目的构建，前端自动化流程。在用 Vite 构建项目时，也会参与打包工作，但是他更注重构建工作，大部分前端项目在打包上线过程中需要完成的构建工作，Vite 都帮我们内置好了，不需要我们再下载插件和配置来完成。</li><li>平时，我们并不会把构建工具和打包工具做严格的区分，所以 <code>WebPack</code>和 Vite 被称打包或构建工具都没问题</li><li>这两个工具都会完成构建和打包这两个步骤；<code>WebPack</code>本身是用来打包的，所以构建的功能注意靠第三方插件；而<code>Vite</code>本身更注重构建项目</li></ul></blockquote><h3 id="二、Vite-简介"><a href="#二、Vite-简介" class="headerlink" title="二、Vite 简介"></a>二、Vite 简介</h3><ol><li><p>Vite 的诞生</p><blockquote><ul><li>Vite 是尤雨溪随 Vue3 正式版(2020 年 9 月 18 日)一并发布的一种新型的前端构建工具。</li><li>起初，大家会认为 Vite 是为 Vue3 服务的这么一款工具。但其实他不是这样一款工具，在 Vite 发布之后，很快，他就经历了一次迭代，发布了 2.0 版本。</li><li>至从 2.0 版本发布后，他就是一个完全独立于前端框架的这样一个构建工具，不再只服务于 Vue 了。</li></ul></blockquote></li><li><p>为什么选 Vite</p><blockquote><ul><li>随着前端的发展，我们开始构建越来越大型的应用时，需要处理的<code>JavaScript</code>代码量也呈指数级增长。包含数千个模块的大型项目相当普遍。</li><li>基于<code>JavaScript</code>开发的工具就会开始遇到<strong>性能瓶颈</strong>：通常需要很长时间（甚至是几分钟！）才能启动开发服务器，即使使用模块热替换（HMR），文件修改后的效果也需要几秒钟才能在浏览器中反映出来。如此循环往复，迟钝的反馈会极大地影响开发者的开发效率和幸福感。</li></ul></blockquote></li></ol><blockquote><p>以下是常见的打包构建工具，都是采用 JS 编写的</p><ul><li>WebPack</li><li>rollup</li><li>parcel</li><li>gulp</li></ul><p>这些工具，大型项目中都存在缓慢的服务启动和缓慢的更新问题。而 Vite 就解决了上面这个问题，他在启动应用时的速度可以说是相当的快。</p></blockquote><ol start="3"><li><p>Vite 的优势</p><blockquote><p>Vite 相比其它的打包工具，具有以下优势</p><ul><li>上手非常简单</li><li>开发效率极高</li><li>社区成本低（兼容 rollup 插件）</li><li>没有复杂晦涩的配置</li><li>Vite 有自身的插件系统</li></ul></blockquote></li><li><p>Vite 的两大组成部分</p><blockquote><p>Vite 针对开发环境和生产环境下的<strong>打包构建模式</strong>完全不一样，他主要由以下两个部分组成：</p><ul><li>一个开发服务，服务于<strong>开发环境</strong>，基于原生 <code>ES</code> 模块和 <code>esbuild</code> 依赖预构建，同时提供了丰富的内建功能，如极快的模块热替换（HMR）</li><li>一套构建指令，服务于<strong>生产环境</strong>，基于 <code>Rollup</code> 完成打包，并且它是预配置的，可输出用于生产环境的高度优化过的静态资源。<blockquote><p>Vite 这样做的主要目的是为了<strong>在开发环境</strong>构建项目时能获得极快的体验。</p></blockquote></li></ul></blockquote></li></ol><h3 id="三、搭建第一个-Vite-项目"><a href="#三、搭建第一个-Vite-项目" class="headerlink" title="三、搭建第一个 Vite 项目"></a>三、搭建第一个 Vite 项目</h3><blockquote><p>前提：</p><ul><li>在使用 Vite 前，需要先安装 Node，同时了解 npm 的用法。</li><li>Vite 需要的 Node.js 版本为 14.18+ 然而，有些模板需要依赖更高的 Node 版本才能正常运行，当你的包管理器发出警告时，请注意升级你的 Node 版本</li></ul></blockquote><h4 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h4><ol><li>项目初始化<blockquote><p>创建名为<code>vite-demo</code>的文件夹作为当前项目的根目录</p></blockquote></li></ol><ul><li>在当前目录下，执行以下命令初始化<code>package.json</code>文件。</li></ul><pre><code>npm init -y</code></pre><ol start="2"><li>安装 Vite<blockquote><p>执行以下命令，安装 Vite</p></blockquote></li></ol><pre><code>npm i vite -D</code></pre><ol start="3"><li>创建项目<blockquote><p>根据以下目录结构，创建项目</p></blockquote></li></ol><pre><code>vite-demo├─ index.html    // 项目打包入口文件├─ main.js├─ basic.js├─ package-lock.json└─ package.json</code></pre><ul><li><code>vite-demo/index.html</code> 文件</li></ul><pre><code>&lt;head&gt;  &lt;!--ES模块化方式引入main.js--&gt;  &lt;script type=&quot;module&quot; src=&quot;./main.js&quot;&gt;&lt;/script&gt;&lt;/head&gt;</code></pre><blockquote><ul><li>Vite 默认以当前项目<strong>根目录</strong>下的<code>index.html</code>文件作为打包的入口文件， 并且他是基于原生 ES 模块提供服务。</li><li>所以在<code>index.html</code>文件中要通过<strong>ES 模块方式</strong>加载 JS 文件。</li></ul></blockquote><ul><li><code>vite-demo/main.js</code>文件</li></ul><pre><code>// 导入 basic.js文件中变量import &#123; username, age &#125; from &quot;./basic.js&quot;;const sex = &quot;女&quot;;const hobbies = [&quot;唱歌&quot;, &quot;跑步&quot;, &quot;音乐&quot;];console.log(`$&#123;username&#125;性别$&#123;sex&#125;,今年$&#123;age&#125;岁了，他喜欢$&#123;hobbies.join(&quot;,&quot;)&#125;`);</code></pre><ul><li><code>vite-demo/basic.js</code>文件</li></ul><pre><code>export const username = &quot;hermia&quot;;export const age = 21;</code></pre><h4 id="启动开发服务"><a href="#启动开发服务" class="headerlink" title="启动开发服务"></a>启动开发服务</h4><ol><li>在当前项目根目录下执行以下命令，启动开发服务。</li></ol><pre><code># 相当于开发环境下打包，不过Vite并不会对源码打包处理npx vite   </code></pre><ul><li>命令执行后，并没有当前根目录下新建<code>dist</code>目录，而是在命令终端显示以下代码</li></ul><pre><code>  ➜  Local:   http://localhost:5173/  ➜  Network: use --host to expose  ➜  press h to show help</code></pre><ol start="2"><li>预览打包后项目</li></ol><ul><li>在浏览器中访问上面Local字段对应的<code>http://localhost:5173/</code>地址，然后在当前地址下打开浏览器的<code>Console</code>控制面板，看到我们创建的内容，就说明服务器启动成功</li><li>切换到<code>Network</code>面板，可以看到<code>main.js</code>和<code>basic.js</code>是通过浏览器直接发请求获取的，并没有做相关的打包工作</li></ul><ol start="3"><li>总结：Vite 开发环境下打包特点</li></ol><ul><li>开发环境下，Vite <strong>并没有对源码执行打包</strong>工作，而是直接启动一个服务器加载当前根目录下的<code>index.html</code>文件（默认情况下，<code>index.html</code>文件为打包的入口文件）</li><li>然后利用浏览器支持 ES 模块化加载这一特点，直接加载<code>index.html</code>里面的 JS 文件，然后<strong>顺着依赖</strong>加载其它的 JS 文件。</li></ul><h4 id="生产环境下打包"><a href="#生产环境下打包" class="headerlink" title="生产环境下打包"></a>生产环境下打包</h4><ol><li>执行以下命令，来完成生成环境下打包工作</li></ol><pre><code>npx vite build</code></pre><ul><li>命令执行后，会在当前目录下生成<code>dist</code>文件夹，<code>dist</code>目录结构如下：</li></ul><pre><code>dist├─ assets   // 打包后的资源放在assets目录下│  └─ index-bdbbf184.js   // main.js打包后生成的js文件└─ index.html // 项目入口文件</code></pre><blockquote><ul><li>可以看到，打包后，<code>main.js</code>及相关的依赖全部被打包生成了<strong>一个</strong> <code>JS</code> 文件。</li></ul></blockquote><ul><li>查看打包后的<code>index.html</code>文件，内容如下：</li></ul><pre><code>&lt;script type=&quot;module&quot; crossorigin src=&quot;/assets/index-bdbbf184.js&quot;&gt;&lt;/script&gt;</code></pre><blockquote><ul><li>可以看到，打包后依然采用的是 ES 模块化来加载打包后生成的 JS 文件。</li></ul></blockquote><ol start="2"><li>预览打包后项目<blockquote><p>如果我们直接在 VSCode 中打开<code>dist</code>目录下的<code>index.html</code>页面，在浏览器控制台会抛出错误</p></blockquote></li></ol><ul><li>因为，打包后生成的<code>dist</code>目录，项目默认以<code>dist</code>目录作为项目的根目录</li><li>而我们直接在 VSCode 打开<code>dist</code>目录下的<code>index.html</code>文件，是以<code>vite-demo</code>作为项目的根目录。</li><li>所以，我们可以在<code>dist</code>目录下打开 VSCode，然后再用 VSCode 打开<code>index.html</code>文件，项目就可以正常跑起来。</li></ul><blockquote><p>不过 Vite 给我们内置了以下命令，我们执行以下命令，就相当以<code>dist</code>目录为项目根目录开启一个服务。</p></blockquote><pre><code>npx vite preview   # 预览打包后的项目</code></pre><ul><li>命令执行后，显示以下代码</li></ul><pre><code>➜  Local:   http://localhost:4173/➜  Network: use --host to expose</code></pre><ul><li>在浏览器中打开 Local 字段后面对应的<code>http://localhost:4173/</code>地址，然后在浏览器的 Console 面板，就可以看到输出结果。</li></ul><ol start="3"><li>注意事项<blockquote><p>如果入口文件<code>index.html</code>中有加载了多个 JS，则打包后也只会生成<strong>一个</strong> JS 文件</p></blockquote></li></ol><pre><code>&lt;!-- index.html --&gt;&lt;script type=&quot;module&quot; src=&quot;./main.js&quot;&gt;&lt;/script&gt;&lt;script type=&quot;module&quot; src=&quot;index.js&quot;&gt;&lt;/script&gt;&lt;script type=&quot;module&quot; src=&quot;a.js&quot;&gt;&lt;/script&gt;</code></pre><ul><li>生产环境下打包后，生成的<code>dist</code>目录结构和<code>index.html</code>文件如下</li></ul><pre><code>dist├─ assets│  └─ index-453aba04.js└─ index.html</code></pre><pre><code>&lt;!--index.html--&gt;&lt;script type=&quot;module&quot; crossorigin src=&quot;/assets/index-453aba04.js&quot;&gt;&lt;/script&gt;</code></pre><ol start="4"><li>总结：Vite 生产环境下打包特点<blockquote><ul><li>在生产环境下，我们可以执行<code>npx vite build</code>命令来完打包工作，执行<code>npx vite preview</code>命令来启动打包后的项目。</li><li>生产环境下也是以<code>index.html</code>作为入口文件来执行打包，会把入口文件中加载的 JS 及相关依赖打包成一个 JS 文件，然后在<code>index.html</code>文件中，采用 ES 模块化方式来加载打包后生成的 JS 文件。</li><li>如果<code>index.html</code>中通过模块化的方式加载了多个 JS，则最终都会打包到一个 JS 文件中</li></ul></blockquote></li></ol><h4 id="配置scripts命令脚本"><a href="#配置scripts命令脚本" class="headerlink" title="配置scripts命令脚本"></a>配置<code>scripts</code>命令脚本</h4><blockquote><p>我们可以把 Vite 的以下三个常用命令</p></blockquote><pre><code>npx vite  # 启动开发服务npx vite build # 执行生产环境打包npx vite preview #预览生产环境打包后的项目</code></pre><ul><li>在<code>package.json</code>文件的<code>&quot;scripts&quot;</code>字段中配置，具体配置如下：</li></ul><pre><code>&quot;scripts&quot;: &#123;    &quot;dev&quot;:&quot;vite&quot;,    &quot;build&quot;:&quot;vite build&quot;,    &quot;preview&quot;:&quot;vite preview&quot;&#125;</code></pre><ul><li>配置好后，我们就可以通过执行以下命令，来完成 Vite 对应的工作。</li></ul><pre><code>npm run dev    # 启动开发服务npm run build   # 执行生产环境打包npm run preview  #预览生产环境打包后的项目</code></pre><h3 id="四、Vite-的依赖预构建"><a href="#四、Vite-的依赖预构建" class="headerlink" title="四、Vite 的依赖预构建"></a>四、Vite 的依赖预构建</h3><blockquote><p>当你在开发环境下首次启动 vite 时，Vite 在本地加载你的站点之前预构建了项目依赖，本质就是做了以下两件事：</p><ul><li>针对依赖使用esbuild打包处理</li><li>针对打包后的依赖文件做缓存</li><li>详细查阅，Vue 官方文档 - <a href="https://cn.vitejs.dev/guide/dep-pre-bundling.html">依赖预构建</a></li></ul></blockquote><blockquote><p>你现在可能有以下 4 个疑问：</p></blockquote><ul><li>何为依赖 ？</li><li>为什么依赖需要打包 ？</li><li>为什么采用esbuild来打包，而不是别的工具呢 ？</li><li>如何对依赖做缓存 ？</li></ul><h4 id="区分依赖与源码"><a href="#区分依赖与源码" class="headerlink" title="区分依赖与源码"></a>区分依赖与源码</h4><blockquote><p>Vite 通过在一开始将应用中的模块区分为<strong>依赖</strong>和<strong>源码</strong>两类，改进了开发服务器启动时间。</p></blockquote><ul><li>依赖模块： 大多为在开发时不会变动的纯<code>JavaScript</code>，这里通常指引用的第三方模块。</li><li>源码模块： 通常指由我们自己写的那部分代码，如自已写 CSS 样式、Vue 组件、JS 代码。<blockquote><ul><li>在开发环境下，Vite 并不会对源码做打包工作，但对于依赖（第三方模块）会做相关的打包工作。</li></ul></blockquote></li></ul><p>通过前面学习，我们知道源码不打包主要是为了更快的开发服务启动，那依赖为什么又要做打包处理呢 ？</p><h4 id="依赖打包原因"><a href="#依赖打包原因" class="headerlink" title="依赖打包原因"></a>依赖打包原因</h4><blockquote><p>依赖做打包处理主要有两个目的：</p></blockquote><ul><li>代码兼容性</li><li>更好的性能</li></ul><ol><li>代码兼容性<blockquote><p>在开发阶段中，Vite 的开发服务器将所有代码视为<strong>原生 ES 模块</strong>，但以下两种情况，必须处理</p></blockquote></li></ol><ul><li>针对开发中用到的第三方模块（依赖），采用如下 <code>import</code> 语法导入模块时，浏览器是<strong>不能识别的</strong>，如下：</li></ul><pre><code>import axios from &quot;axios&quot;; // ES 模块   浏览器可不知道要到node_modules目录下去找axios</code></pre><ul><li>第三方模块所使用的模块系统<strong>不一定</strong>是 ES 模块的规范，可能是<code>CommonJS</code>或<code>UMD</code>等，Vite 必须先将以<code>CommonJS</code>或<code>UMD</code>形式提供的依赖项转换为 ES 模块。</li></ul><pre><code>// node.js 导出模块module.exports = &#123;  a: 1,  b: 2,&#125;;// 导航模块const obj = require(&quot;./b.js&quot;);console.log(obj.a);console.log(obj.b);</code></pre><ol start="2"><li>更好的性能</li></ol><ul><li>为了提高后续页面的加载性能，Vite 将那些具有许多内部模块的 ESM 依赖项转换为<strong>单个模块</strong>。</li><li>有些包将它们的 ES 模块构建为许多单独的文件，彼此导入。例如，<code>lodash-es</code> 有超过 300 个内置模块！当我们执行 <code>import &#123; debounce &#125; from &#39;lodash-es&#39;</code> 时，浏览器同时发出 300 多个 HTTP 请求！即使服务器能够轻松处理它们，但大量请求会导致浏览器端的网络拥塞，使页面加载变得明显缓慢。</li><li>通过将 <code>lodash-es</code> 预构建成单个模块，现在我们只需要一个 HTTP 请求！<ul><li><code>lodash-es</code>是使用 ES6 的模块语法编写的一个高性能的 <code>JavaScript</code> 实用工具库</li></ul></li></ul><h4 id="为什么采用-esbuild-依赖预构建"><a href="#为什么采用-esbuild-依赖预构建" class="headerlink" title="为什么采用 esbuild 依赖预构建"></a>为什么采用 esbuild 依赖预构建</h4><blockquote><p><code>esbuild</code> 使用 <code>Go</code> 编写，并且比以 JavaScript 编写的打包器（如：WebPack 和 Rollup）预构建依赖快 <code>10-100</code> 倍。所以 Vite 采用<code>esbuild</code>打包速度会非常快。</p><p>以下是 <code>esbuild</code> 官方提供的一个关于几种不同打包工具的打包速度对比。<br><img src="esbuild速度对比.png"></p></blockquote><h4 id="文件缓存与浏览器缓存"><a href="#文件缓存与浏览器缓存" class="headerlink" title="文件缓存与浏览器缓存"></a>文件缓存与浏览器缓存</h4><blockquote><p>Vite 对打包后的依赖文件做了：文件缓存和浏览器缓存</p></blockquote><ol><li>文件缓存</li></ol><ul><li>Vite 将预构建的依赖项缓存到 <code>node_modules/.vite</code> 中。也就是把依赖打包后生成的 JS 文件，保存在当前项目的<code>node_modules/.vite</code>目录下缓存起来。</li><li>在后续启动开发服务时，如果<code>node_modules/.vite</code>下能找到对应的缓存文件，则直接使用，不会再进行依赖预构建。</li><li>依赖模块在打包后，在<code>node_modules/.vite</code>下会多出<code>.js</code>和<code>.map</code>两个 JS 文件，本质就是将依赖打包后文件缓存下来</li></ul><ol start="2"><li>浏览器缓存</li></ol><ul><li>对于已预构建的依赖请求使用 HTTP 头 <code>max-age=31536000, immutable</code>进行强缓存，以提高开发期间页面重新加载的性能。</li><li>一旦被缓存，这些请求将永远不会再次访问开发服务器，而是直接从缓存中读取。</li></ul><h4 id="总结-2"><a href="#总结-2" class="headerlink" title="总结"></a>总结</h4><blockquote><p>什么是依赖预构建</p></blockquote><ul><li>在开发环境首次启动<code>vite</code>时，<code>vite</code>会：<ul><li>使用<code>esbulid</code>，对引用的依赖模块(第三方模块)做打包工作。这是为了处理代码的兼容问题，以及提高性能 </li><li>对打包后的依赖文件做<ul><li>文件缓存：将预构建的依赖项缓存到<code>node_modules/.vite</code></li><li>浏览器缓存：对已预构建的依赖请求使用强缓存</li></ul></li></ul></li><li>为什么生产环境下不使用<code>esbuild</code>来构建呢 ？这个官方文档给出了说明。参考地址：<a href="https://cn.vitejs.dev/guide/why.html">https://cn.vitejs.dev/guide/why.html</a></li></ul><h3 id="五、Vite-开发服务器启动快的原因"><a href="#五、Vite-开发服务器启动快的原因" class="headerlink" title="五、Vite 开发服务器启动快的原因"></a>五、Vite 开发服务器启动快的原因</h3><blockquote><p>Vite 在开发环境下之所以能快速的启动服务，除了前面讲到的以下几个原因：</p></blockquote><ul><li>Vite 以原生 ESM 方式(<code>&lt;script type=&quot;module&quot;&gt;</code>)提供源码（源码不打包），让浏览器接管了打包程序的部分工作</li><li>使用<code>esbuild</code>预构建依赖和加快构建速度</li><li>对预构建的依赖做文件缓存与浏览器缓存</li></ul><blockquote><p>还有以下 2 个重要的原因：</p></blockquote><ul><li>启动应用时按需提供代码</li><li>内置了一套原生 ESM 的模块热替换（HMR）</li></ul><h4 id="启动应用时按需提供代码"><a href="#启动应用时按需提供代码" class="headerlink" title="启动应用时按需提供代码"></a>启动应用时按需提供代码</h4><blockquote><p>为什么传统的打包工具在应用启动很慢，而 Vite 确可以做到极快的启动应用。</p><p>这就需要我们了解传统工具在开发环境下的服务启动流程和 Vite 在开发环境下的服务启动流程。</p></blockquote><ol><li>传统工具打包的整个流程图<img src="传统工具打包的整个流程图.png"></li></ol><blockquote><p>注：</p><ul><li>这幅图清淅的描述了 Webpack 的整个打包过程，他是根据<code>entry</code>打包的入口点构建一个<strong>依赖图</strong>，然后将你项目中所需的每一个模块<strong>打包</strong>成一个或多个模块，最后再<strong>启动</strong>服务器。</li><li>如果项目比较大，打包所需要的时间就会很长，这就是为什么传统打包工具在启动服务时会非常慢的原因。</li><li>同时，因为项目都是基于打包器启动，重建整个包的效率很低，每次更新相当于做了一次打包工作，每次更新都要先打包</li></ul></blockquote><ol start="2"><li>Vite构建项目时的，构建流程图<img src="Vite构建项目的构建流程图.png"></li></ol><blockquote><p>注：<br>Vite 在开发环境下构建项目时，先<code>esbuild</code>依赖<strong>预构建</strong>，然后<strong>启动</strong>服务器，加载<code>index.html</code>项目<strong>入口</strong>文件，根据访问的路由<strong>按需加载</strong>对应的模块，那些不在当前路由内的模块，并不会去加载。</p></blockquote><h4 id="模块热替换"><a href="#模块热替换" class="headerlink" title="模块热替换"></a>模块热替换</h4><blockquote><p>Vite 提供了一套原生 <code>ESM</code> 的 <code>HMR API</code>。具有 HMR 功能的框架可以利用该 API 提供即时、准确的更新，而无需重新加载页面或清除应用程序状态。</p><p>模块热替换我们在讲 WebPack 的时候讲过，所以这里不再讲解，忘记的可以看之前的资料。</p></blockquote><ul><li>当我们使用 Vite 脚手架创建应用程序时，所选模板已经为你预先配置了这些</li></ul><pre><code>npm create vite@latest</code></pre><h4 id="总结：Vite-开发服务启动过程"><a href="#总结：Vite-开发服务启动过程" class="headerlink" title="总结：Vite 开发服务启动过程"></a>总结：Vite 开发服务启动过程</h4><blockquote><p>在开发环境下采用 Vite 构建项目时</p></blockquote><ul><li>首先，Vite 在本地加载你的站点之前<strong>预构建了项目依赖</strong>（采用打包速度极快的<code>esbuild</code>完成依赖预构建）</li><li>其次，将依赖预构建的生成的模块保存在<code>node_modules\vite</code>目录下<strong>缓存</strong>起来</li><li>接着，开启一个<strong>开发服务器</strong>，用来加载当前项目，并且针对依赖预构建生成的模块做<strong>浏览器强缓存</strong>。<ul><li>服务是基于原生 ES 模块，所以在开发环境下 Vite 并不会对开发的源代码进行打包工作，这部分工作交给了浏览器来处理。</li></ul></li><li>在访问页面时，只根据访问的路由<strong>按需加载</strong>对应的模块，那些不在当前路由内的模块，并不会去加载。<blockquote><ul><li>通过以上优化，Vite 解决了传统打包工具存在缓慢的服务启动和缓慢的更新两个问题</li></ul></blockquote></li></ul><h3 id="六、Vite-脚手架创建-Vite-项目"><a href="#六、Vite-脚手架创建-Vite-项目" class="headerlink" title="六、Vite 脚手架创建 Vite 项目"></a>六、Vite 脚手架创建 Vite 项目</h3><blockquote><p>Vite 为了方便我们创建 Vite 项目，给我们提供了更快捷的方式，可以通过 Vite 脚手架创建 Vite 项目</p></blockquote><h4 id="创建-Vite-项目"><a href="#创建-Vite-项目" class="headerlink" title="创建 Vite 项目"></a>创建 Vite 项目</h4><ul><li>执行以下命令，就可以创建一个简单版的 Vite 项目</li></ul><pre><code>npm create vite@latest</code></pre><ul><li>执行该命令之后，会出现以下代码<img src="用vite脚手架创建vite项目.png"></li></ul><blockquote><ul><li>创建 Vite 项目，是选择第一个<code>Vanilla</code>进入后，再选择 <code>JS</code> 就可以了</li></ul></blockquote><ul><li>回车后，会出现以代码<img src="vite脚手架启动开发服务命令.png"></li></ul><blockquote><p>按顺序执行以上三个命令，就可以启动开发服务，因为：</p><ul><li>新建的<code>vite-project</code>文件夹为项目的根目录，需要执行<code>cd vite-project</code>进入根目录下</li><li>其次，并没有安装项目相关的依赖包，需要在根目录下执行<code>npm install</code>安装<code>package.json</code>中提供的开发和生产依赖包。</li><li>最后，执行<code>npm run dev</code>启动开发服务。</li></ul></blockquote><blockquote><p>注意：</p></blockquote><ul><li>脚手架并没有安装项目相关的依赖包，因为不同项目需要的不一样，为了不造成冗余，它在你选择完项目类型后，会根据你的选择创建不同的文件内容</li><li>虽然在<code>package.json</code>文件，会有相应的开发和生产依赖，但安装包需要你根据命令安装</li></ul><h4 id="目录结构分析"><a href="#目录结构分析" class="headerlink" title="目录结构分析"></a>目录结构分析</h4><blockquote><p>以下是通过<code>npm create vite@latest</code>命令创建后，生成的目录结构。</p></blockquote><pre><code>vite-project   //  项目目录（项目名称）└─ ├─ counter.js   ├─ index.html  // 项目打包的入口文件   ├─ javascript.svg   ├─ .gitignore  // git在提交时，忽略的文件   ├─ main.js  // index.html文件用到的main.js文件   ├─ package-lock.json   ├─ package.json   ├─ public  // 不会被起其它文件引用的资源放在这个目录   │  └─ vite.svg  // 浏览网页时，出现在地址栏上方的小图标   └─ style.css</code></pre><ul><li>public 目录<blockquote><p>如果你有下列这些资源，应当放在 public 目录下</p></blockquote></li><li>不会被源码引用（例如 <code>robots.txt</code>）</li><li>必须保持原有文件名（没有经过<code>hash</code>，比如浏览器右上角显示公司 logo 的小图标）</li><li>… 或者你压根不想引入该资源，只是想得到其 URL<blockquote><ul><li>public 目录下的资源，在开发时能直接通过<code>/</code>根跟径访问，并且打包时会被完整复制到目标目录的根目录下（如：dist 目录）</li><li>注意：<code>public</code>中的资源<strong>不应该</strong>被<code>JavaScript</code>文件引用</li></ul></blockquote></li></ul><h4 id="Vite-脚手架作用"><a href="#Vite-脚手架作用" class="headerlink" title="Vite 脚手架作用"></a>Vite 脚手架作用</h4><blockquote><p><strong>脚手架：</strong>帮我们把开发项目时需要做的一些常规项给做了，而提高我们的开发效率。如：</p></blockquote><ul><li>创建一个简单的项目示例</li><li>配置项目启动脚本命令</li><li>配置项目需要用到的开发与生产依赖包</li><li>…..</li></ul><h3 id="七、Vite-中使用插件"><a href="#七、Vite-中使用插件" class="headerlink" title="七、Vite 中使用插件"></a>七、Vite 中使用插件</h3><h4 id="JS-兼容型处理"><a href="#JS-兼容型处理" class="headerlink" title="JS 兼容型处理"></a>JS 兼容型处理</h4><blockquote><p>Vite 在生产环境下打包时，默认是不会处理 JS 的兼容型问题，需要借助 Vite 的<code>@vitejs/plugin-legacy</code>插件来实现。</p></blockquote><ol><li>安装插件<blockquote><p>执行以下命名，安装<code>@vitejs/plugin-legacy</code>插件 ，<a href="https://github.com/vitejs/vite-plugin-vue/tree/main/packages/plugin-vue">点击查看插件详细教程</a></p></blockquote></li></ol><pre><code>npm i -D @vitejs/plugin-legacynpm i -D terser  #必须安装Terser，因为 @vitejs/plugin-legacy插件使用Terser进行压缩JS代码</code></pre><blockquote><ul><li>插件安装成功后，我们需要在 Vite 的配置文件中来配置插件，这样才能在打包时找到对应的插件做相关工作</li></ul></blockquote><ol start="2"><li>配置插件</li></ol><ul><li>在根目录下，<strong>新建</strong><code>vite.config.js</code>文件，此文件为 Vite 的配置文件。</li><li>配置文件采用 ES 模块语法，对外<strong>导出</strong>一个对象。</li></ul><pre><code>// vite.config.jsexport default &#123;&#125;;</code></pre><ul><li>通过<code>import</code>语法<strong>导入</strong>插件，并在配置文件导出对象的<code>plugins</code>选项中配置插件。<blockquote><ul><li>指定转码后的代码需要兼容那些版本的浏览器</li></ul></blockquote></li></ul><pre><code>import legacy from &quot;@vitejs/plugin-legacy&quot;;export default &#123;  // 插件配置选项，plugins的值是一个数组，其中的第一项代表一个插件  plugins: [    // 配置legacy插件    legacy(&#123;      // 指定转码后的代码需要兼容那些版本的浏览器,      // 与webpack中`@babel/preset-env`预设中设置了`targets`参数的含义一样      targets: &quot;Firefox &gt; 23&quot;,    &#125;),  ],&#125;;</code></pre><ol start="3"><li>生产打包</li></ol><ul><li><p>执行<code>npm run build</code>完成生产环境下的打包，最后在生成的<code>dist/assets</code>目录下生成了三个 <code>JS</code> 文件，如下图</p><img src="JS兼容性处理-打包文件.png"></li><li><p>查看打包后生成的<code>index.html</code>文件，</p><blockquote><ul><li>发现新增了一些脚本，这些脚本根据浏览器的支持程度来动态的引入正常版本文件还是带有 <code>legacy</code> 字样的遗留版本文件。</li><li>当项目运行在一些版本较低的浏览器时，插件添加的脚本会自动加载 legacy 版本的文件。</li></ul></blockquote></li><li><p>执行<code>npm run preview</code>来查看打包后的项目</p><blockquote><ul><li>当我们在最新的<code>Chorme</code>浏览器中访问项目时，Network中只有打包生成的<code>index-36c8d0ed.js</code>文件。</li><li>当我们在<code>firefox 32</code>版的浏览器中访问项目时，Network中请求加载了 3 个 JS文件，也就是<code>dist/assets</code>目录的那三个</li></ul></blockquote></li></ul><h4 id="配置文件智能提示功能"><a href="#配置文件智能提示功能" class="headerlink" title="配置文件智能提示功能"></a>配置文件智能提示功能</h4><ul><li>可以使用 <code>defineConfig</code> 工具函数来为配置添中智能提示功能，具体写法如下</li></ul><pre><code>import &#123; defineConfig &#125; from &quot;vite&quot;;export default defineConfig(&#123;  // ...&#125;);</code></pre><ul><li>与<code>@vitejs/plugin-legacy</code>插件结合，<code>vite.config.js</code>文件配置如下：</li></ul><pre><code>import legacy from &quot;@vitejs/plugin-legacy&quot;;import &#123; defineConfig &#125; from &quot;vite&quot;;export default defineConfig(&#123;  plugins: [    legacy(&#123;      targets: &quot;Firefox &gt; 23&quot;,    &#125;),  ],&#125;);</code></pre><blockquote><p>关于其它相关配置，也可以让配置有智能提示，查阅 <a href="https://cn.vitejs.dev/config/#config-intellisense">Vite 官方- 配置智能提示</a></p></blockquote><h4 id="支持-Vue-结尾的文件"><a href="#支持-Vue-结尾的文件" class="headerlink" title="支持.Vue 结尾的文件"></a>支持.Vue 结尾的文件</h4><blockquote><p>Vue 的单文件组件都是写在以<code>.vue</code>结尾的文件，但是 Vite 默认是不支持<code>.vue</code>的文件的。</p></blockquote><ul><li>需要通过第三方的<code>@vitejs/plugin-vue</code>插件实现。</li></ul><p><strong>安装插件</strong></p><ul><li>首先：执行以下命令，安装<code>@vitejs/plugin-vue</code>插件包</li></ul><pre><code>npm i -D @vitejs/plugin-vue</code></pre><ul><li>然后：在<code>vite.config.js</code>配置文件中，配置对应的插件，如下</li></ul><pre><code>// 导入包import vue from &quot;@vitejs/plugin-vue&quot;;export default (&#123;  // 配置vue插件。  plugins: [vue()],&#125;);</code></pre><ul><li>执行<code>npx vite</code>或<code>npm run dev</code>命令就可以成功启动项目</li><li>执行<code>npm run build</code>也可以正常完成生产环境下打包</li></ul><h4 id="Vite-脚手架初始-Vue-项目"><a href="#Vite-脚手架初始-Vue-项目" class="headerlink" title="Vite 脚手架初始 Vue 项目"></a>Vite 脚手架初始 Vue 项目</h4><ul><li>执行<code>npm create vite@latest</code>命令</li><li>在命令执行过程，我们选择支持的框架为<code>Vue</code>，然后，再选择对应的<code>javascript</code>或<code>TypeScript</code></li><li>根据提示，进入项目根目录，下载开发与生产依赖，启动开发服务</li><li>按以上步骤操作后，最终搭建一个简单的 Vue 项目，项目结构如下：<img src="vite脚手架创建vue项目.png"></li></ul><blockquote><p>Vite 脚手架创建<code>vue</code>项目时，脚手架帮我们做了以下几件事</p></blockquote><ul><li>初始化一个简单的<code>vue</code>项目</li><li>在<code>package.json</code>中配置启动<code>vue</code>项目用到的脚本命令</li><li>在<code>package.json</code>中配置了项目需要用到的开发和生产依赖包（如：<code>vite、vue、@vitejs/plugin-vue</code>），我们只需要执行<code>npm i</code>就可以一键安装</li><li>在<code>vite.config.js</code>中配置好使用的<code>@vitejs/plugin-vue</code>插件<blockquote><ul><li>注意：<code>@vitejs/plugin-vue</code>插件和配置文件智能提示功能的<code>defineConfig</code>工具函数都已经自动配置好了</li></ul></blockquote></li></ul><h3 id="八、Vite-静态资源处理"><a href="#八、Vite-静态资源处理" class="headerlink" title="八、Vite 静态资源处理"></a>八、Vite 静态资源处理</h3><blockquote><p>Vite 作为一个开箱即用的前端构建工具，默认支持 JS、CSS、Sass、Less、JSON、图片、HTML 等静态资源的处理。</p><p>但有些情况下还是需要做额外的配置，我们挑了一些比较常用的功能来做讲解：</p><ul><li>CSS 的默认处理行为</li><li>CSS 模块化处理</li><li>CSS 预处理器</li><li>CSS 兼容性处理</li><li>限定大小的图片转为 Base64 编码</li><li>JSON 的导入</li><li>JSON 支持具名导入</li></ul></blockquote><h4 id="CSS-的默认处理行为"><a href="#CSS-的默认处理行为" class="headerlink" title="CSS 的默认处理行为"></a>CSS 的默认处理行为</h4><blockquote><p>css 文件中通过<code>@import</code>导入的其它 CSS，能自动识别，被打包到当前 CSS 中。</p></blockquote><ul><li>开发环境下<blockquote><ul><li>JS 文件中以<code>import</code>导入的<code>.css</code>文件内容最终处理后，会插入到<code>index.html</code>文件的<code>&lt;style&gt;</code>标签中，同时自带<code>HMR</code> 支持。</li><li>对于<code>&lt;link&gt;</code>标签引入的 CSS 不做额外处理。</li></ul></blockquote></li><li>生产环境下<blockquote><ul><li>通过<code>&lt;link&gt;</code>标签引入的 CSS 和<code>import</code>导入的 CSS 打包到<strong>一个</strong> CSS 文件中，输出在项目的<code>dist/assets</code>目录下。</li></ul></blockquote></li></ul><h4 id="CSS-模块化处理"><a href="#CSS-模块化处理" class="headerlink" title="CSS 模块化处理"></a>CSS 模块化处理</h4><ul><li><code>Vite</code>允许我们对 CSS 进行模块化处理，也就对 CSS 类名和选择器的<strong>作用域</strong>进行限定的一种方式。</li><li><code>Vite</code>会把任何以<code>.module.css</code>为的缀名的 CSS 文件看成一个模块，并采用<code>CSS module</code>的方式来处理<ul><li>也就是进行样式隔离，相同命名不会冲突</li></ul></li></ul><h4 id="CSS-预处理器"><a href="#CSS-预处理器" class="headerlink" title="CSS 预处理器"></a>CSS 预处理器</h4><blockquote><p>Vite 默认是支持<code>.scss</code>、<code>.sass</code>、<code>.less</code>、<code>.stylus</code>结尾的文件，但必需要安装相应的预处理器依赖。</p></blockquote><ul><li><p><code>.scss</code>和<code>.sass</code>对应的预处理器依赖包为 <code>sass</code></p></li><li><p><code>.less</code>对应的的预处理器依赖包为 <code>less</code> 包</p></li><li><p><code>.stylus</code>对应的的预处理器依赖包为 <code>stylus</code> 包</p></li><li><p>执行以下命令，安装预处理器依赖的 sass 包</p></li></ul><pre><code>npm i sass -D</code></pre><ul><li>执行<code>npx vite</code>命令，在浏览器查看效果</li><li>执行<code>npx vite build</code>命令后，在<code>dist/assets</code>目录下生成了对应的 <code>css</code> 文件</li></ul><h4 id="CSS-兼容性处理"><a href="#CSS-兼容性处理" class="headerlink" title="CSS 兼容性处理"></a>CSS 兼容性处理</h4><blockquote><p>如果我们想要 CSS 能兼容不同的浏览器，那我们就需要为相关的 CSS 属性添加兼容性前缀。我们自己去书写每个 CSS 前缀太麻烦了，所以我们可以利用 <code>PostCSS</code> 来帮我们处理。</p></blockquote><ul><li><p><code>Vite</code>内置了 PostCSS，我们只需要安装相关的 PostCSS 插件，并做好相关的 PostCSS 配置就可以了。</p></li><li><p><code>autoprefixer</code>插件，是专门用来处理 CSS 兼容性的插件。我们只需要安装这个插件，并配置好就可以</p></li><li><p>执行以下命令，安装<code>autoprefixer</code>插件</p></li></ul><pre><code>npm i autoprefixer@10.4.14 --save-dev</code></pre><ul><li>方式一：在<code>vite.config.js</code>文件的<code>css.postcss</code>选项中来配置这个插件</li></ul><pre><code>// 导入插件import autoprefixer from &quot;autoprefixer&quot;;export default &#123;  css: &#123;    postcss: &#123;      // 配置postcss插件      plugins: [        autoprefixer(&#123;          // 指定兼容 99.5%的浏览器。          browsers: [&quot;cover 99.5%&quot;],        &#125;),      ],    &#125;,  &#125;,&#125;;</code></pre><ul><li>方式二：与JS保持相同的浏览器兼容处理<blockquote><ul><li>把对浏览器支持的 <code>browsers</code> 配置，从 <code>postcss</code> 的插件配置中去掉，改写在<code>package.json</code>的<code>browserslist</code>字段中配置，如下</li><li><code>package.json</code>文件</li></ul></blockquote></li></ul><pre><code>&#123;  &quot;devDependencies&quot;: &#123;&#125;,  &quot;browserslist&quot;: [&quot;cover 99.5%&quot;]&#125;</code></pre><blockquote><ul><li><code>vite.config.js</code>文件</li></ul></blockquote><pre><code>// 导入插件import autoprefixer from &quot;autoprefixer&quot;;export default &#123;  css: &#123;    postcss: &#123;      // 配置postcss插件      plugins: [        autoprefixer(),      ],    &#125;,  &#125;,&#125;;</code></pre><h4 id="图片转为-base64-编码"><a href="#图片转为-base64-编码" class="headerlink" title="图片转为 base64 编码"></a>图片转为 base64 编码</h4><blockquote><p>如果想要在<strong>生产环境</strong>下打包时，针对一定大小的图片转成 <code>Base64</code>编码，只需要在<code>vite.config.js</code>中添加如下配置即可</p><ul><li>注意：在开发环境下不会变化</li></ul></blockquote><pre><code>import &#123; defineConfig &#125; from &quot;vite&quot;;export default defineConfig(&#123;  build: &#123;    // 10kb以下，转Base64    assetsInlineLimit: 1024 * 10,  &#125;,&#125;);</code></pre><h4 id="JSON-文件处理"><a href="#JSON-文件处理" class="headerlink" title="JSON 文件处理"></a>JSON 文件处理</h4><blockquote><p>JSON 可以被直接导入 —— 同样支持<strong>具名导入</strong></p></blockquote><ul><li>新建<code>data.json</code>文件，内容如下</li></ul><pre><code>&#123;  &quot;code&quot;: &quot;0000&quot;,  &quot;data&quot;: [    &#123;      &quot;category_id&quot;: 1001,      &quot;title&quot;: &quot;人气 TOP&quot;    &#125;,    &#123;      &quot;category_id&quot;: 1002,      &quot;title&quot;: &quot;爆款套餐&quot;    &#125;  ],  &quot;message&quot;: &quot;成功&quot;&#125;</code></pre><ul><li>新建<code>index.js</code>文件内容如下<blockquote><ul><li>可以整个导入</li><li>也可以通过解构赋值来具名导入，没导入的就会被<code>treeshaking</code></li></ul></blockquote></li></ul><pre><code>// 导入整个JSON，最终json为JSON对象import json from &quot;./data.json&quot;;console.log(json);//  对一个根字段使用具名导入 —— 有效帮助 treeshaking！import &#123; data &#125; from &quot;./data.json&quot;;console.log(data);</code></pre><ul><li>新建<code>index.html</code>内容如下</li></ul><pre><code>&lt;script type=&quot;module&quot; src=&quot;./index.js&quot;&gt;&lt;/script&gt;</code></pre><h3 id="九、Vite-常规配置"><a href="#九、Vite-常规配置" class="headerlink" title="九、Vite 常规配置"></a>九、Vite 常规配置</h3><h4 id="Vite-开发服务器配置"><a href="#Vite-开发服务器配置" class="headerlink" title="Vite 开发服务器配置"></a>Vite 开发服务器配置</h4><blockquote><p>当我们执行<code>npx vite</code>或<code>npx run vite</code>命令时，会启动一个开发服务。Vite提供了相关的配置允许更改服务的主机，端口等。</p><p>通过修改<code>vite.config.js</code>文件导出对象的<code>server</code>选项中来配置。</p></blockquote><ul><li>具体如下：</li></ul><pre><code>import &#123; defineConfig &#125; from &quot;vite&quot;;export default defineConfig(&#123;  server: &#123;    port: 8880, // 自定义端口，默认为5173    open: true, // 服务启动后，自动在浏览器中打开，默认是不打开的    hmr: true, // 为开发服务启用热更新，默认是不启用热更新的  &#125;,&#125;);</code></pre><blockquote><ul><li>更多配置：查阅 Vite 官方文档 - <a href="https://cn.vitejs.dev/config/server-options.html">开发服务选项配置img srcui</a></li></ul></blockquote><h4 id="Vite-代理服务配置"><a href="#Vite-代理服务配置" class="headerlink" title="Vite 代理服务配置"></a>Vite 代理服务配置</h4><blockquote><p>当我们在项目中利用<code>Ajax</code>向服务端发请求时，会遇到跨域的限制。</p><p>为了能让请求成功，我们通常会在请求和真实服务之间架设一个代理服务。代理服务再向真实服务器发请求拿到数据并返回给到客户端<br><img src="代理跨域.png"></p><ul><li>Vite允许我们为开发服务配置自定义代理规则，我们只需要在<code>server.proxy</code>选项下进行相关配置就可</li></ul></blockquote><ul><li><code>server.proxy</code>配置</li></ul><pre><code>import &#123; defineConfig &#125; from &#39;vite&#39;export default defineConfig(&#123;    server:&#123;        proxy:&#123;            // /api是字符串 http://localhost:5173/api 的简写法            // 以下表示，当我们向 http://localhost:5173/api地址及下级路径发请求时，帮我转发到`http://127.0.0.1:8990/api`地址及对应的下级路径发请求            // http://127.0.0.1:8990/api --&gt; http://127.0.0.1:8990/api            // http://127.0.0.1:8990/api/menu --&gt; http://127.0.0.1:8990/api/menu            &quot;/api&quot;:&quot;http://127.0.0.1:8990/api            //        &#125;    &#125;&#125;)</code></pre><ol><li>代码演示 -（项目结构）<blockquote><p>我们利用<code>node</code>来搭建两个请求数据的服务</p></blockquote></li></ol><ul><li><p><code>http://127.0.0.1:8990/api/menu</code>获取菜单数据</p></li><li><p><code>http://127.0.0.1:8990/api/course</code>获取课程数据</p><blockquote><p>然后在 Vite 项目中，利用<code>axios</code>向上面两个地址发送请求来获取数据</p><p>因为受到跨域限制，所以我们需要设置开发服务的代理服务，利用代理服务帮帮我们拿到数据并转发给我们。</p></blockquote></li><li><p>整体项目目录结构如下</p></li></ul><pre><code>vite├─ data   // JSON数据，node服务会读取JSON文件中内容，然后返回给客户端│  ├─ course.json│  └─ menu.json├─ index.html  // Vite 项目的入口文件├─ index.js  // 文件中会利用axios向服务端发请求获取数据├─ node-api.js  // 搭建node服务，返回JSON数据├─ package-lock.json├─ package.json└─ vite.config.js  // 配置文件</code></pre><ol start="2"><li>代码演示 - 搭建 node 服务</li></ol><ul><li><code>node-api.js</code>文件内容如下 ：</li></ul><pre><code>const http = require(&quot;http&quot;); // 加载http模块,用来创建http服务const fs = require(&quot;fs&quot;); // 加载fs模块，用来操作文件// 创建http服务，req请求对象   res响应对象http  .createServer((req, res) =&gt; &#123;    // 获取请求地址主机端口后地址    const url = req.url;    // 设置响应头，响应的数据类型    res.writeHead(200, &#123;      &quot;Content-Type&quot;: &quot;application/json&quot;,    &#125;);    // 请求地址拦截    if (url === &quot;/api/menu&quot;) &#123;      // 读取JSON文件中数据，并响应到客户端      const data = fs.readFileSync(&quot;./data/menu.json&quot;, &quot;utf-8&quot;);      res.end(data);    &#125; else if (url === &quot;/api/course&quot;) &#123;      const data = fs.readFileSync(&quot;./data/course.json&quot;, &quot;utf-8&quot;);      res.end(data);    &#125; else &#123;      res.end(&quot;Hello Node&quot;);    &#125;  &#125;)  .listen(&quot;8990&quot;); // 设置端口号// 服务器正常启动，打印下面这句话作为提示console.log(&quot;Server running at http://127.0.0.1:8990&quot;);</code></pre><ul><li>data 文件夹中<code>product.json</code>和<code>menu.json</code>文件，内容如下</li></ul><pre><code>&#123;  &quot;code&quot;: &quot;0000&quot;,  &quot;data&quot;: [    &#123;      &quot;Name&quot;: &quot;丝袜奶茶&quot;,      &quot;imageUrl&quot;: &quot;https://sce7a2b9c9d95a-sb-qn.qiqiuyun.net/files/course/2022/08-29/210311f423d6528839.jpg&quot;,      &quot;desc&quot;: &quot;奶茶香飘飘&quot;    &#125;,    &#123;      &quot;Name&quot;: &quot;柠檬水&quot;,      &quot;imageUrl&quot;: &quot;https://sce7a2b9c9d95a-sb-qn.qiqiuyun.net/files/course/2020/03-30/13215973670d532706.jpg&quot;,      &quot;desc&quot;: &quot;暴打柠檬&quot;    &#125;  ],  &quot;message&quot;: &quot;成功&quot;&#125;</code></pre><pre><code>&#123;  &quot;code&quot;: &quot;0000&quot;,  &quot;data&quot;: [    &#123;      &quot;category_id&quot;: 1001,      &quot;title&quot;: &quot;人气 TOP&quot;    &#125;,    &#123;      &quot;category_id&quot;: 1005,      &quot;title&quot;: &quot;甜品小点&quot;    &#125;  ],  &quot;message&quot;: &quot;成功&quot;&#125;</code></pre><ul><li>以上文件创建好后，只需要 Vite 目录执行<code>node node-api.js</code>就可以启动<code>node</code>服务。</li><li>访问<code>http://127.0.0.1:8990/api/menu</code>和<code>http://127.0.0.1:8990/api/course</code>地址，可以查看到返回的<code>JSON</code>字符串。</li></ul><ol start="3"><li>代码演示 - 搭建 Vite 项目</li></ol><ul><li><code>index.html</code>文件内容如下</li></ul><pre><code>&lt;script type=&quot;module&quot; src=&quot;./index.js&quot;&gt;&lt;/script&gt;</code></pre><ul><li><code>index.js</code>文件内容如下</li></ul><pre><code>import axios from &quot;axios&quot;;// 向 http://localhost:5173/api/menu 发请求,因为设置了代理，代理转发向http://127.0.0.1:8990/api/menu 发请求axios.get(&quot;/api/menu&quot;).then((res) =&gt; &#123;  console.log(res.data.data);&#125;);// 向 http://localhost:5173/api/course 发请求 因为设置了代理，代理转发向http://127.0.0.1:8990/api/course 发请求axios.get(&quot;/api/course&quot;).then((res) =&gt; &#123;  console.log(res.data);&#125;);</code></pre><ul><li><code>vite.config.js</code>配置文件内如下</li></ul><pre><code>import &#123; defineConfig &#125; from &quot;vite&quot;;export default defineConfig(&#123;  server: &#123;    proxy: &#123;      &quot;/api&quot;: &quot;http://127.0.0.1:8990&quot;,    &#125;,  &#125;,&#125;);</code></pre><ul><li>新建终端</li><li>初始化项目</li></ul><pre><code>npm init -y</code></pre><ul><li>安装vite</li></ul><pre><code>npm i vite -D</code></pre><ul><li>安装<code>axios</code></li></ul><pre><code>npm i axios</code></pre><ul><li>最后执行<code>npx vite</code>启动开发服务，访问<code>http://localhost:5173/</code>地址，可以看到控制台正常打印了请求到的内容。</li></ul><h4 id="Vite-中如何配置别名路径"><a href="#Vite-中如何配置别名路径" class="headerlink" title="Vite 中如何配置别名路径"></a>Vite 中如何配置别名路径</h4><ul><li>当我们在访问静态资源时，如果书写的路径非常长，那每次书写时就会非常麻烦。</li><li>如果能把相同部分的路径用别名代替，那我们在书写路径时只需要书写别名+不同的路径部分就好了。</li><li>我们可以在<code>vite</code>的配置文件中， 为文件系统路径配置别名，如下：</li></ul><pre><code>import &#123; defineConfig &#125; from &#39;vite&#39;export default defineConfig(&#123;    resolve:&#123;        alias:&#123;            /*                @js 为 路径 /src/assets/js 的别名                导入JS：  import &#123; username &#125;  from &quot;/src/assets/js/basic.js&quot;                可简写成： import &#123; username &#125; from &quot;@js/basic.js&quot;            */          &quot;@js&quot;:&quot;/src/assets/js&quot;,    &#125;  &#125;&#125;)</code></pre><blockquote><p>注意事项</p><ul><li>当使用文件系统路径的别名时，请始终使用<strong>绝对路径</strong>，相对路径的别名值会原封不动地被使用，因此无法被正常解析。</li><li>在<code>index.html</code>项目入口文件中<strong>不要</strong>使用别名加载文件，因为启动开发服务并不会对源码做打包</li></ul></blockquote><h4 id="vite-中如何配置多入口，进行多页面开发"><a href="#vite-中如何配置多入口，进行多页面开发" class="headerlink" title="vite 中如何配置多入口，进行多页面开发"></a>vite 中如何配置多入口，进行多页面开发</h4><ul><li>Vite 在<strong>开发环境</strong>下默认是多入口开发的</li><li>在<strong>生产环境</strong>下，如果想要多入口开发，需要额外的配置。</li><li>Vite 在生产环境下是利用<code>rollup</code>来实现打包，所以我们需要对<code>rollup</code>的打包入口进行配置。</li></ul><blockquote><p>开发环境下</p></blockquote><ul><li>如果在项目根目录下同时存在<code>index.html</code>和<code>app.html</code>两个页面</li><li>在浏览器访问项目时默认打开的是<code>index.html</code></li><li>访问<code>app.html</code>需要在地址后添加<code>app.html</code>，如<code>http://localhost:5173/app.html</code></li></ul><blockquote><p>生产环境下，多入口打包配置如下</p></blockquote><pre><code>import &#123; defineConfig &#125; from &quot;vite&quot;;import &#123; resolve &#125; from &quot;path&quot;;export default defineConfig(&#123;  // 生产环境下打包配置在build选项中配置  build: &#123;    // rollup 相关配置在rollupOptions选项中配置    rollupOptions: &#123;      // 打包入口，以下是多入口      input: &#123;        index: resolve(__dirname, &quot;index.html&quot;),        app: resolve(__dirname, &quot;app.html&quot;),      &#125;,    &#125;,  &#125;,&#125;);</code></pre><ul><li>执行<code>npx vite build</code>打包，会发现生成的<code>dist</code>目录下有一个<code>modulepreload-polyfill.js</code>文件，是自动注入的 模块预加载 <code>polyfill</code><ul><li><code>modulepreload</code>模块预加载可以预加载原生模块，保证某些文件可以不必等到执行时才加载</li></ul></li><li>观察<code>dist</code>目录，会发现所有资源文件全部打包后放在了<code>dist/assets</code>目录下，如果我们想按文件类型，将 JS、CSS、Images 分别放到 JS、CSS、Images 文件夹，还需要我们做额外配置</li></ul><h4 id="Vite-打包后资源分类存到对应文件夹"><a href="#Vite-打包后资源分类存到对应文件夹" class="headerlink" title="Vite 打包后资源分类存到对应文件夹"></a>Vite 打包后资源分类存到对应文件夹</h4><ul><li>可以做如下配置：</li></ul><pre><code>import &#123; defineConfig &#125; from &quot;vite&quot;;import &#123; resolve &#125; from &quot;path&quot;;export default defineConfig(&#123;  build: &#123;    rollupOptions: &#123;      // 打包输出路径,默认是dist/assets,以下相当于dist/static      assetsDir: &quot;static&quot;,      // 打包入口，以下是多入口      input: &#123;        index: resolve(__dirname, &quot;index.html&quot;),        app: resolve(__dirname, &quot;app.html&quot;),      &#125;,      // 出口设置      output: &#123;        // 入口文件中JS输出地址        entryFileNames: &quot;static/js/[name]-[hash].js&quot;,        // 对代码分割中产生的 chunk 自定义命名        chunkFileNames: &quot;static/chunk/[name]-[hash].js&quot;,        // 资源出口路径(如：图片、css等)        assetFileNames: function (assetInfo) &#123;          const name = assetInfo.name;          if (/.css$/.test(name)) &#123;            return &quot;static/css/[name]-[hash].[ext]&quot;;          &#125; else if (/.[jpe?g|png|gif]$/.test(name)) &#123;            return &quot;static/images/[name]-[hash].[ext]&quot;;          &#125; else &#123;            return &quot;static/[ext]/[name]-[hash].[ext]&quot;;          &#125;        &#125;,      &#125;,    &#125;,  &#125;,&#125;);</code></pre>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Vue </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>网络（二）</title>
      <link href="/2024/01/20/%E7%BD%91%E7%BB%9C%EF%BC%88%E4%BA%8C%EF%BC%89/"/>
      <url>/2024/01/20/%E7%BD%91%E7%BB%9C%EF%BC%88%E4%BA%8C%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<span id="more"></span><h3 id="一、JSON-数据"><a href="#一、JSON-数据" class="headerlink" title="一、JSON 数据"></a>一、<code>JSON</code> 数据</h3><ol><li><p><code>JSON</code> 是什么 ？</p><blockquote><p><code>JSON</code>全称是<code>JavaScript Object Notation</code> ，即：<code>JavaScript</code> 对象表示法</p><ul><li><code>JSON</code>是 <code>Ajax</code> 发送和接收数据的一种格式</li><li><code>JSON</code>是一种轻量级的数据交换格式，常用来做前后端数据交互，其为<strong>字符串类型</strong>。</li><li><code>JSON</code>是一种语法，用来<strong>序列化</strong>对象、数组、数值、字符串、布尔值和 <code>null</code>，但不能是<code>undefined</code>。</li></ul><p>以下我们之前了解过的，都属于一种数据的格式</p><ul><li><code>XML</code></li><li><code>username=icoding&amp;sex=male&amp;age=19</code></li><li><code>JSON</code></li></ul></blockquote></li><li><p>序列化 与 反序列化</p><blockquote><ul><li><strong>序列化</strong>： 将对象转、数组、字符串、布尔值、null 转换成 JSON 字符串</li><li><strong>反序列化（解析）</strong>： 将 JSON 字符串转换为对象、数组、字符串、布尔值、null</li></ul><p><strong>为什么要序列化 ？</strong></p><ul><li>其实序列化最终的目的是为了对象可以<strong>跨平台存储和进行网络传输</strong>。而我们进行跨平台存储和网络传输的方式就是<code>IO</code>，而我们的 <code>IO</code> 支持的数据格式就是<strong>字节数组</strong>。</li><li>因为我们单方面的只把对象转成字节数组还不行，因为没有规则的字节数组我们是没办法把对象的本来面目还原回来的，所以我们必须在把对象转成字节数组的时候就制定一种规则（序列化），那么我们从 <code>IO</code> 流里面读出数据的时候再以这种规则把对象还原回来 （反序列化）。</li></ul><p>如果我们要把一栋房子从一个地方运输到另一个地方去，<strong>序列化</strong>就是我把房子拆成一个个的砖块放到车子里，然后留下一张房子原来结构的图纸，<strong>反序列化</strong>就是我们把房子运输到了目的地以后，根据图纸把一块块砖头还原成房子原来面目的过程</p><p>你可以理解为 JSON 是一种<strong>特殊的字符串</strong>。其特殊性在于，字符串中的内容为对象或数组，但JSON中的对象与 JS 的对象有些不一样。比如：JSON 字符串中的对象，他的属性名必需用双号号包裹，而 JS 对象中的属性名不用。</p></blockquote></li></ol><ul><li>以下是常见的 JSON 格式数据(<code>data.json</code>文件内容)</li></ul><pre><code>&#123;  &quot;status&quot;: 0,  &quot;data&quot;: &#123;    &quot;id&quot;: &quot;230000201401123540&quot;,    &quot;username&quot;: &quot;艾编程&quot;,    &quot;password&quot;: &quot;123456&quot;,    &quot;email&quot;: &quot;g.tkybf@lfsqxivjr.de&quot;,    &quot;phone&quot;: 123456,    &quot;role&quot;: 0,    &quot;createTime&quot;: &quot;2030-07-31 17:17:38&quot;,    &quot;updateTime&quot;: &quot;2035-06-30 16:12:53&quot;  &#125;&#125;&gt;或&#123;  &quot;code&quot;: 200,  &quot;data&quot;: [    &#123;      &quot;word&quot;: &quot;javascript&quot;    &#125;,    &#123;      &quot;word&quot;: &quot;java&quot;    &#125;,    &#123;      &quot;word&quot;: &quot;json&quot;    &#125;,    &#123;      &quot;word&quot;: &quot;python&quot;    &#125;,    &#123;      &quot;word&quot;: &quot;c/c++&quot;    &#125;,    &#123;      &quot;word&quot;: &quot;node.js&quot;    &#125;,    &#123;      &quot;word&quot;: &quot;php&quot;    &#125;  ]&#125;</code></pre><ol start="3"><li><p>为什么需要 JSON</p><blockquote><p><strong>前后端通信过程中需要交换数据</strong>，如果将前端 JS 的数据（对象、数组 等）直接传给后端，后端是无法解析的；后端直接传给前端的数据也是无法解析的，因为他们互相都不认识，因此就需要一种能够进行前后端通信的统一的数据格式作为<strong>中转</strong>。</p><p>而 JSON 有 <code>3</code> 种形式，每种形式的写法都和 JS 中的数据类型很像，可以很轻松的和 JS 中的数据类型互相转换，同时后端也认识这种 JSON 类型的数据，也有对应解析 JSON 的方式，所以在前后端通信中，用 JSON 来做为传输的数据格式是非常棒的。</p><ul><li>前端将 JS 的数据（对象，数组等）转换成 JSON 的格式发送到后端，后端拿到对应的数据后，用对应的方法来解析 JSON，然后做相关处理。<blockquote><p><code>JS（前端）-&gt; JSON -&gt; Java/Python/GO/PHP/Node.js（后端）</code></p></blockquote></li><li>后端向前端发送数据时，发送的也是 JSON 格式的数据，前端拿到对应的数据后，也有对应的方法来解析 JSON，然后做相关处理。<blockquote><p><code>Java/Python/GO/PHP/Node.js（后端）-&gt; JSON -&gt; JS（前端）</code></p></blockquote></li></ul></blockquote></li><li><p>JSON 的 3 种形式</p><blockquote><p>JSON 有 3 种形式：简单值形式、对象形式、数组形式</p><ul><li>JSON 数据文件的后缀名是：<code>.json</code></li><li>JSON 中是<strong>不能写注释</strong>的</li></ul></blockquote></li></ol><ul><li><p>JSON 简单值形式</p><blockquote><ul><li>JSON 的简单值形式就对应着 JS 中的<strong>基础数据类型</strong></li><li>数字、字符串、布尔值、null<br><strong>注意事项</strong></li><li>JSON 中没有<code>undefined</code>值，字符串类型的<code>&quot;undefined&quot;</code>是可以的</li><li>JSON 中的字符串必须使用<strong>双引号</strong>，单引号会报错<br><strong>应用实践</strong><br>新建 后缀名为<code>.json</code> 文件，文件中写入 JSON 简单值形式：数字、字符串、布尔值、null，进行体验和测试</li></ul></blockquote></li><li><p>JSON 对象形式</p><blockquote><p>JSON 的对象形式就是对应着 JS 中的对象，但与 JS 中的对象存在以下不同点</p><ul><li>JSON 中对象的<strong>属性名必须用双引号</strong>，属性值如果是<strong>字符串</strong>也必须用双引号</li><li>JSON 对象的属性值不能是<code>undefined</code>,字符串类型的<code>&quot;undefined&quot;</code>是可以的<br>新建<code>data.json</code>文件，内容如下</li></ul></blockquote></li></ul><pre><code>&#123;  &quot;username&quot;: &quot;艾编程&quot;,  &quot;sex&quot;: &quot;male&quot;,  &quot;age&quot;: 20,  &quot;hobby&quot;: [&quot;篮球&quot;, &quot;乒乓球&quot;, &quot;足球&quot;, &quot;书法&quot;],  &quot;family&quot;: &#123;    &quot;father&quot;: &quot;icoding&quot;,    &quot;mother&quot;: &quot;美美&quot;  &#125;&#125;</code></pre><blockquote><ul><li>以下 JS 变量中保存的字符串符合 JSON 格式的有</li></ul></blockquote><pre><code>let strJson1 = &#39;&#123;&quot;name&quot;:1,&quot;age&quot;:32&#125;&#39;; // 正确的JSON字符串let strJson2 = `&#123;&quot;name&quot;:1,&quot;age&quot;:32&#125;`; // 正确的JSON字符串let strJson3 = &quot;&#123;&#39;name&#39;:1,&#39;age&#39;:32&#125;&quot;; // 错误的JSON字符串let strJson4 = `&#123;&#39;name&#39;:1,&#39;age&#39;:32&#125;`; // 错误的JSON字符串</code></pre><blockquote><ul><li>注意模板字符串，可以在html文件里用，不能写在JSON文件里</li></ul></blockquote><ul><li>JSON 数组形式<blockquote><p>JSON 的数组形式就对应着 JS 中的数组，但也有如下<strong>区别</strong>：</p><ul><li>数组中的字符串必须用双引号</li><li>如果数组中的成员有<strong>对象类型</strong>，则需要满足<code>JSON</code>对象的格式要求。</li><li>不支持<code>undefined</code>类型,字符串类型的<code>&quot;undefined&quot;</code>是可以的</li></ul></blockquote></li></ul><blockquote><ul><li>新建<code>data.json</code>文件，内容如下，表示简单的 JSON 数组</li></ul></blockquote><pre><code>[1, &quot;icoding&quot;, null];</code></pre><blockquote><ul><li>新建<code>user.json</code>文件，内容如下，表示相对复杂些的 JSON 数组</li></ul></blockquote><pre><code>[  &#123;    &quot;id&quot;: 1,    &quot;username&quot;: &quot;艾编程&quot;,    &quot;phone&quot;: &quot;123456&quot;,    &quot;email&quot;: &quot;123@gmail.com&quot;,  &#125;,  &#123;    &quot;id&quot;: 2,    &quot;username&quot;: &quot;小可爱&quot;,    &quot;phone&quot;: &quot;18912368918&quot;,    &quot;email&quot;: &quot;666@gmail.com&quot;,  &#125;,  &#123;    &quot;id&quot;: 3,    &quot;username&quot;: &quot;星辰大海&quot;,    &quot;phone&quot;: &quot;18966668888&quot;,    &quot;email&quot;: &quot;888@gmail.com&quot;,  &#125;,];</code></pre><blockquote><ul><li>以下 JS 变量中保存的字符串符合 JSON 格式的有</li></ul></blockquote><pre><code>let arrStr1 = &quot;[1,2,3,4]&quot;; // 正确let arrStr2 = &#39;[&#123;&quot;name&quot;:&quot;清心&quot;&#125;,3,4,5]&#39;; // 正确let arrStr3 = &#39;  [9.1,&quot;A&quot;,[1,3],undefined]&#39;; // 错误let arrStr4 = &quot;[&#123;&#39;name&#39;:清心&#39;&#125;,3,4,5]&quot;; // 错误</code></pre><ul><li>总结：<code>JSON</code>数据的注意事项<blockquote><p><code>JSON</code>数据一般是保存在<code>.json</code>的文件中，当然其写法一定要是合法的JSON字符串，否则解析会报错。<strong>合法即以下规则</strong>：</p><ul><li><code>JSON</code>中没有<code>undefined</code>值,字符串类型的<code>&quot;undefined&quot;</code>是可以的</li><li><code>JSON</code>中的字符串必须使用双引号</li><li><code>JSON</code>中对象的属性名必须用双引号，属性值如果是字符串也必须用双引号</li><li><code>JSON</code>中是不能注释的</li></ul></blockquote></li></ul><ol start="5"><li>JSON 的常用方法<blockquote><p>JSON 对象包含以下两个方法</p><table><thead><tr><th>方法</th><th>说明</th></tr></thead><tbody><tr><td><code>JSON.stringify()</code></td><td>可以将 JS 的基本数据类型、对象或者数组转换成<code>JSON</code>格式的字符串</td></tr><tr><td><code>JSON.parse()</code></td><td>可以将<code>JSON</code>格式的字符串解析成 JS 中的对应值</td></tr></tbody></table></blockquote></li></ol><blockquote><p><strong>注：</strong><br>除了上面两个方法，<code>JSON</code>这个对象本身并没有其他作用，也不能被调用或者作为构造函数调用。</p></blockquote><ul><li>对象与 JSON 字符串之间相互转换</li></ul><pre><code>const obj = &#123;  username: &quot;清心&quot;,  age: 33,&#125;;// 将对象转换为字符串 （对象序列化）const strJson = JSON.stringify(obj);console.log(strJson);//&#123;&quot;username&quot;:&quot;清心&quot;,&quot;age&quot;:33&#125;console.log(typeof strJson);//string&gt;// 将JSON字符串转换为对象，字符串解析const obj2 = JSON.parse(strJson);console.log(obj2);//&#123;username: &#39;清心&#39;, age: 33&#125;console.log(typeof obj2);//object</code></pre><ul><li>数组与 JSON 字符串之间相互转换</li></ul><pre><code>let arrStr = &#39;[&#123;&quot;name&quot;:&quot;清心&quot;&#125;,3,4,5]&#39;; // 正确const arr = JSON.parse(arrStr);console.log(arr);// 将数组转成JSON字符串const jsonStr = JSON.stringify(arr);console.log(jsonStr);</code></pre><h3 id="二、原生-Ajax"><a href="#二、原生-Ajax" class="headerlink" title="二、原生 Ajax"></a>二、原生 Ajax</h3><h4 id="Ajax-是什么"><a href="#Ajax-是什么" class="headerlink" title="Ajax 是什么"></a>Ajax 是什么</h4><blockquote><p>Ajax 是 <code>Asynchronous Javascript And XML</code>（异步 JavaScript 和 XML）的简写</p><ul><li>Ajax 中的异步：可以异步地向服务器发送请求，在等待响应的过程中，不会阻塞当前页面，浏览器可以做自己的事情。直到成功获取响应后，浏览器才开始处理响应数据。</li><li>XML（可扩展标记语言）是前后端数据通信时传输数据的一种格式（早年用的多，现在都用<code>JSON</code>了）</li><li>查看博客网站地图的 xml 文件，可了解语法结构 <code>https://www.arryblog.com/sitemap.xml</code></li><li>XML 现在已经很少使用了，当下比较常用的是<code>JSON</code><blockquote><p><code>Ajax</code> 其实就是浏览器与服务器之间的一种异步通信方式。</p></blockquote></li></ul></blockquote><h4 id="Ajax主要作用"><a href="#Ajax主要作用" class="headerlink" title="Ajax主要作用"></a><code>Ajax</code>主要作用</h4><blockquote><p><code>Ajax</code>最吸引人的就是它的“异步”特性，也就是说它可以在<strong>不重新刷新页面的情况下</strong>与服务器通信，交换数据，或更新页面。</p><ul><li>你可以使用<code>Ajax</code>最主要的两个特性做下列事：<ul><li>在不重新加载页面的情况下发送请求给服务器。</li><li>接受并使用从服务器发来的数据。</li></ul></li></ul></blockquote><p><strong>应用场景如下</strong></p><blockquote><p>以下只是列举出一些简单的常见应用，让大家对<code>Ajax</code>有个初步的了解，<code>Ajax</code>能做的事情非常多，后面我们在项目中主要就是使手<code>Ajax</code>来实现前后端通信。</p></blockquote><ul><li>注册用户名或手机号检测，一般都会使用<code>Ajax</code>异步交互<blockquote><ul><li>用户名检测时会提示 “名称已被占用”</li><li>本质的过程是使用 Ajax 向后端发送请求，将用户名一起发送到后端，后端获取到数据后会和数据库中的数据进行比对，查看是否存在该用户名，如果存在就会响应给前端已存在，前端就会给出对应的用户提示信息。如果响应给前端为不存在，就继续注册就好。</li></ul></blockquote></li><li>搜索提示，自动补全<blockquote><ul><li>同样使用了 Ajax 向后端发送请求，后端会进行一些列的操作，最终将响应回来的数据给到前端，最后展示出来</li></ul></blockquote></li></ul><h4 id="搭建-Ajax-开发环境"><a href="#搭建-Ajax-开发环境" class="headerlink" title="搭建 Ajax 开发环境"></a>搭建 Ajax 开发环境</h4><blockquote><p><code>Ajax</code> 需要服务器环境</p><ul><li>在非服务器环境下（如本地文件直接打开的形式），浏览器无法正常使用 <code>Ajax</code></li><li>搭建服务访问就意味着浏览器地址栏访问一定是以 <code>http</code> 或 <code>https</code> 开头的，才可以正常使用 <code>Ajax</code></li></ul></blockquote><ul><li>使用 VSCode 搭建 Ajax 开发环境<blockquote><p>使用 VSCode 开发，建议使用<code>Live Server</code>插件，它会给我们提供一个本地的服务器环境。使用注意事项如下：</p><ul><li>需在当前文件的目录中打开 VSCode ，<code>Live Server</code>插件才能生效。</li><li>在 VSCode 中，打开需要运行的文件，右键选择 <code>&quot;Open with Live Server&quot;</code> 即可启动本地服务器来运行对应的文件</li><li>也可以使用快捷键 <code>Ctrl + shift + p</code> 在弹窗的命令行窗口中输入<code>Live Server</code>会自动补全 选择 <code>Open with Live Server</code> 即可，下次再打开其他文件时，会默认出现在第一个。直接使用快捷键 <code>Ctrl + shift + p</code> 再回车 即可运行。</li></ul></blockquote></li></ul><blockquote><p>当然，VSCode 中的 Live Server 也不是强制一定要用这个</p><ul><li>Windows 可用 phpStudy</li><li>Mac 可用 MAMP</li><li>Windows 和 Mac 上也可直接用 Nginx<br>为了开发方便，我们选择使用 Live Server 足以，其他知道即可。</li></ul></blockquote><h4 id="Ajax-的基本用法"><a href="#Ajax-的基本用法" class="headerlink" title="Ajax 的基本用法"></a>Ajax 的基本用法</h4><ul><li><p><code>XMLHttpRequest</code></p><blockquote><p>我们要使用<code>Ajax</code>，<strong>但</strong>浏览器是没有直接提供类似 Ajax 这样对象的。因此</p><ul><li><code>Ajax</code>想要实现浏览器与服务器之间的异步通信，就需要依靠 <code>XMLHttpRequest</code>，它是一个<strong>构造函数</strong>。</li><li>因为早期前后端通信的数据格式是 XML，所以<code>XMLHttpRequest</code>构造函数的命名中带有 <code>XML</code>，<strong>但本质上</strong><code>XMLHttpRequest</code>在实现前后端通信时，并没有和具体的某种数据格式绑定。</li><li>不过我们现在前后端通信，主要使用的还是 JSON 格式的数据</li></ul></blockquote></li><li><p>Ajax 的使用步骤</p></li></ul><ol><li>第一步：创建 xhr 对象</li></ol><pre><code>const xhr = new XMLHttpRequest();</code></pre><ol start="2"><li>第二步：调用用<code>open()</code>方法，准备发送</li></ol><pre><code>xhr.open(method, url, boolean);//例：xhr.open(  &quot;get&quot;,  &quot;https://www.fastmock.site/mock/6ec78e345df340241e1f5043f0167833/icode/test&quot;);</code></pre><blockquote><ul><li>调用 open方法并不是真正的发送请求，只是做好发送请求的准备工作<br>pen方法的<strong>三个参数</strong></li><li>method：表示HTTP请求的方法，如：<code>GET、POST、PUT、DELETE</code></li><li>url: 请求的url地址（本地或远程服务器都可以）</li><li>boolean: 是一个可选的布尔值，表示是否异步执行操作，默认为true。true表示是异步，false表示同步，但从来不会使用ajax来同步加载</li></ul></blockquote><ol start="3"><li>第三步：调用<code>send()</code>方法，正式发送请求</li></ol><pre><code>xhr.send(body);</code></pre><blockquote><ul><li><code>body</code>:是一个可选参数，用于你想发送给服务器的任何内容，主要用于发送<code>POST</code>请求时，发送<strong>请求体</strong>数据。如果采用的是GET请求，其参数写和不写一样，因为写了也不会被处理</li></ul></blockquote><blockquote><ul><li>目前常用的几种发送数据形式有以下三种</li></ul></blockquote><pre><code>xhr.send(&#39;123&#39;) //  字符串xhr.send(&quot;username=icoding&amp;key=1242&quot;);  // 参数字符串xhr.send(&#39;&#123;&quot;username&quot;:&quot;icoding&quot;,&quot;key&quot;:1254&#125;&#39;); // JSON格式xhr.send(new FormData()); // 发送表单数据</code></pre><blockquote><blockquote><p><code>send()</code>方法中发送数据的格式前后端要协商好，这样后端在接受到参数时就知道以什么格式来解析。</p></blockquote></blockquote><ol start="4"><li>第四步：通过监听<code>readystatechange()</code>事件，来处理服务器响应</li></ol><pre><code>xhr.onreadystatechange = function () &#123;  // ...&#125;;//也可以采用 addEventListener 方式来监听事件xhr.addEventListener(&quot;readystatechange&quot;, () =&gt; &#123;&#125;, false);</code></pre><blockquote><p>当获取到响应后，会触发 xhr 对象的<code>readystatechange</code>事件，可以在该事件中对响应进行处理</p><ul><li><code>onreadystatechange()</code>见名知意，即：<strong>状态改变时</strong>触发事件,所以我们需要判断当前Ajax的状态。</li></ul></blockquote><blockquote><ul><li><code>xhr.readyState</code>属性记录了整个通信过程中的状态，它的值从 0 ~ 4，一共 5 个状态<table><thead><tr><th>值</th><th>状态</th><th>描述</th></tr></thead><tbody><tr><td>0</td><td>UNSENT</td><td>代理被创建，但尚未调用<code>open()</code>方法。</td></tr><tr><td>1</td><td>OPENED</td><td><code>open()</code>方法已经被调用。</td></tr><tr><td>2</td><td>HEADERS_RECEIVED</td><td><code>send()</code>方法已经被调用，并且头部和状态已经可获得。</td></tr><tr><td>3</td><td>LOADING</td><td>下载中，<code>responseText</code>属性已经包含部分数据。</td></tr><tr><td>4</td><td>DONE</td><td>下载操作已完成。</td></tr><tr><td>每次状态发生改变，都会触发<code>readystatechange</code>事件</td><td></td><td></td></tr></tbody></table></li></ul></blockquote><pre><code>xhr.onreadystatechange = function () &#123;  // readyState 不等于 4，未完成，数据还没有准备好，就没必要继续执行，直接返回null就好  if (xhr.readyState !== 4) return;  // readyState 等于 4，表示完成，并已经接收到全部响应数据  if((xhr.status &gt;= 200 &amp;&amp; xhr.status &lt; 300) || xhr.status === 304 ) &#123;      // 请求被发送后，从服务器端返回文本。      console.log(xhr.responseText);      // 查看返回值的类型      console.log(typeof xhr.responseText);  &#125;&#125;</code></pre><ul><li>使用 Ajax 完成前后端通信<blockquote><p>通过以上四个步骤完成 Ajax 前后端通信，不过我们一般会把<code>xhr.onreadystatechange</code>事件写<code>在xhr.open()</code>和<code>xhr.send()</code>代码<strong>前面</strong>，保证请求发出去后的状态一定能被事件监听到。</p><ul><li>完整代码</li></ul></blockquote></li></ul><pre><code>// 第一步：创建xhr对象const xhr = new XMLHttpRequest();// 第四步：通过监听`readystatechange()`事件，来处理服务器响应xhr.onreadystatechange = function () &#123;  // readyState 不等于 4，未完成，数据还没有准备好，就没必要继续执行，直接返回null就好  if (xhr.readyState !== 4) return;  // readyState 等于 4，表示完成，并已经接收到全部响应数据  if ((xhr.status &gt;= 200 &amp;&amp; xhr.status &lt; 300) || xhr.status === 304) &#123;    // 请求被发送后，从服务器端返回文本。    console.log(xhr.responseText);    // 查看返回值的类型    console.log(typeof xhr.responseText);  &#125;&#125;;// 第二步：调用用open()方法，准备发送xhr.open(  &quot;get&quot;,  &quot;https://www.fastmock.site/mock/6ec78e345df340241e1f5043f0167833/icode/test&quot;,  true);// 第三步：调用send()方法，正式发送请求xhr.send();</code></pre><h4 id="Ajax-发送-GET-请求"><a href="#Ajax-发送-GET-请求" class="headerlink" title="Ajax 发送 GET 请求"></a>Ajax 发送 GET 请求</h4><blockquote><p>前面了解了 Ajax 是如何发送请求的，接下来深入了解 发送 GET 请求时，如何携带数据 和 数据编码</p><ul><li>GET 请求不能通过请求体携带数据，但可以通过<strong>请求头</strong>携带</li><li>URL 地址中<strong>问号后边</strong>即为携带的数据，<code>&amp;</code>符号来分隔多个名值对</li></ul></blockquote><pre><code>const url = &quot;http://www.xxx.com/test?keyword=json&amp;type=1&amp;sort=1&quot;;// url地址？号的字符串就是GET请求体携带的数据 keyword=json&amp;type=1&amp;sort=1</code></pre><p><strong>代码演示</strong></p><blockquote><ul><li>根据参数 num 来决定返回几条用户信息</li><li>使用<code>fast mock</code>来模拟接口：<code>https://www.fastmock.site/#/</code></li></ul></blockquote><ol><li>接口设置<blockquote><ul><li>接口地址的结尾是：项目接口基础路径+接口地址url</li></ul></blockquote></li></ol><pre><code>const url = &quot;https://www.fastmock.site/mock/b7eabdc70b21d19726d2d7ee7f372da9/item/user&quot;;</code></pre><img src="fastmock-项目基础路径.png"><img src="Ajax发送GET请求.png"><blockquote><p>右边是服务端返回的<code>JSON</code>数据</p><ul><li><code>data</code>里面的函数接收两个参数，<code>_req和Mock</code> 注意：这两个变量名不能改动</li><li><code>fastmock</code>用<code>query</code>查询参数，如<code>/user?id=1</code> 获取方式为<code>_req.query.id</code></li></ul></blockquote><blockquote><ul><li>预览：<img src="预览get请求.png"></li></ul></blockquote><ol start="2"><li>发送请求<blockquote><ul><li><code>get</code>通过请求头携带数据，URL地址中<strong>问号后边</strong>即为携带的数据；所以我们把<code>num</code>写在地址后面，让请求头传到服务端，服务端根据不同的<code>num</code>，返回对应的数据</li></ul></blockquote></li></ol><pre><code>const url =  &quot;https://www.fastmock.site/mock/b7eabdc70b21d19726d2d7ee7f372da9/item/user?num=3&quot;;//第一步 创建xhr对象const xhr = new XMLHttpRequest();//第四步 通过监听事件，来处理服务器响应xhr.onreadystatechange = function () &#123;  if (xhr.readyState !== 4) return;  if (xhr.status === 200) &#123;    console.log(xhr.responseText);    console.log(typeof xhr.responseText);  &#125;&#125;;//第二步 调用open方法，准备发送xhr.open(&quot;get&quot;, url);//第三步 调用send方法，正式发送请求xhr.send();</code></pre><img src="console-get.png"><img src="network-get.png">>- 注：要在浏览器中看到 Ajax 的请求，一定要选中上面的Fetch/XHR 选项<h4 id="Ajax-发送-POST-请求"><a href="#Ajax-发送-POST-请求" class="headerlink" title="Ajax 发送 POST 请求"></a>Ajax 发送 POST 请求</h4><blockquote><ul><li>POST 请求主要通过<strong>请求体</strong>携带数据，同量也可以在请求头携带（不过实际开发不这样用）</li><li>请求体数据作为<code>send()</code>方法的参数（一般是字符串），被传送到服务器端。</li></ul><p>Ajax 发送 POST 请求，请求体携带的数据格式通常为以下两种，但不管那一种，都需要和后端沟通好，这样后端就能以对应的格式来解析数据</p><table><thead><tr><th>数据类型</th><th>格式</th><th>fastmock 接受数据形式</th></tr></thead><tbody><tr><td>application&#x2F;x-www-form-urlencoded</td><td>“username&#x3D;admin&amp;password&#x3D;123456”</td><td>_req.body.username</td></tr><tr><td>JSON</td><td>JSON.stringify({username:”admin”,password:”123456”})</td><td>_req.body.username</td></tr></tbody></table></blockquote><blockquote><ul><li>和<code>get</code>方法不同的是：<code>post</code>方法用请求体携带数据，因此：<ul><li>要在请求头中，设置数据格式</li><li>用<code>send()</code>方法，发送请求体数据</li></ul></li></ul></blockquote><ol><li><p>接口设置</p><blockquote><ul><li>新增接口：<img src="Ajax发送post请求.png">右边是服务端返回的`JSON`数据</li><li><code>data</code>里面的函数接收两个参数，<code>_req和Mock</code> 注意：这两个变量名不能改动</li><li><code>fastmock</code>获取body请求体数据：<code>_req.body.id</code></li><li>接口地址：直接复制，不用添加内容<br>预览：<img src="预览post请求.png"></li></ul></blockquote></li><li><p>发送<code>application/x-www-form-urlencoded</code>格式的请求</p></li></ol><pre><code>const url =   &quot;https://www.fastmock.site/mock/b7eabdc70b21d19726d2d7ee7f372da9/item/login&quot;; //第一步 创建xhr对象 const xhr = new XMLHttpRequest(); //第四步 通过监听事件，来处理服务器响应 xhr.onreadystatechange = function () &#123;   if (xhr.readyState !== 4) return;   if (xhr.status === 200) &#123;     console.log(xhr.responseText);     console.log(typeof xhr.responseText);   &#125; &#125;; //第二步 调用open方法，准备发送 xhr.open(&quot;post&quot;, url); //设置请求头，发送内容类型为application/x-www-form-urlencoded 格式 xhr.setRequestHeader(&quot;Content-Type&quot;, &quot;application/x-www-form-urlencoded&quot;); //第三步 调用send方法，正式发送请求 xhr.send(&quot;username=hermia&amp;password=12345&quot;);</code></pre><img src="console-post.png"><img src="network-post.png"><ol start="3"><li>JSON 格式</li></ol><pre><code>const url =   &quot;https://www.fastmock.site/mock/b7eabdc70b21d19726d2d7ee7f372da9/item/login&quot;; //第一步 创建xhr对象 const xhr = new XMLHttpRequest(); //第四步 通过监听事件，来处理服务器响应 xhr.onreadystatechange = function () &#123;   if (xhr.readyState !== 4) return;   if (xhr.status === 200) &#123;     console.log(xhr.responseText);     console.log(typeof xhr.responseText);   &#125; &#125;; //第二步 调用open方法，准备发送 xhr.open(&quot;post&quot;, url); //设置请求头，发送内容类型为application/x-www-form-urlencoded 格式 xhr.setRequestHeader(&quot;Content-Type&quot;, &quot;application/json&quot;); //第三步 调用send方法，正式发送请求 xhr.send(   JSON.stringify(&#123;     username: &quot;hermia&quot;,     password: &quot;12345&quot;,   &#125;) );</code></pre><blockquote><ul><li>结果和上面一样</li></ul></blockquote><h4 id="请求数据编码"><a href="#请求数据编码" class="headerlink" title="请求数据编码"></a>请求数据编码</h4><blockquote><p>不管是GET还是POST请求，如果请求携带的数据是<strong>非英文字母</strong>的，如：中文汉字，就需要<strong>编码</strong>之后再发送给后端，不然会造成乱码问题<br>可以使用<code>encodeURIComponent()</code>方法进行编码</p></blockquote><pre><code>// GET请求地址中有中文需要编码const url = `https://www.xxx.com/test?wd=$&#123;encodeURIComponent(&quot;web前端&quot;)&#125;`;// POST请求体数据中有中文需要编码xhr.send(`username=$&#123;encodeURIComponent(&quot;艾编程&quot;)&#125;&amp;age=20`);</code></pre><ul><li>代码演示</li></ul><pre><code>const url =   &quot;https://www.fastmock.site/mock/b7eabdc70b21d19726d2d7ee7f372da9/item/login&quot;; //第一步 创建xhr对象 const xhr = new XMLHttpRequest(); //第四步 通过监听事件，来处理服务器响应 xhr.onreadystatechange = function () &#123;   if (xhr.readyState !== 4) return;   if (xhr.status === 200) &#123;     console.log(xhr.responseText);     console.log(typeof xhr.responseText);   &#125; &#125;; //第二步 调用open方法，准备发送 xhr.open(&quot;post&quot;, url); //设置请求头，发送内容类型为application/x-www-form-urlencoded 格式 xhr.setRequestHeader(&quot;Content-Type&quot;, &quot;application/x-www-form-urlencoded&quot;); //第三步 调用send方法，正式发送请求 xhr.send(`username=$&#123;encodeURIComponent(&quot;艾编程&quot;)&#125;&amp;password=12345`);</code></pre><blockquote><ul><li>查看编码后传递到服务器端的中文字符串：<img src="请求数据编码.png"></li></ul></blockquote><h4 id="form表单get请求携带数据"><a href="#form表单get请求携带数据" class="headerlink" title="form表单get请求携带数据"></a>form表单get请求携带数据</h4><blockquote><ul><li>不需要设置<code>enctype</code>属性的值</li></ul></blockquote><pre><code>&gt;&lt;form&gt;  action=&quot;https://www.fastmock.site/mock/b7eabdc70b21d19726d2d7ee7f372da9/item/login&quot;&gt;  method=&quot;get&quot;&gt;&gt;&gt;  &lt;input type=&quot;text&quot; name=&quot;username&quot; id=&quot;&quot; /&gt;&gt;  &lt;input type=&quot;password&quot; name=&quot;password&quot; /&gt;&gt;  &lt;input type=&quot;submit&quot; value=&quot;提交&quot; /&gt;&gt;&lt;/form&gt;</code></pre><blockquote><ul><li>我们可以看到，表单请求（提交）的地址，并没有参数</li><li>输入用户名、密码，提交之后，表单的值就会组成键值对的形式，作为参数拼接到url路径上，这个参数就是get请求所携带的数据体<img src="form表单发送get请求.png"></li></ul></blockquote><h4 id="form-表单-post-请求携带数据"><a href="#form-表单-post-请求携带数据" class="headerlink" title="form 表单 post 请求携带数据"></a>form 表单 post 请求携带数据</h4><blockquote><p><code>form</code> 表单在发送<code>post</code>请求时，请求体数据类型有如下三种，通过<code>enctype</code>属性设置。</p><table><thead><tr><th>enctype</th><th>属性</th><th>说明</th></tr></thead><tbody><tr><td>application&#x2F;x-www-form-urlencoded</td><td>默认值，只能上传文本格式的文件。不能用于发送文件。在发送前<strong>会编码所有字符</strong>，即在发送到服务器之前，所有字符都会进行编码</td><td></td></tr><tr><td>multipart&#x2F;form-data</td><td>指定传输数据为<strong>二进制类型</strong>（不对字符编码），比如图片，mp3，文件。是将文件以二进制的形式上传，可以实现多种类型的文件上传</td><td></td></tr><tr><td>text&#x2F;plain</td><td>纯文本的传输，空格转换为”+”号，但不对特殊字符编码，一般用于 email 之类的</td><td></td></tr></tbody></table></blockquote><blockquote><p><strong>温馨提示</strong></p><ul><li>form 表单只有在发送 post 请求时，需要设置 enctype 属性的值，如果不设置默认为<code>application/x-www-form-urlencoded</code></li></ul><p><strong>表单参数</strong></p><ul><li>action: 设置表单请求（提交）的地址</li><li>method: 设置请求的方法</li><li>enctype: 设置以post方法请求时，请求体携带的数据类型。</li></ul></blockquote><ul><li>当<code>enctype=&quot;application/x-www-form-urlencoded&quot;</code></li></ul><pre><code>&gt;&lt;form&gt;  action=&quot;https://www.fastmock.site/mock/6ec78e345df340241e1f5043f0167833/icode/login&quot;&gt;  method=&quot;post&quot;&gt;  enctype=&quot;application/x-www-form-urlencoded&quot;&gt;&gt;  &lt;input type=&quot;text&quot; name=&quot;username&quot; id=&quot;&quot; /&gt;&gt;  &lt;input type=&quot;password&quot; name=&quot;password&quot; id=&quot;&quot; /&gt;&gt;  &lt;input type=&quot;submit&quot; value=&quot;提交&quot; /&gt;&gt;&lt;/form&gt;</code></pre><blockquote><ul><li>在<code>Network</code>里查看提交的数据格式：<img src="表单发送post请求-1.png"></li><li>是自动将表单<code>name</code>属性值和输入的内容进行拼接，作为请求体中的内容发送</li></ul></blockquote><ul><li>当 <code>enctype=&quot;text/plain&quot;</code></li></ul><pre><code>&gt;&lt;form&gt;  action=&quot;https://www.fastmock.site/mock/6ec78e345df340241e1f5043f0167833/icode/login&quot;&gt;  method=&quot;post&quot;&gt;  enctype=&quot;text/plain&quot;&gt;&gt;  &lt;input type=&quot;text&quot; name=&quot;username&quot; id=&quot;&quot; /&gt;&gt;  &lt;input type=&quot;password&quot; name=&quot;password&quot; id=&quot;&quot; /&gt;&gt;  &lt;input type=&quot;submit&quot; value=&quot;提交&quot; /&gt;&gt;&lt;/form&gt;</code></pre><blockquote><ul><li>在<code>Network</code>里查看提交的数据格式：<img src="表单发送post请求-2.png"></li></ul></blockquote><ul><li>当<code>enctype=&quot;multipart/form-data&quot;</code></li></ul><pre><code>&gt;&lt;form&gt;  action=&quot;https://www.fastmock.site/mock/6ec78e345df340241e1f5043f0167833/icode/login&quot;&gt;  method=&quot;post&quot;&gt;  enctype=&quot;multipart/form-data&quot;&gt;&gt;  &lt;input type=&quot;text&quot; name=&quot;username&quot; id=&quot;&quot; /&gt;&gt;  &lt;input type=&quot;password&quot; name=&quot;password&quot; id=&quot;&quot; /&gt;&gt;  &lt;input type=&quot;submit&quot; value=&quot;提交&quot; /&gt;&gt;&lt;/form&gt;</code></pre><blockquote><ul><li>在<code>Network</code>里查看提交的数据格式：<img src="表单发送post请求-3.png"></li></ul></blockquote><h4 id="利用Ajax来提交enctype-multipart-form-data-类型的表单数据。"><a href="#利用Ajax来提交enctype-multipart-form-data-类型的表单数据。" class="headerlink" title="利用Ajax来提交enctype = &quot;multipart/form-data&quot;类型的表单数据。"></a>利用<code>Ajax</code>来提交<code>enctype = &quot;multipart/form-data&quot;</code>类型的表单数据。</h4><blockquote><p>根据前面的演示，可以发现：</p><ul><li>通过提交按扭提交表单数据时，<strong>会发生页面的跳转</strong>，如果不想发生页面跳转就需要通过<code>Ajax</code>来发送请求。</li></ul></blockquote><blockquote><p>思路：</p><ul><li>阻止默认行为，即点击提交按钮时的默认跳转行为</li><li>用点击事件来发送<code>Ajax</code>请求</li></ul></blockquote><pre><code>&gt;&lt;form method=&quot;post&quot; id=&quot;login&quot;&gt;&gt;  &lt;input type=&quot;text&quot; name=&quot;username&quot; id=&quot;&quot; /&gt;&gt;  &lt;!-- 密码框不能自填充 --&gt;&gt;  &lt;input type=&quot;password&quot; name=&quot;password&quot; autocomplete=&quot;off&quot; /&gt;&gt;  &lt;input type=&quot;submit&quot; value=&quot;提交&quot; id=&quot;submit&quot; /&gt;&gt;&lt;/form&gt;&gt;&lt;script&gt;  const login = document.getElementById(&quot;login&quot;);  const &#123; username, password &#125; = login;  //获取提交按钮  const submit = document.getElementById(&quot;submit&quot;);  //添加点击事件  submit.addEventListener(&quot;click&quot;, (e) =&gt; &#123;    e.preventDefault(); //阻止默认行为    //获取表单输入框中的数据    const _username = username.value.trim();    const _password = password.value.trim();    //输入的数据验证    //发送Ajax请求    const url =      &quot;https://www.fastmock.site/mock/b7eabdc70b21d19726d2d7ee7f372da9/item/login&quot;;    //第一步 创建xhr对象    const xhr = new XMLHttpRequest();    //第四步 通过监听事件，来处理服务器响应    xhr.onreadystatechange = function () &#123;      if (xhr.readyState !== 4) return;      if (xhr.status === 200) &#123;        console.log(xhr.responseText);      &#125;    &#125;;    //第二步 调用open方法，准备发送    xhr.open(&quot;post&quot;, url);    //设置请求头，发送内容类型为application/x-www-form-urlencoded 格式    xhr.setRequestHeader(      &quot;Content-Type&quot;,      &quot;application/x-www-form-urlencoded&quot;    );    //第三步 调用send方法，正式发送请求    //拼接date数据    const date = `username=$&#123;_username&#125;&amp;password=$&#123;_password&#125;`;    xhr.send(date);  &#125;);&gt;&lt;/script&gt;</code></pre><blockquote><blockquote><p>注意：</p></blockquote><ul><li>密码框不能自填充：需要设置<code>autocomplete=&quot;off&quot;</code></li><li>可以通过结构赋值的方式拿到输入框：<code>&#123;username, password &#125; = login</code>，然后用<code>.value</code>方法拿到输入的数据</li></ul></blockquote><img src="Ajax发送表单数据.png">>- 可以看到，通过`Ajax`方法发送post请求，在不跳转页面的情况下，也可以提交`enctype = "multipart/form-data"`类型的表单数据。>- 设置请求头时，发送内容类型为`application/x-www-form-urlencoded`格式；所以提交的数据格式和`form`表单数据格式为` enctype="application/x-www-form-urlencoded"`时，提交的数据格式是相同的，都使用参数字符串格式>- 弊端：通过请求体携带的数据是我们人为 拼接输入框中的数据，当提交的信息比较多时，就比较麻烦了<h4 id="FormData-对象"><a href="#FormData-对象" class="headerlink" title="FormData 对象"></a>FormData 对象</h4><ol><li>利用<code>FormData</code>来提交表单数据<blockquote><p>从前面的学习中，可以知道：通过<code>Ajax</code>来提交 Form 表单时，如果提交的数据类型为<code>application/x-www-form-urlencoded</code>，需要人为拼接数据</p><ul><li><code>FormData</code>构造函数可以弥补这个问题</li><li>如果提交的数据类型为<code>multipart/form-data</code>类型，可以利用到 <code>FormData</code> 构造函数来创建对应类型的数据。</li><li><code>FormData</code>对象会自动将表单的所有数据编译成键值对，以便用<code>XMLHttpRequest</code>来发送数据</li></ul></blockquote></li></ol><blockquote><ul><li>把表单元素作为构造函数的参数，更改数据类型</li><li>还可以自己添加内容</li></ul></blockquote><pre><code>&gt;&lt;form method=&quot;post&quot; id=&quot;login&quot;&gt;&gt;  &lt;input type=&quot;text&quot; name=&quot;username&quot; id=&quot;&quot; /&gt;&gt;  &lt;!-- 密码框不能自填充 --&gt;&gt;  &lt;input type=&quot;password&quot; name=&quot;password&quot; autocomplete=&quot;off&quot; /&gt;&gt;  &lt;input type=&quot;submit&quot; value=&quot;提交&quot; id=&quot;submit&quot; /&gt;&gt;&lt;/form&gt;&gt;&lt;script&gt;  const login = document.getElementById(&quot;login&quot;);  const &#123; username, password &#125; = login;  //获取提交按钮  const submit = document.getElementById(&quot;submit&quot;);  //添加点击事件  submit.addEventListener(&quot;click&quot;, (e) =&gt; &#123;    e.preventDefault(); //阻止默认行为    //输入的数据验证    //发送Ajax请求    const url =      &quot;https://www.fastmock.site/mock/b7eabdc70b21d19726d2d7ee7f372da9/item/login&quot;;    //第一步 创建xhr对象    const xhr = new XMLHttpRequest();    //第四步 通过监听事件，来处理服务器响应    xhr.onreadystatechange = function () &#123;      if (xhr.readyState !== 4) return;      if ((xhr.status &gt;= 200 &amp;&amp; xhr.status &lt; 300) || xhr.status === 304) &#123;        console.log(xhr.responseText);      &#125;    &#125;;    //第二步 调用open方法，准备发送    xhr.open(&quot;post&quot;, url);    //设置请求头，发送内容类型为multipart/form-data格式    xhr.setRequestHeader(&quot;Content-Type&quot;, &quot;multipart/form-data&quot;);    //第三步 调用send方法，正式发送请求    //拼接date数据    const date = new FormData(login);    //而且可以添加表单中没有的内容    date.append(&quot;age&quot;, 20);    xhr.send(date);  &#125;);&gt;&lt;/script&gt;</code></pre><img src="formData发送表单数据.png">>>注意：`fastMock`不能解析`FormData`数据，所以，得不到成功的结果<ol start="2"><li>FormData 的基本用法<blockquote><p>接下来我们来学习以下几个 FormData 的实例方法</p><ul><li><code>new FormData()</code>得到的实例是<strong>可迭代对象</strong><table><thead><tr><th>实例方法</th><th>说明</th></tr></thead><tbody><tr><td>append(key,value)</td><td>添加一个新的值到 FormData 对象内的一个已存在的键中，如果键不存在则会添加该键</td></tr><tr><td>set</td><td>对 FormData 对象里的某个 key 设置一个新的值，如果该 key 不存在，则添加。</td></tr><tr><td>get</td><td>get() 方法用于返回 FormData 对象中和指定的键关联的第一个值</td></tr><tr><td>getAll</td><td>方法会返回该 FormData 对象指定 key 的所有值</td></tr><tr><td>delete(key)</td><td>根据 key 从 FormData 对象中删除指定键</td></tr></tbody></table></li></ul></blockquote></li></ol><blockquote><ul><li>关于 FormData 构造函数相关的实例方法查看官方文档</li></ul></blockquote><ul><li><code>append(key,value)</code>和<code>get(key)</code>和<code>getAll(key)</code></li></ul><pre><code>const data = new FormData(); data.append(&quot;a&quot;, 1); data.append(&quot;a&quot;, 2); data.append(&quot;a&quot;, 1); data.append(&quot;a&quot;, 2); for (let item of data) &#123;   console.log(item); &#125; //[&#39;a&#39;, &#39;1&#39;] //[&#39;a&#39;, &#39;2&#39;] //[&#39;a&#39;, &#39;1&#39;] //[&#39;a&#39;, &#39;2&#39;]&gt; console.log(data.get(&quot;a&quot;)); //1 console.log(data.getAll(&quot;a&quot;)); //[&#39;1&#39;, &#39;2&#39;, &#39;1&#39;, &#39;2&#39;]</code></pre><blockquote><ul><li><code>append</code>方法可以添加相同的值</li><li><code>get</code>方法只能得到指定的键关联的第一个值</li><li><code>getAll</code>会返回由指定key的所有值组成的数组</li></ul></blockquote><ul><li><code>set(key,value)</code></li></ul><pre><code>const data = new FormData();data.set(&quot;a&quot;, 1);data.set(&quot;a&quot;, 2);data.set(&quot;a&quot;, 3);data.set(&quot;b&quot;, 1);for (let item of data) &#123;  console.log(item);&#125;//[&#39;a&#39;, &#39;3&#39;]//[&#39;b&#39;, &#39;1&#39;]&gt;console.log(data.get(&quot;a&quot;)); //3console.log(data.getAll(&quot;a&quot;)); //[&#39;3&#39;]</code></pre><blockquote><ul><li><code>set</code>方法添加的键值不能相同，如果键名一样后添加的会替代前面的</li><li>所以<code>get</code>方法和<code>getAll</code>方法得到的值都是最后添加进去的<code>value</code>值</li></ul></blockquote><ul><li><code>delete</code></li></ul><pre><code> const data = new FormData(); data.set(&quot;a&quot;, 1); data.append(&quot;a&quot;, 2); data.append(&quot;b&quot;, 3);&gt; for (let item of data) &#123;   console.log(item, &quot;--&quot;); &#125; // [&#39;a&#39;, &#39;1&#39;] &#39;--&#39; // [&#39;a&#39;, &#39;2&#39;] &#39;--&#39; // [&#39;b&#39;, &#39;3&#39;] &#39;--&#39; data.delete(&quot;a&quot;); for (let item of data) &#123;   console.log(item, &quot;--&quot;); &#125; // [&#39;b&#39;, &#39;3&#39;] &#39;--&#39;</code></pre><h3 id="三、跨域"><a href="#三、跨域" class="headerlink" title="三、跨域"></a>三、跨域</h3><h4 id="什么是跨域-？"><a href="#什么是跨域-？" class="headerlink" title="什么是跨域 ？"></a>什么是跨域 ？</h4><blockquote><p>跨域问题其实就是<strong>浏览器</strong>的<a href="https://developer.mozilla.org/zh-CN/docs/Web/Security/Same-origin_policy">同源策略</a>所导致的。</p><p><strong>同源策略</strong>是一个重要的安全策略，它用于限制一个源<a href="https://developer.mozilla.org/zh-CN/docs/Glossary/Origin">Origin</a>的文档或者它加载的脚本如何能与另一个源的资源进行交互。它能帮助阻隔恶意文档，减少可能被攻击的媒介</p><p><strong>源(Origin)的定义</strong><br>Web 内容的源由用于访问它的<code>URL</code>的 <strong>方案（协议）、主机名（域名）和 端口</strong>定义。只有当协议、主机和端口都匹配时，两个对象才具有相同的源。</p></blockquote><h4 id="什么是同域（源），什么是不同域（源）"><a href="#什么是同域（源），什么是不同域（源）" class="headerlink" title="什么是同域（源），什么是不同域（源）"></a>什么是同域（源），什么是不同域（源）</h4><blockquote><p>我们观察以下 URL 地址:<br><img src="url地址.png"><br>只有当两个 <code>URL</code> 地址的 <code>protocol</code>（协议）、<code>domain</code>（域名）、<code>port</code>（端口） <strong>三者完全相同</strong>时，我们才认为他们是同域，只要三者中任何一个不同，就是不同域，与路径（参数、锚点）无关，路径是否一样无所谓</p></blockquote><ul><li>以下 URL 为同域</li></ul><pre><code>https://www.icodingedu.com/https://www.icodingedu.com/goods/https://www.icodingedu.com/open/course/20https://www.icodingedu.com/goods/show/81?targetId=90&amp;preview=0</code></pre><blockquote><ul><li>以上地址的协议都是：https，域名都是：<a href="http://www.icodingedu.com,端口号没有写,默认都是/">www.icodingedu.com，端口号没有写，默认都是</a> 443</li></ul></blockquote><ul><li>以下 URL 为不同域</li></ul><pre><code>&lt;!-- 以下URL的 协议不同，即为不同域 --&gt;https://www.icodingedu.com/http://www.icodingedu.com/&gt;&lt;!-- 以下URL的 域名不同，即为不同域 --&gt;http://www.icodingedu.com:80/goods/http://m.icodingedu.com:80/goods/&gt;&lt;!-- 以下URL的 第1个和第2个的协议 端口号都不同 --&gt;https://www.icodingedu.com:443/goods/http://www.icodingedu.com:80/goods/</code></pre><blockquote><p>注意事项：</p><ul><li>默认情况下 <code>http</code> 协议的默认端口号是<code>80</code>， 可以省略端口号</li><li><code>https</code> 的默认端口是<code>443</code>，可以省略端口号</li><li>所以以下情况为同域：</li></ul></blockquote><pre><code>http://www.icodingedu.com:80 与 http://www.icodingedu.com 是同域https://www.icodingedu.com:443 与 https://www.icodingedu.com 是同域</code></pre><h4 id="同域请求"><a href="#同域请求" class="headerlink" title="同域请求"></a>同域请求</h4><blockquote><p>如果请求的 URL 地址和当前 URL 地址是<strong>同域</strong>，则不会受浏览器的同源策略限制。所以服务端响应的内容前端能正常的接受到。</p><p><strong>代码演示</strong></p><ul><li>在同一目录下，新建<code>index.html</code>和<code>data.json</code>文件 ，在<code>index.html</code>页面使用<code>Ajax</code>异步请求<code>data.json</code>文件</li></ul></blockquote><ul><li><code>index.html</code>页面核心代码如下</li></ul><pre><code>&gt;&lt;script&gt;  const url = &quot;./data.json&quot;;  const xhr = new XMLHttpRequest();  xhr.onreadystatechange = function () &#123;    if (xhr.readyState !== 4) return;    if ((xhr.status &gt;= 200 &amp;&amp; xhr.status &lt; 300) || xhr.status === 304) &#123;      const data = xhr.responseText;      console.log(data);      console.log(typeof data);      console.log(JSON.parse(data));    &#125;  &#125;;  xhr.open(&quot;get&quot;, url);  xhr.send();&gt;&lt;/script&gt;</code></pre><ul><li><code>data.json</code> 页面代码如下</li></ul><pre><code>&#123;  &quot;username&quot;: &quot;icoding&quot;,  &quot;age&quot;: 33&#125;</code></pre><blockquote><p><strong>代码解读</strong></p><ul><li>上面的代码，相当于是在 <code>http://127.0.0.1:5500/index.html</code> 路径下向 <code>http://127.0.0.1:5500/data.json</code> 路径发送了 <code>Ajax</code> 请求，因为两者 “协议名，域名，端口号” 三者都相同，所以是<strong>同域请求</strong>，并不受浏览器同源策略的限止。<blockquote><p>注意：Ajax发送HTTP请求的url地址可以是<strong>本地</strong>也可以是远程服务</p></blockquote></li></ul></blockquote><h4 id="跨域请求"><a href="#跨域请求" class="headerlink" title="跨域请求"></a>跨域请求</h4><blockquote><p>如果请求的 URL 地址和当前 URL 地址是<strong>不同域</strong>，则会受浏览器的同源策略限制，即服务端响应的会被浏览器给<strong>丢弃掉</strong>。</p><p>也就是说请求发出去了，服务端也响应了内容，但是浏览器在接受到服务端的内容后，发现请求的地址和当前 URL 不是同域的，则会把内容丢弃掉</p></blockquote><blockquote><p><strong>代码演示</strong></p><ul><li>在同一目录下创建<code>index.html</code>和<code>server.js</code>两个文件</li><li><code>server.js</code>文件，用来创建 <code>HTTP</code> 服务器，服务器的访问地址为 <code>http://127.0.0.1:8887</code></li><li>在<code>index.html</code>页面使用 <code>Ajax</code> 异步请求 <code>http://127.0.0.1:8887</code>来获取内容</li></ul></blockquote><ul><li><code>index.html</code></li></ul><pre><code>&gt;&lt;script&gt;  const url = &quot;http://127.0.0.1:8887&quot;;  const xhr = new XMLHttpRequest();  xhr.onreadystatechange = function () &#123;    if (xhr.readyState !== 4) return;    if ((xhr.status &gt;= 200 &amp;&amp; xhr.status &lt; 300) || xhr.status === 304) &#123;      console.log(xhr.responseText);    &#125;  &#125;;  xhr.open(&quot;get&quot;, url);  xhr.send();&gt;&lt;/script&gt;</code></pre><ul><li><code>server.js</code></li></ul><pre><code>const http = require(&quot;http&quot;);http  .createServer((request, response) =&gt; &#123;    console.log(&quot;请求成功&quot;);    // 设置响应头，解决中文乱码    response.writeHead(200, &#123;      &quot;Content-Type&quot;: &quot;text/plain; charset=utf-8&quot;,    &#125;);    response.end(&quot;发送的数据内容&quot;);  &#125;)  .listen(8887);&gt;console.log(&quot;Server running at http://127.0.0.1:8887&quot;);</code></pre><blockquote><p><strong>运行代码：</strong></p><ul><li>先在在 <code>VSCode</code> 的命令终端执行 <code>node server.js</code> 命令来运行 <code>node</code> 程序，创建<code>http://127.0.0.1:8887</code>服务</li><li>然后在 <code>VScode</code> 中打开<code>index.html</code>页面，打开后地址为：<code>http://127.0.0.1:5500/index.html</code>，打开后，其内部就会向<code>http://127.0.0.1:8887</code>发送 <code>Ajax</code> 请求。</li><li>所以我们 <code>VSCode</code> 的终端看到，服务端成功响应请求，并输出 “请求成功”。<blockquote><p>但浏览器端并没有在控制台正确打印服务端响应的内容，而是报如下错误<br><img src="跨域错误.png"></p></blockquote></li></ul></blockquote><blockquote><p>注：</p><ul><li>跨域限制是<strong>浏览器的行为</strong>，它不限制请求发送到服务端，也没有限制服务端响应内容，只在服务端响应内容后，浏览器会判断当前地址和请求地址是不是同一域，如果不是，则会把响应回来的内容丢弃，并抛出相应错误。</li><li>Ajax发送http请求的地址是本地的<code>http://127.0.0.1:5500</code>；而服务器的地址是<code>http://127.0.0.1:8887</code>，端口号不同，所以不同域</li><li>当然，如果后端有相关设置，跨域也是可以的，后面会讲</li></ul></blockquote><h4 id="跨域请求为什么会被阻止"><a href="#跨域请求为什么会被阻止" class="headerlink" title="跨域请求为什么会被阻止"></a>跨域请求为什么会被阻止</h4><blockquote><p>阻止跨域请求，其实是浏览器本身的一种安全策略，即：同源策略</p><p><strong>本质上</strong></p><ul><li>跨域被阻止的问题就是<strong>浏览器本身的问题</strong>（基于安全考虑，帮我们禁止掉了），其他客户端 或 服务器 都不存在跨域被阻止的问题。</li><li>虽然，阻止了跨域请求保障了一定的安全，但有的时候合理的跨域请求也是至关重要的。那我们应该如何跨域请求，还不被浏览器阻止呢 ？<blockquote><p>这就是我们接下来为什么要学习 跨域解决方案的原因了 ！</p></blockquote></li></ul></blockquote><blockquote><p><strong>跨域常用解决方案</strong></p><ul><li>CORS 跨域资源共享（最常用）</li><li>JSONP（主要用到 script 标签）</li><li>代理跨域：开启一个代理服务器实现数据转发<br>关于跨域请求的解决方案有数十种之多，主要看应用场景，每种方式都有各自的优缺点。</li><li>当下我们前端开发中会优先使用 CORS 跨域资源共享。</li></ul></blockquote><h4 id="CORS-跨域资源共享"><a href="#CORS-跨域资源共享" class="headerlink" title="CORS 跨域资源共享"></a>CORS 跨域资源共享</h4><blockquote><ul><li>我们使用 CORS 跨域资源共享 主要是<strong>后端</strong>来解决的，其实我们前端什么都不用做也帮不上啥忙，只要后端解决了，前端就可以实现跨域了。</li></ul></blockquote><ol><li>CORS 是什么<blockquote><p><strong>CORS</strong>（<code>Cross-Origin Resource Sharing</code>）通俗地译为<strong>跨域资源共享</strong>，定义了浏览器与服务器如何实现跨源通信。背后的基本思路是一种基于 HTTP 头的机制，该机制通过允许服务器标示除了它自己以外的其它源（域、协议或端口），使得浏览器允许这些源访问加载自己的资源。</p><p>我们前面说过，因为浏览器的同源策略，所以不同域之间是不能实现资源共享。如果我们想要不同域之间能实现资源共享，我们只需要在服务端的响应头中添加<code>Access-Control-Allow-Origin</code>头信息</p></blockquote></li></ol><ul><li>允许任意的外源访问该资源</li></ul><pre><code>Access-Control-Allow-Origin: &quot;*&quot;</code></pre><ul><li>只允许指定的外源访问该资源</li></ul><pre><code>Access-Control-Allow-Origin: &quot;https://www.xxx.com&quot;</code></pre><ol start="2"><li>CORS 实现资源共享<blockquote><p>接下来我们用代码来演示，<code>CORS</code>是如何解决不同域之间的资源共享。</p><ul><li>在同一目录下新建<code>index.html</code>和<code>server.js</code>文件。</li></ul></blockquote></li></ol><ul><li><code>server.js</code>文件<blockquote><ul><li>用来创建一个<code>HTTP</code>服务，服务的访问地址 <code>http://127.0.0.1:8886</code></li></ul></blockquote></li></ul><pre><code>const http = require(&quot;http&quot;);http  .createServer((request, response) =&gt; &#123;    // 设置响应头    response.writeHead(200, &#123;      // 允许所有域访问      // &quot;Access-Control-Allow-Origin&quot;:&quot;*&quot;      // 只允许http://127.0.0.1:5500 这个域名下的所有请求      &quot;Access-Control-Allow-Origin&quot;: &quot;http://127.0.0.1:5500&quot;,    &#125;);    // 设置响应内容    response.end(&quot;响应内容&quot;);  &#125;)  .listen(8886);console.log(&quot;Server running at http:127.0.0.1:8886&quot;);</code></pre><ul><li><code>index.html</code>页面<blockquote><ul><li>使用<code>Ajax</code>向<code>http://127.0.0.1:8886</code>发起一个异步的请求</li></ul></blockquote></li></ul><pre><code>&gt;&lt;script&gt;  const url = &quot;http://127.0.0.1:8886&quot;;  const xhr = new XMLHttpRequest();  xhr.onreadystatechange = function () &#123;    if (xhr.readyState !== 4) return;    if ((xhr.status &gt;= 200 &amp;&amp; xhr.status &lt; 300) || xhr.status === 304) &#123;      console.log(xhr.response);    &#125;  &#125;;  xhr.open(&quot;get&quot;, url);  xhr.send();&gt;&lt;/script&gt;</code></pre><p><strong>以上代码执行过程</strong></p><blockquote><ul><li>首先在 <code>VSCode</code> 的终端，执行<code>node server.js</code>命令来运行 <code>node</code> 程序，创建 <code>Http</code> 服务，服务地址<code>http:127.0.0.1:8886</code></li><li>然后在 <code>VSCode</code> 中打开 <code>index.html</code> 页面，这时地址栏中的地址为<code>http://127.0.0.1:5500</code>,同时内部的 JS 代码执行，发起了 Ajax 请求，因为请求的地址：<code>http:127.0.0.1:8886</code>和<code>http://127.0.0.1:5500</code>不是同域的，所以就会有跨域限制，但是我们在响应头中设置了<code>&quot;Access-Control-Allow-Origin&quot;:&quot;http://127.0.0.1:5500&quot;</code>，相当于允许<code>http://127.0.0.1:5500</code>来访问我的资源，所以在浏览器的控制台能成功的打印出”响应内容”。</li><li>如果把<code>server.js</code>文件中设置响应头<code>&quot;Access-Control-Allow-Origin&quot;:&quot;http://127.0.0.1:5500&quot;</code>代码去掉，你再次启动 <code>node</code> 服务，刷新<code>index.html</code>页面时，你就发现浏览器的控制台就报出了错误，相当请求失败。</li></ul></blockquote><ol start="3"><li><p>使用 CORS 跨域过程</p><blockquote><ul><li>①、浏览器发送请求</li><li>②、后端在响应头中添加 <code>Access-Control-Allow-Origin</code>头信息</li><li>③、浏览器接收到响应</li><li>④、如果是同域下的请求，浏览器不会额外做什么，这次前后端通信就圆满完成了</li><li>⑤、如果是跨域请求，浏览器会从响应头中查找是否允许跨域访问</li><li>⑥、如果允许跨域，通信圆满完成</li><li>⑦、如果没找到或不包含想要跨域的域名，就丢弃响应结果</li></ul></blockquote></li><li><p>如何给 CORS 设置多域名</p><blockquote><p>如果想要指定<strong>多个外源</strong>能访问该资源，其需要一定的办法才能办到，同时我们还需要了解以下两个必要的知识点：</p><ul><li>如果当前请求是跨域请求，则<strong>请求头</strong>中会有<code>Origin</code> 头字段</li><li>如果当前请求不是跨域请求，则请求头中不会有<code>Origin</code>头字段<blockquote><p>了解了这一点，我们就知道如何：指定多个外源访问该资源<br><strong>具体思路</strong></p></blockquote></li><li>在响应端获取请求头中的<code>Origin</code>字段，如果没有值，则说明当前并没跨域，可以不做任何处理</li><li>如果请求头中带有<code>Orign</code>字段，则说明当前为跨域请求，只需要将响应头<code>Access-Control-Allow-Origin</code>字段的值设置为请求头<code>Orign</code>字段的值</li></ul></blockquote></li></ol><ul><li>具体代码实现</li></ul><pre><code>// 用来保存响应头信息的对象const head = &#123;&#125;;// 允许访问该资源的外源const origin = [&quot;http://127.0.0.1:5500&quot;, &quot;http://127.0.0.1:5501&quot;];// 获取请求头的origin字段中的值，只有在请求是跨域请求是，请求头中才会有该字段，并且该字段的值是发起请求时所在的地址const requestOrigin = request.headers.origin;// 判断origin的值是否在允许的源中，如果在，则将响应头Access-Control-Allow-Origin的值设置为该源if (origin.includes(requestOrigin)) &#123;  head[&quot;Access-Control-Allow-Origin&quot;] = requestOrigin;&#125;&gt;// 设置 Vary: Origin，避免 CDN 缓存破坏 CORS 配置(head[&quot;Vary&quot;] = &quot;Origin&quot;),  // 设置响应头  response.writeHead(200, head);</code></pre><ul><li>完整的 node 代码</li></ul><pre><code>const http = require(&quot;http&quot;);http  .createServer((request, response) =&gt; &#123;    // 用来保存响应头信息的对象    const head = &#123;&#125;;    // 允许访问该资源的外源    const origin = [&quot;http://127.0.0.1:5500&quot;, &quot;http://127.0.0.1:5501&quot;];    // 获取请求头的origin字段中的值，只有在请求是跨域请求是，请求头中才会有该字段，并且该字段的值是发起请求时所在的地址    const requestOrigin = request.headers.origin;    // 判断origin的值是否在允许的源中，如果在，则将响应头Access-Control-Allow-Origin的值设置为该源    if (origin.includes(requestOrigin)) &#123;      head[&quot;Access-Control-Allow-Origin&quot;] = requestOrigin;    &#125;    // 设置 Vary: Origin，避免 CDN 缓存破坏 CORS 配置    (head[&quot;Vary&quot;] = &quot;Origin&quot;),      // 设置响应头      response.writeHead(200, head);    // 设置响应内容    response.end(&quot;响应内容&quot;);  &#125;)  .listen(8886);console.log(&quot;Server running at http:127.0.0.1:8886&quot;);</code></pre><h4 id="JSONP-实现跨域"><a href="#JSONP-实现跨域" class="headerlink" title="JSONP 实现跨域"></a>JSONP 实现跨域</h4><ol><li><p><code>JSONP</code>的原理</p><blockquote><p>在浏览器中<code>&lt;img&gt; 、&lt;link&gt; 、&lt;video&gt; 、&lt;script&gt;</code>等标签在跨域请求资源时<strong>不受浏览器同源策略的影响</strong>。</p><ul><li><code>JSONP</code>主要就是利用<code>&lt;script&gt;</code>标签，加载跨域文件</li></ul></blockquote></li><li><p>使用 JSONP 实现跨域</p><blockquote><p>为了让大家能理解 JSONP 是如何实现跨域来请求资源，我们先来从一段简单的 JS 代码开始说起</p></blockquote></li></ol><ul><li><code>index.html</code>页面的 JS 代码</li></ul><pre><code>&gt;&lt;script&gt;  // 处理数据的函数  data为需要处理的数据  function handle(data) &#123;    console.log(data);  &#125;&gt;  // 调用函数，并将数据作为参数传入 ，这里的操作，我们是希望服务端返回对应的JS代码来实现  handle(&#123; userName: &quot;icoding&quot;, password: 123456 &#125;);&gt;&lt;/script&gt;</code></pre><blockquote><ul><li>我们希望通过<code>&lt;script&gt;</code>标签来发起请求，返回以下<code>JS</code>代码，而不是我们人为写死，因为我们传入函数中的参数数据更希望<strong>后端</strong>发送给到我们。</li></ul></blockquote><pre><code>handle(&#123; userName: &quot;icoding&quot;, password: 123456 &#125;);</code></pre><blockquote><ul><li>改造后的<code>index.html</code>页面代码如下</li></ul></blockquote><pre><code>&gt;&lt;script&gt;  // 处理数据的函数  data为需要处理的数据  function handle(data) &#123;    console.log(data);  &#125;&gt;&lt;/script&gt;&lt;!-- 服务端通过地址中的参数 callback=handle 来判断返回的函数的名--&gt;&gt;&lt;script src=&quot;http://127.0.0.1:8885/callback=handle&quot;&gt;&lt;/script&gt;</code></pre><ul><li><code>node.js</code> 搭建 <code>HTTP</code> 服务<blockquote><p>接下来我们来搭建 <code>HTTP</code> 服务，让大家感受完整的处理过程。即后端拿收到<code>http://127.0.0.1:8885/callback=handle</code>这个请求后，会如何响应，才能实现我们想要的结果</p><ul><li>创建<code>server.js</code>文件，用来创建<code>HTTP</code>服务</li></ul></blockquote></li></ul><pre><code>const http = require(&quot;http&quot;);http  .createServer((request, response) =&gt; &#123;    // 获取路径 /callback=handle 中的handle    const callback = request.url.split(&quot;=&quot;)[1];&gt;    const data = JSON.stringify(&#123; userName: &quot;icoding&quot;, password: 123456 &#125;);    response.end(`$&#123;callback&#125;($&#123;data&#125;)`);    // 上面代码同等于    //   response.end(`handle(&#123;&quot;userName&quot;:&quot;icoding&quot;,&quot;password&quot;:123456&#125;)`)  &#125;)  .listen(8885);console.log(&quot;Server running at http://127.0.0.1:8885&quot;);</code></pre><blockquote><ul><li>服务端根据请求地址中的参数，来确定返回的字符串中的函数名，同时把对应的数据做为函数的实参传入。前端的<code>&lt;script&gt;</code>标签收到响应内容后，会把内容当成<code>JS</code>代码来编译和执行。</li></ul></blockquote><p><strong>代码执行过程</strong></p><blockquote><ul><li>首先在<code>VSCode</code>的终端，执行<code>node server.js</code>命令来运行<code>node</code>程序，创建<code>Http</code>服务，服务地址<code>http:127.0.0.1:8885</code></li><li>然后在<code>VSCode</code>中打开<code>index.html</code>页面，这里你在控制台就能看到函数调用执行后的结果<img src="JSONP实现跨域.png"></li></ul></blockquote><h4 id="代理跨域"><a href="#代理跨域" class="headerlink" title="代理跨域"></a>代理跨域</h4><ol><li><p>代理跨域的原理</p><blockquote><p>我们前面说过，跨域请求被阻止是浏览器的行为，服务器和服务器之间是没有这种限制。</p><p>如果在浏览器访问<code>http:127.0.0.1:5500</code>页面时，该页面发送<code>Ajax</code>请求到<code>http://127.0.0.1:8886</code>服务下获取资源，受到浏览器同源策略的影响，肯定会被阻止。</p><p>如果我们可以在<strong>请求端和服务端之间</strong>架设一个代理服务器。这个代理服务器与请求端满足同源策略，那我们请求端就可把请求发给代理服务器，然后代理服务器帮我们把请求转发给真实的服务器，服务器响应内容给到代理服务器，代理服务器再把内容响应给到请求端。</p><ul><li>这样就完美的解决了跨域问题。<img src="代理跨域.png"></li><li>关于代理服务器，我们后面将到 Vue 时会涉及到。这里我们就用 node 来搭建两个服务器来模拟下中间整个过程。</li></ul></blockquote></li><li><p>模拟代理跨域的实现过程</p><blockquote><ul><li>创建<code>a.js</code>，来创建 HTTP 服务器，服务地址<code>http:127.0.0.1:8881</code></li><li>创建<code>b.js</code>，来创建 HTTP 服务，服务地址<code>http:127.0.0.1:8882</code>在这个服务器中返回一个<code>index.html</code>页面，这个返回的页面需要发送<code>Ajax</code>请求，获取服务器<code>http:127.0.0.1:8881</code>的响应结果。<blockquote><p>因为受到浏览器同源策略的限制，所以请求肯定会失败。</p></blockquote></li></ul></blockquote></li></ol><p><strong>我们模拟代理来实现</strong></p><blockquote><p>我们把请求转发给<code>http:127.0.0.1:8882/userInfo</code>这个服务器，然后这个服务器就相当于是一个代理服务器，他再发送请求到<code>http:127.0.0.1:8881</code>，拿到响应结果后，返回给到浏览器端。<br><img src="代理服务器跨域.png"></p></blockquote><ul><li>新建<code>index.html</code>网页</li></ul><pre><code>&gt;&lt;body&gt;  a.js创建的服务器返回的html内容渲染后页面&gt;  &lt;script&gt;    // 需要获取http:127.0.0.1:8881 服务器响应的内容，因为受到同源策略的限制，所以我们需要把请求发送给到http://127.0.0.1:8882/getInfo,他会在接受到请求后，将请求转发给到http:127.0.0.1:8881，然后拿到响应的结果，返回给到浏览器端。    const url = &quot;http://127.0.0.1:8882/getInfo&quot;;    const xhr = new XMLHttpRequest();    xhr.onreadystatechange = function () &#123;      if (xhr.readyState !== 4) return;      if ((xhr.status &gt;= 200 &amp;&amp; xhr.status &lt; 300) || xhr.status === 304) &#123;        console.log(xhr.response);      &#125;    &#125;;    xhr.open(&quot;get&quot;, url);    xhr.send();&gt;  &lt;/script&gt;&gt;&lt;/body&gt;</code></pre><ul><li>新建<code>a.js</code>创建<code>HTTP</code>服务器，服务地址<code>http:127.0.0.1:8881</code></li></ul><pre><code>const http = require(&quot;http&quot;);const fs = require(&quot;fs&quot;);http  .createServer((request, response) =&gt; &#123;    response.writeHead(200, &#123;      &quot;Content-Type&quot;: &quot;text/plain;charset=utf-8&quot;,    &#125;);    // 发送请求到另一台服务器（目标服务器来获取内容）    response.end(&quot;目标服务器返回的内容&quot;);  &#125;)  .listen(8881);console.log(&quot;Server running at http:127.0.0.1:8881&quot;);</code></pre><ul><li>新建<code>b.js</code>，创建 HTTP 服务器，服务地址<code>http:127.0.0.1:8882</code><blockquote><ul><li>首先，这个地址返回<code>index.html</code>页面</li><li>然后，<code>index.html</code>页面发送<code>Ajax</code>请求到<code>http://127.0.0.1:8882/getInfo</code>；因为<code>index.html</code>是<code>b.js</code>这个服务器返回的，所以他俩是同域的</li><li>这个<code>http://127.0.0.1:8882/getInfo</code>服务器收到请求后，会发送请求到目标服务器<code>http://127.0.0.1:8881</code> 获取响应内容，然后将获取到的内容响应到浏览器端</li></ul></blockquote></li></ul><pre><code>const http = require(&quot;http&quot;);const fs = require(&quot;fs&quot;);// 需要 npm install axios命令在当前目录下安装axios包const axios = require(&quot;axios&quot;);&gt;http  .createServer((request, response) =&gt; &#123;    // 获以url路径    if (request.url === &quot;/&quot;) &#123;      // 读取文件内容      const html = fs.readFileSync(&quot;./index.html&quot;);      response.writeHead(200, &#123;        &quot;Content-Type&quot;: &quot;text/html;charset=utf-8&quot;,      &#125;);      response.end(html);    &#125; else &#123;      // 发送请求到另一台服务器（目标服务器来获取内容）      axios.get(&quot;http://127.0.0.1:8881&quot;).then((res) =&gt; &#123;        // 将目标服务器响应的内容作为响应内容返回        response.end(res.data);      &#125;);    &#125;  &#125;)  .listen(8882);console.log(&quot;Server running at http:127.0.0.1:8882&quot;);</code></pre><h3 id="四、XHR-对象的属性"><a href="#四、XHR-对象的属性" class="headerlink" title="四、XHR 对象的属性"></a>四、XHR 对象的属性</h3><ol><li><code>responseType</code>、<code>esponseText</code>、<code>response</code>属性<table><thead><tr><th>属性</th><th>描述</th></tr></thead><tbody><tr><td>responseType</td><td>属性值是一个枚举字符串值，用于<strong>指定响应中包含的数据类型</strong>。其常用的类型有：<code>text</code>、<code>json</code>。 如果没有指定，则默认值为<code>text</code>文本类型</td></tr><tr><td>response</td><td>用于<strong>返回响应的正文</strong>，返回的类型为<code>responseType</code>指定的类型</td></tr><tr><td>esponseText</td><td>用来<strong>返回响应的正文</strong>，其接受的内容为文本形式。所以只有在没有设置<code>responseType</code>或者<code>responseType = &quot;&quot;</code>或<code>&quot;text&quot;</code>的时候才能使用</td></tr></tbody></table></li></ol><blockquote><p><strong>提示：</strong></p><ul><li>通过上面的了解，我们应该知道<code>response</code>完全可以替代 <code>responseText</code> ，关于<code>responseType</code>的更多类型，可查看 MDN 官方文档</li></ul></blockquote><p><strong>代码演示</strong></p><blockquote><p>如果<code>xhr.responseType=&#39;json&#39;</code>，则<code>xhr.response</code>的返回值是经过<code>json</code><strong>解析后的</strong><code>js</code>对象。</p><ul><li>所以如果返回内容不是<code>json</code>格式的，则返回值为<code>null</code></li></ul></blockquote><ul><li><code>server.js</code>创建 HTTP 服务</li></ul><pre><code>const http = require(&quot;http&quot;);http  .createServer((request, response) =&gt; &#123;    response.writeHead(200, &#123;      &quot;Content-Type&quot;: &quot;text/plain;charset=utf-8&quot;,      &quot;Access-Control-Allow-Origin&quot;: &quot;*&quot;,    &#125;);&gt;    response.end(`&#123;&quot;username&quot;:&quot;icoding&quot;,&quot;age&quot;:12&#125;`);    //  response.end(&#39;abc&#39;);  &#125;)  .listen(8885);console.log(&quot;Server running at http://127.0.0.1:8885&quot;);</code></pre><ul><li><code>index.html</code>文件</li></ul><pre><code>const url = &quot;http://127.0.0.1:8885&quot;;const xhr = new XMLHttpRequest();xhr.onreadystatechange = function () &#123;  if (xhr.readyState !== 4) return;  if ((xhr.status &gt;= 200 &amp;&amp; xhr.status &lt; 300) || xhr.status === 304) &#123;    console.log(xhr.response); // 如果服务端响应内容不符合JSON格式,则最后的结果为null  &#125;&#125;;// 指定接受过来的响应的数据类型，如果为json字符串，则收到的值为json解析后的js对象xhr.responseType = &quot;json&quot;;xhr.open(&quot;get&quot;, url);xhr.send();</code></pre><ol start="2"><li><code>timeout</code>属性<blockquote><p><code>timeout</code>的值是 是一个无符号长整型数（正整数），代表着一个请求在被自动终止前所消耗的毫秒数。也就是说在规定时间内请求发出去还没有响应，则取消请求。</p></blockquote></li></ol><pre><code>xhr.timeout = 10; //  超时时间为10ms</code></pre><blockquote><ul><li><code>timeout</code>的默认值为 0，意味着没有超时（不设置 timeout 属性，就没有超时一说）</li><li><code>timeout</code>一般在调用<code>open()</code>方法之后且在调用<code>send()</code>方法之前设置。</li><li><code>timeout</code>属性常于**<code>timeout</code>事件**结合使用，在超时后，就会触发<code>timeout</code>事件，我们可以在<code>timeout</code>事件中来做相关处理</li></ul></blockquote><pre><code>const url =  &quot;https://www.fastmock.site/mock/6ec78e345df340241e1f5043f0167833/icode/test&quot;;const xhr = new XMLHttpRequest();xhr.onreadystatechange = function () &#123;  if (xhr.readyState !== 4) return;  if ((xhr.status &gt;= 200 &amp;&amp; xhr.status &lt; 300) || xhr.status === 304) &#123;    console.log(xhr.response);  &#125;&#125;;xhr.ontimeout = function () &#123;  console.log(&quot;timeout&quot;);&#125;;xhr.open(&quot;get&quot;, url);xhr.timeout = 1000; // 请求超过1s还没响应，则取消请求xhr.send();</code></pre><ol start="3"><li>withCredentials 属性<blockquote><p><code>withCredentials</code>属性：指定**<code>Ajax</code>跨域**请求是要不要携带<code>cookie</code>等。</p></blockquote></li></ol><blockquote><p>使用<code>Ajax</code>发送请求，<strong>默认情况下</strong>：</p><ul><li>同域时，会携带 Cookie</li><li>跨域时，不会携带Cookie</li></ul><p>同时需要设置<code>xhr.withCredentials = true;</code> ，但最终能否成功跨域携带 Cookie 还要看服务器是否同意，<strong>服务器端</strong>默认是不同意的。</p><ul><li>如果在同域请求时，设置<code>xhr.withCredentials=true;</code><strong>会抛出错误</strong></li><li>如果需要成功携带 Cookie 服务端还需要以下两个设置。</li></ul><p><strong>服务端的设置</strong></p><ul><li>服务端必需要设置Access-Control-Allow-Origin，告诉浏览器允许跨域，而且这个值必须指定域名，不能设置为 *</li><li>在响应头中，Access-Control-Allow-Credentials这个值也要设置为true</li></ul></blockquote><p><strong>代码演示</strong></p><ul><li>新建<code>index.html</code>页面，代码如下</li></ul><pre><code>const url =  &quot;https://www.fastmock.site/mock/6ec78e345df340241e1f5043f0167833/icode/users/login&quot;;const xhr = new XMLHttpRequest();xhr.onreadystatechange = function () &#123;  if (xhr.readyState !== 4) return;  if ((xhr.status &gt;= 200 &amp;&amp; xhr.status &lt; 300) || xhr.status === 304) &#123;    console.log(xhr.responseText);  &#125;&#125;;&gt;xhr.open(&quot;post&quot;, url);xhr.setRequestHeader(&quot;Content-Type&quot;, &quot;application/json&quot;);//允许Ajax跨域请求时携带Cookie，如果把这里去掉，则请求时，请求头中没有Cookie信息xhr.withCredentials = true;xhr.send(JSON.stringify(&#123; username: &quot;admin&quot;, password: &quot;123456&quot; &#125;));</code></pre><p><strong>温馨提示：</strong></p><blockquote><p>在测试这个功能时，建议使用<code>Firfox</code>（火狐）浏览器，因为 <code>Chrome 80</code> 版本以上的浏览器中仍然在请求头中没有携带 <code>Cookie</code>。原因在于<code>Chrome 80</code>以后<code>SameSite</code>的默认值为<code>Lax</code>，导致跨域<code>Cookie</code>传输收到限制，在此之前默认值为<code>none</code>。</p><ul><li>此处内容为后端人员需要解决的，所以不讲解（网上也有现成的答案，有兴趣自已了解）</li></ul></blockquote><h3 id="五、XHR-对象的方法"><a href="#五、XHR-对象的方法" class="headerlink" title="五、XHR 对象的方法"></a>五、XHR 对象的方法</h3><ol><li>abort() 方法<blockquote><ul><li>如果该请求已被发出，<code>XMLHttpRequest.abort()</code>方法将终止该请求</li><li>需要<code>send()</code>方法发送请求完<strong>之后</strong>再调用<code>abort()</code>方法</li><li><code>abort()</code>方法一般与**<code>abort</code>事件**一起配合使用</li></ul></blockquote></li></ol><pre><code>const url =  &quot;https://www.fastmock.site/mock/6ec78e345df340241e1f5043f0167833/icode/test&quot;;const xhr = new XMLHttpRequest();xhr.onreadystatechange = function () &#123;  if (xhr.readyState !== 4) return;  if ((xhr.status &gt;= 200 &amp;&amp; xhr.status &lt; 300) || xhr.status === 304) &#123;    console.log(xhr.response);  &#125;&#125;;// abort事件，在调用abort方法时，触发xhr.onabort = function () &#123;  console.log(&quot;abort&quot;);&#125;;xhr.open(&quot;get&quot;, url);xhr.send();&gt;// 需要在发送完请求之后来调用 abort() 方法，即：发送完请求后，立马就取消了// abort() 方法用来终止当前请求// 请完成后，马上又终止了请求xhr.abort();</code></pre><ol start="2"><li>setRequestHeader 方法<blockquote><p><code>XMLHttpRequest.setRequestHeader()</code>是设置 <code>HTTP</code> 请求<strong>头部</strong>的方法。</p><ul><li>此方法必须在<code>open()</code>方法和 <code>send()</code> 之间调用。<br><strong>语法</strong></li></ul></blockquote></li></ol><pre><code>// header 属性的名称   value属性的值xhr.setRequestHeader(header, value);</code></pre><blockquote><ul><li>为了安全起见，大部分的请求头我们是没办法设置的，具体查阅官方文档</li></ul></blockquote><blockquote><p>我们学习<code>setRequestHeader()</code>主要是为了设置<code>Content-Type</code>的属性值，在请求中，<code>Content-Type</code>主要是告诉服务器实际发送的数据类型，其值为<code>MIME</code>类型。</p><ul><li><a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Basics_of_HTTP/MIME_types">MIME类型</a></li></ul></blockquote><pre><code>const url =  &quot;https://www.fastmock.site/mock/6ec78e345df340241e1f5043f0167833/icode/users/login&quot;;const xhr = new XMLHttpRequest();xhr.onreadystatechange = function () &#123;  if (xhr.readyState !== 4) return;  if ((xhr.status &gt;= 200 &amp;&amp; xhr.status &lt; 300) || xhr.status === 304) &#123;    console.log(xhr.response);  &#125;&#125;;&gt;xhr.open(&quot;post&quot;, url);&gt;/*&gt;    前后端通信时，需要协商好发送的数据类型（参数），默认不设置&quot;Content-Type&quot;属性时，其值为&quot;text/plain&quot;类型。但是响应端https://www.fastmock.site/.....是以JSON格式来处理接受的参数，所以不设置就会造成数据出错，拿不到结果。&gt;*/xhr.setRequestHeader(&quot;Content-Type&quot;, &quot;application/json&quot;);const data = &#123;  username: &quot;admin&quot;,  password: &quot;123456&quot;,&#125;;xhr.send(JSON.stringify(data));</code></pre><h3 id="六、XHR-对象的事件"><a href="#六、XHR-对象的事件" class="headerlink" title="六、XHR 对象的事件"></a>六、XHR 对象的事件</h3><blockquote><p>XHR 常用的事件有</p><table><thead><tr><th>事件</th><th>说明</th></tr></thead><tbody><tr><td>loadstart</td><td>当调用send()函数，发出请求时触发</td></tr><tr><td>load</td><td>当请求完成（成功）时触发</td></tr><tr><td>loadend</td><td>请求结束时触发，无论请求成功 ( load) 还是失败 (abort) 或 (error)</td></tr><tr><td>error</td><td>当请求或网络错误时触发</td></tr><tr><td>timeout</td><td>当请求超时时触发</td></tr><tr><td>abort</td><td>当调用 abort 方 法，终止请求时触发</td></tr><tr><td>progress</td><td>当服务器响应数据时开始周期性触发</td></tr></tbody></table></blockquote><blockquote><p>注：</p><ul><li>对任何请求，浏览器只会触发<code>load、timeout、abort、error</code>事件<strong>中的一个</strong><br>更多事件可 查阅官方文档</li></ul></blockquote><ol><li>load、loadstart、loadend 事件<blockquote><p><code>load</code>事件：用于响应数据成功时触发，相当于<code>readyState === 4</code>时，才会触发。</p><ul><li>所以我们可以用<code>load</code>事件<strong>代替</strong><code>readystatechange</code>监听事件，处理响应。</li></ul></blockquote></li></ol><pre><code>const url =  &quot;https://www.fastmock.site/mock/6ec78e345df340241e1f5043f0167833/icode/test&quot;;const xhr = new XMLHttpRequest();//   xhr.onreadystatechange = function () &#123;//     if (xhr.readyState !== 4) return;//     if((xhr.status &gt;= 200 &amp;&amp; xhr.status &lt; 300) || xhr.status === 304 ) &#123;//       console.log(xhr.response);//     &#125;//   &#125;;&gt;// 用onload代替onreadystatechange,代码如下xhr.onload = function () &#123;  if ((xhr.status &gt;= 200 &amp;&amp; xhr.status &lt; 300) || xhr.status === 304) &#123;    console.log(xhr.response);  &#125;&#125;;xhr.open(&quot;get&quot;, url);xhr.send();</code></pre><ul><li>对比 load、loadstart、loadend 事件</li></ul><pre><code>const url =  &quot;https://www.fastmock.site/mock/6ec78e345df340241e1f5043f0167833/icode/test&quot;;const xhr = new XMLHttpRequest();// 当调用send()函数，发出请求时触发xhr.onloadstart = function () &#123;  console.log(&quot;loadstart&quot;);&#125;;// 当请求完成（成功）时触发xhr.onload = function () &#123;  console.log(&quot;load&quot;);&#125;;// 请求结束时触发，无论请求成功 (load) 还是失败 (abort) 或 (error)xhr.onloadend = function () &#123;  console.log(&quot;loadend&quot;);&#125;;&gt;xhr.open(&quot;get&quot;, url);xhr.send();//loadstart//load//loadend</code></pre><ol start="2"><li>error 事件<blockquote><p>error 事件：请求发生错误时触发</p></blockquote></li></ol><pre><code>// url地址中的site，错写成了sitconst url =  &quot;https://www.fastmock.sit/mock/6ec78e345df340241e1f5043f0167833/icode/test&quot;;const xhr = new XMLHttpRequest();// 当调用send()函数，发出请求时触发xhr.onloadstart = function () &#123;  console.log(&quot;loadstart&quot;);&#125;;// 当请求完成（成功）时触发xhr.onload = function () &#123;  console.log(&quot;load&quot;);&#125;;// 请求结束时触发，无论请求成功 (load) 还是失败 (abort) 或 (error)xhr.onloadend = function () &#123;  console.log(&quot;loadend&quot;);&#125;;// 请求发生错误时触发，比如上面的url地址错误xhr.onerror = function () &#123;  console.log(&quot;error&quot;);&#125;;&gt;xhr.open(&quot;get&quot;, url);xhr.send();//loadstart//error//loadend</code></pre><ol start="3"><li>abort 事件<blockquote><p>abort 事件：调用 abort() 终止请求时触发</p></blockquote></li></ol><pre><code>const url =  &quot;https://www.fastmock.site/mock/6ec78e345df340241e1f5043f0167833/icode/test&quot;;const xhr = new XMLHttpRequest();xhr.addEventListener(&quot;load&quot;, () =&gt; &#123;  if ((xhr.status &gt;= 200 &amp;&amp; xhr.status &lt; 300) || xhr.status === 304) &#123;    console.log(xhr.response);  &#125;&#125;);// 当调用abort方法终止请求时触发xhr.addEventListener(&quot;abort&quot;, () =&gt; &#123;  console.log(&quot;abort&quot;);&#125;);xhr.open(&quot;get&quot;, url);xhr.send();// 调用 abort() 方法终止请求xhr.abort();</code></pre><ol start="4"><li>timeout 事件<blockquote><p>timeout 事件：当请求超时后触发</p></blockquote></li></ol><pre><code>const url =  &quot;https://www.fastmock.site/mock/6ec78e345df340241e1f5043f0167833/icode/test&quot;;const xhr = new XMLHttpRequest();xhr.onreadystatechange = function () &#123;  if (xhr.readyState !== 4) return;  if ((xhr.status &gt;= 200 &amp;&amp; xhr.status &lt; 300) || xhr.status === 304) &#123;    console.log(xhr.response);  &#125;&#125;;xhr.ontimeout = function () &#123;  console.log(&quot;timeout&quot;);&#125;;xhr.open(&quot;get&quot;, url);xhr.timeout = 1000; // 请求超过1s还没响应，则取消请求xhr.send();</code></pre><ol start="5"><li>progress 事件<blockquote><p>progress 事件会在请求接收到数据的时候被<strong>周期性触发</strong>。</p><ul><li>在 progress 事件的<strong>事件对象（Event）</strong>上存在以下<strong>三个重要的属性</strong>，可以用来显示资源的下载进度，用<code>e.属性名</code>的方式调用。</li></ul></blockquote></li></ol><table><thead><tr><th>属性</th><th>描述</th></tr></thead><tbody><tr><td>lengthComputable</td><td>只读属性，是一个布尔值；表示底层流程将需要完成的总工作量和已经完成的工作量是否可以计算。换句话说，它告诉我们<strong>进度是否可以被测量</strong></td></tr><tr><td>loaded</td><td>只读属性，是一个正整数，表示底层流程<strong>已经执行</strong>的工作总量</td></tr><tr><td>total</td><td>只读属性，是一个正整数，表示正在执行的底层流程的工作<strong>总量</strong>。（需要在响应头中携带<code>Content-Length</code>字段，<code>total</code>相当于是读取这个字段的信息</td></tr></tbody></table><p><strong>代码演示</strong></p><blockquote><p>在请求资源时，最好弄一张大的图片，以免因为加载内容太小而看不到效果。同时在控制台把网速调慢和禁用缓存，否则直接从缓存读取或网速过快，也看不到进度效果。</p></blockquote><pre><code>// 请求地址const url = &quot;./bg.jpg&quot;;// 创建xhr对象const xhr = new XMLHttpRequest();// 响应成功的操作xhr.onload = function () &#123;  // 成功相关的操作可以自己设置&#125;;// 数据响应过程中的进度情况xhr.onprogress = function (e) &#123;  // 如果进度可以被测量  if (e.lengthComputable) &#123;    // 获取当前已执行的工作总量    const loaded = e.loaded;    // 获取响应数据的工作总量    const total = e.total;    // 计算当前的工作进程（百分比）    console.log(&quot;图片加载进度:&quot;, ((loaded / total) * 100).toFixed(0) + &quot;%&quot;);  &#125;&#125;;// 准备发送xhr.open(&quot;get&quot;, url);// 正式发送xhr.send();</code></pre><ol start="6"><li>案例：显示图片加载进度</li></ol><ul><li>页面布局</li></ul><pre><code>&gt;&lt;style&gt;  html,  body &#123;    width: 100%;    height: 100%;    margin: 0;    padding: 0;  &#125;  body &#123;    display: flex;    justify-content: center;    align-items: center;  &#125;  .progress &#123;    width: 80%;    height: 50px;  &#125;  .progress .progress-bar &#123;    width: 0%;    height: 50px;    background-color: red;    text-align: center;    line-height: 50px;    color: #fff;    transition: all 0.2;  &#125;&gt;&lt;/style&gt;&gt;&lt;body&gt;&gt;  &lt;div class=&quot;progress&quot;&gt;&gt;    &lt;div class=&quot;progress-bar&quot;&gt;&lt;/div&gt;&gt;  &lt;/div&gt;&gt;&lt;/body&gt;</code></pre><ul><li>JS实现加载进度条</li></ul><pre><code>let progressEl = document.querySelector(&quot;.progress&quot;);// 获取DOM元素let bar = document.querySelector(&quot;.progress-bar&quot;);&gt;// 请求地址const url = &quot;./bg.jpg&quot;;// 创建xhr对象const xhr = new XMLHttpRequest();// 响应成功的操作xhr.onload = function () &#123;  // 读取响应过来的数据  let blob = xhr.response;  // 根据blob创建对象的URL  let src = window.URL.createObjectURL(blob);  // 创建图片标签  let img = document.createElement(&quot;img&quot;);  // 给图片添加地址  img.src = src;  // 将图片添加到页面中  document.body.appendChild(img);  // 将进度掉隐藏  if (progressEl) &#123;    document.body.removeChild(progressEl);    progressEl = null;    bar = null;  &#125;&#125;;// 数据响应过程中的进度情况xhr.onprogress = function (e) &#123;  // 如果进度可以被测量  if (e.lengthComputable) &#123;    // 获取当前已执行的工作总量    const loaded = e.loaded;    // 获取响应数据的工作总量    const total = e.total;    // 计算当前的工作进程（百分比）    let progress = ((loaded / total) * 100).toFixed(0);    bar.style.width = progress + &quot;%&quot;;    bar.innerText = progress + &quot;%&quot;;  &#125;&#125;;// 将接受的数据类型设置为blob,一个包含二进制数据的 Blob 对象xhr.responseType = &quot;blob&quot;;// 准备发送xhr.open(&quot;get&quot;, url);// 正式发送xhr.send();</code></pre><blockquote><ul><li><code>xhr.response</code>接收到的是二进制数据，需要两步：<ul><li>将XHR对象的属性<code>responseType</code>设置为<code>&quot;blob&quot;</code></li><li>用静态方法<code>window.URL.createObjectURL(xhr.response)</code>将二进制数据转化成<code>blob</code>格式的URL</li></ul></li></ul></blockquote><h3 id="七、Ajax-的简单封装"><a href="#七、Ajax-的简单封装" class="headerlink" title="七、Ajax 的简单封装"></a>七、Ajax 的简单封装</h3><ol><li>Promise 简单封装 Ajax<blockquote><p>利用 Promise 来简单封装下 Ajax 请求，关于更完善更复杂的封装后面再讲。</p></blockquote></li></ol><pre><code>&gt;/**&gt; * @param method 表示请求的方法，如get或post&gt; * @param url 请求的地址&gt; * @param body 如果为post请求，传入的请求体数据，需要传入JSON格式&gt; */function ajax(method, url, body = null) &#123;  // 返回Promise对象  return new Promise((resolve, reject) =&gt; &#123;    const xhr = new XMLHttpRequest();    xhr.addEventListener(&quot;load&quot;, () =&gt; &#123;      if ((xhr.status &gt;= 200 &amp;&amp; xhr.status &lt; 300) || xhr.status === 304) &#123;        resolve(xhr.response);      &#125; else &#123;        reject(&quot;请求失败&quot;);      &#125;    &#125;);    // 响应过来的数据类型为json格式才接受    xhr.responseType = &quot;json&quot;;    xhr.open(method, url);    xhr.setRequestHeader(&quot;Content-Type&quot;, &quot;application/json&quot;); // 发送JSON格式数据    xhr.send(body);  &#125;);&#125;&gt;export default ajax;</code></pre><blockquote><p>注意：</p><ul><li>我们设置了响应过来的数据类型为json格式，所以使用<code>post</code>方法的时候，<code>.send()</code>里面的数据要用<code>JSON.stringify()</code>处理</li></ul></blockquote><ol start="2"><li>Ajax继发</li></ol><pre><code>&gt;&lt;script type=&quot;module&quot;&gt;  import ajax from &quot;./ajax.js&quot;;  ajax(    &quot;get&quot;,    &quot;https://www.fastmock.site/mock/b7eabdc70b21d19726d2d7ee7f372da9/item/user?num=2&quot;  )    .then((data) =&gt; &#123;      console.log(data);      return ajax(        &quot;post&quot;,        &quot;https://www.fastmock.site/mock/b7eabdc70b21d19726d2d7ee7f372da9/item/login&quot;,        JSON.stringify(&#123; username: &quot;hermia&quot;, password: 12345 &#125;)      );    &#125;)    .then((data) =&gt; &#123;      console.log(data);    &#125;);&gt;&lt;/script&gt;</code></pre><ol start="3"><li>Ajax并发</li></ol><pre><code>&gt;&lt;script type=&quot;module&quot;&gt;  import ajax from &quot;./ajax.js&quot;;  ajax(    &quot;get&quot;,    &quot;https://www.fastmock.site/mock/b7eabdc70b21d19726d2d7ee7f372da9/item/user?num=2&quot;  ).then((data) =&gt; &#123;    console.log(data);  &#125;);  ajax(    &quot;post&quot;,    &quot;https://www.fastmock.site/mock/b7eabdc70b21d19726d2d7ee7f372da9/item/login&quot;,    JSON.stringify(&#123; username: &quot;hermia&quot;, password: &quot;12345&quot; &#125;)  ).then((data) =&gt; &#123;    console.log(data);  &#125;);&gt;&lt;/script&gt;</code></pre><ol start="4"><li>Ajax 并发问题<blockquote><p>利用 Promise.all 来处理多个 Ajax 并发的问题</p><ul><li>实现：两个Ajax并发后，拿到结果，再继发一条Ajax请求</li></ul></blockquote></li></ol><blockquote><ul><li>相关伪代码如下：</li></ul></blockquote><pre><code>const p1=ajax(method,url);const p2=ajax(method,url)&gt;const p=Promise.all([p1,p2]);p.then([data1,data2]=&gt;&#123;    console.log(data1)    console.log(data2)&#125;)&gt;// 以上针对情况是在需要拿到p1和p2的结果后，才能做后续相关操作</code></pre><blockquote><ul><li>代码处理</li></ul></blockquote><pre><code>&gt;&lt;script type=&quot;module&quot;&gt;  import ajax from &quot;./ajax.js&quot;;  const p1 = ajax(    &quot;get&quot;,    &quot;https://www.fastmock.site/mock/b7eabdc70b21d19726d2d7ee7f372da9/item/user?num=2&quot;  );  const p2 = ajax(    &quot;post&quot;,    &quot;https://www.fastmock.site/mock/b7eabdc70b21d19726d2d7ee7f372da9/item/login&quot;,    JSON.stringify(&#123; username: &quot;hermia&quot;, password: &quot;12345&quot; &#125;)  );  Promise.all([p1, p2])    .then((data) =&gt; &#123;      console.log(data); //由p1,p2的data组成的数组 [&#123;…&#125;, &#123;…&#125;]      return ajax(        &quot;get&quot;,        &quot;https://www.fastmock.site/mock/b7eabdc70b21d19726d2d7ee7f372da9/item/user?num=3&quot;      );    &#125;)    .then((data) =&gt; &#123;      console.log(data); //&#123;code: &#39;0000&#39;, message: &#39;成功&#39;, data: &#39;成功返回三条数据&#39;&#125;    &#125;);&gt;&lt;/script&gt;</code></pre><h3 id="八、Ajax-的实践与应用"><a href="#八、Ajax-的实践与应用" class="headerlink" title="八、Ajax 的实践与应用"></a>八、Ajax 的实践与应用</h3><h4 id="案例1：搜索自动补全"><a href="#案例1：搜索自动补全" class="headerlink" title="案例1：搜索自动补全"></a>案例1：搜索自动补全</h4><ol><li>实现思路<blockquote><ul><li>给输入框绑定<code>input</code>事件,然后在事件中判断文本框输入的内容。如果内容不为空，则把输入的内容作为查询的参数拼接到请求的 <code>url </code>地址上，然后利用 <code>Ajax</code> 向后端发送 <code>get</code> 请求。</li><li>根据后端返回的数据来创建 <code>DOM</code>，并插入到页面中。</li></ul></blockquote></li></ol><pre><code>&gt;&lt;style&gt;&gt;  .search &#123;&gt;    display: flex;&gt;    height: 200px;&gt;    flex-direction: column;&gt;    align-items: center;&gt;  &#125;&gt;  .search-input &#123;&gt;    width: 400px;&gt;    height: 40px;&gt;  &#125;&gt;&lt;/style&gt;&gt;&gt;&lt;div class=&quot;search&quot;&gt;&gt;  &lt;div&gt;&lt;input type=&quot;text&quot; name=&quot;&quot; class=&quot;search-input&quot; /&gt;&lt;/div&gt;&gt;  &lt;ul class=&quot;list&quot;&gt;&gt;    &lt;li&gt;111&lt;/li&gt;&gt;  &lt;/ul&gt;&gt;&lt;/div&gt;&gt;&gt;&lt;script type=&quot;module&quot;&gt;  // 导入模块  import ajax from &quot;./ajax.js&quot;;  // 获取DOM  const list = document.querySelector(&quot;.list&quot;);  const searchInput = document.querySelector(&quot;.search-input&quot;);  // 请求地址  let url =    &quot;https://www.fastmock.site/mock/6ec78e345df340241e1f5043f0167833/icode/search/keyword&quot;;  // 监听文本框input输入事件  searchInput.oninput = function () &#123;    // 获取内容，并去除字符串前后的空格    let value = this.value.trim();    // 如果输入内容不为空，则发起Ajax请求    if (value) &#123;      // 将搜索的参数拼接在url后面，发送到服务端      let newUrl = `$&#123;url&#125;?keyword=$&#123;value&#125;`;      ajax(&quot;get&quot;, newUrl).then((res) =&gt; &#123;        let data = res.data;        // 根据返回的数据，创建DOM，添加到页面中        render(data);      &#125;);    &#125; else &#123;      list.innerHTML = &quot;&quot;;    &#125;  &#125;;&gt;  // 根据请求的数据创建DOM，添加到页面  function render(data) &#123;    let html = &quot;&quot;;    list.innerHTML = &quot;&quot;; // 重新赋值前，先将原来的内容清空    for (let &#123; keyword &#125; of data) &#123;      html += `&lt;li&gt;$&#123;keyword&#125;&lt;/li&gt;`;    &#125;    list.innerHTML = html;  &#125;&gt;&lt;/script&gt;</code></pre><ol start="2"><li>优化</li></ol><ul><li>如果想要降低请求的频率，可以结合之间讲的防抖函数，在规定的时间内再次触发 <code>input</code> 事件，则重新计时。</li></ul><pre><code>&gt;/**&gt; * debounce 防抖函数&gt; * @param fn 事件处理函数&gt; * @param delay 延迟时间&gt; */function debounce(fn, delay = 200) &#123;  var timer = null;  // 以下是每次需要执行的代码  return function () &#123;    if (timer) clearTimeout(timer);    // 开启定时器    timer = setTimeout(() =&gt; &#123;      fn.apply(this, arguments);      timer = null; // 这里很多人有争议，要不要置空    &#125;, delay);  &#125;;&#125;</code></pre><ul><li>如果上一次请求没有响应回来前，又触发了事件，则把上一次请求取消，重新发送请求<blockquote><ul><li>关注以下代码<code>--------------------------------</code>部分内容</li></ul></blockquote></li></ul><pre><code>import ajax from &quot;./ajax.js&quot;;// 获取输入框const searchInput = document.querySelector(&quot;.search-input&quot;);// 获取ul列表const list = document.querySelector(&quot;.list&quot;);// 请求地址let url =    &quot;https://www.fastmock.site/mock/6ec78e345df340241e1f5043f0167833/icode/search/keyword&quot;;&gt;//---------------------------------let xhr = null; // 保证xhr对象let done = false; // 当前没有请求// --------------------------------&gt;// 给输入框添加input事件searchInput.oninput = function () &#123;    // 获取输入框中内容，并去掉前后的空格    let value = this.value.trim();&gt;    // --------------------------------    if (done) &#123;        xhr.abort();    &#125;    done = true; // 当前有请求    // --------------------------------&gt;    // 如果输入框中的内容不为空，把对应内容作为参数拼接到URL后面，发送到服务端    if (value) &#123;        let newUrl = `$&#123;url&#125;?keyword=$&#123;value&#125;`;        xhr = new XMLHttpRequest();        // 监听事件        xhr.addEventListener(&quot;load&quot;, () =&gt; &#123;            if ((xhr.status &gt;= 200 &amp;&amp; xhr.status &lt; 300) || xhr.status === 304) &#123;                // 响应成功                // --------------------------------                done = false; // 请求响应回来，标识目前没有请求                // --------------------------------                render(xhr.response.data);            &#125; else &#123;                // 响应失败            &#125;        &#125;);        // 统一响过来的数据只是JSON类型，并把他转换成JS对象返回        xhr.responseType = &quot;json&quot;;        xhr.open(&quot;get&quot;, newUrl);        xhr.send();    &#125; else &#123;        list.innerHTML = &quot;&quot;;    &#125;&#125;;&gt;// 用来渲染DOMfunction render(data) &#123;    let html = &quot;&quot;;    for (let &#123; keyword &#125; of data) &#123;        html += `&lt;li&gt;$&#123;keyword&#125;&lt;/li&gt;`;    &#125;    list.innerHTML = html;&#125;</code></pre><h4 id="案例2：动态加载二级菜单"><a href="#案例2：动态加载二级菜单" class="headerlink" title="案例2：动态加载二级菜单"></a>案例2：动态加载二级菜单</h4><ul><li>HTML、CSS 布局</li></ul><pre><code>&gt;&lt;style&gt;  html,  body,  ul &#123;    margin: 0;    padding: 0;    list-style: none;  &#125;  .menu &#123;    width: 200px;    margin-left: 300px;    margin-top: 100px;    border: 1px solid #ddd;    position: relative;  &#125;  .menu ul li &#123;    padding-left: 20px;    height: 50px;    line-height: 50px;    cursor: pointer;  &#125;  .menu ul li:hover &#123;    background-color: tomato;    color: #fff;  &#125;  .menu ul li:hover .content &#123;    display: block;  &#125;  .menu .content &#123;    width: 200px;    min-height: 250px;    position: absolute;    left: 200px;    top: 0;    background-color: #ddd;    display: none;    padding: 0 10px;  &#125;  .menu .content p &#123;    display: flex;    align-items: center;  &#125;  .menu .content p img &#123;    width: 50px;    margin-right: 10px;  &#125;  .menu .content p a &#123;    text-decoration: none;    color: #000;  &#125;&gt;&lt;/style&gt;&gt;&lt;body&gt;&gt;  &lt;div class=&quot;menu&quot;&gt;  &lt;!-- &lt;ul&gt;      &lt;li data-id=&quot;&quot; data-done=&quot;&quot;&gt;        一级菜单        &lt;div class=&quot;content&quot;&gt;          加载二级菜单前          &lt;img src=&quot;./loading-balls.svg&quot; alt=&quot;&quot; /&gt;          加载后          &lt;p&gt;            &lt;img src=&quot;&quot; alt=&quot;&quot; /&gt;            &lt;a href=&quot;&quot;&gt;&lt;/a&gt;          &lt;/p&gt;        &lt;/div&gt;      &lt;/li&gt;      &lt;li&gt;一级2&lt;/li&gt;      &lt;li&gt;一级3&lt;/li&gt;      &lt;li&gt;一级4&lt;/li&gt;      &lt;li&gt;一级5&lt;/li&gt;    &lt;/ul&gt; --&gt;&gt;  &lt;/div&gt;&gt;&lt;/body&gt;</code></pre><ul><li>JS 实现原理<blockquote><p><strong>第一步：实现一级菜单</strong></p><ul><li>利用 Ajax 加载一级菜单数据，然后利用数据渲染出一级菜单。</li><li>一级菜单<code>&lt;li&gt;</code>标签身上有两个自定义属性，分别为<code>data-id</code>和<code>data-done</code></li><li>发送Ajax请求，得到数据后，构建dom，将<code>category_id</code>作为<code>li</code>标签的属性，<code>title</code>作为一级菜单的内容<ul><li><code>data-id</code>用来保存一级菜单的栏目 <code>id</code>，后面根据这个 <code>id</code> 来确定需要获取的二级菜单数据</li><li><code>data-done</code>属性值为<code>true</code>表示<code>Ajax</code>请求加载过数据，不需要再次发送请求。如果没有这个属性则表示没有加载过数据，需要发送<code>Ajax</code>请求来加载二级菜单数据</li></ul></li></ul><p><strong>第二步：实现动态显示二级菜单</strong></p><ul><li>当利用事件代理来处理，当滑动到li时，先获取<code>data-done</code>属性，如果没有这个属性，则获取 <code>li</code> 身上的<code>data-id</code>属性，来发送 <code>Ajax</code> 请求。</li><li>如果没有<code>data-done</code>属性，则说明之前发送 Ajax 请求到了数据，不需要再发送 <code>Ajax</code> 请求。</li><li>将一级菜单的<code>id</code>拼接在<code>url</code>后面，发送Ajax请求；读取数据来构建dom，<code>productImg</code>作为<code>img</code>元素的<code>src</code>，<code>productName</code>作为<code>a</code>标签的内容</li><li>发送Ajax请求后，说明已经加载过了，所以给li添加自定义属性<code>data-done=true</code><blockquote><p>注意：这两步请求是<strong>继发的</strong></p></blockquote></li></ul></blockquote></li></ul><pre><code>&gt;&lt;script type=&quot;module&quot;&gt;  // 导入模块  import ajax from &quot;./ajax.js&quot;;  // 获取DOM节点（菜单）  const menuEl = document.querySelector(&quot;.menu&quot;);  // 发送Ajax加载一级菜单  const url =    &quot;https://www.fastmock.site/mock/6ec78e345df340241e1f5043f0167833/icode/menu&quot;;  ajax(&quot;get&quot;, url)    .then((res) =&gt; &#123;      // Ajax加载成功的数据      let data = res.data;      // 拼接html      let html = &quot;&lt;ul&gt;&quot;;      // for...of遍历      for (let item of data) &#123;        html += `&lt;li data-id=$&#123;item[&quot;category_id&quot;]&#125;&gt;$&#123;item.title&#125;          &lt;div class=&quot;content&quot;&gt;              &lt;img src=&quot;./loading-svg/loading-bars.svg&quot; alt=&quot;&quot; /&gt;          &lt;/div&gt;      &lt;/li&gt;`;      &#125;      html += &quot;&lt;/ul&gt;&quot;;      menuEl.innerHTML = html;    &#125;)    // 处理鼠标滑上一级菜单，显示对应二级菜单    .then(() =&gt; &#123;      // 利用事件委托      menuEl.addEventListener(&quot;mouseover&quot;, (e) =&gt; &#123;        const target = e.target;        const tagName = target.tagName.toLowerCase();        let url =          &quot;https://www.fastmock.site/mock/6ec78e345df340241e1f5043f0167833/icode/menu/&quot;;        if (tagName === &quot;li&quot;) &#123;          // 判断li身上是的data-done是否为true，如果为true表示已经加载过了，不再发ajax请求          if (!target.dataset.done) &#123;            // 把数据做为参数传过去            let newUrl = url + `$&#123;e.target.dataset.id&#125;`;            // 发起Ajax请求            ajax(&quot;get&quot;, newUrl).then((res) =&gt; &#123;              // 添加自定义属性 data-done=true              target.dataset.done = true;              // 读取Ajax加载的数据，来构建DOM              let data = res.data;              const conEl = target.querySelector(&quot;.content&quot;);              let html = &quot;&quot;;              // for...of遍历              for (let &#123; productName, productImg &#125; of data) &#123;                html += `&lt;p&gt;                    &lt;img src=&quot;$&#123;productImg&#125;&quot; /&gt;                    &lt;a href=&quot;&quot;&gt;$&#123;productName&#125;&lt;/a&gt;                  &lt;/p&gt;`;              &#125;              conEl.innerHTML = html;            &#125;);          &#125;        &#125;      &#125;);    &#125;);&gt;&lt;/script&gt;</code></pre><h4 id="案例3：GET-请求实现搜索课程"><a href="#案例3：GET-请求实现搜索课程" class="headerlink" title="案例3：GET 请求实现搜索课程"></a>案例3：GET 请求实现搜索课程</h4><blockquote><ul><li>在<code>index.html</code>页面的表单搜索关键词跳转到表单的<code>action</code>设置的<code>url</code>链接</li><li>由于表单的<code>method</code>方式是<code>get</code>，所以在页面跳转时，搜索框里输入的关键词会自动以<code>?关键词</code>的形式被添加到新的<code>url</code>地址后面，如果关键词是中文，会自动进行编码</li><li>在新页面发送Ajax请求，关键词作为Ajax请求的url地址后缀<code>url?keyword=关键词</code></li></ul></blockquote><ul><li><code>index.html</code>页面<blockquote><ul><li>创建 form 表单，然后选择 get 方式发送请求</li></ul></blockquote></li></ul><pre><code>&lt;!--action：表单提交后，发送请求的地址,请求发送到search.html搜索页method:表示请求的方式，是以get方式发送请求--&gt;&gt;&lt;form action=&quot;./search.html&quot; method=&quot;get&quot;&gt;&gt;  &lt;input type=&quot;text&quot; name=&quot;keyword&quot; /&gt;&gt;  &lt;input type=&quot;submit&quot; value=&quot;搜索&quot; /&gt;&gt;&lt;/form&gt;</code></pre><p><strong>注：</strong></p><blockquote><ul><li>搜索框的input标签中一定要添加 name 属性，表单中的数据才能以<strong>键值对</strong>的形式自动出现在提交的地址栏中。</li><li>因为搜索按扭的内容不需要出现在地址栏中，所以不用加 name 属性</li></ul></blockquote><ul><li>新建<code>search.html</code>页面，用来显示搜索到的课程<blockquote><ul><li>先获取地址栏中传过来的<code>keyword = xxx</code>参数，然后根据这个参数，再一次发送<code>Ajax</code>请求，向后端请求数据，拿到数据，开始根据数据创建<code>DOM</code>插入到页面。</li></ul></blockquote></li></ul><pre><code>// 导入模块import ajax from &quot;./ajax.js&quot;;// 获取传递过来的keyword参数对应的值let url = window.location.search;const keyword = url.split(&quot;=&quot;)[1];// 发送Ajax请求let newUrl =  &quot;https://www.fastmock.site/mock/6ec78e345df340241e1f5043f0167833/icode/search&quot;;ajax(&quot;get&quot;, `$&#123;newUrl&#125;?keyword=$&#123;keyword&#125;`).then((res) =&gt; &#123;  console.log(res.data);  render(res.data);&#125;);&gt;//方式1：function render(data) &#123;  // 我们可以将所有内容先添加到文档碎片  const fragment = document.createDocumentFragment();  // for(let item of data)&#123;  const div = document.createElement(&quot;div&quot;);  const h3 = document.createElement(&quot;h3&quot;);  const p = document.createElement(&quot;p&quot;);  const img = document.createElement(&quot;img&quot;);&gt;  h3.innerText = data.courseName;  p.innerText = data.desc;  img.src = data.imageUrl;&gt;  div.appendChild(img);  div.appendChild(h3);  div.appendChild(p);&gt;  fragment.appendChild(div);  &#125;&gt;//方式2：function render(data) &#123;  let html = &quot;&lt;div&gt;&quot;;  for (let &#123; courseName, desc, imageUrl &#125; of data) &#123;    html += `      &lt;img src=&quot;$&#123;imageUrl&#125;&quot;/&gt;      &lt;h3&gt;$&#123;courseName&#125;      &lt;p&gt;$&#123;desc&#125;      `;  &#125;  html += &quot;&lt;/ul&gt;&quot;;  document.body.innerHTML = html;&#125;</code></pre><h3 id="九、Axios"><a href="#九、Axios" class="headerlink" title="九、Axios"></a>九、Axios</h3><ol><li><p>Axios 是什么</p><blockquote><ul><li>axios 是一个基于 <code>Promise</code> 的 HTTP 库，可以用在<strong>浏览器</strong> 和 <code>node.js</code> 中</li><li>可理解为 axios 是一个第三方 <code>Ajax</code> 库，这个库是基于 <code>Promise</code> 的</li><li>axios 的官方文档地址<a href="axios-http.com">Axios Docs</a></li></ul></blockquote></li><li><p>axios 的基本用法</p><blockquote><ul><li>axios 是一个第三方库，所以我们需要引入这个库才能使用。最简单的方式就是通过<code>&lt;script&gt;</code>标签来引入对应的 <code>axios.js </code>文件来使用。</li></ul></blockquote></li></ol><pre><code>&lt;script src=&quot;https://cdn.jsdelivr.net/npm/axios/dist/axios.min.js&quot;&gt;&lt;/script&gt;</code></pre><blockquote><ul><li>为了提高文件的加载速度，我们使用 <code>CDN</code> 加速服务，[网址] (<a href="https://www.bootcdn.cn/)%EF%BC%8C%E5%9C%A8%E6%90%9C%E7%B4%A2%E6%A1%86%E8%BE%93%E5%85%A5%60axios%60%EF%BC%8C%E6%89%BE%E5%88%B0%E5%AF%B9%E5%BA%94%E7%9A%84%E5%BC%95%E5%85%A5%E5%9C%B0%E5%9D%80%EF%BC%8C%E8%BF%9B%E5%85%A5">https://www.bootcdn.cn/)，在搜索框输入`axios`，找到对应的引入地址，进入</a></li></ul></blockquote><pre><code>&lt;script src=&quot;https://cdn.bootcdn.net/ajax/libs/axios/1.3.4/axios.min.js&quot;&gt;&lt;/script&gt;</code></pre><ul><li>axios 的基本用法<blockquote><ul><li>axios参数<ul><li>url:请求的URL</li><li>config:为可选项,请求相关的配置信息</li></ul></li></ul></blockquote></li></ul><pre><code>const p=axios(config);const p=axios(url[,config]);</code></pre><blockquote><ul><li><code>axios</code> 函数的返回值是一个 <code>Promise</code> 对象，所以可以通过<code>then()</code>方法来接受响应数据</li></ul></blockquote><pre><code>&gt;&lt;script src=&quot;https://cdn.bootcdn.net/ajax/libs/axios/1.3.4/axios.min.js&quot;&gt;&lt;/script&gt;&gt;&lt;script&gt;  // 查看axios  console.log(axios);  // 基本用法  axios(url, config).then((response) =&gt; &#123;    // response 响应相关的数据都在这个对象上  &#125;);&gt;&lt;/script&gt;</code></pre><ul><li>使用 axios 来发送 get 请求<blockquote><p>如果axios只传一个参数，这个参数是一个<code>url</code>，则默认为 get 请求，其它相关参数会采用默认配置</p></blockquote></li></ul><pre><code>const url =  &quot;https://www.fastmock.site/mock/6ec78e345df340241e1f5043f0167833/icode/test&quot;;// 发送ajax请求axios(url).then((response) =&gt; &#123;  // response 响应相关的信息都在response对象上  // 可以打印response,了解这个对象身上的相关属性和方法  console.log(response);  if (response.status === 200) &#123;    console.log(response.data.data);  &#125;&#125;);</code></pre><ol start="3"><li>config 请求配置<blockquote><p><code>config</code>为axios 创建请求时可用的配置选项，相关的配置项可能参考<a href="https://axios-http.com/zh/docs/req_config">官方地址</a></p><ul><li>以下列出第几个常用的来作为讲解</li></ul></blockquote></li></ol><pre><code>axios(&#123;  // url是用于请求的服务器URL，如果第一个参数为url，这里可以不写  url: &quot;https://www.fastmock.site/mock/6ec78e345df340241e1f5043f0167833/icode/users/list&quot;,  // 请求的方法  method: &quot;post&quot;,  // 自定义请求头  headers: &#123; &quot;Content-Type&quot;: &quot;application/json&quot; &#125;,  // 通过请求头携带的数据,主要与get方法结合  params: &#123;    num: 3,  &#125;,  //  请求体被发送的数据，主要与&#39;PUT&#39;, &#39;POST&#39;, &#39;DELETE 和 &#39;PATCH&#39; 请求方法  data: &#123;    username: &quot;admin&quot;,    password: &quot;123456&quot;,  &#125;,  // 请求超时的毫秒数,默认值 0 （永不超时）  timeout: 1000,  // 表示跨域请求时是否需要使用凭证（是否携带Cookie)  默认值false  withCredentials: false,  // 表示浏览器将要响应的数据类型，默认值 json  responseType: &quot;json&quot;,  // 浏览器专属 onUploadProgress 允许为上传处理进度事件  onUploadProgress: function (progressEvent) &#123;    // 处理原生进度事件  &#125;,  // onDownloadProgress 允许为下载处理进度事件  // 浏览器专属  onDownloadProgress: function (progressEvent) &#123;    // 处理原生进度事件  &#125;,  // `validateStatus` 定义了对于给定的 HTTP状态码是 resolve 还是 reject promise。  // 如果 `validateStatus` 返回 `true` (或者设置为 `null` 或 `undefined`)，  // 则promise 将会 resolved，否则是 rejected。  validateStatus: function (status) &#123;    return status &gt;= 200 &amp;&amp; status &lt; 300; // 默认值  &#125;,&#125;).then((res) =&gt; &#123;&#125;);</code></pre><ul><li><code>get</code> 请求</li></ul><pre><code>&gt;&lt;script src=&quot;https://cdn.bootcdn.net/ajax/libs/axios/1.3.4/axios.min.js&quot;&gt;&lt;/script&gt;&gt;&lt;script&gt;  axios(&#123;    // url是用于请求的服务器URL，如果第一个参数为url，这里可以不写    url: &quot;https://www.fastmock.site/mock/6ec78e345df340241e1f5043f0167833/icode/users/list&quot;,    // url: &quot;./bg.jpg&quot;,    // 请求的方法    method: &quot;get&quot;,    // 通过请求头携带的数据,主要与get方法结合    params: &#123;      num: 3,    &#125;,    // 请求超时的毫秒数,默认值 0 （永不超时）    timeout: 5000,    // 表示跨域请求时是否需要使用凭证（是否携带Cookie)  默认值false    withCredentials: true,    // 表示浏览器将要响应的数据类型，默认值 json    responseType: &quot;json&quot;,&gt;    // onDownloadProgress 允许为下载处理进度事件    // 浏览器专属    onDownloadProgress: function (progressEvent) &#123;      // 处理原生进度事件      const e = progressEvent.event;      if (e.lengthComputable) &#123;        console.log(&quot;当前下载量:&quot;, e.loaded);        console.log(&quot;总下载量&quot;, e.total);      &#125;    &#125;,  &#125;).then((res) =&gt; &#123;    console.log(res.data);  &#125;);&gt;&lt;/script&gt;</code></pre><ul><li>post 请求</li></ul><pre><code>&gt;&lt;script src=&quot;https://cdn.bootcdn.net/ajax/libs/axios/1.3.4/axios.min.js&quot;&gt;&lt;/script&gt;&gt;&lt;script&gt;  axios(&#123;    // url是用于请求的服务器URL，如果第一个参数为url，这里可以不写    url: &quot;https://www.fastmock.site/mock/6ec78e345df340241e1f5043f0167833/icode/users/login&quot;,    // url: &quot;./bg.jpg&quot;,    // 设置请求头，请求发送的数据类型    headers: &#123;      &quot;Content-Type&quot;: &quot;application/json&quot;,    &#125;,    // 请求的方法    method: &quot;post&quot;,    //  请求体被发送的数据，主要与&#39;PUT&#39;, &#39;POST&#39;, &#39;DELETE 和 &#39;PATCH&#39; 请求方法    data: &#123;      username: &quot;admin&quot;,      password: &quot;123456&quot;,    &#125;,    // 表示跨域请求时是否需要使用凭证（是否携带Cookie)  默认值false    withCredentials: true,    // 表示浏览器将要响应的数据类型，默认值 json    responseType: &quot;json&quot;,  &#125;).then((res) =&gt; &#123;    console.log(res.data);  &#125;);&gt;&lt;/script&gt;</code></pre><ol start="4"><li>response 响应对象<blockquote><p>当请求响应回来后，相关信息保存在 response 响应对象中，响应对象的相关信息如下</p><ul><li><a href="https://axios-http.com/zh/docs/res_schema">参考官方文档</a></li></ul></blockquote></li></ol><pre><code>&#123;  // `data` 由服务器提供的响应  data: &#123;&#125;,&gt;  // `status` 来自服务器响应的 HTTP 状态码  status: 200,&gt;  // `statusText` 来自服务器响应的 HTTP 状态信息  statusText: &#39;OK&#39;,&gt;  // `headers` 是服务器响应头  // 所有的 header 名称都是小写，而且可以使用方括号语法访问  // 例如: `response.headers[&#39;content-type&#39;]`  headers: &#123;&#125;,&gt;  // `config` 是 `axios` 请求的配置信息  config: &#123;&#125;,&gt;  // `request` 是生成此响应的请求  // 在node.js中它是最后一个ClientRequest实例 (in redirects)，  // 在浏览器中则是 XMLHttpRequest 实例  request: &#123;&#125;&#125;</code></pre><ol start="5"><li>使用别名方式请求<blockquote><p>为了方便起见，已经为所有支持的请求方法提供了别名。</p><ul><li><code>axios.request(config)</code></li><li><code>axios.get(url[, config])</code></li><li><code>axios.delete(url[, config])</code></li><li><code>axios.head(url[, config])</code></li><li><code>axios.options(url[, config])</code></li><li><code>axios.post(url[, data[, config]])</code></li><li><code>axios.put(url[, data[, config]])</code></li><li><code>axios.patch(url[, data[, config]])</code><blockquote><p>在使用别名方法时<code>url、method、data</code>这些属性都不必在配置中指定。</p></blockquote></li></ul></blockquote></li></ol><blockquote><p>axios 是别人封装好的，已经是非常成熟了，我们未来企业项目开发中也会经常用到。我们前面自己的封装的 Ajax 主要是为了学习使用，还有很多特殊情况没有考虑到，一般在实际开发中也不会真正使用。在实际开发中就使用 axios 这样成熟的库即可。</p></blockquote><pre><code>&gt;&lt;script src=&quot;https://cdn.bootcdn.net/ajax/libs/axios/1.3.4/axios.min.js&quot;&gt;&lt;/script&gt;&gt;&lt;script&gt;  axios    .post(      &quot;https://www.fastmock.site/mock/6ec78e345df340241e1f5043f0167833/icode/users/login&quot;,      &#123;        username: &quot;admin&quot;,        password: &quot;123456&quot;,      &#125;,      &#123;        headers: &#123;          &quot;Content-Type&quot;: &quot;application/json&quot;,        &#125;,        // 表示跨域请求时是否需要使用凭证（是否携带Cookie)  默认值false        // withCredentials: true,        // 表示浏览器将要响应的数据类型，默认值 json        responseType: &quot;json&quot;,      &#125;    )    .then((res) =&gt; &#123;      console.log(res.data);    &#125;);&gt;&lt;/script&gt;</code></pre><h3 id="十、Fetch"><a href="#十、Fetch" class="headerlink" title="十、Fetch"></a>十、Fetch</h3><ol><li><code>Fetch</code> 是什么<blockquote><ul><li>与<code>Ajax</code>类似，<code>Fetch</code>也是前后端通信的一种方式。<code>Fetch</code>要比<code>Ajax</code>年轻一些</li><li><code>Fetch</code>被称为下一代<code>Ajax</code>技术（用来替代<code>XMLHttpRequest</code>），内部是采用<code>Promise</code>的方式来处理数据。</li><li><code>API</code>语法简洁明了，比<code>XMLHttpRequest</code>更加简单易用</li><li>采用了模块化设计，<code>API</code>分散于多个对象中（如：<code>Response</code>对象，<code>Request</code>对象、<code>Header</code>对象）</li><li>通过数据流（<code>Stream</code>对象）处理数据，可以分块读取，有利于提高网站性能，对于大文件或者网速慢的场景极为有用。</li></ul></blockquote></li></ol><blockquote><p><strong>兼容性</strong></p><ul><li>关于兼容性也可以使用：<a href="https://caniuse.com/">查询</a><br><strong>Fetch 缺点</strong></li><li>Fetch 的<strong>兼容性</strong>没有 Ajax 好</li><li>Fetch 原生<strong>没有提供</strong> <code>abort</code> 终止请求方式、<code>timeout</code> 请求超时方式，如果需要用到这些时，需要自己来实现。</li></ul></blockquote><ol start="2"><li>Fetch 的基本用法<blockquote><p><strong>全局的</strong> fetch() 方法用于发起获取资源的请求。</p><ul><li>它返回一个 promise，这个 promise 会在请求响应成功时被 resolve，并传回 Response对象。</li><li>失败时会被 reject，并传回TypeError</li></ul></blockquote></li></ol><pre><code>// fetch 是一个全局函数，是真实存在的console.log(fetch);// ajax 是不存在的console.log(ajax);</code></pre><ul><li>语法<blockquote><ul><li>p 为Promise对象,通过then方法可以接受响应后的response对象</li><li>url  :获取资源的URL</li><li>options: 配置对象，包括所有对请求的设置</li><li>response：是一个Response类型的对象，呈现了对一次请求的响应数据</li></ul></blockquote></li></ul><pre><code>const p = fetch(url, options).then((response) =&gt; &#123;  // 处理响应回来的数据&#125;);</code></pre><ul><li>利用 fetch 发送 get 请求<blockquote><ul><li>如果fetch()只接受一个url字符串参数，则表示向该网址发送 get 请求，请求返回一个 Promise 对象</li><li>能过 Promise 的 then 方法可以得到一个 response 对象，对象的<code>status</code>属性获取返回响应的状态码，通过这个状态码可以知道响应是成功还是失败。</li><li>调用 response 对象身上的特定方法可以获取到响应回来的数据，如<code>response.json()</code>方法</li></ul></blockquote></li></ul><pre><code>// 发送Ajax请求，请求方式 getfetch(  &quot;https://www.fastmock.site/mock/6ec78e345df340241e1f5043f0167833/icode/test&quot;)  .then((res) =&gt; &#123;    // res 为response对象，res.status 返回响应的状态码    if (res.status === 200) &#123;      // res.json() 是一个异步操作 返回响应的数据（一个被解析为JSON格式的Promise对象）      return res.json();    &#125; else &#123;      // 抛出错误      throw new Error(&quot;请求错误&quot;);    &#125;  &#125;)  .then((data) =&gt; &#123;    // 拿到返回的JSON数据    console.log(data);  &#125;)  .catch((err) =&gt; &#123;    // 捕获错误信息    console.log(err);  &#125;);</code></pre><ol start="3"><li>response 对象<blockquote><p>关于 fetch 方法发起请求响应成功后，promise 对象返回的 response 对象的相关属性和方法可以查阅官方文档</p><ul><li>以下是常用到的一些属性和方法<table><thead><tr><th>属性</th><th>说明</th></tr></thead><tbody><tr><td>status</td><td>只读属性包含响应的状态代码，如成功为 200</td></tr><tr><td>body</td><td>body 是一个可读的流，<strong>只能读取一次</strong>，读过之后就不让再读了</td></tr><tr><td>bodyUsed</td><td>表示 response 对象是否读取过 body 流，默认值为 false，如果读取过就变为 true</td></tr></tbody></table></li></ul></blockquote></li></ol><table><thead><tr><th>方法</th><th>说明</th></tr></thead><tbody><tr><td>json</td><td>接收一个 Response 流，并将其读取完成。它返回一个 Promise，Promise 的解析 resolve 结果是<strong>将文本体解析为 JSON</strong></td></tr></tbody></table><pre><code>fetch(  &quot;https://www.fastmock.site/mock/6ec78e345df340241e1f5043f0167833/icode/test&quot;)  .then((res) =&gt; &#123;    if (res.status === 200) &#123;      console.log(res.bodyUsed);      console.log(res.json()); // 因为body流只能读一次，所以这里读了，后面就没法读      console.log(res.bodyUsed);      return res.json();    &#125;  &#125;)  .then((data) =&gt; &#123;    console.log(data); // 这里拿不到数据  &#125;);</code></pre><ol start="3"><li>Fecth 的参数配置<table><thead><tr><th>属性</th><th>说明</th></tr></thead><tbody><tr><td>method</td><td>请求使用的方法，如 GET、POST、PUT 等</td></tr><tr><td>body</td><td>请求的 body(请求体) 信息，GET 方法不包含 body 信息</td></tr><tr><td>headers</td><td>请求的头信息，形式为 Headers的对象或包含 ByteString值的对象字面量</td></tr><tr><td>mode</td><td>请求的模式，如 cors、no-cors 或者 same-origin；<code>cors：</code>跨域请求，且要求后端需要设置 cors 响应头；<code>no-cors：</code>允许跨域，但服务端不设置 cors 响应头，如果图片、脚本、样式；<code>same-origin</code>：同源请求，限制了不能跨域</td></tr><tr><td>credentials</td><td>请求是否携带 Cookie，有三个值：omit、same-origin、include；<code>omit：</code>缺省值，默认为该值<code>same-origin: </code>同源, 表示同域请求才发送 cookie；<code>include：</code>跨域请求中需要带有 cookie 时；与 Ajax 的 withCredentials 属性一样，设置跨域请求时是否允许携带 Cookie 等，同是后端也要做相关设置</td></tr></tbody></table></li></ol><pre><code>&gt;&lt;script&gt;  const url =    &quot;https://www.fastmock.site/mock/6ec78e345df340241e1f5043f0167833/icode/users/login&quot;;&gt;  fetch(url, &#123;    // 请求使用的方法，如 `GET`、`POST`、`PUT` 等    method: &quot;post&quot;,    // post请求体携带数据，不传递就是 null,可以是键值对、JSON、FormData    body: &quot;username=admin&amp;password=123456&quot;,    // 请求的头信息    headers: &#123;      // Form格式      &quot;Content-Type&quot;: &quot;application/x-www-form-urlencoded&quot;,      // JSON格式      // &quot;Content-Type&quot;: &quot;application/json&quot;,    &#125;,    // 请求的模式：跨域资源共享，默认值：cors 默认支持跨域    mode: &quot;cors&quot;,    // 是否携带Cookie    credentials: &quot;include&quot;,  &#125;)    .then((res) =&gt; &#123;      if (res.status === 200) &#123;        return res.json();      &#125; else &#123;        throw new Error(&quot;请求出错&quot;);      &#125;    &#125;)    .then((data) =&gt; &#123;      console.log(data);    &#125;)    .catch((err) =&gt; &#123;      console.log(err);    &#125;);&gt;&lt;/script&gt;</code></pre><h3 id="测试题"><a href="#测试题" class="headerlink" title="测试题"></a>测试题</h3><ol><li>下列选项中，描述错误的是 ？(单选)<blockquote><ul><li>A、JSON.stringify()的作用是将 JavaScript 中的对象转换为 JSON 字符串</li><li>B、JSON.stringify()方法让 localStorage&#x2F;sessionStorage 可以存储对象</li><li>C、JSON.parse()作用是将字符串转为一个对象</li><li>D、JSON.stringify()方法可以判断两个数组或对象中的值是否相等</li></ul></blockquote></li></ol><blockquote><p>答案：C</p><ul><li>C项应该是将JSON字符串转为一个对象</li><li>注意选项D，<code>JSON.stringify()</code>方法可以判断两个数组或对象中的值是否相等</li></ul></blockquote><ol start="2"><li>下列描述正确的选项是 ？<blockquote><ul><li>A、responseType 属性值为空时，不可以使用 response 属性接收</li><li>B、responseType 属性值为 json 时，不可以使用 responseText 属性接收</li><li>C、responseType 属性值为 text 时，只能使用 responseText 属性接收</li><li>D、没有设置 responseType 属性时，可以使用 responseText 或 response 属性接收<br>答案：BD<br>responseType 、esponseText、 response 属性之间的关系</li><li><code>responseType</code>：指定响应中包含的数据类型，如果没有指定，则默认值为 text 文本类型</li><li><code>response</code>用于返回响应的正文，返回的类型为<code>responseType</code>指定的类型</li><li><code>esponseText</code>用来返回响应的正文，其接受的内容只能为<strong>文本形式</strong><code>text</code><blockquote><p>所以在<strong>没有设置</strong><code>responseType</code>或者<code>responseType</code>为<code>text</code>时，用<code>esponseText、 response</code>都可以；</p></blockquote></li></ul></blockquote></li></ol>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 网络 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>网络（一）</title>
      <link href="/2024/01/18/%E7%BD%91%E7%BB%9C%EF%BC%88%E4%B8%80%EF%BC%89/"/>
      <url>/2024/01/18/%E7%BD%91%E7%BB%9C%EF%BC%88%E4%B8%80%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<span id="more"></span><h2 id="前后端数据交互、HTTP-协议"><a href="#前后端数据交互、HTTP-协议" class="headerlink" title="前后端数据交互、HTTP 协议"></a>前后端数据交互、HTTP 协议</h2><h3 id="一、前后端通信"><a href="#一、前后端通信" class="headerlink" title="一、前后端通信"></a>一、前后端通信</h3><h4 id="前后端通信是什么-？"><a href="#前后端通信是什么-？" class="headerlink" title="前后端通信是什么 ？"></a>前后端通信是什么 ？</h4><ul><li>前后端通信指：前端和后端数据交互的过程。即 <strong>浏览器和服务器</strong>之间数据交互的过程。</li></ul><p><strong>为什么需要前后端通信</strong></p><ul><li>因为，不论前端还是后端，它们彼此都离不开对方。有时前端需要后端发送过来的数据，有时后端也需要前端发送来的数据。所以，前后端通信就是前端和后端各取所需的一个过程。</li></ul><blockquote><p>后端向前端发送数据</p></blockquote><ul><li>打开任意在线网页后，如：<a href="https://www.icodingedu.com/">https://www.icodingedu.com/</a></li><li>在浏览器中按 “F12” 或 右键 检查元素，打开浏览器的开发者工具</li><li>将面板切换至 “Network” -&gt; 刷新网页，注意观察发生了什么</li></ul><p>在<strong>刷新网页</strong>的过程中，浏览器和服务器之间就完成了一次通信，也就是完成一次数据之间的交互。</p><ul><li>这里主要是后端向前端发送的数据，包括：HTML 文件、CSS、JS、图片 等，我们只要能够看到的都是后端发送过来的。因为浏览器要想展示一个网页给到用户查看，就需要当前网页相关的文件，而这些文件本身就保存在服务器中的。</li><li>当我们通过网址访问网页的时候，这时浏览器和服务器就会展开通信，浏览器向服务器请求网页相关文件，服务器就会将浏览器请求的东西发送给它，然后就会通过这些文件进行渲染和展示网页了。</li></ul><blockquote><p>前端向后端发送数据</p></blockquote><ul><li>典型应用场景，用户登录注册、站内搜索、表单提交等</li><li>用户登录，前端向后端发送数据：<ul><li>用户输入用户名、密码，点击 “登录” 后，数据就会被发送到后端；</li><li>后端收到数据后，就会判断用户名、密码是否正确，然后将判断结果告诉前端；</li><li>前端拿到返回的结果后，就可以进一步操作了，比如：跳转到登录前的页面。</li></ul></li></ul><blockquote><p>前后端通信的过程</p></blockquote><ul><li>首先我们需要明白，地球不是围绕着某一个人转的。同理 服务器也不是围绕着某一个浏览器来转的，它可以服务相当多的浏览器。</li><li>也就是说浏览器和服务器通信时，<strong>一般情况下都是浏览器主动联系服务器</strong>。如：一般都是你主动打电话给 110 报警，没见过 110 主动打电话给你来接警的，是一个道理。</li><li>所以，在服务器和浏览器之前通信的时候，是有一个主动和被动的关系。如下图所示</li><li>需要通信时，浏览器就会<strong>主动发送一个请求</strong>给到服务器，如果有数据也会在请求中把数据携带上</li><li>服务器在接收到请求后，会<strong>按照请求给出响应</strong>（即：回应浏览器的请求），如果服务端有数据也会在随着响应一起发送到浏览器端</li><li>前后端通信是在 “请求 - 响应” 中完成的<img src="前后端通信过程.png"></li></ul><h4 id="基础概念的理解"><a href="#基础概念的理解" class="headerlink" title="基础概念的理解"></a>基础概念的理解</h4><ul><li>前端：浏览器端</li><li>客户端：只要能和服务器通信的就叫客户端<ul><li>如：命令行工具（客户端），输入 <code>curl https://www.icodingedu.com/</code>；包括我们日常，安装的很多 桌面端软件，基本都属于 客户端</li></ul></li><li>后端：服务器端</li></ul><h3 id="二、前后端的通信方式"><a href="#二、前后端的通信方式" class="headerlink" title="二、前后端的通信方式"></a>二、前后端的通信方式</h3><h4 id="使用浏览器访问网页"><a href="#使用浏览器访问网页" class="headerlink" title="使用浏览器访问网页"></a>使用浏览器访问网页</h4><ul><li>在浏览器地址栏输入网址，按下回车</li><li>在打开网页的过程中，浏览器和服务器之间就完成了一次通信</li></ul><h4 id="解析-HTML-标签"><a href="#解析-HTML-标签" class="headerlink" title="解析 HTML 标签"></a>解析 HTML 标签</h4><ul><li><p>浏览器在解析 <code>HTML</code> 标签的时候，遇到一些特殊的标签，<strong>会再次</strong>向服务器发送请求。</p></li><li><p>如下标签：</p><ul><li><code>&lt;link&gt;</code> 标签</li><li><code>&lt;img&gt;</code> 标签</li><li><code>&lt;script&gt; &lt;/script&gt;</code> 标签 ，如 ：使用 JSONP 跨域，就会用到 script 标签</li><li><code>&lt;iframe&gt;</code> 标签</li></ul></li><li><p>还有一些标签，浏览器解析的时候，不会向服务器发送请求，<strong>但用户可以使用它们向服务器发送请求</strong>。如下</p><ul><li><code>&lt;a href=&quot;https://www.baidu.com/&quot;&gt;&lt;/a&gt;</code> 标签，点击 a 标签时，就会向 百度的服务器发送请求</li><li><code>&lt;form&gt;</code>标签，<code>form</code>表单提交时，就会向服务器发送请求</li></ul></li></ul><h4 id="Ajax-和-Fetch"><a href="#Ajax-和-Fetch" class="headerlink" title="Ajax 和 Fetch"></a>Ajax 和 Fetch</h4><blockquote><p>它们也是前后端的通信方式之一</p></blockquote><ul><li>与 Ajax 类似，Fetch 也是前后端通信的一种方式。Fetch 要比 Ajax 年轻一些</li><li>Fetch 是 Ajax（XMLHttpRequest）的一种替代方案，它是基于 Promise 的</li></ul><h4 id="Fetch-缺点"><a href="#Fetch-缺点" class="headerlink" title="Fetch 缺点"></a>Fetch 缺点</h4><ul><li>Fetch 的兼容性没有 Ajax 好</li><li>Fetch 原生没有提供 abort 终止请求方式、timeout 请求超时方式，如果需要用到这些时，需要自己来实现。</li></ul><h3 id="三、HTTP-协议"><a href="#三、HTTP-协议" class="headerlink" title="三、HTTP 协议"></a>三、HTTP 协议</h3><h4 id="HTTP-是什么-？"><a href="#HTTP-是什么-？" class="headerlink" title="HTTP 是什么 ？"></a>HTTP 是什么 ？</h4><blockquote><p><code>HTTP</code> 全称：<code>Hyper Text Transfer Protocol</code><strong>超文本传输协议</strong>（HTTP 是这几个英文单词的首字母）</p></blockquote><ul><li><code>HTML</code>是 <strong>超文本标记语言</strong></li><li><strong>超文本：</strong> 原先一个个单一的文本，通过超链接将其联系起来。由原先的单一的文本变成了可无限延伸、扩展的超级文本，立体文本。</li><li><strong>传输协议：</strong> 传输，如将请求传输过去、响应传输回来 等。协议即在传输的过程中需要遵守的规范</li></ul><p>我们网页中的 HTML、JS、CSS、图片、字体、音频、视频 等等文件，都是通过 HTTP （超文本传输协议）在服务器和浏览器之间传输</p><ul><li>每一次前后端通信，前端需要主动向后端发出请求，后端接收到前端的请求后，可以给出响应</li><li>因此，HTTP 是一个<strong>请求、响应协议</strong></li></ul><h4 id="HTTP-请求响应的过程"><a href="#HTTP-请求响应的过程" class="headerlink" title="HTTP 请求响应的过程"></a>HTTP 请求响应的过程</h4><blockquote><p>在浏览器的地址栏中输入网址，回车一下后，发生了什么 ？</p></blockquote><ul><li><p>HTTP 请求响应的简单过程：</p><img src="http请求响应的简单过程.png"></li><li><p>同时，也可以打开浏览器的控制台 “Network” 也可实时查看到整个过程。</p></li></ul><blockquote><p><strong>概括说：</strong></p></blockquote><ul><li>浏览器向服务器发送了 HTTP 请求，服务器端又向浏览器发送了 HTTP 响应，总体就这一个过程。详细描述如下：<blockquote><ul><li>当我们在浏览器中访问网页时，浏览器<strong>先到自己的缓存中查询</strong>，如有缓存就不必向服务器发送请求，直接从缓存中读取。</li><li>但，有时候即便浏览器找到了缓存，它还需要<strong>考虑是否过期</strong>，这时就需要向服务器发送一个请求来询问缓存是否过期，服务器发送响应是否能用。这个过程就会涉及到浏览器和服务器之间的通信。具体是如何通讯的呢 ？</li><li>在浏览器地址栏：输入网址<code>https://www.arryblog.com/</code> 是无法直接找到 服务器在哪里的。因为服务器是有一个<strong>位置信息（即：IP 地址）</strong>浏览器会先在内部通过网址查询对应的 IP，找到了 IP ，直接使用 IP（类似于门牌号） 和服务器建立链接 ，这个链接叫** TCP 连接**</li><li>HTTP 是建立在 TCP 连接基础之上的，连接建立之后，就相当于 浏览器和服务器之间就开通了一条通路（上图蓝色部分），浏览器的请求和服务器的响应都在这个通路中完成。</li></ul></blockquote></li></ul><blockquote><p>如果在浏览器中能查到网址对应的 IP，说明之前有访问过，浏览器内部会保存一份。</p><ul><li>如果之前没有访问过，浏览器也就没有记录过，本地就查不到，这时就需要到 <strong>DNS 域名解析服务器</strong>中去查询 <code>IP</code> （这个远程服务器会比较慢），查到之后会先在浏览器中存储一份，下次再访问时，就会在浏览器中查到对应的 IP 了，这样速度就会非常快。</li><li>这也是为什么，第一次打开一个网站时，会非常慢。第二次打开时就会快很多。</li><li>其中原因之一，就是我们再次访问网站时，就不用再次去 DNS 域名解析服务器中去查询 IP 了。而是直接用本地浏览器中的</li></ul></blockquote><h4 id="HTTP-报文"><a href="#HTTP-报文" class="headerlink" title="HTTP 报文"></a>HTTP 报文</h4><blockquote><p>HTTP 报文是什么 ？</p></blockquote><ul><li>浏览器向服务器发送请求时，请求本身就是信息，叫<strong>请求报文</strong></li><li>服务器向浏览器发送响应时，传输的信息，叫<strong>响应报文</strong></li></ul><p>因此，我们讲的 HTTP 报文就是：请求报文 和 响应报文<br><img src="http报文.png"></p><blockquote><p>HTTP 报文格式</p></blockquote><ul><li>请求：请求头（起始行 + 首部），请求体</li><li>响应：响应头（起始行 + 首部），响应体</li></ul><p><strong>注：</strong></p><ul><li><p><code>GET</code> 请求，没有请求体，数据通过请求头携带</p></li><li><p><code>POST</code> 请求，有请求体，数据通过请求体携带；它既有请求头也有请求体，都可以携带数据，但在实际开发中，一般使用请求体携带数据</p></li><li><p>在浏览器中访问网页，点开 ”Network“ 查看</p><img src="http报文格式.png"></li></ul><h3 id="四、HTTP-方法"><a href="#四、HTTP-方法" class="headerlink" title="四、HTTP 方法"></a>四、HTTP 方法</h3><ul><li><a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Methods">官方文档</a></li></ul><h4 id="常用的-HTTP-方法"><a href="#常用的-HTTP-方法" class="headerlink" title="常用的 HTTP 方法"></a>常用的 HTTP 方法</h4><blockquote><p>浏览器发送请求时采用的方法<strong>和响应无关</strong></p><ul><li>常见的方法有：GET、POST、PUT、DELETE，用来定义对于资源采取什么样的操作的，有各自的语义</li></ul></blockquote><h4 id="HTTP-方法的语义"><a href="#HTTP-方法的语义" class="headerlink" title="HTTP 方法的语义"></a>HTTP 方法的语义</h4><blockquote><p>常用的这 4 种方法，行业中一般称之为”CRUD”增删改查</p></blockquote><ul><li><code>CRUD</code>：增加<code>create</code>、查询<code>read/retrieve</code>、修改<code>update</code>、删除<code>delete</code></li></ul><table><thead><tr><th>HTTP 方法</th><th>描述</th></tr></thead><tbody><tr><td>GET</td><td>获取数据：获取资源（文件），多用于获取或查询数据 等</td></tr><tr><td>POST</td><td>创建数据：多用于增加数据、注册 等</td></tr><tr><td>PUT</td><td>更新数据：多用于 修改信息，修改密码 等</td></tr><tr><td>DELETE</td><td>删除数据：多用于删除数据，删除商品信息 … 等</td></tr></tbody></table><ul><li>这些方法虽然有各自的语义，但并不是强制性的</li></ul><h4 id="RESTful-接口设计"><a href="#RESTful-接口设计" class="headerlink" title="RESTful 接口设计"></a>RESTful 接口设计</h4><blockquote><p><code>RESTful</code>是一种接口设计风格，充分利用<code>HTTP</code>方法的语义</p><ul><li>如：我们需要对用户信息，进行增删改查，如何设计接口</li></ul></blockquote><ul><li>常规方式</li></ul><table><thead><tr><th>需求</th><th>HTTP 方法</th><th>接口地址</th></tr></thead><tbody><tr><td>根据 ID 获取个人信息</td><td>GET</td><td><a href="https://hermiablog.com/api/getUser?id=1">https://hermiablog.com/api/getUser?id=1</a></td></tr><tr><td>注册新用户</td><td>POST</td><td><a href="https://hermiablog.com/api/addUser">https://hermiablog.com/api/addUser</a></td></tr><tr><td>修改用户信息</td><td>POST</td><td><a href="https://hermiablog.com/api/modifyUser">https://hermiablog.com/api/modifyUser</a></td></tr><tr><td>删除一个用户信息</td><td>POST</td><td><a href="https://hermiablog.com/api/deleteUser">https://hermiablog.com/api/deleteUser</a></td></tr></tbody></table><p><strong>注：</strong></p><ul><li><p>以上方式正常使用没有问题，但会显得非常麻烦，需要通过名称来进行区分具体的功能</p></li><li><p>使用 <code>RESTful</code> 接口设计风格</p></li></ul><table><thead><tr><th>需求</th><th><code>HTTP</code> 方法</th><th><code>RESTful</code> 风格接口地址</th></tr></thead><tbody><tr><td>根据 ID 获取个人信息</td><td>GET</td><td><a href="https://icoding.com/api/user?id=1">https://icoding.com/api/user?id=1</a></td></tr><tr><td>注册新用户</td><td>POST</td><td><a href="https://icoding.com/api/user">https://icoding.com/api/user</a></td></tr><tr><td>修改用户信息</td><td>PUT</td><td><a href="https://icoding.com/api/user">https://icoding.com/api/user</a></td></tr><tr><td>删除一个用户信息</td><td>DELETE</td><td><a href="https://icoding.com/api/user">https://icoding.com/api/user</a></td></tr></tbody></table><h4 id="GET-和-POST-方法的对比"><a href="#GET-和-POST-方法的对比" class="headerlink" title="GET 和 POST 方法的对比"></a>GET 和 POST 方法的对比</h4><ul><li>语义不同</li></ul><table><thead><tr><th>HTTP方法</th><th>描述</th></tr></thead><tbody><tr><td>GET</td><td>获取数据</td></tr><tr><td>POST</td><td>创建数据</td></tr></tbody></table><ul><li>发送数据不同</li></ul><table><thead><tr><th>HTTP 方法</th><th>描述</th></tr></thead><tbody><tr><td>GET</td><td>通过地址在请求头中携带数据；能携带的数据量和地址的长度有关系，一般最多就<strong>几 K</strong></td></tr><tr><td>POST</td><td>既可以通过地址在请求头中携带数据（一般实际开发中不会这么做），也可以通过请求体携带数据；能携带的数据量理论上是<strong>无限的</strong></td></tr><tr><td>结论</td><td>携带少量数据，可以使用 GET 请求，大量的数据可以使用 POST 请求</td></tr></tbody></table><ul><li>缓存不同</li></ul><table><thead><tr><th>HTTP 方法</th><th>描述</th></tr></thead><tbody><tr><td>GET</td><td>可以被缓存；因为，GET 请求连同它请求的数据都会被浏览器缓存；如：我们访问过的网站，就会被浏览器记住（输入前几个字母就会自动补全）</td></tr><tr><td>POST</td><td>不会被缓存；因为 POST 请求的数据一般不通过地址来发送请求，而是通过请求体来发送，所以不会被缓存</td></tr></tbody></table><ul><li>安全性<ul><li>GET 和 POST <strong>本质上都不安全</strong>，但为什么很多人说 POST 会比 GET 更安全呢 ？</li><li>因为 GET 是在浏览器的地址栏中<strong>明文显示</strong>传输的（也可以在历史记录找到对应的信息，如果是密码的话），而 POST 是通过请求体发送的，我们看不到。</li></ul></li></ul><p><strong>注：</strong></p><ul><li>发送密码或其他敏感信息时不要使用 GET，主要是避免直接<strong>被他人窥屏或通过历史记录</strong>找到你的密码，从这个点来说 POST 确实会比 GET 安全一点。</li></ul><h4 id="HTTP-状态码"><a href="#HTTP-状态码" class="headerlink" title="HTTP 状态码"></a>HTTP 状态码</h4><ul><li>完整 HTTP 响应状态码，详细可查看<a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Status">官方文档</a>解读</li></ul><p><strong>HTTP 状态码是什么 ？</strong></p><ul><li>HTTP 状态码是定义服务器对请求的处理结果，是由服务器返回的</li><li>HTTP 状态码的语义（常见状态码）</li></ul><blockquote><p>100 ~ 199 状态码</p></blockquote><ul><li>表示消息：代表请求已被接受，需要继续处理。</li><li>如：使用 <code>websocket</code> 会经常看到</li><li>我们经常使用的 <code>Live Server</code> 插件保存代码会自动刷新页面，就是使用 <code>websocket</code> 来实现的<img src="liver-Server状态码.png"></li></ul><blockquote><p>200 ~ 299 状态码</p></blockquote><ul><li>表示成功响应</li></ul><blockquote><p>300 ~ 399 状态码</p></blockquote><ul><li>表示重定向</li><li>如：输入 <code>https://hermiablog.com</code> 跳转至 <code>https://www.hermiablog.com</code> 发生了 <strong>301 永久重定向</strong></li><li>重定向的位置一般都会被浏览器缓存，下次输入会自动跳转，除非我们手动把浏览器缓存清空，否则会默认跳转过去。<img src="301重定向状态码.png"></li></ul><blockquote><p><strong>我们常见的企业级 301 跳转解决方案</strong></p></blockquote><ul><li>http：no-www 跳转到 www</li><li>http：www 跳转到 no-www</li><li>https：no-www 跳转到 www</li><li>https：www 跳转到 no-www</li><li>包括一些废弃的网址或更新后的地址，防止用户访问和搜索引擎爬虫爬取时，会报错。造成不好的用户体验 和 不利于 SEO 搜索引擎优化等，我们就会经常使用 301 永久重定向来处理。</li></ul><blockquote><p><strong>注：</strong></p></blockquote><ul><li>301 是永久重定向，需要谨慎使用，一旦设置 301 跳转的地址，就会被用户端的浏览器缓存了，我们是没有办法控制用户的浏览器来清空他的浏览器缓存，如果一旦服务端发生了新的修改，可能会跳转错误。</li><li>除非，我们本身就需要强制跳转的，如上边提到的 企业级 301 跳转解决方案，其他的慎用。</li><li><code>302</code> 临时性的缓存，每一次都会向服务器发送一次请求，确认下会往哪里跳转。</li><li><code>304</code> 表示没有修改，如：我们本地浏览器中有一份缓存，但还不敢用，怕它过期了，因此浏览器就会向服务器发送一次请求，确认是否过期。如果服务器返回的是 <code>304</code> 表示没有过期，即可直接使用，就不用再发送新的响应。表示还是使用本地的缓存，没有被修改。</li></ul><blockquote><p>400 ~ 499 状态码</p></blockquote><ul><li>表示客户端错误响应，一般会发生在<strong>前端</strong></li><li>常见的 404 Not Found 找不到请求的资源</li></ul><blockquote><p>500 ~ 599 状态码</p></blockquote><ul><li>表示服务端错误响应</li><li>调用接口时，经常会遇到的错误 <code>500 Internal Server Error</code> 服务器遇到了不知道如何处理的情况。当我们看到 <code>500 ~ 599</code> 之间状态码 一般都是<strong>服务端的错误</strong>，这是就需要跟后端的同同事沟通下，找到具体的问题所在</li></ul><h3 id="五、测试题"><a href="#五、测试题" class="headerlink" title="五、测试题"></a>五、测试题</h3><blockquote><p>关于 GET 请求 和 POST 请求，描述正确的是 ？(多选)</p><ul><li>A、POST 请求主要通过请求体携带数据，不能通过请求头携带</li><li>B、GET 请求，可以在通过代码 <code>xhr.send(&#39;sex=female&#39;)</code>，成功的发送数据</li><li>C、POST 请求可以通过<code>xhr.send(username=$&#123;encodeURIComponent(&#39;icoding)&#125;);</code>的形式发送数据。</li><li>D、GET 请求不能通过请求体携带数据，但是可以通过请求头携带数据</li></ul></blockquote><blockquote><p>正确答案：C D</p></blockquote><ul><li>答案解析：该题考察 GET 请求与 POST 请求的区别</li></ul><p><strong>POST 请求</strong></p><ul><li>POST 请求，既可以通过请求体携带数据、又可以通过请求头携带数据，A 说法错误。</li><li>POST 请求可以通过<code>xhr.send(username=$&#123;encodeURIComponent(&#39;icoding&#39;)&#125;);</code>的形式发送数据，C 说法正确。</li></ul><p><strong>GET 请求</strong></p><ul><li>GET 请求不能通过请求体携带数据，但是可以通过请求头携带数据，D 选项描述正确。</li><li><code>send</code> 方法发送的数据，<strong>是通过请求体携带的</strong>，因此在 <code>get 请求中，书写</code>xhr.send(‘sex&#x3D;female’)&#96;这句代码，无法成功发送数据，B 说法错误</li></ul><h2 id="本地存储"><a href="#本地存储" class="headerlink" title="本地存储"></a>本地存储</h2><h3 id="一、Cookie-简介"><a href="#一、Cookie-简介" class="headerlink" title="一、Cookie 简介"></a>一、<code>Cookie</code> 简介</h3><ol><li><code>Cookie</code> 是什么<blockquote><p><code>Cookie</code> 的全称是 <code>HTTP Cookie</code> ，简称 <code>Cookie</code></p><ul><li>它是<strong>浏览器存储数据</strong>的一种方式，因为存储在用户本地，而不是存储在服务器上，属于本地存储，一般会自动随着浏览器每次请求发送到服务器端。</li></ul></blockquote></li></ol><blockquote><p>在 <code>MDN</code> 官网上的定义如下：</p><ul><li><code>HTTP Cookie</code>（也叫<code>Web Cookie</code>或浏览器<code>Cookie</code>）是<strong>服务器发送到用户浏览器并保存在本地的一小块数据</strong>。浏览器会存储 cookie 并在下次向同一服务器再发起请求时携带并发送到服务器上。通常，它用于告知服务端两个请求是否来自同一浏览器——如保持用户的登录状态。Cookie 使基于<strong>无状态</strong>的 HTTP 协议记录稳定的状态信息成为了可能。<blockquote><p><code>MDN</code>官网上的定义更多是站在<strong>后端</strong>的角度来理解 <code>Cookie</code>，当我们在课程最后讲解后端是如何创建 Cookie 时再来理解。</p></blockquote></li></ul></blockquote><ol start="2"><li>在浏览器中操作 Cookie<blockquote><p>找到浏览器开发者工具中，打开 <code>Application</code></p></blockquote></li></ol><ul><li><p>手动添加浏览器的 <code>Cookie</code> 信息</p><img src="在浏览器操作cookie-1.png"></li><li><p>观察</p><blockquote><p>添加完成浏览器本地的 Cookie 后，再次刷新当前网页，这时就会向服务器端发送请求。</p><ul><li>观察 Cookie 是否会随着请求一起发送到服务器端 ，查看开发者工具中的 <code>“Network”</code><img src="在浏览器操作cookie-2.png"></li></ul></blockquote></li></ul><blockquote><p><strong>注：</strong></p><ul><li>以上我们可以看到，<strong>在请求头中</strong>有一个字段 Cookie 后边就是我们之前添加的值。</li><li>当看到请求头中携带的 Cookie 时，说明它确实发送给了服务器端。</li></ul></blockquote><ul><li>获取 Cookie <blockquote><ul><li>在控制台输入：<code>document.cookie;</code></li><li>即 获取到的就是 “名值对” 的形式<img src="在浏览器操作cookie-3.png"></li></ul></blockquote></li></ul><ol start="3"><li>Cookie 的主要作用<blockquote><p>Cookie 主要用于以下三个方面：</p><ul><li>会话状态管理<ul><li>如用户登录状态、购物车、游戏分数或其它需要记录的信息</li></ul></li><li>个性化设置<ul><li>如用户自定义设置、主题和其他设置</li></ul></li><li>浏览器行为跟踪<ul><li>如跟踪分析用户行为等</li></ul></li></ul></blockquote></li></ol><h3 id="二、Cookie-的基本用法"><a href="#二、Cookie-的基本用法" class="headerlink" title="二、Cookie 的基本用法"></a>二、Cookie 的基本用法</h3><blockquote><p>这里我们主要学习浏览器端利用 <code>JS</code> 来操作 Cookie</p><ul><li>即<code>JavaScript</code>写入<code>Cookie</code>和读取<code>Cookie</code></li></ul></blockquote><ol><li>写入 Cookie</li></ol><ul><li>写入 Cookie 语法</li></ul><pre><code>document.cookie = &quot;键=值&quot;;</code></pre><ul><li>在浏览器中写入Cookie</li></ul><pre><code>//写入Cookieducument.cookie = &quot;username=icoding&quot;;document.cookie = &quot;sex=male&quot;;document.cookie = &quot;age=18&quot;;</code></pre><blockquote><ul><li>注意：设置多个<code>Cookie</code>时，只能通过多次调用<code>document.cookie = &#39;键=值” </code>的方式逐个添加，无法批量添加</li></ul></blockquote><ol start="2"><li>读取 Cookie<blockquote><p>读取 Cookie 的值是一个<strong>由名值对构成的字符串</strong>，每个名值对之间由<code>; </code>（一个分号 + 一个空格）隔开</p></blockquote></li></ol><pre><code>// 读取 Cookieconsole.log(document.cookie); // username=icoding; sex=male; age=18</code></pre><blockquote><ul><li>以上<code>document.cookie</code>读取出来的是<strong>全部的 <code>Cookie</code></strong> ，不能通过特定的名称来读取特定的值，只能一次性全部读取出来。</li></ul></blockquote><blockquote><p>那么，如何根据具体的名称来读取具体的值呢 ？</p><ul><li>原生的 Cookie 是没有这样方法的，需要我们自己去封装（后边会深入讲解）</li></ul></blockquote><h3 id="三、Cookie-的属性"><a href="#三、Cookie-的属性" class="headerlink" title="三、Cookie 的属性"></a>三、Cookie 的属性</h3><ol><li><code>Cookie</code> 的名称 <code>Name</code> 和 值 <code>Value</code><blockquote><p><code>Name</code> 和 <code>Value</code> 是最重要的两个属性，创建 <code>Cookie</code> 时<strong>必须填写</strong>，其他属性可以使用默认值</p><p><strong><code>Cookie</code> 的名称或值如果包含非英文字母</strong></p><ul><li>写入时需要使用<code>encodeURIComponent()</code>编码</li><li>读取时使用<code>decodeURIComponent()</code>解码<blockquote><p>一般名称使用英文字母，不要用中文。值可以用中文，但一定需要编码</p></blockquote></li></ul></blockquote></li></ol><pre><code>// 名称和值 都是 英文document.cookie = &quot;username=icoding&quot;;// 名称为英文，值为中文document.cookie = `username=$&#123;encodeURIComponent(&quot;艾编程&quot;)&#125;`;// 名称和值 都是 中文document.cookie = `$&#123;encodeURIComponent(&quot;用户名&quot;)&#125;=$&#123;encodeURIComponent(  &quot;艾编程&quot;)&#125;`;&gt;// 读取Cookie，并解码const cookie = decodeURIComponent(document.cookie);console.log(cookie); // 用户名=艾编程; username=艾编程</code></pre><blockquote><blockquote><p>之所以使用<code> encodeURIComponent()</code> 方法进行编码，因为 <code>cookie</code> 在前端存储时有中文没问题。一旦传递到后端就可能获取不到值了。</p></blockquote></blockquote><ol start="2"><li><code>expires</code> 和 <code>max-age</code> 属性<blockquote><ul><li>expires 和 max-age属性都可以设置 Cookie 的<strong>失效期</strong>，Cookie 的失效（到期）时间可以理解为 Cookie 生命的倒计时。</li><li>如果 Cookie <strong>没有设置</strong>失效时间，这样的 Cookie 称为：“会话 Cookie”，只要关闭浏览器，Cookie 就会被浏览器清除（<strong>注意是关闭浏览器，不是单个标签页</strong>）。</li><li>如果设置了对应的失效时间，只有到时间后，才会被浏览器清除。</li></ul></blockquote></li></ol><ul><li>不设置失效时间的会话<code>Cookie</code><blockquote><ul><li>会话<code>cookie</code>的属性值是<code>Session</code></li><li>只要关闭浏览器，<code>Cookie</code>消失</li></ul></blockquote></li></ul><pre><code>document.cookie = &quot;username=icoding&quot;;</code></pre><ul><li>如果 Cookie 需要长时间存储，可以设置<code>expires</code>或<code>max-age</code> 属性<table><thead><tr><th>属性</th><th>说明</th></tr></thead><tbody><tr><td>expires</td><td>设置具体的过期时间，值为<code>Date</code>类型</td></tr><tr><td>max-age</td><td>值为数字，表示当前时间<code>+</code>多少秒后过期，单位是秒</td></tr></tbody></table></li></ul><blockquote><ul><li>使用<code>expires</code>需要<code>new Date()</code></li><li>键值对之间要间隔<code>;+空格</code></li><li>此时属性值就是到期时间</li></ul></blockquote><pre><code>// expires 过期时间   值为 Date 类型document.cookie = `username=icoding; expires=$&#123;new Date(&quot;2023-3-22 00:00:00&quot;)&#125;`;// max-age 表示多少秒后过期，20秒document.cookie = `password=12345; max-age=20`;// 需要cookie存储一个月，按 30天计算，如下document.cookie = `age=33; max-age=$&#123;30 * 24 * 3600&#125;`;</code></pre><img src="设置到期时间.png"><ol start="3"><li>删除 Cookie<blockquote><ul><li>如果要删除一个 Cookie，我们只需要设置他的失效期，让他马上失效就好。</li><li>如果 <code>max-age</code> 的值是<code>0</code>或负数，则 Cookie 就会失效，从浏览器中被删除</li><li>如果 <code>expires</code> 的时间小于当前时间，则 Cookie 就会失效，从浏览器中被删除</li></ul></blockquote></li></ol><pre><code>// expires 过期时间   值为 Date 类型document.cookie = `username=icoding; expires=$&#123;new Date(&quot;2023-3-22 00:00:00&quot;)&#125;`;// 2023-2-22 小于当前时间，当前时间 2023-2-23document.cookie = `username=icoding; expires=$&#123;new Date(&quot;2023-2-22 00:00:00&quot;)&#125;`;&gt;//  max-age属性，需要cookie存储一1天document.cookie = `age=33; max-age=$&#123;24 * 3600 * 30&#125;`;// max-age=-1或0  表示删除cookiedocument.cookie = &quot;age=33;max-age=-1&quot;;</code></pre><ol start="4"><li><code>Domain</code> 属性<blockquote><p>Domain 属性指定了哪些域名可以访问该 Cookie。如果 Domain 省略未写，其默认为当前域名</p><ul><li>通过 JS 添加 domain 属性，其 domain 值只能是<strong>当前域或父域</strong></li><li>使用 JS 也只能<strong>读写当前域 或 父域</strong>的 Cookie ，无法读写其他域的 Cookie</li></ul><p><strong>当前域和父域的解读</strong></p><ul><li>当我们访问小米的 <code>PC</code> 端网站 <code>www.mi.com</code> 或 移动端 <code>m.mi.com</code> 网站时</li><li>当前域：<code>www.mi.com</code>和 <code>m.mi.com</code> 表示当前访问的域名，为当前域</li><li>父域：<code>.mi.com</code> 也就是上面<strong>两个域名共有的域</strong>，称为两者的父域<blockquote><p>注意：</p></blockquote></li><li>在子域添加<code>domain</code>为子域的cookie，另一个子域不能访问到该cookie</li><li>在子域添加<code>domain</code>为父域的cookie，另一个子域可以访问到该cookie</li></ul></blockquote></li></ol><pre><code>//在子域 www.mi.com，添加以下cookie，另一个子域m.mi.com不能访问到该cookiedocument.cookie=`username=12345; domain=&quot;www.mi.com&quot;`&gt;//在子域www.mi.com，添加以下cookie，子域m.mi.com可以访问到该cookiedocument.cookie=`sex=888; domain=&quot;.mi.com&quot;`</code></pre><blockquote><ul><li>所以，把<code>domain</code>属性设置为父域，可以实现跨域</li></ul></blockquote><ol start="5"><li>Path 路径<blockquote><p><code>Path</code>属性指定了一个<code>URL</code>路径，限定了访问<code>Cookie</code>的范围（同一域名下）<br>如果 <code>path</code> 省略未写，其值默认为当前路径（当前文件所在文件夹路径）</p><ul><li>使用 JS 只能读写<strong>当前路径</strong>和<strong>上级路径</strong>的<code>Cookie</code>，无法读写下级路径的<code>Cookie</code></li><li>同时在当前路径中，<code>path</code>只能设置当前或上级路径，不能设置成下级路径</li></ul></blockquote></li></ol><ul><li>创建以下文件目录结构<img src="path目录结构.png"></li></ul><pre><code>// docs/doc.htmldocument.cookie = `doc=&#39;doc123&#39;; max-age=$&#123;24 * 3600&#125;; path=/docs`;// 上面代码等同于下面代码// document.cookie = `doc=&#39;doc123&#39;; max-age=$&#123;24 * 3600&#125;;`;console.log(document.cookie); // doc=&#39;doc123&#39;&gt;// docs/web/web.htmldocument.cookie = `web=&#39;web123&#39;; max-age=$&#123;24 * 3600&#125;; path=/docs/web `;console.log(document.cookie); // web=&#39;web123&#39;; doc=&#39;doc123&#39;&gt;// docs/web/http/http.htmldocument.cookie = `http=&#39;http123&#39;;max-age=$&#123;24 * 3600&#125;; path=/docs/web/http `;console.log(document.cookie); // http=&#39;http123&#39;; web=&#39;web123&#39;; doc=&#39;doc123&#39;</code></pre><blockquote><p><strong>注：</strong></p><ul><li><code>/</code>表示<code>http://www.xxx.com/</code>以下目录都可以访问这个 Cookie，但以上都不行</li><li><code>/docs</code>表示<code>http://ww.xxx.com/docs</code>以下目录都可以访问这个 Cookie，但以上都不行</li><li><code>/docs/web</code>表示<code>http://ww.xxx.com/docs/web</code>以下目录都可以访问这个 Cookie，但以上都不行</li></ul></blockquote><blockquote><ul><li>在当前路径中，path 只能设置当前或上级路径，不能设置成下级路径</li></ul></blockquote><pre><code>// 以下代码属于 /docs/doc.html页面&gt;// 错误写法 因为path不能指向当前路径的下级路径document.cookie = `doc=&#39;doc123&#39;; path=/doc/web`;&gt;// 正确写法document.cookie = `doc=&#39;doc1&#39;; path=/docs`;document.cookie = `doc=&#39;doc123&#39;; path=/`;</code></pre><ol start="6"><li>判断是否为同一 Cookie<blockquote><p>通过上面的学习，我们知道，只有当<code>Name、Domain、Path</code> 这<strong>三个字段都相同时</strong>，才是同一个<code>Cookie</code></p></blockquote></li></ol><pre><code>// 以下为相同Cookiedocument.cookie = `doc=&#39;doc1&#39;; path=/docs`;document.cookie = &quot;doc=abc&quot;; // 其path默认值为 /docs&gt;// 以下都为不同Cookiedocument.cookie = `doc=&#39;doc123&#39;; path=/docs`;document.cookie = `doc=&#39;doc123&#39;; path=/`;</code></pre><blockquote><ul><li>在<code>docs</code>目录里，<code>/</code>和<code>/docs</code>不同</li></ul></blockquote><ol start="7"><li>HttpOnly 属性<blockquote><ul><li>设置了<code>HttpOnly</code>属性的<code>Cookie</code><strong>不能通过</strong><code>JS</code> 去访问，禁止 JS 访问也是为了安全性考虑。</li><li>HttpOnly 属性不能通过 JS 来设置，<strong>只能通过服务端</strong>来设置。如果我们想要看到效果，可以手动在浏览器的控制台勾选。<img src="httponly.png"></li></ul></blockquote></li></ol><blockquote><ul><li>在当前页面的控制台操作<code>document.cookie</code>时，只能获取到<code>doc = doc123</code> ，说明<code>HttpOnly</code>属性<strong>选中时</strong>，<code>JS</code>是无法读取当前<code>Cookie</code></li></ul></blockquote><ol start="8"><li><p>Secure 安全标志</p><blockquote><ul><li>标记为<code>Secure</code>的<code>Cookie</code>只能通过被<code>HTTPS</code>协议加密过的请求发送给服务端。它<strong>永远不会使用不安全</strong>的 <code>HTTP</code> 发送（本地主机除外）</li></ul></blockquote></li><li><p>什么样的 Cookie 才能发送到服务器端</p><blockquote><ul><li><code>Domain、Path、Secure</code>都要满足条件，还不能过期的 <code>Cookie</code>才能随着请求发送到服务器端</li></ul></blockquote></li></ol><h3 id="四、Cookie-的封装"><a href="#四、Cookie-的封装" class="headerlink" title="四、Cookie 的封装"></a>四、Cookie 的封装</h3><blockquote><p>前边几节中我们学习了通过<code>JS</code>来写入、读取、删除 Cookie，我们在使用的过程中也发现了 Cookie 原生提供的方式都不好用。因此，我们现在开始对 Cookie 进行封装，让 Cookie 在实际开发中使用起来更方便。</p><ul><li>需要封装<strong>写入</strong> Cookie，<strong>读取</strong>Cookie，<strong>删除</strong> Cookie 这三个功能。会用到我们前面学习过的 ES6 Module 模块的方式进行导入和导出。</li></ul></blockquote><ol><li>封装 cookie<blockquote><p>新建<code>cookie.js</code>文件，封装成一个模块 ，创建一个 <code>Cookie</code>类，添加三个静态方法，将<code>Cookie</code>类做为接口导出</p><ul><li>set 方法，设置 cookie</li><li>get 方法，通过 cookie 的 name 获取 value 值</li><li>remove 方法，通过 cookie 的 name 删除对应的 cookie</li></ul></blockquote></li></ol><ul><li>模块文件<code>cookie.js</code></li></ul><pre><code>class Cookie &#123;  // set方法，用来添加Cookie  // name 和 value 是必传项  // &#123;&#125; 对象中的属性是非必传项，这是对象字面量的新增简洁表示法  // &#123; maxAge, domain, path, secure &#125; = &#123;&#125; 设置默认值，在没有传值的情况下给 &#123;&#125; 对象  static set(name, value, &#123; maxAge, domain, path, secure &#125; = &#123;&#125;) &#123;    // 对传过来的name和value编码    let cookieText = `$&#123;encodeURIComponent(name)&#125;=$&#123;encodeURIComponent(value)&#125;`;    // 设置失效时间    if (typeof maxAge === &quot;number&quot;) &#123;      cookieText += `; max-age=$&#123;maxAge&#125;`;    &#125;    // 设置访问域    if (domain) &#123;      cookieText += `; domain=$&#123;domain&#125;`;    &#125;    // 设置路径    if (path) &#123;      cookieText += `; path=$&#123;path&#125;`;    &#125;    // 设置安全标志    if (secure) &#123;      cookieText += `; secure=$&#123;secure&#125;`;    &#125;    document.cookie = cookieText;  &#125;  // get方法，用来获取Cookie  // 原来通过 document.cookie 获取的 Cookie 值是：  // &quot;username=icoding; age=20; sex=male&quot;  // 对于以上有规律的字符串可以使用 split(&quot;; &quot;) 分割拆分成一个数组，分割后如下  // 得到一个数组 [&#39;username=icoding&#39;, &#39;age=20&#39;, &#39;sex=male&#39;]  static get(name) &#123;    // 将获到的name解码    name = encodeURIComponent(name);    // 将读取到的cookie信息字符串，通过&quot;; &quot;分割成一个数组    let cookies = document.cookie.split(&quot;; &quot;);    // 利用for...of来遍历数组    for (let item of cookies) &#123;      const [cookieName, cookieValue] = item.split(&quot;=&quot;);      if (cookieName === name) &#123;        // 解码        return decodeURIComponent(cookieValue);      &#125;    &#125;    // 如果最后没有找到    return;  &#125;  // remove方法，用来删除Cookie  // 根据 name，domain 和 path 删除 Cookie  // name 必传参数  // domain 和 path 可选项  static remove(name, &#123; domain, path &#125; = &#123;&#125;) &#123;    this.set(name, &quot;&quot;, &#123; domain, path, maxAge: -1 &#125;);  &#125;&#125;// 默认导出export default Cookie;</code></pre><ul><li>新建一个 <code>cookie.html</code> 文件，导入封装好的 <code>cookie</code> 模块，调用对应的方法</li></ul><pre><code>&gt;&lt;script type=&quot;module&quot;&gt;  // 导入 Cookie 模块  import Cookie from &quot;../Cookie.js&quot;;  // 设置Cookie  Cookie.set(&quot;username&quot;, &quot;清心&quot;, &#123; maxAge: 10 &#125;);  Cookie.set(&quot;age&quot;, 33, &#123; path: &quot;/&quot; &#125;);  Cookie.set(&quot;sex&quot;, &quot;女&quot;, &#123; secure: &quot;secure&quot; &#125;);&gt;  // 获取Cookie  console.log(Cookie.get(&quot;username&quot;));  console.log(Cookie.get(&quot;age&quot;));  console.log(Cookie.get(&quot;sex&quot;));&gt;  // 删除Cookie  Cookie.remove(&quot;age&quot;, &#123; path: &quot;/&quot; &#125;);  Cookie.remove(&quot;sex&quot;);&gt;&lt;/script&gt;</code></pre><h3 id="五、Cookie-的注意事项"><a href="#五、Cookie-的注意事项" class="headerlink" title="五、Cookie 的注意事项"></a>五、Cookie 的注意事项</h3><blockquote><p>在实际开发中需要注意，前后端都可以写入和获取 <code>Cookie</code> ，<code>Cookie</code> 有数量限制，<code>Cookie</code> 有大小限制。</p></blockquote><ol><li>Cookie 有数量限制<blockquote><p>每个域名下的 Cookie <strong>数量有限</strong>，具体有多少无法确定，得看浏览器，每个都会不一样</p><ul><li>以下数据也只是<strong>参考</strong>，不能作为实际数据来用，因为浏览器在更新，相关限制也会出现变动<table><thead><tr><th>Cookie 限制</th><th>Edge</th><th>Opera</th><th>Firefox</th><th>Safari</th><th>Chrome</th></tr></thead><tbody><tr><td>Cookie 个数（每个域）</td><td>50 个</td><td>180 个</td><td>150 个</td><td>没有个数限制</td><td>没有个数限制</td></tr><tr><td>Cookie 总大小（字节数）</td><td>4095</td><td>4096</td><td>4097</td><td>4097</td><td>4097</td></tr></tbody></table></li></ul></blockquote></li></ol><blockquote><p><strong>注：</strong></p><ul><li>浏览器 Cookie 的数量限制只跟 <strong>每个域名下</strong> Cookie 数量有关系</li><li>当超过单个域名限制之后，再设置 Cookie ，浏览器就会清除以前设置的 Cookie<blockquote><p>因此，在实际开发中不要过多的设置 Cookie ，要考虑它的数量限制，防止发生无法预期的后果</p></blockquote></li></ul></blockquote><ol start="2"><li><p>Cookie 有大小限制</p><blockquote><p>Cookie 的存储容量很小，最多只有 <code>4KB</code> 左右（具体在以上表格中），这里对容量的限制不是针对一个 Cookie，是<strong>针对一个域名下的所有</strong> <code>Cookie</code> 而言</p><p>在实际开发中一般是遇不到超出 Cookie 的数量和大小限制的，我们正常也不会设置那么多的 Cookie。</p><ul><li>如果真的设置了很多 Cookie，就需要考虑下 Cookie 的限制了。</li></ul></blockquote></li><li><p>前后端都可以写入 和 获取 Cookie</p><blockquote><ul><li>不仅仅前端可以创建 Cookie，随着请求发送到服务器端</li><li>后端同样可以创建 Cookie ，通过响应发送到前端来，之后的请求总会携带 Cookie 发送到后端</li><li>到底 Cookie 是从前端来创建还是后端来创建，就需要根据具体的业务需求来了</li></ul></blockquote></li></ol><h3 id="六、服务端创建-Cookie"><a href="#六、服务端创建-Cookie" class="headerlink" title="六、服务端创建 Cookie"></a>六、服务端创建 Cookie</h3><blockquote><p>我们通过图解和代码来帮助大家理解服务端创建 Cookie 的过程。服务端是后台开发人员需要掌握的，我们这个阶段只需要先了解就好，因为需要操作服务器。</p><ul><li>所以我们需要简单学习下 node，用来搭建一个简单的 HTTP 服务器。</li></ul></blockquote><ol><li>什么是 <code>Node.js</code><blockquote><ul><li><code>Node.js</code>是一个基于 Chrome V8 引擎的 JavaScript 运行时环境。</li><li><code>Node.js</code>为 JavaScript 提供了在服务端运行的环境，使得 JavaScript 也能开发服务端的程序，前后端统一语言，统一模型的梦想得以实现</li></ul><p>Node.js 2009 年诞生，2015 到 2016 左右在中国就火起来了，Node 火了之后带来了连锁反应。</p><p>2016 年前后，以 webpack 为代表的 Node.js 工作流工具 使前端开发的开发形式产生了翻天覆地的变化。并且，随着<code>Vue / React</code>的诞生，使前端开发进入了框架时代。</p><ul><li>在今天，可以说前端开发 “上天入地，无所不能”：PC 端 web 开发、移动 web 开发、APP 开发、小程序开发、服务端开发等等都能搞定。</li></ul></blockquote></li></ol><blockquote><p>我们日常听到 <code>Node.js</code> 时，要<strong>注意区分</strong>他到底说的是 <strong>平台</strong> 还是 <strong><code>Node.js</code>语言</strong>，因此我们讲 Node.js 有两个层面的含义：</p><ul><li><code>Node.js</code>是个平台或工具，即在 Node.js 平台上安装模块或包，类似于前端在浏览器上安装插件一样</li><li><code>Node.js</code>语言 &#x3D; 后端 JavaScript &#x3D; ECMAScript + IO + File + … 等服务端的操作</li></ul><p>我们前端常说的<code>Node</code>更多是指如何在<code>Node.js</code>平台上安装模块或包，类似前端在浏览器上安装插件一样。</p><p>因此，大家在日常开发中会用到在<code>Node.js</code>平台上安装模块或包， 这只是使用了<code>Node.js</code>平台，并不代表你就懂<code>Node.js</code> 语言了（<code>Node.js</code>语言本质上它就类似<code>PHP、Python、Perl、Ruby</code>等服务端语言，包括<code>Java</code>这些服务端的语言能干的<code>Node.js</code>都能干，非常强大 ），这个一定要搞清楚，务必盲目的自信，避免闹笑话。</p><ul><li>但本节课的案例中为了帮助大家更好的理解 Cookie 的前后交互，会简单涉及<code>Node.js</code>语言相关内容，大家不要深究，只做了解即可。</li></ul></blockquote><ol start="2"><li><p>node 的安装</p><blockquote><ul><li>Node.js<a href="https://nodejs.org/en/download/">官方下载地址</a></li><li>选择最新稳定版，根据自己的操作系统选择对应的下载地址</li><li>下载完成后，直接下一步，默认安装即可</li></ul></blockquote></li><li><p>检测是否安装成功及版本号</p><blockquote><p>在 window 的 cmd 命令窗口，输入 <code>node -v</code></p><ul><li>如果需要切到<code>D</code>盘，输入<code>D:</code></li><li>安装 node 时，会自动安装 npm , npm 是 node.js 的包管理器</li></ul></blockquote></li></ol><pre><code>&gt;检测 node 是否安装及版本，正常显示版本号说明已经安装相应的版本node -v&gt;&gt;检测 npm 是否安装及版本，正常显示版本号说明已经安装相应的版本npm -v</code></pre><ol><li>node 搭建服务器<blockquote><p>创建 <code>server.js</code> 文件</p><ul><li>文件内容如下</li></ul></blockquote></li></ol><pre><code>// 加载Node.js自带的http模块，http模块主要用来创建HTTP服务器const http = require(&quot;http&quot;);// 创建HTTP服务器  回调函数中的request用来接受请求数据，response用来处理响应数据http  .createServer(function (request, response) &#123;    // 设置响应头，解决中文乱码问题    response.writeHead(200, &#123;      // 返回内容的类型和编码      &quot;Content-type&quot;: &quot;text/plain;charset=utf-8&quot;,    &#125;);    // response.write方法向前端返回数据，该方法可调用多次,多次调用的数据会被拼接到一起返回    response.write(&quot;hello&quot;);    response.write(&quot;world&quot;);    // 必须调用response.end方法结束请求，否则前端会一直处于等待状态，    // response.end方法也可以用来向前端返回数据    response.end(&quot;发送完，结束&quot;);  &#125;)  .listen(8886); // 指定HTTP服务器监听的端口号 四位数字&gt;console.log(&quot;Server running at http://127.0.0.1:8886&quot;);</code></pre><p><strong>运行流程</strong></p><blockquote><ul><li>执行程序，在 VSCode 的终端命令中运行<code>node server.js</code>命令来执行程序，程序启动成功后，在地址栏中输入<code>http://127.0.0.1:8886</code> 回车，就可以看到返回的内容。</li><li>返回上级目录，在 VSCode 的终端命令中运行<code>cd ../</code>回车</li><li>切换到下级目录，在 VSCode 的终端命令中运行<code>cd 目录名</code>回车 如：<code>cd Desktop/test</code></li><li>终止程序执行，使用快捷键<code> ctrl + C</code></li></ul></blockquote><p><strong>常见的返回数据类型（MIME 类型）</strong></p><blockquote><p><code>MIME</code>类型就是设定某种扩展名的文件用一种应用程序来打开的方式类型，当该扩展名文件被访问的时候，浏览器会自动使用指定应用程序来打开</p><ul><li>多用于指定一些客户端自定义的文件名，以及一些媒体文件打开方式。</li><li>普通文本： <code>text/plain</code></li><li>JS 代码：<code>application/javascript</code></li><li>HTML 代码： <code>text/html</code></li><li>JSON 类型：<code>application/json</code></li><li>图片类型：<code>image/gif 、image/jpeg、image/png</code></li><li>设置编码的格式：<code>charset = utf-8</code></li></ul></blockquote><ol start="5"><li>服务端 Cookie 的创建过程<blockquote><p>服务端在响应头中设置<code>Set-Cookie</code>选项，然后发送到浏览器（客户端），浏览器对应的数据存储<code>Cookie</code>中，并在下次向同一服务器再发起请求时携带并发送到服务器上。<br><img src="cookie在服务器端的响应过程.png"></p></blockquote></li></ol><ul><li>创建过程解析<blockquote><ul><li>当前端（浏览器端）<strong>第一次发送</strong> HTTP 请求时，服务端收到 HTTP 请求后，服务端可以在响应头里面添加一个或多个 <code>Set-Cookie</code> 选项。</li><li><strong>浏览器收到响应后</strong>会将接受的<code>Set-Cookie</code>中的数据保存在浏览器的<code>Cookie</code>中。</li><li>当下一次前端（浏览器端）<strong>再次</strong>向服务端发送 HTTP 请求时，会将其放在 HTTP 请求头的<code>Cookie</code>中，发送到服务端。服务端收到这个数据后，会拿这个数据来做校验….</li></ul></blockquote></li></ul><ol start="6"><li>代码演示 Cookie 创建过程</li></ol><pre><code>//加载Node.js自带的http模块，http模块主要用来创建HTTP服务器const http = require(&quot;http&quot;);//http.createServer()方法创建服务器//函数通过 request, response 参数来接收和响应数据。http.createServer(function(request,response)&#123;    //获取请求端发来的数据    const cookie=request.headers.cookie;    // console.info(cookie);    //设置响应头，解决中文乱码问题    response.writeHead(200,&#123;        //返回内容的类型和编码        &quot;Content-type&quot;:&quot;text/plain;charset=utf-8&quot;,        &quot;Set-Cookie&quot;:[&quot;username=hermia&quot;],    &#125;);    //响应体内容：    //response.write方法向前端返回数据    //该方法可多次调用，多次调用的数据会被拼接到一起返回    if(cookie)&#123;        response.write(&quot;收到你的cookie了&quot;);&gt;    &#125;else&#123;        response.write(&quot;你的身份不合格&quot;);    &#125;    //必须调用response.end方法结束请求，否则前端一直会处于等待状态，response.end方法也可以用来向前端发送数据    response.end();&#125;).listen(8888);//指定HTTP服务器监听的端口号，四位数console.log(&quot;Server running at http://127.0.0.1:8888&quot;);</code></pre><p><strong>运行流程</strong></p><blockquote><ul><li>先<strong>安装</strong> node，然后在一个文件夹中打开 VSCode，在 VSCode 中创建<code>server.js</code>文件，文件内容如上面代码。</li><li>然后<strong>在终端执行</strong><code>node server.js</code>命令运行程序，程序启动成功后，<strong>在浏览器地址栏</strong>输入：<code>http://127.0.0.1:8888/</code>就可以向服务端发起 <code>Http</code> 请求，同时服务端响应内容”你的身份不合格”。</li><li><strong>第一次</strong>向<code>http://127.0.0.1:8888/</code>发起请求时，请求头中并没有<code>Cookie</code> 信息，<strong>服务端接收请求后</strong>，在响应头中设置了<code>Set-Cookie</code>，所以响应头信息中有<code>Set-Cookie: username = hermia</code>信息。这时候浏览器会把响应头<code>Set-Cookie</code>中的信息，保存在浏览器的 <code>Cookie</code> 中。</li><li><strong>第二次</strong>向<code>http://127.0.0.1:8888/</code>发送请求时，请求头中携带了<code>Set-Cookie: username = hermia</code>信息，同时服务端读取到请求头中的<code>Cookie</code>，并在服务端的终端打印”收到你的cookie了”</li><li>在当前页面中，打开控制台，选择<code>Network</code>面板，然后刷新浏览器，然后按下图操作，就能看到整个过程。</li></ul></blockquote><h3 id="七、Cookie-在实际开发中的实际应用"><a href="#七、Cookie-在实际开发中的实际应用" class="headerlink" title="七、Cookie 在实际开发中的实际应用"></a>七、Cookie 在实际开发中的实际应用</h3><ul><li>Cookie 实现中英文网站语言切换<blockquote><ul><li>当用户第一次访问网站时，默认显示的是中文网站</li><li>如果点击了页面的英文切换按扭，则切换到英文网站。下次打开网站后显示的就是英文版的。</li></ul></blockquote></li></ul><ol><li><p>实现原理</p><blockquote><ul><li>第一次发送请求，服务端会判断请求头中是否有对应的 <code>Cookie</code>，如果没有，则默认发送的中文版的网站</li><li>点击页面中英文按扭，在 Cookie 中添加<code>language=en; max-age=$&#123;365*24*3600&#125;&quot;</code>，然后利用<code>window.location=&#39;/&#39;</code>重新向后端发送一次请求。</li><li>点击页面中中文按扭，在 Cookie 中添加<code>language=cn; max-age=$&#123;365*24*3600&#125;&quot;</code>，然后利用<code>window.location=&#39;/&#39;</code>重新向后端发送一次请求</li><li>服务器接收请求头中的 Cookie，判断 cookie 值，如是为en,则发送英文网站，否则发送中文。随后的每次请求，请求头中都会携带 Cookie，服务端都会根据请求头中的 Cookie 来判断是发送中文网站还是英文网站</li></ul></blockquote></li><li><p>代码实现步骤</p><blockquote><p>创建两个 HTML 页面</p><ul><li><code>en.html</code>表示英文网站</li><li><code>cn.html</code>表示中文网站<br>在页面中添加对应的中英文切换按扭，点击对应的按扭，就创建对应的 Cookie 存入到浏览器中，然后利用<code>window.location = &#39;/&#39;</code>重新向后端发送一次请求，后端会根据这一次请求，响应对应的内容</li></ul></blockquote></li></ol><ul><li><code>cn.html</code>页面</li></ul><pre><code>&gt;&lt;body&gt;&gt;  &lt;button id=&quot;cn&quot;&gt;中文&lt;/button&gt;&gt;  &lt;button id=&quot;en&quot;&gt;英文&lt;/button&gt;&gt;  中国欢迎你！&gt;  &lt;script&gt;&gt;    const cn = document.getElementById(&quot;cn&quot;);&gt;    const en = document.getElementById(&quot;en&quot;);&gt;    cn.addEventListener(&quot;click&quot;, () =&gt; &#123;&gt;      //创建Cookie&gt;      document.cookie = `language=cn; max-age=$&#123;365 * 24 * 3600&#125;`;&gt;      window.location = &quot;/&quot;;&gt;    &#125;);&gt;&gt;    en.addEventListener(&quot;click&quot;, () =&gt; &#123;&gt;      //创建Cookie&gt;      document.cookie = `language=en; max-age=$&#123;365 * 24 * 3600&#125;`;&gt;      window.location = &quot;/&quot;;&gt;    &#125;);&gt;  &lt;/script&gt;&gt;&lt;/body&gt;</code></pre><ul><li><code>en.html</code>页面</li></ul><pre><code>&gt;&lt;body&gt;&gt;  &lt;button id=&quot;cn&quot;&gt;中文&lt;/button&gt;&gt;  &lt;button id=&quot;en&quot;&gt;English&lt;/button&gt;&gt;  Welcome to China!&gt;  &lt;script&gt;&gt;    const cn = document.getElementById(&quot;cn&quot;);&gt;    const en = document.getElementById(&quot;en&quot;);&gt;    cn.addEventListener(&quot;click&quot;, () =&gt; &#123;&gt;      //创建Cookie&gt;      document.cookie = `language=cn; max-age=$&#123;365 * 24 * 3600&#125;`;&gt;      window.location = &quot;/&quot;;&gt;    &#125;);&gt;&gt;    en.addEventListener(&quot;click&quot;, () =&gt; &#123;&gt;      //创建Cookie&gt;      document.cookie = `language=en; max-age=$&#123;365 * 24 * 3600&#125;`;&gt;      window.location = &quot;/&quot;;&gt;    &#125;);&gt;  &lt;/script&gt;&gt;&lt;/body&gt;</code></pre><ul><li>用 <code>node</code> 创建服务器，具体代码如下</li></ul><pre><code>// http模块，主要用来搭建 HTTP 服务器const http = require(&quot;http&quot;);// 文件操作模块const fs = require(&quot;fs&quot;);&gt;// 创建服务器http  .createServer((request, response) =&gt; &#123;    // 获取请求体中的cookie    const cookie = request.headers.cookie;    const language = cookie ? cookie.split(&quot;=&quot;)[1] : &quot;cn&quot;;    let html = &quot;&quot;; // 保存响应体内容    // 根据Cookie的内容，来决定发送的内容    if (language === &quot;en&quot;) &#123;      html = fs.readFileSync(&quot;./en.html&quot;);    &#125; else &#123;      html = fs.readFileSync(&quot;./cn.html&quot;);    &#125;&gt;    // 设置响应头信息 200 表示状态响应成功，    // Content-Type 响应主体的内容类型为html文件，编码格式utf-8    response.writeHead(200, &#123;      &quot;Content-Type&quot;: &quot;text/html;charset=utf-8&quot;,    &#125;);    // 发送响应体内容    response.end(html);  &#125;)  .listen(1128); // 监听端口&gt;console.log(&quot;Server running at http://127.0.0.1:1128/&quot;);</code></pre><ol start="3"><li>升级版<blockquote><p>在上面的版本中，我们没有办法在<code>cn.html</code>和<code>en.html</code>页面使用模块化加载 <code>Cookie.js</code> 来操作 Cookie，本质是因为<code>http://127.0.0.1:8889/Cookie</code> 请求失败，<strong>后端并没有针对这个请求做相关的响应</strong>（也就是返回 <code>Cookie.js</code> 文件）。</p><ul><li>所以我们需要根据用户的请求路径来响应不同的内容</li></ul></blockquote></li></ol><ul><li><code>cn.html</code>页面</li></ul><pre><code>&gt;&lt;button id=&quot;cn&quot;&gt;中文&lt;/button&gt;&gt;&lt;button id=&quot;en&quot;&gt;英文&lt;/button&gt;&gt;我爱你&gt;&gt;&lt;script type=&quot;module&quot;&gt;&gt;  // 模块化导入JS&gt;  import Cookie from &quot;./Cookie&quot;;&gt;  const cn = document.getElementById(&quot;cn&quot;);&gt;  const en = document.getElementById(&quot;en&quot;);&gt;  cn.addEventListener(&quot;click&quot;, () =&gt; &#123;&gt;    //创建Cookie&gt;    Cookie.set(&quot;language&quot;, &quot;cn&quot;, &#123; maxAge: 365 * 24 * 3600 &#125;);&gt;    // 重新加载页面&gt;    window.location = &quot;/&quot;;&gt;  &#125;);&gt;&gt;  en.addEventListener(&quot;click&quot;, () =&gt; &#123;&gt;    //创建Cookie&gt;    Cookie.set(&quot;language&quot;, &quot;en&quot;, &#123; maxAge: 365 * 24 * 3600 &#125;);&gt;    window.location = &quot;/&quot;;&gt;  &#125;);&gt;&lt;/script&gt;</code></pre><ul><li><code>en.html</code>页面</li></ul><pre><code>&gt;&lt;button id=&quot;cn&quot;&gt;中文&lt;/button&gt;&gt;&lt;button id=&quot;en&quot;&gt;English&lt;/button&gt;&gt;I love you&gt;&gt;&lt;script type=&quot;module&quot;&gt;&gt;  // 模块化导入JS&gt;  import Cookie from &quot;./Cookie&quot;;&gt;  const cn = document.getElementById(&quot;cn&quot;);&gt;  const en = document.getElementById(&quot;en&quot;);&gt;  cn.addEventListener(&quot;click&quot;, () =&gt; &#123;&gt;    //创建Cookie&gt;    Cookie.set(&quot;language&quot;, &quot;cn&quot;, &#123; maxAge: 365 * 24 * 3600 &#125;);&gt;    // 重新加载页面&gt;    window.location = &quot;/&quot;;&gt;  &#125;);&gt;&gt;  en.addEventListener(&quot;click&quot;, () =&gt; &#123;&gt;    //创建Cookie&gt;    Cookie.set(&quot;language&quot;, &quot;en&quot;, &#123; maxAge: 365 * 24 * 3600 &#125;);&gt;    // 重新加载页面&gt;    window.location = &quot;/&quot;;&gt;  &#125;);&gt;&lt;/script&gt;</code></pre><ul><li><code>server.js</code>页面</li></ul><pre><code>// http模块，主要用来搭建 HTTP 服务器const http = require(&quot;http&quot;);// 文件操作模块const fs = require(&quot;fs&quot;);&gt;// 创建服务器http  .createServer((request, response) =&gt; &#123;    // 请求根目录    if (request.url === &quot;/&quot;) &#123;      // 获取请求体中的cookie      const cookie = request.headers.cookie;      const language = cookie ? cookie.split(&quot;=&quot;)[1] : &quot;cn&quot;;      let html = &quot;&quot;; // 保存响应内容体      if (language === &quot;en&quot;) &#123;        html = fs.readFileSync(&quot;./en.html&quot;);      &#125; else &#123;        html = fs.readFileSync(&quot;./cn.html&quot;);      &#125;&gt;      // 设置响应头信息 200 表示状态响应成功，      // Content-Type 响应主体的内容类型为html文件，编码格式utf-8      response.writeHead(200, &#123;        &quot;Content-Type&quot;: &quot;text/html;charset=utf-8&quot;,      &#125;);      // 发送响应体内容      response.end(html);&gt;      //----------------------------------------------------------------      // 请求 /Cookie目录    &#125; else if (request.url === &quot;/Cookie&quot;) &#123;      // 读取JS文件      const js = fs.readFileSync(&quot;./Cookie.js&quot;);      // 设置响应头      response.writeHead(200, &#123;        &quot;Content-Type&quot;: &quot;application/javascript;charset=utf-8&quot;,      &#125;);      // 发送响应体内容      response.end(js);    &#125;  &#125;)  .listen(8889); // 监听端口&gt;console.log(&quot;Server running at http://127.0.0.1:8889/&quot;);</code></pre><h3 id="八、LocalStorage-简介"><a href="#八、LocalStorage-简介" class="headerlink" title="八、LocalStorage 简介"></a>八、<code>LocalStorage</code> 简介</h3><ol><li><p><code>localStorage</code>是什么</p><blockquote><p>有一些数据确实是需要存储在本地，但它却不需要发送到服务器端，所以它并不适合放在 Cookie 中。那么，<code>localStorage</code>就是一个不错的选择。</p><p><code>localStorage</code>也是一种浏览器存储数据的方式（本地存储），它<strong>只存储在本地，不会发送到服务器端</strong>（不会像 Cookie 那样发送到服务器端）。</p><p>这样一来</p><ul><li>对于那些你既想存储在用户本地，又不想发送到服务器端的数据，就可以存储在<code>localStorage</code>中</li><li>而那些既希望它存储在本地，又希望它能随着请求发送到服务器端的数据就可以存储在 <code>Cookie</code> 中</li></ul></blockquote></li><li><p>在浏览器中操作<code>localStorage</code></p><blockquote><p><code>localStorage</code>也是按<strong>域名</strong>来存储的，在浏览器可直接查看。</p><ul><li><code>Local Storage</code>中的数据是以键值对的形式存储的</li><li>如下<img src="localstorage.png"></li></ul></blockquote></li></ol><h3 id="九、LocalStorage-的基本用法"><a href="#九、LocalStorage-的基本用法" class="headerlink" title="九、LocalStorage 的基本用法"></a>九、LocalStorage 的基本用法</h3><blockquote><p>我们可以通过<code>window.localStorage</code>对象来操作浏览器中的 <code>Local Storage</code>数据。</p></blockquote><ol><li><code>localStorage</code><strong>对象</strong><blockquote><p>通过<code>window.localStorage</code>对象可以获取浏览器 <code>Local Storage</code>中所有的项的数据</p></blockquote></li></ol><pre><code>// 获取本地所有 Local Storageconsole.log(localStorage);&gt;// 控制台输出结果： Storage &#123;font-size: &#39;12px&#39;, color: &#39;#666&#39;, background-color: &#39;skyblue&#39;, length: 3&#125;</code></pre><blockquote><ul><li><code>localStorage</code>对象的 <code>length</code> 属性表示存在的 key 和 value 键值对有多少项。</li></ul></blockquote><pre><code>console.log(localStorage.length); // 3</code></pre><ol start="2"><li>localStorage 对象的方法<blockquote><ul><li>其中<code>window.localStorage</code>对象身上提供了以下方法来操作数据。</li></ul></blockquote></li></ol><table><thead><tr><th>方法</th><th>说明</th></tr></thead><tbody><tr><td>setItem(key,value)</td><td>为本地的 Local Storage 添加一个数据项。</td></tr><tr><td>getItem(key)</td><td>根据对应的键名，获取对应的键值</td></tr><tr><td>removeItem(key)</td><td>根据键名，移除指定项</td></tr><tr><td>clear()</td><td>移除所有的 Local Storage 项</td></tr></tbody></table><ul><li>setItem(key,value)<blockquote><ul><li>setItem(key,value) 为本地的 Local Storage <strong>添加</strong>一个数据项。</li></ul></blockquote></li></ul><pre><code>localStorage.setItem(&quot;font-size&quot;, &quot;12px&quot;);localStorage.setItem(&quot;color&quot;, &quot;#666&quot;);localStorage.setItem(&quot;background-color&quot;, &quot;skyblue&quot;);</code></pre><ul><li>getItem(key)<blockquote><ul><li>getItem(key)根据对应的键名，获取对应的键值，获取不存在的会返回<code>null</code></li></ul></blockquote></li></ul><pre><code>localStorage.getItem(&quot;font-size&quot;); // &quot;12px&quot;localStorage.getItem(&quot;color&quot;); // &quot;#666&quot;localStorage.getItem(&quot;background-color&quot;); // &quot;skyblue&quot;</code></pre><ul><li>removeItem(key)<blockquote><ul><li>removeItem(key)方法根据键名 key，移除指定项，如果删除不存在的 key，<strong>不会报错</strong>。这个方法没有返回值或返回<code>undefined</code></li></ul></blockquote></li></ul><pre><code>// 移除（删除）不存在的 key，不报错localStorage.removeItem(&quot;username&quot;);// 移除存在的指定项localStorage.removeItem(&quot;font-size&quot;);localStorage.removeItem(&quot;color&quot;);</code></pre><ul><li>clear()<blockquote><ul><li>clear()方法用来<strong>移除所有的</strong><code>localStorage</code>数据项</li></ul></blockquote></li></ul><pre><code>// 移除所有localStorage.clear();&gt;// 打印输入 localStorageconsole.log(localStorage); // Storage &#123;length: 0&#125;</code></pre><h3 id="十、localStorage-的注意事项"><a href="#十、localStorage-的注意事项" class="headerlink" title="十、localStorage 的注意事项"></a>十、localStorage 的注意事项</h3><ol><li>localStorage 的存储期限<blockquote><p>localStorage 是<strong>持久化</strong>的本地存储，除非手动清除（如 <strong>通过 JS 删除</strong>或<strong>清除浏览器缓存</strong>）否则，数据永远不会过期的。</p></blockquote></li></ol><ul><li>与 localStorage 对应的是 sessionStorage<blockquote><ul><li>sessionStorage 当前<strong>会话结束（如：关闭浏览器）</strong>的时候，sessionStorage 中的数据会被清空</li><li>操作 sessionStorage 的方法和操作 localStorage 的方法一模一样</li></ul></blockquote></li></ul><pre><code>// 添加项sessionStorage.setItem(&quot;font-size&quot;, &quot;12px&quot;);sessionStorage.setItem(&quot;color&quot;, &quot;#666&quot;);sessionStorage.setItem(&quot;background-color&quot;, &quot;skyblue&quot;);&gt;// 打印sessionStorageconsole.log(sessionStorage);&gt;// 获取指定项console.log(sessionStorage.getItem(&quot;font-size&quot;));&gt;// 移除指定项sessionStorage.removeItem(&quot;font-size&quot;);sessionStorage.removeItem(&quot;color&quot;);&gt;// 移除所有项sessionStorage.clear();</code></pre><ul><li>localStorage 和 sessionStorage 什么时候用 ？<blockquote><ul><li>如需要<strong>永久化</strong>的存储一个数据，可保存在 <code>localStorage</code> 中</li><li>需要<strong>会话结束</strong>（关闭浏览器）就消失，可保存在 <code>sessionStorage</code> 中</li></ul></blockquote></li></ul><ol start="2"><li><p>不同域名下能否共用 localStorage</p><blockquote><p>localStorage 是<strong>按域名</strong>来存储的，即<strong>同一个域名下的所有页面</strong>都可以访问该域名下的 <code>localStorage</code></p><p>但不同的域名下是<strong>不能共用</strong> localStorage 的</p><ul><li>我们自己域名下的 localStorage 别的域名是无法访问的，别的域名下的 localStorage 我们自己的域名也是不能访问的。</li></ul></blockquote></li><li><p>localStorage 的大小限制</p><blockquote><p>单个域名下的localStorage 总大小有限制（不超过<code>5MB</code>），但<strong>没有单个大小的限制</strong>。而 Cookie 是单个大小的限制，也跟浏览器有关系，不同浏览器大小限制不同。</p><ul><li>正常情况下是不会存满的，使用中不要超过限制即可，超过了会造成数据丢失。</li></ul></blockquote></li><li><p>localStorage 键和值的类型</p><blockquote><ul><li>localStorage 存储的键和值<strong>只能是字符串类型</strong></li><li>不是字符串类型，也会先转化成字符串类型再存进去（localStorage 会自动转的，不需要手动转换）</li></ul></blockquote></li></ol><pre><code>// key传入的是一个对象localStorage.setItem(&#123;&#125;, &quot;hello&quot;);console.log(localStorage.getItem(&quot;[object Object]&quot;)); // hello&gt;// value传入的是一个对象localStorage.setItem(&quot;skinTheme&quot;, &#123;  &quot;font-size&quot;: &quot;12px&quot;,  color: &quot;#666&quot;,  &quot;background-color&quot;: &quot;skyblue&quot;,&#125;);console.log(localStorage);// 打印结果 Storage &#123;skinTheme: &#39;[object Object]&#39;, [object Object]: &#39;hello&#39;, length: 2&#125;</code></pre><h3 id="十一、localStorage-的封装"><a href="#十一、localStorage-的封装" class="headerlink" title="十一、localStorage 的封装"></a>十一、localStorage 的封装</h3><blockquote><ul><li>因为 localStorage 的键和值<strong>只能是字符串类型</strong>的</li><li>但很多时候我们希望保存的 value 值是一个<strong>对象</strong>，根据对应的 key 来取值时，也能取出对应的对象。<blockquote><p>这就需要我们人为的来封装一个类来实现。</p></blockquote></li></ul></blockquote><ol><li>封装 storage 对象<blockquote><p>新建<code>storage.js</code>文件，封装成一个模块 ，创建一个 storage 对象，添加三个方法，将 storage 对象做为默认接口导出</p><ul><li>set 方法，添加一项数据</li><li>get 方法，通过指定的 key 来获取数据</li><li>remove 方法，根据 key 来移除指定的数据项</li><li>has 方法，根据 key 来判断是否存在指定项</li><li>clear() 清除所有项</li></ul></blockquote></li></ol><pre><code>// storage.js模块 默认导出一个对象export default &#123;  // 根据key value 添加一项数据  set(key, value) &#123;    if (typeof value === &quot;object&quot;) &#123;      value = JSON.stringify(value); // 将对象转成JSON字符串    &#125;    localStorage.setItem(key, value);  &#125;,  // 根据key来获取指定项  get(key) &#123;    const data = localStorage.getItem(key);    try &#123;      return JSON.parse(data); // 将字符串转换为对象    &#125; catch (err) &#123;      return data;    &#125;  &#125;,  // 根据key来删除指定项  remove(key) &#123;    localStorage.removeItem(key);  &#125;,&gt;  // 根据key来判断是否存在指定项  has(key) &#123;    const value = localStorage.getItem(key);    return value ? true : false;  &#125;,&gt;  // clear() 清除所有项  clear() &#123;    localStorage.clear();  &#125;,&#125;;</code></pre><blockquote><ul><li>在<code>get(key)</code>时，需要将字符串转成对象，如果key&#x3D;undefined，就会报错，所以用<code>try...catch</code>捕获错误，直接返回value值</li></ul></blockquote><ul><li>新建<code>index.html</code>页面，添加如下代码，测试封装好的模块</li></ul><pre><code>&gt;&lt;script type=&quot;module&quot;&gt;  import storage from &quot;./storage.js&quot;;  // 添加  storage.set(&quot;skinTheme&quot;, &#123;    &quot;font-size&quot;: &quot;12px&quot;,    color: &quot;#666&quot;,    &quot;background-color&quot;: &quot;skyblue&quot;,  &#125;);  storage.set(&quot;history&quot;, [1, 2, 3, 4, 5]);  storage.set(&quot;username&quot;, &quot;清心&quot;);  storage.set(&quot;空&quot;, null);&gt;  // 获取  console.log(storage.get(&quot;username&quot;)); // 清心  console.log(storage.get(&quot;history&quot;)); // [1, 2, 3, 4, 5]&gt;  // 移除  storage.remove(&quot;空&quot;);  storage.remove(&quot;history&quot;);&gt;  // 判断是否存在  console.log(storage.has(&quot;skinTheme&quot;)); // true  console.log(storage.has(&quot;ab&quot;)); // false&gt;&lt;/script&gt;</code></pre><h3 id="十二、localStorage-在实际开发中的应用"><a href="#十二、localStorage-在实际开发中的应用" class="headerlink" title="十二、localStorage 在实际开发中的应用"></a>十二、localStorage 在实际开发中的应用</h3><h4 id="案例一：添加搜索历史记录"><a href="#案例一：添加搜索历史记录" class="headerlink" title="案例一：添加搜索历史记录"></a>案例一：添加搜索历史记录</h4><blockquote><p>当用户在搜索框搜索对应的关键字时，会把用户搜索过的关键字保存在搜索框下面，并且只限定能放 <code>6</code> 个，超过了就删除最早加入的，当然也可以手动删除不想要的。</p></blockquote><ol><li>HTML布局</li></ol><pre><code>&gt;&lt;style&gt;  input,  button &#123;    box-sizing: border-box;    outline: none;  &#125;  .search &#123;    width: 600px;    margin: 50px auto;  &#125;  .search-wrap &#123;    display: flex;    height: 70px;  &#125;  .search-input &#123;    width: 680px;    height: 50px;    border: 1px solid #ddd;    border-right: 0px;    border-radius: 5px 0 0 5px;  &#125;  .search-input::placeholder &#123;    font-size: 20px;  &#125;  .search-button &#123;    width: 120px;    height: 50px;    background-color: orange;    border: none;    color: #fff;    font-size: 24px;    cursor: pointer;  &#125;&gt;  .keywords-wrap span &#123;    display: inline-block;    background-color: #ddd;    padding: 5px 10px;    border-radius: 2px;    margin: 5px;    position: relative;    cursor: pointer;  &#125;  .keywords-wrap span i &#123;    display: block;    width: 15px;    height: 15px;    position: absolute;    right: -2px;    top: -2px;    background-color: orange;    border-radius: 10px;    font-size: 12px;    text-align: center;    line-height: 10px;    color: #fff;    display: none;    cursor: pointer;  &#125;  .keywords-wrap span:hover i &#123;    display: block;  &#125;&gt;&lt;/style&gt;&gt;&lt;body&gt;&gt;  &lt;div class=&quot;search&quot;&gt;&gt;    &lt;div class=&quot;search-wrap&quot;&gt;&gt;      &lt;input type=&quot;text&quot; placeholder=&quot;请输入搜索关键字&quot; class=&quot;search-input&quot; /&gt;&gt;      &lt;button class=&quot;search-button&quot;&gt;搜索&lt;/button&gt;&gt;    &lt;/div&gt;&gt;&gt;    &lt;div class=&quot;keywords-wrap&quot;&gt;&gt;      &lt;!-- &gt;        &lt;span&gt;漂亮的包包&lt;i&gt;x&lt;/i&gt;&lt;/span&gt;          &gt;        &lt;span&gt;衣服&lt;i&gt;x&lt;/i&gt;&lt;/span&gt;&gt;        &lt;span&gt;女性化妆品 &lt;i&gt;x&lt;/i&gt;&lt;/span&gt;&gt;        &lt;span&gt;洗面奶&lt;i&gt;x&lt;/i&gt;&lt;/span&gt;&gt;        &lt;span&gt;小米手机 &lt;i&gt;x&lt;/i&gt;&lt;/span&gt;&gt;        &lt;span&gt;图解HTTP&lt;i&gt;x&lt;/i&gt;&lt;/span&gt;&gt;        &lt;span&gt;你不知道的Javascript&lt;i&gt;x&lt;/i&gt;&lt;/span&gt;&gt;        &lt;span&gt;ES6标准入门&lt;i&gt;x&lt;/i&gt;&lt;/span&gt;&gt;      --&gt;&gt;    &lt;/div&gt;&gt;  &lt;/div&gt;&gt;&lt;/body&gt;</code></pre><ol start="2"><li>JS 代码实现逻辑</li></ol><ul><li>第一步：操作输入框中的关键词<blockquote><p>给搜索按钮添加点击事件，获取关键字，创建对象</p><ul><li>获取 DOM 元素：搜索框、搜索按扭、关键词容器</li><li>如果搜索框有内容，就创建一个对象，里面保存关键词的信息，<code>obj=&#123;id:id值,keyword:value&#125;</code></li><li>定义一个数组<code>let keywordsArr = []</code>，用来保存每次搜索的关键字对象</li><li>创建对象后，将对象添加进数组<ul><li>判断搜索框有内容：去掉前后空格</li><li><code>id</code>值通过时间戳创建唯一的id值</li></ul></li></ul><p>将关键词插入到页面</p><ul><li>新建<code>span</code>节点，将关键词、删除按钮添加到节点中</li><li>给<code>span</code>设置<strong>自定义属性</strong><code>data-id</code>，保存和关键词一样的id，便于删除<br>如果数据长度超出限制：</li><li>将关键词容器的第一个节点删除</li><li>将数组中的第一个元素删除</li></ul><p>将对象保存到<code>localStorage</code>中</p><ul><li>使用<code>storage</code>模块，将数组中对应数据存入<code>storage</code><blockquote><p>用户输入内容，点击搜索后，清空搜素框：在获取输入框的<code>value</code>值之后，将其设置为空内容</p></blockquote></li></ul></blockquote></li></ul><pre><code>//导入模块import storage from &quot;./storage.js&quot;;// 获取输入框和搜索按扭const searchInput = document.querySelector(&quot;.search-input&quot;);const searchButton = document.querySelector(&quot;.search-button&quot;);// 获取（历史搜索）存放关键词容器const keywords = document.querySelector(&quot;.keywords-wrap&quot;);// 用来保存关键字的数组let keywordsArr = [];&gt;// 点击搜索按扭searchButton.addEventListener(&quot;click&quot;, () =&gt; &#123;  let value = searchInput.value;  searchInput.value = &quot;&quot;;//获取value后，清空搜索框  // 如果内容去掉前后空格，还有内容，将内容添加到页面中  if (value.trim()) &#123;    // 创建一条数据    const obj = &#123;      id: new Date().getTime(),      keyword: value,    &#125;;    // 创建span标签    const span = document.createElement(&quot;span&quot;);    span.dataset.id = obj.id; // 添加唯一标识    span.innerHTML = `$&#123;value&#125;&lt;i&gt;x&lt;/i&gt;`;    // span标签添加到页面    keywords.appendChild(span);    // 将内容添加到数组的尾部保存起来&gt;    keywordsArr.push(obj);    // 因为记录的数据不能超过6条，所以要判断，如果超过，则删除第一条    if (keywordsArr.length &gt; 6) &#123;      // 数组中将第一个元素删除      keywordsArr.shift();      // DOM中也将第一个元素删除      keywords.removeChild(keywords.children[0]);    &#125;    // 将数组中对应的数据存入到localStorage中    storage.set(&quot;history&quot;, keywordsArr);  &#125;&#125;);</code></pre><ul><li>第二步：读取<code>localStorage</code>中的数据，显示在页面中<blockquote><ul><li>当关闭页面后，再次打开，搜索框下的内容就消失了，所以需要每次打开页面时，把 <code>localStorage</code> 中存储的数据取出来插入到页面中<ul><li>通过<code>storage</code>模块的<code>get</code>方法将<code>history</code>拿出来<blockquote><p>虽然我们存进去的是一个数组，但取出来的是一个对象，模块里用<code>Json</code>做了处理</p></blockquote></li></ul></li><li>这里要考虑<strong>第一次打开页面</strong>时，localStorage 中还没有存任何数据，所以取出的 localStorage 数据可能为 <code>undefined</code>，所以需要判断数据是否存在<ul><li>如果存在，就遍历取出的数据，生成 DOM 插入到页面</li></ul></li></ul></blockquote></li></ul><pre><code>showKeyWords();function showKeyWords() &#123;  //获取history  const storageDate = storage.get(&quot;history&quot;); //拿到的是一个对象  //判断数据是否存在  if (storage) &#123;    //将数据存入数组    keywordArr = storageDate;    //for...of遍历对象 将其插入到页面中    for (let &#123; id, keyword &#125; of storageDate) &#123;      const span = document.createElement(&quot;span&quot;);      //给span添加和id相同的唯一标识      span.dataset.id = id;      span.innerHTML = `$&#123;keyword&#125;&lt;i&gt;x&lt;/x&gt;`;      //将内容生成DOM插入页面      keywrap.appendChild(span);    &#125;  &#125;&#125;</code></pre><ul><li>第三步：点击关键字右侧顶部的删除按扭，<strong>删除对应关键字</strong><blockquote><p>利用事件代理，给<code>keywords-wrap</code>添加点击事件，如果点击的元素是<code>&lt;i&gt;</code>标签，就</p><ul><li>删除对应关键词的DOM标签<ul><li>通过i标签的父元素的父元素删除</li></ul></li><li><strong>更新</strong><code>localStorage</code>；为了下一次打开的时候不出现已删除关键词，就得把<code>storage</code>里面的数据更新；而<code>storage</code>里面的数据是通过数组存进来的，所以先更新数组，再用新数组更新<code>localStorage</code><ul><li>删除数组中的数据：获取i标签的父元素对应的id值；遍历数组，找到有相同id的对象，获取其下标，根据下标删除</li><li>重新给<code>localStorage</code>赋值</li></ul></li></ul></blockquote></li></ul><h4 id="案例2：更改网站皮肤"><a href="#案例2：更改网站皮肤" class="headerlink" title="案例2：更改网站皮肤"></a>案例2：更改网站皮肤</h4><blockquote><p>大家可以自己去实现，可以参考 MDN 官方网站给出的实例<code>https://mdn.github.io/dom-examples/web-storage/</code></p></blockquote><h3 id="面试题"><a href="#面试题" class="headerlink" title="面试题"></a>面试题</h3><ul><li>Cookie、localStorage、sessionStorage 的对比（面试题）<table><thead><tr><th>对比项</th><th>Cookie</th><th>LocalStorage</th><th>sessionStorage</th></tr></thead><tbody><tr><td>存储大小</td><td>4K</td><td>5M</td><td>5M</td></tr><tr><td>有效期</td><td>手动设置</td><td>无</td><td>浏览器窗口关闭</td></tr><tr><td>存储位置</td><td>浏览器</td><td>浏览器</td><td>浏览器</td></tr><tr><td>与请求一起发送</td><td>是</td><td>否</td><td>否</td></tr><tr><td>访问限止</td><td>子域可以访问自己和父域中的</td><td>Cookie同域下都可以访问</td><td>只限当前窗口</td></tr></tbody></table></li></ul>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 网络 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>前端工程化（二）</title>
      <link href="/2024/01/11/%E5%89%8D%E7%AB%AF%E5%B7%A5%E7%A8%8B%E5%8C%96%EF%BC%88%E4%BA%8C%EF%BC%89/"/>
      <url>/2024/01/11/%E5%89%8D%E7%AB%AF%E5%B7%A5%E7%A8%8B%E5%8C%96%EF%BC%88%E4%BA%8C%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<span id="more"></span><h3 id="一、Webpack5-基础入门"><a href="#一、Webpack5-基础入门" class="headerlink" title="一、Webpack5 基础入门"></a>一、Webpack5 基础入门</h3><img src="webpack总结-1.png"><h4 id="Webpack-是什么"><a href="#Webpack-是什么" class="headerlink" title="Webpack 是什么"></a>Webpack 是什么</h4><blockquote><p>本质上，Webpack是一个用于现代JavaScript应用程序的 <strong>静态模块打包工具</strong>，当 Webpack 处理应用程序时，它会在内部从一个或多个入口点构建一个<strong>依赖图</strong>（dependency graph），然后将你项目中所需的每一个模块组合成一个或多个 bundles（包），它们均为静态资源，用于展示你的内容。</p></blockquote><ul><li>详细查阅<a href="https://webpack.docschina.org/concepts/">Webpack5 中文文档教程</a></li><li>模块：是 Webpack 可以处理的最小单位，一切文件都可以当成一个模块，比如 JS、CSS、图片、图标字体等</li><li>静态：通俗点说，就是开发过程中存在于本地的 JS、CSS、图标字体等文件就是静态的模块，当然最终都要上传到服务器。</li></ul><blockquote><p>在开发过程中有些资源你是放在本地，使用相对地址来引用，有些是放在服务器，需要通过远程地址（绝对地址）来引用。这些存在本地的就是静态的，而那些需要从远程服务器获取的就是<strong>动态</strong>的。</p><ul><li>所以你可以理解为，使用<strong>相对路径</strong>来引用的资源，可以看作是静态的模块。</li></ul></blockquote><pre><code>//静态的&lt;img src=&quot;./logo.png&quot; /&gt;//动态的&lt;img src=&quot;https://www.xxx.com/images/logo.png&quot; /&gt;</code></pre><ul><li>对于动态的内容，webpack 是没有办法处理的。</li></ul><p><strong>打包</strong></p><blockquote><p>打包简单理解就是将多个模块组合成一个模块。当然这多个模块之间有一定的依赖关系，根据他们的依赖关系来组合成一个模块。</p></blockquote><ul><li>src目录下有 3 个 JS 文件，分别是为<code>index.js、a.js、b.js</code></li></ul><pre><code>// index.js 模块import &#123;name,age&#125; from &#39;./a.js&#39;function()console.log(name,age)// a.js 模块import &#123;age&#125; from &quot;./b.js&quot;const name=&quot;icoding&quot;;export &#123;name,age&#125;// b.js内容export const age=33</code></pre><ul><li>如果我们以<code>a.js</code>作为打包的入口文件，最终打包后会生成一个新的 JS 文件，这个新的 JS 文件我们称为出口文件，内容如下</li></ul><pre><code>(() =&gt; &#123;  &quot;use strict&quot;;  console.log(&quot;icoding&quot;, 33);&#125;)();</code></pre><p><strong>注：</strong></p><ul><li>当然，webpack 在打包时，可以是多入口的，可以将<code>index.js</code>和<code>a.js</code>都作为打包的入口，这个时候对应的也会生成两个新的 JS 文件，这两个新的 JS 文件我们称为 出口文件</li></ul><h4 id="Webpack-初体验"><a href="#Webpack-初体验" class="headerlink" title="Webpack 初体验"></a>Webpack 初体验</h4><blockquote><p>接下来我们就利用 Webpack 来完成我们上面所说的打包工作。这里我们重点关注打包的整个流程，关于更多的细节，后面会单独来讲。<br><strong>打包具体流程如下：</strong></p><ul><li>创建项目目录，并初始化 npm 的package.json文件</li><li>准备好需要打包的 JS 文件(index.js、a.js、b.js)</li><li>安装 webpack 需要的包</li><li>执行打包命令，完成打包。</li></ul><p>以上打包流程可以参考<code>webpack</code><a href="https://webpack.docschina.org/guides/getting-started">官网指南</a>，主要考虑后续升级有可能会有部分细节与现在讲的不太一样。</p><ul><li>所以大家后期还是要以官方提供的指南为主。</li></ul></blockquote><ol><li>创建项目，并初始化 npm<blockquote><p>首先创建项目目录文件夹<code>icoding</code>，然后进入当前目录，在当前目录初始化<code>npm</code></p></blockquote></li></ol><pre><code>#第一步：创建icoding文件夹，作为项目的目录文件夹md icoding#第二步：进入icoding文件夹目录cd icoding#第三步：初始化npm，生成package.json文件npm init -y</code></pre><blockquote><ul><li>完成以上命令后，会在当前目录创建<code>icoding</code>文件夹，并在 <code>icoding</code>文件夹生成了<code>package.json</code>文件</li></ul></blockquote><ol start="2"><li>准备好需要打包的 JS 文件<blockquote><p>接下来，我们将在icoding文件夹下，分别新<code>src</code>文件夹和<code>dist</code>文件夹</p></blockquote></li></ol><pre><code>md srcmd dist</code></pre><blockquote><ul><li>src 文件夹：用于存放源代码（需要打包的文件），我们把把<code>index.js，a.js，b.js</code>放到这个目录下</li><li>dist 文件夹：用于存放打包后的代码，利用 <code>webpack</code> 打包生成后的文件会添加到这个目录下</li></ul></blockquote><ul><li><code>index.js、a.js、b.js</code> 的内容如下</li></ul><pre><code>// index.js 模块import &#123; name, age &#125; from &quot;./a.js&quot;;console.log(name, age);// a.js 模块import &#123; age &#125; from &quot;./b.js&quot;;const name = &quot;icoding&quot;;export &#123; name, age &#125;;// b.js内容export const age = 33;</code></pre><ol start="3"><li>安装 webpack 需要的包</li></ol><ul><li>执行以下命令，<strong>本地安装</strong>Webpack 所需要的包，添加到开发依赖</li></ul><pre><code>#webpack 是webpack的核心包#webpack-cli 是命令行运行webpack所需要的包#--save-dev 安装为开发依赖，因为webpack只是用来帮我们打包文件，项目上线是不需要用到他#以下安装并没有指定版本，安装最新的长期支持版本npm install webpack webpack-cli --save-dev#以下是全局安装，不过我们一般会选择本地安装（主要考虑不同的项目对webpack版本的依赖不同）npm install webpack webpack-cli -D -g</code></pre><ul><li>安装后在package.json中添加了如下字段</li></ul><pre><code>&quot;devDependencies&quot;: &#123;    &quot;webpack&quot;: &quot;^5.76.2&quot;,    &quot;webpack-cli&quot;: &quot;^5.0.1&quot;  &#125;</code></pre><ol start="4"><li>执行 webpack 命令打包<blockquote><ul><li>在当前目录下执行以下命令，完成打包工作</li></ul></blockquote></li></ol><pre><code>npx webpack</code></pre><ul><li>打包后在<code>dist</code>目录下，生成了<code>main.js</code>文件，文件内容如下：</li></ul><pre><code>(() =&gt; &#123;  &quot;use strict&quot;;  console.log(&quot;icoding&quot;, 33);&#125;)();</code></pre><p><strong>解析：</strong></p><blockquote><ul><li>当我们执行<code>npx webpack</code>时，<strong>默认</strong>会把当前目录下的<code>src/index.js</code>文件作为打包的<strong>入口文件</strong>，打包后默认生成<code>main.js</code>出口文件，并输出到<code>dist</code>目录。</li></ul></blockquote><ol start="5"><li>npm scripts<blockquote><p>我们也可以在<code>package.json</code>中，配置以下信息，然后执行<code>npm run webpack</code>来完成打包工作</p></blockquote></li></ol><pre><code>&quot;scripts&quot;: &#123;    &quot;webpack&quot;:&quot;webpack&quot;  &#125;,</code></pre><p><strong>注：</strong></p><blockquote><ul><li>如果我们想要指定打包的入口和出口，我们需要通过<code>Webpack</code>的配置文件来配置。</li></ul></blockquote><ol start="6"><li>Webpack 配置文件<blockquote><p>如果不配置，Webpack 怎么知道</p></blockquote></li></ol><ul><li>你想用 Webpack 来打包哪些文件呢？</li><li>打包后的文件要放在哪里呢？</li><li>打包过程中需要做哪些处理？ 比如打包时要不要把代码压缩下，需不需要把 ES6 转换成 ES5 等此类的操作。都需要在配置文件中说明。</li></ul><blockquote><p>配置文件的名称为 <code>webpack.config.js</code> （在当前项目的根目录下自己新建）。</p></blockquote><ul><li>配置文件也是一个模块，后面我们需要将配置的内容<strong>导出去</strong>，供外部使用。</li></ul><p><strong>需要注意的是</strong></p><ul><li>咱们这里的模块导出就不要使用 ES6 的模块了，咱们这里的 Webpack 是要在 <code>Node</code> 平台上运行的，所以我们需要使用 Node 中导入模块的方法。</li></ul><pre><code>// 不需要导出的内容，就写在这里就行// 导出模块module.exports = &#123;&#125;;</code></pre><ul><li>接下来，通过 Webpack 的配置文件来指定打包的入口和出口。<blockquote><p>现在我们在项目的根目录下新建<code>webpack.config.js</code>文件，配置以下信息</p></blockquote></li></ul><pre><code>// webpack是基于node的，所以这里可以使用node.js语法// path模块为node中的内置模块，用来解决路径问题const path = require(&quot;path&quot;);// 模块导出module.exports = &#123;  // 指定打包的入口文件，单入口  entry: &quot;./src/index.js&quot;,  // 指定打包的出口  output: &#123;    // 打包后文件存放的目录，__dirname为node的全局变量，    // 为当前文件所在的绝对路径 C:\Users\EDY\Desktop\test\icoding    // path.resolve()用来将两个参数拼接成当一个完整的路径    path: path.resolve(__dirname, &quot;dist&quot;),    // 打包后文件的名字    filename: &quot;bundle.js&quot;,  &#125;,&#125;;</code></pre><p><strong>以上配置中的</strong></p><ul><li><p><code>entry</code>表示打包的入口文件，Webpack 打包时，会以这个文件作为入口，根据他的关系依赖图，来完成打包。</p></li><li><p><code>output</code>表示打包后资源的出口配置项，他是一个对象，对象中的</p></li><li><p><code>path</code>表示打包后资源的输出路径，他是一个绝对值</p></li><li><p><code>filename</code>表示打包后输出的出口文件名</p></li><li><p><code>filename</code>中的值与path中的值拼接后，得到一个完整的绝对地址，告诉<code>Webpack</code>，打包后输出的出口文件名和位置。</p></li><li><p>然后运行<code>npx webpack</code>完成打包，在 dist 目录中生成了<code>bundle.js</code>文件。</p><blockquote><ul><li>文件内容如下：</li></ul></blockquote></li></ul><pre><code>(() =&gt; &#123;  &quot;use strict&quot;;  console.log(&quot;icoding&quot;, 33);&#125;)();</code></pre><p><strong>注：</strong></p><blockquote><ul><li>在我们执行<code>npx webpack</code>命令的时候，<code>Webpack</code> 会自动寻找 <code>Webpack</code> 的配置文件并使用配置信息进行打包，<strong>如果找不到该文件就会使用默认配置打包</strong>。</li></ul></blockquote><h4 id="总结：Webpack-打包流程"><a href="#总结：Webpack-打包流程" class="headerlink" title="总结：Webpack 打包流程"></a>总结：Webpack 打包流程</h4><blockquote><p>Webpack 打包具体流程如下：</p><ul><li>创建项目目录，并在当前目录下初始化 npm（创建<code>package.json</code>）</li><li>准备好打包的入口文件和出口目录 （在当前目录下创建 src 文件夹和 dist 文件夹，把需要打包的 JS 文件放入 src 目录）</li><li>执行<code>npm i webpack webpack-cli -D</code>命令，本地安装 Webpack，并添加到开发依赖</li><li>在当前目录下新建<code>webpack.config.js</code>文件，配置打包的入口和出口</li><li>最后执行<code>npx webpack</code>完成打包工作，或在<code>package.json</code>中添加以下配置，然后在命令终端执行<code>npm run webpack</code>完成打包工作</li></ul></blockquote><pre><code>&quot;scripts&quot;: &#123;    &quot;webpack&quot;:&quot;webpack&quot;, // 也可以在打包时，指定webpack的配置文件 // &quot;webpack&quot;:&quot;webpack --config 指定的配置文件&quot; //  &quot;webpack&quot;: &quot;webpack --config webpack.config.js&quot;&#125;,</code></pre><h4 id="4、mode-配置项"><a href="#4、mode-配置项" class="headerlink" title="4、mode 配置项"></a>4、mode 配置项</h4><blockquote><p>在 Webpack 打包时，我们可以通过 mode 配置选项，告诉 Webpack 使用相应模式来打包。</p><ul><li>点击 查阅<a href="https://webpack.docschina.org/configuration/mode">官方文档</a></li></ul></blockquote><ul><li>mode 属性有三个值：</li></ul><table><thead><tr><th>属性值</th><th>说明</th></tr></thead><tbody><tr><td>production</td><td>默认值，表示给生产环境打包</td></tr><tr><td>development</td><td>表示给开发环境打包</td></tr><tr><td>none</td><td>表示不使用任何的默认优化选项</td></tr></tbody></table><p><strong>注：</strong></p><blockquote><p>在不同的模式下打包，<code>Webpack</code> 会做不同的优化处理，例如：<code>production </code>模式下会对打包后的代码<strong>进行压缩</strong>。而 <code>none</code> 模式表示对打包后的代码不做任何的处理。</p><p>想要在 <code>Webpack</code> 打包时，根据对应的模式来打包，需要先将 <code>mode</code> 属性设置为对应值。</p></blockquote><p>设置方式有两种：</p><ul><li>方式一：在<code>webpack.config.js</code>文件的配置对象上添加<code>mode</code>选项</li></ul><pre><code>module.exports = &#123;  mode: &quot;development&quot;, // 打包模式，还可以是 production  或 none&#125;;</code></pre><ul><li>方式二：从<code>CLI</code>（命令行）参数中传递</li></ul><pre><code>npx webpack --mode=development</code></pre><p><strong>注：</strong></p><ul><li>如果没有设置对应的<code>mode</code>选项，则默认使用<code>production</code>模式打包。如果以上两种方式同时设置，则<strong>优先</strong>以<code>CLI</code> 命令行参数中传递的模式为主。</li></ul><blockquote><p>根据 mode 变量更改打包行为</p><ul><li>如果想根据<code>CLI</code>命令行参数中的 mode 值来改变打包的行为，则需要将<code>webpack.config.js</code>中的配置导出为<strong>函数</strong>，而不是对象。</li><li>具体如下：</li></ul></blockquote><pre><code>const path = require(&quot;path&quot;);// 配置对象const config = &#123;  entry: &quot;./src/a.js&quot;,  output: &#123;    path: path.resolve(__dirname, &quot;dist&quot;),    filename: &quot;bundle.js&quot;,  &#125;,&#125;;// argv 表示命令行传过来的参数对象（参数以键值分别为argv对象的属性和值）// env 用来接受环境变量module.exports = (env, argv) =&gt; &#123;  console.log(env);  console.log(argv);  if (argv.mode === &quot;development&quot;) &#123;    // 更多配置，可以在这里更改config对象中属性的值实现    console.log(&quot;开发模式打包&quot;);    // 开发模式下把打包入口改为a.js    config.entry = &quot;./src/a.js&quot;;  &#125;  if (argv.mode === &quot;production&quot;) &#123;    // 更多配置，可以在这里更改config对象中属性的值实现    console.log(&quot;生产模式打包&quot;);    config.entry = &quot;./src/b.js&quot;;  &#125;  return config;&#125;;</code></pre><p><strong>配置解析</strong></p><blockquote><ul><li>如果执行命令时传入的<code>--mode=development</code>则为开发模式打包，打包入口文件为<code>./src/a.js</code></li><li>如果执行命令时传入的<code>--mode=production</code>则为生产模式打包，打包入口文件为<code>./src/b.js</code></li></ul></blockquote><blockquote><p>当我们在命令行执行<code>npx webpack --mode=development --env global=local</code>时，表示以开发模式打包，打包入口为<code>./src/a.js</code>文件，箭头函数中的<code> env</code> 与 <code>argv</code> 对应的值如下</p></blockquote><pre><code>// evn对应的对象&#123; WEBPACK_BUNDLE: true, WEBPACK_BUILD: true, global: &#39;local&#39; &#125;// argv对应的对象&#123;  mode: &#39;development&#39;,  env: &#123; WEBPACK_BUNDLE: true, WEBPACK_BUILD: true, global: &#39;local&#39; &#125;&#125;</code></pre><blockquote><ul><li>注：<a href="https://webpack.docschina.org/guides/environment-variables/">环境变量</a></li></ul></blockquote><h3 id="二、Webpack-的入口（entry）配置"><a href="#二、Webpack-的入口（entry）配置" class="headerlink" title="二、Webpack 的入口（entry）配置"></a>二、Webpack 的入口（entry）配置</h3><blockquote><p>前面我们已经学习了简单的 Webpack 资源入口与出口的配置，接下来我们将深入学习 Webpack 的资源入口 entry 的配置。</p><ul><li>我们以下面这个<code>Webpack</code>配置文件来展开讲解</li></ul></blockquote><pre><code>const path = require(&quot;path&quot;);module.exports = &#123;  entry: &quot;./src/index.js&quot;,  output: &#123;    path: path.resolve(__dirname, &quot;dist&quot;),    filename: &quot;bundle.js&quot;,  &#125;,  mode: &quot;none&quot;,&#125;;</code></pre><ul><li>上面配置表示从当前根目录下的<code>./src/index.js</code>文件开始打包，打包后生成的<code>bundle.js</code>文件放在根目录下的<code>dist</code>文件夹下。</li><li>上面的<code>entry</code>表示打包入口，我们看到他是一个相对路径。实际上上面配置还省略了一个配置参数<code>context</code>，<code>Webpack</code>官方称为基础目录。</li></ul><h4 id="context-基础目录"><a href="#context-基础目录" class="headerlink" title="context 基础目录"></a>context 基础目录</h4><blockquote><ul><li><code>context</code>表示入口的基础目录，他的值是一个字符串，表示一个绝对路径，表示资源入口<code>entry</code>是以哪个目录为起点的。</li><li>在实际开发中，通常不会设置<code>context</code>,不设置时，<strong>他的默认值为当前工作目录的绝对路径</strong>。因为我们打包时，都是在当前工作目录下开始打包的，所以默认值并不会造成地址出错。</li><li><code>context</code>的值与entry的值<strong>拼接</strong>起来，就是 Webpack 的打包入口文件了</li></ul></blockquote><ul><li>以下配置表示从工程目录的<code>src</code>文件夹下的<code>index.js</code>文件开始打包</li></ul><pre><code>// 导入path模块const path = require(&quot;path&quot;);module.exports = &#123;  // 以下可以理解为context的默认值（当前工程目录的绝对路径），所以也可以省略不写  context: path.resolve(__dirname, &quot;&quot;),  entry: &quot;./src/index.js&quot;,&#125;;</code></pre><blockquote><ul><li>打包后，默认生成打包后的出口文件<code>main.js</code>，保存在当前目录的<code>dist</code>目录下，如果当前目录下没有<code>dist</code>目录，则会自动创建<code>dist</code>目录</li></ul></blockquote><h4 id="入口-entry"><a href="#入口-entry" class="headerlink" title="入口 entry"></a>入口 entry</h4><blockquote><ul><li>entry 表示 Webpack 资源入口文件，也就是打包的入口文件，入口文件的路径需要用<strong>相对路径</strong>来表示。</li><li>entry 的值可以是一个字符串，也可是<strong>数组、对象、函数、描述符</strong>形式。当然不同的形式也有不同的含义，接下来我们就来 一 一展开讲解。</li></ul></blockquote><ol><li><p>入口 entry 的值是字符串</p><blockquote><p>入口 entry 是字符串形式，我们前面使用过了，表示的就是打包的入口 JS 文件，所以就不再重复讲解。</p></blockquote></li><li><p>入口 entry 的值是数组</p><blockquote><p>如果 entry 的值是一个数组，那数组中的<strong>最后一个文件</strong>为资源的入口文件，数组的其余文件会被<strong>预先构建</strong>到入口文件中。</p></blockquote></li></ol><blockquote><p>基本用法</p></blockquote><ul><li>在当前目录下的src文件目录下有三个文件，分别为<code>a.js，b.js，index.js</code>，文件内容如下</li></ul><pre><code>// a.jsconsole.log(&quot;a.js中内容&quot;);// b.jsconsole.log(&quot;b.js中内容&quot;);// index.jsconsole.log(&quot;index.js中内容&quot;);</code></pre><ul><li>以下是 webpack 的配置文件，下面配置相当于在<code>index.js</code>文件中先用<code>import</code>导入<code>a.js</code>与<code>b.js</code>，然后再把<code>index.js</code>文件作为入口文件打包</li></ul><pre><code>// webpack.config.jsconst path = require(&quot;path&quot;);module.exports = &#123;  entry: [&quot;./src/a.js&quot;, &quot;./src/b.js&quot;, &quot;./src/index.js&quot;],&#125;;</code></pre><ul><li>上面，如同以下写法</li></ul><pre><code>// index.jsimport &quot;./a.js&quot;;import &quot;./b.js&quot;;console.log(&quot;index.js中内容&quot;);// webpack.config.jsconst path = require(&quot;path&quot;);module.exports = &#123;  entry: &quot;./src/index.js&quot;,&#125;;</code></pre><ul><li>打包后，默认会生成出口文件<code>main.js</code>，并保存在当前目录的<code>dist</code>目录下。</li><li>如果当前目录下没有<code>dist</code>目录，则会自动创建<code>dist</code>目录</li></ul><ol start="3"><li>入口<code>entry</code>的值是对象</li></ol><ul><li>如果一个项目有多个入口，我们通常把<code>entry</code>的值设置为一个对象，表示<strong>多入口配置</strong>。</li><li>对象有多少个属性，就表示有多少个入口。</li><li>打包后，<strong>对象的属性名</strong>会作为生成后对应的出口文件的名称。</li><li>前面我们讲的字符串和数组形式的值，都是属于单入口，打包后只会生成一个 JS 文件。而多入口打包后会生成多个 JS 文件。</li></ul><blockquote><p>基本用法</p></blockquote><ul><li>在当前目录下的<code>src文</code>件目录下有三个文件，分别为<code>a.js，b.js，index.js，login.js</code></li><li>以下是 Webpack 的配置文件，表示多入口打包，entry 对应的对象有多少个属性，就有多少个入口</li></ul><pre><code>const path = require(&quot;path&quot;);module.exports = &#123;  entry: &#123;    app: [&quot;./src/a.js&quot;, &quot;./src/b.js&quot;, &quot;./src/index.js&quot;],    login: &quot;./src/login.js&quot;,  &#125;,&#125;;</code></pre><blockquote><p><strong>上面配置，表示有两个入口</strong></p></blockquote><ul><li>第一个入口是<code>./src/index.js</code>文件，打包前会先将<code>a.js</code>与<code>b.js</code>预先构建到index.js中</li><li>第二个入口是<code>./src/login.js</code>文件。<blockquote><p>打包后，对象的属性名会作为生成后对应的出口文件的名称。</p></blockquote></li><li><code>entry</code>中<code>app</code>属性对应的入口文件打包后生成的出口文件名为<code>app.js</code></li><li><code>entry</code>中<code>login</code>属性对应的入口文件打包后生成的出口文件名为<code>login.js</code></li><li>所以以上配置打包后会，默认在当前目录的<code>dist</code>目录中生成两个出口文件，分别为<code>app.js</code>和<code>login.js</code></li></ul><ol start="4"><li>入口 entry 值是函数</li></ol><ul><li>entry 的值是一个函数，则 Webpack 的入口entry的值最终为这个函数的<strong>返回值</strong>。</li><li>函数的返回值可以是<strong>字符串、数组、对象</strong>。</li><li>当我们在设置 entry 的值时，<strong>如果需要处理一些额外的逻辑</strong>，就可以把entry值设为函数<blockquote><p>基本用法</p></blockquote></li></ul><pre><code>const path = require(&quot;path&quot;);module.exports = &#123;  // 函数的返回值作为 entry的值  entry() &#123;    return &#123;      app: &quot;./src/index.js&quot;,      login: &quot;./src/login.js&quot;,    &#125;;  &#125;,&#125;;</code></pre><blockquote><p>以上写法等同于以下写法</p></blockquote><pre><code>const path = require(&quot;path&quot;);module.exports = &#123;  entry: &#123;    app: &quot;./src/index.js&quot;,    login: &quot;./src/login.js&quot;,  &#125;,&#125;;</code></pre><ul><li>关于 entry 入口是描述符形式，相对有些复杂，入门阶段暂时不需要了解</li></ul><ol start="5"><li>Webpack 入口总结<blockquote><p>Webpack 的入口，表示 Webpack 从那个 JS 文件开始打包。Webpack 打包时，通过context和entry这两个参数的值找到需要打包的入口文件。</p></blockquote></li></ol><ul><li><code>context</code>是一个基础目录，他的值是一个字符串，表示一个绝对路径（默认值为前工程目录的绝对路径），表示资源入口 entry 是以那个目录为起点的。</li><li><code>entry</code>是一个相对路径，它的值与context的值拼接起来，就是Webpack打包的入口文件了。</li></ul><p><strong>单入口与多入口</strong></p><ul><li>Webpack 的的打包入口，可以是单一入口，也可以是多入口，可以通过 entry 的值来设置。</li></ul><p><strong>entry 的值的不同形式</strong></p><table><thead><tr><th>entry 的值类型</th><th>描述</th></tr></thead><tbody><tr><td>字符串</td><td>表示单入口打包，打包后，默认生成main.js文件，保存在当前目录的dist目录</td></tr><tr><td>数组</td><td>表示单入口打包，数组的最后一个文件为打包的入口文件，在打包前会先把数组的其余文件预先加载到入口文件中；打包后，默认生成<code>main.js</code>文件，保存在当前目录的dist目录</td></tr><tr><td>对象</td><td>如果是多入口打包，可以将值设为对象类型。对象的每个属性对应一个入口。打包后，默认情况下，对象的属性名会是出口文件名，最后这些出口文件统一保存在当前目录的dist目录</td></tr><tr><td>函数</td><td>如果入口文件的设置涉及到一些逻辑处理，可以把值设为函数。函数的返回值可以是字符串、数组、对象中的任意一种形式。最后打包的结果与上面三种形式单独写的效果是一致的。</td></tr></tbody></table><h3 id="三、Webpack-的出口（output）配置"><a href="#三、Webpack-的出口（output）配置" class="headerlink" title="三、Webpack 的出口（output）配置"></a>三、Webpack 的出口（output）配置</h3><blockquote><p>前面我们在学习 Webpack 的入口配置时，并没有设置对应的出口配置，而是采用的默认值。接下来我们就来深入学习 Webpack 的出口（output）配置。</p><ul><li>我们以下面这个 Webpack 配置文件来展开讲解。</li></ul></blockquote><pre><code>const path = require(&quot;path&quot;);module.exports = &#123;  entry: &quot;./src/index.js&quot;,  output: &#123;    path: path.resolve(__dirname, &quot;dist&quot;),    filename: &quot;bundle.js&quot;,  &#125;,  mode: &quot;none&quot;,&#125;;</code></pre><p><strong>注：</strong></p><blockquote><p>以上配置文件告诉<code>Webpack</code>，以当前目录下的<code>src/index.js</code>作为打包的入口文件，打包后，生成<code>bundle.js</code>文件，并将该文件保存在当前目录下的<code>dist</code>目录中</p><ul><li>以上配置文件中的<code>output</code>就是资源的出口配置项。<code>output</code>是一个对象，他身上有以下几个重要的属性，也是我们接下来学习的重心。</li></ul></blockquote><p><strong>output 对象的属性</strong></p><table><thead><tr><th>属性</th><th>描述</th></tr></thead><tbody><tr><td>path</td><td>资源打包后的输出位置</td></tr><tr><td>filename</td><td>表示打包后生成的出口文件名，可以是一个文件名，也可以是一个相对地址</td></tr><tr><td>publicPath</td><td>表示打包后生成的资源的访问路径</td></tr><tr><td>chunkFilename</td><td>用来设置入口文件打包过程中生成的其它的模块名</td></tr></tbody></table><blockquote><ul><li>output 对象身上的更多属性，参考<a href="https://webpack.docschina.org/configuration/output/#outputpath">官方文档</a></li></ul></blockquote><h4 id="output-path"><a href="#output-path" class="headerlink" title="output.path"></a>output.path</h4><blockquote><p><code>output.path</code>：表示资源打包后的输出位置，该位置需要一个绝对路径。</p></blockquote><ul><li>如果不设置，默认值为当前目录下的dist目录。</li></ul><pre><code>const path = require(&quot;path&quot;);module.exports = &#123;  entry: &quot;./src/index.js&quot;,  output: &#123;    // 以下值相当于是path的默认值，如果输出地址与默认地址一样，也可以省略不写    // path:path.resolve(__dirname,&quot;dist&quot;),    filename: &quot;bundle.js&quot;,  &#125;,&#125;;</code></pre><h4 id="output-filename"><a href="#output-filename" class="headerlink" title="output.filename"></a>output.filename</h4><ul><li><code>output.filename</code>：表示打包后生成的出口文件名。</li><li><code>filename</code>的值可以是一个<strong>文件名</strong>，如：<code>bundle.js</code>,也可以是一个<strong>相对地址</strong>，如：<code>&quot;./js/bundle.js&quot;</code>。</li><li>这些出口文件最终会被保存到<code>output.path</code>选项指定的目录下。<blockquote><p>单入口打包写法</p></blockquote></li></ul><pre><code>const path = require(&quot;path&quot;);module.exports = &#123;  entry: &quot;./src/index.js&quot;,  output: &#123;    path: path.resolve(__dirname, &quot;dist&quot;),    filename: &quot;[name].js&quot;,    //或者自己取名    // filename: &quot;bundle.js&quot;  &#125;,&#125;;</code></pre><p><strong>配置解析：</strong></p><ul><li>第一种写法<code>filename:&quot;[name].js&quot;</code>中的<code>name</code>的值是默认值<code>main</code></li><li>以上配置表示以当前目录下的<code>./src/index.js</code>文件作为打包入口文件，打包后生成<code>main.js</code>文件，保存在当前目录的<code>dist</code>目录下。</li></ul><blockquote><p>如果针对的是多入口打包，我们需要为每一个出口文件设置一个唯一的名称，可以使用以下写法</p></blockquote><pre><code>const path = require(&quot;path&quot;);module.exports = &#123;  entry: &#123;    app: &quot;./src/index.js&quot;,    login: &quot;./src/login.js&quot;,  &#125;,  output: &#123;    path: path.resolve(__dirname, &quot;dist&quot;),    filename: &quot;[name].js&quot;,    // 也支持以下写法：    //  filename:&quot;[name]/index.js&quot;  &#125;,&#125;;</code></pre><p><strong>配置解析</strong></p><blockquote><ul><li>上面配置项<code>filename:&quot;[name].js</code>“ 中的方括号<code>[]</code>代表<strong>占位符</strong>，里面的<code>name</code>表示特定的动态值，与<code>entry</code>对象中的属性名一一对应，用来表示打包生成后出口的文件名。</li><li><strong>第一种写法</strong>表示有两个打包入口，打包后，对应生成两个出口文件，分别为<code>app.js</code>和<code>login.js</code>，最终这两个文件会保存在当前目录的<code>dist</code>目录下。</li><li>第二种写法<code>filename:&quot;[name]/index.js&quot;</code>，在文件打包后，文件名都是<code>index.js</code>，他们会被分别保存在<code>dist</code>目录下的<code>app</code>和<code>login</code>文件夹中</li></ul></blockquote><blockquote><p><strong>温馨提示</strong></p></blockquote><ul><li>上面<code>Wepack</code>配置中，<code>filename</code>值中的方括号<code>[]</code>中的特定动态值除了<code>name，还有id、hash、fullhash、chunkhash、contenthash</code>，分别表示不同的动态值，他们有什么区别，后面我们单独来介绍</li></ul><h4 id="output-publicPath"><a href="#output-publicPath" class="headerlink" title="output.publicPath"></a>output.publicPath</h4><blockquote><p><code>output.publicPath</code>表示的是资源的<strong>访问路径</strong>。<br><strong>注意区分：output.path 与 output.publicPath</strong></p></blockquote><ul><li><code>output.path</code>表示的打包后的<strong>资源输出位置</strong>，也就是资源存放在磁盘中的位置。</li><li>资源存放在磁盘后，如果我们想要<strong>通过浏览器来访问该资源</strong>，这时候就需要指定该资源的访问路径，这个访问路径就是用<code>output.publicPath</code>来指定。</li></ul><blockquote><p>在实际的开发中，我们通常需要设置<code>output.publicPath</code>的值。他的值可以是<strong>函数</strong>与<strong>字符串</strong>两种形式，通常我们使用字符串形式的值，所以我们这里也只讲字符串类型的值。</p><p><code>output.publicPath</code>可以设置成以下几种类型的值</p><ul><li>具体参考<a href="https://webpack.docschina.org/configuration/output/#outputpublicpath">官方文档</a></li></ul></blockquote><table><thead><tr><th>值</th><th>说明</th></tr></thead><tbody><tr><td>“auto”</td><td>默认值，表示资源调用者与被调用者在同一目录下</td></tr><tr><td><strong>相对 URL</strong> 地址(relative URL)</td><td>对于当前浏览的 HTML 页面解析</td></tr><tr><td><strong>相对于服务器</strong> URL（Server-relative URL）</td><td>值以“&#x2F;“开头，表示访问的资源以当前页面的服务器地址根目录作为基础路径</td></tr><tr><td><strong>绝对 URL</strong>（absolute URL）</td><td>值以”http”协议开始，代表一个 HTTP 协议的绝对地址</td></tr><tr><td><strong>相对于协议</strong>的 URL（protocol-relative URL）</td><td>相对 HTTP 协议地址，以<code>//</code> 开头</td></tr></tbody></table><ol><li>publicPath 值为”auto“<blockquote><p><code>output.publicPath</code>的默认值为”auto”,表示资源调用者与被调用者在<strong>同一目录下</strong><br><strong>案例演示</strong></p></blockquote></li></ol><ul><li>在项目根目录下，执行<code>npm init -y</code>初始化 <code>package.json</code> 文件</li><li>在项目根目录下，安装 webpack</li></ul><blockquote><p><code>src</code>文件夹,中有<code>a.js</code>和<code>index.js</code>两个文件，文件内容如下：</p></blockquote><pre><code>// a.jsconsole.log(&quot;a.js中内容&quot;)// index.jsimport (&#39;./a.js&#39;);console.log(&quot;index.js&quot;)</code></pre><ul><li><code>webpack.config.js</code>配置文件，内容如下</li></ul><pre><code>const path = require(&quot;path&quot;);module.exports = &#123;  entry: &quot;./src/index.js&quot;,  output: &#123;    path: path.resolve(__dirname, &quot;dist&quot;),    filename: &quot;bundle.js&quot;,  &#125;,&#125;;// 以 src/index.js 为打包入口文件，打包后生成bundle.js文件，文件保存在当前目录的dist目录下，当前没有dist目录，在打包后会自动创建</code></pre><ul><li><code>index.html</code>文件内容如下</li></ul><pre><code>&lt;body&gt;  &lt;!-- 导入打包后dist目录下的bundle.js文件--&gt;  &lt;script src=&quot;./dist/bundle.js&quot;&gt;&lt;/script&gt;&lt;/body&gt;</code></pre><p><strong>分析打包后结果</strong></p><ul><li>打包后，在根目录的<code>dist</code>目录中多了两个<code>JS</code>文件：<code>bundle.js</code>与<code>85.bundle.js</code></li><li><code>bundle.js</code>是入口<code>./src/index.js</code>文件打包后生成的<code>output.filename</code>指定的输出文件。</li><li><code>85.bundle.js</code>是<code>./src/index.js</code>文件中通过<code>import (&#39;./a.js&#39;)</code>加载的异步资源文件，被单独打包成了<code>85.bundle.js</code>文件。</li><li>最后，我们在通过<code>VSCode</code>在浏览器中打开<code>index.html</code>文件，在控制台输出以下结果</li></ul><pre><code>index.jsa.js中内容</code></pre><ul><li>我们切换到控制台的<code>NetWork</code>选项，如下图<img src="autoUrl-network.png"></li></ul><p><strong>注：</strong></p><ul><li>可以看到<code>bundle.js</code> 与 <code>85.bundle.js</code>在同一访问目录下。这是因为<code>output:publicPath</code>的默认值是<code>auto</code>，<code>Webpack</code>自行决定其访问路径，<strong>默认</strong>（资源调用者与被调用者在同一目录下）。</li><li>在<code>index.html</code>页面加<code>bundle.js</code>，在解析<code>bundle.js</code>时，发起请求加载<code>85.bundle.js</code>文件。这里<strong>资源调用者</strong>是<code>bundle.js</code>，<strong>被调用者</strong>是<code>85.bundle.js</code></li></ul><ol start="2"><li>publicPath 值为”相对 URL”<blockquote><p>当<code>output.publicPath</code>的值以<code>&quot;./&quot;、”./js&quot;、“../&quot;</code>等开头，表示的是相对<code>URL</code>，其相对于当前浏览的<code>HTML</code>页面解析。</p></blockquote></li></ol><ul><li>接下来，我们通过案例来演示<code>publicPath</code>值为相对 URL（relative URL）时的情况</li></ul><p><strong>代码演示</strong></p><ul><li>在上面案例的基础上，我们把配置文件中设置<code>publicPath</code>的值改为<code>./js/</code>，具体如下</li></ul><pre><code>const path = require(&quot;path&quot;);module.exports = &#123;  entry: &quot;./src/index.js&quot;,  output: &#123;    path: path.resolve(__dirname, &quot;dist&quot;),    filename: &quot;bundle.js&quot;,    publicPath: &quot;./js/&quot;,  &#125;,&#125;;</code></pre><ul><li>重新执行<code>npx webpack</code>打包，发现项目的目录和刚才的一样，并没有任何改变，不过这一次，我们在浏览器中打开<code>index.html</code>文件时，控制台抛出了 <code>404</code> 错误</li><li>我们切换到控制台的<code>NetWork</code>选项，如下图<img src="相对url-network.png"></li></ul><p><strong>注：</strong></p><ul><li>观察上图，<code>index.html</code>页面的地址为<code>http://127.0.0.1:5500/index.html</code>，而<code>85.bundle.js</code>文件的访问地址是<strong>相对于<code>index.html</code>页面</strong>，所以其访问地址为<code>http://127.0.0.1:5500/js/85.bundle.js</code>因为我们项目中没有<code>js</code>这个文件夹，所以找不到对应的文件。</li></ul><ol start="3"><li>相对于服务器 URL（Server-relative URL）<blockquote><p>当<code>output.publicPath</code>的值以<code>“/&quot;</code>开头，表示访问的资源以当前页面的<strong>服务器地址根目录</strong>作为基础路径。</p></blockquote></li></ol><p><strong>代码演示</strong></p><blockquote><p>在上面案例的基础上，把<code>output.publicPath</code>的值，改成<code>&quot;/&quot;</code>开头，代码如下：</p></blockquote><pre><code>const path = require(&quot;path&quot;);module.exports = &#123;  entry: &quot;./src/index.js&quot;,  output: &#123;    path: path.resolve(__dirname, &quot;dist&quot;),    filename: &quot;bundle.js&quot;,    publicPath: &quot;/&quot;,  &#125;,&#125;;</code></pre><ul><li>重新执行<code>npx webpack</code>打包，打包后在浏览器中打开<code>index.html</code>页面。发现控制报了 404 错误。</li><li>切换到控制台的<code>NetWork</code>选项，如下图</li></ul><p><strong>注：</strong></p><ul><li>观察上图，<code>index.html</code>页面的访问地址是<code>http://127.0.0.1:5500/index.html</code>，<code>85.bundle.js</code>文件地址是相对于 <code>index.html</code>页面，所以访问地址为<code>http://127.0.0.1:5500/85.bundle.js</code>。因为当前项目根目录下没有该文件，所发抛出 <code>404</code> 错误。<blockquote><ul><li>当我们把<code>85.bundle.js</code>文件从<code>dist</code>文件夹下剪切到根目录下时，刷新<code>http://127.0.0.1:5500/index.html</code>页面时，报错消失了，控制台正确输出了内容。</li></ul></blockquote></li></ul><ol start="4"><li>绝对 URL（absolute URL）<blockquote><p>当<code>output.publicPath</code>的值是以 <code>HTTP</code> 协议名开始的地址，我们称为绝对 URL。web中常见的协议名有<code>HTTP</code>和<code>HTTPS</code><br>如果我们<strong>静态资源</strong>是分布在<strong>两台服务器</strong>上，这个时候我们就需要把<code>output.publicPath</code>的值设置为以<code>HTTP</code>协议开头的绝对地址。</p><p>这样做的目的是加快资源的下载速度，因为浏览器只能为每一个域名维护了<code>6</code>个<code>TCP</code>连接，也就一次性最多支持 <code>6</code> 个并发请求。</p><p>如果资源放在多个服务器上，比如 3 个，那相当于我一次性可以并行发送 18 个请求来获取资源。相当于之前只有一个帮你干活，现在有 3 个人，你说快吗 ？</p></blockquote></li></ol><p><strong>代码演示</strong></p><ul><li>在上面案例的基础上，把<code>output.publicPath</code>的值，改成以 <code>http</code> 协议开头的绝对地址，代码如下：</li></ul><pre><code>const path = require(&quot;path&quot;);module.exports = &#123;  entry: &quot;./src/index.js&quot;,  output: &#123;    path: path.resolve(__dirname, &quot;dist&quot;),    filename: &quot;bundle.js&quot;,    publicPath: &quot;https://web.arryblog.com/&quot;,  &#125;,&#125;;</code></pre><ul><li>重新执行npx webpack打包，打包后在浏览器中打开index.html页面。发现控制报了 404 错误。</li><li>切换到控制台的NetWork选项，如下图<img src="绝对url-network.png"></li></ul><p><strong>注：</strong></p><ul><li>观察上图，我们发现，<code>85.bundle.js</code>文件的访问地址为<code>https://web.arryblog.com/85.bundle.js</code>。因为服务器上没有这个文件，所以抛出 404 错误。接下来我把打包好的<code>85.bundle.js</code>文件上传到服务器根目录下，重新刷新页面，报错消失了，资源被正常加载了。</li></ul><ol start="5"><li>相对于协议的 URL（protocol-relative URL）<blockquote><p>在 web 端相对于协议的 URL，通常指的是相对于HTTP协议地址以<code>//</code>开头的地址。与绝对的 HTTP 协议地址相比，它省略了前面的<code>https:或http:</code>。</p><p>通常情况下，我们的网站可以同时以 http 或 https 两种协议来访问。在使用相对于协议的 URL 时，浏览器会<strong>将当前页面使用的协议名称</strong>与<strong>相对协议地址</strong>拼接得到完整的地址。得到的完整地址就是http或https开头的绝对地址。</p></blockquote></li></ol><p><strong>代码演示</strong></p><blockquote><p>在上面案例的基础上，把<code>output.publicPath</code>的值，改成相对于协议的 <code>URL </code>地址，代码如下：</p></blockquote><pre><code>const path = require(&quot;path&quot;);module.exports = &#123;  entry: &quot;./src/index.js&quot;,  output: &#123;    path: path.resolve(__dirname, &quot;dist&quot;),    filename: &quot;bundle.js&quot;,    publicPath: &quot;//web.arryblog.com/&quot;,  &#125;,&#125;;</code></pre><ul><li>重新执行npx webpack打包，打包后在浏览器中打开<code>index.html</code>页面，控制台能正常输出结果。</li><li>切换到控制台的NetWork选项，如下图<img src="相对协议-network.png"></li></ul><p><strong>注：</strong></p><ul><li>观察上图，我们发现<code>85.bundle.js</code>文件的访问地址前面自动中上与<code>index.html</code>页面相同的<code>http</code>协议名。</li></ul><ol start="6"><li>output.publicPath 配置总结<blockquote><p><code>output.publicPath</code>可以设置成以下 5 种类型的值</p></blockquote></li></ol><pre><code>// 默认值 auto，可以省略，表示调用者与被调用者在同一目录下publicPath: &quot;auto&quot;;// 相对URL，相对于当前浏览器访问的HTML页面publicPath: &quot;./js&quot;;// 相对服务器URL，相当于当前浏览器访问的HTML页面所在的服务器地址的根目录publicPath: &quot;/dist&quot;;// 绝对URLpublicPath: &quot;http://web.arryblog.com/&quot;;// 相对于协议的URL浏览器会自动将访问的HTML页面的协议添加到以下地址前，拼接成一个完整的绝对地址publicPath: &quot;//web.arryblog.com/&quot;;</code></pre><h4 id="output-chunkFilename"><a href="#output-chunkFilename" class="headerlink" title="output.chunkFilename"></a>output.chunkFilename</h4><blockquote><p><code>output.chunkFilename</code>是用来表示打包后生成的文件名，不过他与<code>filename</code>是有区别的。</p></blockquote><ul><li><p><code>filename</code>表示入口文件打包后生成的对应的出口文件的文件名，而<code>output.chunkFilename</code>表示的是入口文件打包过程中生成的<strong>其它的模块名</strong>。</p></li><li><p>比如前面例子中，<code>index.js</code>文件里有<code>import(&#39;./a.js&#39;)</code>，其中<code>a.js</code>就被单独打包成了<code>85.bundle.js</code>，这个名称就是默认的<code>output.chunkFilename</code></p></li><li><p><code>ouput.chunkFilename</code>的值也支持占位符，可以设置成如下：</p></li></ul><pre><code>output.chunkFilename = &quot;[id].js&quot;;// [] 表示占位符 id为随机生成的数字</code></pre><p><strong>代码演示</strong></p><ul><li>在上面案例的基础上，在<code>output</code>对象上添加<code>chunkFilename</code>属性，具体代码如下：</li></ul><pre><code>const path = require(&quot;path&quot;);module.exports = &#123;  entry: &quot;./src/index.js&quot;,  output: &#123;    path: path.resolve(__dirname, &quot;dist&quot;),    filename: &quot;bundle.js&quot;,    publicPath: &quot;auto&quot;,    chunkFilename: &quot;[id].js&quot;,  &#125;,&#125;;</code></pre><p><strong>注：</strong></p><ul><li>在当前目录下执行<code>npx webpack</code>打包后，在当前目录的<code>dist</code>文件夹下会生成<code>bundle.js</code>和<code>85.js</code></li><li>其中<code>85.js</code>就是<code>index.js</code>中通过<code>import (&#39;./a.js&#39;)</code>引入的<code>a.js</code>文件被单独打包后形成的。他的名称就是通过<code>chunkFilename</code>属性来设置的。</li></ul><h4 id="has、fullhash、chunkhash、contenthash-的区别"><a href="#has、fullhash、chunkhash、contenthash-的区别" class="headerlink" title="has、fullhash、chunkhash、contenthash 的区别"></a>has、fullhash、chunkhash、contenthash 的区别</h4><blockquote><p>在前面学习<code>output.filename</code>属性的配置和刚学习的<code>output.chunkFilename</code>属性配置时，我们提到了下面这种写法</p></blockquote><pre><code>output.filename = &quot;[name].js&quot;;output.chunkFilename: &quot;[id].js&quot;;</code></pre><p><strong>注：</strong></p><blockquote><ul><li>我们知道<code>[]</code>方括号表示一个占位符，<code>name</code>和<code>id</code>表示一个特定的动态值。</li><li>其实，占位符中还有<code>hash、fullhash、chunkhash、contenthash</code>值，这些值都是根据文件内生成的<strong>唯一的</strong><code>hash</code> 值。<br>这些值主要与浏览器的缓存行为有关。所以我们先来了解下浏览器的缓存</li></ul></blockquote><ol><li><p>浏览器缓存</p><blockquote><p>当浏览器访问一个 HTML 页面时，HTML 页面会加载 JS、CSS 和图片等外部资源，这需要花费一定的加载时间。</p><p>如果页面上有些外部资源<strong>长时间并没有什么变化</strong>，比如：Logo 图片，CSS 文件。那我们就可以在发送第一次请求后，把这部分资源存储在本地的磁盘上，这就是<strong>缓存</strong>。</p><ul><li>下次我们再打开这个网页时，就<strong>不需要再发送请求</strong>到服务端获取这部分资源，而是可以直接在本地的磁盘取回缓存的 Logo 图片和 CSS 文件。这样大大的提高了网站资源的加载速度。</li></ul><p>浏览器如何知道该资源是从本地磁盘中取，还是从网络服务器请求下载呢 ？</p><ul><li>这需要服务端在响应头中添加<code>Cache-Control</code>字段来设置。</li></ul></blockquote></li><li><p><code>Cache-Control</code> 响应头</p><blockquote><p><code>Cache-Control</code>的常用值有以下几个，用来设置资源的可缓存性</p></blockquote></li></ol><table><thead><tr><th>属性值</th><th>说明</th></tr></thead><tbody><tr><td>public</td><td>资源经过的任意方（如：客户端、代理服务器）都可以缓存</td></tr><tr><td>private</td><td>只有发起请求的浏览器（用户端）可以缓存</td></tr><tr><td>no-cache</td><td>可以缓存，但每次使用前必需要发请求到服务端验证是否可以</td></tr><tr><td>no-store</td><td>不缓存请求和响应的任何内容</td></tr><tr><td>max-age</td><td>整数，单位是毫秒，表示缓存的过期时间</td></tr></tbody></table><p><strong>代码演示</strong></p><blockquote><p>接下来我们通过搭建node服务，来给大家演示下缓存</p><ul><li>新建<code>icoding</code>文件夹，在当前文件夹下有两个文件，分别为<code>index.html</code>和<code>server.js</code></li><li><code>index.html</code>文件夹内容如下，在访问 <code>index.html</code> 页面时，会发起请求加载 <code>JS</code> 文件</li></ul></blockquote><pre><code>&lt;body&gt;  index.html页面内容  &lt;script src=&quot;http://127.0.0.1:8887/js&quot;&gt;&lt;/script&gt;&lt;/body&gt;</code></pre><ul><li><code>server.js</code>文件内容如下</li></ul><pre><code>const http = require(&quot;http&quot;);const fs = require(&quot;fs&quot;);http  .createServer((request, response) =&gt; &#123;    const url = request.url;    if (url === &quot;/&quot;) &#123;      // 返回html页面      const html = fs.readFileSync(&quot;./index.html&quot;);      response.writeHead(200, &#123;        &quot;Content-Type&quot;: &quot;text/html;charset=utf-8&quot;,      &#125;);      response.end(html);    &#125; else if (url === &quot;/js&quot;) &#123;      // 返回js代码      response.writeHead(200, &#123;        &quot;Content-Type&quot;: &quot;text/html;charset=utf-8&quot;,        // ---------------------------        &quot;Cache-Control&quot;: &quot;no-cache&quot;,        // ---------------------------      &#125;);      response.end(&#39;console.log(&quot;hello world&quot;)&#39;);    &#125;  &#125;)  .listen(8887);console.log(&quot;Server running at http://127.0.0.1:8887&quot;);</code></pre><p><strong>注：</strong></p><blockquote><p><code>server.js</code>代码，用于创建两个服务，分别为<code>http://127.0.0.1:8887/</code>和<code>http://127.0.0.1:8887/js</code></p><p>当访问<code>http://127.0.0.1:8887/</code>地址时，返回<code>index.html</code>页面，并在这个页面中发起请求加载<code>http://127.0.0.1:8887/js</code>下的<code>js</code>内容。</p><ul><li>接下来，我们可以通过修改上面代码中的<code>Cache-Control</code>的值，来查看对应的缓存效果。</li></ul></blockquote><ul><li>会刷新页面<blockquote><ul><li>当没有设置<code>Cache-Control</code>响应头或其值为<code>&quot;no-store&quot;</code>，表示不缓存。</li><li>当值为<code>&quot;no-cache&quot;</code>或<code>&quot;no-cache,max-age=200&quot;</code>时，每次刷新页面，都会向服务器发送请求来验证<strong>是否能使用缓存中内容</strong>,所以每次更新响应的内容，页面都会及时响应。</li></ul></blockquote></li><li>不会刷新页面<blockquote><ul><li>当值为<code>&quot;public,max-age=200&quot;</code>或<code>&quot;max-age=200&quot;</code>或<code>&quot;private,max-age=200&quot;</code>时，页面输出<code>&quot;hello world&quot;</code>，然后更新响应的内容为<code>&quot;hello world 123&quot;</code>，重启服务器，不管如何刷新页面，控制台始终输出<code>&quot;hello world&quot;</code></li></ul></blockquote></li></ul><ol start="3"><li><p>缓存未过期，如何更新内容</p><blockquote><p>通过上面的学习我们知道，使用缓存的优势很明显。当用户再访问页面时，不用再向服务器发请求获取内容，而是直接从本地电脑的磁盘中读取内容，极大的提高了网站的加载速度。</p><p>但问题也就随之而来，我们可以把缓存的过期时间设置为几天，几个月甚至几年，使该资源能长时间缓存在本地磁盘中。但是，如果我们的资源内容变化了，不想从本地缓存中读取该资源了，那我们又该如何办呢 ？</p><p><strong>唯一的办法就是给文件重新取一个名字</strong>，这样当我们再次访问该资源的时候，因为文件的名字变了，浏览器的缓存中没有缓存该名字的文件，则就会向服务器发请求来重新获取。</p><p>所以缓存文件中的内容一但发生变化，我们就需要重新给文件取一个名字，<strong>那我们如何保证每次变动后产生的名字是唯一的，不和之前的发生重名呢？</strong>这就引出了我们要讲的 <code>hash</code>知识。</p></blockquote></li><li><p>Webpack 与 hash 算法</p><blockquote><p>在使用 Webpack 的时候，Webpack 会根据<strong>所有文件内容</strong>计算出一个特殊的字符串。只要文件的内容有变化，Webpack 就会计算出一个新的特殊字符串，并保证是<strong>唯一的</strong></p><p>Webpack 根据文件内容计算出特殊字符串的时候，使用的算法就是 hash 算法，这个特殊的字符串一般叫作 hash 值。</p><p>我们一般取计算出的特殊字符串的<strong>前 8 位</strong>作为文件名的一部分，因为 hash 算法计算的这个特殊字符串的前 8 位基本可以保证唯一性了。所以 <code>filename</code> 的值常设置为<code>[name][fullhash:8].js</code></p></blockquote></li><li><p>Webpack 中 <code>hash、fullhash、chunkhash、contenthash</code> 的区别</p><blockquote><p>Webpack 通过对文件内容进行 hash 计算来获得 hash 值，那 hash、fullhash、chunkhash、contenthash 有什么区别 ？<br><strong>见下表</strong></p></blockquote></li></ol><table><thead><tr><th>hash 值</th><th>说明</th></tr></thead><tbody><tr><td>hash</td><td>根据打包中<strong>所有文件</strong>计算出的 hash 值</td></tr><tr><td>fullhash</td><td>webpack5 提出的，它用来<strong>替代</strong>之前的 hash</td></tr><tr><td>chunkhash</td><td>根据打包的**当前模块(JS)**计算出来的 hash 值</td></tr><tr><td>contenthash</td><td>他与<code>chunkhash</code>很像，不过他主要用于计算 <code>CSS</code>文件的 hash 值</td></tr></tbody></table><p><strong>代码演示</strong></p><blockquote><ul><li>我们还是用之前的案例代码，把<code>webpack.config.js</code>配置文件的内容更改为如下：</li></ul></blockquote><pre><code>const path = require(&quot;path&quot;);module.exports = &#123;  entry: &#123;    app: &quot;./src/index.js&quot;,    login: &quot;./src/login.js&quot;,  &#125;,  output: &#123;    path: path.resolve(__dirname, &quot;dist&quot;),    filename: &quot;[name][fullhash:8].js&quot;,    chunkFilename: &quot;[chunkhash:8].js&quot;,  &#125;,&#125;;</code></pre><blockquote><p>在当前目录执行npx webpack打包后，在dist目录下生成以下文件<br><img src="hash值区别.png"></p></blockquote><p><strong>观察以上图，我们发现</strong></p><blockquote><ul><li><code>app3152888d.js</code>与<code>login3152888d.js</code>的 hash 值是一样的，都是<code>3152888d</code>。因为<code>fullhash</code>的值是通过<strong>所有打包文件</strong>计算也来的，所以是一样的</li><li><code>5aa23035.js</code> 与<code>f2229a8d.js</code>的 hash 值是不一样的，因为<code>chunkhash</code>的值是通过<strong>当前打包的 JS 文件</strong>内容计算出来的。 <code>5aa23035.js</code>是<code>b.js</code>打包后生成的，<code>f2229a8d.js</code>是<code>a.js</code>文件打包后生成的，两者的内容不一样，所以计算得出的<code>hash</code> 值也不一样</li></ul></blockquote><h3 id="四、Webpack-预处理器-loader"><a href="#四、Webpack-预处理器-loader" class="headerlink" title="四、Webpack 预处理器 loader"></a>四、Webpack 预处理器 loader</h3><h4 id="什么是-loader"><a href="#什么是-loader" class="headerlink" title="什么是 loader"></a>什么是 loader</h4><blockquote><p>loader 被翻译成中文为“加载器”,不过我们一般称之为预处理器，或直接称为他为<code>loader</code>。</p><p>我们之前说 Webpack 是静态模块打包器，他可以处理 JS、CSS、图片等之类的文件，<strong>但其实 Webpack 本身只是用来处理 JS 和 JSON 文件</strong>。</p><p>如果要让 Webpack 能够去处理其它类型的文件，如：CSS、图片等些模块，就需要借助<code>loader</code>帮忙。</p><p><strong>loader 的作用就是让 Webpack 能够去处理那些非 JS 和 JSON 文件的模块</strong></p><p>各种各样的 loader 可以让我们去处理各种不同类型的文件，你想处理什么类型的模块，你就加载对应的 loader 来处理就好。</p></blockquote><blockquote><p>接下来我们先借助<code>babel-loader</code>预处理器来学习 loader 是<strong>如何配置的</strong>，然后再学习另外两个重要的 loader，他们分别是：css-loader和style-loader。</p><ul><li>大家在学习时，重点关注如何在 Webpack 中配置相关的 loader，因为 Webpack 中的 loader 非常多，我们了解了如何配置 loader，以后需要用到的相关 loader，查看对应 loader 的文档说明就好。</li><li>不过上面提到的三个 loader 在我们实际开发中也常用，所以他们具体如何配置也是要掌握的。</li></ul></blockquote><h4 id="babel-loader-预处理器"><a href="#babel-loader-预处理器" class="headerlink" title="babel-loader 预处理器"></a>babel-loader 预处理器</h4><blockquote><p>Webpack 他本身<strong>只是对 JS 做了打包，并没有处理他的兼容问题</strong>。也就是 Webpack 在打包过程中并没将 ES6 代码转成兼容低版本浏览器的 ES5 或 ES3 代码。</p><p>如果需要在打包过程中对 JS 实现转码，就需要借助 <code>Babel</code> 来实现。先用 Babel 对 JS 代码转码，然后再将转码后的代码交给 WebPack 去打包。</p><p>不过 Babel 和 Webpack 是两个相互独立的工具，为了让两个相互独立的工具能互通起来，他们之间就需要有一个<strong>接口</strong>，这里的接口就叫着<code>babel-loader</code>。有了babel-loader，咱们的 Webpack 就可以与 Babel 互通了，也就是说可以在 Webpack 中使用 Babel 了。</p><ul><li>接下来我们就在 Webpack 中尝试使用 Babel 来编译我们的代码。</li></ul></blockquote><ol><li><strong>安装</strong> babel-loader<blockquote><ul><li>在使用 bable-loader 前，需要先安装相应的 npm 包，即：<code>babel-loader</code> 包</li><li>最终是使用 Babel 来实现转码，所以还需要安装 Babel 相关包，即：<code>@babel/core</code></li><li>转码过程中 Babel 如何知道把 ES6 的代码转换 ES5 还是 ES3 等 ？就需要选择对应的 Babel 预设来进行转码，所以还需要安装<code>@babel/preset-env</code>包。</li></ul></blockquote></li></ol><ul><li>使用以下命令一次性安装以上三个包</li></ul><pre><code>npm install --save-dev babel-loader @babel/core  @babel/preset-env</code></pre><blockquote><p><strong>注：</strong></p></blockquote><ul><li><p>我们是在 Webpack 中使用 Babel，所以并<strong>不需要</strong>安装<code>@babel/cli</code>包，但一定要记得先安装 Webpack 相关的包 ！！</p></li><li><p>安装后，<code>package.json</code> 文件中<code>devDependencies</code>属性值如下</p></li></ul><pre><code> &quot;devDependencies&quot;: &#123;    &quot;@babel/core&quot;: &quot;^7.21.3&quot;,    &quot;@babel/preset-env&quot;: &quot;^7.20.2&quot;,    &quot;babel-loader&quot;: &quot;^9.1.2&quot;,    &quot;webpack&quot;: &quot;^5.76.3&quot;,    &quot;webpack-cli&quot;: &quot;^5.0.1&quot;  &#125;</code></pre><ol start="2"><li>Webpack 中 babel-loader 的<strong>配置</strong><blockquote><p>接下来，我们在 Webpack 中如何使用 Babel 来实现转码，就需要借助 babel-loader，所以我们需要在 Webpack 的配置文件配置 babel-loader，告诉 Webpack。</p></blockquote></li></ol><ul><li><code>webpack.config.js</code>配置文件如下</li></ul><pre><code>const path = require(&quot;path&quot;);module.exports = &#123;  mode: &quot;none&quot;,  entry: &quot;./src/index.js&quot;,  output: &#123;    path: path.resolve(__dirname, &quot;dist&quot;),    filename: &quot;bundle.js&quot;,  &#125;,  module: &#123;    rules: [      &#123;        test: /\.js$/,        exclude: /node_modules/,        // 只对 src 目录下的js文件进行处理        //include: /src/,        use: &#123;          loader: &quot;babel-loader&quot;,          options: &#123;            presets: [&quot;@babel/preset-env&quot;],          &#125;,        &#125;,      &#125;,    ],  &#125;,&#125;;</code></pre><p><strong>以上配置文件解析</strong></p><ul><li><p><code>module</code>：module 模块的意思，表示该配置项是用来对模块进行解析与处理。webpack 打包前，需要对模块做相关的处理，就会按 module 中的配置来。所有有关预处理器的配置，都是在配置项 module 下配置。</p></li><li><p><code>rules</code>：是一个数组，数组中的每一项是一个 JS 对象，表示一类预处理器。比如：有专门处理 JS 的预处器 balbel-loader，也有专门处理 CSS 的预处理器（css-loader，style-loader）等。</p></li><li><p><code>test</code>：是一个正则表达式或正则表达式数组，模块文件名与正则表达式相匹配的，会被 use 属性里的 loader 属性中对应的预处理器处理。上面<code>/\.js$/</code>表示匹配所有以<code>.js</code> 结尾的文件。</p></li><li><p><code>exclude</code>：翻译成中文为“排除”的意思，排除指定目录下的模块。他的值可以是字符串或正则表达式，字符串必需是绝对地址。上面<code>/node_modules/</code>表示排除<code>node_modules</code>文件夹文件，不被 babel-loader 预处理器处理。</p></li><li><p><code>include</code>：翻译成中文为“包含”的意思，表示只处理当前目录下与正则表达式匹配的文件。</p></li><li><p>如果 <code>exclude</code> 与 <code>include</code> 同时存在，Webpack 会<strong>优先</strong>使用 <code>exclude</code> 的配置。</p></li><li><p><code>use</code> ：表示要使用的预处理器，值可以是字符串、对象或数组。如果该处理器有些额外的配置参数，那 use 的需要设置为对象。如上面配置</p></li><li><p><code>loader</code>:预处理器的名称</p></li><li><p><code>options</code>：用来设置预处理器需要额外配置的参数</p><blockquote><p>以上配置成功后，在当前目录<code>npx webpack</code>命令后，Webpack 就会在当前目录下寻找所有以<code>.js</code>结尾的文件，并排除<code>node_module</code>文件中的所有<code>JS</code>文件,然后把这些文件先交给<code>bable-loader</code>预处理器来处理，实现转码。最后将转码后的入口文件打包后输出</p></blockquote></li><li><p><code>index.js</code>文件</p></li></ul><pre><code>let username = &quot;icoding&quot;;const sex = &quot;male&quot;;const add = (x, y) =&gt; x + y;new Promise((resolve, reject) =&gt; &#123;  resolve(&quot;成功 ！&quot;);&#125;).then((value) =&gt; &#123;  console.log(value);&#125;);const obj = Object.assign(&#123; a: 1 &#125;, &#123; b: 4 &#125;);console.log(obj);</code></pre><ul><li>利用 Webpack 打包后生成的<code>bundle.js</code>文件如下</li></ul><pre><code>(() =&gt; &#123;  // webpackBootstrap  var __webpack_exports__ = &#123;&#125;;  var username = &quot;icoding&quot;;  var sex = &quot;male&quot;;  var add = function add(x, y) &#123;    return x + y;  &#125;;  new Promise(function (resolve, reject) &#123;    resolve(&quot;成功 ！&quot;);  &#125;).then(function (value) &#123;    console.log(value);  &#125;);  var obj = Object.assign(    &#123;      a: 1,    &#125;,    &#123;      b: 4,    &#125;  );  console.log(obj);&#125;)();</code></pre><blockquote><p><strong>注：</strong></p></blockquote><ul><li>打包后输出的的<code>bundle.js</code>成功实现了转码，不过里面的 <code>API</code> 还是不能转！关于 <code>API</code> 如何处理，后面再讲，这里主要讲 loader。</li></ul><ol start="3"><li>babel-loader 如何<strong>提速</strong><blockquote><p>在上面的<code>webpack.config.js</code>中，我们通过<code>exclude</code>和<code>include</code>配置项，来确保转码时<strong>尽可能少</strong>的文件来提高转码的速度。</p><p>我们还可以通过使用<code>cacheDirectory</code>选项，设置<code>cacheDirectory:true</code>来<strong>开启缓存</strong>。在初始打包后再次打包，如果 JS 文件<strong>未发生变化</strong>，可以直接使用初次打包后的缓存文件，这样避免了二次转码，可以有效提高打包速度。</p></blockquote></li></ol><pre><code>module: &#123;  rules: [    &#123;      test: /\.js$/,      exclude: /node_modules/,      use: &#123;        loader: &quot;babel-loader&quot;,        options: &#123;          presets: [&quot;@babel/preset-env&quot;],          // 开启缓存          cacheDirectory: true,        &#125;,      &#125;,    &#125;,  ];&#125;</code></pre><ul><li>注：<code>babel-loader</code>缓存的文件默认保存在<code>node_modules/.cache/babel-loader</code>目录下</li></ul><ol start="4"><li>Babel 配置较复杂情况处理<blockquote><p>在上面的配置中，Babel 相关的配置直接配置在<code>webpack.config.js</code>的 <code>module-&gt; rules -&gt; use -&gt; options</code> 下面。如果 Babel 的<strong>配置较复杂</strong>的情况下，我们可以直接在当前工程目录下单独新建一个 <code>Bable</code> 的配置文件，如：<code>babel.config.json</code></p></blockquote></li></ol><ul><li>以下是<code>babel.config.json</code>文件内容</li></ul><pre><code>&#123;  &quot;presets&quot;: [&quot;@babel/preset-env&quot;]&#125;</code></pre><blockquote><p>Babel 的相关配置直接配置在了<code>babel.config.json</code>文件中，则<code>webpack.config.js</code>中对应的配置信息就可以<strong>删除</strong>了。删除后，<code>webpack.config.js</code>文件的内容如下：</p></blockquote><pre><code>const path = require(&quot;path&quot;);module.exports = &#123;  mode: &quot;none&quot;,  entry: &quot;./src/index.js&quot;,  output: &#123;    path: path.resolve(__dirname, &quot;dist&quot;),    filename: &quot;bundle.js&quot;,  &#125;,  module: &#123;    rules: [      &#123;        test: /\.js$/,        exclude: /node_modules/,        use: &#123;          loader: &quot;babel-loader&quot;,          options: &#123;            // 不能写在babel.config.json，会抛出错误            cacheDirectory: true,          &#125;,        &#125;,      &#125;,    ],  &#125;,&#125;;</code></pre><ol start="5"><li>总结 loader 及使用流程<blockquote><p>默认 Webpack 只能处理 JS 和 JSON 文件，对于其它类型的文件需要借除 <code>loader</code> 预处理器来帮忙。</p><p>loader 的作用就是让 Webpack 能够去处理那些非 JS 和 JSON 文件的模块。</p></blockquote></li></ol><p><strong>loader 的使用流程</strong></p><ul><li>安装 loader 需要的相关包</li><li>在<code>webpack.config.js</code>文件的<code>module</code>选项中配置<code>loader</code>，具体格式如下</li></ul><pre><code>module.exports = &#123;  // loader相关模块在module选项中中  module: &#123;    // rules的值是一个数组，数组中的每一项是一个JS对象，表示一类预处理器    rules: [      // 第一个预处理器相关配置      &#123;        // 是一个正则表达式或正则表达式数组，模块文件名与正则表达式相匹配的，会被use属性里的loader属性中对应的预处理器处理        test: /正则/,        // 排除该文件夹的文件，不需要处理        exclude: /文件夹名或目录/,        // 只处理该文件夹下符合条件的文件        include: /文件夹名或目录/,        // 表示要使用的预处理器，值可以是字符串、对象或数组        use: &#123;          // loader的名称          loader: &quot;loader名称&quot;,          // 预处理器需要额外配置的参数          options: &#123;            //          &#125;,        &#125;,      &#125;,      &#123;        // 第二个预处理器相关配置      &#125;,    ],  &#125;,&#125;;</code></pre><h3 id="五、处理-CSS-的-loader"><a href="#五、处理-CSS-的-loader" class="headerlink" title="五、处理 CSS 的 loader"></a>五、处理 CSS 的 loader</h3><blockquote><p>以下会讲解<code>css-loader、style-loader、sass-loader</code> 来处理 CSS 文件</p></blockquote><h4 id="css-loader-与-style-loader-预处理器"><a href="#css-loader-与-style-loader-预处理器" class="headerlink" title="css-loader 与 style-loader 预处理器"></a>css-loader 与 style-loader 预处理器</h4><blockquote><p>前面我们说过，Webpack 本身只能处理 JS 和 JSON 类型的文件，对于 CSS 类型的文件自然是处理不了的。</p><p>如果我们在 JS 中使用<code>import(&quot;./basic.css&quot;)</code>函数来加载 CSS 文件，默认情况下 <code>Webpack</code> 打包会失败，在命令行抛出错误。</p><p>而 <code>css-loader</code> 就是用来解析 css 文件，同时会将解析后的 CSS 文件以字符串的形式<strong>打包到 <code>JS</code> 文件中</strong>。不过，此时的 CSS 样式<strong>并不会生效</strong>，因为需要把 CSS 文件插入到 HTML 文件中才会生效。</p><p>所以我们还需要借助<code>style-loader</code>来帮忙，他可以<strong>把 JS 里面的样式代码插入到 HTML 文件中</strong>。他的原理很简单，就是动态生成 style 标签，然后将 CSS 内容添加到 style 标签中，然后将 style 标签插入到 HTML 页面。<br><strong>代码演示</strong></p></blockquote><ul><li>项目目录结构</li></ul><pre><code>icoding├─ node_modules├─ package-lock.json├─ package.json├─ src│  ├─ basic.css│  └─ index.js└─ webpack.config.js</code></pre><ul><li><code>index.js</code>文件中内容</li></ul><pre><code>import &quot;./basic.css&quot;;console.log(&#39;index.js&#39;)</code></pre><ul><li><code>webpack.config.js</code>文件内容如下</li></ul><pre><code>const path=require(&quot;path&quot;);module.exports=&#123;    mode:&quot;none&quot;,    entry:&quot;./src/index.js&quot;,    output:&#123;        path:path.resolve(__dirname,&quot;dist&quot;),        filename:&quot;bundle.js&quot;    &#125;&#125;</code></pre><ul><li><code>basic.css</code>文件内容</li></ul><pre><code>body &#123;  background-color: red;&#125;</code></pre><blockquote><p><strong>注：</strong><br>以上配置好了后，在当前目录下执行<code>npx webpack</code>执行打包命令时，控制台报错：<br><code>You may need an appropriate loader to handle this file type, currently no loaders are configured to process this file.</code><br>上面英文的意思是：你需要一个合适的 loader 来处理这类文件，目前没有配置任何加载器来处理该文件</p></blockquote><ol><li>安装 css-loader 与 style-loader</li></ol><ul><li>执行以下命令，安装 <code>css-loader</code> 和 <code>style-loader</code> 的包</li></ul><pre><code>npm install --save-dev style-loader  css-loader</code></pre><ul><li>安装成功后，<code>package.json</code>文件<code>devDependencies</code>字段的信息如下:</li></ul><pre><code>&quot;devDependencies&quot;: &#123;    &quot;css-loader&quot;: &quot;^6.7.3&quot;,    &quot;style-loader&quot;: &quot;^3.3.2&quot;,    &quot;webpack&quot;: &quot;^5.76.3&quot;,    &quot;webpack-cli&quot;: &quot;^5.0.1&quot;  &#125;</code></pre><ol start="2"><li>Webpack 中<strong>配置</strong> css-loader 与 style-loader<blockquote><p>以下是配置好的<code>webpack.config.js</code>文件</p></blockquote></li></ol><pre><code>const path = require(&quot;path&quot;);module.exports = &#123;  mode: &quot;none&quot;,  entry: &quot;./src/index.js&quot;,  output: &#123;    path: path.resolve(__dirname, &quot;dist&quot;),    filename: &quot;bundle.js&quot;,  &#125;,  module: &#123;    rules: [      &#123;        test: /\.css$/i,        // 表示将匹配到的css文件先交给css-loader处理,然后        // 将处理后的内容再交给style-loader来处理。        use: [&quot;style-loader&quot;, &quot;css-loader&quot;],      &#125;,    ],  &#125;,&#125;;</code></pre><ul><li>最后在当前目录执行<code>npx webpack</code>命令打包，打包后的目录结构如下：</li></ul><pre><code>icoding├─ node_modules├─ dist│  └─ bundle.js  // index.js打包后的出口文件├─ index.html├─ package-lock.json├─ package.json├─ src│  ├─ basic.css│  └─ index.js└─ webpack.config.js</code></pre><ul><li>在<code>index.html</code>页面中引入<code>bundle.js</code><blockquote><ul><li>最后在浏览器中浏览<code>index.html</code>页面，页面的背景变成了红色。在当前面右击—检查，在 <code>Elements</code> 选项中可以看到生成的 <code>style</code> 标签</li></ul></blockquote></li></ul><h4 id="css-loader-对-css-中图片的处理"><a href="#css-loader-对-css-中图片的处理" class="headerlink" title="css-loader 对 css 中图片的处理"></a>css-loader 对 css 中图片的处理</h4><blockquote><p><code>css-loader</code>在处理 CSS 样式时，会处理 CSS 中通过<code>url()</code>方式引入的资源。</p><ul><li>接下来我们通过代码来演示下</li></ul></blockquote><ul><li>在<code>src</code>文件夹新建<code>images</code>文件夹，将图片&#x2F;音频&#x2F;视频放入该文件夹，目录结构：</li></ul><pre><code>icoding├─ node_modules├─ package-lock.json├─ package.json├─ src│  ├─ css│  │  └─ basic.css│  ├─ images│  │  ├─ 18.mp4│  │  └─ course.jpg│  └─ js│     └─ index.js└─ webpack.config.js</code></pre><ul><li>我们把<code>basic.css</code>文件的内容更新为如下：</li></ul><pre><code>/*basic.css 文件内容*/body &#123;  background-color: red;  background: url(&quot;../images/course.jpg&quot;);  /* background: url(&quot;../images/18.mp4&quot;); */&#125;</code></pre><ul><li><code>index.js</code>文件内容如下</li></ul><pre><code>import &quot;../css/basic.css&quot;;console.log(&quot;index.js&quot;);</code></pre><ul><li><code>package.json</code> 内容如下</li></ul><pre><code>&#123;  &quot;name&quot;: &quot;icoding&quot;,  &quot;version&quot;: &quot;1.0.0&quot;,  &quot;description&quot;: &quot;&quot;,  &quot;main&quot;: &quot;index.js&quot;,  &quot;scripts&quot;: &#123;    &quot;test&quot;: &quot;echo \&quot;Error: no test specified\&quot; &amp;&amp; exit 1&quot;  &#125;,  &quot;keywords&quot;: [],  &quot;author&quot;: &quot;&quot;,  &quot;license&quot;: &quot;ISC&quot;,  &quot;devDependencies&quot;: &#123;    &quot;css-loader&quot;: &quot;^6.7.3&quot;,    &quot;style-loader&quot;: &quot;^3.3.2&quot;,    &quot;webpack&quot;: &quot;^5.76.3&quot;,    &quot;webpack-cli&quot;: &quot;^5.0.1&quot;  &#125;&#125;</code></pre><ul><li>接下来，我们更改配置文件如下：</li></ul><pre><code>const path = require(&quot;path&quot;);module.exports = &#123;  mode: &quot;none&quot;,  entry: &quot;./src/js/index.js&quot;,  output: &#123;    path: path.resolve(__dirname, &quot;dist&quot;),    filename: &quot;./js/bundle.js&quot;,  &#125;,  module: &#123;    rules: [      &#123;        test: /\.css$/i,        // use: [&quot;style-loader&quot;, &quot;css-loader&quot;],        // 或写成下面这样        use: [          &quot;style-loader&quot;,          &#123;            loader: &quot;css-loader&quot;,            options: &#123;              url: true, // true表示图片url方式引入的资源，false表示不处理            &#125;,          &#125;,        ],        //      &#125;,    ],  &#125;,&#125;;</code></pre><ul><li>执行<code>npx webpack</code>打包后，生成的目录结构变为：</li></ul><pre><code>icoding├─ node_modules├─ dist│  ├─ 2715c2f1ee2c4063d887.jpg│  └─ js│     └─ bundle.js├─ package-lock.json├─ package.json├─ src│  ├─ css│  │  └─ basic.css│  ├─ images│  │  ├─ 18.mp4│  │  └─ course.jpg│  └─ js│     └─ index.js└─ webpack.config.js</code></pre><blockquote><p><strong>注：</strong><br>观察以上目录，我们发现图片被<strong>成功处理并复制</strong>到了当前<code>dist</code>的根目录下。</p><p>但我们在实际开发中不会用<code>css-loader</code>来处理<code>css</code>中的图片，而是选择后面的<code>file-loader</code>和<code>url-loader</code>来处理。因为 <code>file-loader</code> 可以处理导入的<strong>各种类型的文件</strong>，而 <code>css-loader</code> 只能处理 css 中的<strong>图片</strong>等资源，并且在后期与<code>file-loader</code>在处理图片时<strong>发生冲突</strong>。</p><ul><li>以上我们安装的<code>css-loader@6.7.3</code> 版本，也就是 <code>css-loader</code> 的第 6 个版本才有处理图片等资源的能力，对于 6 以下的版本是没有处理图片功能的。如：<code>css-loader@5.0.2</code>版本，所以在后续使用<code>file-loader</code>时，一般会使用第5个版本的<code>css-loader</code></li></ul></blockquote><h4 id="sass-loader-预处理器"><a href="#sass-loader-预处理器" class="headerlink" title="sass-loader 预处理器"></a>sass-loader 预处理器</h4><blockquote><p>在实际的开发中，我们通常会用 <code>Sass </code>或 <code>less</code> 来书写样式文件，但是<strong>浏览器本身是不认识 Sass 的</strong>，我们还是需要将 Sass 转换成最终浏览器能够识别的 CSS 文件。这就需要用到 <code>sass-loader</code> 来帮我们处理。</p><ul><li><a href="https://www.sass.hk/">Sass 的官网</a></li></ul></blockquote><ul><li>以下是一段 Sass 书写的样式</li></ul><pre><code>.box &#123;  display: flex;  width: 100px;  height: 100px;  p &#123;    background-color: #ddd;    span &#123;      color: red;    &#125;  &#125;&#125;</code></pre><ul><li>上面 Sass 转换成 CSS 如下</li></ul><pre><code>.box &#123;  display: flex;  width: 100px;  height: 100px;&#125;&gt;.box p &#123;  background-color: #ddd;&#125;.box p span &#123;  color: red;&#125;</code></pre><blockquote><ul><li>我们后面讲 Vue 项目时就会采用 Sass 来书写样式，所以我们主要介绍 Sass 如何处理。</li></ul></blockquote><ul><li>创建基础的项目结构</li></ul><pre><code>icoding├─ node_modules├─ index.html├─ package-lock.json├─ package.json└─ src   ├─ css   │  └─ basic.scss   └─ index.js</code></pre><ul><li><code>basic.scss</code> 文件内容如下</li></ul><pre><code>.box &#123;  display: flex;  width: 100px;  height: 100px;  p &#123;    background-color: #ddd;    span &#123;      color: red;    &#125;  &#125;&#125;</code></pre><ul><li><code>index.js</code> 内容如下</li></ul><pre><code>import &quot;./css/basic.scss&quot;;</code></pre><ul><li><code>index.html</code> 页面内容如下</li></ul><pre><code>&gt;&lt;script src=&quot;./dist/bundle.js&quot;&gt;&lt;/script&gt;&gt;&lt;body&gt;&gt;  &lt;div class=&quot;box&quot;&gt;&gt;    &lt;p&gt;成功编译了&lt;span&gt;scss&lt;/span&gt;文件&lt;/p&gt;&gt;  &lt;/div&gt;&gt;&lt;/body&gt;</code></pre><ol><li>sass-loader 的使用<blockquote><p>首先我们需要安装<code>sass-loader</code>所需要的 npm 包，sass-loader 底层依赖 <code>Node Sass</code> 或 <code>Dart Sass</code> 进行处理，它们对应的 npm 包分别为 <code>node-sass</code> 和 <code>sass</code>。 这里推荐安装 <code>sass</code> 包</p></blockquote></li></ol><ul><li>执行以下命令，安装 <code>sass</code> 包</li></ul><pre><code>npm install sass-loader sass  --save-dev</code></pre><ul><li>sass 转成 css 后，还需要用 <code>css-loader</code> 和 <code>style-loader</code>来处理，所以也需要安装</li></ul><pre><code>npm install css-loader style-loader --save-dev</code></pre><ul><li>安装成功后<code>package.json</code>文件中<code>devDependencies</code>字段信息如下</li></ul><pre><code>&quot;devDependencies&quot;: &#123;    &quot;css-loader&quot;: &quot;^6.7.3&quot;,    &quot;style-loader&quot;: &quot;^3.3.2&quot;,    &quot;webpack&quot;: &quot;^5.76.3&quot;,    &quot;webpack-cli&quot;: &quot;^5.0.1&quot;  &#125;</code></pre><ul><li>接下来配置<code>webpack.config.js</code>文件，内容如下</li></ul><pre><code>const path = require(&quot;path&quot;);module.exports = &#123;  mode: &quot;none&quot;,  entry: &quot;./src/index.js&quot;,  output: &#123;    path: path.resolve(__dirname, &quot;dist&quot;),    filename: &quot;./bundle.js&quot;,  &#125;,  module: &#123;    rules: [      &#123;        test: /\.(s[ac]ss|css)$/i,        // 从右往左调用对应的loader来处理,先用sass-loader将sass处理成css，再将用css-loader来处理css，最后用style-loader将css插入到style标签中，并添加到html页面        use: [&quot;style-loader&quot;, &quot;css-loader&quot;, &quot;sass-loader&quot;],      &#125;,    ],  &#125;,&#125;;</code></pre><ul><li>最后执行<code>npx webpack</code>打包，打包后在浏览器打开<code>index.html</code>页面<blockquote><ul><li><code>sass</code> 被成功的处理成了 <code>css</code>，在配合 <code>css-loader</code> 与 <code>style-loader</code> 最终添加到了 <code>html</code> 页面</li></ul></blockquote></li></ul><h3 id="六、Webpack-插件-plugins"><a href="#六、Webpack-插件-plugins" class="headerlink" title="六、Webpack 插件 plugins"></a>六、Webpack 插件 plugins</h3><h4 id="什么是-plugins"><a href="#什么是-plugins" class="headerlink" title="什么是 plugins"></a>什么是 plugins</h4><blockquote><p>plugins 翻译过来就是 <strong>“插件”</strong> 的意思，我们很难去描述 Webpack 插件他是干什么的。如果站在<strong>更底层</strong>的角度来理解，Webpack 插件是在 Webpack 编译的某些阶段，通过调用 Webpack 对外暴露的 API 来扩展 Webpack 的能力。</p><p>对于上面这句话，暂时不理解没关系，当我们学到如何开发 Webpack 插件时，你自然就能理解上面这句话了。</p><p>在这里，我们只要把他和 loader 做区分就好。<code>loader</code> 是用来<strong>解析模块</strong>的，让 Webpack 可以去处理非 JS 和 JSON 类型的其它文件模块。而<strong>插件</strong>可以让 Webpack 执行范围更广的任务。</p><p>Webpack 的插件非常多，我们可以具体的插件具体来分析。那 Webpack 具体有那些插件，分别有什么用？</p><p>大家可以参考<a href="https://webpack.docschina.org/plugins/">官方提供的</a>当然还有很多官网没有提供的，大家可以通过搜索引擎自行搜索，还可以在<code>npm</code>上下载</p><p>接下来我们选择 3 款插件，来帮助大家学习如何在 Webpack 使用插件，本质上就是学习如何在 Webpack 中配置我们的插件。掌握了方法后，具体的插件如何配置，大家只需要根据对应插件的说明文档来就好。所以再多的插件，大家也不用担心不会用的问题。</p></blockquote><h4 id="clean-webpack-plugin-插件"><a href="#clean-webpack-plugin-插件" class="headerlink" title="clean-webpack-plugin 插件"></a>clean-webpack-plugin 插件</h4><blockquote><p><code>clean-webpack-plugin</code>插件是一个清除文件插件。每次使用 Webpack 打包后，都会在<code>output.path</code>指定的目录下生成很多打包后的出口文件（资源），当我们再次打包的时候，我们就需要手动的先<strong>将原来的打包后的文件给清空</strong>。</p><p>而<code>clean-webpack-plugin</code>插件就是帮我们做这件事的，有了他，我们每次打包后，会在生成新的出口文件（资源前），先将原来的文件给删除掉。</p></blockquote><ol><li>clean-webpack-plugin 插件的安装</li></ol><ul><li>在使用clean-webpack-plugin插件前，我们需要先通过以下命令，安装插件所需要的包</li></ul><pre><code>npm install --save-dev clean-webpack-plugin</code></pre><ul><li>安装后package.json文件中devDependencies字段内容如下</li></ul><pre><code>&quot;devDependencies&quot;: &#123;    &quot;clean-webpack-plugin&quot;: &quot;^4.0.0&quot;,    &quot;webpack&quot;: &quot;^5.76.3&quot;,    &quot;webpack-cli&quot;: &quot;^5.0.1&quot;  &#125;</code></pre><ol start="2"><li>clean-webpack-plugin 插件的使用<blockquote><p>所谓的使用插件，就是如何在 Webpack 中来<strong>配置插件信息</strong>。所有 Webpack 需要用到的插件都需要配置在<code>webpack.config.js</code>文件的<code>plugins</code>选项中</p></blockquote></li></ol><ul><li>当前项目的<code>webpack.config.js</code>文件中的配置信息，如下</li></ul><pre><code>const path = require(&quot;path&quot;);// 在使用插件前，需要先导入插件模块const &#123; CleanWebpackPlugin &#125; = require(&quot;clean-webpack-plugin&quot;);&gt;module.exports = &#123;  entry: &quot;./src/index.js&quot;,  output: &#123;    path: path.resolve(__dirname, &quot;dist&quot;),    filename: &quot;[name]_[chunkhash:8].js&quot;,  &#125;,  // 配置插件，目前只使用了一个插件  plugins: [new CleanWebpackPlugin()],&#125;;</code></pre><p><strong>配置说明</strong></p><blockquote><ul><li>在使用插件前，先需要导入对应的插件，以下表示加载对应的插件模块</li></ul></blockquote><pre><code>const &#123; CleanWebpackPlugin &#125; = require(&quot;clean-webpack-plugin&quot;);</code></pre><blockquote><ul><li>接下来我们需要告诉 Webpack，使用那些插件来扩展对应功能。将需要使用的插件在plugins选项中来配置。</li><li>plugins 的值是一个<strong>数组</strong>，数组中的每个成员表示一个插件，这里的成员<strong>都是通过 new 关键字创建的实例对象</strong>。</li><li>如果插件有相关的参数，则直接将一个对象<strong>作为插件的构造函数的参数</strong>传入就好。上面没有传入对应的参数，则表示启用默认配置。该插件默认使用<code>output.path</code>目录作为需要清空的目录。<br><code>clean-webpack-plugin</code>插件更多配置，<a href="https://www.npmjs.com/package/clean-webpack-plugin">查询文档</a></li></ul></blockquote><ul><li><code>index.js</code></li></ul><pre><code>console.log(&quot;index.js&quot;);</code></pre><ol start="3"><li>执行 Webpack 打包<blockquote><p>完成以上配置后，我们在当前工作目录下执行npx webpack打包</p><ul><li>如果<code>index.js</code>里引用了<code>css</code>文件，则需要相应的<code>loader</code></li></ul></blockquote></li></ol><h4 id="html-webpack-plugin-插件"><a href="#html-webpack-plugin-插件" class="headerlink" title="html-webpack-plugin 插件"></a>html-webpack-plugin 插件</h4><blockquote><p><code>html-webpack-plugin</code>插件可以<strong>自动创建 HTML 文件</strong>，并且会<strong>自动</strong>将打包后的 JS、CSS 等资源<strong>引入到创建的 HTML 文件中</strong>。当然，也<strong>可以使用指定的 HTML 模板</strong>，因为自动创建的 HTML 模块功能有限。</p><p>在这之前，我们需要手动将打包后的 JS、CSS 等文件引入到 HTML 页面中来使用。</p></blockquote><ol><li>html-webpack-plugin 插件的安装<blockquote><p>接下来我们就在上面的项目基础上，来使用<code>html-webpack-plugin</code>插件</p></blockquote></li></ol><ul><li>在使用<code>html-webpack-plugin</code>插件前，我们需要使用以下命令来安装插件对应的包</li></ul><pre><code>npm install --save-dev html-webpack-plugin</code></pre><ul><li>安装后<code>package.json</code>文件中<code>devDependencies</code>字段内容如下</li></ul><pre><code>&quot;devDependencies&quot;: &#123;    &quot;clean-webpack-plugin&quot;: &quot;^4.0.0&quot;,    &quot;html-webpack-plugin&quot;: &quot;^5.5.0&quot;,    &quot;webpack&quot;: &quot;^5.76.3&quot;,    &quot;webpack-cli&quot;: &quot;^5.0.1&quot;&#125;</code></pre><ul><li>当前项目中还使用了前面讲到的 clean-webpack-plugin插件</li></ul><ol start="2"><li>html-webpack-plugin 插件的使用<blockquote><p>插件安装成功后，接下来需要在<code>webpack.config.js</code>文件的<code>plugins</code>选项中添加相关配置来使用该插件。</p></blockquote></li></ol><pre><code>const path = require(&quot;path&quot;);const &#123; CleanWebpackPlugin &#125; = require(&quot;clean-webpack-plugin&quot;);// 导入插件模块const HtmlWebpackPlugin = require(&quot;html-webpack-plugin&quot;);module.exports = &#123;  entry: &quot;./src/index.js&quot;,  output: &#123;    path: path.resolve(__dirname, &quot;dist&quot;),    filename: &quot;[name]_[chunkhash:8].js&quot;,  &#125;,  plugins: [    // 清除文件插件    new CleanWebpackPlugin(),    // 自动创建一个空的HTML文件，并在页面中引用打包后的JS文件    new HtmlWebpackPlugin(),  ],&#125;;</code></pre><p><strong>配置说明</strong></p><ul><li>以下代码为，导入<code>html-webpack-plugin</code>插件对应的模块</li></ul><pre><code>const HtmlWebpackPlugin = require(&quot;html-webpack-plugin&quot;);</code></pre><ul><li>在 plugins 选项中，配置插件，告诉 Webpack 可以使用该插件来完成相关功能</li></ul><pre><code>plugins: [  // 该插件会自动创建一个空的HTML文件，并在页面中引用打包后的JS文件  new HtmlWebpackPlugin(),];</code></pre><ol start="3"><li>执行 Webpack 打包<blockquote><p>按以上配置好之后，接下来在当前目录下执行npx webpack 完成打包</p></blockquote></li></ol><ul><li>打包后的目录结构如下</li></ul><pre><code>icoding├─ node_modules├─ dist  // 在dist目录下生成了html和js文件│  ├─ index.html│  └─ main_7b90bcf6.js├─ index.html├─ package-lock.json├─ package.json├─ src│  └─ index.js└─ webpack.config.js</code></pre><ul><li>打包后，<code>dist</code>目录下的<code>index.html</code>是插件自动帮我们创建的，页面代码如下：</li></ul><pre><code>&lt;!DOCTYPE html&gt;&lt;html&gt;  &lt;head&gt;    &lt;meta charset=&quot;utf-8&quot; /&gt;    &lt;title&gt;Webpack App&lt;/title&gt;    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1&quot; /&gt;    &lt;script defer src=&quot;main_7b90bcf6.js&quot;&gt;&lt;/script&gt;  &lt;/head&gt;  &lt;body&gt;&lt;/body&gt;&lt;/html&gt;</code></pre><p><strong>注：</strong></p><blockquote><ul><li>观察以上代码，我们可以看到，<code>html</code> 页面中自动插入了我们打包后生成的<code>main_7b90bcf6.js</code></li></ul></blockquote><ol start="4"><li>自定义模板<blockquote><p>在实际开发中，我们希望能以指定的 html 页面来做为模板，生成新的 html 页面。也就是<strong>指定插件以某个 html 文件为模板</strong>，生成新的 html 文件，并把打包后的 JS 文件添加到该 html 页面中。</p><p>要实现以上功能，我们只需要在<code>webpack.config.js</code>文件中，做相关的配置就好，修改<code>webpack.config.js</code>中 <code>plugins</code> 选项内容如下：</p></blockquote></li></ol><pre><code> plugins:[        // 清除文件插件        new CleanWebpackPlugin(),        new HtmlWebpackPlugin(&#123;            // 指定生成的html文件以当前目录下的index.html文件为模板            template:&quot;./index.html&quot;,        &#125;)    ]</code></pre><ul><li>当前目录下的<code>index.html</code>文件内容如下</li></ul><pre><code>&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;  &lt;head&gt;    &lt;meta charset=&quot;UTF-8&quot; /&gt;    &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot; /&gt;    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot; /&gt;    &lt;title&gt;Document&lt;/title&gt;  &lt;/head&gt;  &lt;body&gt;    我是根目录下的index.html文件  &lt;/body&gt;&lt;/html&gt;</code></pre><ul><li>打包生成后，<code>dist</code>目录下生成了<code>index.html</code>和<code>main_7b90bcf6.js</code>文件，其中<code>index.html</code>文件的内容如下</li></ul><pre><code>&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;  &lt;head&gt;    &lt;meta charset=&quot;UTF-8&quot; /&gt;    &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot; /&gt;    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot; /&gt;    &lt;title&gt;Document&lt;/title&gt;    &lt;script defer src=&quot;main_7b90bcf6.js&quot;&gt;&lt;/script&gt;  &lt;/head&gt;  &lt;body&gt;    我是根目录下的index.html文件  &lt;/body&gt;&lt;/html&gt;</code></pre><ul><li>生成后的 html 文件是以根目录下的<code>index.html</code>为模板生成的，同时还把打包后的 JS 文件自动添加到了<code>index.html</code>页面中。</li></ul><ol start="5"><li>html-webpack-plugin 的参数<blockquote><p>html-webpack-plugin插件，<strong>不仅支持单入口打包，也支持多入口打包</strong>。可以同时生成多个 html 文件，并把对应的 JS、CSS 等资源引用到指定的 html 文件中。<br><strong>案例演示</strong></p></blockquote></li></ol><ul><li>我们根据以下目录结构来创建对应的文件</li></ul><pre><code>icoding├─ node_modules├─ package-lock.json├─ package.json├─ src│  ├─ index.html│  ├─ index.js│  ├─ search.html│  └─ search.js└─ webpack.config.js</code></pre><ul><li><code>index.html</code> 内容如下</li></ul><pre><code>&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;  &lt;head&gt;    &lt;meta charset=&quot;UTF-8&quot; /&gt;    &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot; /&gt;    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot; /&gt;    &lt;title&gt;Document&lt;/title&gt;  &lt;/head&gt;  &lt;body&gt;    网站首页  &lt;/body&gt;&lt;/html&gt;</code></pre><ul><li><code>search.html</code> 内容如下</li></ul><pre><code>&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;  &lt;head&gt;    &lt;meta charset=&quot;UTF-8&quot; /&gt;    &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot; /&gt;    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot; /&gt;    &lt;title&gt;Document&lt;/title&gt;  &lt;/head&gt;  &lt;body&gt;    网站搜索页  &lt;/body&gt;&lt;/html&gt;</code></pre><ul><li>package.json 内容如下</li></ul><pre><code>&#123;  &quot;name&quot;: &quot;icoding&quot;,  &quot;version&quot;: &quot;1.0.0&quot;,  &quot;description&quot;: &quot;&quot;,  &quot;main&quot;: &quot;index.js&quot;,  &quot;scripts&quot;: &#123;    &quot;test&quot;: &quot;echo \&quot;Error: no test specified\&quot; &amp;&amp; exit 1&quot;  &#125;,  &quot;keywords&quot;: [],  &quot;author&quot;: &quot;&quot;,  &quot;license&quot;: &quot;ISC&quot;,  &quot;devDependencies&quot;: &#123;    &quot;clean-webpack-plugin&quot;: &quot;^4.0.0&quot;,    &quot;html-webpack-plugin&quot;: &quot;^5.5.0&quot;,    &quot;webpack&quot;: &quot;^5.76.3&quot;,    &quot;webpack-cli&quot;: &quot;^5.0.1&quot;  &#125;&#125;</code></pre><ul><li>当前项目的<code>webpack.config.js</code>文件内容如下</li></ul><pre><code>const path = require(&quot;path&quot;);const &#123; CleanWebpackPlugin &#125; = require(&quot;clean-webpack-plugin&quot;);const HtmlWebpackPlugin = require(&quot;html-webpack-plugin&quot;);module.exports = &#123;  mode: &quot;none&quot;,  entry: &#123;    index: &quot;./src/index.js&quot;,    search: &quot;./src/search.js&quot;,  &#125;,  output: &#123;    path: path.resolve(__dirname, &quot;dist&quot;),    filename: &quot;[name]_[chunkhash:8].js&quot;,  &#125;,  plugins: [    // 清除文件插件    new CleanWebpackPlugin(),    new HtmlWebpackPlugin(&#123;      template: &quot;./src/index.html&quot;,      filename: &quot;index.html&quot;,      chunks: [&quot;index&quot;],      minify: &#123;        // 删除index.html中的空格        collapseWhitespace: true,        // 删除index.html中的注释        removeComments: true,      &#125;,    &#125;),    new HtmlWebpackPlugin(&#123;      template: &quot;./src/search.html&quot;,      filename: &quot;search.html&quot;,      chunks: [&quot;search&quot;],    &#125;),  ],&#125;;</code></pre><blockquote><p><code>new HtmlWebpackPlugin()</code>插件的参数说明</p></blockquote><ul><li><p><code>template</code>：指定生成的 HTML 的模块文件，最终以这里指定的文件为模板，生成最终的 HTML 文件</p></li><li><p><code>filename</code>：最终生成的 HTML 文件的名称</p></li><li><p><code>chunks</code>：指定当前 HTML 文件引入那个入口文件打包后生成的出口文件</p></li><li><p><code>minify</code>：用来指定打包后文件是否做相关体积压缩的处理。如果值为 true，则按默认配置压缩 HTML 代码，也可以向上面一样，设置为一个对象，指定相关的压缩处理。</p></li><li><p>更多参数，<a href="https://github.com/jantimon/html-webpack-plugin#options">查阅文档</a></p></li><li><p>打包后生成的目录结构</p></li></ul><pre><code>icoding├─ node_modules├─ dist│  ├─ index.html│  ├─ index_433c545f.js│  ├─ search.html│  └─ search_26a2e76a.js├─ package-lock.json├─ package.json├─ src│  ├─ index.html│  ├─ index.js│  ├─ search.html│  └─ search.js└─ webpack.config.js</code></pre><ul><li>生成后<code>index.html</code>的内容如下</li></ul><pre><code>&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;  &lt;head&gt;    &lt;meta charset=&quot;UTF-8&quot; /&gt;    &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot; /&gt;    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width,initial-scale=1&quot; /&gt;    &lt;title&gt;Document&lt;/title&gt;    &lt;script defer=&quot;defer&quot; src=&quot;index_433c545f.js&quot;&gt;&lt;/script&gt;  &lt;/head&gt;  &lt;body&gt;    网站首页  &lt;/body&gt;&lt;/html&gt;</code></pre><ul><li>打包后生成的search.html的内容如下</li></ul><pre><code>&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;  &lt;head&gt;    &lt;meta charset=&quot;UTF-8&quot; /&gt;    &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot; /&gt;    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot; /&gt;    &lt;title&gt;Document&lt;/title&gt;    &lt;script defer src=&quot;search_26a2e76a.js&quot;&gt;&lt;/script&gt;  &lt;/head&gt;  &lt;body&gt;    网站搜索页  &lt;/body&gt;&lt;/html&gt;</code></pre><h4 id="mini-css-extract-plugin-插件"><a href="#mini-css-extract-plugin-插件" class="headerlink" title="mini-css-extract-plugin 插件"></a>mini-css-extract-plugin 插件</h4><blockquote><p>在前面学习<code>css-loader</code>与<code>style-loader</code>时，我们并不能将 CSS 内容单独提取到一个 CSS 文件中，而<code>mini-css-extract-plugin</code>插件就是用来作这件事的。<strong>他会将 CSS 提取到单独的 CSS 文件中，为每个包含 CSS 的 JS 文件创建一个 CSS 文件</strong>。</p><p>所以他一般需要与<code>css-loader</code>一起配合使用</p></blockquote><ul><li><code>css-loader</code>负责解析 CSS 模块，会将解析后的 CSS 文件以字符串的形式打包到 JS 文件中</li><li>而<code>mini-css-extract-plugin</code>负责将 JS 中的 CSS 提取到单独的 CSS 文件中。<blockquote><p>本插件基于 webpack v5 的新特性构建，并且需要 <code>webpack 5</code>才能正常工作<br><strong>演示案例</strong></p></blockquote></li><li>接下来我们创建项目来演示下，以下是项目的目录结构</li></ul><pre><code>// 项目目录结构icoding├─ node_modules├─ index.html├─ package-lock.json├─ package.json├─ src│  ├─ basic.css│  └─ index.js└─ webpack.config.js</code></pre><ul><li><code>index.html</code> 页面代码</li></ul><pre><code>&gt;&lt;!--省略了部分，只留下了重要信息--&gt;&gt;&lt;body&gt;&gt;  &lt;div id=&quot;box&quot;&gt;&lt;/div&gt;&gt;&lt;/body&gt;</code></pre><ul><li><code>basic.css</code> 文件内容</li></ul><pre><code>body &#123;  background-color: red;&#125;</code></pre><ul><li><code>index.js</code> 文件内容</li></ul><pre><code>import(&quot;./basic.css&quot;);console.log(&quot;index.js&quot;);</code></pre><ul><li>安装 <code>webpack、clean-webpack-plugin、html-webpack-plugin</code> 插件</li></ul><pre><code>npm i webpack webpack-cli clean-webpack-plugin  html-webpack-plugin -D</code></pre><ol><li>安装 mini-css-extract-plugin 和 css-loader 插件</li></ol><ul><li>项目创建好后，接下来执行以下命令安装<code>mini-css-extract-plugin</code>和<code>css-loader</code>插件对应的包</li></ul><pre><code>npm install --save-dev mini-css-extract-plugin css-loader</code></pre><ul><li>安装后<code>package.json</code>中<code>devDependencies</code>的信息如下</li></ul><pre><code>&quot;devDependencies&quot;: &#123;    &quot;clean-webpack-plugin&quot;: &quot;^4.0.0&quot;,    &quot;css-loader&quot;: &quot;^6.7.3&quot;,    &quot;html-webpack-plugin&quot;: &quot;^5.5.0&quot;,    &quot;mini-css-extract-plugin&quot;: &quot;^2.7.5&quot;,    &quot;webpack&quot;: &quot;^5.76.3&quot;,    &quot;webpack-cli&quot;: &quot;^5.0.1&quot;  &#125;</code></pre><ol start="2"><li>插件配置<blockquote><p>安装好对应插件后，接下来就可以通过修改 Webpack 配置，来使用这个两个插件</p></blockquote></li></ol><ul><li><code>webpack.config.js</code>的内容如下</li></ul><pre><code>const path = require(&quot;path&quot;);const MiniCssExtractPlugin = require(&quot;mini-css-extract-plugin&quot;);const HtmlWebpackPlugin = require(&quot;html-webpack-plugin&quot;);const &#123; CleanWebpackPlugin &#125; = require(&quot;clean-webpack-plugin&quot;);module.exports = &#123;  mode: &quot;none&quot;,  entry: &quot;./src/index.js&quot;,  output: &#123;    path: path.resolve(__dirname, &quot;dist&quot;),    filename: &quot;bundle.js&quot;,    chunkFilename: &quot;[name]_[chunkhash:8].js&quot;,  &#125;,  module: &#123;    rules: [      &#123;        test: /\.css$/i,        use: [MiniCssExtractPlugin.loader, &quot;css-loader&quot;],      &#125;,    ],  &#125;,  plugins: [    new MiniCssExtractPlugin(&#123;      filename: &quot;basic_[contenthash:8].css&quot;,      // 找到 id 为 box 的元素，在它之后插入新的 &lt;link&gt; 元素      insert: &quot;#box&quot;,      // 把指定的属性和值附加到 &lt;link&gt; 元素上      attributes: &#123;        id: &quot;target&quot;,        &quot;data-target&quot;: &quot;example&quot;,      &#125;,    &#125;),    new HtmlWebpackPlugin(&#123;      template: &quot;./index.html&quot;,    &#125;),    new CleanWebpackPlugin(),  ],&#125;;</code></pre><ul><li>MiniCssExtractPlugin 插件的配置说明<blockquote><ul><li><code>filename</code>: 抽离出来的 CSS 文件名，也可以是保存路径,如果想让该css文件单独放在<code>dist</code>文件夹下的一个目录，可以：<code>filename: &quot;./css/[name]_[contenthash:8].css&quot;</code>，会自动创建<code>css</code>文件夹，注意：该路径是以<code>output.path</code>指定的路径为起点</li><li><code>insert</code>: 值是一个 css 选择器字符串，用来指定生成的 CSS 的<code>&lt;link&gt;</code>标签插入的位置，<code>&lt;link&gt;</code>标签会插入到此选择器选中的元素后面</li><li><code>attributes</code>：值是一个对象，指定相关属性和值，添加到<code>&lt;link&gt;</code>标签上<br>更多配置，查阅<a href="https://webpack.docschina.org/plugins/mini-css-extract-plugin/">官方文档</a><blockquote><p>由于安装了<code>css-loader</code>，所以还要配置它</p></blockquote></li></ul></blockquote></li></ul><ol start="3"><li>执行 Webpack 打包</li></ol><ul><li>在当前目录下执行<code>npx webpac</code>执行打包，打包后，生成的目录结构如下<img src="MiniCssExtractPlugin目录.png"></li></ul><blockquote><ul><li>观察以上图，我们可以看到<code>index.js</code>中通过<code>import(&quot;./basic.css&quot;)</code>加载的 <code>CSS</code> 样式，打包后单独生成了<code>1.basic_4a73e62e</code>文件。</li><li>接下来，在浏览器中预览 <code>dist</code> 目录下的 <code>index.html</code> 文件，发现页面背景变红，css生效<img src="MiniCssExtractPlugin效果.png"></li></ul></blockquote><p><strong>注：</strong></p><blockquote><ul><li>观察以上图，我们可以看到 <code>css</code> 被当作单独的文件，通过 <code>link </code>标签引入到 <code>html</code> 页面中。</li><li>同时<code>&lt;link&gt;</code>标签被插入到<code>&quot;body .box&quot;</code>元素后面。还有<code>&lt;link&gt;</code>标签上添加了 <code>id</code> 与 <code>data-target</code> 属性</li></ul></blockquote><h3 id="七、Webpack-处理图片、音视频资源"><a href="#七、Webpack-处理图片、音视频资源" class="headerlink" title="七、Webpack 处理图片、音视频资源"></a>七、Webpack 处理图片、音视频资源</h3><h4 id="file-loader-预处理器"><a href="#file-loader-预处理器" class="headerlink" title="file-loader 预处理器"></a>file-loader 预处理器</h4><blockquote><p>file-loader 是一个<strong>文件资源预处理器</strong>，他在 Webpack 中的作用是：处理文件导入语句<strong>并替换成它的访问地址</strong>，同时把文件输出到相应位置。</p><p>其中导入语句包括 JS 的<code>import ...from &quot;...&quot; </code>和 CSS 样式中的<code>url()</code></p></blockquote><ol><li><code>file-loader</code> 处理 JS 中引入的图片<blockquote><p>接下来我们要在<code>load-img.js</code>文件中通过<code>import ... from &quot;...&quot;</code>语句来导入一张图片，然后把这张图片插入到打包后的<code>search.html</code>页面中的<code>#main</code>元素中。</p></blockquote></li></ol><p><strong>项目的相关信息如下：</strong></p><ul><li><code>package.json</code>中字段信息如下</li></ul><pre><code> &quot;devDependencies&quot;: &#123;    &quot;clean-webpack-plugin&quot;: &quot;^4.0.0&quot;,    &quot;html-webpack-plugin&quot;: &quot;^5.5.0&quot;,    &quot;webpack&quot;: &quot;^5.76.3&quot;,    &quot;webpack-cli&quot;: &quot;^5.0.1&quot;  &#125;</code></pre><ul><li><code>search.html</code>文件内容如下</li></ul><pre><code>&lt;body&gt;  &lt;div id=&quot;main&quot;&gt;&lt;/div&gt;&lt;/body&gt;</code></pre><ul><li><code>load-img.js</code>文件内容如下</li></ul><pre><code>import img from &quot;../images/logo.png&quot;;let imgEl = new Image();imgEl.src = img;// 页面加载完成，再将图片插入页面中window.onload = function () &#123;  document.getElementById(&quot;main&quot;).appendChild(imgEl);&#125;;</code></pre><p><strong>安装 file-loader</strong></p><ul><li>执行以下命令，安装 <code>file-loader</code> 所需要的包</li></ul><pre><code>npm install file-loader@6.2.0 --save-dev</code></pre><p><strong>配置 webpack.config.js</strong></p><pre><code>const path = require(&quot;path&quot;);const HtmlWebpackPlugin = require(&quot;html-webpack-plugin&quot;);const &#123; CleanWebpackPlugin &#125; = require(&quot;clean-webpack-plugin&quot;);module.exports = &#123;  mode: &quot;none&quot;,  entry: &quot;./src/js/search.js&quot;,  output: &#123;    path: path.resolve(__dirname, &quot;dist&quot;),    filename: &quot;js/bundle.js&quot;,    chunkFilename: &quot;./js/[name].js&quot;,  &#125;,  module: &#123;    rules: [      &#123;        /* 被file-loader处理的文件后缀名 */        test: /\.(png|jpe?g|gif)$/i,        use: &#123;          /* loader的名称 */          loader: &quot;file-loader&quot;,          /* loader的参数设置 */          options: &#123;            /* 打包后生成的图片名称，[ext] 图片后缀名与原来一样*/            name: &quot;[name].[contenthash:8].[ext]&quot;,            /* 打包后生成的图片输出目录，相对于output.path而言*/            outputPath: &quot;./images/&quot;,            /*             publicPath默认以output.publicPath作为访问资源的地址            图片在网页中的预览地址，相对于被调用者而言*/            publicPath: &quot;./images/&quot;,          &#125;,        &#125;,      &#125;,    ],  &#125;,  plugins: [    new HtmlWebpackPlugin(&#123;      template: &quot;./src/search.html&quot;,      filename: &quot;search.html&quot;,//决定最终生成的 HTML 文件的名称    &#125;),    new CleanWebpackPlugin(),  ],&#125;;</code></pre><ul><li>以上配置好后，在当前目录下执行<code>npx webpack</code>打包，打包后生成的目录结构如下</li></ul><pre><code>icoding├─ node_modules├─ dist│  ├─ images│  │  └─ logo.ad0f1f9b.png│  ├─ search.html│  └─ js│     └─ bundle.js├─ package-lock.json├─ package.json├─ src│  ├─ images│  │  └─ logo.png│  ├─ search.html│  └─ js│     └─ load-img.js└─ webpack.config.js</code></pre><blockquote><p>观察以上结构，打包后的图片保存在 <code>dist/images</code> 目录下，<code>js</code> 保存在 <code>dist/js</code> 目录下，<code>search.html</code>页面在 <code>dist</code> 目录下。</p></blockquote><ol start="2"><li><code>file-loader</code> 处理 CSS 中的图片<blockquote><p>我们在上面案例的基础上</p></blockquote></li></ol><ul><li><p>在 images 文件夹下新加了一张图片</p></li><li><p>在src&#x2F;js目录下添加index.js</p></li><li><p>在src&#x2F;css目录下添加basic.css文件</p></li><li><p>然后在index.js文件中引入basic.css样式文件</p></li><li><p><code>index.js</code>文件内容</p></li></ul><pre><code>import &quot;../css/basic.css&quot;;</code></pre><ul><li><code>basic.css</code>内容</li></ul><pre><code>body &#123;  background: url(&quot;../images/course.jpg&quot;);  /* background: url(&quot;../images/18.mp4&quot;); */&#125;</code></pre><ul><li>当前项目目录结构如下</li></ul><pre><code>icoding├─ node_modules├─ package-lock.json├─ package.json├─ src│  ├─ css│  │  └─ basic.css  // 新增│  ├─ images│  │  ├─ 18.mp4  // 新增│  │  ├─ course.jpg  // 新增│  │  └─ logo.png│  ├─ index.html│  └─ js│     ├─ index.js  // 新增│     └─ load-img.js└─ webpack.config.js</code></pre><ul><li>安装包<blockquote><ul><li>执行以下命令安装处理 css 需要的包</li></ul></blockquote></li></ul><pre><code>npm i css-loader@5.2.7 mini-css-extract-plugin@2.7.5 -D</code></pre><blockquote><p>注意我们安装的<code>css-loader</code>是<code>5</code>版本的，而不是 6 版本的</p></blockquote><ul><li>修改<code>webpack.config.js</code>配置文件，如下</li></ul><pre><code>const path = require(&quot;path&quot;);const HtmlWebpackPlugin = require(&quot;html-webpack-plugin&quot;);const &#123; CleanWebpackPlugin &#125; = require(&quot;clean-webpack-plugin&quot;);const MiniCssExtractPlugin = require(&quot;mini-css-extract-plugin&quot;);module.exports = &#123;  mode: &quot;none&quot;,  entry: &#123;    img: &quot;./src/js/load-img.js&quot;,    index: &quot;./src/js/index.js&quot;,  &#125;,  output: &#123;    path: path.resolve(__dirname, &quot;dist&quot;),    filename: &quot;js/[name][chunkhash:8].js&quot;,    chunkFilename: &quot;./js/[name].js&quot;,  &#125;,  module: &#123;    rules: [      &#123;        test: /\.(png|jpe?g|gif|mp4)$/i,        use: &#123;          loader: &quot;file-loader&quot;,          options: &#123;            name: &quot;[name].[contenthash:8].[ext]&quot;,            outputPath: &quot;./images/&quot;,            // publicPath:&#39;./images/&#39;          &#125;,        &#125;,      &#125;,      &#123;        test: /\.css$/i,        use: [MiniCssExtractPlugin.loader, &quot;css-loader&quot;],      &#125;,    ],  &#125;,  plugins: [    new HtmlWebpackPlugin(&#123;      template: &quot;./src/index.html&quot;,    &#125;),    new CleanWebpackPlugin(),    new MiniCssExtractPlugin(&#123;      filename: &quot;./css/basic_[contenthash:8].css&quot;,    &#125;),  ],&#125;;</code></pre><ol start="3"><li>file-loader 总结<blockquote><ul><li>file-loader 不仅可以处理图片，还可以处理视频、音频等媒体资源。</li><li>它的实现原理就是在打包时根据资源的地址，把这些资源复制一份到打包后的指定目录，然后重新取个名字，并替换资源的访问路径。</li></ul></blockquote></li></ol><h4 id="url-loader-预处理器"><a href="#url-loader-预处理器" class="headerlink" title="url-loader 预处理器"></a>url-loader 预处理器</h4><blockquote><p><code>url-loader</code>可以看作是<code>file-loader</code>的<strong>增强版</strong>，他除了支持file-loader的所有功能外，还可以将图片转换成 <code>Base64</code> 编码格式的 <code>DataURL</code>，并将其作为模块来引入到打包后的代码中，以减少 <code>HTTP</code> 请求的数量。</p><p><code>url-loader</code> 可以通过配置相关的参数，限定<strong>小于</strong>多少 <code>KB</code> 的图片才处理成 Base64 编码格式的 DataURL，<strong>大于</strong>这个限制的按 <code>file-loader</code> 的方式来处理。</p></blockquote><ul><li>正常情况下，<code>html</code> 中引入图片的代码如下：</li></ul><pre><code>&lt;img src=&quot;./images/go.png&quot; /&gt;</code></pre><ul><li>如果将 <code>go.png</code> 转换成 <code>Base64</code> 编码格式，<code>html</code> 中引入的图片代码就是一长串代码</li></ul><ol><li><code>url-loader</code> 的安装与使用<blockquote><p>我们在上面<code>file-loader</code>案例的基础上来操作。<code>file-loader</code> 案例中<code>logo.png</code>图片大小为<code>9.8KB</code>，而<code>courser.jpg</code>图片大小为<code>20KB</code>。</p><p>因为<code>url-loader</code>本身需要依赖<code>file-loader</code>的，所以我们在安装 <code>url-loader</code> 时，<strong>也需要同时安装 file-loader</strong>。</p></blockquote></li></ol><ul><li>执行以下命令，安装 url-loader 包（file-loader 上面案例中安装过）</li></ul><pre><code>npm install url-loader@4.1.1 --save-dev</code></pre><ul><li>安装后，我们修改<code>webpack.config.js</code>配置文件如下</li></ul><pre><code>const path = require(&quot;path&quot;);const HtmlWebpackPlugin = require(&quot;html-webpack-plugin&quot;);const &#123; CleanWebpackPlugin &#125; = require(&quot;clean-webpack-plugin&quot;);const MiniCssExtractPlugin = require(&quot;mini-css-extract-plugin&quot;);module.exports = &#123;  mode: &quot;none&quot;,  entry: &#123;    img: &quot;./src/js/load-img.js&quot;,    index: &quot;./src/js/index.js&quot;,  &#125;,  output: &#123;    path: path.resolve(__dirname, &quot;dist&quot;),    filename: &quot;js/[name][chunkhash:8].js&quot;,    chunkFilename: &quot;./js/[name].js&quot;,  &#125;,  module: &#123;    rules: [      &#123;        test: /\.css$/i,        use: [MiniCssExtractPlugin.loader, &quot;css-loader&quot;],      &#125;,      &#123;        // 根据正则表达式来匹配要处理的文件类型        test: /\.(png|jpe?g|gif)$/i,        use: &#123;          // 处理的loader名          loader: &quot;url-loader&quot;,          // 参数设置          options: &#123;            // 当图片的大小小于10kb时，会将其转成Base64编码格式的DataURL            limit: 10240, // 10240=1024*10 相当于10k大小            name: &quot;[name].[ext]&quot;, // 图片的名字            // 图片的输出目录，相对于output.path而言            outputPath: &quot;./mages/&quot;,            // 图片的预览地址，相对于被调用者与ouput.publicPath机制一样            publicPath: &quot;/dist/images/&quot;,          &#125;,        &#125;,      &#125;,    ],  &#125;,  plugins: [    new HtmlWebpackPlugin(&#123;      template: &quot;./src/index.html&quot;,    &#125;),    new CleanWebpackPlugin(),    new MiniCssExtractPlugin(&#123;      filename: &quot;./css/basic_[contenthash:8].css&quot;,    &#125;),  ],&#125;;</code></pre><ul><li>以上配置好后，在当前目录执行<code>npx webpack</code>打包，生成如果的<code>dist</code>目录结构如下</li></ul><pre><code>dist  ├─ css  │  └─ basic_1beaad77.css  ├─ images  │  └─ course.jpg  ├─ index.html  └─ js     ├─ img1509d649.js     └─ index59c407b4.js</code></pre><ul><li><p>观察上面结构，我们发现只有<code>course.jpg</code>被成功复制到了<code>images</code>文件夹中，<strong>logo.png没有出现</strong>。接下来我们在浏览器中访问<code>index.html</code>页面，查看源代码，如下</p><img src="url-loader.png"></li><li><p>因为logo.png的小于10KB，所以被成功处理成Base64位的。</p></li></ul><h4 id="html-withimg-loader-预处理器"><a href="#html-withimg-loader-预处理器" class="headerlink" title="html-withimg-loader 预处理器"></a>html-withimg-loader 预处理器</h4><blockquote><p>html 中直接使用 <code>img</code> 标签 src 加载图片的话，因为没有被依赖，图片将不会被打包。</p><p><code>html-withimg-loader</code>预处理器，主要就是用来处理 html 文件中的通过 img 标签引入的图片。<br>不过他主要是用来<strong>解析html 文件</strong>，里面的图片最终还是交给我们前面提到的<code>file-loader</code>来处理。</p></blockquote><ol><li>我们先来创建项目</li></ol><ul><li><code>index.html</code>文件内容如下</li></ul><pre><code>&lt;body&gt;  &lt;img src=&quot;./images/logo.png&quot; alt=&quot;&quot; /&gt;  &lt;img src=&quot;./images/course.jpg&quot; alt=&quot;&quot; /&gt;&lt;/body&gt;</code></pre><ul><li><code>js/index.js</code>文件内容如下</li></ul><pre><code>console.log(&quot;index.js&quot;);</code></pre><ul><li><code>package.json</code>中部分信息如下</li></ul><pre><code> &quot;devDependencies&quot;: &#123;    &quot;file-loader&quot;: &quot;^6.2.0&quot;,    &quot;html-webpack-plugin&quot;: &quot;^5.5.0&quot;,    &quot;html-withimg-loader&quot;: &quot;^0.1.16&quot;,    &quot;url-loader&quot;: &quot;^4.1.1&quot;,    &quot;webpack&quot;: &quot;^5.76.3&quot;,    &quot;webpack-cli&quot;: &quot;^5.0.1&quot;  &#125;</code></pre><ol start="2"><li>html-withimg-loader 的使用</li></ol><ul><li>执行以下命令，安装html-withimg-loader对应的包</li></ul><pre><code>npm install html-withimg-loader --save-dev</code></pre><ul><li>然后在 <code>webpack</code> 的<code>module.rules</code>选中添加如下配置</li></ul><pre><code>module: &#123;  rules: [    // ....    &#123;      test: /\.(htm|html)$/i,      loader: &quot;html-withimg-loader&quot;,    &#125;,  ];&#125;</code></pre><ul><li>最后<code>webpack.config.js</code>文件内容如下：</li></ul><pre><code>const path = require(&quot;path&quot;);const MiniCssExtractPlugin = require(&quot;mini-css-extract-plugin&quot;);const HtmlWebpackPlugin = require(&quot;html-webpack-plugin&quot;);module.exports = &#123;  mode: &quot;none&quot;,  entry: &quot;./src/js/index.js&quot;,  output: &#123;    path: path.resolve(__dirname, &quot;dist&quot;),    filename: &quot;./js/bundle.js&quot;,  &#125;,  module: &#123;    rules: [      &#123;        // 根据正则表达式来匹配要处理的文件类型        test: /\.(png|jpe?g|gif)$/i,        use: &#123;          // 处理的loader名          loader: &quot;url-loader&quot;,          // 参数设置          options: &#123;            // 当图片的大小小于10kb时，会将其转成Base64编码格式的DataURL            limit: 10240, // 10240=1024*10 相当于10k大小            name: &quot;[name].[ext]&quot;, // 图片的名字            // 图片的输出目录，相对于output.path而言            outputPath: &quot;./images/&quot;,            // 图片的预览地址，相对于被调用者与ouput.publicPath机制一样            publicPath: &quot;/dist/images/&quot;,          &#125;,        &#125;,      &#125;,      &#123;        test: /\.(htm|html)$/i,        loader: &quot;html-withimg-loader&quot;,      &#125;,    ],  &#125;,  plugins: [    new HtmlWebpackPlugin(&#123;      template: &quot;./src/index.html&quot;,      chunks: &quot;[name]&quot;,    &#125;),  ],&#125;;</code></pre><ul><li>然后，执行<code>npx webpack</code>打包，就可以看到 html 文件中的图片被成功处理了。<strong>但是发现处理后的地址不对</strong>，如下：</li></ul><pre><code>&lt;img src=&#123;&quot;default&quot;:&quot;/dist/images/logo.png&quot;&#125; alt=&quot;&quot; /&gt; &lt;imgsrc=&#123;&quot;default&quot;:&quot;/dist/images/course.jpg&quot;&#125; alt=&quot;&quot; /&gt;</code></pre><ul><li>是因为file-loader或url-loader在处理这个地址时，采用的是 <strong><code>ES6</code> 的模块导入</strong>的，所以我们需要在他们的配置中，添加<code>rules.use.options.esModule:false</code>配置，具体如下：</li></ul><pre><code>rules:[&#123;// 根据正则表达式来匹配要处理的文件类型    test: /\.(png|jpe?g|gif)$/i,        use: &#123;            // 处理的loader名            loader: &#39;url-loader&#39;,                // 参数设置                options: &#123;                    esModule:false,                    // ......                &#125;        &#125;&#125;],</code></pre><ul><li>接下来，再执行<code>npx webpack</code>打包，打包后再浏览器端打开 html 文件，就可以正常看到图片被成功加载。</li></ul><h4 id="Asset-Modules-资源模块"><a href="#Asset-Modules-资源模块" class="headerlink" title="Asset Modules 资源模块"></a>Asset Modules 资源模块</h4><blockquote><p><code>Asset Modules</code> 翻译成中文为 <strong>“资源模块”</strong> 的意思，他是 <code>Webpack5</code> 内置的模块类型，它允许 Webpack 处理资源文件（字体，图标等）而无需配置额外 <code>loader</code>。相当于 <code>Webpack5</code>已经<strong>内置</strong>前面提到的<code>file-loader</code>与<code>url-loader</code>对图片、字体等这一类型文件的处理能力。</p><p>我们只需要在 Webpack 的<code>module.rules</code>配置选项中配置相关的信息，就可以完成对图片，字体等这一类型文件的处理。</p><p>Asset Modules 是 Webpack 的<strong>未来</strong>，随着 Asset Modules 功能的不断完善，未来我们将不会再使用之前提到的<code>file-loader、url-loader</code>等对文件资源处理的 loader，而完全用 <code>Asset Modules</code> 来取代。但目前还不完善，但我们需要学习和了解它。</p></blockquote><ol><li>Asset Modules 配置<blockquote><p>Asset Modules 的相关配置,查阅<a href="https://webpack.docschina.org/guides/asset-modules/">官方资料</a></p></blockquote></li></ol><ul><li>以下为<code>Asset Modules</code>在<code>Webpack</code>中的几个重要配置</li></ul><pre><code>rules: [  &#123;    test: /\.(jpe?g|png|gif)$/i,    type: &quot;asset&quot;,    generator: &#123;      filename: &quot;images/[hash][ext]&quot;,    &#125;,    parser: &#123;      dataUrlCondition: &#123;        maxSize: 10 * 1024,      &#125;,    &#125;,  &#125;,];</code></pre><p><strong>以上配置说明：</strong></p><ul><li><code>test</code>：需要被以下规则处理的符合条件的文件。上面<code>/\.(jpe?g|png|gif)$/i</code>表示匹配所有以<code>jpg、jpeg、png、gif</code>结尾的图片。</li><li><code>type</code>：采用那种方式来处理 <code>test</code> 中匹配到的资源模块，他的值有很多，这里主要讲解与图片相关的 3 种类型，详细查<a href="https://webpack.docschina.org/configuration/module/#ruletype">阅资料</a></li></ul><table><thead><tr><th>类型值</th><th>说明</th></tr></thead><tbody><tr><td>asset&#x2F;resource</td><td>这种类型用来替换之前file-loader的操作。它处理文件导入地址并将其替换成访问地址，同时把文件输出到相应位，</td></tr><tr><td>asset&#x2F;inline</td><td>这种类型用来替换之前url-loader的操作。它处理文件导入地址并将其替换成 Base64 编码格式的 DataURL 地址。</td></tr><tr><td>asset</td><td>在单独导出文件和生成 DataURL 间自动选择。用来替换之前通过url-loader，并配置资源体积来实现的功能。</td></tr></tbody></table><ul><li><code>generator.filename</code>用来设置文件的名称。默认文件名格式是：<code>[hash][ext][query]</code>。也可以通过<code>output.assetModuleFilename</code>来设置，如：</li></ul><pre><code>output: &#123;  // ...  assetModuleFilename: &#39;images/[hash][ext][query]&#39; &#125;,</code></pre><ul><li><p><code>generator.filename</code>与<code>output.assetModuleFilename</code>功能相同，并且<strong>仅适用于</strong> <code>asset</code> 和 <code>asset/resource</code> 模块类型</p></li><li><p><code>parser.dataUrlCondition.maxSize</code>用来设置文件的大小，Webpack 会<strong>根据这个大小来决定打包的图片资源是以文件输出还是替换成 <code>Base64</code> 编码格式的 <code>DataURL</code></strong></p></li></ul><ol><li>接下来，我们通过案例来演示下</li></ol><ul><li><code>js/index.js</code>文件内容</li></ul><pre><code>import &quot;../css/basic.css&quot;;console.log(&quot;index.js&quot;);css/basic.css文件内容&gt;/*basic.css 文件内容*/.box1 &#123;  width: 100px;  height: 100px;  background: url(&quot;../images/course.jpg&quot;);  background-size: contain;&#125;&gt;.box2 &#123;  width: 100px;  height: 100px;  background: url(&quot;../images/logo.png&quot;);  background-size: contain;&#125;</code></pre><ul><li><code>index.html</code> 文件内容</li></ul><pre><code>&lt;body&gt;  &lt;div class=&quot;box1&quot;&gt;&lt;/div&gt;  &lt;div class=&quot;box2&quot;&gt;&lt;/div&gt;&lt;/body&gt;</code></pre><ul><li><code>images</code>文件夹中的图片<code>course.jpg</code>为20KB,<code>logo.png</code>为8.7KB</li><li>以下是本项目的<code>package.json</code>文件的部分内容</li></ul><pre><code>&quot;devDependencies&quot;: &#123;    &quot;css-loader&quot;: &quot;^5.2.7&quot;,    &quot;html-webpack-plugin&quot;: &quot;^5.5.0&quot;,    &quot;mini-css-extract-plugin&quot;: &quot;^2.7.5&quot;,    &quot;webpack&quot;: &quot;^5.76.3&quot;,    &quot;webpack-cli&quot;: &quot;^5.0.1&quot;  &#125;</code></pre><ul><li>以下是<code>webpack.config.js</code>配置文件内容</li></ul><pre><code>const path = require(&quot;path&quot;);const MiniCssExtractPlugin = require(&quot;mini-css-extract-plugin&quot;);const HtmlWebpackPlugin = require(&quot;html-webpack-plugin&quot;);module.exports = &#123;  mode: &quot;none&quot;,  entry: &quot;./src/js/index.js&quot;,  output: &#123;    path: path.resolve(__dirname, &quot;dist&quot;),    filename: &quot;./js/bundle.js&quot;,  &#125;,  module: &#123;    rules: [      &#123;        test: /\.css$/i,        use: [MiniCssExtractPlugin.loader, &quot;css-loader&quot;],      &#125;,      &#123;        test: /\.(jpe?g|png|gif)$/i,        type: &quot;asset&quot;,        generator: &#123;          filename: &quot;images/[hash][ext]&quot;,        &#125;,        parser: &#123;          dataUrlCondition: &#123;            maxSize: 10 * 1024, // 10KB  1KNB=1024B（字节）          &#125;,        &#125;,      &#125;,    ],  &#125;,  plugins: [    new MiniCssExtractPlugin(&#123;      filename: &quot;./css/[name].[contenthash].css&quot;,    &#125;),    new HtmlWebpackPlugin(&#123;      template: &quot;./src/index.html&quot;,      chunks: &quot;[name]&quot;,    &#125;),  ],&#125;;</code></pre><ul><li>执行<code>npx webpack</code>打包<blockquote><ul><li>最终<code>logo.png</code>转成了 <code>Base64</code> 的 <code>DataURL</code>，<code>course.jpg</code>被复制到<code>dist/images/</code>目录下</li></ul></blockquote></li></ul><h3 id="八、CSS-样式兼容型处理"><a href="#八、CSS-样式兼容型处理" class="headerlink" title="八、CSS 样式兼容型处理"></a>八、CSS 样式兼容型处理</h3><ol><li>PostCSS<blockquote><p><code>PostCSS</code> 是一个允许使用 JS 插件转换样式的工具。 这些插件可以检查（lint）你的 CSS，支持 <code>CSS Variables</code> 和 <code>Mixins</code>， 编译尚未被浏览器广泛支持的先进的 CSS 语法，内联图片，以及其它很多优秀的功能。</p><p>我们在书写 CSS 样式时，为了考虑<strong>不同浏览器的兼容问题</strong>，很多时候需要对 CSS 样式<strong>添加浏览器厂商私有前缀</strong>。而 postCSS 就是帮我们做这件事的。这样我们在书写 CSS 样式时，就不用担心没有添加浏览器厂商私有前缀而造成兼容问题。</p></blockquote></li></ol><ul><li><p><a href="https://github.com/postcss/postcss/blob/main/docs/README-cn.md">PostCSS 中文文档</a></p></li><li><p>比如：我们书写了下面这样一段 css 样式</p></li></ul><pre><code>.box &#123;  display: flex;  width: 100px;  height: 100px;  background-color: red;&#125;</code></pre><ul><li>经过 <code>postcss</code> 处理后，就会自动帮我们加上浏览器的前缀，处理后 css 如下</li></ul><pre><code>.box &#123;  display: -webkit-box;  display: -webkit-flex;  display: -moz-box;  display: -ms-flexbox;  display: flex;  width: 100px;  height: 100px;  background-color: red;&#125;</code></pre><ol start="2"><li>postcss-loader 的使用<blockquote><p>要使用 PostCSS 这个工具来给样式添加不同浏览器的前缀，需要安装<code>postcss-loader、postcss</code>两个包</p></blockquote></li></ol><ul><li>执行以下命令，安装所需要的包</li></ul><pre><code>npm install --save-dev postcss-loader@7.1.0 postcss@8.4.21</code></pre><ul><li>安装后，我们修改下<code>webpac.config.js</code>文件，内容如下：</li></ul><pre><code>const path = require(&quot;path&quot;);module.exports = &#123;  entry: &quot;./src/index.js&quot;,  output: &#123;    path: path.resolve(__dirname, &quot;dist&quot;),    filename: &quot;./bundle.js&quot;,  &#125;,  module: &#123;    rules: [      &#123;        test: /\.(s[ac]ss|css)$/i,        use: [&quot;style-loader&quot;, &quot;css-loader&quot;, &quot;postcss-loader&quot;, &quot;sass-loader&quot;],      &#125;,    ],  &#125;,&#125;;</code></pre><p><strong>注：</strong></p><ul><li>然后在当前根目录执行<code>npx wepack</code>执行打包，打包后发现生成的 CSS 样式中的并没有任何变化。</li><li>是因为我们还需要借助<code>autoprefixer</code>插件，告诉 postcss，我们需要把 CSS 处理成兼容哪些浏览器版本的 CSS。</li></ul><ol start="2"><li>安装 autoprefixer 插件</li></ol><ul><li>接下来，执行以下命令安装插件</li></ul><pre><code>npm i autoprefixer@10.4.14 --save-dev</code></pre><ul><li>安装成功后，在当前根目录下，新建 <code>postcss</code> 的配置文件<code>postcss.config.js</code>，添加以下配置</li></ul><pre><code>const autoprefixer = require(&quot;autoprefixer&quot;);module.exports = &#123;  plugins: [    autoprefixer(&#123;      browsers: [&quot;cover 99.5%&quot;],    &#125;),  ],&#125;;</code></pre><ul><li>或把<code>autoprefixer</code>插件中的<strong>参数去掉</strong>，直接在<code>package.json</code>中来配置浏览器信息,添加<code>&quot;browserslist&quot;</code>字段，具体如下：</li></ul><pre><code>&#123;  &quot;devDependencies&quot;: &#123;&#125;,  &quot;browserslist&quot;: [&quot;cover 99.5%&quot;]&#125;</code></pre><p><strong>注：</strong></p><blockquote><p>还有其它方式，关于浏览器相关配置，[可查阅文档](<a href="https://github.com/browserslist/browserslist#queries">opens new window</a>)</p></blockquote><ul><li>最后在当前工作目录执行<code>npx webpack</code>打包</li></ul><h3 id="九、处理-JS-中的兼容问题"><a href="#九、处理-JS-中的兼容问题" class="headerlink" title="九、处理 JS 中的兼容问题"></a>九、处理 JS 中的兼容问题</h3><blockquote><p>前面我们学习过 Babel，利用 Babel 将 ES6 的代码转找成 ES5 或 ES3 的代码，但是我们是将所有 ES6 的语法部分全部转换成了 ES5 或 ES3，<strong>并没有指定按目标环境来转换</strong>。比如：只考虑<code>firefox 版本&gt;50</code>的浏览器中缺失的那部分<code>ES6</code>语法才转换等。</p><p>同时，我们之前利用 Babel 只能转换 ES6 的语法，<strong>对于缺失的 API</strong>，我们只能通过引入 <code>polyfill</code> 来实现，<strong>并不能实现按指定目标环境</strong>来引入缺失的 API。</p><ul><li>以上这两个核心问题，就是接下来我们要重点解决的。</li></ul><p>我们先回顾前面讲过的内容，比如：</p><ul><li>Babel 的配置文件</li><li>Babel 的预设包</li><li>Babel 官方的 polyfill</li><li>利用 webpack 与 bable-loader 来实现 Babel 转码<br>然后，我们再来学习如何利用 Babel 实现按需转码（即：按指定的目标环境来转码）</li></ul></blockquote><h4 id="Babel-的配置文件"><a href="#Babel-的配置文件" class="headerlink" title="Babel 的配置文件"></a>Babel 的配置文件</h4><blockquote><p>前面我们已经了解过 Babel,并且也使用过 Babel 的配置文件，这里我们对于 Babel 的配置文件做相关补充。</p><ul><li>详细资料<a href="https://babeljs.io/docs/configurationc">参考官方</a></li></ul><p><code>Babel</code>的配置文件支持很多种格式，比如<code>babelr.json</code>、<code>babel.config.json</code>、<code>babel.config.js</code>、<code>.babelrc.js</code>。当然我们也可以在<code>package.json</code>来配置 Babel。</p><ul><li>接下来我们挑几个我们常用的说下<blockquote><p>以下所有配置文件中的<code>&quot;presets&quot;</code>中用来配置 Babel 预设，<code>&quot;plugins&quot;</code>中用来配置插件</p></blockquote></li></ul></blockquote><ol><li><code>babel.config.json</code>文件<blockquote><p>在当前项目的根目录下创建<code>babel.config.json</code>文件，其配置格式</p></blockquote></li></ol><pre><code>&#123;  &quot;presets&quot;: [...],  &quot;plugins&quot;: [...]&#125;</code></pre><ol start="2"><li><code>babel.config.js</code>文件<blockquote><p>在当前项目的根目录下创建<code>babel.config.js</code>文件，其配置格式</p></blockquote></li></ol><pre><code>module.exports=&#123;    presets: [...],    plugins: [...]&#125;</code></pre><ol start="3"><li><code>package.json</code>文件<blockquote><p>在<code>package.json</code>文件中配置格式如下</p></blockquote></li></ol><pre><code>&#123;  &quot;name&quot;: &quot;my-package&quot;,  &quot;version&quot;: &quot;1.0.0&quot;,  &quot;babel&quot;: &#123;    &quot;presets&quot;: [ ... ],    &quot;plugins&quot;: [ ... ],  &#125;&#125;</code></pre><h4 id="Babel-中的预设"><a href="#Babel-中的预设" class="headerlink" title="Babel 中的预设"></a>Babel 中的预设</h4><blockquote><p>在前面我提到过 Babel 中预设，我们说预设就是<strong>一组 Babel 插件的集合</strong>，我们想把 ES6 的语法转换成 ES5 或 ES3 需要用到对应的插件来帮我们转，而这些相关的插件非常多，所以我们就把他们统一到一个包中，这个包就是<code>@babel/preset-env</code>预设。</p><ul><li><code>@babel/preset-env</code> 预设的<a href="https://babeljs.io/docs/babel-preset-env">相关配置文档</a><br>所以我们需要将 ES6 的语法转换成 ES5 或 ES3 语法，只需要在 Babel 的配置文件中配置这个预设就可以了。</li></ul></blockquote><ul><li>以下是<code>babel.config.js</code>配置文件内容：</li></ul><pre><code>module.exports = &#123;  presets: [&quot;@babel/preset-env&quot;],&#125;;</code></pre><ul><li>如果在<code>package.json</code>中配置如下：</li></ul><pre><code>&quot;babel&quot;: &#123;    &quot;presets&quot;: [ &quot;@babel/preset-env&quot; ]  &#125;</code></pre><p><strong>注：</strong></p><blockquote><p>但是我们说，<code>@babel/preset-env</code>预设只能帮我转换 JS 中的语法，但对于 API 本身是没有办法转的，所以我们需要借助 <code>polyfill</code> 来帮我们实现。</p></blockquote><h4 id="Babel-官方的-polyfill"><a href="#Babel-官方的-polyfill" class="headerlink" title="Babel 官方的 polyfill"></a>Babel 官方的 polyfill</h4><blockquote><p>在 <code>Bable7.4.0</code> 以前，Babel 官方提供的<code>polyfill</code>包名为<code>@babel/polyfill</code>,但现在官方已经把这个包给<strong>弃用</strong>了。<code>@babel/polyfill</code>包本身是<code>regenerator-runtime</code> 和 <code>core-js</code>这两个包组成的。</p><ul><li>因为 <code>core-js</code> 这个包的版本已经更新到 <code>3.x.x.x</code> 版本，而<code>@babel/polyfill</code>里的 <code>core-js</code> 已经锁死为 <code>2.x.x.x</code> 版本的。</li></ul><p>所以官方推荐我们在开发中，<strong>独立安装</strong><code>core-js</code>和 <code>regenerator-runtime</code>包,并在你的 JS 中独立加载他们。</p><ul><li><code>core-js</code>为核心包，几乎所有 API 接口的实现都在这个包里。</li><li><code>regenerator-runtime</code>是对编译&#x2F;转译<code>async</code>函数的运行时支持（它可能还有其他用途,但这是主要用途）。<br><a href="https://babeljs.io/docs/babel-polyfill">官方文档参考</a></li></ul></blockquote><ul><li>执行以下命令安装 polyfill 对应的包</li></ul><pre><code>npm i core-js@3.24.1  regenerator-runtime@0.13.11</code></pre><ul><li>安装好后，我们只需要通过<code>import</code>语句在需要的 JS 文件中，通过以下句语来引用这两个包就好</li></ul><pre><code>import &quot;core-js/stable&quot;;import &quot;regenerator-runtime/runtime&quot;;</code></pre><h4 id="webpack-与-babel-loader-实现转码"><a href="#webpack-与-babel-loader-实现转码" class="headerlink" title="webpack 与 babel-loader 实现转码"></a>webpack 与 babel-loader 实现转码</h4><blockquote><p>接下来，我们结合 Webpack 在项目利用 Babel 来给 JS 文件进行<strong>转码后再打包</strong>。</p></blockquote><ul><li><code>index.js</code>文件内容如下：</li></ul><pre><code>import &quot;core-js/stable&quot;;import &quot;regenerator-runtime/runtime&quot;;const obj = Object.assign(&#123; a: 1 &#125;, &#123; b: 4 &#125;);console.log(obj);</code></pre><ul><li><code>index.html</code>文件内容如下：</li></ul><pre><code>&gt;&lt;body&gt;&gt;  &lt;script src=&quot;../dist/bundle.js&quot;&gt;&lt;/script&gt;&gt;&lt;/body&gt;</code></pre><ul><li><code>webpack.config.js</code>文件配置内容如下：</li></ul><pre><code>const path = require(&quot;path&quot;);module.exports = &#123;  mode: &quot;none&quot;,  entry: &quot;./src/index.js&quot;,  output: &#123;    path: path.resolve(__dirname, &quot;dist&quot;),    filename: &quot;bundle.js&quot;,  &#125;,  module: &#123;    rules: [      &#123;        test: /\.js$/,        exclude: /node_modules/,        use: &#123;          loader: &quot;babel-loader&quot;,          /* 预设可以直接设置在这里，也可以在`package.json`或bable的配置文件中                options:&#123;                    &quot;presets&quot;: [                        &quot;@babel/preset-env&quot;                    ]                &#125;                */        &#125;,      &#125;,    ],  &#125;,&#125;;</code></pre><ul><li><code>babel.config.js</code>文件内容如下：</li></ul><pre><code>module.exports=&#123;    presets: [&quot;@babel/preset-env&quot;]&#125;// 我们也可以把`bable`的配置设置在`package.json`中，如下 &quot;babel&quot;: &#123;    &quot;presets&quot;: [      &quot;@babel/preset-env&quot;    ]  &#125;</code></pre><ul><li><code>package.json</code>文件核心内容如下</li></ul><pre><code>&quot;devDependencies&quot;: &#123;    &quot;@babel/core&quot;: &quot;^7.21.3&quot;,    &quot;@babel/preset-env&quot;: &quot;^7.20.2&quot;,    &quot;babel-loader&quot;: &quot;^9.1.2&quot;,    &quot;webpack&quot;: &quot;^5.76.3&quot;,    &quot;webpack-cli&quot;: &quot;^5.0.1&quot;  &#125;,  &quot;dependencies&quot;: &#123;    &quot;core-js&quot;: &quot;^3.24.1&quot;,    &quot;regenerator-runtime&quot;: &quot;^0.13.11&quot;  &#125;,</code></pre><ul><li>接下来在当前工作目录执行<code>npx webpack</code>完成打包工作，然后在<code>firefox 32</code>版本的浏览器中来浏览，发现控制台正确打印出以下结果：</li></ul><pre><code>Object &#123; a: 1, b: 4 &#125;</code></pre><ul><li><code>Object.assign()</code>方法，在大于<code>&gt;=34</code>版本的 <code>firefox</code> 中才被支持</li></ul><h4 id="实现-Babel-按需转码"><a href="#实现-Babel-按需转码" class="headerlink" title="实现 Babel 按需转码"></a>实现 Babel 按需转码</h4><blockquote><p>当我们在 Babel 中使用了<code>@babel/preset-env</code>预设时，我们可以为这个预设<strong>配置相关的参数</strong>，通过这些参数我们可以<strong>设置只针对目标环境不支持的语法</strong>进行语法转换。</p><p>同时也可以与 <code>polyfill</code> 结合，<strong>只针对目标环境不支持的特性API进行部分引用</strong>，这样我们就不用把完整的 <code>polyfill</code> 全部引入到最终的文件。</p></blockquote><ul><li>以下是<code>@babel/preset-env</code>预设的部分重要参数，也是我们着重要掌握的参数。</li></ul><table><thead><tr><th>参数</th><th>说明</th></tr></thead><tbody><tr><td><code>targets</code></td><td>这个参数用来设置 Babel 转码的<strong>目标环境</strong>，也就是指定我们转码后的代码需要兼容那些版本的浏览器。他与前面讲到的<code>browserslist</code>功能一样，设置也是一样。</td></tr><tr><td><code>useBuiltIns</code></td><td>这个参数的作用主要是根据<code>targets</code>中的设置（目标环境），找出需要的<code>polyfill</code>进行部分引入。</td></tr><tr><td><code>corejs</code></td><td>指定 Babel 转码时使用的 <code>core-js</code> 的版本，默认设置为 <code>2.x.x.x</code> 版本。不过建议使用 3.x.x 版本。 这个值只在 <code>useBuiltIns</code> 的值是<code>entry</code>与<code>usage</code>时才生效。注意：如果不指定，默认为 <code>2.x.x</code>，则对应的 <code>polyfill</code> 为<code>@babel/polyfill</code>。如果为 <code>3.x.x</code> 版本，则需要手动安装<code>@core-js@3.x.x</code>的包。</td></tr></tbody></table><ul><li>参数设置<blockquote><ul><li>当<code>@babel/preset-env</code>预设需要设置参数时，预设就不<strong>能以字符串形式</strong>直接放在数组中，而是<strong>应该再包裹一层数组</strong>，数组的第一项是该预设的名称字符串，数组的第二项是一个对象，该预设的参数就是添加在这个对象中。具体参考以下格式</li></ul></blockquote></li></ul><pre><code>// babel.config.jsmodule.exports = &#123;  presets: [    [&quot;@babel/preset-env&quot;],    &#123;      // 预设参数设置在这里    &#125;,  ],&#125;;</code></pre><ol><li>targets 参数<blockquote><p>这个参数用来设置 Babel 转码的目标环境，也就是指定我们转码后的代码需要兼容哪些版本的浏览器。他与前面讲到的<code>browserslist</code>功能一样，设置也是一样。</p><p>也就是说，我们可以通过<code>@babel/preset-env</code>预设的<code>targets</code>参数来指定 <code>Babel</code> 转码的目标环境，也可以在<code>package.json</code>中通过<code>browserslist</code>字段来设置。</p><ul><li><p>如果我们在<code>@babel/preset-env</code>预设中设置了<code>targets</code>参数，那<code>Babel</code>转码时就会<strong>以这里指定的为主</strong>。</p></li><li><p>如果这里没有指定，就会使用<code>package.json</code>中<code>browserslist</code>中的配置。如果<code>package.json</code>中也没有配置,那默认就会将所有 <code>ES6</code> 语法转换成 <code>ES5</code> 语法。</p></li><li><p><code>@babel/preset-env</code>预设的<code>targets</code>参数，只能实现语法按指定目标环境来转码，并不能实现 API 转换。</p></li></ul><p>targets 参数的值可是字符串，数组、对象都可以。</p><ul><li>targets 参数设置<a href="https://babeljs.io/docs/options#targets">参考文档</a></li><li>关于浏览器<a href="https://github.com/browserslist/browserslist">兼容性列表查询</a></li></ul></blockquote></li></ol><p><strong>代码演示</strong></p><ul><li>我们以上一个项目为基础，修改<code>index.js</code>文件内容如下</li></ul><pre><code>// async 函数 在firefox 第52版本才开始支持async function fn() &#123;  console.log(1);&#125;fn();</code></pre><ul><li>以下为当前项目的<code>babel.config.js</code>的配置文件内容</li></ul><pre><code>module.exports = &#123;  presets: [    [      &quot;@babel/preset-env&quot;,      &#123;        // 只考虑firefox版本大于53的浏览器        targets: &quot;Firefox &gt; 53&quot;,      &#125;,    ],  ],&#125;;</code></pre><p><strong>注：</strong></p><blockquote><p>接下来在当前目录下执行<code>npx webpack</code>打包，打包后，在<code>firefox32</code>版的浏览器中打开<code>index.html</code>页面，发现控制台<strong>抛出错误</strong>。因为当前浏览器并不支持<code>async</code>函数，而我们打包时指定转换的<code>Firefox&gt;53</code>版本，也就是不考虑 <code>53</code> 及以下版本的兼容型的处理。</p><p>如果我们把配置改为<code>targets:&quot;Firefox &gt; 30&quot;</code>，然后再次打包，打包后刷新浏览器，在控制台成功输出 <code>1</code></p><p>当然，我们为了考虑和 <code>CSS</code> 指定相同的目标环境，我们一般会不会在这里设置 <code>targets</code> 属性，而是在<code>package.json</code>中，通过属性来指定。</p></blockquote><ol start="2"><li>useBuiltIns 参数<blockquote><p>这个参数的作用主要是根据上面提到的<code>targets</code>参数中的设置或<code>package.json</code>中的<code>browserslist</code>设置，找出需要的 <code>polyfill</code>进行部分引入。</p><ul><li>他有三个值，3 个值及具体作用如下表</li></ul></blockquote></li></ol><table><thead><tr><th>属性值</th><th>说明</th></tr></thead><tbody><tr><td>false</td><td>表示引入<strong>全部</strong>的 polyfill，即(core-js 和 regenerator-runtime)包中的所有代码</td></tr><tr><td>entry</td><td>会根据targets配置的目标环境 或browserslist中的配置，找出缺失的 API，然后从 polyfill 中<strong>只引入缺失部分</strong>的 API 代码。</td></tr><tr><td>usage</td><td>他和 entry 一样，会根据目标环境引入缺失的 API，还会考虑使用的 ES6 特性 API 在目标环境中缺失问题。<strong>如果项目中使用的某些 API 在目标环境中缺失</strong>，他也会把这部分 API 给引入进来</td></tr></tbody></table><p><strong>注意事项</strong></p><blockquote><p><code>useBuiltIns</code>参数虽然是作为<code>@babel/preset-env</code>预设的参数，但是他<strong>主要是解决 <code>JS</code> 中 <code>API</code> 的兼容问题</strong>。</p><p>所以我们要让配置生效，一定要下载<code>@bable/polyfill</code>包或手动下载<code>core-js@3.x.x</code>和<code>regenerator-runtime/runtime</code>包，并且还需要在对应的 <code>JS </code>中通过 <code>import</code> 来引用他们。</p></blockquote><p><strong>代码演示</strong></p><ul><li>接下来我们在之前的项目基础上，修改<code>index.js</code>文件内容如下</li></ul><pre><code>import &quot;core-js/stable&quot;;import &quot;regenerator-runtime/runtime&quot;;&gt;// 只在firefox&gt;=92的浏览器中生效const example = &#123;&#125;;// 对象自身是否有指定的属性const bool = Object.hasOwn(example, &quot;prop&quot;);console.log(&quot;值为&quot;, bool);&gt;// 只在firefox&gt;=34的浏览器中生效const obj = Object.assign(&#123; a: 1 &#125;, &#123; b: 4 &#125;);console.log(obj);</code></pre><ul><li>修改<code>babel.config.js</code>配置文件内容如下</li></ul><pre><code>module.exports = &#123;  presets: [    [      &quot;@babel/preset-env&quot;,      &#123;        // 只考虑firefox版本大于35的浏览器        targets: &quot;Firefox &gt; 35&quot;,        useBuiltIns: &quot;entry&quot;,        // 这里不指定corejs的版本，默认采用core-js@2.x.x版本，而本案例中安装的是3版，所以要指定，否则打包后会与预期的效果不一样。        corejs: &quot;3.24.1&quot;,      &#125;,    ],  ],&#125;;</code></pre><p><strong>注：</strong></p><blockquote><ul><li>接下来，我们在当前目录下执行<code>npx webpck</code>打包，打包后在浏览器中访问<code>index.html</code>页面。同时我们在控制台执行<code>[1,2,[3,[4],5]].flat(3)</code>代码，最终被成功执行。<blockquote><p>数组的 <code>flat</code> 方法在<code>firefox&gt;=63</code>版本的浏览器中，才原生支持，所以也被成功处理了兼容型。</p></blockquote></li><li>接下来，我们把<code>useBuiltIns</code>的值改为<code>&quot;usage&quot;</code>，再次打包，然后刷新浏览器。同时我们在控制台执行<code>[1,2,[3,[4],5]].flat(3)</code>代码，最终被成功执行。</li></ul><p>通过控制台输出的结果，我相信你已经能够区分<code>entry</code>与<code>usage</code>的区别了。所以简单一点，<code>entry</code>会根据给定的目标环境来引入缺失的<code>API</code>，而<code>usage</code>除了会考虑目标环境中缺失的 <code>API</code>，还会考虑项目中<strong>实际使用</strong>的 API 是否在目标环境中缺失，如果缺失，也会引入这部分 API。</p></blockquote><ol start="3"><li><code>corejs</code> 参数<blockquote><p>通过上面的学习，我们应该知道 <code>corejs</code> 参数的作用了。他主要用来指定 <code>Babel</code> 转码时使用的 <code>core-js</code> 的版本。默认不设置时，值为 <code>2.x.x </code>版本，这时候我们需要安装的 <code>polyfill</code> 为<code>@babel/polyfill</code></p><p>如果设置值为 <code>3.x.x</code> 版本，则需要手动安装<code>core-js@3.x.x</code>和<code>regenerator-runtime</code>两个包。</p><ul><li>这个值只在 useBuiltIns 的值是entry与usage时才生效。</li></ul></blockquote></li></ol><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><blockquote><p>本章重点掌握 loader 与 plugins 是如何配置的。在 Web 前端领域里，我们只需要掌握以下几个方向的 loader 和插件<br>处理 JS 需要用到的 loader 与插件</p><ul><li>babel-loader</li></ul><p>处理 CSS 需要用到的 loader 与插件</p><ul><li>css-loader 与 style-loader</li><li>sass-loader</li><li>min-css-extract-plugin 插件</li></ul><p>处理图片需要用到的 loader</p><ul><li>file-loader 与 url-loader</li><li>html-withimg-loader</li><li>Asset Modules 资源模块</li></ul><p>处理 html 文件需要用到的插件</p><ul><li>html-webpack-plugin</li></ul><p>webpack 开发环境下用到的工具插件<br>clean-webpack-plugin</p><p>Web 前端 CSS 与 JS 兼容处理</p><ul><li>掌握通过使用<code>postcss-loader</code>预处理器与<code>autoprefixer</code>插件来解决 CSS 兼容问题</li><li>掌握如何利用 <code>Babel</code> 来处理 <code>JS</code> 中的兼容问题（其中包括语法和 <code>API</code> 的兼容）</li></ul></blockquote><h3 id="十、Webpack5-开发环境配置"><a href="#十、Webpack5-开发环境配置" class="headerlink" title="十、Webpack5 开发环境配置"></a>十、Webpack5 开发环境配置</h3><blockquote><p>学习开发环境的配置主要目的是为了给开发人员在开发项目时有一个更好的体验。</p><p>本章节我们讲解的开发环境配置有：文件监听与 <code>webpack-dev-server</code> 工具、模块热替换、<code>source map</code>。</p><ul><li>每一项配置的具体功能如下表：</li></ul></blockquote><table><thead><tr><th>配置项</th><th>描述</th></tr></thead><tbody><tr><td>文件监听</td><td>Webpack提供了开启文件监听模式的功能后，当我们修改保存项目代码时，会自动进行重新构建，而不需要再次执行npx webpack命令</td></tr><tr><td>webpack-dev-server 工具</td><td>当安装并启用</td></tr><tr><td>模块热替换</td><td>可以在不刷新浏览器页面情况下，做到局部刷新，只刷新修改过的模块部分的内容，实现实时预览。</td></tr><tr><td>source map</td><td>通过 Webpack 打包后生成的代码与我们的源码完全不一致，可读性很差。当我们需要对这些代码进行调试时，就很麻烦。而 source map 可以帮我们把打包后的代码与源码作一一映射，快速找到问题。</td></tr></tbody></table><h4 id="文件监听"><a href="#文件监听" class="headerlink" title="文件监听"></a>文件监听</h4><blockquote><p><code>Webpack</code>提供了开启文件监听模式的功能后，当我们修改保存项目代码时，会<strong>自动进行重新构建</strong>，而不需要再次执行<code>npx webpack</code>命令</p><p>开启文件监听模式最简单的方法就是在执行<code>npx webpack</code>打包的时候，在后面带上<code>--watch</code>这个参数。</p></blockquote><pre><code>npx webpack --watch</code></pre><blockquote><ul><li>接下来，我们通过一个案例了解监听模式的具体功能</li></ul></blockquote><ul><li>项目目录结构</li></ul><pre><code>icod├─ node_modules├─ package-lock.json├─ package.json├─ src│  └─ index.js└─ webpack.config.js</code></pre><ul><li><code>index.js</code>文件内容</li></ul><pre><code>const username = &quot;icoding&quot;;console.log(username);package.json中devDependencies字段信息如下：&quot;devDependencies&quot;: &#123;    &quot;webpack&quot;: &quot;^5.76.3&quot;,    &quot;webpack-cli&quot;: &quot;^5.0.1&quot;  &#125;</code></pre><ul><li><code>webpack.config.js</code>文件内容如下</li></ul><pre><code>const path = require(&quot;path&quot;);module.exports = &#123;  mode: &quot;none&quot;,  entry: &quot;./src/index.js&quot;,  output: &#123;    path: path.resolve(__dirname, &quot;dist&quot;),    filename: &quot;bundle.js&quot;,  &#125;,&#125;;</code></pre><ol><li>在命令行开启文件监听模式<blockquote><p>项目创建好后，我们在当前目录下执行以下命令开始打包</p></blockquote></li></ol><pre><code>npx webpack --watch</code></pre><ul><li>以上命令就相当于开启了 Webpack 的文件监听模式，<strong>同时</strong>完成了打包工作。在 <code>dist</code> 目录下生成了<code>bundle.js</code>文件</li><li>仔细观察命令行窗口，会发现<code>Webpack</code>的构建信息与以往不同。<strong>该命令行构建程序并没有自动退出</strong>，而且这个时候不能再执行其它命令。</li><li>接下来，我们把<code>index.js</code>文件里<code>username</code>变量的值由<code>icoding</code>改成code，然后保存进行观察。观察命令行，发现 <code>Webpack</code> 自动进行了重新构建，命令行窗口提示了新的构建信息<blockquote><ul><li>这时候我们再查看<code>bundle.js</code>文件，发现里面变量<code>username</code>的值也变成了code</li></ul></blockquote></li></ul><ol start="2"><li>在 Wepack 配置文件中开启文件监听模式<blockquote><p><code>Webpack</code>开启文件监听模式的方式，除了上面的命令行模式外，还可以在<code>Webpack</code>的配置文件里开启。具体设置如下：</p><ul><li>点击 <a href="https://webpack.docschina.org/configuration/watch/#watch">查阅官方文档</a></li></ul></blockquote></li></ol><pre><code>const path = require(&quot;path&quot;);module.exports = &#123;  mode: &quot;none&quot;,  entry: &quot;./src/index.js&quot;,  output: &#123;    path: path.resolve(__dirname, &quot;dist&quot;),    filename: &quot;bundle.js&quot;,  &#125;,  // 开启文件监听模式  watch: true,&#125;;</code></pre><blockquote><p><strong>注：</strong></p><ul><li>不过我们很少在配置文件里配置，因为在实际的开发中，我们并不会选择这种方式来开启文件监听模式，而是会采用接下来进的<code>webpack-dev-server</code>工具</li></ul></blockquote><h4 id="DevServer-工具"><a href="#DevServer-工具" class="headerlink" title="DevServer 工具"></a>DevServer 工具</h4><blockquote><p><code>webpack-dev-server</code>是 Webpack 官方提供的一个 Webpack 服务工具，一般也称它为<code>DevServer</code>。</p><p>当安装并启用<code>webpack-dev-server</code>后，它会<strong>自动</strong>帮我们执行<code>npx webpack</code>打包命令完成<strong>打包</strong>工作，同时还会开启Webpack的<strong>文件监听模式</strong>。最终通过<strong>开启一个本地服务器</strong>来加载构建完成的资源文件，它还有<strong>代理请求</strong>等功能。</p><ul><li>具体的安装和使用（配置）教程 可查阅<a href="https://webpack.docschina.org/configuration/dev-server/">官方文档</a></li></ul></blockquote><ol><li>DevServer 的使用</li></ol><ul><li>首先我们需要执行以下命令，安装<code>webpack-dev-server</code>包</li></ul><pre><code>npm install --save-dev webpack-dev-server</code></pre><ul><li>接下来，我们在前一个项目的基础上，在<code>src</code>文件夹下面新建<code>index.html</code>页面，页面内容如下：</li></ul><pre><code>&lt;body&gt;  网站首页&lt;/body&gt;</code></pre><ul><li>然后修改<code>webpack.config.js</code>配置文件内容如下：</li></ul><pre><code>const path = require(&quot;path&quot;);const HtmlWebpackPlugin = require(&quot;html-webpack-plugin&quot;);module.exports = &#123;  mode: &quot;none&quot;,  entry: &quot;./src/index.js&quot;,  output: &#123;    path: path.resolve(__dirname, &quot;dist&quot;),    filename: &quot;bundle.js&quot;,  &#125;,  // watch:true  plugins: [    new HtmlWebpackPlugin(&#123;      template: &quot;./src/index.html&quot;,      filename: &quot;index.html&quot;,    &#125;),  ],&#125;;</code></pre><ul><li>记得还要安装<code>html-webpack-plugin</code>插件。</li><li>然后，我们在当前目录下执行以下命令</li></ul><pre><code>npx webpack serve</code></pre><ul><li><p>以上命令执行后，它会自动帮我们执行<code>npx webpack</code>打包，同时开启了 <code>Webpack</code> 的文件监听模式。同时开启一个本地服务器来加载构建完成的资源文件。</p></li><li><p>观察命令行终端信息，提示信息如下：（截取了部分内容）</p><img src="devserver.png"></li><li><p>我们在浏览器中打开<code>http://localhost:8080/</code>地址，可以正确的访问到<code>index.html</code>页面，具体如下截图:</p><img src="Dev-localhost.png"></li></ul><p><strong>注意事项</strong></p><blockquote><ul><li>我们并没有在根目录下看见dist目录，是因为<code>webpack-dev-server</code><strong>在编译之后不会写入到任何输出文件</strong></li><li>而是将<code>bundle</code>文件保留在<strong>内存</strong>中，然后将它们 <code>serve</code> 到 <code>server</code> 中，就好像它们是挂载在 <code>server</code> 根路径上的真实文件一样。</li><li>当我们访问<code>http://localhost:8080/</code>地址，默认访问的是<code>output.path</code>指定目录下的<code>index.html</code>文件</li><li>如果修改<code>index.html</code>页面的内容，保存后，发现浏览器中访问的<code>index.html</code>页面内容并<strong>没有变化</strong></li><li>如果修改<code>index.js</code>页面的内容，保存后，这时<code>bundle.js</code>和浏览器中访问的<code>index.html</code>页面内容也更新为<strong>最新内容</strong>了。<blockquote><p>只有打包入口文件相关的依赖文件中的内容被更改后，才会自动开启重新打包。</p></blockquote></li></ul></blockquote><ol><li>DevServer 的常用参数<blockquote><p>DevServer 除了上述默认行为，它还支持自定义参数，通过配置相关参数，可以改变其行为。</p><ul><li>常用的参数有以下：</li></ul></blockquote></li></ol><table><thead><tr><th>参数</th><th>说明</th></tr></thead><tbody><tr><td>open</td><td>是否自动在浏览器中打开服务,true 为自动打开</td></tr><tr><td>port</td><td>指定 Web 服务运行的端口号</td></tr><tr><td>compress</td><td>可设定是否为静态资源开启 Gzip 压缩。</td></tr><tr><td>static</td><td>用于设置静态文件的目录</td></tr><tr><td>hot</td><td>开启模块热替换功能，后面单独来讲</td></tr></tbody></table><blockquote><ul><li>接下来，我们通过代码来演示下。我们在上面项目的基础上，在当前目录下新建<code>public</code>文件夹，然后在<code>public</code>文件夹下新建<code>index.html</code>页面。</li></ul></blockquote><ul><li>最后项目的目录结构如下：</li></ul><pre><code>icoding├─ node_modules├─ package-lock.json├─ package.json├─ public│  └─ index.html├─ src│  ├─ index.html│  └─ index.js└─ webpack.config.js</code></pre><ul><li>接下来，我们更改<code>webpack.config.js</code>文件中的配置如下：</li></ul><pre><code>const path = require(&quot;path&quot;);const HtmlWebpackPlugin = require(&quot;html-webpack-plugin&quot;);module.exports = &#123;  mode: &quot;none&quot;,  entry: &quot;./src/index.js&quot;,  output: &#123;    path: path.resolve(__dirname, &quot;dist&quot;),    filename: &quot;bundle.js&quot;,  &#125;,  // watch:true  plugins: [    new HtmlWebpackPlugin(&#123;      template: &quot;./src/index.html&quot;,      filename: &quot;index.html&quot;,    &#125;),  ],  devServer: &#123;    // 自动打开浏览器    open: true,    // 服务的端口号    port: 8809,    // 为静态资源开启Gzip压缩    compress: true,    // 静态资源访问路径,必需在当前磁盘上存在对应的目录    static: &#123;      // 告诉服务器从哪里提供内容,只有在你希望提供静态文件时才需要这样做      directory: path.resolve(__dirname, &quot;public&quot;),      // 告诉服务器在哪个 URL 上提供 static.directory 的内容      // 比如：通过http://localhost:8809/assets/可以访问当前目录下public文件夹中内容      publicPath: &quot;/assets&quot;,    &#125;,  &#125;,&#125;;</code></pre><ul><li>最后在当前目录下执行<code>npx webpack serve</code>命令，会<strong>新开</strong>一个浏览器窗口打开<code>output.path</code>目录下的<code>index.html</code>文件，访问地址是：<code>http://localhost:8809</code></li><li>如果想要访问当前目录下的<code>public</code>文件夹中的内容，可以能过 <code>http://localhost:8809/assets/</code> 地址访问，该地址默认访问的是<code>public</code>下面的<code>index.html</code>文件，如果需要访问该目录下其它资源，手动修改访问题到该资源就好。</li></ul><p><strong>温馨提示：</strong></p><ul><li>只有在你希望提供<strong>静态文件</strong>时才需要配置<code>static</code>配置。</li><li>如果我们只想访问打包后生成的资源，不用做任何路径相关配置，因为这些打包的资源在内存中，并且访问地址会默认映射到该内存地址访问打包后的资源。</li></ul><ol start="3"><li>模块热替换<blockquote><p>在上面我们使用<code>webpack-dev-server</code>实现了当内容更新后，会<strong>自动刷新整个页面</strong>的功能，从而做到了实时预览代码修改后的效果。</p><p><code>Webpack</code>还有一种更高级的方式来做到实时预览，那就是模块热替换。这种技术不需要重新刷新整个页面，而只是通过<strong>重新加载修改过的模块</strong>来实现实时预览。该技术称为模块热更新，英文名称是<code>Hot Module Replacement</code>，简称<code>HMR</code>。</p><p>在 Webpack5 中，我们只需要在<code>devServer</code>配置中，添加<code>hot</code>选项，将他的值设为 <code>true</code>，就可以开启模块热更新功能。</p></blockquote></li></ol><ul><li>具体如下：</li></ul><pre><code>devServer: &#123;  // ....  // 开启模块热更新  hot: true;&#125;</code></pre><ul><li>不过，在前端项目里，开启模块热替换功能后，我们还需要在使用模块热替换功能的模块中,<strong>添加以下代码来触发模块的自更新</strong>。</li></ul><pre><code>// module.hot 为HotModuleReplacementPlugin插件暴露的接口，是一个对象// 在webpack5之前，需要安装HotModuleReplacementPlugin插件，在webpack5中只要开启模块热替换，就会自动加载这个插件// 以下代码表示，只有在开启了模块热替换，才执行accept方法，否则不执行if (module.hot) &#123;  module.hot.accept(); // 触发自身更新&#125;</code></pre><p><strong>注：</strong></p><blockquote><ul><li>关于模块热替换相关的配置 查阅<a href="https://webpack.docschina.org/api/hot-module-replacement">官方文档</a></li></ul></blockquote><p><strong>使用模块热替换</strong></p><blockquote><ul><li>接下来，我们通过一个案例来演示。</li></ul></blockquote><ul><li>我们在上一个项目的基础上，更新<code>index.js</code>文件的内容如下：</li></ul><pre><code>import &#123; password &#125; from &quot;./login.js&quot;;const username = &quot;icoding&quot;;console.log(username);console.log(password);</code></pre><ul><li>同时在src目录下新建<code>login.js</code>文件，内容如下：</li></ul><pre><code>export const password = 123456;console.log(password);// 只有在启用了模块热替换功能，再执行下面方法触发热替换if (module.hot) &#123;  module.hot.accept(); // 触发当前模块自身热更新&#125;</code></pre><ul><li>最后，当前项目的目录结构如下</li></ul><pre><code>icoding├─ node_modules├─ package-lock.json├─ package.json├─ public│  └─ index.html├─ src│  ├─ index.html│  ├─ index.js│  └─ login.js└─ webpack.config.js</code></pre><ul><li>最后，我们在当前目录执行<code>npx webpack serve</code>命令后，会在浏览器窗口自动打开<code>index.html</code>页面。查看当前页的控制台，可以看到输出的内容</li><li>如果更新<code>login.js</code>内容，就会发现浏览器，只更新了当前更新模块的部分内容</li><li>如果更新<code>index.js</code>内容，就会发现浏览器整个页面刷新了，因为没有启用模块热替换功能</li></ul><h4 id="source-map"><a href="#source-map" class="headerlink" title="source map"></a>source map</h4><blockquote><p>利用 Webpack 编译打包后的代码，<strong>会添加很多与原始代码无关的代码</strong>。如果我们的原始代码一旦有错，在调试的时候就很难找到错误，<strong>因为我们是在打包后的代码上进行调试的</strong>。</p><p>要想在浏览器里能直接看到打包前的原始代码，在原始代码上进行调试，这就需要用到<code>source map</code></p></blockquote><ol><li>使用 source map</li></ol><ul><li>我们在上面代码的基础上，修改<code>index.js</code>中的代码如下：</li></ul><pre><code>import &#123; password &#125; from &quot;./login.js&quot;;const username = &quot;code&quot;;debugger; // 设置断点console.log(s);console.log(username);console.log(password);</code></pre><ul><li>要使用<code>source map</code>只需要在<code>Webpack</code>的配置文件中。<blockquote><ul><li>添加以下配置即可：</li></ul></blockquote></li></ul><pre><code>module.exports = &#123;  // ....  devtool: &quot;source-map&quot;,&#125;;</code></pre><ul><li>接下来，在当前根目录下，执行<code>npx webpack</code>命令再重新打包，打包成功后，刷新 <code>index.html</code> 页面，观察<code>Sources</code>面板，如下图：<img src="source-map.png"></li></ul><p><strong>注：</strong></p><blockquote><ul><li>观察上图，我们发现多了一个<code>index.js</code>文件，也就是打包前的原始代码。</li><li>并且在调试时，可以直接在<code>index.js</code>文件上打断点调试，非常方便</li></ul></blockquote><ol><li>devtool 的值<blockquote><p>因为 <code>devtool</code> 后面的值非常多，所以我们在实际开发中，具体应该选择使用那个值，建议大家参考官方给推荐的，每一种值为什么被推荐，官方给出了明确说明。 详细 查阅<a href="https://webpack.docschina.org/configuration/devtool/#devtool">官方文档</a></p><ul><li>以下是我从官网简单摘录，关于第一种环境下的推荐的 devtool 值。</li></ul></blockquote></li></ol><table><thead><tr><th>推荐</th><th>值</th></tr></thead><tbody><tr><td>开发环境下使用的值</td><td>eval、eval-source-map、eval-cheap-source-map、eval-cheap-module-source-map</td></tr><tr><td>生产环境下使用的值</td><td>none、source-map、hidden-source-map、nosources-source-map（注意看每一种值后面对应的警告信息，<strong>一定不要</strong>让用户能访问到 <code>source-map</code> 文件，会暴露源码，很不安全）</td></tr><tr><td>针对一些特定场景使用的值</td><td>inline-source-map、cheap-source-map、cheap-module-source-map、inline-cheap-module-source-map</td></tr></tbody></table><blockquote><p>生产环境下，一般是不会选择source-map的，所以更推荐大家使用 none</p></blockquote><h3 id="十一、Webpack-生产环境优化"><a href="#十一、Webpack-生产环境优化" class="headerlink" title="十一、Webpack 生产环境优化"></a>十一、Webpack 生产环境优化</h3><h4 id="摇树优化-Tree-Shaking"><a href="#摇树优化-Tree-Shaking" class="headerlink" title="摇树优化 Tree Shaking"></a>摇树优化 Tree Shaking</h4><blockquote><p>在实际开发中，我们通常会用到一些<strong>第三方</strong>的工具函数，如果没有经过任何特殊处理的话，打包时会引入整个包。但实际开发中我们可能只用到了里面极小部分的功能（API），这样将整个工具函数的代码都打包进来，体积就太大了。</p><p>有没有什么办法，<strong>只帮我们引入在我们的代码中用到的那部分代码</strong>呢 ？有，那就是我们接下来讲到的<code>Tree Shaking</code>。</p><p><code>Tree Sharking</code>可以帮我们检测模块中没有用到的那块代码，并在 Webpack 打包时将没有使用到的代码块移除，减小打包后的资源体积。它的名字也非常形象，通过摇晃树，把树上干枯无用的叶子摇掉。</p><p>Webpack5 中<strong>内置</strong>了这个功能，在生产环境打包时，Webpack 会<strong>自动开启</strong><code>Tree Shaking</code>功能，将没有用到的那部分代码给删除。</p></blockquote><p><strong>我们创建一个简单的项目来演示下</strong></p><ul><li>当前项目目录结构如下</li></ul><pre><code>icoding├─ node_modules├─ package-lock.json├─ package.json├─ src│  └─ index.js└─ webpack.config.js</code></pre><ul><li><code>index.js</code>文件的代码如下</li></ul><pre><code>function max(a, b) &#123;  return a &gt; b ? a : b;&#125;function min(a, b) &#123;  return a &gt; b ? b : a;&#125;console.log(1);package.json文件内容如下： &quot;devDependencies&quot;: &#123;    &quot;webpack&quot;: &quot;^5.76.3&quot;,    &quot;webpack-cli&quot;: &quot;^5.0.1&quot;,  &#125;webpack.config.js文件内容如下：const path = require(&quot;path&quot;);module.exports = &#123;  mode: &quot;production&quot;,  entry: &quot;./src/index.js&quot;,  output: &#123;    path: path.resolve(__dirname, &quot;dist&quot;),    filename: &quot;bundle.js&quot;,  &#125;,&#125;;</code></pre><ul><li>接下来，在当前根目录下执行<code>npx webpack</code>打包，打包后生成的<code>bundle.js</code>文件内容如下：</li></ul><pre><code>console.log(1);</code></pre><ul><li>观察以上代码，我们可以得出，没有用到的min和max函数，都被删除了。</li></ul><h4 id="资源压缩"><a href="#资源压缩" class="headerlink" title="资源压缩"></a>资源压缩</h4><blockquote><p>资源压缩的主要目的是减小文件体积，以提升页面加载速度或降低带宽消耗等。资源压缩通常发生在<strong>生产环境打包的最后一个环节</strong>，开发环境打包是不需要进行资源压缩处理的。</p><p>资源压缩主要是对 HTML、JS、CSS 文件、图片进行压缩，通常的做法就是整个文件或大段的代码压缩成一行，比如：去掉空格，空行，删除注释，把较长的变量名替换成较短的变量名等。</p><p>图片这类<strong>静态资源</strong>，一般在项目上线后会交由服务端来处理，不需要我们处理。</p><ul><li>接下来，我们创建一个简单的项目来演示下</li></ul></blockquote><ul><li>项目结构如下：</li></ul><pre><code>icoding├─ node_modules├─ package-lock.json├─ package.json├─ src│  ├─ basic.css│  ├─ index.html│  └─ index.js└─ webpack.config.js</code></pre><ul><li><code>index.html</code>文件核心内容如下:</li></ul><pre><code>&lt;body&gt;  网站首页&lt;/body&gt;</code></pre><ul><li><code>index.js</code>文件内容如下：</li></ul><pre><code>import &quot;./basic.css&quot;;const username = &quot;icoding&quot;;const password = 123456;function login(username, password) &#123;  if (username === &quot;icoding&quot; &amp;&amp; password === 123456) &#123;    console.log(&quot;登录成功&quot;);  &#125; else &#123;    console.log(&quot;登录失败&quot;);  &#125;&#125;login(username, password);</code></pre><ul><li><code>basic.css</code>文件内容如下：</li></ul><pre><code>.box1 &#123;  width: 100px;  height: 100px;  background-color: skyblue;  border: 20px solid khaki;  font-size: 20px;  padding: 20px;  margin: 20px;&#125;&gt;.box2 &#123;  width: 100px;  height: 100px;  background-color: skyblue;  border: 20px solid khaki;  font-size: 20px;  padding: 20px;&#125;</code></pre><ul><li><code>package.json</code> 文件的核心内容如下：</li></ul><pre><code> &quot;devDependencies&quot;: &#123;    &quot;css-loader&quot;: &quot;^6.7.3&quot;,    &quot;html-webpack-plugin&quot;: &quot;^5.5.0&quot;,    &quot;mini-css-extract-plugin&quot;: &quot;^2.7.5&quot;,    &quot;webpack&quot;: &quot;^5.76.3&quot;,    &quot;webpack-cli&quot;: &quot;^5.0.1&quot;,    &quot;webpack-dev-server&quot;: &quot;^4.13.1&quot;  &#125;</code></pre><ul><li><code>webpack.config.js</code>文件内容如下：</li></ul><pre><code>const path = require(&quot;path&quot;);const HtmlWebpackPlugin = require(&quot;html-webpack-plugin&quot;);const MiniCssExtractPlugin = require(&quot;mini-css-extract-plugin&quot;);module.exports = &#123;  mode: &quot;none&quot;,  entry: &quot;./src/index.js&quot;,  output: &#123;    path: path.resolve(__dirname, &quot;dist&quot;),    filename: &quot;bundle.js&quot;,  &#125;,  module: &#123;    rules: [      &#123;        test: /\.css$/i,        use: [MiniCssExtractPlugin.loader, &quot;css-loader&quot;],      &#125;,    ],  &#125;,  plugins: [    new HtmlWebpackPlugin(&#123;      template: &quot;./src/index.html&quot;,      filename: &quot;index.html&quot;,    &#125;),    new MiniCssExtractPlugin(),  ],&#125;;</code></pre><ol><li>JS 压缩<blockquote><p>在 Webpack5 中，当我们开启生产环境打包时，JS 代码会自动做压缩处理，并不需要做任何配置。是因为，在安装 Webpack5 时，会<strong>自动</strong>安装<code>terser-webpack-plugin</code>插件，同时在生产环境下打包时，Webpack5 会<strong>自动</strong>使用这个插件来对 JS 做压缩处理。</p></blockquote></li></ol><p><strong>如果我们不想在生产环境打包时</strong>，对 JS 做压缩处理</p><blockquote><ul><li>我们只需要<code>webpack.config.js</code>文件中添加如下配置，就可以。</li></ul></blockquote><pre><code>module.exports = &#123;  // 相关的优化配置，在这里配置  optimization: &#123;    // 不使用插件压缩代码    // 默认值为true，表示使用terser-webpack-plugin 插件来对JS代码压缩。    minimize: false,  &#125;,&#125;;</code></pre><ol start="2"><li>CSS 压缩<blockquote><p>默认配置下，Webpack5 在生产环境打包下，并不会对 CSS 做压缩处理。</p><p>我们需要借助<strong>第三方插件</strong>：<code>css-minimizer-webpack-plugin</code>来帮我们对 CSS 做压缩处理。</p></blockquote></li></ol><ul><li>首先，我们需要执行以下命令，安装<code>css-minimizer-webpack-plugin</code>插件需要的包</li></ul><pre><code>npm install css-minimizer-webpack-plugin --save-dev</code></pre><ul><li>接下来，只要按以下步骤修改<code>webpack.config.js</code>文件，来完成相关插件配置就可以<blockquote><ul><li>使用<code>require</code>方法，来加载插件</li><li>在<code>optimization</code>选项中通过<code>minimize</code>和<code>minimizer</code>属性，告诉 Webpack 需要使用<code>minimizer</code>中的插件来压缩代码。</li></ul></blockquote></li></ul><pre><code>module.exports = &#123;  // ....  optimization: &#123;    // 使用插件压缩代码    minimize: true,    // 提供一个或多个压缩插件，来对打包后的文件作相关压缩，不过会覆盖默认的插件    // 也就是，这样设置后，CSS代码确实压缩，但是JS代码确没有被压缩了    minimizer: [new CssMinimizerPlugin()],  &#125;,&#125;;</code></pre><ul><li>当我们在当前目录执行<code>npx webpack</code>来打包时，打包后的 css 代码确实压缩，压缩后代码如下：</li></ul><pre><code>/* css压缩后 */.box1 &#123;  margin: 20px;&#125;.box1,.box2 &#123;  background-color: skyblue;  border: 20px solid khaki;  font-size: 20px;  height: 100px;  padding: 20px;  width: 100px;&#125;</code></pre><blockquote><ul><li>但是 JS 代码却没有被压缩了。是因为<code>minimizer:[new CssMinimizerPlugin()]</code>设置，<strong>覆盖了默认的 JS 压缩插件</strong>。</li></ul></blockquote><blockquote><ul><li>如果想要 JS 和 CSS 都能被压缩，则需要在<code>minimizer</code>对应数组中添加 JS 压缩插件。官方说明文档中提到，可以在 <code>optimization.minimizer</code> 中可以使用 <code>&#39;...&#39;</code> 来访问默认值（JS 压缩插件）。</li></ul></blockquote><ul><li>接下来我们把<code>webpack.config.js</code>配置文件中<code>optimization</code>项的内容，修改如下：</li></ul><pre><code>module.exports = &#123;  optimization: &#123;    minimize: true,    // ...表示，webpack5自带的JS压缩插件    minimizer: [new CssMinimizerPlugin(), &quot;...&quot;],  &#125;,&#125;;</code></pre><ul><li>最后，我们再在当前目录下执行npx webpack打包，打包后的 JS 与 CSS 都做了压缩处理。</li></ul><ol start="3"><li>HTML 压缩<blockquote><p>还记得，在前面学习<code>html-webpack-plugin</code>插件时，在这个插件中通过配置<code>minify</code>参数，就可以控制打包后的 <code>HTML</code> 代码是否需要做压缩处理。</p><p>如果<code>minify</code>的值为<code>false</code>表示不对打包后的 HTML 压缩，<code>true</code>表示做压缩处理。他的默认值就是 <code>true</code>，所以如果要做压缩处理，也可以不用写这个配置。</p></blockquote></li></ol><pre><code>plugins:[new HtmlWebpackPlugin(&#123;        template:&quot;./src/index.html&quot;,        filename:&quot;index.html&quot;,        // minify的值为false表示不对打包后的HTML压缩，true表示压缩        // 默认值就是true，所以如果要做压缩处理，也可以不用写这个配置        minify:true    &#125;),new MiniCssExtractPlugin() ],</code></pre><h4 id="缩小查找范围"><a href="#缩小查找范围" class="headerlink" title="缩小查找范围"></a>缩小查找范围</h4><blockquote><p>在 Webpack 打包时，我们可以通过以下几个方面来<strong>减少打包所需要的时间</strong></p><ul><li>排除那些不需要被预处理器解析的模块</li><li>帮助 Webpack 快速找到需要的模块</li><li>帮助 Webpack 识别不带后缀名的文件<br>接下来，我们就从上面三个方向来讲解一些常见的缩小查找范围的方法</li></ul></blockquote><ol><li>配置预处理器的 exclude 与 include<blockquote><p>在使用预处理器解析模块的时候，可以通过配置 exclude 和 include 来减少需要处理的模块。</p><ul><li><code>exclude</code>：排除不需要使用当前预处理器来处理的文件夹目录</li><li><code>include</code>：指定当前预处理器只对哪些目录中匹配的文件做预处理</li></ul></blockquote></li></ol><ul><li>当exclude与include<strong>同时指定</strong>时，以<code>exclude</code>的设置为主</li></ul><pre><code>module.exports = &#123;  // ....  module: &#123;    rules: [      // 预处理器      &#123;        test: /\.js$/,        exclude: /node_modules/,        include: /src/,        use: &#123;          loader: &quot;babel-loader&quot;,        &#125;,      &#125;,    ],  &#125;,&#125;;</code></pre><ol start="2"><li><code>module.noParse</code><blockquote><p>在实际开发中，我们有可能用到<strong>第三方模块</strong>，这些模块本身没有依赖任何的第三方模块（内部使用<code>import</code>或<code>require</code>关键字），所以<strong>不需要再用相关的预处理器来解析</strong>。</p><p><code>module.noParse</code>：可以让 webpack <strong>忽略</strong>对部分没有采用模块化的文件的递归解析和处理，以提高构建性能</p></blockquote></li></ol><ul><li><code>modlue.noParse</code>的值可以是字符串，正则表达式和数组。具体设置如下：</li></ul><pre><code>module.exports = &#123;  // ....  module: &#123;    noParse: /login/, // login.js文件不需要解析，其内部没有使用第三方模块  &#125;,&#125;;</code></pre><p><strong>我们来看下面这个例子</strong></p><ul><li>项目目录结构</li></ul><pre><code>icode├─ node_modules├─ babel.config.json├─ package-lock.json├─ package.json├─ src│  ├─ index.js│  ├─ login.js│  └─ search.js└─ webpack.config.js</code></pre><ul><li><code>index.js</code> 文件</li></ul><pre><code>import &quot;./login&quot;;const a = 1;const b = 2;console.log(a, b);</code></pre><ul><li><code>login.js</code>文件</li></ul><pre><code>import &quot;./search&quot;;&gt;const username = &quot;icoding&quot;;const password = 123456;console.log(username, password);</code></pre><ul><li><code>search.js</code>文件</li></ul><pre><code>const n = 1;const m = 2;console.log(1, 2);package.json文件内容 &quot;devDependencies&quot;: &#123;    &quot;@babel/core&quot;: &quot;^7.21.3&quot;,    &quot;@babel/preset-env&quot;: &quot;^7.20.2&quot;,    &quot;babel-loader&quot;: &quot;^9.1.2&quot;,    &quot;webpack&quot;: &quot;^5.76.3&quot;,    &quot;webpack-cli&quot;: &quot;^5.0.1&quot;  &#125;</code></pre><ul><li><code>webpack.config.js</code>文件内容</li></ul><pre><code>const path = require(&quot;path&quot;);module.exports = &#123;  mode: &quot;none&quot;,  entry: &quot;./src/index.js&quot;,  output: &#123;    path: path.resolve(__dirname, &quot;dist&quot;),    filename: &quot;[name].js&quot;,  &#125;,  module: &#123;    rules: [      &#123;        test: /\.js$/,        exclude: /node_modules/,        use: &#123;          loader: &quot;babel-loader&quot;,          options: &#123;            presets: [&quot;@babel/preset-env&quot;],          &#125;,        &#125;,      &#125;,    ],    // login文件中，不需要再递归解析    noParse: /login/,  &#125;,&#125;;</code></pre><p><strong>注：</strong></p><ul><li>最后在当前目录执行<code>npx webpack</code>命令打包，发现在打包后的<code>main.js</code>文件中，还保留了<code>import &#39;./search&#39;</code>语句，说明打包时，并<strong>没有</strong>对<code>login.js</code>文件进行递归解析。</li><li>当然，这样打包后的内容肯定是有问题的，所以我们要指定某个文件不需要被解析的<strong>前提</strong>是，这些文件内部没有使用<code>import</code>或<code>require</code>这样的语句。</li></ul><ol start="3"><li><code>resolve.modules</code></li></ol><ul><li><code>resolve.modules</code>用来配置 Webpack 如何搜寻第三方模块的路径。</li><li><code>resolve.modules</code>的值可以是相对路径，也可以是绝对路径，他的默认值是[‘node_modules’]这是一个相对路径。<blockquote><p>当我们使用 <code>import</code> 等语句来加载第三方模块时，如下：</p></blockquote></li></ul><pre><code>import axios from &#39;axios&#39;</code></pre><ul><li>上面代码表示，Webpack 在打包时，<strong>默认</strong>会在当前目录的<code>./node_modules</code>下搜索 <code>axios</code> 模块</li><li>如果没有找到，则会到<strong>上一级目录</strong><code>../node_modules</code>下找</li><li>如果还没找到，则会再去<code>../../node_modules</code>下找，以此类推，直到找到为止。如果找不到，最后就会抛出错误。</li></ul><blockquote><p>我们的第三方模块都是保存在项目根目录的<code>node_modules</code>下，因此<strong>没有必要</strong>一级一级向上找。主要考虑的时，当我们的地址写错时，一层一层向上找，最后找不到再抛出错误，浪费了大量的时间。所以，<strong>我们可以指定第三方模块的搜索地址为绝对地址</strong>，就是我们当前项目目录下的<code>node_modules</code>文件夹中找，找不到就直接抛错，</p></blockquote><ul><li>以下是<code>resolve.modules</code>的配置</li></ul><pre><code>module.exports = &#123;  // ...  resolve: &#123;    modules: [path.resolve(__dirname, &quot;node_modules&quot;)],  &#125;,&#125;;</code></pre><ol start="4"><li><code>resolve.extensions</code><blockquote><p>在我们引入（导入）自定义模块时，我们通常会采用以下简写形式</p></blockquote></li></ol><pre><code>import &#123; username &#125; from &quot;./login&quot;;</code></pre><ul><li>以上代码并没有指定 login 文件的后缀名是以<code>.js</code>还是.<code>json</code>等其它格式。那 Webpack 是如何知道这个文件最后是以.js结尾的后缀名呢？</li><li><code>resolve.extensions</code>就是 Webpack 识别不带后缀名文件的关键。他的默认值是：<code>[&#39;.js&#39;, &#39;.json&#39;, &#39;.wasm&#39;]</code>。</li></ul><blockquote><p>Webpack 在解析到这些不带后缀名的文件后，会按数组<code>[&#39;.js&#39;, &#39;.json&#39;, &#39;.wasm&#39;]</code>中的元素<strong>从头到尾的顺序</strong>尝试找到对应的文件，如果找到了，后面的格式就不匹配了，如果没找到一直往后匹配，直到找到为止。如果都匹配完还没找到就会抛出错误。</p></blockquote><ul><li>如果<code>resolve.extensions</code>指定的数组中的项越多，那 Webpack 尝试搜寻的次数就越多，这会影响 Webpack 的解析速度。所以我们可以根据我们的实际项目来合理的配置<code>resolve.extensions</code>的值。</li></ul><p><strong>配置的规则：</strong></p><ul><li><p>出现频率高的放在最前，以免能最快找到对应文件</p></li><li><p>没有用到的后缀名，不要出现，这样在找不到对应文件后，会尽快抛出错误。</p><blockquote><p>如果很在乎这些解析时间，那最好是在导入语句中带上后缀名。</p></blockquote></li><li><p>配置代码如下：</p></li></ul><pre><code>module.exports = &#123;  //...  resolve: &#123;    extensions: [&quot;.js&quot;, &quot;.css&quot;, &quot;.json&quot;],  &#125;,&#125;;</code></pre>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 工程化 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>前端工程化（一）</title>
      <link href="/2024/01/11/%E5%89%8D%E7%AB%AF%E5%B7%A5%E7%A8%8B%E5%8C%96%EF%BC%88%E4%B8%80%EF%BC%89/"/>
      <url>/2024/01/11/%E5%89%8D%E7%AB%AF%E5%B7%A5%E7%A8%8B%E5%8C%96%EF%BC%88%E4%B8%80%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<span id="more"></span><h3 id="一、常见的-DOS-命令"><a href="#一、常见的-DOS-命令" class="headerlink" title="一、常见的 DOS 命令"></a>一、常见的 DOS 命令</h3><blockquote><p><code>DOS</code>（Disk Operating System）磁盘操作系统，是早期个人计算机上的一类操作系统，和我们现在常用的<code>Windows</code>系统是一个意思。</p><p>在<code>Windows</code>系统还没有出来之前，那时候电脑的主流系统就是<code>DOS</code>，只能通过黑窗口来操作电脑。</p><p>虽然现在的电脑主流使用的都是<code>Windows</code>系统，但在<code>Windows</code>系统中一直保留有<code>DOS</code>系统！作为程序员，有些时候我们需要通过<code>DOS</code>命令来执行一些操作，所以我们还是需要对<code>DOS</code>命令做相关了解。</p></blockquote><ol><li>如何进入 DOS 系统</li></ol><ul><li>在 Window 系统中，按<strong>键盘上的<code>win</code>+R 键</strong>，可以打开运行窗口，在窗口中输入 cmd，然后回车，就会弹出一个黑窗口(这就是 DOS 系统的主界面)，我们就可以在黑窗口中通过 DOS 命令来执行相关操作。</li><li>或把鼠标移到电脑右下角**<code>win</code>这个图标**上，点击后，输入 cmd 然后按回车，就会弹出一个黑窗口…</li><li>可以直接在打开的<strong>文件夹路径</strong>，直接输入 cmd，然后回车，这里进入到的黑窗口显示的路径为当前文件夹所在的路径。</li></ul><ol start="2"><li>常见的 DOS 命令</li></ol><table><thead><tr><th>命令</th><th>说明</th></tr></thead><tbody><tr><td>dir</td><td>列出当前目录下的所有文件</td></tr><tr><td>cd</td><td><code>cd \</code> 退回到根目录；<code>cd test</code> 表示进入到<code>test</code>子目录；<code>cd ..</code>返回到上一层目录</td></tr><tr><td>c:</td><td>改变当前盘符命令，切换到 c 盘</td></tr><tr><td>md</td><td>在当前目录下新建一个文件夹</td></tr><tr><td>rd</td><td><code>rd test</code>表示 删除当前目录下的 test 文件夹（前提是当前目录为空，不为空不能删除）</td></tr><tr><td>tree</td><td>显示当前目录下的目录结构（只显示文件夹名，不包含文件名）</td></tr><tr><td>cls</td><td>清屏幕命令，清除屏幕上的所有显示，光标置于屏幕左上角</td></tr></tbody></table><ol start="3"><li>特殊命令</li></ol><table><thead><tr><th>命令</th><th>说明</th></tr></thead><tbody><tr><td>向上箭头<code>↑</code>和向下箭头<code>↓</code></td><td>回看上一次执行的命令，可以一直按到第一次&#x2F;最后一次输入命令</td></tr><tr><td><code>Ctrl + c</code>快捷键</td><td>中断操作</td></tr><tr><td>tab 键</td><td>自动补全文件名（会根据书写的字母来匹配当前目录的文件），如果有多个相同前缀的文件名，可以按<code>tab</code>切换</td></tr></tbody></table><ol start="4"><li>环境变量<blockquote><p>当我们想要通过 <code>DOS</code> 命令来打开<code>demo</code>文件夹中的<code>hello.txt</code>文件时，我们只需要进入到当前目录，然后在路径后面输入<code>hello.txt</code>就可以打开这个文件了。</p></blockquote></li></ol><pre><code>C:\Users\EDY\Desktop\demo&gt; hello.txt</code></pre><ul><li>但如果我们想在<strong>任意的目录下</strong>，输入<code>hello.txt</code>时，都能打开<code>demo</code>目录下的<code>hello.txt</code>文件，那要如何做到呢？这就需要配置环境变量了。</li></ul><p><strong>环境变量</strong>：一般是指在操作系统中用来指定操作系统运行环境的一些参数。你可以简单理解为 window 系统中的变量，用来保存文件夹位置等信息。</p><p><strong>配置环境变量</strong></p><ul><li>第一步：复制<code>hello.txt</code>文件所在的绝对路径</li><li>第二步：在电脑桌面我的电脑上右击—属性—高级系统—环境变量—–&gt; 用户变量（每个变量都有特定的用处）我们主要来看 <code>Path</code> 变量，双击 <code>Path</code> 变量，在弹出的新窗口中把<code>hello.txt</code>文件所在的绝对路径保存在在这里。</li><li>配置好环境变量，需要把黑窗口关闭，<strong>重新打开</strong>才会生效。之后不管我们在哪个目录下输入<code>hello.txt</code>，都可以打开<code>hello.txt</code>文件。</li></ul><blockquote><p><strong>总结：</strong><br>当我们在命令行窗口打开一个文件或调用一个程序时，系统会首先在当前目录下寻找，如果找到就直接打开，如果没找到，则会<strong>依次到环境变量的 path 路径中寻找</strong>，如果找到就直接打开，如果没找到，最后就会报错。</p><ul><li>其查找方式和我们 JS 中变量查找的规则类似。</li></ul><p><strong>什么情况下需要配环境变量</strong></p><ul><li>如果我们需要一个命令能在任意位置都可以生效，就可以配置对应的环境变量。</li></ul></blockquote><ol start="5"><li><p>Windows、Linux、Mac 它们都使用什么命令</p><blockquote><ul><li>DOS 命令是基于<code>Windows</code>操作系统的命令行工具，它提供了一系列命令，可以用于执行各种操作，例如文件管理、系统配置、网络设置等等。</li><li>在 <code>Mac </code>操作系统中，命令行工具是基于<code>Unix</code>操作系统的，因此使用的命令是 Unix 命令。Mac 上的命令行工具被称为终端（Terminal），通过它可以使用诸如 ls、cd、cp、rm 等命令。</li><li>在 Linux 操作系统中，命令行工具也是基于<code>Unix</code>操作系统的，因此同样使用的是 Unix 命令。Linux 上的命令行工具可以通过终端（Terminal）或控制台（Console）来访问，可以使用诸如 ls、cd、cp、rm 等命令。</li></ul></blockquote></li><li><p>DOS 命令 与 Mac 和 Linux 的命令有什么区别</p></li></ol><ul><li>主要区别如下</li></ul><table><thead><tr><th>区别</th><th>DOS</th><th>Mac和Linux</th></tr></thead><tbody><tr><td>文件路径</td><td>使用反斜杠<code>\</code>分隔</td><td>使用正斜杠<code>/</code>分隔</td></tr><tr><td>命令名称</td><td>dir</td><td>ls</td></tr><tr><td>命令参数</td><td>以斜杠<code>/</code>开头</td><td>以破折号<code>-</code>或双破折号开头</td></tr><tr><td>环境变量</td><td>使用<code>%变量名%</code>表示</td><td>使用<code>$</code>变量名表示</td></tr><tr><td>文件权限</td><td>无此概念</td><td>使用所有者和权限控制</td></tr></tbody></table><p><strong>注：</strong></p><ul><li>这只是一些基本区别的简单概述，实际上每个系统都有大量的命令和特定的功能，因此这些区别只是一些常见的差异</li></ul><h3 id="二、Node-相关知识"><a href="#二、Node-相关知识" class="headerlink" title="二、Node 相关知识"></a>二、Node 相关知识</h3><h4 id="什么是-Node"><a href="#什么是-Node" class="headerlink" title="什么是 Node"></a>什么是 Node</h4><ul><li>Node.js 是一个基于 Chrome V8 引擎的 JavaScript 运行时环境。</li><li>Node.js 为 JavaScript 提供了在服务端运行的环境，使得 JavaScript 也能开发服务端的程序，前后端统一语言，统一模型的梦想得以实现</li></ul><blockquote><p>Node.js 2009 年诞生，2015 到 2016 左右在中国就火起来了，Node 火了之后带来了连锁反应。2016 年前后，以 webpack 为代表的 Node.js 工作流工具 使前端开发的开发形式产生了翻天覆地的变化。并且，随着 Vue &#x2F; React 的诞生，使前端开发进入了框架时代。</p><p>在今天，可以说前端开发 “上天入地，无所不能”：PC 端 web 开发、移动 web 开发、APP 开发、小程序开发、服务端开发等等都能搞定。</p></blockquote><p><strong>注：</strong></p><blockquote><p>我们日常听到 Node.js 时，要注意区分他到底说的是 <strong>平台</strong> 还是 <strong>Node.js 语言</strong>，因此我们讲 Node.js 有两个层面的含义：</p></blockquote><ul><li>Node.js 是个平台或工具，即在 Node.js 平台上安装模块或包，类似于前端在浏览器上安装插件一样</li><li><code>Node.js 语言 = 后端 JavaScript = ECMAScript + IO + File + ... </code>等服务端的操作</li></ul><h4 id="Node-的基本使用"><a href="#Node-的基本使用" class="headerlink" title="Node 的基本使用"></a>Node 的基本使用</h4><blockquote><p>在没有 Node.js 之前，JS 是没有办法单独运行的，只能插入到 html 页面，在浏览器中运行。</p><p>现在有了 Node.js，我们可以通过 node 命令在 node 平台上直接运行 JS 文件了。</p></blockquote><p><strong>案例演示</strong></p><ul><li>在demo文件夹下，新建<code>test.js</code>文件，内容如下</li></ul><pre><code>console.log(&quot;test&quot;);</code></pre><ul><li><p>在当前目录下打开 <code>VScode</code> 命令终端，然后输入以下命令，<code>test.js</code>就被执行，并在终端输出了<code>test</code></p><img src="node的基本使用.png"></li><li><p>node 后面为需要执行的 JS 文件，前提是<strong>路径</strong>要写对，否则会报错，找不到对应模块；</p></li><li><p>只输入文件名时，只能在当前文件所在目录下加载，否则找不到文件就会报错</p></li></ul><h4 id="Node-中模块系统"><a href="#Node-中模块系统" class="headerlink" title="Node 中模块系统"></a>Node 中模块系统</h4><blockquote><p>在<code>ES6</code>中我们学习过<code>Module</code>模块系统，在<code>Module</code>中使用<code>export</code>和<code>export default</code>来为模块指定输出的接口，利用 <code>import</code> 来导入（加载）模块。</p><p>我们知道，模块系统是为了解决模块化过程中产生的一系列的问题。那什么是模块化，模块化有什么好处，又会产生什么问，模块系统是如何解决这些问题的 ？<br>我们一起来复习下</p></blockquote><p><strong>什么是模块化</strong></p><ul><li>所谓的模块化就是把一个大的文件，拆分成许多个独立的相互依赖的小文件，这些小的文件我们就称为一个一个的模块。这些小的模块按一定的规则组合起来就能完成某个具体的功能。</li></ul><p><strong>模块化的好处</strong></p><ul><li>提高代码的复用性</li><li>可以提高代码的可维护性</li><li>可以实现按需加载</li></ul><p><strong>模块化产生的三个问题：</strong></p><ul><li>JS 模块化的问题（如何让一个 JS 文件就是一个模块，有自己独立的作用域）</li><li>变量命名冲突问题</li><li>管理模块间的加载顺序问题</li></ul><blockquote><p>模块系统，就是为了解决模块化过程中产生的问题，如上面提到的 3 个问题。那<strong>Node 中的模块系统</strong>是如何解决模块化产生的问题，就是我们接下来要学习的。</p></blockquote><ul><li>Node 的模块系统，与 ES6 中的 Module 模块基本思想是一样，但语法和用法不一样。</li><li><a href="https://www.nodeapp.cn/">Node.js 中文网站（非官方）</a></li></ul><ol><li>模块的分类<blockquote><p>Node.js 中根据模块的来源，将模块分为 3 大类，分别是：</p></blockquote></li></ol><ul><li>内置模块（Node.js官方提供的模块，如<code>fs、path、http</code>）</li><li>自定义模块（用户自已在创建的<code>.js</code>文件）</li><li>第三方模块（由第三方开发出来的模块（排除 node 官方和用户自定义），使用前需要先下载</li></ul><ol start="2"><li>模块的加载<blockquote><p><code>Node.js</code>中使用<code>require()</code>方法来加载一个模块，不过对于不同类别的模块加载时，路径的书写不太一样</p></blockquote></li></ol><ul><li>加载内置模块，直接在require中书写模块的名字就好</li></ul><pre><code>const fs = require(&quot;fs&quot;);</code></pre><ul><li>加载自定义模块，需要写好对应的路径，JS文件的后缀名也可以省略不写</li></ul><pre><code>const myCoustom = require(&quot;./myCoustom.js&quot;);//或 const myCoustom=require(&quot;./myCoustom&quot;);</code></pre><ul><li>加载第三方模块，需要用npm下载对应模块，然后才能用requier导入，导入时只需要写对应的名字就好</li></ul><pre><code>const axios = require(&quot;axios&quot;);</code></pre><blockquote><p>注：</p></blockquote><ul><li><code>require()</code>方法在加载模块后，会将模块中的代码执行一遍，多次导入相同的模块，<strong>只会执行一次</strong></li><li>关于 module 相关的内容可<a href="https://www.nodeapp.cn/modules.html#modules_exports_shortcut">查阅文档</a></li></ul><ol start="3"><li><p>模块作用域</p><blockquote><p>在自定义模块中的变量和方法等，<strong>只能在当前模块内被访问</strong>，模块外是没有办法访问的，我们把这种访问的限制，叫做<strong>模块的作用域</strong></p><ul><li>模块的作用域解决了全局变量污染的问题<img src="模块作用域.png"></li></ul></blockquote></li><li><p>module 对象-共享模块成员</p><blockquote><p>Node.js 中每个<code>.js</code>自定义模块中都有一个<code>module</code>对象，它里面存储了当前模块相关的信息，通过<code>module.exports</code> 这个属性（这个属性值是一个对象）将模块内的成员共享出去，供外界使用。</p><ul><li>在利用<code>require()</code>方法导入自定义模块时，得到的就是 <code>module.exports</code>所指向的对象。<img src="module对象.png"></li></ul></blockquote></li><li><p>exports 对象 - 共享模块成员</p></li></ol><ul><li>当我们通过<code>module.exports.username</code>共享成员时，可以简写成<code>exports.username</code>，<code>exports</code>相当于这种情况下的一个<strong>快捷键</strong>。</li><li><code>exports</code>在模块被执行前被赋予<code>module.exports</code>的值，也就是在模块被执行前，<code>exports</code>和<code>module.exports</code>指向**同一个对象<code>&#123;&#125;</code>**。</li></ul><blockquote><p>但最终模块对外共享的结果，还是以<code>module.exports</code>指向的对象为准</p></blockquote><p><strong>判断以下模块最终共享的结果：</strong><br>情况一：</p><pre><code>module.exports = &#123;  a: 1,  b: 2,&#125;;exports.c = 3;// 最终输出结果： &#123; a: 1, b: 2 &#125;</code></pre><ul><li>在模块被执行前，<code>exports</code>和<code>module.exports</code>都指向同一个对象<code>&#123;&#125;</code></li><li>执行<code>module.exports=&#123;a: 1,b: 2,&#125;</code>，<code>module.exports</code>指向了一个新对象</li><li><code>exports.c = 3;</code>给<code>&#123;&#125;</code>添加了新属性<code>c</code>，因此：<code>exports</code>指向<code>&#123; c : 3&#125;</code></li><li>但是！最终模块对外共享的结果，还是以<code>module.exports</code>指向的对象为准，所以最终输出结果：<code>&#123;a: 1,b: 2,&#125;</code></li></ul><p>情况二：</p><pre><code>module.exports = &#123;  a: 1,  b: 2,&#125;;exports = &#123;  c: 3,&#125;;// 最终输出结果： &#123; a: 1, b: 2 &#125;</code></pre><ul><li>在模块被执行前，<code>exports</code>和<code>module.exports</code>都指向同一个对象<code>&#123;&#125;</code></li><li>执行<code>module.exports=&#123;a: 1,b: 2,&#125;</code>，<code>module.exports</code>指向了一个新对象</li><li><code>exports</code>也指向了一个新对象<code>&#123; c : 3&#125;</code></li><li>但是！最终模块对外共享的结果，还是以<code>module.exports</code>指向的对象为准，所以最终输出结果：<code>&#123;a: 1,b: 2,&#125;</code></li></ul><p>情况三</p><pre><code>exports.c = 3;module.exports.a = 1;module.exports.b = 2;// 最终输出结果： &#123; c: 3, a: 1, b: 2 &#125;</code></pre><ul><li>在模块被执行前，<code>exports</code>和<code>module.exports</code>都指向同一个对象<code>&#123;&#125;</code></li><li>执行<code>exports.c = 3;</code>，它给<code>&#123;&#125;</code>新增一个属性<code>c</code>，因此<code>exports</code>指向<code>&#123; c : 3 &#125;</code></li><li>执行后两行代码，<code>module.exports</code>给对象<code>&#123; c : 3 &#125;</code>又新增了新属性<code>a,b</code>，因此<code>module.exports</code>指向<code>&#123; c:3 , a:1 , b:2&#125;</code></li><li>因为<code>exports</code>和<code>module.exports</code>都是通过打点的方式新增属性，所以没有改变指向，一直都指向同一个对象，后面的操作都只是在这个对象上添加新的属性。</li></ul><p>情况四</p><pre><code>exports = &#123;  c: 3,&#125;;module.exports = exports;module.exports.a = 1;module.exports.b = 2;// 最终输出结果： &#123; c: 3, a: 1, b: 2 &#125;</code></pre><blockquote><ul><li>在模块被执行前，<code>exports</code>和<code>module.exports</code>都指向同一个对象<code>&#123;&#125;</code></li><li><code>exports</code>指向了新对象<code>&#123;  c : 3 &#125;</code></li><li><code>module.exports = exports;</code>使得<code>module.exports</code>也指向了<code>exports</code>的新对象<code>&#123;  c : 3 &#125;</code></li><li>后面两行代码都是在给新对象添加属性<code>a,b</code></li><li>最终模块对外共享的结果，还是以<code>module.exports</code>指向的对象为准，所以最终输出结果：<code>&#123; c: 3, a: 1, b: 2 &#125;</code></li></ul></blockquote><ol start="6"><li><code>Node.js</code>中模块化规范<blockquote><p><code>Node.js</code>中遵循了<code>CommonJS</code>模块化规范（不过与 <code>CommonJS</code>还存在细微差别，这里不做讲解），其规范如下：</p></blockquote></li></ol><ul><li>每个模块都有一个 module 变量，这个变量代表当前模块</li><li>module 变量是一个<strong>对象</strong>，它有一个 <code>exports</code> 属性，用来对外共享成员</li><li>利用 <code>require()</code> 方法加载模块，加载的就是 <code>module.exports</code> 导出的值</li></ul><h4 id="fs-文件模块"><a href="#fs-文件模块" class="headerlink" title="fs 文件模块"></a>fs 文件模块</h4><blockquote><p><code>fs</code>模块，为<code>Node.js</code>中提供的操作文件系统的模块，我们这里简单学习下<code>fs</code>模块的<code>readFile()</code>与<code>readFileSync()</code>方法</p></blockquote><pre><code>fs.readFile(path, options, callback); // 异步读取fs.readFileSync(path, options); // 同步读取</code></pre><ul><li><code>path</code> 文件名</li><li><code>options</code>参数，可以用来指字符编码，比如<code>&quot;utf8&quot;</code></li><li><code>callback</code>回调函数，文件读取响应结果后要调的，回调函数有两个参数<code>err</code>和<code>data</code>，<code>err</code>表示失败的对象，<code>data</code>成为读取的结果</li></ul><ol><li>基本使用</li></ol><ul><li><p>在同一目录<code>D:\web\gitwork\Engineering\practice\Node&gt;</code>下，新建<code>index.js</code>和<code>hello.txt</code>文件</p></li><li><p><code>hello.txt</code>文件内容如下</p></li></ul><pre><code>大家好</code></pre><ul><li><code>index.js</code>文件内容如下</li></ul><pre><code>const fs = require(&quot;fs&quot;);// 同步读取hello.txt文件中内容const txt = fs.readFileSync(&quot;./hello.txt&quot;, &quot;utf8&quot;);console.log(txt);// 异步读取hello.txt文件中内容const txt2 = fs.readFile(&quot;./hello.txt&quot;, &quot;utf8&quot;, (err, data) =&gt; &#123;  if (err) &#123;    throw new Error(&quot;文件读取失败&quot;);  &#125; else &#123;    console.log(data);  &#125;&#125;);</code></pre><ul><li>当在目录<code>...\Node</code>下执行<code>node index.js</code>命令时，在控制台能正常输出结果：”大家好”   “大家好”</li><li>当在目录<code>...\practice</code>下执行<code>node .\Node\path.js</code>命令时，<strong>抛出错误</strong>。这里为什么呢 ？</li></ul><blockquote><p>因为<code>node</code>命令在执行时，他会在<code>\practice\hello.txt</code>这个路径中找<code>hello.txt</code>文件，那肯定是找不到了。所以在 <code>node</code>中使用<code>./</code>来表示相对路径是非常危险的。</p><ul><li>不过用<code>require(&#39;./index.js&#39;)</code>方式来导入模块时，<strong>不需要</strong>特别处理，内部处理过了</li></ul></blockquote><ul><li>那如何保证<strong>在不同的目录下</strong>执行<code>index.js</code>文件，都能正常的找到文件呢？接下来我们就学习 <code>node</code> 中的<code>path</code>模块和<code>__dirname</code>全局变量，来解决这个问题。</li></ul><h4 id="path-路径模块"><a href="#path-路径模块" class="headerlink" title="path 路径模块"></a>path 路径模块</h4><blockquote><p><code>path</code>模块是<code>Node.js</code>内置模块，该模块提供了一些工具函数，用于处理文件与目录的路径。</p></blockquote><ul><li><p>我们主要学习 <code>path</code> 模块提供的<code>resolve()</code>方法</p></li><li><p>该方法用于把一个路径或路径片段的序列，<strong>从右往左</strong>处理成一个<strong>绝对路径</strong></p></li><li><p>如果处理完给定的路径片段还未生成一个绝对路径，则<strong>当前工作目录</strong>会被用上</p></li><li><p>语法</p></li></ul><pre><code>path.resolve(path1,path2,path3....); // 从右往左将三个路径拼接成一个绝对路径</code></pre><ul><li>基本使用</li></ul><pre><code>// 在使用path模块前，需要先使用require()方法将其导入const path = require(&quot;path&quot;);const url = path.resolve(&quot;foo&quot;, &quot;bar&quot;);console.log(url);</code></pre><blockquote><p><strong>代码解析</strong></p></blockquote><ul><li><code>index.js</code>文件所在目录<code>D:\web\gitwork\Engineering\practice\Node&gt;</code></li><li>如果我在目录<code>D:\web\gitwork\Engineering\practice\Node&gt;</code>下执行<code>node index.js</code>，在控制台打印的结果是：<code>D:\web\gitwork\Engineering\practice\Node\foo\bar</code></li><li>如果我在目录<code>D:\web\gitwork\Engineering\practice&gt;</code>下执行<code>node .\Node\index.js</code>，在控制台打印的结果：<code>D:\web\gitwork\Engineering\practice\foo\bar</code></li></ul><blockquote><p>经过两次打印的结果我们可以得出，当我们的路径片段未能生成一个绝对路径时，<code>path.resolve()</code>方法<strong>自动帮我们补全的</strong>绝对路径是在当前路径前加上<strong>工作目录</strong>，而非文件所在目录。</p><p>如果我们希望<strong>不管在哪个目录下</strong>执行对应的 JS 文件，最后都能得到当前 <code>JS</code> 文件所在的绝对路径，那要如何处理呢 ？这就需要用到 <code>Node.js</code> 中的全局变量<code>__dirname</code></p><blockquote><p>path 模块的更多方法<a href="https://www.nodeapp.cn/path.html">可参考文档</a></p></blockquote></blockquote><ol start="3"><li>全局变量<code>__dirname</code><blockquote><p><code>__dirname</code>为<code>Node.js</code>的一个全局变量，表示<strong>当前文件的路径</strong></p></blockquote></li></ol><ul><li>我们通常把这个变量与<code>path.resolve()</code>方法结合使用，用来指定当前文件所在的绝对路径。</li></ul><blockquote><p><strong>语法：</strong></p></blockquote><pre><code>const path = require(&quot;path&quot;);const url = path.resolve(__dirname, &quot;&quot;);console.log(url);</code></pre><blockquote><p><strong>以上代码解析</strong></p></blockquote><ul><li><p><code>index.js</code>文件所在目录<code>D:\web\gitwork\Engineering\practice\Node&gt;</code></p></li><li><p>如果我目录<code>D:\web\gitwork\Engineering\practice\Node&gt;</code>下执行<code>node index.js</code>，在控制台打印的结果是：<code>D:\web\gitwork\Engineering\practice\Node&gt;</code></p></li><li><p>如果我在目录<code>D:\web\gitwork\Engineering\practice&gt;</code>下执行<code>node .\demo\index.js</code>，在控制台打印的结果还是： <code>D:\web\gitwork\Engineering\practice\Node&gt;</code></p></li><li><p>可见：不管在什么目录下执行<code>index.js</code>文件，最后<code>url</code>得到的路径都是<strong>当前文件所在的绝对路径</strong></p></li><li><p>解决最开始的文件路径错误的问题</p></li></ul><pre><code>const fs = require(&quot;fs&quot;);const path = require(&quot;path&quot;);// 同步读取hello.txt文件中内容const txt = fs.readFileSync(path.resolve(__dirname, &quot;./hello.txt&quot;), &quot;utf8&quot;);console.log(txt);// 异步读取hello.txt文件中内容const txt2 = fs.readFile(  path.resolve(__dirname, &quot;./hello.txt&quot;),  &quot;utf8&quot;,  (err, data) =&gt; &#123;    if (err) &#123;      throw new Error(&quot;文件读取失败&quot;);    &#125; else &#123;      console.log(data);    &#125;  &#125;);</code></pre><h3 id="三、npm"><a href="#三、npm" class="headerlink" title="三、npm"></a>三、npm</h3><h4 id="什么是-npm"><a href="#什么是-npm" class="headerlink" title="什么是 npm"></a>什么是 npm</h4><blockquote><p>NPM 的全称是<code>Node Package Manager</code>，是一个 Node.js 的包管理工具。</p></blockquote><blockquote><p><strong>那什么是包呢 ？</strong><br>在我们开发 Node 项目的时候，需要用到很多第三方的模块（和开发者自定义的模块，而是由其它人或团队开发出来，免费供所有人使用的一些模块），这些第三方的模块也称为包。</p></blockquote><pre><code>// axios就是一个第三方模块（包），我们在使用前，需要先通过npm来下载对应的包，否则就会报错。const axios = require(&quot;axios&quot;);</code></pre><p><strong>为什么需要包呢 ？</strong></p><blockquote><p>通过 JS 的学习，我们知道一门语言本身，他提供的只是一个底层的 API，而我们在使用这些底层的 API 开发项目时，效率很低，所以在实际的业务开发中，经常需要在底层 API 的基础上做一层封装。</p><p>比如我们前面讲到的<code>XMLHttpRequest</code>对象，利用他来发送 Ajax 请求时，每次都要书写大量重复的代码，所以就有人针对这个对象做了相关的封装，封装了 Axios 这个包。那后面我们发送 Ajax 请求，就可以直接使用第三方的模块 Axios 来实现，极大的提高了开发的效率。</p></blockquote><p><strong>需要的包从哪里下载呢 ？</strong></p><blockquote><p>国外有一家叫<code>npm,Inc.</code>的公司，这家公司旗下有一个非常著名的<strong>网站</strong>：<code>&quot;https://www.npmjs.com/&quot;</code>，是全球最大的包共享平台，你可以在这个平台上搜索你想要的任何包，了解这些包的功能和使用方法。</p><p>同时<code>npm,Inc.</code>的公司还提供了一个地址为<code>https://registry.npmjs.org</code>的<strong>服务器</strong>，来对外共享所有的包，我们可以通过这个服务器来下载自己想要的包</p></blockquote><p><strong>那如何下载需要的包呢</strong></p><blockquote><p><code>npm,Inc.</code>提供了一个包管理工具，也就是我们前面提到的npm，我们可以通过这个工具，就可以从<code>https://registry.npmjs.org</code>服务器上，把需要包下载到本地来使用。</p><p>当我们安装 <code>Node</code> 时，<code>npm</code> 这个工具也被一起安装到了我们的电脑上面。检测是否安装成功，在命令终端执行以下命令</p></blockquote><pre><code>//检测 node 是否安装及版本，正常显示版本号说明已经安装相应的版本node -v//检测 npm 是否安装及版本，正常显示版本号说明已经安装相应的版本npm -v</code></pre><h4 id="npm-的作用"><a href="#npm-的作用" class="headerlink" title="npm 的作用"></a>npm 的作用</h4><blockquote><p>我们知道 npm 是<code>Node.js</code>的包管理工具，那他具体能帮我们做什么呢 ？他可以帮我们做以下事情</p></blockquote><ul><li>帮我们从<code>https://registry.npmjs.org</code>服务器上下载需要的包</li><li>在我们开发项目时，帮我们管理下载好的包</li><li>把我们开发的项目（包）上传到服务器<code>https://registry.npmjs.org</code>上供别人免费使用</li></ul><blockquote><p>那在我们开发一个项目时，npm 是如何帮助我们做好下载和管理我们的包呢 ？我们从新创建一个项目开始说起。</p></blockquote><ul><li>至于如何把我们开发的包上传到 npm 服务器上，后面作为单独的模块来讲解</li></ul><h4 id="npm-的初体验"><a href="#npm-的初体验" class="headerlink" title="npm 的初体验"></a>npm 的初体验</h4><blockquote><p>在我们创建一个新项目时，我们首先会在当前项目的根目录创建一个<code>package.json</code>文件，这个文件用来描述项目及项目所依赖的模块信息。即 帮我们管理项目中的依赖包的，让我们远离了依赖地狱。比如：</p><ul><li>当前项目的名称、版本号、描述等（我们自己开发的项目，也是一个包，也可以供别人使用，npm 也需要帮我们管理）</li><li>项目中都用到了哪些包</li><li>哪些包是在开发期间会用到的</li><li>哪些包是在开发和生产（项目上线）都会用到<br>当然，我们不需要手动来创建<code>package.json</code>文件</li></ul></blockquote><ol><li>创建 <code>package.json</code> 文件<blockquote><p>我们只需要在当前项目录下，在<code>VsCode</code>终端执行<code>npm init</code>命令，然后按命令提示，输入对应的项目名称，之后就一直回车就行，直到命令结束，最后就会自动在当前目录创建好<code>package.json</code>文件。</p></blockquote></li></ol><pre><code>// 执行以下命令，会在当前项目中，创建一个package.json文件npm init// 如果想调过中间所有步骤，全部采用默认值，可以使用npm init -y</code></pre><ul><li>以下是生成好的<code>package.json</code>文件，关于这个文件配置项的说明，后面会讲到</li></ul><pre><code>&#123;  &quot;name&quot;: &quot;qinxin&quot;,  &quot;version&quot;: &quot;1.0.0&quot;,  &quot;description&quot;: &quot;&quot;,  &quot;main&quot;: &quot;index.js&quot;,  &quot;scripts&quot;: &#123;    &quot;test&quot;: &quot;echo \&quot;Error: no test specified\&quot; &amp;&amp; exit 1&quot;  &#125;,  &quot;author&quot;: &quot;&quot;,  &quot;license&quot;: &quot;ISC&quot;&#125;</code></pre><ol start="2"><li>npm 下载（安装）包<blockquote><ul><li>在当前目录的命令终端，执行以下命令可以下载需要的包</li></ul></blockquote></li></ol><pre><code>// 下载对应的包npm install 包名// 下载对应的包，i 是上面 install 的简写npm i  包名//如果需要下载指定版本的包，则在包后面带上对应的版本号 版本号格式 @x.x.xnpm i 包名@5.1.2// 如果需要一次性安装多个包，每个包之间用空格隔开npm i 包名  包名  包名</code></pre><blockquote><ul><li>在当前目录下，安装 axios 包</li></ul></blockquote><pre><code>//下载最新版本的axiosnpm install axios// 下载最新版本的axios，上面方法的简写npm i axios// 安装指定版本，版本号为 1.3.3npm i axios@1.3.3// 一次安装2个包npm i  jquery axios// 查看axios共有多少个版本npm view axios versions</code></pre><p><strong>注：</strong></p><ul><li>当我们下载好对应包后，在当前目录下多出了<code>node_modules</code>文件夹和<code>package-lock.json</code>文件，同时<code>package.json</code>中多出了一个<code>dependencies</code>属性</li></ul><p><strong>node_modules 文件夹</strong></p><ul><li>所有安装到项目中的包，都放在了这个文件夹中。<code>require()</code>导入第三方包时，就是从这个目录中查找并加载包。</li></ul><p><strong>package-lock.json 文件</strong></p><ul><li>它记录了<code>node_modules</code>目录下所有模块（包）的名称、版本号、下载地址、及这个模块又依赖了哪些依赖</li><li><code>package-lock.json</code>的作用：锁定安装时的包的版本号及包的依赖的版本号，以保证其他所有人在使用<code>npm install</code>时下载的依赖包都是一致的。锁定版本号，防止自动升级新版本。</li></ul><p><strong><code>package.json</code> 与 <code>package-lock.json</code>的区别</strong></p><ul><li>npm5 以前，没有 <code>package-lock.json</code> 这个文件。<code>package.json</code>只能锁定模块的大版本号（版本号的第一位），不能锁定后面的小版本，所以你每次重新<code>npm install</code>时候拉取的都是该大版本下面最新的版本。</li><li>一般我们为了项目的稳定性考虑我们不能随意升级依赖包，如果换包导致兼容性 <code>bug</code> 出现很难排查，这样很容易出现问题</li><li><code>npm5</code> 以后，新增了<code>package-lock.json</code>这个文件，它用来锁定所有模块的版本号，包括主模块和所有依赖子模块。</li><li>当你执行<code>npm install</code>的时候，<code>node</code>从<code>package.json</code>文件读取模块名称，从<code>package-lock.json</code>文件中获取版本号，然后进行下载或者更新。</li></ul><ol start="3"><li>指定包的依赖<blockquote><p>在开发项目时，我们会用到很多包，有些包只需要在开发环境中使用，项目上线后就不再需要了，而有些包在开发和项目上线后都需要用到。</p></blockquote></li></ol><ul><li>所以我们把包分为：开发依赖包和生产（核心）依赖包</li></ul><table><thead><tr><th>包分类</th><th>描述</th></tr></thead><tbody><tr><td>开发依赖包</td><td>只在项目开发期间会用到，比如后面学到的 <code>webpack</code> 打包工具，他只是用来对项目做打包构建的，项目打包构建好后，上线部署肯定就用不到<code>webpack</code>包了。所以<code>webpack</code>为开发依赖包</td></tr><tr><td>生产（核心）依赖包</td><td>在项目开发和上线都需要用到，比如前面说的<code>axios</code>包，他在项目中是用来发送请求的，不管是上线还是开发阶段都需要用到。如果上线把这个包去掉了，项目就会出错。所以<code>axios</code>就是生产（核心）依赖包。</td></tr></tbody></table><blockquote><p>在<code>package.json</code>中，有如下两个属性，用来记录包的类型</p></blockquote><table><thead><tr><th>属性</th><th>作用</th></tr></thead><tbody><tr><td>dependencies</td><td>记录生产（核心）依赖包，项目在打包上线时，会把对应的包打包进去</td></tr><tr><td>devDependencies</td><td>记录开发依赖包，项目打包上线时，不会把对应的包打包进去</td></tr></tbody></table><blockquote><p><strong>注：</strong></p></blockquote><ul><li><p>在安装包时，如果不指定包的依赖环境，<strong>默认指定为生产依赖包</strong>。如果想要在安装包时，指定包的依赖环境，可用以下命令</p></li><li><p>将包指定为开发依赖</p></li></ul><pre><code>npm i 包名 --save-dev   # 将安装的包指定为开发依赖包npm i 包名 -D  # -D相当于是--save-dev的缩写，将安装的包指定为开发依赖包// 以下写法也可以npm i --save-dev 包名npm i -D 包名// 安装webpack webpack-cli 为开发依赖npm i webpack webpack-cli -D</code></pre><ul><li>安装成功后，就会在<code>package.json</code>文件的<code>devDependencies</code>属性中添加如下两个属性</li></ul><pre><code>&quot;devDependencies&quot;: &#123;    &quot;webpack&quot;: &quot;^5.76.1&quot;,    &quot;webpack-cli&quot;: &quot;^5.0.1&quot;  &#125;,</code></pre><ul><li>将包指定为生产依赖</li></ul><pre><code>npm i 包  # 不指定依赖环境，默认安装到生产环境npm i 包 --save  #将安装的包指定为生产依赖// 以下写法也可以npm i --save 包&gt;// 安装axios包到生产环境npm i axios;// 或npm i axios --save</code></pre><ul><li>安装成功后，就会在package.json文件的dependencies属性中添加如下属性</li></ul><pre><code>&quot;dependencies&quot;: &#123;    &quot;axios&quot;: &quot;^1.3.4&quot;&#125;</code></pre><p><strong>温馨提示</strong></p><ul><li>我们在安装对应的包时，可以参考包的说明，包的说明中会给出包安装的命令，通过命令可以知道当前包是需要安装在生产还是开发环境。</li></ul><ol start="4"><li>npm 删除(卸载)包<blockquote><p>在当前目录命令终端，执行以下命令可以删除下载好的包</p></blockquote></li></ol><pre><code>npm uninstall 包  # 删除本地包，不考虑版本，不考虑依赖环境// 删除axios包npm uninstall axios</code></pre><p><strong>注：</strong></p><ul><li>包删除成功后，对应<code>package.json</code>和<code>package-lock.json</code>文件中包相关的信息全部都会被移除。</li></ul><ol start="5"><li>package.json 文件配置说明<blockquote><p>以下是关于<code>package.json</code>文件的相关配置项说明</p></blockquote></li></ol><pre><code>&#123;  // 项目名称，不能以&quot;.&quot;和&quot;_&quot;开头，不能包含大写字母，因为当软件包在npm上发布时，会基于此属性获取自己的URL，同时名称作为参数被传入require(&quot;&quot;)，用来导入模块，所以尽量简短、语义化  &quot;name&quot;: &quot;hermia&quot;,  // 该项目的版本号，它是一个字符串。每次项目改动后，即将发布时，都要同步的去更改项目的版本号。版本号的格式为： 主版本号.次版本号.修订号   =&gt; 5.1.0  // 通常情况下，修改主版号是做了大的功能的改动  // 修改次版本号是新增了新功能，  // 修改修订号就是修复了一些bug  // 查看包的版本信息  npm view  包名  version =&gt;查看最新版本  // npm view 包名 versions  =&gt;查看所有版本  &quot;version&quot;: &quot;1.0.0&quot;,  // 项目的描述，可以让其它开发者在npm的搜索中发现我们的项目包，搜索对应包时对应的描述  &quot;description&quot;: &quot;&quot;,  // 用来指定加载的入口文件，在浏览器和Node环境中都可以使用。如果我们将项目发布为npm包，那么当使用require导入npm包时，返回的就是main字段列出的文件的module.exports属性。如果不指定该字段，默认是项目根目录下的index.js，如果没找到，就会报错。  &quot;main&quot;: &quot;index.js&quot;,  // 脚本配置  scripts是package.json中内置的脚本入口，是key-value键值对配置。  // 可以通过npm run 来执行的命令。  npm run dev  // 还可以通过与 pre 和 post 完成前置和后续操作  &quot;scripts&quot;: &#123;    &quot;test&quot;: &quot;echo \&quot;Error: no test specified\&quot; &amp;&amp; exit 1&quot;  &#125;,  // 项目作者 它的值是你在https://npmjs.org网站的有效账户名  &quot;author&quot;: &quot;&quot;,  // 指定软件的开源协议，开源协议表述了其他人获得代码后拥有的权利，可以对代码进行何种操作，何种操作又是被禁止的  &quot;license&quot;: &quot;ISC&quot;,  // devDependencies 开发阶段需要的依赖包  &quot;devDependencies&quot;: &#123;    &quot;webpack&quot;: &quot;^5.76.1&quot;,    &quot;webpack-cli&quot;: &quot;^5.0.1&quot;  &#125;,  // dependencies 表示项目的生产和开发环境中都需要依赖的包  &quot;dependencies&quot;: &#123;    &quot;axios&quot;: &quot;^1.3.4&quot;  &#125;&#125;</code></pre><blockquote><p>注意：”scripts”脚本</p></blockquote><ul><li>脚本配置<code>scripts</code>是<code>package.json</code>中内置的脚本入口，是<code>key-value</code>键值对配置。</li><li>可以通过<code>npm run 键名</code> 来执行键值里面的命令。如：<code>npm run dev</code></li></ul><ol start="6"><li><code>package.json</code> 文件作用<blockquote><p>通过前面的学习，我们知道<code>package.json</code>文件用来描述项目及项目所依赖的模块信息。即 帮我们管理项目中的依赖包的，让我们远离了依赖地狱。</p><p>如果我们想把自己开发的项目分享给别人，<strong>不需要</strong>把 <code>node_modules</code> 这个文件分享过去，这个文件夹中的文件体积庞大，下载和上传都是极为不方便，而且会特别慢。</p></blockquote></li></ol><ul><li>我们只需要<strong>把其它的文件发送给对方</strong>，对方拿到文件后，只需要在当前项目的根目录下，执行以下命令</li></ul><pre><code>npm i  //自动根据package.json中的信息来下载项目所需要的所有依赖包。</code></pre><ul><li>就会自动根据<code>package.json</code>和<code>package-lock.json</code>文件中的信息来下载项目所需要的所有依赖包</li></ul><h4 id="解决-npm-下包速度慢问题"><a href="#解决-npm-下包速度慢问题" class="headerlink" title="解决 npm 下包速度慢问题"></a>解决 npm 下包速度慢问题</h4><blockquote><p>当我们使用 npm 下载包的时候，默认是从国外的<code>https://registry.npmjs.org</code>服务器进行下载，所以下载的速度会很慢。</p><ul><li>那国内是如何解决下载速度慢的问题，这就要提到<strong>淘宝</strong>的 <code>npm</code> 镜像服务器 和 <code>nrm</code>。</li></ul></blockquote><ol><li>淘宝的 NPM 镜像服务器<blockquote><p>镜像（Mirroring）：是一种文件存储形式，一个磁盘上的数据在另一个磁盘上存在一个完全相同的副本即为镜像。</p><p>淘宝在国内搭建了一个 <code>https://registry.npmmirror.com/</code>服务器（也就是 NPM 镜像服务器），专门用来把国外<code>https://registry.npmjs.org</code> 服务器上的包同步到国内的服务器。</p></blockquote></li></ol><ul><li>这样国内需要对应的包，就可以直接在国内的服务器上来下载了，极大的提高了下包的速度。<img src="淘宝镜像npm.png"></li></ul><p><strong>提示：</strong></p><blockquote><p>淘宝官方通知：<code>https://npm.taobao.org</code> 和 <code>https://registry.npm.taobao.org</code> 将在 2022 年 6 月 30 日正式下线和停止 DNS 解析。域名切换规则：</p><ul><li><code>https://npm.taobao.org</code> &#x3D;&gt; <code>https://npmmirror.com</code></li><li><code>https://registry.npm.taobao.org</code> &#x3D;&gt; <code>https://registry.npmmirror.com</code></li></ul></blockquote><ul><li>查看当前正在使用的 npm 镜像源</li></ul><pre><code>npm config get registry</code></pre><ul><li>切换 npm 镜像源</li></ul><pre><code>npm config  set registry  https://registry.npmmirror.com</code></pre><ul><li>镜像源地址只需设置一次即可</li><li><code>npm</code> 的镜像源切换为<code>https://registry.npmmirror.com</code>后，我们使用 <code>npm</code> 命令来下载包，就相当于是直接国内的这个服务器上来下载包，速度会很快速。</li></ul><ol start="2"><li>nrm 源管理器<blockquote><p>npm 有很多镜像源服务器,而<code>nrm</code>（npm registry manager）是 npm 的<strong>镜像源管理工具</strong>，允许你快速地在 npm 源间切换。</p></blockquote></li></ol><ul><li>全局安装 nrm</li></ul><pre><code>//通过npm，将nrm安装为全局可用的工具，即不管在任何目录下，都可以使用nrm命令npm i nrm -g</code></pre><ul><li>安装好 nrm 后，查看所有可用的镜像源</li></ul><pre><code>//查看所有可用的镜像源nrm ls  </code></pre><ul><li>将当前源切换为对应的 taobao 源</li></ul><pre><code>nrm use taobao</code></pre><ul><li>我们可以通过以下命令来查看我们的源是否切换成功</li></ul><pre><code>npm config get registry</code></pre><h3 id="四、开发自己-npm-包"><a href="#四、开发自己-npm-包" class="headerlink" title="四、开发自己 npm 包"></a>四、开发自己 npm 包</h3><blockquote><p>接下来我们尝试开发一个简单的包，然后上传到 npm 平台上去。让大家了解 npm 在整个过程中的应用。</p></blockquote><ul><li>一个完整的包，至少有以下三个文件</li></ul><table><thead><tr><th>文件名</th><th>作用</th></tr></thead><tbody><tr><td>package.json</td><td>用来描述项目和管理项目所依赖的模块信息</td></tr><tr><td>index.js</td><td>用来指定加载的入口文件，如果我们将项目发布为 npm 包，那么当使用 require 导入 npm 包时，返回的就是<code>package.json</code>文件中 main 字段列出的文件的<code>module.exports</code>属性。如果不指定该字段，默认是项目根目录下的<code>index.js</code>，如果没找到，就会报错。</td></tr><tr><td>README.md</td><td>包的说明文档，描述包的作用和包的使用教程</td></tr></tbody></table><blockquote><p>接下来我们就按以下步骤来开发自己的</p></blockquote><ul><li>创建项目文件夹，用来存放项目用到的所有文件</li><li>初始化项目需要的 package.json 文件</li><li>创建index.js文件，包的入口文件</li><li>撰写 README.md 说明文档</li></ul><ol><li><p>创建项目文件夹</p><blockquote><p>在创建项目文件夹前，先要想好自己包（项目）的名字，同时在 npm 官网<code>https://www.npmjs.com/</code>上查询有没有对应的包名。</p><ul><li>如果没有这个包名就能用，如果有，那就要更换，因为<strong>不能出现同名的包</strong>。<br>在本地新建一个<code>hermia</code>文件夹（项目名），所以项目需要用到的文件都保存在当前目录中</li></ul></blockquote></li><li><p>初始化 <code>package.json</code> 文件</p><blockquote><p>当项目<code>hermia</code>文件夹下，利用 <code>npm init -y</code> 命令初始化<code>package.json</code>文件</p><ul><li>得到如下 <code>package.json</code> 文件</li></ul></blockquote></li></ol><pre><code>&#123;  &quot;name&quot;: &quot;icoding-max&quot;,  &quot;version&quot;: &quot;1.0.0&quot;,  &quot;description&quot;: &quot;&quot;,  &quot;main&quot;: &quot;index.js&quot;,  &quot;scripts&quot;: &#123;    &quot;test&quot;: &quot;echo \&quot;Error: no test specified\&quot; &amp;&amp; exit 1&quot;  &#125;,  &quot;keywords&quot;: [],  &quot;author&quot;: &quot;&quot;,  &quot;license&quot;: &quot;ISC&quot;&#125;</code></pre><ul><li>完善 <code>package.json</code> 文件中的描述、关键字、作者</li></ul><ol start="3"><li>创建 index.js 文件<blockquote><p>在当前目录下创建<code>index.js</code>文件，作为项目的加载入口文件。在文件中编写<code>max</code>和<code>min</code>两个函数，这两个函数用来实现两个数中的最大值和最小值，并将其作为模块接口导出。</p><ul><li>具体代码如下</li></ul></blockquote></li></ol><pre><code>// 求两个值中的最大值function max(a, b) &#123;  return a &gt; b ? a : b;&#125;// 求两个值中的最小值function min(a, b) &#123;  return a &gt; b ? b : a;&#125;// 将两个方法作为模块对外输出的接口module.exports = &#123;  max,  min,&#125;;</code></pre><ol start="4"><li><p>撰写 README.md 说明文档</p><blockquote><p><code>README.md</code> 包的使用说明文档，以 <code>markdown</code> 的格式来书写，方便阅读。<code>READEM.md</code> 文件中具体写什么内容，没有强制要求，开发者尽可能清晰的把包的功能，安装、用法，注意事项等描述清楚即可。</p><ul><li>以下是我为本包做的一个简单的说明文档<img src="README.png"></li></ul></blockquote></li><li><p>上传包到 npm 平台</p><blockquote><p>要将自己开发的包上传到 npm 平台，经历以下几步：</p></blockquote></li></ol><ul><li>在 npm 平台，注册 npm 账号<ul><li>访问 <code>https://www.npmjs.com/</code>网站，点击右上角的sign up按扭，进入用户注册界面。</li><li>填写账号相关的信息</li></ul></li><li>登录 npm 账号<ul><li>npm 账号注册完成后，在<strong>命令终端</strong>切换到当前项目的根目录，并执行<code>npm login</code>命令，开始登录，根据提示，分别输入 用户名、密码，一次性密码等操作，最后就会登录成功。<blockquote><p><strong>温馨提示</strong></p></blockquote></li></ul></li><li>在运行 <code>npm login</code> 命令前，必须要先把 <code>npm</code> 的镜像切换为 <code>npm</code> 官方的服务器<code>https://registry.npmjs.org</code>，否则登录不进去。</li><li>如果不清楚是否成功，可以执行<code>npm profile get</code>命令，查看账户简介</li></ul><pre><code>// icoding-max为项目文件夹PS C:\Users\EDY\Desktop\demo\icoding-max&gt; npm loginPS C:\Users\EDY\Desktop\demo\icoding-max&gt; npm profile get </code></pre><ul><li>发布包到 npm 上<ul><li>在当前项目的根目录下，执行<code>npm publish</code>命令，即可将包发布到 npm 上。</li></ul></li></ul><pre><code>// icoding-max为项目文件夹C:\Users\EDY\Desktop\demo\icoding-max&gt; npm publish// 如果希望发布的包对外不公开，则可以使用下面命令npm publish --access public</code></pre><blockquote><p>发布成功后</p><ul><li>在 npm 官网<code>https://www.npmjs.com/</code>右上角，点击我的头像，选择<code>Packages</code>菜单进入，就可以看到自己发布的包</li></ul></blockquote><ul><li>删除发布的包<blockquote><p>在终端登录 npm 账号后，可以运行以下命令，将对应的包从 npm 平台上删除</p></blockquote></li></ul><pre><code>npm unpublish 包名 --force # 从npm平台上删除自己发布的对应包// 删除刚才发布的包，-f 是 --force 的简写npm unpublish icoding-max -f</code></pre><p><strong>温馨提示：</strong></p><ul><li><code>npm unpublish</code>命令只能删除 <code>72</code> 小时以内发布的包</li><li><code>npm unpublish</code>删除的包，在 <code>24</code> 小时内不允许重复发布</li><li>所以在发布包时，要再三检查，有没有错误。</li></ul><h3 id="五、npm-常用命令和使用技巧"><a href="#五、npm-常用命令和使用技巧" class="headerlink" title="五、npm 常用命令和使用技巧"></a>五、npm 常用命令和使用技巧</h3><ul><li>检测是否安装及版本</li></ul><pre><code>npm -v # 显示版本号说明已经安装相应的版本</code></pre><ul><li>生成 package.json 文件<ul><li><code>package.json</code>用来描述项目中用到的模块和其他信息</li></ul></li></ul><pre><code>npm init # 初始化生成package.json</code></pre><ul><li>安装模块</li></ul><pre><code>npm install # 安装package.json定义好的模块，简写 npm i// 安装包指定模块npm i &lt;ModuleName&gt;// 全局安装npm i &lt;ModuleName&gt; -g// 安装包的同时，将信息写入到package.json中的 dependencies 配置中npm i &lt;ModuleName&gt; --save/P// 安装包的同时，将信息写入到package.json中的 devDependencies 配置中npm i &lt;ModuleName&gt; --save-dev/D// 安装多模块npm i &lt;ModuleName1&gt; &lt;ModuleName2&gt;// 安装方式参数：-save # 简写-S，加入到生产依赖中-save-dev # 简写-D，加入到开发依赖中-g # 全局安装 将安装包放在 /usr/local 下或者你 node 的安装目录</code></pre><ul><li>查看命令</li></ul><pre><code>// 查看所有全局安装的包npm ls -g// 查看本地项目中安装的包npm ls// 查看包的 package.json文件npm view &lt;ModuleName&gt;// 查看包的依赖关系npm view &lt;ModuleName&gt; dependencies// 查看包的源文件地址npm view &lt;ModuleName&gt; repository.url// 查看包所依赖的node版本npm view &lt;ModuleName&gt; engines// 查看帮助npm help</code></pre><ul><li>更新模块</li></ul><pre><code>// 更新本地模块npm update &lt;ModuleName&gt;// 更新全局模块npm update -g &lt;ModuleName&gt; # 更新全局软件包。npm update -g # 更新所有的全局软件包。npm outdated -g --depth=0 # 找出需要更新的包。</code></pre><ul><li>卸载模块</li></ul><pre><code>// 卸载本地模块npm uninstall &lt;ModuleName&gt;// 卸载全局模块npm uninstall -g &lt;ModuleName&gt; # 卸载全局软件包。</code></pre><ul><li>清空缓存</li></ul><pre><code>// 清空npm缓存npm cache clear</code></pre><p>使用淘宝镜像源</p><ul><li><p>npm 默认的镜像源下载速度很慢，通常切换国内淘宝镜像源，下载速度更快</p></li><li><p>查看当前正在使用的 npm 镜像源</p></li></ul><pre><code>npm config get registry</code></pre><ul><li>临时使用 npm 镜像源（仅使用一次淘宝镜像源地址）</li></ul><pre><code>npm --registry https://registry.npmmirror.com install &lt;ModuleName&gt;</code></pre><ul><li>切换 npm 镜像源</li></ul><pre><code>npm config set registry https://registry.npmmirror.com</code></pre><ul><li>其他</li></ul><pre><code>// 更改包内容后进行重建npm rebuild &lt;ModuleName&gt;// 检查包是否已经过时，此命令会列出所有已经过时的包，可以及时进行包的更新npm outdated// 访问npm的json文件，此命令将会打开一个网页npm help json// 发布一个包的时候，需要检验某个包名是否存在npm search &lt;ModuleName&gt;// 撤销自己发布过的某个版本代码npm unpublish &lt;package&gt; &lt;version&gt;</code></pre><p>npm 使用技巧</p><ul><li>多次安装不成功尝试先清除缓存</li></ul><pre><code>npm cache clean -f</code></pre><ul><li>查看已安装的依赖包版本号</li></ul><pre><code>npm ls &lt;ModuleName&gt;</code></pre><blockquote><p>注意：</p><ul><li>用此方法才能准确的知道项目使用的版本号，查看 <code>package.json</code> 时，有“^” 符号表示大于此版本</li></ul></blockquote><p>nrm 的作用与使用</p><blockquote><ul><li>nrm（npm registry manager）是 npm 的镜像源管理工具</li><li>有时候国外资源太慢，使用这个就可以快速地在 npm 源间切换</li></ul></blockquote><ul><li>nrm 的安装</li></ul><pre><code>npm install -g nrm</code></pre><ul><li>nrm 命令</li></ul><pre><code>nrm ls　#查看可用的源（有*号的表示当前所使用的源,以下&lt;registry&gt;表示源的名称）nrm use &lt;registry&gt; # 将npm下载源切换成指定的源nrm add &lt;registry&gt; &lt;url&gt; # 添加源，url为源的路径nrm del &lt;registry&gt; # 删除源nrm test &lt;registry&gt; # 测试源的响应时间，可以作为使用哪个源的参考nrm help　# 查看nrm帮助nrm home &lt;registry&gt;　# 跳转到指定源的官网</code></pre><ul><li>nrm 使用<blockquote><p>如果在你的网络不太理想或者受到其他网络限制导致不能使用 npm 原本的源进行下载时，nrm 就非常有用了，你只需要：</p></blockquote></li></ul><pre><code>nrm ls # 查看可用的源nrm use &lt;registry&gt;　# 切换到指定源</code></pre><h3 id="六、Babel-简介与基本使用"><a href="#六、Babel-简介与基本使用" class="headerlink" title="六、Babel 简介与基本使用"></a>六、Babel 简介与基本使用</h3><blockquote><p>深入浅出 Babel 是什么，Babel 的使用方式，使用 Babel 编译 ES6 代码前后的结果 等</p></blockquote><h4 id="什么是-Babel"><a href="#什么是-Babel" class="headerlink" title="什么是 Babel"></a>什么是 Babel</h4><blockquote><p>Babel 是一个<code>JavaScript</code>编译器，用来将 ES6 的代码转换成 ES6 之前（ES5 或 ES3）的代码</p><p>说的直白一点，Babel 就是将新版本的代码（ES6）转换成浏览器可以兼容的 ES5 或 ES3 版本的代码，这样我们就可以放心大胆的使用 ES6 ，而不担心兼容性问题了</p><p>关于 ES6 之后的代，其兼容性问题就交给<code>Babel</code>来处理了，<code>Babel</code>可以说是ES6的好兄弟 ！</p></blockquote><ul><li><a href="https://babeljs.io/">Babel 的官网</a></li><li><a href="https://www.babeljs.cn/">Babel 中文网站（非官方）</a></li><li><a href="https://babeljs.io/repl">Babel 的在线编译网址</a></li></ul><h4 id="使用-Babel-在线编译器转码"><a href="#使用-Babel-在线编译器转码" class="headerlink" title="使用 Babel 在线编译器转码"></a>使用 Babel 在线编译器转码</h4><blockquote><p>接下来我们编写了一段简单的 ES6 代码，然后利用 Babel 的在线编译工具来编译，具体如下</p><ul><li>注意编译器左边的勾选项<img src="bable设置.png"></li></ul></blockquote><ol><li>编译前后代码对比解析</li></ol><ul><li>编译前 ES6 代码如下</li></ul><pre><code>let username = &quot;icoding&quot;;const sex = &quot;male&quot;;const add = (x, y) =&gt; x + y;new Promise((resolve, reject) =&gt; &#123;  resolve(&quot;成功 ！&quot;);&#125;).then((value) =&gt; &#123;  console.log(value);&#125;);const obj = Object.assign(&#123; a: 1 &#125;, &#123; b: 4 &#125;);console.log(obj);</code></pre><ul><li>利用 Babel 在线编译后的代码如下</li></ul><pre><code>var username = &quot;icoding&quot;;var sex = &quot;male&quot;;var add = function add(x, y) &#123;  return x + y;&#125;;new Promise(function (resolve, reject) &#123;  resolve(&quot;成功 ！&quot;);&#125;).then(function (value) &#123;  console.log(value);&#125;);var obj = Object.assign(&#123; a: 1 &#125;, &#123; b: 4 &#125;);console.log(obj);</code></pre><p><strong>编译解析：</strong></p><ul><li>Babel 转码后，let 和 const 转换成了 var，箭头函数转换成了普通函数。</li><li>但<code>Promise</code>、<code>Object.assign()</code>编译后，<strong>并没有做任何的修改，还是原样输出了</strong></li></ul><p><strong>原因是：</strong></p><ul><li>Babel 只能编译 ES6 的<strong>大部分语法</strong>（如：let、const、class、()&#x3D;&gt;箭头函数这些类似新增的语法），<strong>但对于 ES6 新增的 API</strong>（如：<code>Set、Map、Promise、Array.from()、Object.assign()</code>）本身默认是没有办法通过 Babel 编译来转换成 ES5 之前的语法的。<blockquote><ul><li>因为语法的转换很简单，直接替换就完事。但像 Promise 等这些新增的全局对象，并没有办法直接替换，除非再实现一份，否则是无法转换的。</li><li>所以要解决 ES6 新增的 API，我们只能人为的去实现这些 API 方法，说的直白一点就是在当前代码中通过 ES5 版本的 JS 来手动实现<code>Promise、Set、Map</code>等方法。当然这些方法不需要我们自己去写，官方帮我们实现了，我们只需要引入第三方对应的 JS 模块就可以了</li></ul></blockquote></li></ul><ol start="2"><li>引入 polyfill<blockquote><p>能过前面的学习，我们知道 Babel 只能编译 ES6 的大部分语法，对 ES6 新的 API 本身是没有办法转的。所以我们需要通过引入<strong>第三方模块</strong>来解决代码（目标环境-浏览器）中缺失的 API。</p><p><code>polyfill</code>翻译为中文为”垫片”，所谓的”垫片“,是指<strong>垫平不同浏览器之间差异的东西</strong>。比如我们上面提到的，在低版本浏览器中不支持 ES6 的大部分语法，所以<code>polyfill</code>提供了 ES6 中新增的所有 API。通过在我们的项目中引入<code>polyfill</code>就可以补全浏览器缺失的 API。</p></blockquote></li></ol><ul><li>在<code>bootcdn</code>网站上，搜索<code>babel</code>官方提供的<code>polyfill</code>，搜索名字为<code>babel-polyfill</code>，具体如下</li><li>代码经过 Babel 转码后，我们再在项目中，手动引入<code>polyfill.min.js</code>文件，如下</li></ul><pre><code>&lt;script src=&quot;https://cdn.bootcdn.net/ajax/libs/babel-polyfill/7.12.1/polyfill.min.js&quot;&gt;&lt;/script&gt;&lt;script&gt;  var username = &quot;icoding&quot;;  var sex = &quot;male&quot;;  var add = function add(x, y) &#123;    return x + y;  &#125;;  new Promise(function (resolve, reject) &#123;    resolve(&quot;成功 ！&quot;);  &#125;).then(function (value) &#123;    console.log(value);  &#125;);  var obj = Object.assign(&#123; a: 1 &#125;, &#123; b: 4 &#125;);  console.log(obj);&lt;/script&gt;</code></pre><p><strong>注：</strong></p><ul><li>为了测试效果，可以安装低版本的浏览器来测试，以下是<code>firefox</code>浏览器所有版本的下载地址</li><li>下载是<code>firefox32</code>版来测试，在<code>firefox32.0</code>版中，是不支持<code>Object.assign()</code>方法的，这个方法从<code>firefox34.0</code>版开始支持。</li><li>以上代码在没有引入<code>polyfill</code>前，在<code>firefox32 </code>中没有会抛出错误<code>TypeError: Object.assign is not a function</code>,引入后，则正常输出结果。</li></ul><p><strong>在实际的项目开发中</strong></p><ul><li>我们肯定不会手动的在编译好的代码中来引入<code>polyfill</code>，因为这种方式会把当前代码中没有用到的 ES6API 全都加载进来了，这样项目的<strong>体积就太大了</strong>。我们希望能实现按需加载（也就是只加载当前项目中用到的 ES6 API）<blockquote><ul><li>后面我们会结合<code>Webpack</code>来实现<strong>按需引入</strong></li></ul></blockquote></li></ul><h4 id="Babel-的安装与使用"><a href="#Babel-的安装与使用" class="headerlink" title="Babel 的安装与使用"></a>Babel 的安装与使用</h4><blockquote><p>上面使用 Babel 的在线编译是为了让大家能快速的了解 Babel，在实际开发中，我们肯定不会利用在线编译来转码，而是通过安装 Babel 来实现转码。</p><p>Babel 有哪些使用方式，在官网中即可查看 <code>https://babeljs.io/setup</code></p><p>习惯性通过官网查看学习，毕竟最新的使用方式也会实时更新和升级（避免现在学习了，未来又会有新的变化）</p></blockquote><ul><li><p>这里我们先来学习使用Babel的<code>CLI</code>命令行工具来实现转码，具体如下</p><img src="babel安装与使用.png"></li><li><p>Babel 的使用方式非常多,我们常见的会使用 CLI 命令行工具 或 在 Webpack 中使用。</p></li><li><p>当我们点击任意使用方式，即可跳转至 对应的使用步骤，按步骤操作即可</p></li></ul><ol><li>Babel 的安装</li></ol><ul><li>首先新建项目目录文件夹，所有<code>Babel</code>都是安装在当前项目下</li><li>则在项目目录下执行<code>npm init -y</code> 初始化项目（生成<code>package.json</code>文件）</li><li>执行下面命令，安装<code>Babel</code>相关的两个包，安装成<strong>开发依赖</strong></li></ul><pre><code>// 我们可以通过运行以下命令在本地安装 Babel CLI// 注：以下命令会默认安装最新版本的 babel// @babel/core Babel 的所有核心功能都在这里// @babel/cli 是Babel命令行转码工具，如果我们想在通过命令进行Babel转码，就需要安装它，如:在终端通过命令 npx babel...或 npm run bulid  来实现转码npm install --save-dev @babel/core @babel/cli</code></pre><p><strong>在实际开发中</strong></p><ul><li>不会每次都使用最新版本，毕竟是第三方的包，我们无法控制。如果官方升级，有可能语法也会变化，就会导致项目报错而无法运行，这也是非常常见的情况。</li></ul><blockquote><p>安装成功后，会在<code>package.json</code>文件中的<code>devDependencies</code>属性中，添加如下两个字段</p></blockquote><pre><code> &quot;devDependencies&quot;: &#123;      // 提供了 CLI 命令，用来执行 babel 相关命令    &quot;@babel/cli&quot;: &quot;^7.21.0&quot;,      // babel 的核心包，用来发号施令调度用的，不做具体的事情，具体怎么做交给其他包来完成    &quot;@babel/core&quot;: &quot;^7.21.3&quot;  &#125;</code></pre><ul><li>可以在安装前，执行<code>npm view @babel/core versions</code>来查其所有版本</li><li>Babel 相关的包安装好之后，接下来创建项目目录和需要转码的 JS 代码，然后利用 Babel 命令来转码。</li></ul><ol start="2"><li>创建目录和对应的 ES6 代码</li></ol><ul><li>转码前，在当前目录下新建<code>src</code>目录，然后在<code>src</code>目录下新建<code>main.js</code>文件</li><li>把需要转码的代码放在<code>main.js</code>文件中</li><li>代码如下</li></ul><pre><code>let username = &quot;icoding&quot;;const sex = &quot;male&quot;;const add = (x, y) =&gt; x + y;new Promise((resolve, reject) =&gt; &#123;  resolve(&quot;成功 ！&quot;);&#125;).then((value) =&gt; &#123;  console.log(value);&#125;);const obj = Object.assign(&#123; a: 1 &#125;, &#123; b: 4 &#125;);console.log(obj);</code></pre><ol start="3"><li>在<code>package.json</code>文件中添加执行的<code>babel</code>命令</li></ol><ul><li>接下来，在<code>package.json</code>文件的<code>scripts</code>属性中，新增<code>&quot;build&quot;: &quot;babel src -d dist&quot;</code></li></ul><pre><code>&quot;scripts&quot;: &#123;    &quot;test&quot;: &quot;echo \&quot;Error: no test specified\&quot; &amp;&amp; exit 1&quot;,    &quot;build&quot;: &quot;babel src -d dist&quot;  &#125;</code></pre><p><strong>scripts 属性解析</strong></p><ul><li><code>scripts</code>属性用于存放通过<code>npm run</code>命令来执行的命令</li><li>通过在命令行中输入<code>npm run build</code> 就相当于是执行后面的<code>babel src -d dist</code>，那你可能会想，那我直接把<code>babel src -d dist</code>命令在终端执行，为什么会报错呢？这个问题，我们放在后面来给大家讲。</li><li>test用于测试使用，可以删除，也可以保留。</li></ul><p><strong>“build”: “babel src -d dist” 命令解读</strong></p><ul><li>build：构建创建的意思，这个名字可以自己取，主要用于 <code>npm run build</code>时来执行后面的<code>babel src -d dist</code>命令</li><li>babel：表示编译执行的是<code>babel</code>命令</li><li>src：表示将 src 目录下的所有 JS 文件进行编译（用于存放需要编译的 ES6 文件），也可以指定单独的某个 JS 文，如：<code>babel src/main.js -d dist</code></li><li>-d：表示输出，-d 是<code>--out-dir</code>的缩写，表示输出目录的意思</li><li>dist：表示编译后的文件输出到<code>dist</code>目录下，这个文件夹的名字可以自定义</li></ul><blockquote><p>当我们执行上面的命令后，在当前目录下生成了 <code>dist</code> 目录，同时在目录中有<code>main.js</code>文件</p></blockquote><ul><li>打开<code>main.js</code>文件，就会发现以上编译后的代码，只是将格式调整了下，又原文输出了 ！本质上没有发生任何变化。</li></ul><p><strong>转码失败原因</strong></p><ul><li>原因是，<strong>缺少了 Babel 的配置文件</strong>，我们要能实现 ES6 编译成兼容 ES5 或 ES3 的代码，需要在 Babel 的配置文件中配置相关信息（指定编译规则），告诉 Babel 把 ES6 编译成兼容 ES5 还是 ES3 的代码。</li><li>如果我们不指定具体将 ES6 的代码编译成兼容 ES5 的，还是 ES3 等，那 Babel 也不知道要如何转，所以他就会原样输出我们的代码。</li></ul><ol start="4"><li>创建 Babel 配置文件 <code>babel.config.json</code></li></ol><ul><li>Babel 的配置文件是执行 Babel 时默认在当前目录下搜寻的文件，主要有<code>.babelrc、.babelrc.js、babel.config.json、package.json</code>。它们的配置项都是相同的，作用也是一样的的，只需要选择其中一种即可。</li><li>接下来我们在根目录中创建一个<code>babel.config.json</code>配置文件并启用一些<strong>预设</strong>。我们可以使用<code>env</code>预设，该预设为 <code>ES2015+</code>启用转换（<strong>本质：</strong>如何将所有 ES6 转换成 ES5，具体转换规则的方法都在这个包里）。<blockquote><p>具体配置如下：</p></blockquote></li></ul><pre><code>&#123;  &quot;presets&quot;: [&quot;@babel/preset-env&quot;]&#125;</code></pre><p><strong>关于预设的理解</strong></p><blockquote><p>预设可以理解为<strong>一组插件的集合</strong>，我们想要把 ES6 代码转换成 ES5 或 ES3 的代码，需要用到的插件非常多，而预设相当于是把这些需要用到的插件放到了一个包里，我们只需要安装这个包，然后利用这个包里的插件来帮我们实现对应的转码工作。</p></blockquote><blockquote><p>在<code>Babel 6</code>时期，有年代预设，比如</p></blockquote><ul><li>babel-preset-es2015 ES2015 标准中的语法转换器预设</li><li>babel-preset-es2016 ES2016 标准中的语法转换器预设</li><li>babel-preset-es2017 ES2017 标准中的语法转换器预设</li><li>…….</li></ul><blockquote><p>但现在没有年代预设了，而是把所有预设打包到一起为<code>@balel/preset-env</code>中，至后新增的语法需要转换，对应的插件也会更新到这个包中，所以我们现在只需要配置这一个预设就可以。</p></blockquote><ul><li>配置后，我们还需要安装<code>@babel/preset-env</code>包，执行以下命令即可</li></ul><pre><code>// @babel/preset-env 包只是告诉babel我们如何把ES6转成ES5，转码后，项目上线并不需要这个包，所以安装成开发依赖npm install @babel/preset-env --save-dev</code></pre><ul><li>安装完成后，可在<code>package.json</code>文件中查看<code>@babel/preset-env</code>的配置依赖信息，如下</li></ul><pre><code> &quot;devDependencies&quot;: &#123;     // 提供了 CLI 命令，用来执行 babel 相关命令    &quot;@babel/cli&quot;: &quot;^7.21.0&quot;,     // babel 的核心包，用来发号施令调度用的，不做具体的事情，具体怎么做交给其他包来完成    &quot;@babel/core&quot;: &quot;^7.21.3&quot;,     // 这个包提供了ES6转ES5的语法转换规则，用来告诉 babel 具体该如何将ES6转ES5    &quot;@babel/preset-env&quot;: &quot;^7.20.2&quot;  &#125;</code></pre><p><strong>注：</strong></p><blockquote><p>你可能会想，明明每次 Babel 转码都需要安装三个包，为什么还要把他们拆分，然后分别安装呢 ？</p></blockquote><ul><li>其实这就是模块化开发思想，这样模块化拆分，每一个包的分工都会非常的明确，需要什么就用什么（避免用不到的都统统引入项目，造成资源的浪费）</li></ul><ol start="5"><li>再次执行编译命令<blockquote><p>以上配置好后，我们接下来再次执行以下命令来编译</p></blockquote></li></ol><pre><code>npm run build</code></pre><ul><li>这一次终于成功了，恭喜你，你已经学会了如何使用 Babel 来实现转码。不过上面 ES6 新增的 API 目前还是实现不了，只能通过手动引入Polyfill来补全。</li><li>等我们后面学到Webpack时，我们就可以通过Webpack来实现按需引入空缺的 API。</li></ul><h4 id="总结：Babel-转码流程"><a href="#总结：Babel-转码流程" class="headerlink" title="总结：Babel 转码流程"></a>总结：Babel 转码流程</h4><blockquote><p>我们利用 Babel 来转码，需要经过以下 7 个步骤</p></blockquote><ul><li>①、创建项目的根目录，如 icoding 新建文件夹</li><li>②、在根目录，利用<code>npm init -y</code>来初始化项目，会自动创建<code>package.json</code>文件</li><li>③、在根目录创建<code>src</code>文件夹， 把需要转码的<code>JS</code>文件(<code>main.js</code>)放在<code>src</code>文件夹下（目录名可以自定义）</li><li>④、执行以下命令，一次安装 Babel 需要的包，安装成开发依赖</li></ul><pre><code>npm install --save-dev @babel/core @babel/cli @babel/preset-env</code></pre><ul><li>⑤、在根目录下创建<code>babel.config.json</code>配置文件，配置以下信息</li></ul><pre><code>&#123;  &quot;presets&quot;: [&quot;@babel/preset-env&quot;]&#125;</code></pre><ul><li>⑥、在<code>package.json</code>中添加执行 <code>babel</code> 的命令，这样我们就可以通过<code>npm run build</code>命令来执行 <code>babel</code> 命令完成转码</li></ul><pre><code>&quot;scripts&quot;: &#123;    &quot;build&quot;: &quot;babel src -d dist&quot;  &#125;</code></pre><ul><li>⑦、最后在当前目录终端执行以下命令，完成转码</li></ul><pre><code>npm run build</code></pre><p><strong>注：</strong></p><blockquote><p>不过 Babel 只能编译 ES6 的大部分语法，但对于 ES6 新增的 API 是没有办法转的。我们只能通过引入 polyfill 来补全缺失的 API，这样我们的项目就可以在不同版本的浏览器上运行，而不用担心兼容性问题。</p><p>不过手动引入 polyfill 会造成我们的 JS 文件过大，因为我们可能只用了部分的 ES6 新特性，但我们把所有缺失的新特性都添加进来了。</p><ul><li>这个问题，我们后面学了 Webpack 再来解决。</li></ul></blockquote><h3 id="七、其它扩展"><a href="#七、其它扩展" class="headerlink" title="七、其它扩展"></a>七、其它扩展</h3><h4 id="npm-run-build-背后到底做了什么-？"><a href="#npm-run-build-背后到底做了什么-？" class="headerlink" title="npm run build 背后到底做了什么 ？"></a><code>npm run build</code> 背后到底做了什么 ？</h4><blockquote><p>在<code>package.json</code>中通过配置以下信息，就可以通过<code>npm run build</code>命令来执行 babel 了。</p></blockquote><pre><code>&quot;scripts&quot;: &#123;    &quot;build&quot;: &quot;babel src -d dist&quot;  &#125;</code></pre><p>我们说<code>npm run build</code>就相当于是执行了<code>babel src -d dist</code>，那为什么我们直接在命令终端输出<code>babel src -d dist</code>命令<strong>会报错</strong>呢 ？</p><p><strong>原因在于</strong></p><blockquote><p>当我们执行<code>npm run build</code>时, 他会默认找到<code>node_modules/.bin/</code>下的 <code>babel</code>，也就是<code>node_modules/.bin/babel</code> ,打开这个文件，文件内容如下</p></blockquote><pre><code>#!/bin/shbasedir=$(dirname &quot;$(echo &quot;$0&quot; | sed -e &#39;s,\\,/,g&#39;)&quot;)case `uname` in    *CYGWIN*|*MINGW*|*MSYS*) basedir=`cygpath -w &quot;$basedir&quot;`;;esacif [ -x &quot;$basedir/node&quot; ]; then  exec &quot;$basedir/node&quot;  &quot;$basedir/../@babel/cli/bin/babel.js&quot; &quot;$@&quot;else  exec node  &quot;$basedir/../@babel/cli/bin/babel.js&quot; &quot;$@&quot;fi</code></pre><p>上面的 babel 文件中，相当于执行了以下命令</p><pre><code>  node  C:/Users/EDY/Desktop/test/icoding/node_modules/@babel/cli/bin/babel.js  src -d dist// 我们在命令行执行上面命令，也可以实现同样的转码效果// 在当前目录下，上面命令可以简写成如下 node .\node_modules\@babel\cli\bin\babel.js src -d dist</code></pre><p><strong>总结：</strong></p><ul><li>我们把命令配置在<code>package.json</code>中，这样在每次执行相同命令时，就可以达到减化输入的命令。</li></ul><h4 id="npx-命令"><a href="#npx-命令" class="headerlink" title="npx 命令"></a><code>npx</code> 命令</h4><blockquote><p><code>npx</code>是新版的<code>Node.js</code>里附带的命令，我们也可能通过在当前目录的命令终端执行以下代码，来实现转码。</p></blockquote><ul><li>安装npx</li></ul><pre><code>npm i -g npx</code></pre><ul><li><code>npx</code>的功能和<code>npm</code>类似，他在运行时，也会默认找到<code>node_modules/.bin/</code>下面<code>babel</code>来执行</li></ul><pre><code>npx babel src -d dist</code></pre><ul><li>这里我们来补充一种写法</li></ul><pre><code>//将当前目录下的src目录中的main.js文件转码后，在当前目录下生成转码成功后bundle.js文件npx babel .\src\main.js -o bundle.js&gt;#-o 右侧是编译后js的存放位置，不过不会自动创建文件，需要手动把文件夹新建好npx babel .\src\main.js -o .\dist\bundle.js</code></pre>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 工程化 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>vue3全家桶+Ts+vant 前后端分离购物商城项目介绍</title>
      <link href="/2023/12/24/vue3%E5%85%A8%E5%AE%B6%E6%A1%B6-Ts-vant-%E5%89%8D%E5%90%8E%E7%AB%AF%E5%88%86%E7%A6%BB%E8%B4%AD%E7%89%A9%E5%95%86%E5%9F%8E%E9%A1%B9%E7%9B%AE/"/>
      <url>/2023/12/24/vue3%E5%85%A8%E5%AE%B6%E6%A1%B6-Ts-vant-%E5%89%8D%E5%90%8E%E7%AB%AF%E5%88%86%E7%A6%BB%E8%B4%AD%E7%89%A9%E5%95%86%E5%9F%8E%E9%A1%B9%E7%9B%AE/</url>
      
        <content type="html"><![CDATA[<span id="more"></span><h2 id="项目介绍"><a href="#项目介绍" class="headerlink" title="项目介绍"></a>项目介绍</h2><p>欢迎访问：<a href="https://web.hermiablog.com/">https://web.hermiablog.com/</a></p><blockquote><p>登录与注册</p></blockquote><ul><li>可使用以下手机号和验证码访问<ul><li>手机号：17369245121；验证码：123456</li><li>手机号：17369245122；验证码：123456</li></ul></li><li>也可以用自己的手机号注册</li></ul><blockquote><p>更多</p></blockquote><ul><li>github地址：<a href="https://github.com/hermiablog/shopApp">https://github.com/hermiablog/shopApp</a> (包括前后端数据)</li><li>欢迎光临我的博客：<a href="https://hermiablog.com/">https://hermiablog.com/</a></li></ul><blockquote><p>手机扫码访问</p></blockquote><img src="vueShop.png" style="width: 300px;"><img src="myblog.png" style="width: 300px;"><h4 id="项目技术栈"><a href="#项目技术栈" class="headerlink" title="项目技术栈"></a>项目技术栈</h4><p>本次 Vue 项目用到的技术栈、构建工具、组件库、代码检查、代码格式化工具。如下表：</p><table><thead><tr><th>工具</th><th>描述</th><th>版本</th></tr></thead><tbody><tr><td>Node</td><td>JS 运行时环境</td><td>20.9.0</td></tr><tr><td>Vue</td><td>渐进式 JS 框架</td><td>3.3.10</td></tr><tr><td>TypeScript</td><td>具有类型语法的 JS</td><td>5.2.0</td></tr><tr><td>Vite</td><td>前端构建工具</td><td>5.0.5</td></tr><tr><td>Vue Router</td><td>Vue.js 的官方路由</td><td>4.2.5</td></tr><tr><td>Pinia</td><td>Vue.js 状态管理库</td><td>2.1.7</td></tr><tr><td>Vant</td><td>移动端 Vue 组件库</td><td>4.8.0</td></tr><tr><td>VueUse</td><td>基于 Vue 组合式 API 的实用函数集合</td><td>10.7.0</td></tr><tr><td>ESLint</td><td>代码检查工具，统一代码规范</td><td>8.49.0</td></tr><tr><td>Prettier</td><td>代码格式化工具</td><td>3.0.3</td></tr><tr><td>json-server</td><td>模拟服务端接口数据</td><td>0.17.4</td></tr><tr><td>jsonwebtoken</td><td>生成 和 校验 token</td><td>9.0.2</td></tr><tr><td>axios</td><td>异步请求</td><td>1.6.2</td></tr><tr><td>postcss</td><td>利用 JavaScript 的强大编程能力对 CSS 代码进行转换</td><td>8.4.32</td></tr><tr><td>sass</td><td>CSS 预处理器</td><td>1.69.5</td></tr></tbody></table><h4 id="项目页面"><a href="#项目页面" class="headerlink" title="项目页面"></a>项目页面</h4><p>本项目所涉及到的页面有：首页、购物车、订单、我的、商家店铺、商品详情、订单支付、登录、注册、地址管理、编辑地址、搜索页<br><img src="introduce.png" style="max-width: 100%;"></p><h4 id="项目功能"><a href="#项目功能" class="headerlink" title="项目功能"></a>项目功能</h4><p>本项目中涉及到的一些功能主要用：</p><ul><li>搜索功能</li><li>轮播图</li><li>弹出层和弹窗</li><li>倒计时</li><li>滚动菜单</li><li>滚动加载</li><li>下拉刷新</li><li>图片懒加载</li><li>单选与全选</li><li>加入购物车</li><li>地址管理（选择、新增、修改、删除、默认设置）</li><li>短信验证码登录与注册</li><li>token 身份认证</li></ul><h4 id="项目技术点"><a href="#项目技术点" class="headerlink" title="项目技术点"></a>项目技术点</h4><p>本项目所涉及到的技术栈和相关知识点，如下</p><blockquote><p>Vue3 框架</p></blockquote><ul><li>基础知识应用</li><li>ref 和 reactive</li><li>computed 和 watch</li><li>组件封装</li><li>自定义指令 directive</li><li>composition API</li><li>生命周期</li><li>VueUse 基本用法</li><li>ESLint 和 Prettier 基础配置</li></ul><blockquote><p>Vue Route4</p></blockquote><ul><li>基础用法</li><li>动态路由匹配</li><li>导航守卫</li></ul><blockquote><p>Pinia 状态管理</p></blockquote><ul><li>基础用法</li><li>state</li><li>getter</li><li>action</li><li>数据本地持久化(localstorage)</li></ul><blockquote><p>构建工具 Vite</p></blockquote><ul><li>Vite 构建项目</li><li>配置 eslint、prettier</li><li>设置请求代理</li></ul><blockquote><p>TypeScript</p></blockquote><ul><li>基础用法</li><li>函数</li><li>接口 interface</li><li>类 Class</li><li>泛型</li></ul><blockquote><p>Axios</p></blockquote><ul><li>创建 axios 实例</li><li>get、post、put、deleted 请求</li><li>axios 封装</li><li>请求和响应拦截器</li></ul><blockquote><p>Vant 组件</p></blockquote><ul><li>Icon 图标</li><li>Popup 弹出层</li><li>Checkbox 复选框</li><li>Form 表单</li><li>Search 搜索</li><li>PullRefresh 下拉刷新</li><li>Lazyload 懒加载</li><li>List 列表</li><li>Sticky 粘性布局</li><li>Swipe 轮播</li><li>IndexBar 索引栏</li><li>NavBar 导航栏</li><li>Tab 标签页</li><li>Tabbar 标签栏</li><li>Area 省市区选择</li><li>Dialog 弹出框</li><li>CountDown 倒计时</li></ul><blockquote><p>服务器端</p></blockquote><ul><li>json-server 模拟服务端接口数据</li><li>Http 状态码与业务状态码</li><li>jsonwebtoken 生成和校验 token</li><li>申请短信验证码接口</li><li>json-server 模拟服务端接口数据</li></ul><h2 id="项目搭建过程"><a href="#项目搭建过程" class="headerlink" title="项目搭建过程"></a>项目搭建过程</h2><h3 id="一、基础框架、准备工作"><a href="#一、基础框架、准备工作" class="headerlink" title="一、基础框架、准备工作"></a>一、基础框架、准备工作</h3><h4 id="开发环境初始化"><a href="#开发环境初始化" class="headerlink" title="开发环境初始化"></a>开发环境初始化</h4><blockquote><p>创建Vue项目，集成相关工具：TS、Vue Router、Pinia、ESLint、Prettier、Vant、VueUse等</p></blockquote><ul><li>执行以下代码，并开启相关功能</li></ul><pre><code>npm create vue@latest</code></pre><blockquote><p>安装Vant组件</p></blockquote><pre><code># Vue 3 项目，安装最新版 Vantnpm i vant</code></pre><ul><li>按需引入</li></ul><pre><code># 通过 npm 安装npm i @vant/auto-import-resolver unplugin-vue-components -D</code></pre><ul><li>配置插件:修改<code>vite.config.ts</code>配置文件</li></ul><pre><code>import vue from &#39;@vitejs/plugin-vue&#39;;import Components from &#39;unplugin-vue-components/vite&#39;;import &#123; VantResolver &#125; from &#39;@vant/auto-import-resolver&#39;;export default &#123;  plugins: [    vue(),    Components(&#123;      resolvers: [VantResolver()],    &#125;),  ],&#125;;</code></pre><blockquote><p>安装VueUse</p></blockquote><pre><code>npm i @vueuse/core</code></pre><h4 id="页面结构与路由"><a href="#页面结构与路由" class="headerlink" title="页面结构与路由"></a>页面结构与路由</h4><blockquote><p>页面结构梳理</p></blockquote><table><thead><tr><th>页面</th><th>路由</th><th>路由组件</th></tr></thead><tbody><tr><td>首页</td><td>&#x2F;</td><td><code>/src/views/home/Index.vue</code></td></tr><tr><td>购物车</td><td>&#x2F;cart</td><td><code>/src/views/cart/CartIndex.vue</code></td></tr><tr><td>订单</td><td>&#x2F;order</td><td><code>/src/views/order/OrderIndex.vue</code></td></tr><tr><td>我的</td><td>&#x2F;my</td><td><code>/src/views/my/MyIndex.vue</code></td></tr><tr><td>登录</td><td>&#x2F;login</td><td><code>/src/views/login/LoginIndex.vue</code></td></tr><tr><td>注册</td><td>&#x2F;register</td><td><code>/src/views/register/RegisterIndex.vue</code></td></tr><tr><td>商家店铺</td><td>&#x2F;shop&#x2F;:shopId</td><td><code>/src/views/shop/ShopIndex.vue</code></td></tr><tr><td>商品详情</td><td>&#x2F;goods-details&#x2F;:shopId&#x2F;:goodsId</td><td><code>/src/views/goods/GoodsIndex.vue</code></td></tr><tr><td>订单支付</td><td>&#x2F;order&#x2F;confirmation&#x2F;:shopId</td><td><code>/src/views/order/OrderComfirmation.vue</code></td></tr><tr><td>地址管理</td><td>&#x2F;address</td><td><code>/src/views/address/AddressIndex.vue</code></td></tr><tr><td>新增或修改地址</td><td>&#x2F;address&#x2F;edit</td><td><code>/src/views/address/AddressEdit.vue</code></td></tr></tbody></table><blockquote><p>路由配置</p></blockquote><ul><li>修改<code>router/index.ts</code>文件，配置路由</li></ul><h4 id="CSS样式处理"><a href="#CSS样式处理" class="headerlink" title="CSS样式处理"></a>CSS样式处理</h4><blockquote><p>安装<code>normalize.css</code>，用来处理不同浏览器的兼容</p><ul><li>注意：它并不是很全面</li></ul></blockquote><pre><code>npm i normalize.css</code></pre><ul><li>在<code>main.ts</code>中引入</li></ul><pre><code>import &quot;normailize.css&quot;</code></pre><blockquote><p>安装sass</p></blockquote><ul><li>安装sass css预处理器</li></ul><pre><code>npm install sass -D</code></pre><blockquote><p>添加字体抗锯齿效果</p></blockquote><ul><li>在<code>App.vue</code>中添加以下样式</li></ul><pre><code>#app &#123;  -webkit-font-smoothing: antialiased;  -moz-osx-font-smothing: grayscale; &#125;</code></pre><blockquote><p>公共样式文件<br>在<code>/src/assets</code>目录下新建<code>common.scss</code>文件，用于存放整个项目的公共样式</p></blockquote><ul><li>重置</li><li>设置通用样式</li><li>溢出文本省略等公共样式</li><li>设置苹方字体<ul><li>使用<code>@font-face</code>声明所需字体，format表示如果用户代理不支持指定的格式，就跳过下载字体资源</li><li>在<code>font-family</code>中引用该字体</li></ul></li></ul><h4 id="移动端适配与浏览器兼容性处理"><a href="#移动端适配与浏览器兼容性处理" class="headerlink" title="移动端适配与浏览器兼容性处理"></a>移动端适配与浏览器兼容性处理</h4><blockquote><p>vw布局——自动转换单位</p></blockquote><p>使用<code>postcss-px-to-viewport-8-plugin</code>插件进行转换</p><ul><li>安装</li></ul><pre><code>npm install postcss-px-to-viewport-8-plugin -D</code></pre><ul><li>配置：在根目录下新建<code>postcss.config.js</code>文件</li></ul><pre><code>module.exports = &#123;  plugins: &#123;    &#39;postcss-px-to-viewport-8-plugin&#39;: &#123;      viewportWidth: 375,//设计稿的视口宽度      exclude: [/node_modules/],      unitToConvert: &#39;px&#39;,      minPixelValue: 1, //设置最小的转换数值      selectorBlackList: [/^body$/], //需要忽略的 CSS 选择器    &#125;  &#125;&#125;</code></pre><blockquote><p>CSS兼容性处理</p></blockquote><ul><li>安装autoprefixer插件——自动为css属性添加不同的浏览器前缀</li></ul><pre><code>npm i autoprefixer -D</code></pre><ul><li>在<code>postcss.config.js</code>文件中配置该插件</li></ul><pre><code>module.exports = &#123;  plugins: &#123;    &#39;autoprefixer&#39;:&#123;&#125;  &#125;&#125;</code></pre><ul><li>在<code>package.json</code>中添加兼容到的浏览器版本</li></ul><pre><code>&#123;  &quot;browserslist&quot;:[    &quot;Andriod&gt;=4.0&quot;,    &quot;iOS&gt;=7&quot;  ]&#125;</code></pre><blockquote><p>JS兼容性处理</p></blockquote><ul><li>安装<code>@vitejs/plugin-legacy</code>插件，为打包后的JS文件提供浏览器兼容性支持</li></ul><pre><code>npm i @vitejs/plugin-legacy -D</code></pre><ul><li>必须同时安装 Terser，因为旧版插件使用 Terser 进行缩小</li></ul><pre><code>npm add -D terser</code></pre><ul><li>在<code>vite.config.js</code>文件中配置该插件</li></ul><pre><code>// vite.config.jsimport legacy from &#39;@vitejs/plugin-legacy&#39;export default &#123;  plugins: [    legacy(&#123;      //target放到package.json中    &#125;),  ],&#125;</code></pre><ul><li>为了和css保持一样的兼容性版本，把兼容到的目标浏览器配置<code>targets</code>，添加到<code>package.json</code>的<code>browserslist</code>字段中</li></ul><pre><code>&#123;  &quot;browserslist&quot;:[    &quot;Andriod&gt;=4.0&quot;,    &quot;iOS&gt;=7&quot;  ]&#125;</code></pre><h4 id="API接口调用设计"><a href="#API接口调用设计" class="headerlink" title="API接口调用设计"></a>API接口调用设计</h4><p>创建Axios实例</p><blockquote><p>我们需要通过axios发送大量HTTP请求，因此创建Axios实例将其中相同的配置放在一起</p></blockquote><ul><li>安装axios</li></ul><pre><code>npm install axios</code></pre><ul><li>新建<code>/src/api/base.ts</code>文件，来创建实例</li></ul><pre><code>import axios from &#39;axios&#39;const instance = axios.create(&#123;  baseURL: &#39;/api&#39;,  timeout: 3000,&#125;);export default instance</code></pre><ul><li>配置代理——修改<code>vite.config.ts</code>文件</li></ul><pre><code>server:&#123;  proxy:&#123;    &#39;/api&#39;:&#39;http://127.0.0.1:8888&#39;  &#125;&#125;</code></pre><blockquote><p>使用示例</p></blockquote><ul><li>新建<code>/src/api/test.ts</code>文件，引入axios实例，将接口封装成方法暴露出去</li></ul><pre><code>//这里给axios实例取别名为axios import axios from &#39;@/api/base&#39;export function getFruits()&#123;  return axios.get(&#39;/getFruits&#39;)&#125;</code></pre><ul><li>使用时，只需要导入请求的方法，进行调用</li></ul><pre><code>import &#123; getFruits &#125; from &#39;@/api/test&#39;const list = ref([])const getFruitsList = async () =&gt; &#123;  try&#123;    list.value = await getFruits()  &#125; catch (err)&#123;    list.value = []  &#125;&#125;getFruitsList()</code></pre><blockquote><p><a href="https://www.axios-http.cn/docs/instance">Axios实例官方文档</a></p></blockquote><p>身份验证流程<br><img src="identityAuth.png" style="max-width: 100%;"></p><p>拦截器<br>拦截器分为请求拦截器和响应拦截器</p><ul><li>请求拦截器：在发送请求之前被调用</li><li>响应拦截器：在响应被then或catch处理前被调用</li></ul><blockquote><p>作用</p></blockquote><ul><li>在请求拦截器中给请求头添加<code>Authorization</code>字段携带认证的Token</li><li>在响应拦截器中根据响应数据的业务状态码来做相关的处理</li></ul><blockquote><p><a href="https://www.axios-http.cn/docs/interceptors">拦截器官方文档</a></p></blockquote><blockquote><p>请求拦截器</p></blockquote><pre><code>// 添加请求拦截器instance.interceptors.request.use(function (config) &#123;    // 在发送请求之前将token保存到localStorage    const token=window.localStorage.getItem(&#39;token&#39;)    // 如果有token    if(token)&#123;      config.headers[&quot;Authorization&quot;]=token      &#125;    return config;  &#125;, function (error) &#123;    // 对请求错误做些什么    return Promise.reject(error);  &#125;);</code></pre><blockquote><p>响应拦截器</p></blockquote><pre><code>// 添加响应拦截器instance.interceptors.response.use(async (response)=&gt; &#123;    // 2xx 范围内的状态码都会触发该函数。    // 身份认证成功，就走这里 返回相应的数据    const &#123;data:_data&#125;=response;    const &#123;data,code,msg&#125;=_data;    // 根据业务状态码来判断要做的事    if(code===-1)&#123;    await showDialog(&#123;        title:&quot;错误提示&quot;,        message:msg      &#125;)      return Promise.reject(msg);    &#125;    return data  &#125;, function (error) &#123;    // 超出 2xx 范围的状态码都会触发该函数。    // 如果身份认证失败，就弹出提示框并跳转到登录界面    if(error.response&amp;&amp;error.response.status===401)&#123;      showDialog(&#123;        title:&quot;请登录&quot;,        message:&quot;没有访问权限，请登录后再试&quot;      &#125;).then(()=&gt;&#123;        window.location.href=&quot;https//www.baidu.com&quot;      &#125;)    &#125;  &#125;);</code></pre><h3 id="二、登录注册与短信验证"><a href="#二、登录注册与短信验证" class="headerlink" title="二、登录注册与短信验证"></a>二、登录注册与短信验证</h3><h4 id="文件说明"><a href="#文件说明" class="headerlink" title="文件说明"></a>文件说明</h4><pre><code>shopApp├─ jsonServer│  ├─ .env│  ├─ src│  │  ├─ controller│  │  │  ├─ phoneIsExisted.controller.js   //检验电话号码是否已注册│  │  │  ├─ SmsCodeSend.controller.js    // 用于发送验证码│  │  │  ├─ SmsCodeCheck.controller.js   // 用于检验用户输入的验证码是否符合要求│  │  │  └─ userNameIsExisted.controller.js  //检验用户名是否已注册│  │  ├─ data│  │  │  ├─ smsCodeData.js  //包含手机号、验证码、过期时间的数据库 │  │  │  └─ userList.js  //包含用户手机号、用户名、密码等个人信息的数据库│  │  ├─ routes.js  //路由│  │  └─ service│  │     ├─ sendCodeService.js  // 使用阿里云短信服务 发送短信│  └─ utils│     └─ randomNum.js  //随机生成n位数字的方法└─ vue-shop   ├─ src   │  ├─ use   │  │  └─ UseSmsCode.ts   │  ├─ utils   │  │  └─ regular.ts   │  └─ views   │     └─ register   │        └─ RegisterIndex.vue</code></pre><h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><table><thead><tr><th></th><th>客户端</th><th>服务端</th></tr></thead><tbody><tr><td>验证手机号</td><td>正则校验，发起请求查询手机号是否已注册</td><td>根据手机号查询数据库</td></tr><tr><td>验证用户名</td><td>正则校验，发起请求查询用户名是否已注册</td><td>根据用户名查询数据库</td></tr><tr><td>发送验证码</td><td>发起请求、进行倒计时</td><td>拿到手机号发送短信验证码</td></tr><tr><td>验证验证码</td><td>正则校验，发起请求验证验证码是否正确</td><td>根据手机号、验证码查询数据库</td></tr><tr><td>注册</td><td>信息有效、勾选协议，发起请求进行注册</td><td>将用户信息添加进数据库，返回不带密码的用户信息数据</td></tr></tbody></table><h4 id="实现注册"><a href="#实现注册" class="headerlink" title="实现注册"></a>实现注册</h4><p>组件</p><ul><li>使用vantUI的Form表单组件，可以根据rule属性进行校验、使用异步函数发起后端请求</li></ul><p>验证手机号、用户名</p><blockquote><p>前端——校验规则配置——rule属性</p></blockquote><ul><li>required：是否为必选字段，当值为空值时校验不通过</li><li>pattern：使用正则校验输入框内容</li><li>validator：发起异步请求，调用接口</li></ul><blockquote><p>后端</p></blockquote><ul><li>新建数据库<code>smsCodeData</code></li><li>分别创建连个无需认证的接口，获取请求体中携带的数据，查询其是否在数据中已存在，并返回相应信息</li><li>手机号验证接口：<code>/api/register/phone/check</code></li><li>用户名验证接口：<code>/api/register/username/check</code></li></ul><p>获取验证码</p><blockquote><p>开通验证码的功能——阿里云平台短信服务功能</p></blockquote><ul><li>注册账号</li><li>完成实名认证</li><li>进入短信控制台</li><li>开通短信服务，申请签名、模板等</li><li>调用API发送短信(SDK版本v1.0、Node.js)</li><li>申请授权密钥<ul><li>AccessKey管理</li><li>开通子账户</li><li>获取密钥</li><li>添加短信权限</li></ul></li></ul><blockquote><p>前端点击获取验证码，开启倒计时，向接口发起请求</p></blockquote><blockquote><p>后端根据手机号，发送验证码</p></blockquote><ul><li>新建发送验证码的接口：<code>/api/register/code/send</code></li><li>新建发送验证码的通用方法，并在接口文件中调用；</li><li>接入阿里云平台短信服务功能<ul><li>将SDK示例代码复制到发送验证码的接口文件中</li><li>新建<code>.env</code>文件，保存密钥，导入<code>dotenv</code>包解析环境变量</li></ul></li><li>模拟验证码数据库，保存手机号、验证码、过期时间<ul><li>在发送验证码的接口中，生成验证码并发送验证码后，要检查数据库中；如果已经有该手机号，如果有就更新验证码和过期时间；如果没有就新增一条数据</li></ul></li></ul><p>验证验证码</p><blockquote><p>前端</p></blockquote><ul><li>在异步函数中调用接口</li></ul><blockquote><p>后端</p></blockquote><ul><li>新建验证接口：<code>/api/register/code/check</code></li><li>到数据库中查询，传入的手机号和验证码是否正确，该验证码是否未过期</li></ul><p>注册</p><blockquote><p>前端</p></blockquote><ul><li>输入用户信息及验证码，勾选协议</li><li>注册成功后，跳转到登录页<blockquote><p>后端</p></blockquote></li><li>新建接口：<code>/api/register</code></li><li>将用户信息添加到数据库中，并将密码以外的信息返回到前端</li></ul><h4 id="实现登录"><a href="#实现登录" class="headerlink" title="实现登录"></a>实现登录</h4><p>组件</p><ul><li>使用vantUI的Form表单组件，可以根据rule属性进行校验、使用异步函数发起后端请求</li></ul><p>验证手机号格式：</p><ul><li>前端校验：利用正则规范输入框内容的格式</li></ul><p>获取验证码：</p><ul><li>新建接口：<code>/api/login/code/send</code></li><li>实现方式和注册时一样</li></ul><p>验证验证码</p><ul><li>定义新的数据库，存储登录时的手机号与验证码</li><li>创建新的接口：<code>/api/login/code/check</code></li><li>实现方式和注册时一样</li></ul><p>登录</p><ul><li>新建接口：<code>/api/smsLogin</code></li><li>首先根据手机号，在数据库中查找是否已存在；如果没有注册过，就为该手机号创建默认账户</li><li>注册后&#x2F;已注册：返回无密码的账户信息和token</li></ul><p>用户信息和token的存储</p><ul><li>效果：使用pinia，作为全局变量存储，同时要保存在localStorage中</li><li>创建仓库，里面保存了<ul><li>用户信息：未登录时和登录后的信息</li><li>新增数据的方法：根据传入的result更新用户信息，并将用户信息和<code>token</code>保存在<code>localStorage</code>中</li><li>删除用户信息的方法：将用户信息恢复默认值、清空token</li></ul></li><li>当登陆成功后，创建仓库实例，使用新增数据的方法将result传入</li></ul><h3 id="三、我的页面"><a href="#三、我的页面" class="headerlink" title="三、我的页面"></a>三、我的页面</h3><p>顶部页面的渲染</p><ul><li>登录&#x2F;注册后，接口会返回用户信息</li><li>使用保存用户信息的仓库，拿到里面的信息进行渲染，使登录前和登录后状态实现变化</li><li>注意：用户头像在登录前后来源不一样；但图片的地址前缀都是本地服务器<ul><li>所以要对<code>/images</code>进行代理，使登录后的图片地址转到后端服务器；</li><li>而未登录时默认头像是在前端，所以不能放在<code>/images</code>文件夹里，创建<code>img</code>文件夹进行存放</li></ul></li></ul><h3 id="四、首页"><a href="#四、首页" class="headerlink" title="四、首页"></a>四、首页</h3><p>页面组成</p><pre><code>HomeIndex├─ 顶部导航├─ 定位 —— LocationView├─ 搜索 —— HomeSearch│  ├─ 搜索框│  └─ 搜索页 —— SearchPage│     ├─ 搜索框│     └─ 历史记录 —— HistoryView ├─ 轮播图 —— BannerView├─ 分类菜单 —— HomeMenu├─ 特价秒杀 —— PriceKillView└─ 分类推荐 —— HomeRecommand</code></pre><h4 id="搜索"><a href="#搜索" class="headerlink" title="搜索"></a>搜索</h4><p>在首页点击搜索框跳转到搜索页</p><ul><li>搜索组件<code>HomeSearch</code>同时存在搜索框和弹出层两部分，使用<code>showPop</code>变量控制显隐，默认是<code>false</code>，弹出层只在它为<code>true</code>时显示</li><li>当搜索框被点击后，<code>showPop===true</code>弹出层显示，弹出层由搜索页组件<code>SearchPage</code>渲染</li></ul><p>搜索页<code>SearchPage</code></p><ul><li>搜索框输入内容后，拿到关键词向后端发起请求，获取对应内容</li><li>关闭搜索页：<ul><li>点击关闭图标时，触发父组件传递的close事件</li><li>清空店铺数据</li><li>清空输入框的值</li></ul></li></ul><p>组件：历史记录<code>HistoryView</code></p><ul><li>该组件仅在没有商店数据时显示(即搜索出数据后，不显示历史记录)</li><li>接收父组件传递的历史记录<code>historyList</code></li><li>有历史记录时，默认显示最近八条记录，如果有的话，支持展开更多</li><li>点击删除图标可使用父组件传递的事件，清空<code>historyList</code></li><li>点击单条历史记录将该值传给父组件<code>SearchPage</code></li></ul><p>搜索接口 </p><ul><li>创建店铺信息的数据库</li><li>定义搜索接口，根据参数：keyword、page、limit返回相应数据；page、limit是可选参数，不传时使用默认值</li><li>在搜索时使用接口，传入参数，获取数据；接口名：<code>/api/search?keyword=0&amp;page=1&amp;limit=10</code></li><li>未登录时不能搜索，将搜索接口设置为受保护接口，响应拦截器会进行拦截，并跳转到登录页</li></ul><p>搜索框</p><ul><li>搜索框在输入关键词点击搜索后，<ul><li>将关键词添加到本地</li><li>给接口传入参数，搜索出对应内容</li></ul></li></ul><p>点击历史记录搜索</p><ul><li>接收子组件传来的值，修改搜索框的值</li><li>触发onSearch事件</li></ul><p>在搜索页渲染店铺</p><ul><li>使用for循环遍历店铺组件<code>shopItem</code></li><li>给组件传入搜索后得到的数据</li></ul><p>上拉加载更多 —— List 列表</p><table><thead><tr><th>属性&#x2F;事件</th><th>初始值</th><th>功能</th></tr></thead><tbody><tr><td>v-model:loading</td><td>false</td><td>false表示没有在加载数据；true正在更新数据</td></tr><tr><td>v-model:error</td><td>false</td><td>true表示数据加载失败，并显示错误提示，用户点击错误提示后会重新触发 load 事件</td></tr><tr><td>finished</td><td>false</td><td>true表示数据已全部加载完毕</td></tr><tr><td>offset</td><td>300</td><td>滚动条与底部距离小于 offset 时触发 load 事件</td></tr><tr><td>loading-text</td><td>加载中…</td><td>加载过程中的提示文案</td></tr><tr><td>@load事件</td><td>-</td><td>异步更新数据</td></tr></tbody></table><blockquote><p>原理</p></blockquote><ul><li>在loading为false的前提下，组件加载的瞬间&#x2F;组件滚动到底部时，会触发 load 事件，并将loading 设置成 true</li><li>因此1：在进入搜索页的瞬间会马上加载数据(但是都没搜索哪来的数据)</li><li>因此2：要使每次搜索时都加载数据，就得定义一个变量<code>searchState</code>控制店铺列表的显隐</li><li>因此3：每一次加载完(无论有无数据)都要使loading为false</li></ul><blockquote><p>使用</p></blockquote><ul><li>将List列表包裹在店铺组件外面</li><li>在List列表外再加一层控制其显隐</li></ul><blockquote><p>与搜索方法联调</p></blockquote><ul><li>将onSearch方法中用于获取数据的异步方法剪切到onLoad方法中</li><li>上拉加载更多：<ul><li>使每次获取数据的<code>page++</code>，直到数据长度大于<code>total</code>，就将<code>finished</code>设为<code>true</code>，表示数据已全部加载完毕</li><li>在每次搜索前将<code>page=0</code>，将<code>shopList</code>清空，将<code>finished</code>设为<code>false</code></li></ul></li><li>在<code>onSearch</code>方法中使用两个定时器控制店铺列表的显隐，在点击搜索的0毫秒将<code>searchState=false</code>隐藏，100毫秒时将<code>searchState=true</code>显示店铺，触发<code>onLoad</code>事件</li></ul><blockquote><p>注意事项</p></blockquote><ul><li>不能在点击搜索后清空输入框的值，这将导致<code>onLoad</code>事件拿不到搜索的内容</li><li>不能为了进入搜索页时不加载数据 而给<code>List</code>列表设置<code>immediate-check</code>属性，这将导致无法触发onload事件，使用变量控制显隐一举两得</li></ul><p>下拉刷新——List 组件与 PullRefresh 组件结合使用</p><ul><li><code>refreshing</code>默认值为false，true表示正在加载中，</li><li>下拉后就会触发<code>refresh</code>事件，并将<code>refreshing=true</code></li><li>在<code>refresh</code>事件中<ul><li>将数据更新为最新一条</li><li>将<code>loading</code>设为true，表示正在加载中，会有加载中的文字</li><li>将<code>finished = false，page.value = 0</code>表示开始新一轮搜索</li></ul></li></ul><h4 id="店铺组件shopItem"><a href="#店铺组件shopItem" class="headerlink" title="店铺组件shopItem"></a>店铺组件<code>shopItem</code></h4><p>数据的渲染</p><ul><li>根据父传入的数据渲染</li></ul><p>难点</p><ul><li>字体大小为10px，而浏览器最小字号为12px</li><li>解决办法：使用<code>scale</code>缩放到<code>0.85</code>倍 </li><li>产生的问题：会产生无法更改的外边距</li></ul><h4 id="轮播图"><a href="#轮播图" class="headerlink" title="轮播图"></a>轮播图</h4><p>接口</p><ul><li>增加数据库<code>banner.data.js</code></li><li>使用json-server默认接口，在<code>db.js</code>文件中，引入数据库并增加一个接口<code>/api/banner</code></li><li>注意默认接口是以根节点字段为路径的，不需要另外定义<br>前端</li><li>引入接口</li><li>创建<code>BannerView</code>文件，调用接口，渲染页面</li></ul><h4 id="分类菜单"><a href="#分类菜单" class="headerlink" title="分类菜单"></a>分类菜单</h4><p>接口</p><ul><li>增加数据库<code>menu.data.js</code></li><li>使用json-server默认接口，在<code>db.js</code>文件中，引入数据库并增加一个接口<code>/api/menu</code></li></ul><p>前端</p><ul><li>引入接口</li><li>创建<code>HomeMenu</code>文件，调用接口，获取数据</li><li>使用网格布局渲染</li></ul><h4 id="特价秒杀"><a href="#特价秒杀" class="headerlink" title="特价秒杀"></a>特价秒杀</h4><p>前端</p><blockquote><p>倒计时组件 —— CountDown</p></blockquote><ul><li>注意：要进行补0操作，使用<code>String.prototype.padStart()</code>方法</li><li>因为不显示天数，所以需要<code>时</code>的值需要再加上<code>天数*24</code></li><li>当倒计时为0时，会自动调用finish事件；定义一个变控制特价秒杀板块的显隐，在finish事件中改变变量的值将该板块下架</li></ul><blockquote><p>轮播图组件 —— Swipe 轮播</p></blockquote><ul><li>使用<code>RouterLink</code>包裹单个滑块，路由的参数根据每个商品的数据传入</li><li>难点：轮播图组件中单个滑块的宽度不能自适应，只能使用px单位<ul><li>单独写一个方法，将<code>px</code>转换成<code>vw</code> </li><li>在生命周期钩子函数中，使用<code>window.resize()</code>事件调用该方法；并在组件销毁时清理</li></ul></li></ul><p>后端</p><ul><li>增加数据库<code>seckillTimer.data.js</code></li><li>因为不需要逻辑操作，所以直接使用json-server默认接口，在<code>db.js</code>文件中，引入数据库并增加一个接口<code>/api/seckKill-Timer</code></li></ul><h4 id="首页分类推荐"><a href="#首页分类推荐" class="headerlink" title="首页分类推荐"></a>首页分类推荐</h4><p>前端</p><ul><li><code>HomeRecommand</code>组件由两部分组成<ul><li>头部的分类标签和每个标签对应的推荐内容——组件<code>RecommendItem</code></li></ul></li><li>怎样实现分类推荐<ul><li>使用动态组件，将推荐内容的组件名作为参数传入</li></ul></li><li>怎样获取不同类型的数据<ul><li>给动态组件传入类型值：<code>category</code></li></ul></li><li>实现下拉刷新和上拉加载更多<ul><li>注意：下拉刷新时必须给<code>RecommendItem</code>根组件添加<code>overflow-auto</code>和高度；</li><li>不能加在<code>HomeRecommand</code>组件里，否则会导致初次渲染时获取两次数据</li></ul></li><li>在组件<code>RecommendItem</code>中使用接口获取数据<ul><li>写一个方法获取数据，使用for循环遍历店铺组件<code>shopItem</code></li><li>由于上拉加载会在页面初次渲染时自动调用一次；所以在<code>onLoad</code>中调用获取数据的方法</li></ul></li></ul><p>后端</p><ul><li>和开发搜索类似<ul><li>使用同一个数据库</li><li>逻辑类似</li></ul></li><li>根据传递的参数<code>category、page、limit</code>来筛选数据</li><li>接口：<code>/api/recommend?category=0&amp;page=1&amp;limit=10</code></li></ul><h3 id="五、店铺详情"><a href="#五、店铺详情" class="headerlink" title="五、店铺详情"></a>五、店铺详情</h3><p>商家详情页构成</p><pre><code>shopIndex├─ 顶部店铺信息 —— shopTop├─ tab标签栏│  ├─ 全部商品│  │  └─ 菜单 —— AllGoods│  │     └─ 异步组件 —— AsyncGoodsList│  │        └─ 单个商品 —— GoodsItem│  ├─ 评价 —— shopEvaluate│  └─ 商家 —— shopKeeper└─ 购物车 —— CartItem   ├─ 购物车列表    │  └─ 单个商品 —— CartGoodsItem   └─ 结算栏 —— CartSettlement</code></pre><h4 id="顶部的店铺信息-——-shopTop组件"><a href="#顶部的店铺信息-——-shopTop组件" class="headerlink" title="顶部的店铺信息 —— shopTop组件"></a>顶部的店铺信息 —— <code>shopTop</code>组件</h4><blockquote><p>swiper轮播图组件</p></blockquote><ul><li>设置滑块间的间隔且最后一个滑块完整显示的方法：在<code>.van-swipe-item</code>中<ul><li>将单个滑块设置为怪异盒模型</li><li>将间隔设置为内边距</li><li>传入的单个滑块宽度为内容宽+padding</li></ul></li></ul><blockquote><p>展开和收缩</p></blockquote><ul><li>方法1：使用<code>useToggle</code>函数<ul><li>当value为false时，显示下箭头图标，并且对数据长度进行限制</li><li>当value为true时，显示上箭头图标，不限制对数据长度</li></ul></li><li>方法2：对于文字，可以使用<code>van-text-ellipsis</code>组件</li></ul><blockquote><p>后端接口</p></blockquote><ul><li>接口名<code>/api/shop/detail?shopId=1</code></li><li>根据路由传入的参数<code>shopId</code>筛选数据并返回</li></ul><h4 id="tab标签栏"><a href="#tab标签栏" class="headerlink" title="tab标签栏"></a>tab标签栏</h4><ul><li>利用动态组件实现不同面板的切换</li></ul><p>店铺菜单</p><ul><li>使用<code>IndexBar</code>索引栏组件布局</li><li>索引字符作为左侧菜单，<code>van-index-bar</code>作为右侧的对应内容</li><li>实现分类和点击左侧菜单即可调到对应内容</li></ul><blockquote><p>实现布局</p></blockquote><ul><li>页面分为左右两部分，先把该组件放到右侧的<code>goods-list</code>盒子</li><li>要把索引放到左侧盒子<code>goods-menu</code>，则必须使用<code>teleport</code>属性指定索引栏挂载的节点<code>#menu</code>，然后调整样式</li><li>实现的前提是左侧盒子要比<code>IndexBar</code>索引栏组件更早挂载到页面；然而它们是同一父组件，所以这是实现不了的</li><li>因此要将<code>IndexBar</code>索引栏组件单独放入一个组件，并使用<code>defineAsyncComponent</code>异步调用</li></ul><blockquote><p>左侧菜单实现吸顶盒效果</p></blockquote><ul><li>使用Sticky 粘性布局组件，设置<code>:offset-top</code></li><li>将该组件包裹在<code>scroll-wrapper</code>外面</li></ul><blockquote><p>左侧菜单实现滚动</p></blockquote><ul><li>安装并引入滚动插件 —— <code>better-scroll</code></li></ul><pre><code>npm i better-scrollimport BScroll from &#39;@better-scroll/core&#39;</code></pre><ul><li>在节点<code>#menu</code>外面再包裹一个节点<code>scroll-wrapper</code></li><li>注意：调用时，子元素必须有内容<ul><li>因此设置侦听器：并且为了确保能接收数据，设置定时器，等索引列表<code>indexList</code>接收完成后再触发</li></ul></li><li>注意：子元素的高度必须超过<code>scroll-wrapper</code>的高度，因此需要计算它的高度：<code>屏幕高度-tab栏-购物车</code></li><li>该插件会默认将索引的点击跳转效果关闭，因此必须手动配置</li></ul><pre><code>watch(  indexList,  (value) =&gt; &#123;    if (value.length &gt; 0) &#123;      setTimeout(() =&gt; &#123;        new BScroll(&#39;.scroll-wrapper&#39;, &#123;          click: true        &#125;)      &#125;, 100)    &#125;  &#125;,  &#123;    immediate: true  &#125;)</code></pre><blockquote><p>注意各部分的z-index</p></blockquote><ul><li><code>App</code>页面的底部<code>tabBar</code> —— 2</li><li><code>ShopIndex</code>页面和<code>HomeIndex</code>页面的分类<code>tabBar</code> —— <code>99</code></li><li><code>ShopIndex</code>页面的底部购物车 —— 100</li><li>页面顶部的<code>topBar</code>导航 —— 1</li></ul><blockquote><p>数据渲染</p></blockquote><ul><li>在异步组件<code>AsyncGoodsList</code>中使用接口<code>/api/shop/goods?shopId</code>接收数据，渲染页面</li><li>右侧使用for循环商品组件<code>GoodsItem</code>来实现商品列表</li><li>将<code>shopId</code>和商品数据传递给<code>GoodsItem</code></li></ul><blockquote><p>实现点击商品跳转到详情页</p></blockquote><ul><li>使用vue Router编程式导航来实现</li><li>给<code>GoodsItem</code>的根组件，绑定点击的方法</li><li>当商品被点击时就传入<code>shopId</code>和<code>goodsId</code>，使用<code>push</code>方法来导航到<code>name=goods</code>的路由，即商品详情页</li></ul><blockquote><p>注意区分：</p></blockquote><ul><li><code>useRouter</code>函数访问到 router 实例，可以实现路由间的跳转等</li><li><code>useRoute</code>函数访问到当前路由，可以获取当前路由携带的参数</li></ul><h4 id="购物车-——-CartItem组件"><a href="#购物车-——-CartItem组件" class="headerlink" title="购物车 —— CartItem组件"></a>购物车 —— <code>CartItem</code>组件</h4><blockquote><p>该组件由购物车内容和结算面板组成</p></blockquote><ul><li>购物车内容使用Popup 弹出层实现，点击结算面板时就会从底部弹出<ul><li>其中包含的商品列表使用<code>CartGoodsItem</code>组件，进行for循环实现</li><li><code>CartGoodsItem</code>组件和<code>GoodsItem</code>类似，但不同之处不方便复用，因此拆分成两个</li></ul></li><li>结算面板由<code>CartSettlement</code>组件实现</li></ul><blockquote><p>UseCartStore仓库</p></blockquote><ul><li>使用Map来保存购物车的数据，实现店铺和店铺购物车数据的一一对应</li></ul><pre><code>//数据结构new Map([   // [shopId,shopInfos],    [1,&#123;        shopName:&#39;xxx&#39;,        goodList:[             &#123;                goodsId:&#39;10001&#39;                name: &#39;B级-进口香蕉2根/300-350g&#39;|商品名称                imgUrl: &#39;/images/goods/type1-01.jpg&#39;, // 商品图片                cartCount: 1, // 购物车数量                checked: false,  // 添加购物车按扭选中                // ...更多字段            &#125;,        ]    &#125;]])</code></pre><ul><li>将购物车数据保存到本地存储：使用<code>useLocalStorage</code>实现响应式</li></ul><table><thead><tr><th>方法</th><th>作用</th><th>参数</th></tr></thead><tbody><tr><td><code>cartList</code></td><td>所有购物车信息</td><td>-</td></tr><tr><td><code>pushProductToCart</code></td><td>添加购物数量（+1）</td><td><code>shopId</code>、<code>shopName</code>、<code>goods</code></td></tr><tr><td><code>reduceProductFromCart</code></td><td>减少购物数量（-1）</td><td><code>shopId</code>、<code>goodsId</code></td></tr><tr><td><code>getGoodsCartCount</code></td><td>获取某个店铺的某件商品的加购数量</td><td><code>shopId</code>、<code>goodsId</code></td></tr><tr><td><code>getShopCartInfo</code></td><td>返回对应店铺的购物车列表信息</td><td><code>shopId</code></td></tr><tr><td><code>toggleSelect</code></td><td>动态切换单选</td><td><code>shopId</code>、<code>goodsId</code></td></tr><tr><td><code>isAllSelect</code></td><td>判断是否全选</td><td><code>shopId</code></td></tr><tr><td><code>setAllSelect</code></td><td>设置全选</td><td><code>shopId</code></td></tr><tr><td><code>cancleAllSelect</code></td><td>取消全选</td><td><code>shopId</code></td></tr><tr><td><code>toggleAllSelect</code></td><td>动态切换全选状态</td><td><code>shopId</code></td></tr><tr><td><code>cartGoodsNum</code></td><td>计算店铺加购的商品数量</td><td><code>shopId</code></td></tr><tr><td><code>selectGoodsNum</code></td><td>计算购物车内选中的商品数量</td><td><code>shopId</code></td></tr><tr><td><code>TotalPrice</code></td><td>计算总价格</td><td><code>shopId</code></td></tr><tr><td><code>clearCart</code></td><td>清空购物车</td><td><code>shopId</code></td></tr><tr><td><code>selectToPayGoods</code></td><td>获取单个店铺已选中的商品信息，用于结算</td><td><code>shopId</code></td></tr><tr><td><code>getCartList</code></td><td>返回购物车列表数据</td><td>-</td></tr><tr><td><code>getAllCartPrice</code></td><td>计算所有店铺中选中商品的总价格</td><td>-</td></tr><tr><td><code>getAllCheckedGoodsList</code></td><td>获取所有店铺以及被选中的商品 <code>map</code>结构</td><td>-</td></tr><tr><td><code>clearAllCheckedFromCart</code></td><td>删除购物车中已支付&#x2F;取消支付的商品</td><td>-</td></tr><tr><td><code>deleteCartGoods</code></td><td>删除购物车中的商品</td><td><code>shopId</code>、<code>goodsId</code></td></tr></tbody></table><blockquote><p>逻辑处理</p></blockquote><ul><li>加入购物车<code>pushProducetToCart</code><ul><li>传入对应的shopId、shopName、goods(商品信息)</li><li>先根据shopId判断，如果没有该店铺数据就新增一条</li><li>再根据goodsId判断，如果没有就在对应店铺的goodList里添加一条数据；如果有就更新数量和选中状态</li></ul></li><li>减少商品数量<code>removeProductFromCart</code><ul><li>传入对应的shopId、goodsId</li><li>先根据shopId找到该店铺对应的购物车数据</li><li>再根据goodsId判断，如果有将该商品加购数量-1；如果-1之后是0，那就把该商品数据删除；如果删除后goodList没有数据了，就把店铺信息删除</li></ul></li></ul><blockquote><p>数量组件的数据获取</p></blockquote><ul><li>店铺商品菜单栏<ul><li><code>shopName</code>：<code>AsyncGoodsList</code>–&gt;<code>GoodsItem</code>–&gt;<code>ToCart</code></li><li><code>shopId</code>和<code>Goods</code>：<code>GoodsItem</code>–&gt;<code>ToCart</code></li></ul></li><li>购物车结算<ul><li>都是由<code>CartItem</code>根据路由参数获取，传递给<code>CartGoodsItem</code>–&gt;<code>ToCart</code></li><li><code>shopName</code>：<code>CartItem</code>根据路由参数获取</li><li><code>shopId</code>和<code>Goods</code>：<code>CartItem</code>使用仓库的<code>getShopCartInfo</code>方法获取</li><li>购物车中的商品列表也是使用<code>getShopCartInfo</code>方法获取的数据进行渲染</li></ul></li><li>数量组件中的数量：使用仓库的<code>getGoodsCartInfo</code>方法获取；</li><li>注意使用上面两个方法时要用计算属性实现响应</li></ul><blockquote><p>购物车价格、数量的获取</p></blockquote><ul><li>使用仓库中定义的方法，实现对应数据的渲染</li></ul><blockquote><p>优化购物车样式</p></blockquote><ul><li>没有添加商品时，底部结算面板为灰色，不能点击弹出购物车列表，不能跳转到结算页面，没有徽标</li></ul><h3 id="六、收货地址"><a href="#六、收货地址" class="headerlink" title="六、收货地址"></a>六、收货地址</h3><h4 id="提交结算后的流程"><a href="#提交结算后的流程" class="headerlink" title="提交结算后的流程"></a>提交结算后的流程</h4><img src="process-enterShop.png" style="max-width: 100%;"><p>确认订单页</p><blockquote><p>分成三个组件实现：收货信息、商品列表、底部结算</p></blockquote><ul><li>由于商品列表和底部结算组件都需要复用，所以数据都由父组件传入<blockquote><p>收货信息的渲染：</p></blockquote></li><li>先看是否有<code>addressId</code>，如果有就代表是刚选择完回到该页面</li><li>再找默认地址</li><li>如果都没有就显示选择地址的样式</li></ul><p>选择收货地址页</p><ul><li>可进行选择、修改、删除、添加地址的操作<blockquote><p>页面跳转</p></blockquote></li><li>如果是编辑地址，则需要携带<code>addressId</code>跳转</li><li>如果是新增地址，则不需要参数</li><li>如果是选择地址，则需要带着<code>shopId</code>和<code>addressId</code>跳转到确认订单页</li></ul><blockquote><p>注意：处理选择地址后的后退</p></blockquote><ul><li>选择地址后会直接跳转到确认订单页，此时如果点击顶部导航的后退键，则会返回到选择地址页；逻辑上应该回到店铺</li><li>路径：店铺–&gt;不带<code>addressId</code>的确认订单–&gt;选择地址–&gt;带<code>addressId</code>的确认订单页</li><li>不做任何处理时，在带<code>addressId</code>确认订单点击返回–&gt;选择地址–&gt;不带<code>addressId</code>确认订单–&gt;店铺<blockquote><p>处理方法</p></blockquote></li><li>首先：选择地址后的跳转到确认订单页的方法，用<code>replace</code>代替<code>push</code>方法；它与 push 方法一样用来导航到一个新的 URL，但会替换掉之前的 URL，无法后退到之前 URL</li><li>做完这步之后，路径变成：在带<code>addressId</code>确认订单点击返回–&gt;不带<code>addressId</code>确认订单–&gt;店铺</li><li>因此需要设置定时器，在跳转到确认订单页前，使用<code>history.back()</code>回到不带<code>addressId</code>的确认订单页，然后定时结束使用<code>replace</code>方法跳转到确认订单页；这样就可以直接返回店铺</li></ul><p>地址编辑页和新增地址页</p><ul><li>这两个页面是同一组件和同一套样式，只是根据传入的参数不同，数据的渲染是不同的<blockquote><p>页面布局</p></blockquote></li><li>内容使用Form表单组件渲染，其中地区选择部分，使用<code>van-area</code>组件实现</li><li>在表单中使用 Area 组件时的属性或方法</li></ul><pre><code>// 省市区数据的类型interface IArearList &#123;  text: string  value: string  children: IArearList[]&#125;const result = ref() //显示选择后的省市区数据const showArea = ref(false) //弹窗显隐const areaCode = ref(&#39;110101&#39;) //选择器的默认初始的地区const onConfirm = (&#123; selectedOptions &#125;: &#123; selectedOptions: IArearList[] &#125;) =&gt; &#123;  showArea.value = false  result.value = selectedOptions.map((item) =&gt; item.text).join(&#39;/&#39;)&#125;&lt;van-field  v-model=&quot;result&quot;  is-link  readonly  name=&quot;area&quot;  label=&quot;地区选择&quot;  placeholder=&quot;点击选择省市区&quot;  @click=&quot;showArea = true&quot;/&gt;&lt;van-popup v-model:show=&quot;showArea&quot; position=&quot;bottom&quot;&gt;  &lt;van-area    :area-list=&quot;areaList&quot;    v-model=&quot;areaCode&quot;    @confirm=&quot;onConfirm&quot;    @cancel=&quot;showArea = false&quot;  /&gt;&lt;/van-popup&gt;</code></pre><blockquote><p>遇到的问题：在引入<code>area-data</code>时，报错：“找不到 @vant&#x2F;area-data”或其相应的类型声明”</p></blockquote><ul><li>解决办法：将<code>node_modules</code>下存放省市区数据的<code>index.esm.mjs</code>和类型声明文档<code>index.d.ts</code>复制到<code>src/assets</code>中，接着更改引入地址即可</li></ul><blockquote><p>数据渲染</p></blockquote><ul><li>如果路由携带了<code>addressId</code>参数，则根据它获取地址数据，渲染在页面</li><li>如果没有，则什么都不需要渲染</li></ul><h4 id="API接口"><a href="#API接口" class="headerlink" title="API接口"></a>API接口</h4><blockquote><p>获取收货地址信息接口<code>api/address</code>或<code>api.address/addressId</code></p></blockquote><ul><li>可以使用<code>api/address</code>获取用户的所有地址数据</li><li>也可以使用或<code>api.address/addressId</code>获取单条地址数据</li></ul><blockquote><p>其它接口</p></blockquote><ul><li>新增收货地址：<code>/api/address</code> —— post请求</li><li>修改收货地址：<code>/api/address</code> —— put请求</li><li>删除收货地址：<code>/api/address</code> —— delete请求</li><li>获取默认地址：<code>/api/address/default</code> —— get请求</li></ul><h3 id="七、购物车和订单页"><a href="#七、购物车和订单页" class="headerlink" title="七、购物车和订单页"></a>七、购物车和订单页</h3><h4 id="购物车页面布局"><a href="#购物车页面布局" class="headerlink" title="购物车页面布局"></a>购物车页面布局</h4><pre><code>shopIndex├─ 顶部导航 ├─ 购物车列表 —— CartList│  └─ 单个商品 —— CartGoodsItem├─ 底部结算 —— CartSettlement└─ 确认订单 —— CartOrderComfirmation</code></pre><blockquote><p>购物车列表</p></blockquote><ul><li>使用<code>SwipeCell</code>滑动单元格，实现商品的左右滑动效果</li><li>删除按钮的点击事件，使用<code>cartStore</code>的<code>deleteCartGoods</code>方法实现删除</li></ul><blockquote><p>空页面</p></blockquote><ul><li>使用<code>isNull</code>组件</li></ul><h4 id="购物车数据"><a href="#购物车数据" class="headerlink" title="购物车数据"></a>购物车数据</h4><blockquote><p>购物车列表：</p></blockquote><ul><li>在<code>cartStore</code>里定义一个方法<code>getCartList</code>，返回购物车数据<code>cartList</code></li></ul><blockquote><p>确认订单页数据</p></blockquote><ul><li>复制在店铺结算时的确认订单页，加以修改，二者的购物车数据不同</li><li>从底部tab进入购物车进行结算时，需要获取的是购物车中所有店铺被选中的商品，而不是单个店铺</li><li>在<code>cartStore</code>中定义方法<code>getAllCheckedGoodsList</code>，用来获取所有店铺以及被选中的商品，返回的数据为map结构</li></ul><h4 id="确认支付"><a href="#确认支付" class="headerlink" title="确认支付"></a>确认支付</h4><blockquote><p>功能</p></blockquote><ul><li>点击确认支付后，需要完成：模拟支付、生成订单、删除购物车中已结算商品、跳转到订单页</li><li>第一步：根据点击确认支付或取消支付，会生成不同的订单状态：已完成&#x2F;已取消</li><li>第二步：调用接口<code>/generate/order</code>，传入订单信息，生成订单数据</li><li>第三步：使用<code>cartStore</code>中的方法，将提交支付的商品从购物车中删除</li><li>第四步：跳转到订单页</li></ul><blockquote><p>实现</p></blockquote><ul><li>定义一个字段<code>orderList</code>，保存订单数据，在调用生成订单的接口时传入，包括：<ul><li>继承购物车数据：<code>shopName</code>、<code>goodsList</code></li><li>新增：<code>userId</code>、<code>orderId</code>、<code>shopId</code>、<code>addressId</code>、<code>isCanceled</code>(表示订单状态)</li></ul></li></ul><p>接口</p><ul><li>在后端数据库中定义一个函数，返回空的订单数组<blockquote><p>生成订单<code>/generate/order</code></p></blockquote></li><li>在生成订单的接口中，接收请求体中传入的订单数据<ul><li>如果是数组，表示多个店铺的订单数据，遍历数组，给每个订单新增<code>orderId</code>字段；并添加进数据库</li><li>如果是单个数据，直接新增<code>orderId</code>字段，添加进数据库<blockquote><p>返回所有订单<code>/order/list</code></p></blockquote></li></ul></li><li>返回订单数据库的全部内容</li></ul><h4 id="订单页"><a href="#订单页" class="headerlink" title="订单页"></a>订单页</h4><blockquote><p>数据</p></blockquote><ul><li>调用接口<code>/order/list</code>，获取所有订单<blockquote><p>空页面</p></blockquote></li><li>使用<code>isNull</code>组件</li></ul><h3 id="八、商品详情页"><a href="#八、商品详情页" class="headerlink" title="八、商品详情页"></a>八、商品详情页</h3><h4 id="布局中需要注意"><a href="#布局中需要注意" class="headerlink" title="布局中需要注意"></a>布局中需要注意</h4><blockquote><p>加入购物车按钮与数量组件</p></blockquote><ul><li>根据<code>shopId</code>和<code>goodsId</code>获取当前商品的加购数量；如果数量为0，则显示加入购物车按钮</li><li>点击加入购物车，就调用<code>pushProductToCart</code>方法将当前商品加入购物车数据</li></ul><h4 id="商品数据"><a href="#商品数据" class="headerlink" title="商品数据"></a>商品数据</h4><blockquote><p>需要什么</p></blockquote><ul><li>商品详情的渲染需要<code>goods</code>数据</li><li>使用数量组件、获取当前商品的加购数量、加入购物车等都需要<code>shopId</code>和<code>shopName</code></li></ul><blockquote><p>接口</p></blockquote><ul><li>需要传入：<code>shopId</code>和<code>goodsId</code></li><li>在数据库中，我们需要的<code>goods</code>数据包含在<code>data</code>，<code>data</code>字段包含了该店铺所有的商品信息</li><li>因此后端接口在拿到参数后：<ul><li>先找到对应的店铺</li><li>将该店铺不同类别下的所有商品放在一个数组中</li><li>遍历数组，并找到和<code>goodsId</code>相同的商品</li><li>在响应体中，除了返回前一步找到的商品数据，还要加上<code>shopId</code>和<code>shopName</code></li></ul></li></ul><h3 id="九、关联用户"><a href="#九、关联用户" class="headerlink" title="九、关联用户"></a>九、关联用户</h3><p>一般情况下，在项目初始搭建的时候就应该考虑到这一点</p><blockquote><p>购物车关联用户</p></blockquote><ul><li>拿到<code>useInfo</code>状态管理库中的<code>userId</code></li><li>将本地存储中保存用户的购物车数据的字段与用户ID关联</li><li>创建侦听器，一旦用户id变化，LocalStorage就会重新创建字段保存该用户的购物车数据</li></ul><blockquote><p>订单关联用户</p></blockquote><ul><li>在生成订单时，将userId加入订单数据，发送到后端</li><li>前端在调用获取订单的接口时，需要将用户id传入</li><li>获取订单的接口，要根据请求体中携带的用户id，对订单数据进行筛选，返回当前用户的订单数据</li></ul><blockquote><p>收货地址关联用户</p></blockquote><ul><li>在调用接口时传入<code>userId</code></li><li>修改获取&#x2F;删除&#x2F;编辑&#x2F;新增用户地址的接口，使用userId对数据进行筛选</li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> app </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JS核心知识点（二十四）</title>
      <link href="/2023/12/14/JS%E6%A0%B8%E5%BF%83%E7%9F%A5%E8%AF%86%E7%82%B9%EF%BC%88%E4%BA%8C%E5%8D%81%E5%9B%9B%EF%BC%89/"/>
      <url>/2023/12/14/JS%E6%A0%B8%E5%BF%83%E7%9F%A5%E8%AF%86%E7%82%B9%EF%BC%88%E4%BA%8C%E5%8D%81%E5%9B%9B%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<span id="more"></span><h2 id="ES6-Module模块系统"><a href="#ES6-Module模块系统" class="headerlink" title="ES6 Module模块系统"></a>ES6 Module模块系统</h2><blockquote><p>历史上，JavaScript 一直没有模块（module）体系，无法将一个大程序拆分成互相依赖的小文件，再用简单的方法拼装起来。其他语言都有这项功能，比如 Ruby 的require、Python 的import，甚至就连 CSS 都有@import，但是 JavaScript 任何这方面的支持都没有，这对开发大型的、复杂的项目形成了巨大障碍</p><ul><li>在 ES6 之前，社区制定了一些模块加载方案，最主要的有 CommonJS 和 AMD 两种。前者用于服务器，后者用于浏览器。</li><li>ES6 在语言标准的层面上，实现了模块功能，而且实现得相当简单，完全可以取代 CommonJS 和 AMD 规范，成为浏览器和服务器通用的模块解决方案。</li><li>ES6 模块的设计思想是尽量的静态化，使得编译时就能确定模块的依赖关系，以及输入和输出的变量。CommonJS 和 AMD 模块，都只能在运行时确定这些东西。</li></ul></blockquote><h3 id="一、JavaScript-模块化历程"><a href="#一、JavaScript-模块化历程" class="headerlink" title="一、JavaScript 模块化历程"></a>一、JavaScript 模块化历程</h3><h4 id="JS-发展中遇到的问题"><a href="#JS-发展中遇到的问题" class="headerlink" title="JS 发展中遇到的问题"></a>JS 发展中遇到的问题</h4><blockquote><p>早期 JS 能做的事情不多，其代码量也不大，我们通常把所有的 JS 写在一个文件中。但随着 JS 的发展，JS 能做的事情也就越来越多了，JS 的代码量也就越来越多，如果所有的 JS 代码都放在一个文件中，开发和维护都是极为不方便的，更不方便多人协作开发。</p></blockquote><blockquote><p>为了解决这些问题，我们开始考虑 JS 模块化，把不同功能的 JS 代码抽取出来放在一个单独的 JS 文件中，然后用简单的办法他们拼接起来。</p></blockquote><blockquote><p>这样可以多人协作来开发，每个人开发一部分功能，同时维护起来方便，那个功能需要更改，就需要找到对应功能的那个 js 文件来修改就好。</p><ul><li>JS 模块化： 可以理解为把一个大的 JS 程序拆分成多个相互依赖的小文件，再用简单的方法将它们拼装起来。</li></ul></blockquote><blockquote><p>我们来看一个简单的案例，求对象中两个属性的最大值和最小值，我们可以把所有代码写在一个 JS 文件中，如下：</p></blockquote><pre><code>// 数据配置对象const data = &#123;  max: 10,  min: 1,&#125;;// 求最小值function min() &#123;  return data.max &gt; data.min ? data.min : data.max;&#125;// 求最大值function max() &#123;  return data.max &gt; data.min ? data.max : data.min;&#125;</code></pre><ul><li>求最大值和最小值是两个独立的函数，并没有什么关联。但后面很多其他的项目中需要用到这两个方法。 </li><li>为了能够实现复用，我们把这两个函数独立出去放到两个不同的 JS 文件中实现。假设这两个函数内部实现相当复杂，我们就把他们交给了两个不同的程序员来开发。在开发前，协商好数据配置对象按规定的格式，写入<code>config.js</code>文件中。最终开发出来的代码如下：</li><li><code>config.js</code>文件为数据配置对象，用户可以自定义两个需要比较的数,前提是要遵守一定规则。<ul><li><code>min.js</code>文件，用来求两个数中的最小值</li><li><code>max.js</code>文件，用来求两个数中的最大值</li></ul></li></ul><pre><code>// config.jsconst data = &#123;  max: 10,  min: 1,&#125;;// max.jslet a = data.max;let b = data.min;function max() &#123;  return a &gt; b ? a : b;&#125;// min.jslet a = data.max;let b = data.min;function min() &#123;  return a &lt; b ? a : b;&#125;</code></pre><blockquote><p>接下来我们在<code>index.html</code>页面引入这三个 JS 文件，并调用<code>max</code>和<code>min</code>函数，求出最大值和最小值</p></blockquote><pre><code>&lt;script src=&quot;./config.js&quot;&gt;&lt;/script&gt;&lt;script src=&quot;./max.js&quot;&gt;&lt;/script&gt;&lt;script src=&quot;./min.js&quot;&gt;&lt;/script&gt;&lt;script&gt; console.log(max()); console.log(min());&lt;/script&gt;</code></pre><ul><li><strong>注：</strong> 以上代码并没有办法正确的执行，原因在于<code>max.js</code>和<code>min.js</code>文中的变量a,b发生了<strong>命名的冲突</strong></li></ul><blockquote><p>当我们把<code>max.js</code>中的变量a,b改为m,n（代码如下），错误消失了，并且代码正常执行了。</p></blockquote><pre><code>let m = data.max;let n = data.min;function max() &#123;  return m &gt; n ? m : n;&#125;</code></pre><blockquote><p>但是，如果我们再把<code>index.html</code>页面中引入 JS 文件的顺序打乱，代码如下：</p></blockquote><pre><code>&lt;script src=&quot;./max.js&quot;&gt;&lt;/script&gt;&lt;script src=&quot;./min.js&quot;&gt;&lt;/script&gt;&lt;script src=&quot;./config.js&quot;&gt;&lt;/script&gt;&lt;script&gt;  console.log(max());  console.log(min());&lt;/script&gt;</code></pre><ul><li>以上代码执行时，又抛出了错误<code>max.js:1 Uncaught ReferenceError: data is not defined</code> 错误。</li><li>原因在于<code>max.js</code>和<code>min.js</code>在<code>config.js</code>文件前面引入，所以在执行<code>max.js</code>和<code>min.js</code>时，<code>data</code>变量还没有定义。这就引发了我们上面提到的第二个错误</li><li>多个 JS 文件之间存在依赖关系，必需严格的保证 JS 的<strong>加载顺序</strong></li></ul><h4 id="早期模块化遇到的问题"><a href="#早期模块化遇到的问题" class="headerlink" title="早期模块化遇到的问题"></a>早期模块化遇到的问题</h4><blockquote><p>通过上面案例的讲解，我们发现当我们把一个大的 JS 程序拆分成多个小的 JS 文件后，<strong>好处</strong>很明显，就是可以实现代码的复用，同时可以多人协作开发，每人开发一个小的功能，然后再把他们拼接起来。但同时也遇到了以下两个<strong>问题</strong>：</p></blockquote><ul><li>一个页面需要加载多个 JS 文件，多个不同的 JS 文件之间就有可能存在变量命名冲突问题（同时大部分变量为全局变量，造成全局变量的污染）</li><li>多个 JS 文件之间还存在依赖关系，因此必须要严格的保证 JS 文件的加载顺序，否则就会出错</li></ul><h4 id="解决多个-JS-文件变量命名冲突问题"><a href="#解决多个-JS-文件变量命名冲突问题" class="headerlink" title="解决多个 JS 文件变量命名冲突问题"></a>解决多个 JS 文件变量命名冲突问题</h4><blockquote><p>多个 JS 文件中的变量之所以发生命名冲突问题，是因为这些相同的变量都在同一作用域（全局作用域下）<br><strong>早期的解决办法有以下二种：</strong></p></blockquote><ul><li>1、所有代码定义在一个对象中，对外暴露这个对象,通过访问对象的属性和方法来使用</li><li>2、将所有代码用<code>IIFE</code>立即执行函数包裹起来，将需要暴露的接口作为<code>window</code>对象的属性暴露出去。这样他们分别处于不同的函数作用域中，<strong>不仅解决了变量命名冲突问题，也减少了全局变量的污染，但并没有完全消除全局变量的污染</strong></li></ul><pre><code>// 方法一：作为对象的属性和方法const maxObj = &#123;  m: data.max,  n: data.min,  max() &#123;    return this.m &gt; this.n ? this.m : this.n;  &#125;,&#125;(// 方法二： IIFE立即执行函数  function () &#123;    let m = data.max;    let n = data.min;    function max() &#123;      return m &gt; n ? m : n;    &#125;    // 将max作为window对象的属性，暴露出去    window.max = max;  &#125;)();</code></pre><p><strong>注：</strong></p><ul><li>JS 模块化对于 JS 来说很重要，但 JS 原生不支持，所以社区制定了一些模块加载的方案，最主要的有 CommonJS 和 AMD、CMD。当然现在 ES6 原生支持模块化了，所以我们不再需要了解这些插件库的应用，直接来学习 ES6 的 Module 模块化就好。</li></ul><h3 id="二、认识-Module"><a href="#二、认识-Module" class="headerlink" title="二、认识 Module"></a>二、认识 Module</h3><blockquote><p>ES Module 把一个 JS 文件当作一个独立的模块，这个文件内的所有变量，外部都无法获取。如果外部需要获取模块内的某个变量，就必需要使用<code>export</code>关键字输出该变量。在外部利用<code>import</code>关键字来导入该模块，并导入模块对外输出的内容。</p></blockquote><blockquote><p>ES Module 主要就是用来解决以下<strong>三大问题</strong>：</p></blockquote><ul><li>JS 模块化的问题（一个 JS 文件就是一个模块，有自己独立的作用域）</li><li>变量命名冲突问题</li><li>管理模块间的加载顺序问题</li></ul><h4 id="Module-需要的环境"><a href="#Module-需要的环境" class="headerlink" title="Module 需要的环境"></a>Module 需要的环境</h4><blockquote><p>在学习 Module 模块系统之前，首先需要知道一点，Module 模块系统它需要一个服务器环境才能正常的执行。</p></blockquote><ul><li>如我们将<code>Module</code>模块系统的代码写在<code>.html</code>文件中，直接打开是不能正常执行的</li><li>直接使用<code>VSCode</code>中的<code>Live Server</code>本地服务器环境即可。<blockquote><ul><li>接下来的学习，我们需要全程使用<code>Open with Live Server</code>的方式打开了</li></ul></blockquote></li></ul><h4 id="Module-模块化的简单使用"><a href="#Module-模块化的简单使用" class="headerlink" title="Module 模块化的简单使用"></a>Module 模块化的简单使用</h4><blockquote><p><code>.config.js</code>数据配置文件，为一个单独的模块</p></blockquote><pre><code>const data=&#123;    max:10;    min:1&#125;export default data; // 导出模块接口</code></pre><blockquote><p><code>max.js</code> 为一个单独的模块</p></blockquote><pre><code>import data from &quot;./config.js&quot;;let a = data.max;let b = data.min;function max() &#123;  return a &gt; b ? a : b;&#125;export default max; // 导出模块接口</code></pre><blockquote><p><code>min.js</code> 为一个单独的模块</p></blockquote><pre><code>import data from &quot;./config.js&quot;;let a = data.max;let b = data.min;function min() &#123;  return a &gt; b ? b : a;&#125;export default min; // 导出模块接口</code></pre><blockquote><p><code>index.html</code>文件中，通过以下方式来加载模块</p></blockquote><pre><code>&lt;script type=&quot;module&quot;&gt;  // 加载模块  import max from &quot;./max.js&quot;;  console.log(max());  // 加载模块  import min from &quot;./min.js&quot;;  console.log(min());  // 在这里，我们没有办法访问max.js和min.js中的变量a和b  // console.log(a,b); // 报错&lt;/script&gt;</code></pre><blockquote><p>注：通过 ES Moudle 来实现 JS 模块化的模块化，轻松的解决了上面提到的三大问题：</p></blockquote><ul><li>JS 模块化的问题（每个 JS 文件就是一个模块，有自己独立的作用域，通过<code>export</code>导出模块接口）</li><li>变量命名冲突问题</li><li>管理模块间的加载顺序问题</li></ul><h3 id="三、Module-的导入与导出"><a href="#三、Module-的导入与导出" class="headerlink" title="三、Module 的导入与导出"></a>三、Module 的导入与导出</h3><blockquote><p>Module 导入和导出模块有两种形式：</p></blockquote><ul><li><code>export default</code>导出和<code>import</code> 导出</li><li><code>export</code>导出和<code>import</code> 导出</li></ul><h4 id="export-default和对应的import"><a href="#export-default和对应的import" class="headerlink" title="export default和对应的import"></a><code>export default</code>和对应的<code>import</code></h4><ul><li><code>export default</code>命令为模块指定默认输出（导出）</li><li><code>import</code>用来加载模块，并导入模块中导出的内容</li></ul><blockquote><p>使用示例</p></blockquote><ul><li>新建<code>module.js</code>文件，使用<code>export default</code>导出模块中的默认输出</li></ul><pre><code>const username = &quot;icoding&quot;;// 用export default 导出模块中的默认输出export default username;</code></pre><ul><li>新建<code>index.html</code>文件，在<code>index.html</code>文件里，<code>type=&quot;module&quot;</code>必须要写，否则没有办法把js当成模块来加载</li><li>用import来导入模块导出的变量，这里的变量名可以是任意名字</li></ul><pre><code>&lt;!-- type=&quot;module&quot; 必需要写，否则没有办法把js当成模块来加载--&gt;&lt;script type=&quot;module&quot;&gt;  // import username from &quot;./module.js&quot;;  // 这里的变量名可以取任意名字  // console.log(username);  import myname from &quot;./module.js&quot;;  console.log(myname);&lt;/script&gt;</code></pre><blockquote><p>注意事项</p></blockquote><ul><li>带有<code>type = &#39;module&#39;</code>的<code>&lt;script&gt;</code>标签，浏览器是<strong>异步加载</strong>的</li><li>这意味着不会造成浏览器堵塞，即等到<strong>整个页面渲染完</strong>再执行模块脚本，等同于打开了<code>&lt;script&gt;</code>标签的<code>defer</code>属性</li></ul><pre><code>&lt;script type=&quot;module&quot;&gt;  const box = document.getElementById(&quot;box&quot;);  console.log(box.innerHTML); // 我居然显示出来了&lt;/script&gt;&lt;div id=&quot;box&quot;&gt;我居然显示出来了&lt;/div&gt;</code></pre><blockquote><p><code>export default</code>命令为模块指定默认输出时，显然一个模块<strong>只能有一个默认输出</strong></p></blockquote><ul><li>所以<code>export default</code>命令只能使用一次</li><li>如果我们的模块只需要导出一个值，即可使用<code>export default</code></li></ul><pre><code>const username=&quot;icoding&quot;;// 报错，因为一个模块中只能有一个export defaultexport default usernameexport default 53;</code></pre><blockquote><p><code>export default</code>本质上就是输出一个叫作<code>default</code>的变量或方法</p></blockquote><ul><li>所以<code>export default</code>后面<strong>只能是变量或值</strong>，不能是变量声明语句，相当于把后面的值或变量中的值赋值给到变量<code>default</code></li><li>所以在用<code>import</code>接收的时候，可以取任意名字接收</li></ul><pre><code>const username = &quot;icoding&quot;;// 正确导出export default username;export default 53;export default function fn()&#123;&#125;export default function()&#123;&#125;export default &#123;&#125;export default class A&#123;&#125;export default class&#123;&#125;// 错误导出export default const username = &quot;icoding&quot;;export default let fn = function()&#123;&#125;export default const obj = &#123;&#125;</code></pre><h4 id="export和对应的import"><a href="#export和对应的import" class="headerlink" title="export和对应的import"></a><code>export</code>和对应的<code>import</code></h4><blockquote><p><code>export</code>命令用来指定模块的对外输出接口，<strong>可以对外输出多个接口</strong>，这一点与<code>export default</code>不同</p></blockquote><ul><li><code>import</code>命令用来导入其他模块的导出接口</li></ul><blockquote><p>使用示例</p></blockquote><ul><li>新建<code>module.js</code>文件</li></ul><pre><code>// export导出多个接口：函数  类  变量等export function foo() &#123;&#125;export class Person &#123;&#125;export const sex = &quot;male&quot;;</code></pre><ul><li>新建<code>index.js</code>文件</li></ul><pre><code>&lt;script type=&quot;module&quot;&gt;  // import导入多个接口，其导入时变量名与export导出时一模一样，同时要写在&#123;&#125;中  // import &#123; foo &#125; from &quot;./module.js&quot;;  // import &#123; Person &#125; from &quot;./module.js&quot;;  // import &#123; sex &#125; from &quot;./module.js&quot;;  // 下面import代码，等价于上面分三次导入  import &#123; foo, Person, sex &#125; from &quot;./module.js&quot;;  console.log(foo); //  ƒ foo() &#123; &#125;  console.log(Person); // class Person &#123; &#125;  console.log(sex); // male&lt;/script&gt;</code></pre><blockquote><p>注意事项</p></blockquote><ul><li><code>export</code>命令规定的是对外的接口，所以其后<strong>只能是声明语句</strong>，不能是值或变量。</li></ul><pre><code>// 正确导出export let num=1;export function fn(params) &#123;&#125;export class A&#123;&#125;export let obj=&#123;&#125;// 错误导出接口let num=1export num;export function()&#123;&#125;export class &#123;&#125;export obj&#123;&#125;</code></pre><ul><li><code>import</code>导入<code>export</code>导出的接口时，导入时的变量名，需要与导出时<strong>一模一样</strong>。</li></ul><pre><code>&lt;script type=&quot;module&quot;&gt;  // import导入多个接口，其导入时变量名与export导出时一模一样，同时要写在&#123;&#125;中  // import &#123; foo &#125; from &quot;./module.js&quot;;  // import &#123; Person &#125; from &quot;./module.js&quot;;  // import &#123; sex &#125; from &quot;./module.js&quot;;  // 或统一导出  import &#123; foo, Person, sex &#125; from &quot;./module.js&quot;;  console.log(foo); //  ƒ foo() &#123; &#125;  console.log(Person); // class Person &#123; &#125;  console.log(sex); // male&lt;/script&gt;</code></pre><blockquote><p>export 语句输出的接口与其对应的值是<strong>动态绑定关系</strong>，即可以通过接口取到模块内部实时的值</p></blockquote><ul><li><code>module.js</code> 文件</li></ul><pre><code>export let username = &quot;清心&quot;;setTimeout(() =&gt; &#123;  username = &quot;icoding&quot;;&#125;, 3000);</code></pre><ul><li><code>index.js</code> 文件</li></ul><pre><code>&lt;script type=&quot;module&quot;&gt;  import &#123; username &#125; from &quot;./module.js&quot;;  console.log(username);  setTimeout(() =&gt; &#123;    console.log(username);  &#125;, 3000);  // 最终输出结果： 清心  icoding&lt;/script&gt;</code></pre><blockquote><p>export 多个接口统一导出</p></blockquote><ul><li>如果需要导出的变量、对象或方法有几十个怎么办，难道也要一个一个手动导出吗 ？</li><li>一个一个导出，显然太麻烦了，export 允许<strong>一次导出多个</strong></li></ul><pre><code>function foo() &#123;&#125;class Person &#123;&#125;const sex = &quot;male&quot;;// 一次性导出多个接口export &#123; foo, Person, sex &#125;;</code></pre><blockquote><p><code>export</code>导出取别名</p></blockquote><ul><li>使用<code>as</code>关键字可以为导出的变量取别名，如果取了别名后，<code>import</code>在导入时，需要<strong>用别名</strong>来导入。</li></ul><pre><code>function foo() &#123;&#125;class Person &#123;&#125;const sex = &quot;male&quot;;// 使用 as 关键字起别名export &#123; foo as func, Person, sex &#125;;</code></pre><ul><li>导入时，必须用别名</li></ul><pre><code>&lt;script type=&quot;module&quot;&gt;  // func必需与export导出时的别名一致  import &#123; func, Person, sex &#125; from &quot;./module.js&quot;;  // 调用时  console.log(func, Person, sex);&lt;/script&gt;</code></pre><blockquote><p><code>export</code>与<code>export default</code><strong>同时</strong>导出</p></blockquote><ul><li>我们可以在一个模块文件中同时用<code>export</code>来导出多个接口，也可以同时使用<code>export default</code>导出默认输出（接口）</li></ul><pre><code>function foo() &#123;&#125;class Person &#123;&#125;const sex = &quot;male&quot;;const username = &quot;icoding&quot;;// 一次性导出接口（多个变量）export &#123; foo, Person, sex &#125;;// 默认导出export default username;</code></pre><h4 id="import导入"><a href="#import导入" class="headerlink" title="import导入"></a><code>import</code>导入</h4><blockquote><p><code>import</code>导入<code>export</code>时取别名</p></blockquote><ul><li>使用<code>as</code>关键字可以为导入的变量取别名，如果取了别名后，<strong>后面输出内容只能使用别名</strong>。</li><li>导入：一般在使用第三方库时，为了保证代码风格的统一，就需要取别名</li></ul><pre><code>function foo() &#123;&#125;class Person &#123;&#125;const sex = &quot;male&quot;;export &#123; foo, Person, sex &#125;;// 使用 as 关键字起别名import &#123; foo as bar, Person as People, sex &#125; from &quot;./module.js&quot;;console.log(bar); // 必需使用别名，否则访问不到console.log(People); // 必需使用别名，否则访问不到console.log(sex);</code></pre><blockquote><p>同时导入所有接口——方式一：<code>* as</code></p></blockquote><ul><li><p>利用<code>* as</code>来导入多个导出，因为<code>*</code>不能当做变量名来使用，所以我们都要为他<strong>用<code>as</code>的方式取别名</strong>。</p></li><li><p><code>*</code>得到的是一个<strong>模块对象<code>Module</code></strong></p></li><li><p>导出</p></li></ul><pre><code>function foo() &#123;&#125;class Person &#123;&#125;const sex = &quot;male&quot;;const username = &quot;icoding&quot;;export default username;// 一次性导出接口（多个变量）export &#123; foo, Person, sex &#125;;</code></pre><ul><li>导入</li></ul><pre><code>&lt;script type=&quot;module&quot;&gt;  // * 表示所有的输入  // as obj 别名  import * as obj from &quot;./module.js&quot;;  console.log(obj);//Module &#123;Symbol(Symbol.toStringTag): &#39;Module&#39;&#125;&lt;/script&gt;</code></pre><p><strong>取出接口</strong></p><ul><li>方法1：<code>Module</code>是一个模块对象，所以我们需要通过<strong>对象打点属性</strong>的方式来访问导出的接口<ul><li>对于<code>default</code>，使用<code>obj.default</code></li></ul></li></ul><pre><code>&lt;script type=&quot;module&quot;&gt;  // * 表示所有的输入  // as obj 别名  import * as obj from &quot;./module.js&quot;;  //对象打点属性  console.log(obj.default);//&quot;icoding&quot;  console.log(obj.sex);//&quot;male&quot;&lt;/script&gt;</code></pre><ul><li>方法2：取出所有接口时，可以利用对象的解构赋值<ul><li>对于<code>default</code>接口，必须自己取个变量名，用<code>:变量名</code>的方式对应属性值，因为<code>default</code>是关键字，不能作为变量名</li></ul></li></ul><pre><code>&lt;script type=&quot;module&quot;&gt;  // * 表示所有的输入  // as obj 别名  import * as obj from &quot;./module.js&quot;;// 取出所有接口，利用对象的解构赋值const &#123; default: username, foo, Person, sex &#125; = obj;console.log(username);//&quot;icoding&quot;console.log(sex);//&quot;male&quot;&lt;/script&gt;</code></pre><blockquote><p>同时导入所有接口——方式二：<code>默认接口,&#123;export接口&#125;</code></p></blockquote><ul><li><code>export default</code>导出的默认接口，<strong>必须要写在最前面</strong>，然后<strong>用逗号分隔</strong></li><li>后面的<code>&#123;&#125;</code>为 <code>export</code> 导出的多个接口</li><li>如果只有<code>export</code>接口，就直接用<code>&#123;&#125;</code></li></ul><pre><code>&lt;script type=&quot;module&quot;&gt;  // 错误写法  // import &#123; foo, Person, sex &#125;,username from &quot;./module.js&quot;;  // 正确写法  import username, &#123; foo, Person, sex &#125; from &quot;./module.js&quot;;  console.log(username); // icoding  console.log(foo); // ƒ foo() &#123; &#125;  console.log(Person); // class Person &#123; &#125;  console.log(sex); // male&lt;/script&gt;</code></pre><p><strong>取出接口</strong>：直接使用接口名</p><h3 id="四、import-关键字"><a href="#四、import-关键字" class="headerlink" title="四、import 关键字"></a>四、import 关键字</h3><blockquote><p>通过前面的学习，我们知道<code>import</code>关键字用来导入模块的输出接口。不过他还有一些重要的特点，需要我们掌握，具体如下：</p></blockquote><ul><li><code>import</code>可以只用来导入模块（模块中可以没有导出接口）</li><li><code>import</code>命令具有提升效果，会提升到整个模块的头部，率先执行</li><li><code>import</code>是静态执行，也就是说<code>import</code>命令是编译阶段执行的，也就是说<code>import</code>导入的模块是编译阶段就确定好了</li><li>多次加载同一个<code>import</code>语句，只会执行一次（相当多次加载，后面的会覆盖前面的，所以在执行阶段只有一份代码）。</li><li><code>import</code>可以用于在一个模块中导入另一个模块</li></ul><h4 id="import-只用来导入模块"><a href="#import-只用来导入模块" class="headerlink" title="import 只用来导入模块"></a>import 只用来导入模块</h4><blockquote><p>import 可以只用来导入模块（<strong>模块中可以没有导出接口</strong>）</p></blockquote><ul><li><code>module.js</code> 模块文件</li></ul><pre><code>console.log(&quot;我是module.js模块中引入的代码 ...&quot;);</code></pre><ul><li><code>index.js</code>文件中引入<code>module.js</code>模块文件</li></ul><pre><code>&lt;script type=&quot;module&quot;&gt;  // 导入模块  import &quot;./module.js&quot;;  // 在控制台输出： 我是module.js模块中引入的代码 ...&lt;/script&gt;</code></pre><blockquote><p>简写</p></blockquote><pre><code>&lt;!--如果import只是用来导入模块，则可以简写成如下形式--&gt;&lt;script type=&quot;module&quot; src=&quot;./module.js&quot;&gt;&lt;/script&gt;</code></pre><h4 id="import-具有提升效果"><a href="#import-具有提升效果" class="headerlink" title="import 具有提升效果"></a>import 具有提升效果</h4><blockquote><p>import 命令具有提升效果，会提升到整个模块的头部，率先执行</p></blockquote><ul><li><code>module.js</code>模块文件</li></ul><pre><code>onsole.log(&quot;我是module.js模块中引入的代码 ...&quot;);</code></pre><ul><li><code>index.js</code>文件中引入<code>module.js</code>模块文件</li></ul><pre><code>&lt;script type=&quot;module&quot;&gt;  console.log(&quot;我是第一个&quot;);  console.log(&quot;我是第二个&quot;);  // 导入模块  import &quot;./module.js&quot;;&lt;/script&gt;//我是module.js模块中引入的代码 ...//我是第一个//我是第二个</code></pre><ul><li>import 命名导入的模块代码，不论你写在页面的任何位置，<strong>都会提升到最开头的地方</strong>（所有代码的前面，率先执行）</li><li>因为，在执行代码之前，浏览器 JavaScript 引擎<strong>静态分析</strong>会先分析代码中的 import 语法，会在所有代码执行之前先找到 import，将它提升到最前面并先执行完成之后，再执行其他代码</li></ul><blockquote><p>以下代码，并不会如我们期望的那样去执行</p></blockquote><ul><li>因为<code>import</code>命令会被<code>JavaScript</code>引擎静态分析，先于模块内的其他语句执行</li></ul><pre><code>&lt;script type=&quot;module&quot;&gt;  // 模拟判断如果是PC端，执行pc端模块代码，如果是移动端执行移动端代码（伪代码）  let pc = true; // pc端  let yd = false; // 移动端  if (pc) &#123;    import &quot;./pc.js&quot;;  &#125; else if (yd) &#123;    import &quot;mobile.js&quot;;  &#125;&lt;/script&gt;</code></pre><ul><li>上面代码中，引擎处理<code>import</code>语句是在编译时，这时不会去分析或执行<code>if</code>语句，所以<code>import</code>语句放在<code>if</code>代码块之中毫无意义，因此会报语法错误，而不是执行时错误。</li><li>因此，<code>import</code>和<code>export</code>命令只能在<strong>模块的顶层</strong>(指的是最外层，不是最顶端)，不能在代码块之中。</li></ul><h4 id="import-是静态执行"><a href="#import-是静态执行" class="headerlink" title="import 是静态执行"></a>import 是静态执行</h4><ul><li><code>import</code>是静态执行，也就是说<code>import</code>导入的模块是<strong>编译阶段</strong>就确定好了。</li><li>所以<code>import</code>语句中<strong>不能使用表达式或变量</strong>，也就不能使用只有在代码执行阶段才能得到结果的语法结构</li></ul><pre><code>// 报错import &#123;&#39;f&#39;+&#39;oo&#39;&#125; &quot;./module.js&quot;;// 报错let bar = &quot;foo&quot;;import &#123; bar &#125; from &quot;./module.js&quot;;</code></pre><h4 id="import-多次加载，只执行一次"><a href="#import-多次加载，只执行一次" class="headerlink" title="import 多次加载，只执行一次"></a>import 多次加载，只执行一次</h4><blockquote><p>多次加载同一个<code>import</code>语句，只会执行一次</p></blockquote><ul><li><code>module.js</code> 模块文件</li></ul><pre><code>console.log(&quot;我是module.js模块中引入的代码 ...&quot;);function foo() &#123;&#125;class Person &#123;&#125;const sex = &quot;male&quot;;const username = &quot;icoding&quot;;export &#123; foo, Person, sex &#125;;</code></pre><ul><li><code>index.js</code>文件中多次引入<code>module.js</code>模块文件</li></ul><pre><code>&lt;script type=&quot;module&quot;&gt;  import &#123; foo &#125; from &quot;./module.js&quot;;  import &#123; Person &#125; from &quot;./module.js&quot;;  import &#123; sex &#125; from &quot;./module.js&quot;;  console.log(foo);  console.log(Person);  console.log(sex);&lt;/script&gt;//我是module.js模块中引入的代码 ...//foo()&#123;&#125;//class Person &#123;&#125;//male</code></pre><p><strong>注：</strong></p><ul><li>上面<code>import</code>导入了三次<code>module.js</code>文件，但是控制台<strong>只输出了一次</strong>“我是module.js模块中引入的代码 …”。说明三次导入中只有一次被执行了。</li></ul><h4 id="一个模块中导入另一个模块"><a href="#一个模块中导入另一个模块" class="headerlink" title="一个模块中导入另一个模块"></a>一个模块中导入另一个模块</h4><blockquote><p><code>import</code>可以用于在一个模块中导入另一个模块，这个功能解决了多个<code>JS</code>文件之间的依赖关系</p></blockquote><ul><li><code>config.js</code>配置文件</li></ul><pre><code>const data = &#123;  max: 10,  min: 1,&#125;;export default data; // 默认导出</code></pre><ul><li><code>max.js</code>文件，在这文件中导入<code>config.js</code>文件</li></ul><pre><code>import data from &quot;./config.js&quot;; // 导入config.js模块let a = data.max;let b = data.min;function max() &#123;  return a &gt; b ? a : b;&#125;export default max;</code></pre><ul><li><code>index.js</code>文件</li></ul><pre><code>&lt;script type=&quot;module&quot;&gt;  // 导入模块  import max from &quot;./max.js&quot;;  console.log(max());&lt;/script&gt;</code></pre><h3 id="五、import-函数"><a href="#五、import-函数" class="headerlink" title="五、import() 函数"></a>五、import() 函数</h3><blockquote><p>在前面我们学习了<code>import</code>命令（关键字），<code>import</code>命令会被<code>JS</code>引擎静态分析（也就是被加载的模块会在编译阶段就确定好），同时他会被提升到当前模块（代码）的最前面，并在执行阶段最先执行。</p></blockquote><ul><li>所以，以下这种形式的代码会报错</li></ul><pre><code>&lt;script type=&quot;module&quot;&gt;  let a = 3;  if (a === 4) &#123;    import myname from &quot;./a.js&quot;;  &#125;&lt;/script&gt;</code></pre><blockquote><p>因为模块的加载是在编译阶段就确定好的，也就是模块之间的依赖关系是在编译阶段就确定好的。这样有利于提高编译器的效率，但也导致无法在运行时加载模块。也就是我们没有办法按条件来加载对应模块。</p><ul><li>因此，ES2020 提案引入<code>import()</code>函数，支持动态加载模块</li></ul></blockquote><h4 id="import-动态加载模块"><a href="#import-动态加载模块" class="headerlink" title="import()动态加载模块"></a><code>import()</code>动态加载模块</h4><blockquote><p><code>import()</code>函数用于<strong>动态加载模块</strong>，他与<code>import</code>关键字存在以下区别</p></blockquote><ul><li><code>import()</code>函数支持动态加载模块，他可以<strong>在任何地方使用</strong>。</li><li><code>import()</code>函数是<strong>在运行时执行</strong>的，只有当代码运行到<code>improt()</code>函数这一语句时，才会开始加载指定模块。</li><li><code>import()</code>函数加载模块属于运行时<strong>异步加载</strong><br>代码演示</li></ul><pre><code>// a.js文件console.log(&quot;a.js模块执行了&quot;);// b.js文件console.log(&quot;b.js模块执行了&quot;);</code></pre><ul><li><code>index.js</code>文件</li></ul><pre><code>&lt;script type=&quot;module&quot;&gt;  console.log(&quot;同步一&quot;);  setTimeout(function f1() &#123;    console.log(&quot;定时器1000&quot;);  &#125;, 1000);  let a = 3;  if (a === 4) &#123;    import(&quot;./a.js&quot;);  &#125; else &#123;    import(&quot;./b.js&quot;);  &#125;  setTimeout(function f0() &#123;    console.log(&quot;定时器0&quot;);  &#125;, 0);  console.log(&quot;同步二&quot;);&lt;/script&gt;//同步一//同步二//定时器0//b.js模块执行了//定时器1000</code></pre><blockquote><p><strong>上面代码，从上往下执行</strong></p></blockquote><ul><li>遇到同步代码，打印“同步一”，</li><li>遇到异步代码，在<code>1s</code>后，将回调函数<code>f1</code>添加到宏任务队列，接着向下执行。</li><li>遇到<code>import()</code>函数加载模块，因为<code>import()</code>函数加载模块为异步加载，需要等模块加载成功后，才会把模块代码添加到宏任务队列中排着。等着同步任务全部执行完后，再执行。</li><li>遇到定时器，马上将回调函数<code>f0</code>添加到宏任务队列。</li><li>任务队列中需要执行的任务：<code>fn0</code>，<code>import</code>模块，<code>fn1</code></li></ul><blockquote><p><code>import()</code>函数返回值</p></blockquote><ul><li><code>import()</code>函数的返回值为<code>promise</code>对象</li><li><code>promise</code>对象的返回值(即<code>[[PromiseResult]]</code>属性值)为<code>mudule</code>，这个对象的成员为模块对外导出的接口。</li><li>所以我们可以利用<code>promise</code>对象的<code>then</code>方法中的参数来接受这个对象</li><li>获取输出的接口的方式<br> -<code>mudule</code>是一个对象，所以可以采用<code>对象.属性名</code>的方式，注意获取<code>export defalut</code>的时候用<code>对象.default</code><ul><li>利用<strong>对象的解构赋值</strong>来获取输出的接口。注意获取<code>export defalut</code>的时候用<code>&#123;default : 变量名&#125;</code>的方式</li></ul></li></ul><h4 id="使用import-函数导入的模块"><a href="#使用import-函数导入的模块" class="headerlink" title="使用import()函数导入的模块"></a>使用<code>import()</code>函数导入的模块</h4><blockquote><p>模块中只有<code>export</code>方式导出的接口</p><ul><li>方式一：打点调用</li><li>方式二：直接利用对象解构赋值来获取输出的接口<ul><li>接收data后再解构赋值</li><li>接收时就解构赋值</li></ul></li></ul></blockquote><ul><li><code>moudle.js</code></li></ul><pre><code>function foo() &#123;&#125;class Person &#123;&#125;const obj = &#123;&#125;;// 导出接口export &#123; foo, Person, obj &#125;;</code></pre><ul><li><code>index.html</code>——方式一</li></ul><pre><code>&lt;script type=&quot;module&quot;&gt;  const p = import(&quot;./module.js&quot;);  console.log(p);//Promise &#123;&lt;pending&gt;&#125;  p.then((data) =&gt; &#123;    console.log(data); //Module &#123;Symbol(Symbol.toStringTag): &#39;Module&#39;&#125;    console.log(data.foo); // ƒ foo()&#123;&#125;    console.log(data.Person); // class Person&#123;&#125;    console.log(data.obj); // &#123;&#125;  &#125;);&lt;/script&gt;</code></pre><ul><li><code>index.html</code>——方式二</li></ul><pre><code>&lt;script type=&quot;module&quot;&gt;  const p = import(&quot;./module.js&quot;);  console.log(p);//Promise &#123;&lt;pending&gt;&#125;  p.then((data) =&gt; &#123;    console.log(data); //Module &#123;Symbol(Symbol.toStringTag): &#39;Module&#39;&#125;    const &#123; foo, Person, obj &#125; = data;    console.log(foo); // ƒ foo()&#123;&#125;    console.log(Person); // class Person&#123;&#125;    console.log(obj); // &#123;&#125;  &#125;);&lt;/script&gt;</code></pre><ul><li><code>index.html</code>——方式三</li></ul><pre><code>&lt;script type=&quot;module&quot;&gt;  const p = import(&quot;./a.js&quot;);  p.then((&#123; foo, Person, obj &#125;) =&gt; &#123;    console.log(foo);    console.log(Person);    console.log(obj);  &#125;);&lt;/script&gt;</code></pre><blockquote><p>如果模块中，只有 export default 的默认输出</p></blockquote><ul><li><code>moudle.js</code></li></ul><pre><code>let username = &quot;icoding&quot;;export default username;</code></pre><ul><li><code>index.html</code><ul><li>方式一：打点调用</li><li>方式二：解构赋值，不过由于<code>default</code>是关键字，不能作为变量名，所以要取一个变量名来接收属性值</li></ul></li></ul><pre><code>&lt;script type=&quot;module&quot;&gt;  const p = import(&quot;./module.js&quot;);  p.then((data) =&gt; &#123;    console.log(data.default); // // &quot;icoding&quot;  &#125;);  // 或下面这种方式，具名输出  p.then((&#123; default: username &#125;) =&gt; &#123;    console.log(username); // &quot;icoding&quot;  &#125;);&lt;/script&gt;</code></pre><blockquote><p>有 <code>export</code> 导出，又有 <code>export default</code> 的默认导出</p></blockquote><ul><li>方式一：<code>对象.属性名</code></li></ul><pre><code>&lt;script type=&quot;module&quot;&gt;  const p = import(&quot;./module.js&quot;);  p.then((data) =&gt; &#123;    console.log(data.default);    console.log(data.foo);    console.log(data.Person);    console.log(data.obj);  &#125;);&lt;/script&gt;</code></pre><ul><li>方式二：解构赋值</li></ul><pre><code>&lt;script type=&quot;module&quot;&gt;  const p = import(&quot;./module.js&quot;);  p.then((&#123; default: username, foo, Person, obj &#125;) =&gt; &#123;    console.log(username);    console.log(foo);    console.log(Person);    console.log(obj);  &#125;);&lt;/script&gt;</code></pre><h4 id="一次性动态加载多模块"><a href="#一次性动态加载多模块" class="headerlink" title="一次性动态加载多模块"></a>一次性动态加载多模块</h4><blockquote><p>一次性动态加载多个模块，用一个新的 <code>Promise</code> 对象包装下，利用 <code>Promise.all</code> 方法来处理</p></blockquote><ul><li>一个一个处理</li></ul><pre><code>&lt;script type=&quot;module&quot;&gt;  const p1 = import(&quot;./a.js&quot;);  const p2 = import(&quot;./b.js&quot;);  const p3 = import(&quot;./c.js&quot;);  // 然后分别处理，获取输出的接口  p1.then((data)=&gt;&#123;....&#125;)  p2.then((data)=&gt;&#123;....&#125;)  p3.then((data)=&gt;&#123;....&#125;)  // 如果我们需要一次拿 到三个模块的输出接口，才开始后面的操作，显然上面的写法不能实现&lt;/script&gt;</code></pre><ul><li>利用<code>Promise.all</code>方法来处理</li></ul><pre><code>&lt;script type=&quot;module&quot;&gt;  Promise.all([import(&quot;./a.js&quot;), import(&quot;./b.js&quot;), import(&quot;./c.js&quot;)]).then(    ([module1, module2, module3]) =&gt; &#123;      // ....      console.log(module1);      console.log(module2);      console.log(module3);    &#125;  );&lt;/script&gt;</code></pre><h3 id="六、在实际开发中的注意事项"><a href="#六、在实际开发中的注意事项" class="headerlink" title="六、在实际开发中的注意事项"></a>六、在实际开发中的注意事项</h3><h4 id="模块顶层的-this-指向"><a href="#模块顶层的-this-指向" class="headerlink" title="模块顶层的 this 指向"></a>模块顶层的 <code>this</code> 指向</h4><blockquote><p>模块中，顶层的 <code>this</code> 指向 <code>undefined</code></p></blockquote><pre><code>// module.js 文件console.log(this); // module.js作为模块时，其顶层this指向undefined&lt;!--在index.js文件中导入模块module.js--&gt;&lt;script type=&quot;module&quot;&gt;  import &quot;./module.js&quot;;&lt;/script&gt;&lt;!-- 或 --&gt;&lt;script src=&quot;./module.js&quot; type=&quot;module&quot;&gt;&lt;/script&gt;</code></pre><ul><li>应用：JS 文件只能以模块方式加载<blockquote><p>防止用户不使用模块的方式导入（如不使用模块的方式导入，<code>this</code> 就是指向<code>window</code>了，相当于导入了一个普通的 JS 文件），我们可以使用这一特性来限定某个 JS 文件只能以模块的方式加载，否则就抛出错误。</p><ul><li>在模块 <code>module.js</code> 文件中，如果 <code>this 指向 ≠ undefined</code> 时，抛出错误，提示用户需要使用模块化的方式来加载</li></ul></blockquote></li></ul><pre><code>// module.js 文件if (typeof this !== &quot;undefined&quot;) &#123;  throw new Error(&quot;请使用模块的方式加载 ...&quot;);&#125;</code></pre><ul><li>如果在<code>index.html</code>文件中使用普通的<code>JS</code>文件的方式导入</li></ul><pre><code>&lt;!-- 使用普通引入JS文件的方式，未使用模块化的方式加载时，就会抛出自定义错误 --&gt;&lt;script src=&quot;./module.js&quot;&gt;&lt;/script&gt;</code></pre><h4 id="导入导出的复合写法（了解）"><a href="#导入导出的复合写法（了解）" class="headerlink" title="导入导出的复合写法（了解）"></a>导入导出的复合写法（了解）</h4><blockquote><p>如果在一个模块之中<strong>先输入后输出同一个模块</strong>，则可以采用复合写法，将 <code>import</code> 语句与 <code>export</code> 语句写在一起。</p><ul><li>具体如下</li></ul></blockquote><pre><code>import &#123; a, b &#125; from &quot;./a.js&quot;; // 在b模块中，导入a模块接口export &#123; a, b &#125;; // 导出接口a,b// 上面写法，等同于export &#123; a, b &#125; from &quot;./a.js&quot;; // 导出从a模块导入的接口a，b</code></pre><blockquote><p>不过分开写与复合写法之间还是存在不同</p></blockquote><ul><li>分开写，可以在当前模块中使用导入的接口，而复合写法是没有办法在当前模块中使用导入的接口。</li></ul><pre><code>// b.js 文件import &#123; a, b &#125; from &quot;./a.js&quot;;export &#123; a, b &#125;;console.log(a, b); // 正确输出结果</code></pre><pre><code>// b.js文件export &#123; a, b &#125; from &quot;./a.js&quot;;console.log(a, b); // 抛出引用错误，a和b未定义</code></pre><blockquote><p>基本应用</p></blockquote><pre><code>// a.js文件export let a = 1;export let b = 2;// b.js文件export let m = 10;export let n = 20;export &#123; a, b &#125; from &quot;./a.js&quot;; // 导出从a模块导入的接口a，b</code></pre><pre><code>&lt;!--index.js 文件--&gt;&lt;script type=&quot;module&quot;&gt;  import &#123; a, b, m, n &#125; from &quot;./b.js&quot;;  console.log(a, b, m, n); // 1 2 10 20&lt;/script&gt;</code></pre><blockquote><p>其它应用</p></blockquote><ul><li>复合写法中实现修改接口名字</li></ul><pre><code>// b.js文件export &#123; a as aa, b &#125; from &quot;./a.js&quot;;</code></pre><ul><li>整体导入并导出</li></ul><pre><code>// b.js 文件export * from &quot;./a.js&quot;;</code></pre><blockquote><p>注意：以上整体导入并导出，会忽略a.js模块中的<strong>默认导出</strong></p></blockquote><pre><code>// a.js文件let username = &quot;icoding&quot;;export default username;// b.js文件export * from &quot;./a.js&quot;;&lt;!--index.js--&gt;&gt;&lt;script type=&quot;module&quot;&gt;  import username from &quot;./b.js&quot;;  console.log(username);  // 抛出错识：不提供名为 “default” 的导出&lt;/script&gt;</code></pre><blockquote><p>导入默认接口，并将其作为默认接口导出</p></blockquote><ul><li>default表示导入的默认接口，并将其作为默认接口导出（前提要保证b.js中没有其它的默认导出，否则会报错）</li><li>默认接口，<strong>必需要写在最前面</strong>，然后<strong>用逗号分隔</strong>.后面的<code>&#123;&#125;</code>为 <code>export</code> 导出的多个接口</li></ul><pre><code>// a.jslet a = 1;export default aexport let b = 2;// b.jsexport let m = 10;export let n = 20;export &#123;default,b&#125; from &quot;./a.js&quot;;// index.html&lt;script type=&quot;module&quot;&gt;  import a, &#123; b, m, n &#125; from &quot;./b.js&quot;;  console.log(a, b, m, n); // 1 2 10 20&lt;/script&gt;</code></pre><blockquote><p>将导入的接口作为默认接口导出</p></blockquote><ul><li>a.js和b.js都不能有默认接口</li></ul><pre><code>// a.jsexport let a = 1;export let b = 2;// b.jsexport let m = 10;export let n = 20;export &#123;a as default,b&#125; from &quot;./a.js&quot;;// index.html&lt;script type=&quot;module&quot;&gt;  import a, &#123; b, m, n &#125; from &quot;./b.js&quot;;  console.log(a, b, m, n); // 1 2 10 20&lt;/script&gt;</code></pre><ul><li>以上复合写法仅需了解即可。</li></ul><h3 id="七、应用"><a href="#七、应用" class="headerlink" title="七、应用"></a>七、应用</h3><blockquote><p>我们现在有这样一个需求，实现一个名为<code>ball.js</code>的模块，当我们在 <code>html</code> 页面加载这个模块时，导入其<code>init</code>接口，调用下<code>init()</code>函数，就可以实现在页面插入一个小球。</p></blockquote><blockquote><p>当然，用户也可以根据自己的需求，在根目录下创建一个<code>ball.config.js</code>文件,然后按下面要求来配置小球的相关属性或方法等。</p><ul><li><code>ball.config.js</code>文件默认导出一个对象，对象的相关属性和值需要遵守以下表格中的规则。</li></ul></blockquote><table><thead><tr><th>属性名</th><th>说明</th><th>值类型</th></tr></thead><tbody><tr><td>color</td><td>小球颜色</td><td>字符串类型的颜色值，可以是 英文字母、rgb、rgba</td></tr><tr><td>r</td><td>小球半径</td><td>数字类型，必须为整数，最大不超过 100</td></tr><tr><td>x</td><td>小球水平坐标</td><td>数字类型，必须为整数，最大不超过 1800</td></tr><tr><td>y</td><td>小球垂直坐标</td><td>数字类型，必须为整数，最大不超过 800</td></tr><tr><td>opacity</td><td>小球垂直坐标透明度</td><td>数字类型，必须为 0-1 之间的小数</td></tr></tbody></table><ul><li><code>ball.config.js</code>文件</li></ul><pre><code>export default &#123;    color:&quot;pink&quot;,    r:200,    x:300,    y:400,    opacity:0.5,    name:&quot;球球&quot;,&#125;</code></pre><ul><li><code>ball.js</code>文件</li></ul><pre><code>//导入import userDate from &#39;./ball.config.js&#39;function init()&#123;    const defaultDate=&#123;        color:&quot;yellow&quot;,        r:100,        x:100,        y:100,        opacity:1    &#125;     // 遍历用户配置的参数，把不相关的属性过滤掉    let config=&#123;&#125;    const keys=Object.keys(userDate)    for(let key of keys)&#123;        if(defaultDate.hasOwnProperty(key))&#123;            config[key]=userDate[key]        &#125;    &#125;    //创建小球    const ball = document.createElement(&quot;div&quot;);    ball.style.backgroundColor=config.color;    ball.style.width=config.r*2+&quot;px&quot;;    ball.style.height=config.r*2+&quot;px&quot;;    ball.style.opacity=config.opacity;    ball.style.position=&quot;absolute&quot;;    ball.style.left=config.x;    ball.style.top=config.y;    ball.style.borderRadius=&quot;50%&quot;;    //插入页面    document.body.appendChild(ball);&#125;//导出export default init;</code></pre><ul><li><code>index.html</code>页面</li></ul><pre><code>&lt;script type=&quot;module&quot;&gt;  import init from &quot;./ball.js&quot;;  init();&lt;/script&gt;</code></pre><h3 id="八、总结"><a href="#八、总结" class="headerlink" title="八、总结"></a>八、总结</h3><h4 id="导出和导入"><a href="#导出和导入" class="headerlink" title="导出和导入"></a>导出和导入</h4><table><thead><tr><th></th><th>export default</th><th>export</th></tr></thead><tbody><tr><td>个数</td><td>只能使用一次</td><td>可多次</td></tr><tr><td>后面接什么</td><td>变量或值</td><td>声明语句</td></tr><tr><td>导入时的变量名</td><td>可以取任意名字</td><td>必须和导出时一模一样(和别名&#x2F;变量名一样)</td></tr><tr><td>取别名</td><td>导出变量时不能取别名，导入时可以取任意名字</td><td>导入和导出时都可以用<code>as</code>取别名</td></tr></tbody></table><p>导出多个<code>export</code>接口：</p><blockquote><p>用<code>&#123;&#125;</code>将接口包裹：<code>export&#123;&#125;</code>；可以取别名，但导入时也要用别名</p><ul><li><code>export &#123; foo, Person, sex &#125;;</code></li></ul></blockquote><blockquote><p><code>import</code>整体导入所有接口</p></blockquote><ul><li>方式一：用<code>* as 别名</code>的方式，必须取别名来接收这个模块对象；</li><li>从对象中取出接口的方式：<ul><li>1.对象打点属性，默认属性：<code>对象.default</code></li><li>2.解构赋值，默认属性：<code>&#123;default:别名&#125;</code></li></ul></li></ul><pre><code>//导入import * as obj from &quot;./module.js&quot;;//对象打点属性console.log(obj.default);//利用对象的解构赋值const &#123; default: username, foo, Person, sex &#125; = obj;console.log(username);//</code></pre><ul><li>方式二：用<code>默认接口,&#123;export接口&#125;</code>，默认接口取任意名字，不能改变顺序</li><li>取出接口的方式：直接调用接口名</li></ul><pre><code>//导入import username, &#123; foo, Person, sex &#125; from &quot;./module.js&quot;;//取出接口console.log(username); // icoding</code></pre><p>import 命令与 import 关键字</p><blockquote><p><code>import</code> 命令与 <code>import()</code> 函数都可以实现导入模块，并接受导出的接口，不过他们存在以下<strong>不同点</strong></p></blockquote><table><thead><tr><th>区别</th><th>import命令</th><th>import 函数</th></tr></thead><tbody><tr><td>出现位置</td><td>模块最顶层</td><td>任意位置</td></tr><tr><td>运行时机</td><td>编译阶段</td><td>执行阶段</td></tr><tr><td>加载方式</td><td>静态加载（编译时加载）</td><td>异步加载</td></tr></tbody></table><ul><li><code>import</code>命令不能与<code>if</code>配合，实现按需加载，而<code>import()</code>函数可以与<code>if</code>配合，实现按需加载</li></ul><h2 id="ES6Proxy-代理-与-Reflect反射"><a href="#ES6Proxy-代理-与-Reflect反射" class="headerlink" title="ES6Proxy 代理 与 Reflect反射"></a>ES6Proxy 代理 与 Reflect反射</h2><p><strong>什么是代理</strong></p><blockquote><ul><li>代理就是针对一个对象设置代理，控制对这个对象的直接访问。用户不得直接访问这个对象，只能访问该对象的代理，代理会帮忙完成相关操作。</li></ul><p>在现实生活中，需要用到代理的地方非常多，比如：</p><ul><li>房产中介：房产中介作为房主的代理人。如果客户想看房，只能联系中介人员，中介会代理房主带客户看房，签合同，收钱等。</li><li>明星经纪人：经纪人作为明星的代理人。如果有人想请明星参加一场商业演出，只能联系他的经纪人，经纪人会代理明星与客户谈好合作的细节和报酬，再把合同交给明星签。</li></ul></blockquote><p><strong>代理的价值</strong></p><blockquote><p>我们还是以房产中介和明星经纪人作为案例来讲解。<br><strong>为什么房主不直接与客户对接呢？</strong></p><ul><li>因为房主平时忙，没有时间带客户看房，还有房主不会拟合同等，所以找个专业的代理来完成这些事情，肯定比自己亲自来要好。</li></ul><p><strong>为什么明星不直接与客户对接呢？</strong></p><ul><li>明星作为公众人为要维护好自己对外的形象，所以不方便直接和客户谈钱。谈钱这种事交给经纪人更合理。如果明星对于合作有要求，比如低于 10 万的演出就不要接，那这种情况自然是经纪人出面会更好，经经人可以直接帮明星拒绝一些不合理的要求和合作。</li><li>通过上面的例子，我们知道代理可以帮对象做很多对象自己做不了的事情，或拒绝，过滤掉一些不合法，不安全，不满足要求的事情等</li></ul></blockquote><p><strong>代理的价值</strong></p><blockquote><ul><li>使用代理，可以保证<strong>更加方便，安全的访问对象</strong>，代理可以帮助我们<strong>过滤</strong>掉一些不合理的，敏感的，不安全的信息。</li></ul></blockquote><h3 id="一、Proxy-基本用法"><a href="#一、Proxy-基本用法" class="headerlink" title="一、Proxy 基本用法"></a>一、Proxy 基本用法</h3><blockquote><p>Proxy（代理）可以理解成：在目标对象之前架设一层<strong>“拦截”</strong>，外界对该对象的访问，都必须先通过这层拦截，因此提供了一种机制，可以对外界的访问进行过滤和改写。</p></blockquote><h4 id="Proxy-语法"><a href="#Proxy-语法" class="headerlink" title="Proxy 语法"></a>Proxy 语法</h4><blockquote><p>ES6 原生提供了<code>Proxy</code>构造函数，用于生成<code>Proxy</code>实例。</p></blockquote><ul><li>我们实际操作的是 Proxy 的实例<blockquote><p>语法</p></blockquote></li></ul><pre><code>const proxy = new Proxy(target, handler);</code></pre><blockquote><p>参数</p></blockquote><ul><li><code>target</code>：表示要使用<code>Proxy</code>代理的目标对象（可以是任何类型的对象，包括原生数组，函数，甚至另一个代理）</li><li><code>handler</code>：是一个处理器对象，对象的每个属性是一个函数，用来定制相关的拦截行为。</li></ul><h4 id="proxy-基本用法"><a href="#proxy-基本用法" class="headerlink" title="proxy 基本用法"></a>proxy 基本用法</h4><blockquote><p>当我们读取对象的某个属性时，<code>handler</code>对象中的<code>get</code>方法就可以拦截该操作，如果读取对象身上不存在的属性时，就会抛出错误。</p></blockquote><ul><li>具体代码实现如下：</li></ul><pre><code>// 目标对象const obj = &#123;  name: &quot;icoding&quot;,  age: 33,&#125;;// 代理对象const proxy = new Proxy(obj, &#123;  get(target, key) &#123;    if (key in target) &#123;      return target[key];    &#125; else &#123;      throw new Error(&quot;访问的属性不存在&quot;);    &#125;  &#125;,&#125;);//使用代理对象console.log(proxy.name); // icodingconsole.log(proxy.sex); // Uncaught Error: 访问的属性不存在</code></pre><blockquote><p>代码解析</p></blockquote><ul><li>上面代码中的 obj 为目标对象，proxy 为代理对象。当我们访问 proxy 对象的属性时，就相当于是在访问目标对象上的相关属性。</li><li>但和直接访问目标对象不同，通过 proxy 代理访问时，就会调用代理构造函数的第二个参数<code>handle</code>对象中的<code>get</code>方法来处理（相当于拦截）</li></ul><blockquote><p>注意事项</p></blockquote><ul><li>要使 Proxy 代理起作用，必须对<strong>Proxy实例</strong>（上例中的 proxy）进行操作，<strong>而不是针对目标对象</strong>（上例中的 obj）进行操作</li><li>如果直接访问<code>obj.sex</code>，会得到<code>undefined</code>，因为<code>Proxy</code>没起作用</li></ul><h4 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h4><blockquote><p>当<code>handler = &#123;&#125;</code>时，相当于没有设置任何拦截，那操作代理对象<strong>等同于直接操作目标对象</strong>。</p></blockquote><pre><code>// 目标对象const obj = &#123;  name: &quot;icoding&quot;,  age: 33,&#125;;// 代理对象const proxy = new Proxy(obj, &#123;&#125;);//使用代理对象console.log(proxy.name); // icodingconsole.log(proxy.sex); // undefined 相当于obj.sex</code></pre><h3 id="二、handler-对象的方法"><a href="#二、handler-对象的方法" class="headerlink" title="二、handler 对象的方法"></a>二、handler 对象的方法</h3><blockquote><p><code>handler</code>：是一个<strong>处理器对象</strong>，对象的每个属性是一个函数（每个函数相当于是具有特定功能的捕捉器），用来定制相关的拦截行为。如果对象中没有指定相关的捕捉器，那就会保留目标对象的默认行为。</p><ul><li>那接下来我们来学习下 handler 对象身上可以设置那些方法（捕捉器）</li></ul></blockquote><h4 id="handler-get-方法"><a href="#handler-get-方法" class="headerlink" title="handler.get()方法"></a><code>handler.get()</code>方法</h4><blockquote><p><code>handler.get()</code>方法用于拦截对象的读取属性操作，包括访问原型上的属性</p><ul><li>返回值：可以是任何类型，表示最终访问到的属性值。</li></ul></blockquote><blockquote><p>语法</p></blockquote><pre><code>var p = new Proxy(target, &#123;  get: function (target, property, receiver) &#123;    // ....  &#125;,&#125;);</code></pre><blockquote><p>get函数的参数：</p></blockquote><ul><li>target：被代理的目标对象</li><li>property：<strong>被获取的</strong>属性名，注意是<strong>字符串类型</strong></li><li>receiver：可选参数，指代上面的<code>p</code>，<code>Proxy</code>实例</li></ul><blockquote><p>基本应用</p><ul><li>访问对象身上不存在的属性时会报错</li></ul></blockquote><pre><code>// target 目标对象const obj = &#123;  name: &quot;icoding&quot;,  age: 33,&#125;;// proxy 代理对象const proxy = new Proxy(obj, &#123;  get(target, prop) &#123;    if (prop in target) &#123;      return target[prop];    &#125; else &#123;      throw new Error(&quot;访问的属性不存在&quot;);    &#125;  &#125;,&#125;);console.log(proxy.name); // icodingconsole.log(proxy.toString); // ƒ toString() &#123; [native code] &#125;proxy.sex; // Uncaught Error: 访问的属性不存在</code></pre><ul><li>正常情况下，当我们访问对象上不存在的属性时，返回值是<code>undefined</code>，但是上面抛出了错误，说明 <code>proxy</code> 代理生效，拦截了对 <code>obj</code> 对象的访问</li></ul><blockquote><ul><li>实现数组可以通过负索引来访问</li></ul></blockquote><pre><code>const target = [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;];const arr = new Proxy(target, &#123;  get(target, prop) &#123;    prop = Number(prop); // 将属性转换为数字类型    if (prop &lt; 0) &#123;      prop = target.length + prop; // 将负数转换为正数对应索引    &#125;    return target[prop];  &#125;,&#125;);console.log(arr[-1]); // cconsole.log(arr[-2]); // bconsole.log(arr[0]); // a</code></pre><ul><li>当访问的数组的属性（下标）值是小于 0 的负数时，则将其转换为对应的正数索引下标并输出：<code>数组长度+下标</code>。</li><li>注意：<code>property</code>是字符串类型，进行计算时，要转为数字类型</li></ul><blockquote><ul><li>注意事项</li></ul></blockquote><ul><li>如果一个属性<strong>不可配置</strong>(configurable)或<strong>不可写</strong>(writable)，代理时的返回值必须与该目标对象的属性的值相同，否则就会抛出错误</li></ul><pre><code>const obj = &#123;  a: 1,  b: 2,&#125;;Object.defineProperty(obj, &quot;c&quot;, &#123;  configurable: false,  value: 3,  writable: false,&#125;);const proxy = new Proxy(obj, &#123;  get(target, prop) &#123;    if (prop === &quot;c&quot;) &#123;      // return 3;  // 访问属性时，正确输出3      return 4; // 访问属性c时，因为输出的值不是3，和目标属性的值不相同，所以抛出错误    &#125; else &#123;      return target[prop];    &#125;  &#125;,&#125;);console.log(proxy.a); // 1console.log(proxy.c); // 如果上面return3，则正确输出3，否则抛错</code></pre><h4 id="handler-set-方法"><a href="#handler-set-方法" class="headerlink" title="handler.set()方法"></a><code>handler.set()</code>方法</h4><blockquote><p><code>handler.set()</code>方法用于拦截对对象的某个属性做赋值操作。</p></blockquote><ul><li>语法</li></ul><pre><code>const p = new Proxy(target, &#123;  set: function (target, property, value, receiver) &#123;    // ....  &#125;,&#125;);</code></pre><blockquote><p><code>set</code>函数的参数：</p></blockquote><ul><li>target：被代理的目标对象</li><li>property：将要被设置值的属性名</li><li>value：新的属性值</li><li>receiver：可选参数，最初被调用的对象。通常是 proxy 本身</li></ul><blockquote><p>返回值：是一个布尔值，<code>true</code>表示赋值成功，<code>false</code>表示赋值失败</p></blockquote><ul><li>非严格模式下，返回值可写可不写</li><li><strong>严格模式</strong>下，一定要写(除非抛出错误)，同时返回值为<code>false</code>时，会抛出错误</li></ul><pre><code>//   &quot;use strict&quot;;const obj = &#123;  a: 1,  b: 2,&#125;;let handler = &#123;  set(target, prop, value) &#123;    if (prop === &quot;a&quot;) &#123;      return false;    &#125;    target[prop] = value;    return true; // 非严格模式下，可以省略不写  &#125;,&#125;;const proxy = new Proxy(obj, handler);proxy.b = &quot;hello&quot;;// 捕获错误try &#123;  proxy.a = &quot;world&quot;;&#125; catch (err) &#123;  console.log(err);&#125;console.log(proxy.b);console.log(proxy.a);</code></pre><blockquote><p>基本用法</p><ul><li>禁止给以<code>_</code>下划线开头的私有属性被重新赋值，并抛出错误</li></ul></blockquote><pre><code>// &quot;use strict&quot;;const obj = &#123;  name: &quot;icoding&quot;,  age: 33,  _sex: &quot;女&quot;,&#125;;const proxy = new Proxy(obj, &#123;  set(target, prop, value) &#123;    // 如果属性名以_开头，则抛出错误    if (prop[0] === &quot;_&quot;) &#123;      throw new Error(&quot;不允许赋值操作&quot;);    &#125;    // 其它情况，正常赋值    target[prop] = value;    // 非严格模式下，return语句可以省略    return true;  &#125;,&#125;);proxy.name = &quot;arry&quot;;proxy._sex = &quot;男&quot;;//报错</code></pre><blockquote><ul><li>实现数据绑定，当对象的某个属性发生变化时，自动更新 DOM</li></ul></blockquote><pre><code>&lt;h3 class=&quot;title&quot;&gt;标题&lt;/h3&gt;&lt;p class=&quot;desc&quot;&gt;内容&lt;/p&gt;&lt;script&gt; const data = &#123;   title: &quot;新闻标题&quot;,   desc: &quot;新问内容&quot;, &#125;; const title = document.querySelector(&quot;.title&quot;); const desc = document.querySelector(&quot;.desc&quot;); title.innerText = data.title; desc.innerText = data.desc; const proxy = new Proxy(data, &#123;   set(target, prop, value) &#123;     switch (prop) &#123;       case &quot;title&quot;:         title.innerText = value;         break;       case &quot;desc&quot;:         desc.innerText = value;         break;     &#125;   &#125;, &#125;); // 点击页面，更新数据 document.onclick = function () &#123;   proxy.title = &quot;set方法能做什么？&quot;;   proxy.desc = &quot;set方法可以实现动态更新DOM&quot;; &#125;;&lt;/script&gt;</code></pre><blockquote><p>注意事项</p></blockquote><ul><li>若目标属性是一个不可写及不可配置的数据属性，则不能改变它的值，否则会报错</li></ul><h4 id="handler-has-方法"><a href="#handler-has-方法" class="headerlink" title="handler.has() 方法"></a>handler.has() 方法</h4><blockquote><p><code>handler.has()</code>方法用来拦截判断<strong>某个属性是否为对象属性</strong>的操作，但并不拦截判断某个属性是否为对象自身属性的操作。</p></blockquote><ul><li>也就是说 <code>has </code>方法主要针对<code>in</code>运算符，而不针对<code>hasOwnProperty</code>，还有<code>for...in</code>中用到了 in 运算符，但<code>has()</code>拦截对<code>for…in</code>循环不生效。</li><li>返回值： 返回一个布尔值，<code>true</code>表示该属性存在于该对象上，<code>false</code>表示不存在该对象上</li></ul><blockquote><p>语法</p></blockquote><pre><code>const p = new Proxy(target, &#123;  has: function (target, property) &#123;    // ....  &#125;,&#125;);</code></pre><blockquote><p><code>has</code>函数的参数：</p></blockquote><ul><li><code>target</code>：被代理的目标对象</li><li><code>property</code>：需要检查是否存在的属性名</li></ul><blockquote><p>基本应用</p><ul><li>用来隐藏对象的某个属性</li></ul></blockquote><pre><code>const obj = &#123;  name: &quot;icoding&quot;,  age: 33,  _sex: &quot;女&quot;,&#125;;const proxy = new Proxy(obj, &#123;  has(target, prop) &#123;    if (prop[0] === &quot;_&quot;) &#123;      return false;    &#125;    return prop in target;  &#125;,&#125;);console.log(&quot;name&quot; in proxy); // trueconsole.log(&quot;_sex&quot; in proxy); // falseconsole.log(&quot;toString&quot; in proxy); // true</code></pre><blockquote><p>判断对象身上是否有这个属性，如果有，再判断是否为函数，如果是，就调用下这个方法</p></blockquote><pre><code>const obj = &#123;  name: &quot;icoding&quot;,  say() &#123;    console.log(`大家好，我是$&#123;this.name&#125;`);  &#125;,&#125;;const proxy = new Proxy(obj, &#123;  has(target, prop) &#123;    if (prop === &quot;say&quot; &amp;&amp; typeof target[prop] === &quot;function&quot;) &#123;      target[prop]();    &#125;  &#125;,&#125;);&quot;say&quot; in proxy; // 大家好，我是icoding</code></pre><blockquote><p>注意事项</p><ul><li>如果目标对象的某一属性为<strong>不可配置</strong>，则该属性不能够被代理设置为隐藏(false)，只能返回<code>true</code></li></ul></blockquote><pre><code>const obj = &#123;&#125;;Object.defineProperty(obj, &quot;name&quot;, &#123;  value: &quot;icoding&quot;,  writable: false,  configurable: false, // 不可配置&#125;);const proxy = new Proxy(obj, &#123;  has(target, prop) &#123;    return true; // false是会报错，true不会  &#125;,&#125;);console.log(&quot;name&quot; in proxy);</code></pre><blockquote><ul><li>如果目标对象为<strong>不可扩展对象</strong>，则该对象的属性不能够被代理设置为隐藏(false)</li></ul></blockquote><pre><code>const obj = &#123;  a: 1,  b: 2,&#125;;Object.preventExtensions(obj); // 将对象设置为不可扩展的const proxy = new Proxy(obj, &#123;  has(target, prop) &#123;    if (prop in target) &#123;      return true; // false是会报错，true不会    &#125; else &#123;      return false;    &#125;  &#125;,&#125;);console.log(&quot;name&quot; in proxy); // falseconsole.log(&quot;toString&quot; in proxy); // trueconsole.log(&quot;a&quot; in proxy); // 抛出错误</code></pre><p>-<code>Object.preventExtensions()</code>方法让一个对象变的不可扩展，也就是永远不能再添加新的属性。</p><h4 id="handler-apply-方法"><a href="#handler-apply-方法" class="headerlink" title="handler.apply()方法"></a><code>handler.apply()</code>方法</h4><blockquote><p><code>handler.apply()</code>方法用于拦截函数的调用，<code>call</code> 和 <code>apply</code> 操作。</p><ul><li>返回值可以是任意类型，表示函数调用的返回值</li></ul></blockquote><blockquote><p>语法</p></blockquote><pre><code>var p = new Proxy(target, &#123;  apply: function (target, thisArg, args) &#123;    // ...  &#125;,&#125;);</code></pre><blockquote><p>apply函数的参数：</p></blockquote><ul><li><p>target：被代理的目标对象（函数）</p></li><li><p>thisArg：被调用时的上下文对象</p></li><li><p>args：被调用时的参数组成的数组</p></li><li><p>关于 apply 方法的参数的理解，可以看下面代码的演示</p></li></ul><pre><code>function foo() &#123;  console.log(this);&#125;const proxy = new Proxy(foo, &#123;  apply(target, thisArg, args) &#123;    console.log(target); // 被代理的目标对象(函数 foo)    console.log(thisArg); // 被调用是的上下文对象，指 undefined 或&#123;m:1,n:2&#125;    console.log(args); // 被调用时的参数数组，指[1,2,3] 或[&#39;a&#39;,&#39;b&#39;,&#39;c&#39;]  &#125;,&#125;);proxy(1, 2, 3); // foo  undefined  [1, 2, 3]proxy.call(&#123; m: 1, n: 2 &#125;, &quot;a&quot;, &quot;b&quot;, &quot;c&quot;); // foo undefined  [&#39;a&#39;, &#39;b&#39;, &#39;c&#39;]</code></pre><ul><li>代理使用的是严格模式，所以在不改变this指向的情况下，函数的<code>this</code>默认为<code>undefined</code></li></ul><blockquote><p>基本应用</p><ul><li>改变函数调用时的返回值</li></ul></blockquote><pre><code>// 函数返回的是一个数组function foo() &#123;  return [1, 4, 5, 6, 20, 3, 44];&#125;// // 代理后，返回的数组是升序排序好的const proxy = new Proxy(foo, &#123;  apply(target, thisArg, args) &#123;    const arr = target();    return arr.sort((a, b) =&gt; a - b); // 降序  &#125;,&#125;);console.log(proxy()); // [1, 3, 4, 5, 6, 20, 44]</code></pre><blockquote><ul><li>预加载图片</li></ul></blockquote><ul><li>在 <code>web</code> 开发中，图片预加载是一种常用的技术。通常我们加载一张图片的做法是：</li><li>直接给<code>img</code>标签设置<code>src</code>属性，但如果图片过大或网络不佳，图片加载到显示需要很长的一段时间，这时页面显示图片的位置就会出现很长时间的一片空白。</li><li>解决这个问题，常见的做法是，在图片没有加载成功前，先用一张 <code>loading</code> 图片占位，然后异步方式加载图片，等图片加载好了，再显示真正的图片。</li><li>上面这种情况，我们就可以通过代理来实现。</li></ul><pre><code>// 加载图片的方法function loadImg(url) &#123;  const img = new Image();  img.width = &quot;200&quot;;  img.onload = function () &#123;    document.body.appendChild(img);  &#125;;  img.src = url;  return img; // 返回img节点&#125;// 代理loadImg方法来加载图片const proxyImg = new Proxy(loadImg, &#123;  apply(target, thisArg, args) &#123;    // 调用方法，先加载loading占位图,为了演示效果，这里采用本地图片    const realImg = target(&quot;./loading-svg/loading-bars.svg&quot;);    // 创建img标签，来加载真实图片    const img = new Image();    img.src = args[0];    // 真实图片加载成功，再用真实图片替换掉占位图    img.onload = function () &#123;      realImg.src = args[0]; // 把图片的地址改变真实图片地址    &#125;;  &#125;,&#125;);const url =  &quot;https://sce7a2b9c9d95a-sb-qn.qiqiuyun.net/files/course/2022/08-29/210311f40bcf290736.jpg&quot;;proxyImg(url);</code></pre><h4 id="handler-construct-方法"><a href="#handler-construct-方法" class="headerlink" title="handler.construct()方法"></a><code>handler.construct()</code>方法</h4><blockquote><p><code>construct()</code>方法用于拦截<code>new</code>命令。</p><ul><li>其返回值必需是一个<strong>对象</strong>，否则报错</li></ul></blockquote><ul><li>语法</li></ul><pre><code>var p = new Proxy(target, &#123;  construct: function (target, argumentsList, newTarget) &#123;    // ....  &#125;,&#125;);</code></pre><blockquote><p>construct函数的<strong>参数</strong>：</p></blockquote><ul><li><p>target：被代理的目标对象(类)</p></li><li><p>argumentsList：constructor的参数组成的数组</p></li><li><p>newTarget：最初被调用的构造函数，就上面的例子而言是 p</p></li><li><p>关于 construct 方法的参数的理解，可以看下面代码的演示</p></li></ul><pre><code>class A &#123;  constructor(x, y) &#123;    this.x = x;    this.y = y;  &#125;&#125;function fn() &#123;&#125;const proxy = new Proxy(A, &#123;  construct(target, args, newTarget) &#123;    console.log(target);    console.log(args);    console.log(newTarget === proxy);    return new target(...args); // 参数记得传  &#125;,&#125;);const p = new proxy(1, 2);console.log(p);</code></pre><blockquote><p>注意事项</p></blockquote><ul><li><code>construct</code> 方法必需要返回一个对象，否则报错</li><li><code>new Proxy()</code>时，传入的<strong>目标对象本身</strong>必需能使用<code>new</code> 来操作</li></ul><h4 id="handler-deleteProperty-方法"><a href="#handler-deleteProperty-方法" class="headerlink" title="handler.deleteProperty() 方法"></a>handler.deleteProperty() 方法</h4><blockquote><p><code>handler.deleteProperty()</code>方法用于拦截对对象属性的 <code>delete</code>操作。</p><ul><li>返回值必须为一个布尔值，表示该属性是否被成功删除</li></ul></blockquote><ul><li>语法</li></ul><pre><code>var p = new Proxy(target, &#123;  deleteProperty: function (target, property) &#123;    // ....  &#125;,&#125;);</code></pre><blockquote><p>deleteProperty函数的<strong>参数</strong>：</p></blockquote><ul><li>target：被代理的目标对象</li><li>property：待删除的属性名</li></ul><blockquote><p>基本用法</p><ul><li>禁止删除指定的属性</li></ul></blockquote><pre><code>const obj = &#123;  name: &quot;清心&quot;,  age: 22,  sex: &quot;女&quot;,&#125;;const proxy = new Proxy(obj, &#123;  deleteProperty(target, prop) &#123;    if (prop === &quot;name&quot;) &#123;      return false;    &#125;    return delete target[prop];  &#125;,&#125;);console.log(delete proxy.age);console.log(obj);console.log(delete proxy.name);console.log(obj);</code></pre><blockquote><p>注意事项</p><ul><li>如果目标对象的属性为不可配置(configurable)，则不能被<code>deleteProperty</code>方法删除，否则报错。</li></ul></blockquote><pre><code>const obj = &#123;  name: &quot;清心&quot;,  age: 22,  sex: &quot;女&quot;,&#125;;Object.defineProperty(obj, &quot;say&quot;, &#123;  value: function () &#123;&#125;,  configurable: false,  writable: true,&#125;);const proxy = new Proxy(obj, &#123;  deleteProperty(target, prop) &#123;    if (prop === &quot;say&quot;) &#123;      // return false; // 正确执行      return true; // 报错，因为该属性为不可配置，无法删除    &#125;    return delete target[prop];  &#125;,&#125;);console.log(delete proxy.say);</code></pre><h4 id="handler-defineProperty-方法"><a href="#handler-defineProperty-方法" class="headerlink" title="handler.defineProperty() 方法"></a>handler.defineProperty() 方法</h4><blockquote><p><code>handler.defineProperty()</code>用于拦截对象的<code>Object.defineProperty()</code>操作，也就是给对象<strong>添加新的属性</strong>时会被拦截。</p><ul><li>返回值： 必须是一个布尔值，表示定义该属性的操作是否成功，<strong>严格模式下</strong>没有返回值或返回值为 false，则会抛出错误</li></ul></blockquote><ul><li>语法</li></ul><pre><code>var p = new Proxy(target, &#123;  defineProperty: function (target, property, descriptor) &#123;    // ....  &#125;,&#125;);</code></pre><blockquote><p>defineProperty函数的参数：</p></blockquote><ul><li><p>target: 被代理的目标对象</p></li><li><p>property：待添加的属性名</p></li><li><p>descriptor：待添加的属性的描述符对象</p></li><li><p>对于defineProperty中参数的理解，看如下代码示例</p></li></ul><pre><code>&quot;use strict&quot;;let handler = &#123;  defineProperty(target, key, descriptor) &#123;    // 被代理的目标对象 &#123;a:1&#125;    console.log(target);    // 将要被添加的属性名 foo    console.log(key);    // 将要被添加的属性的属性描述符对象    //  &#123;value: &#39;bar&#39;, writable: true, enumerable: true, configurable: true&#125;    console.log(descriptor);    // 添加属性    Object.defineProperty(target, key, descriptor);    return true; // 严格模式下，不写或为false，则会抛出错误  &#125;,&#125;;const obj = &#123; a: 1 &#125;;let proxy = new Proxy(obj, handler);proxy.foo = &quot;bar&quot;;console.log(obj); //  &#123;a: 1, foo: &#39;bar&#39;&#125;</code></pre><blockquote><p>注意事项</p><ul><li>如果目标对象不可扩展，则<code>defineProperty</code>不能增加目标对象中不存在的属性，否则会报错。</li></ul></blockquote><pre><code>//   &quot;use strict&quot;;const obj = &#123; name: &quot;icoding&quot; &#125;;Object.preventExtensions(obj);const proxy = new Proxy(obj, &#123;  defineProperty(target, prop, desc) &#123;    Object.defineProperty(target, prop, desc);  &#125;,&#125;);&gt;proxy.age = 33; // 报错</code></pre><blockquote><ul><li>如果目标对象的某个属性不可以写(writable)或不可配置(configurable)</li></ul></blockquote><ul><li>则<code>defineProperty</code>不能修改这两个设置，严格模式下会<strong>报错</strong>。</li></ul><pre><code>//   &quot;use strict&quot;;const obj = &#123;&#125;;Object.defineProperty(obj, &quot;name&quot;, &#123;  value: &quot;清心&quot;,  writable: false,  configurable: true,&#125;);const proxy = new Proxy(obj, &#123;  defineProperty(target, prop, desc) &#123;    Object.defineProperty(target, prop, desc); // 定义属性    return true;  &#125;,&#125;);proxy.name = &quot;icoding&quot;;console.log(obj); // &#123;name:&#39;清心&#39;&#125;// 以上代码，开启严格模式，则会报错</code></pre><h4 id="handler-getOwnPropertyDescriptor-方法"><a href="#handler-getOwnPropertyDescriptor-方法" class="headerlink" title="handler.getOwnPropertyDescriptor() 方法"></a>handler.getOwnPropertyDescriptor() 方法</h4><blockquote><p><code>handler.getOwnPropertyDescriptor()</code>方法用来拦截<code>Object.getOwnPropertyDescriptor()</code>方法</p><ul><li>其返回值是一个属性描述符对象或<code>undefinedy</code></li></ul></blockquote><ul><li>语法</li></ul><pre><code>var p = new Proxy(target, &#123;  getOwnPropertyDescriptor: function (target, prop) &#123;    // ....  &#125;,&#125;);</code></pre><blockquote><p><code>getOwnPropertyDescriptor</code>函数的参数：</p></blockquote><ul><li>target: 被代理的目标对象</li><li>prop：被用来返回属性描述符对象的属性名</li></ul><blockquote><p>基本用法</p><ul><li>指定属性的描述不允许被获取</li></ul></blockquote><pre><code>const obj = &#123;  name: &quot;icoding&quot;,  age: 33,&#125;;const proxy = new Proxy(obj, &#123;  getOwnPropertyDescriptor(target, prop) &#123;    if (prop === &quot;name&quot;) &#123;      return undefined;    &#125;    return Object.getOwnPropertyDescriptor(target, prop);  &#125;,&#125;);console.log(Object.getOwnPropertyDescriptor(proxy, &quot;name&quot;));console.log(Object.getOwnPropertyDescriptor(proxy, &quot;age&quot;));</code></pre><h4 id="handler-getPrototypeOf-方法"><a href="#handler-getPrototypeOf-方法" class="headerlink" title="handler.getPrototypeOf() 方法"></a>handler.getPrototypeOf() 方法</h4><blockquote><p><code>handler.getPrototypeOf()</code>用来拦截<strong>获取对象原型</strong>的操作。</p><ul><li>返回值必须为一个对象或者<code>null</code>，否则会报错。</li></ul></blockquote><ul><li>语法</li></ul><pre><code>const p = new Proxy(obj, &#123;  getPrototypeOf(target) &#123;    // ...  &#125;,&#125;);</code></pre><blockquote><p><code>getPrototypeOf()</code>方法具体拦截以下操作：</p></blockquote><ul><li><code>对象.__proto__</code></li><li><code>对象.isPrototypeOf()</code>用于测试一个对象是否存在于另一个对象的原型链上。</li><li><code>Object.getPrototypeOf(对象)</code></li><li><code>instanceof</code>操作</li></ul><pre><code>const obj = &#123;  a: 1,  b: 2,&#125;;const proxy = new Proxy(obj, &#123;  getPrototypeOf(target) &#123;    console.log(&quot;执行&quot;);    return &#123;&#125;;  &#125;,&#125;);// 以下四种方式，都需要获取对象的 __proto__ 属性值，都会被 getPrototypeOf 方法拦截Object.getPrototypeOf(proxy);proxy.__proto__;proxy instanceof Object; // proxy 的原型链上是否存在 Object.prototypeObject.prototype.isPrototypeOf(proxy); // Object.prototype 对象是否在 proxy 的原型链上</code></pre><blockquote><p>基本用法</p><ul><li>获取对象原型时，返回一个假的对象。</li></ul></blockquote><pre><code>const obj = &#123;  a: 1,  b: 2,&#125;;const __proto__ = &#123; m: 10, n: 20 &#125;;const proxy = new Proxy(obj, &#123;  getPrototypeOf(target) &#123;    return __proto__;  &#125;,&#125;);// 获取proxy原型，返回的是__proto__console.log(Object.getPrototypeOf(proxy) === __proto__);</code></pre><blockquote><p>注意事项</p><ul><li><code>getPrototypeOf()</code>方法返回的不是对象也不是<code>null</code>，则会抛出错误。</li></ul></blockquote><pre><code>const obj = &#123;&#125;;const proxy = new Proxy(obj, &#123;  getPrototypeOf(target) &#123;    return null; // 如果没有return语句，或返回值不是null或对象，则抛出错误  &#125;,&#125;);Object.getPrototypeOf(proxy);</code></pre><blockquote><ul><li>如果目标对象是不可扩展的，且<code>getPrototypeOf()</code>方法返回的原型不是目标对象本身的原型，则会抛出错误</li></ul></blockquote><pre><code>const obj = &#123;&#125;;Object.preventExtensions(obj);const proxy = new Proxy(obj, &#123;  getPrototypeOf(target) &#123;    return Object.prototype; // 除自身原型以外的返回值，都会抛出错误  &#125;,&#125;);console.log(Object.getPrototypeOf(proxy) === obj.__proto__);</code></pre><h4 id="handler-setPrototypeOf-方法"><a href="#handler-setPrototypeOf-方法" class="headerlink" title="handler.setPrototypeOf() 方法"></a>handler.setPrototypeOf() 方法</h4><blockquote><p><code>handler.setPrototypeOf()</code>方法用于拦截<code>Object.setPrototypeOf</code>方法。</p><ul><li>返回值必须是一个布尔值，表示原型修改是否成功。</li></ul></blockquote><ul><li>语法</li></ul><pre><code>var p = new Proxy(target, &#123;  setPrototypeOf: function (target, prototype) &#123;    // ...  &#125;,&#125;);</code></pre><blockquote><p><code>setPrototypeOf</code>函数的<strong>参数</strong>：</p></blockquote><ul><li>target: 被代理的目标对象</li><li>prototype：对象新原型或为null</li></ul><blockquote><p>基本用法</p><ul><li>不允许更改对象的原型</li></ul></blockquote><pre><code>const arr = [];const proxy = new Proxy(arr, &#123;  setPrototypeOf(target, prototype) &#123;    return false;    //   或    //   throw new Error(&quot;不允许修改原型&quot;);  &#125;,&#125;);&gt;Object.setPrototypeOf(proxy, Object.prototype);console.log(arr.__proto__ === Object.prototype);</code></pre><blockquote><p>注意事项</p><ul><li>如果目对象不可扩展，<code>setPrototypeOf()</code>方法不得改变目标对象的原型（也就是说 <code>setPrototypeOf</code> 的返回值必需与 <code>Object.getPrototypeOf(target)</code> 的值相同</li></ul></blockquote><pre><code>&quot;use strict&quot;;const arr = [];Object.preventExtensions(arr);const proxy = new Proxy(arr, &#123;  setPrototypeOf(target, prototype) &#123;    Object.setPrototypeOf(target, prototype);    return true;  &#125;,&#125;);//   Object.setPrototypeOf(proxy, Object.prototype); // 抛出错误Object.setPrototypeOf(proxy, Array.prototype); // 正常执行</code></pre><h4 id="handler-ownKeys-方法"><a href="#handler-ownKeys-方法" class="headerlink" title="handler.ownKeys() 方法"></a>handler.ownKeys() 方法</h4><blockquote><p><code>handler.ownKeys()</code>方法用来拦截<strong>对象自身属性的读取操作</strong>，具体拦截以下操作：</p></blockquote><ul><li><code>Object.getOwnPropertyNames()</code>获取对象自身属性（可遍历+不可遍历）</li><li><code>Object.getOwnPropertySymbols()</code>获取对象身的 <code>Symbol</code> 属性（可遍历 + 不可遍历）</li><li><code>Object.keys()</code>获取对象自身所有可遍历属性（不包括 Symbolo 类型）</li></ul><table><thead><tr><th>方法</th><th>原型</th><th>自身</th><th>自身 Symbol</th><th>可枚举</th><th>不可枚举</th></tr></thead><tbody><tr><td>Object.keys()</td><td></td><td>✔</td><td></td><td>✔</td><td></td></tr><tr><td>for…in</td><td>✔</td><td>✔</td><td></td><td>✔</td><td></td></tr><tr><td>Object.getOwnPropertyNames</td><td></td><td>✔</td><td></td><td>✔</td><td>✔</td></tr><tr><td>Object.getOwnPropertySymbols</td><td></td><td></td><td>✔</td><td>✔</td><td>✔</td></tr><tr><td>Reflect.ownKeys()</td><td></td><td>✔</td><td>✔</td><td>✔</td><td>✔</td></tr></tbody></table><blockquote><p>返回值只能是数组，其数组的成员只能是字符串类型或 <code>Symbol</code> 类型。</p></blockquote><blockquote><p>语法</p></blockquote><pre><code>var p = new Proxy(target, &#123;  ownKeys: function (target) &#123;    // ...  &#125;,&#125;);</code></pre><p>在拦截以上三种方法时，对于返回的值会有以下区别：</p><blockquote><p><strong>不同点一</strong></p><ul><li>拦截<code>Object.keys()</code>时，会过滤掉以下三类属性<ul><li>目标对象上不存在的属性</li><li>属性名为 <code>Symbol</code> 值</li><li>不可遍历的属性（enumerable 为 false）</li></ul></li><li>拦截<code>Object.getOwnPropertyNames()</code>方法，只会留下字符串类型的值（不可遍历 + 可遍历）</li><li>拦截<code>Object.getOwnPropertySymbols()</code>，只会留下 <code>Symbol</code>类型的值（不可遍历 + 可遍历）</li></ul></blockquote><blockquote><p><strong>不同点二</strong></p><ul><li>拦截<code>Object.keys()</code>方法时，其不能返回目标对象身上<strong>不存在</strong>的属性，但是<code>Object.getOwnPropertyNames()</code>和<code>Object.getOwnPropertySymbols()</code>方法是可以的。</li></ul></blockquote><blockquote><p><strong>相同点</strong></p><ul><li>只要是对象身上的不可配置属性，则必须被<code>ownKeys</code>方法返回，即使最后因为类型不符合要求被过滤</li><li>如果对象是不可扩展，则<code>ownKeys</code>方法必须返回对象自身的<strong>所有属性</strong>，即使最后因为类型不符合要求被过滤。但返回的数组中的成员<strong>不能有对象自身没有的属性</strong>，否则会报错</li></ul></blockquote><blockquote><ul><li>代理返回的数组成员是自己设置的，但不同的方法会再过滤一遍</li></ul></blockquote><ul><li>代码演示</li></ul><pre><code>const obj = &#123;  a: 1,  [Symbol.for(&quot;b&quot;)]: 2,&#125;;Object.defineProperty(obj, &quot;name&quot;, &#123;  value: &quot;icoding&quot;,  configurable: false,&#125;);const proxy = new Proxy(obj, &#123;  ownKeys(target) &#123;    // 正确写法，返回的数组中一定要包含这个值    return [&quot;a&quot;, &quot;c&quot;, &quot;name&quot;, Symbol.for(&quot;b&quot;)];    // 以下方式，则会抛出错误，因没有包含不可配置属性    //   return [&quot;a&quot;, &quot;c&quot;，Symbol.for(&quot;b&quot;)];  &#125;,&#125;);const keys = Object.getOwnPropertyNames(proxy);console.log(keys); // [&#39;a&#39;, &#39;c&#39;, &#39;name&#39;] 只留下字符串类型const keys2 = Object.getOwnPropertySymbols(proxy);console.log(keys2); // [Symbol(b)]  只留下Symbol类型的const keys3 = Object.keys(proxy);console.log(keys3); // [&#39;a&#39;]  过滤Symbol,对象自身不存在的，不可遍历的</code></pre><blockquote><p>代码演示：相同点</p><ul><li>如果代理的目标对象是不可扩展的，则 <code>ownKeys</code> 方法返回的数组中必须包含目标对象自身的所有属性（包括 <code>Symbol</code> 类型，即时最后会被过滤掉），且不能包含多余属性，否则报错。</li></ul></blockquote><pre><code>const obj = &#123;  a: 1,  [Symbol.for(&quot;b&quot;)]: 2,&#125;;Object.defineProperty(obj, &quot;name&quot;, &#123;  value: &quot;icoding&quot;,  configurable: false,&#125;);// 对象设置为不可扩展Object.preventExtensions(obj);const proxy = new Proxy(obj, &#123;  ownKeys(target) &#123;    return [&quot;a&quot;, &quot;name&quot;, Symbol.for(&quot;b&quot;)];    // 以下两种写法，都会抛出错误    // return [&quot;a&quot;, &quot;name&quot;];    //   return [&quot;a&quot;, &quot;name&quot;, Symbol.for(&quot;b&quot;), &quot;c&quot;];  &#125;,&#125;);const keys = Object.getOwnPropertyNames(proxy);console.log(keys); // [&#39;a&#39;, &#39;name&#39;]const keys2 = Object.getOwnPropertySymbols(proxy);console.log(keys2); // [Symbol(b)]const keys3 = Object.keys(proxy);console.log(keys3); // [&#39;a&#39;]</code></pre><h3 id="三、this-问题"><a href="#三、this-问题" class="headerlink" title="三、this 问题"></a>三、this 问题</h3><blockquote><p>虽然 <code>Proxy</code> 可以代理针对目标对象的访问，但它不是目标对象的<strong>透明代理</strong>，即不做任何拦截的情况下也无法保证与目标对象的行为一致。</p><ul><li>主要原因就是 <code>Proxy</code> 代理的情况下，目标对象内部的 <code>this</code> 关键字会指向 <code>Proxy</code> 代理。</li></ul></blockquote><pre><code>const obj = &#123;  name: &quot;icoding&quot;,  age: 33,  say() &#123;    console.log(this === proxy);    console.log(`大家好，我是$&#123;this.name&#125;，我今年$&#123;this.age&#125;岁了`);  &#125;,&#125;;const proxy = new Proxy(obj, &#123;&#125;);obj.say();//false proxy.say();//true</code></pre><ul><li>上面代码中，<code>proxy</code>代理了<code>obj</code>，则<code>proxy.say()</code>方法时，其内部的<code>this</code>指向<code>proxy</code>对象，而非<code>obj</code></li></ul><h4 id="this-问题，造成无法代理"><a href="#this-问题，造成无法代理" class="headerlink" title="this 问题，造成无法代理"></a>this 问题，造成无法代理</h4><blockquote><p>我们再来看一个例子，由于 <code>this</code> 指向的变化导致 <code>Proxy</code> 无法代理目标对象</p></blockquote><ul><li><code>Stack.js</code>文件</li></ul><pre><code>// 存放私有属性const privates = new WeakMap();class Stack &#123;  constructor(size) &#123;    this.size = size;    // 私有属性    privates.set(this, []);  &#125;  // 入栈  push(value) &#123;    privates.get(this).push(value);    return this;  &#125;  // 查看栈中成员  view() &#123;    console.log(privates.get(this));  &#125;&#125;// 默认导出export default Stack;</code></pre><ul><li><code>index.html</code></li></ul><pre><code>&lt;script type=&quot;module&quot;&gt;  import Stack from &quot;./Stack.js&quot;;  const stack = new Stack(10);  // 正确被执行  console.log(stack.push(1));  stack.view();  // 代理  const proxyStack = new Proxy(stack, &#123;&#125;);  console.log(proxyStack.push()); // 抛出错误，因为内部this问题，造成privates.get(this)得到的是undefined，所以无法调用push方法而报错&lt;/script&gt;</code></pre><ul><li>上面代理失败，是因为<code>WeakMap</code>中保存的是<code>stack</code>对象与数组的映射关系，而代理后，<code>this</code>不再指向<code>stack</code>，而指向<code>proxy</code>对象，此时在<code>WeakMap</code>中找不到相关的映射。</li><li>所以<code>privates.get(this)</code>返回的值为<code>undefined</code>, <code>undefined</code>打点调用<code>push</code>方法肯定就会报错。</li></ul><blockquote><p>如果我们直接代理 <code>Stack</code> 类，是可以的，因为 <code>this</code> 没有问题</p></blockquote><pre><code>&lt;script type=&quot;module&quot;&gt;  import Stack from &quot;./Stack.js&quot;;  const proxyStack = new Proxy(Stack, &#123;&#125;);  const stack = new proxyStack(10);  stack.push(1).push(2);  stack.view();  console.log(stack.size);&lt;/script&gt;</code></pre><h4 id="无法代理的原生对象"><a href="#无法代理的原生对象" class="headerlink" title="无法代理的原生对象"></a>无法代理的原生对象</h4><blockquote><p>有些原生对象的内部属性只能通过正确的 <code>this </code>才能获取，所以 <code>Proxy</code> 也无法代理这些原生对象属性。比如<code>new Date()</code>出来的对象</p><ul><li>具体演示看以下代码：</li></ul></blockquote><pre><code>const date = new Date();const handler = &#123;&#125;;const proxy = new Proxy(date, handler);proxy.getDate(); // this is not a Date</code></pre><ul><li>上面代码中，<code>getDate()</code>方法只能在 <code>Date</code> 对象的实例上获取，所以 <code>this</code> 不是 <code>Date</code> 对象实例时就会报错。</li></ul><blockquote><p>解决办法，就是让<code>getDate()</code>方法内的 <code>this</code> 永远指向 <code>Date</code> 实例。</p></blockquote><pre><code>const date = new Date();const proxy = new Proxy(date, &#123;  get(target, prop) &#123;    if (prop === &quot;getDate&quot;) &#123;      return target[prop].bind(target);    &#125;    return target[prop];  &#125;,&#125;);console.log(proxy.getDate()); // 24console.log(proxy.getMonth()); // 报错  因为this指向不是Date实例</code></pre><blockquote><p>因此，如果你创建了一个对象，不相让代理来代理这个对象，就可以把内部的<code>this</code>绑定死</p></blockquote><pre><code>cosnt obj = &#123;  say()&#123;    if(this!==obj)&#123;      throw new Error(&quot;不能被代理)；    &#125;  &#125;&#125;const p=new Proxy(obj,&#123;&#125;);p.say();//报错 不能被代理</code></pre><h3 id="四、Reflect-反射"><a href="#四、Reflect-反射" class="headerlink" title="四、Reflect 反射"></a>四、Reflect 反射</h3><blockquote><p>Reflect 对象与 Proxy 对象一样，也是 ES6 为了操作对象而提供的新的 API。</p></blockquote><blockquote><p>Reflect 是一个内置的对象，他<strong>不是一个函数对象</strong>，所以他不可以用 new 来调用。Reflect 对象所有的属性和方法都是<strong>静态</strong>的（这一点和 Math 对象一样）。</p><ul><li>Reflect 对象被设计出来，主要是解决什么问题呢 ？</li></ul></blockquote><h4 id="Reflect-对象被设计的目的"><a href="#Reflect-对象被设计的目的" class="headerlink" title="Reflect 对象被设计的目的"></a>Reflect 对象被设计的目的</h4><blockquote><p>Reflect 对象被设计出来，主要有以下四个目的：</p></blockquote><blockquote><p>将 Object 对象一些明显属于<strong>语言内部</strong>的方法，放到了 Reflect 对象上，同时未来新增加的语言内部的方法都会放在 Reflect 对象上</p></blockquote><ul><li>比如<code>Object.defineProperty</code>方法，现在 Reflect 对象上也添加了此方法。所以现阶段<code>Object</code>和<code>Reflect</code>对象上<strong>都有</strong>这个方法<blockquote><p>修改某些 <code>Object</code> 方法的<strong>返回结果</strong>，让其变得更合理。</p></blockquote></li><li>比如<code>Object.defineProperty()</code>方法，如果属性定义失败时会抛出一个错误，则<code>Reflect.defineProperty()</code>则会返回 <code>false</code></li></ul><pre><code>// 旧的写法,属性定义不成功抛出错误，所以需要用try...catch语句来捕获错误const obj = &#123;&#125;;Object.preventExtensions(obj);try &#123;  Object.defineProperty(obj, &quot;name&quot;, &#123;    value: &quot;清心&quot;,  &#125;);&#125; catch (e) &#123;  console.log(e);&#125;// 新写法，属性定义不成功，返回值为false，可以直接通过if语句来判断const obj = &#123;&#125;;Object.preventExtensions(obj);if (Reflect.defineProperty(obj, &quot;name&quot;, &#123; value: &quot;清心&quot; &#125;)) &#123;  // 成功...&#125; else &#123;  // 失败  console.log(&quot;添加失败&quot;);&#125;</code></pre><blockquote><p>让 Object 的操作变成函数行为</p></blockquote><ul><li>比如判断某个属性是否为对象的属性时，我们采用的是 <code>属性 in 对象</code>。而<code>Reflect.has()</code>方法，让他变成了函数行为。</li><li>比如我们想要删除对象的某个属性时，我们采用的是<code>delete 对象.属性</code>。而<code>Reflect.deleteProperty()</code>方 法，将它变成了函数行为。</li></ul><pre><code>// 旧写法const obj = &#123;  name: &quot;清心&quot;,  age: 33,&#125;;console.log(&quot;name&quot; in obj);console.log(delete obj.age);console.log(obj);// 新写法const obj = &#123;  name: &quot;清心&quot;,  age: 33,&#125;;// 判断 name是否是obj的属性console.log(Reflect.has(obj, &quot;name&quot;));// 删除 obj的age属性console.log(Reflect.deleteProperty(obj, &quot;age&quot;));// 打印objconsole.log(obj);</code></pre><ul><li>Reflect对象的方法与Proxy对象的方法<strong>一一对应</strong>，这使得Proxy可以代理（覆盖）目标对象的默认行为，而Reflect对象总能找到对应方法<strong>获取目标对象的默认行为</strong></li></ul><pre><code>const obj = &#123;  name: &quot;清心&quot;,  _sex: &quot;女&quot;,&#125;;const proxy = new Proxy(obj, &#123;  set(target, prop, value) &#123;    if (prop[0] === &quot;_&quot;) &#123;      return false;    &#125;    Reflect.set(target, prop, value);    // 上面代码等价于  target[prop] = value;    return true;  &#125;,&#125;);proxy.name = &quot;icoding&quot;;proxy._sex = &quot;男&quot;;console.log(obj);</code></pre><h4 id="Reflect-对象的静态方法"><a href="#Reflect-对象的静态方法" class="headerlink" title="Reflect 对象的静态方法"></a>Reflect 对象的静态方法</h4><blockquote><p>Reflect 对象一共有 13 个静态方法，这些方法与 Proxy 对象的方法一一对象</p></blockquote><table><thead><tr><th>静态方法</th><th>描述</th></tr></thead><tbody><tr><td><code>Reflect.get(obj,name,receiver)</code></td><td>返回<code>obj</code>对象的<code>name</code>属性，如果没有该属性返回<code>undefined</code></td></tr><tr><td><code>Reflect.set(obj,name,value,receiver)</code></td><td>设置<code>obj</code>对象的<code>name</code>属性值等于<code>value</code></td></tr><tr><td><code>Reflect.defineProperty(obj,prop,desc)</code></td><td>为对象 <code>obj</code> 添加属性，相当于<code>Object.defineProperty(obj,prop,desc)</code></td></tr><tr><td><code>Reflect.has(obj,name)</code></td><td>判断<code>name</code>是不是<code>obj</code>对象的属性，相当于<code>name in obj</code></td></tr><tr><td><code>Reflect.apply(fn,thisArg,args)</code></td><td>相当于函数调用 <code>apply</code>方法，即<code>fn.apply(thisArg,args)</code></td></tr><tr><td><code>Reflect.construct(obj,args)</code></td><td>等同于<code>new target(...args)</code>创建类的实例</td></tr><tr><td><code>Reflect.deleteProperty(obj,name)</code></td><td>删除<code>obj</code>对象的<code>name</code>属性，等同于<code>delete obj.name</code></td></tr><tr><td><code>Reflect.getPrototypeOf(obj)</code></td><td>获取对象的原型，相当于<code>Object.getPrototypeOf(obj)</code></td></tr><tr><td><code>Reflect.setPrototypeOf(obj,newProto)</code></td><td>设置对象的原型,相当于<code>Object.setPrototypeOf(obj,newProto)</code></td></tr><tr><td><code>Reflet.getOwnPropertyDescriptor(obj,key)</code></td><td>获取对象属性的属性描述符对象，相当于<code>Object.getOwnPropertyDescriptor()</code>方法</td></tr><tr><td><code>Reflect.ownKeys(target)</code></td><td>返回对象的<strong>自身</strong>所有属性(可遍历+不可遍历+<code>Symbol</code>)，等同于<code>Object.getOwnPropertyNames</code>与<code>Object.getOwnPropertySymbols</code>之和，不能获取原型上的</td></tr></tbody></table><ul><li>基本使用</li></ul><pre><code>&lt;script&gt;  &quot;use strict&quot;;  const obj = &#123;    name: &quot;icoding&quot;,    age: 33,    _sex: &quot;女&quot;,    [Symbol()]: &quot;symbol值&quot;,    say() &#123;      console.log(`大家好，我是$&#123;this.name&#125;今年$&#123;this.age&#125;岁了`);    &#125;,  &#125;;  const proxy = new Proxy(obj, &#123;    get(target, prop) &#123;      if (prop[0] === &quot;_&quot;) &#123;        throw new Error(&quot;私有属性，不能获取&quot;);      &#125;      return Reflect.get(target, prop);    &#125;,    set(target, prop, value) &#123;      if (prop[0] === &quot;_&quot;) &#123;        throw new Error(&quot;私有属性，不能重新被赋值&quot;);      &#125;      return Reflect.set(target, prop, value);    &#125;,    deleteProperty(target, prop) &#123;      if (prop[0] === &quot;_&quot;) &#123;        return false; // 严格模式下，抛出错误      &#125;      return Reflect.deleteProperty(target, prop);    &#125;,    has(target, prop) &#123;      if (prop[0] === &quot;_&quot;) &#123;        return false;      &#125;      return Reflect.has(target, prop);    &#125;,    defineProperty(target, prop, desc) &#123;      // ....      return Reflect.defineProperty(target, prop, desc);    &#125;,    getPrototypeOf(target) &#123;      // ....      return Reflect.getPrototypeOf(target);    &#125;,    setPrototypeOf(target, proto) &#123;      // ....      return Reflect.setPrototypeOf(target, &#123; a: 1 &#125;);    &#125;,    ownKeys(target) &#123;      // ....      return Reflect.ownKeys(target);    &#125;,  &#125;);  try &#123;    console.log(proxy._sex);  &#125; catch (e) &#123;    console.log(e);  &#125;  console.log(proxy.name);  //   proxy._sex = &quot;男&quot;;  proxy.age = 18;  console.log(proxy.age);  delete proxy.age;  console.log(proxy);  try &#123;    delete proxy._sex;  &#125; catch (e) &#123;    console.log(e);  &#125;  console.log(&quot;c&quot; in proxy); // false  console.log(&quot;_sex&quot; in proxy); // false  console.log(&quot;name&quot; in proxy); // true  const bool = Reflect.defineProperty(obj, &quot;money&quot;, &#123;    value: 1000,    writable: false,  &#125;);  const bool2 = Object.defineProperty(obj, &quot;weight&quot;, &#123;    value: &quot;1.6cm&quot;,    writable: false,  &#125;);  console.log(bool);  console.log(obj);  console.log(Object.keys(obj));  console.log(Object.getOwnPropertySymbols(obj));  console.log(Reflect.ownKeys(obj));&lt;/script&gt;</code></pre><ul><li>Reflect 和 Object 上都存在的方法，建议以后使用 Reflect 身上的方法，因为 Object 身上的相关方法会慢慢被 Reflect 替换掉</li></ul><h4 id="注意事项-1"><a href="#注意事项-1" class="headerlink" title="注意事项"></a>注意事项</h4><blockquote><p>关于 <code>Reflect</code> 对象的静态方法，有以下几个需要注意的点</p></blockquote><blockquote><p>如果对象的属性是一个访问器属性，具有 <code>get</code> 方法</p></blockquote><ul><li>则 <code>get</code> 方法内部的 <code>this</code> 指向<code>Reflect.get(target,name,receiver)</code>方法中的 <code>receiver</code> 参数。</li></ul><pre><code>const obj = &#123;  a: 1,  b: 2,  get foo() &#123;    console.log(this.a);    console.log(this.b);  &#125;,&#125;;const proxy = new Proxy(obj, &#123;  get(target, prop, receiver) &#123;    //   return Reflect.get(target, prop, receiver);  // receiver默认为proxy    return Reflect.get(target, prop, &#123; a: 10, b: 20 &#125;);  &#125;,&#125;);proxy.foo;</code></pre><blockquote><p>如果对象的属性是一个访问器属性，具有 <code>set</code> 方法</p></blockquote><ul><li>则 <code>set</code> 方法内部的 <code>this</code> 指向<code>Reflect.set(target,name,value,receiver)</code>方法中的 <code>receiver</code> 参数。</li></ul><pre><code>const obj = &#123;  a: 1,  b: 2,  set foo(value) &#123;    console.log(this.a);    console.log(this.b);  &#125;,&#125;;&gt;const proxy = new Proxy(obj, &#123;  set(target, prop, value, receiver) &#123;    //   return Reflect.set(target, prop, value, receiver);    return Reflect.set(target, prop, value, &#123; a: 10, b: 20 &#125;);  &#125;,&#125;);&gt;proxy.foo = &quot;hello&quot;;</code></pre>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JS核心知识点（二十三）</title>
      <link href="/2023/12/12/JS%E6%A0%B8%E5%BF%83%E7%9F%A5%E8%AF%86%E7%82%B9%EF%BC%88%E4%BA%8C%E5%8D%81%E4%B8%89%EF%BC%89/"/>
      <url>/2023/12/12/JS%E6%A0%B8%E5%BF%83%E7%9F%A5%E8%AF%86%E7%82%B9%EF%BC%88%E4%BA%8C%E5%8D%81%E4%B8%89%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<span id="more"></span><h2 id="Generator-函数的实践与实践应用"><a href="#Generator-函数的实践与实践应用" class="headerlink" title="Generator 函数的实践与实践应用"></a>Generator 函数的实践与实践应用</h2><h3 id="一、Generator函数基础语法"><a href="#一、Generator函数基础语法" class="headerlink" title="一、Generator函数基础语法"></a>一、<code>Generator</code>函数基础语法</h3><blockquote><p><code>Generator</code>函数是<code>ES6</code>提供的一种<strong>异步编程解决方案</strong>，在学习他的异步应用之前，我们先来学习他的基本语法。<br><code>Generator</code>函数可以理解为是一个遍历器（迭代器）对象的生成函数。</p><ul><li>即：调用<code>Generator</code>可以生成一个遍历器对象。</li></ul></blockquote><ol><li>Generator 函数写法<blockquote><p>与普通函数相比，<code>Generator</code>函数的写法有如下两个特征：</p><ul><li>function 命令与函数名之间有一个 <code>*</code>星号</li><li>函数体内部可以使用<code>yield</code>语句定义不同的状态。（yield的英文意思是“产出”）</li></ul></blockquote></li></ol><pre><code>// 定义一个Generator函数function* gen() &#123;    yield 1;    yield 2;    yield 3;&#125;&gt;// 普通函数内部，不能使用 yield语句，使用会报错function gen() &#123;    yield 1; // 报错&#125;</code></pre><blockquote><p>ES6 中并没有规定function关键字与函数名之间的<code>*</code>星号应该写在哪个位置，因此以下写法都是可行的</p></blockquote><pre><code>function* gen() &#123;&#125; // 一般会选择这种写法function * gen() &#123;&#125;function *gen() &#123;&#125;// 由于Generator函数仍是普通的函数，所以一般会用第1种写法，星号紧跟在function关键字后面</code></pre><ol start="2"><li>Generator 函数的基本用法<blockquote><p><code>Generator</code>函数可以理解为是一个遍历器（迭代器）对象的生成函数。</p><ul><li>即：调用<code>Generator</code>可以生成一个遍历器对象。</li></ul></blockquote></li></ol><pre><code>// 定义Generator函数function* gen() &#123;  yield 1;  yield 2;  yield 3;&#125;&gt;// 调用gen()函数，会返回一个遍历器对象const iterator = gen();// 调用遍历器的next方法，手动迭代下一个元素console.log(iterator.next()); // &#123;value: 1, done: false&#125;console.log(iterator.next()); // &#123;value: 2, done: false&#125;console.log(iterator.next()); // &#123;value: 3, done: false&#125;console.log(iterator.next()); // &#123;value: undefined, done: true&#125;</code></pre><blockquote><blockquote><p>注：</p></blockquote><ul><li>上面定义的<code>gen</code>函数就是一个<code>Generator</code>函数，其内部用到了<code>yield</code>语句来维持 3 个状态。<code>yield</code>语句<strong>后面的值</strong>就是gen函数生成的遍历器对象的<code>next()</code>方法返回的对象的<code>value</code>属性值。</li><li>因为<code>Generator</code>函数的返回值是一个遍历器对象，所以我们可以用<code>for...of</code>来遍历这个对象</li></ul></blockquote><pre><code>// 定义Generator函数function* gen() &#123;  yield 1;  yield 2;  yield 3;&#125;&gt;// 调用gen()函数，会返回一个遍历器对象const iterator = gen();// for...of循环遍历遍历器对象for (let v of iterator) &#123;  console.log(v);&#125;// for..of循遍历结果： 1 2 3</code></pre><blockquote><ul><li>直到<code>next</code>方法返回值对象的<code>done</code>属性值为<code>true</code>时，才停止遍历</li></ul></blockquote><ul><li>调用<code>Generator</code>函数，并不会执行函数体中的任何代码，只是返回一个遍历器对象。<blockquote><ul><li>只有调用遍历器对象的<code>next()</code>方法后，才会开始执行函数体内的代码。</li></ul></blockquote></li></ul><pre><code>function* gen() &#123;  console.log(&quot;第一次调用next&quot;);  yield 1;  console.log(&quot;第2次调用next&quot;);  yield 2;  yield 3;&#125;const it = gen(); // gen()函数体中的代码并不会执行it.next(); // 第一次调用nextit.next(); // 第2次调用next</code></pre><blockquote><ul><li>上面代码执行到<code>it=gen()</code>时，并不会执行 <code>gen</code> 函数体中的代码，只是生成了一个遍历器对象，所以并不会在控制台输出 “第一次调用 next” 语句。</li><li>当执行<code>it.next()</code>，开始执行执行<code>gen</code>函数体中的代码,并在控制台输出 “第一次调用 next”。但并不会输出 “第 2 次调用 next”，只有当执行到<code>it.next()</code>时才会在控制台输出 “第 2 次调用 next”。</li></ul></blockquote><ol start="3"><li>yield 表达式<blockquote><ul><li><code>yield</code>语句相当于一个<strong>暂停标志</strong></li><li>当调用 <code>Generator</code> 函数时并不会执行函数体中的代码，而是生成一个遍历器对象。<strong>只有调用遍历器对象的next方法时，才会开始执行函数体中的代码</strong>。</li></ul></blockquote></li></ol><blockquote><p>遍历器对象的<code>next</code>方法<strong>运行逻辑</strong>如下：</p><ul><li>第一次调用<code>next</code>方法，开始执行函数体中的代码，执行遇到<code>yield</code>语句会<strong>暂停执行</strong>后面操作。并将紧跟在<code>yield</code>语句后面的表达式的值作为<code>next</code>方法返回对象的<code>value</code>属性值,<code>done</code>属性值为<code>false</code>。</li><li>再次调用<code>next</code>方法，会恢复执行，从上一次结束位置开始向下执行，如果遇到下一条 <code>yield</code> 语句，则重复上面的操作。如果没有再遇到新的<code>yield</code>语句，会一直运行到函数结束，直到遇到<code>return</code>语句为止。并将<code>return</code>后面表达式的值作为<code>next</code>返回对象的<code>value</code>属性值，<code>done</code>属性值为<code>true</code>。</li><li>如果该函数没有<code>return</code>语句，则返回对象的<code>value</code>属性为<code>undefined</code>，<code>done</code> 属性值为<code>true</code><blockquote><p>注意：在<code>for...of</code>循环时，<code>return</code>后面的表达式不会被遍历出来，因为此时<code>done</code>已经为<code>true</code>了；</p></blockquote></li></ul></blockquote><pre><code>function* gen() &#123;  console.log(&quot;第一次调用next&quot;);  yield 1;  console.log(&quot;第2次调用next&quot;);  yield 2;  console.log(&quot;第3次调用next&quot;);  return 3;&#125;const it = gen(); // gen()函数体中的代码并不会执行console.log(it.next()); // 第1次调用next &#123;value: 1, done: false&#125;console.log(it.next()); // 第2次调用next &#123;value: 2, done: false&#125;console.log(it.next()); // 第3次调用next &#123;value: 3, done: true&#125;console.log(it.next()); // &#123;value: undefined, done: true&#125;</code></pre><pre><code>function* gen() &#123;  console.log(&quot;第一次调用next&quot;);  yield 1;  console.log(&quot;第2次调用next&quot;);  yield 2;  console.log(&quot;第3次调用next&quot;);&#125;const it = gen(); // gen()函数体中的代码并不会执行console.log(it.next()); // 第1次调用next &#123;value: 1, done: false&#125;console.log(it.next()); // 第2次调用next &#123;value: 2, done: false&#125;console.log(it.next()); // 第3次调用next &#123;value: undefined, done: true&#125;</code></pre><blockquote><blockquote><p>注意：<code>yield</code>语句后面的表达式，只有当代码执行到当前这个<code>yield</code>语句时，后面的表达式才会求值。</p></blockquote></blockquote><ol start="4"><li>区分 <code>yield</code> 与 <code>return</code><blockquote><ul><li><code>yield</code>相当于是一个<strong>暂停</strong>标志，一个 <code>Generator</code> 函数中可以有多个<code>yield</code>语句。每次执行遇到 <code>yield</code> 语句，就会暂停执行，将<code>yield</code>后面表达式的值为返回对象的<code>value</code>属性值，<code>done</code>属性值为<code>false</code>。只能再次调用 <code>next</code> 方法，才会继续向下执行。</li><li><code>return</code> 相当于<strong>终止</strong>遍历器，当代码执行到<code>return</code>语句后，其后所有的代码都不会执行了。<code>return</code>后面表达式的值为返回对象的<code>value</code>属性值，<code>done</code>属性值为<code>true</code>表示遍历器迭代完成（终止）<blockquote><p><code>for...of</code> 遍历时，并不会遍历 <code>return</code> 语句后面的值</p></blockquote></li></ul></blockquote></li></ol><pre><code>function* gen() &#123;  yield 1;  yield 2;  return 3; // for...of 循环不会遍历到该值&#125;&gt;const it = gen();console.log(it.next()); //&#123;value: 1, done: false&#125;console.log(it.next()); //&#123;value: 2, done: false&#125;console.log(it.next()); //&#123;value: 3, done: true&#125;console.log(it.next()); //&#123;value: undefined, done: false&#125;&gt;for (let v of gen()) &#123;  console.log(v); // 1 2&#125;</code></pre><ol start="5"><li>yield 注意事项</li></ol><ul><li><code>yield</code>只能直接在<code>Generator</code>函数里面用，在<code>Generator</code>函数体中的普通函数中用也会报错</li></ul><pre><code>// 普通函数中使用抛出错误function fn()&#123;    yield 1 ; // 抛错&#125;&gt;// Generator函数内的普通函数中用，抛出错误function* gen()&#123;    function fn()&#123;        yield 3;    &#125;&#125;&gt;// Generator函数内的普通函数中用，抛出错误function* gen()&#123;    [1,2,3].forEach((v)=&gt;&#123;        yield v    &#125;)&#125;</code></pre><ul><li>yield 可以只作为暂停标志，后面啥也不写</li></ul><pre><code>function* gen() &#123;  yield;  yield 2;&#125;const it = gen();console.log(it.next());//&#123;value: undefined, done: false&#125;console.log(it.next());//&#123;value: 2, done: false&#125;console.log(it.next());&#123;value: undefined, done: true&#125;</code></pre><ul><li>yield 表达式如果在另一个表达式之中，必须放在圆括号里面</li></ul><pre><code>// 错误写法function* gen() &#123;    let str = &quot;hello&quot; + yield 3; // 抛错    console.log(&quot;hello&quot; + yield 5); // 抛错&#125;&gt;// 正确写法function* gen() &#123;    let str = &quot;hello&quot; + (yield 3);    console.log(&quot;hello&quot; + (yield 5));&#125;</code></pre><ul><li><code>yield</code>表达式用作<strong>函数参数</strong>或放在<strong>赋值表达式的右边</strong>，可以不用加括号</li></ul><pre><code>function* gen() &#123;  function Foo(foo) &#123;    console.log(&quot;执行完参数中两个yield语句，才执行我&quot;);  &#125;  Foo(yield &quot;a&quot;, yield &quot;b&quot;);  let num = yield 4 + (yield 5);&#125;const it = gen(); // 遍历器对象console.log(it.next()); // &#123;value: &#39;a&#39;, done: false&#125;console.log(it.next()); // &#123;value: &#39;b&#39;, done: false&#125;console.log(it.next()); // 执行完参数中两个yield语句，才执行我  &#123;value: 5, done: false&#125;console.log(it.next()); // &#123;value: NaN, done: false&#125;console.log(it.next()); // &#123;value: undefined, done: true&#125;</code></pre><blockquote><ul><li>第一步，计算<code>Foo</code>函数中的<code>yield &quot;a&quot;</code>，返回对象的<code>value</code>值为<code>a</code></li><li>第二步，计算<code>Foo</code>函数中的<code>yield &quot;b&quot;</code>，返回对象的<code>value</code>值为<code>b</code></li><li>第三步，执行函数<code>Foo</code>，打印语句；计算<code>(yield 5)</code>，返回对象的<code>value</code>值为<code>5</code>；但<code>yield 5</code>本身是没有返回值的，所以它等于<code>undefined</code></li><li>第四步，计算<code>yield 4+undefined</code>，所以<code>yield=NaN</code>，返回对象的<code>value</code>值为<code>NaN</code><blockquote><p>注意：</p></blockquote></li><li>先计算参数，再执行函数</li><li>紧挨着赋值表达式的右边才不用括号，而且括号会提升优先级；原本是从左往右执行，如果有括号，就先执行括号里面的内容</li><li><code>yield</code><strong>后面表达式的值</strong>为返回对象的<code>value</code>属性值，当括号里的值计算完了，会成为它前面<code>yield</code>的表达式的一部分</li></ul></blockquote><ol start="6"><li>next 方法的参数<blockquote><p><code>yield</code>语句本身没有返回值，或者说总是返回<code>undefined</code></p><ul><li><code>next</code>方法可以带一个参数，该参数会被当作<strong>上一条</strong><code>yield</code>语句的返回值。</li></ul></blockquote></li></ol><pre><code>function* gen() &#123;  let a = yield 1; // yield语句默认没有返回值，或理解为返回值为undefined  console.log(a);  let b = a + 2; // NaN + 2  console.log(b);&#125;const it = gen();it.next();it.next(); // undefined NaN</code></pre><pre><code>function* gen() &#123;  let a = yield 1;  console.log(a);  let b = a + 2; // NaN + 2  console.log(b);&#125;const it = gen();it.next();it.next(10); // 10 12// 相当于给函数体中的 a=10，则b=a+2=12</code></pre><blockquote><blockquote><p>注：</p></blockquote><ul><li>首次调用 <code>next</code> 方法，传不传参数本质上是没有什么区别的，因为其参数表示上一条<code>yield</code>语句的返回值，首次调用时没有上一条<code>yield</code>语句。</li><li>即使传参，JS 引擎也会忽略此次传参。</li></ul></blockquote><ol start="7"><li>带参的 next 方法应用<blockquote><p><code>next</code>方法可以带一个参数，并且这个参数用来表示上一条<code>yield</code>语句的返回值，所以我们可以利用这个特点向 <code>Generator</code>函数体的变量注入值。</p><ul><li>其中最典型的应用，就是用来处理异步交互</li></ul></blockquote></li></ol><pre><code>function* main() &#123;  let result = yield request(&quot;http://www.xxx.com&quot;);  result = JSON.parse(result); // 将返回的字符串解析成对象  for (let key in result) &#123;    console.log(result[key]);  &#125;&#125;// 模拟ajax发送数据function request(url) &#123;  // 发送ajax请求,5秒后拿到返回的数据  setTimeout(function () &#123;    let result = &#39;&#123; &quot;name&quot;: &quot;清心&quot;, &quot;age&quot;: 33 &#125;&#39;;    it.next(result); // 执行下一次迭代  &#125;, 5000);&#125;&gt;const it = main();it.next(); // 清心  33</code></pre><ol start="8"><li><code>yield*</code> 表达式<blockquote><p><code>yield*</code> 表达式用于在一个<code>Generator</code>函数中执行另一个 <code>Generator</code>函数。</p><ul><li>因为直接在一个 <code>Generator</code> 函数中调用另一个 <code>Generator</code> 函数默认情况下是没有效果的。</li></ul></blockquote></li></ol><ul><li>直接调用</li></ul><pre><code>function* foo() &#123;  yield 1;  // 直接调用Generator函数 无任何效果  bar();  yield 5;&#125;function* bar() &#123;  yield 2;  yield 3;&#125;const it = foo();for (let v of it) &#123;  console.log(v); // 1 5&#125;</code></pre><blockquote><ul><li>在 foo 函数中调用了另一个 Generator 函数 bar，相当于没有调用一样，直接被忽略。 所以最后结果为 1 5</li></ul></blockquote><ul><li>用<code>yield</code>调用</li></ul><pre><code>function* foo() &#123;  yield 1;  // 在yield后面调用Generator函数，相当于next的返回对象的value值是一个迭代器对象  yield bar();  yield 5;&#125;function* bar() &#123;  yield 2;  yield 3;&#125;const it = foo();console.log(it.next()); // &#123;value: 1, done: false&#125;console.log(it.next()); // &#123;value: bar, done: false&#125;console.log(it.next()); // &#123;value: 5, done: false&#125;console.log(it.next()); // &#123;value: undefined, done: true&#125;&gt;for (let v of foo()) &#123;  console.log(v); // 1 bar&#123;&#125;  5&#125;</code></pre><blockquote><p>在<code>yield</code>后面调用<code>Generator</code>函数，相当于<code>next</code>方法返回的对象中的<code>value</code>的属性值是一个<strong>迭代器对象</strong></p></blockquote><ul><li>用<code>yield*</code>调用</li></ul><pre><code>function* foo() &#123;  yield 1;  yield* bar();  yield 5;&#125;function* bar() &#123;  yield 2;  yield 3;&#125;const it = foo();// 其内部迭代过程console.log(it.next()); // &#123;value: 1, done: false&#125;console.log(it.next()); // &#123;value: 2, done: false&#125;console.log(it.next()); // &#123;value: 3, done: false&#125;console.log(it.next()); // &#123;value: 5, done: false&#125;console.log(it.next()); // &#123;value: undefined, done: true&#125;&gt;for (let v of foo()) &#123;  console.log(v); // 1 2 3  5&#125;</code></pre><blockquote><ul><li>利用<code>yield*</code>表达式在一个<code>Generator</code>函数中调用另一个<code>Genrator</code>函数。相当于使用一个遍历器遍历<strong>多个</strong> <code>Generator</code>函数，有<strong>递归</strong>的效果。<blockquote><p>上面代码中的 foo 函数，相当于下面两种写法</p></blockquote></li></ul></blockquote><pre><code>// 写法1function* foo() &#123;  yield 1;  yield 2;  yield 3;  yield 5;&#125;// 写法2function* foo() &#123;  yield 1;  for (let v of bar()) &#123;    yield v;  &#125;  yield 5;&#125;</code></pre><ul><li><code>yield*</code>表达式后面通常跟一个迭代器对象或可迭代对象。</li></ul><pre><code>function* gen() &#123;  yield &quot;hello&quot;;  yield* &quot;hello&quot;;  yield [1, 2, 3];  yield* [1, 2, 3];&#125;for (let v of gen()) &#123;  console.log(v);//hello h e l l ...&#125;//function* gen() &#123;  yield &quot;hello&quot;;  // yield* &quot;hello&quot;;相当于：  yield &quot;h&quot;;  yield &quot;e&quot;;  yield &quot;l&quot;;  yield &quot;l&quot;;  yield &quot;o&quot;;&#125;const it = gen();console.log(it.next()); //&#123;value: &#39;hello&#39;, done: false&#125;console.log(it.next()); //&#123;value: &#39;h&#39;, done: false&#125;</code></pre><ol start="9"><li>遍历器的 throw 方法<blockquote><p><code>Generator</code>函数返回的遍历器对象有一个<code>throw</code>方法，可以在函数体外抛出错误，并在函数体内被<code>try...catch</code>捕获。</p><ul><li>使用遍历对象的<code>throw</code>方法，在<code>Generator</code>函数体外抛出错误时，会有以下三种处理情况</li></ul></blockquote></li></ol><table><thead><tr><th>三种不同情况</th><th>描述</th><th>遍历器状态</th></tr></thead><tbody><tr><td>第一种情况</td><td>Generator 函数体内和外都没有用try…catch捕获该错误，则报错后，遍历器终止</td><td>终止</td></tr><tr><td>第二种情况</td><td>Generator 函数体内没有捕获该错误，被函数体外用try…catch捕获了该错误，则会终止遍历器</td><td>终止</td></tr><tr><td>第三种情况</td><td>Generator 函数体内有捕获到该错误，则外部的try…catch就没有办法捕获该错误，同时捕获错误后会自动执行一次next。</td><td>不影响</td></tr></tbody></table><ul><li>第一种情况<blockquote><ul><li><code>Generator</code> 函数<strong>体内和体外</strong>都没有用 <code>try...catch</code> 捕获该错误</li></ul></blockquote></li></ul><pre><code>function* gen() &#123;  yield 1;  yield 2;  yield 3;  yield 4;  yield 5;&#125;&gt;const it = gen();console.log(it.next());//&#123;value:1,done:false&#125;it.throw(&quot;a&quot;); // 往后代码都不执行了console.log(it.next());</code></pre><ul><li>第二种情况<blockquote><ul><li><code>Generator</code> 函数<strong>体内</strong>没有捕获该错误，在函数<strong>体外</strong>用<code>try...catch</code>捕获了该错误，则<code>throw</code>语句后，遍历器终止</li></ul></blockquote></li></ul><pre><code>function* gen() &#123;  yield 1;  yield 2;  yield 3;  yield 4;  yield 5;&#125;&gt;const it = gen();console.log(it.next());//&#123;value:1,done:false&#125;try &#123;  it.throw(&quot;a&quot;);&#125; catch (e) &#123;  console.log(&quot;错误&quot;, e);//错误 a&#125;console.log(it.next());//&#123;value:undefined,done:true&#125;</code></pre><ul><li>第三种情况<blockquote><ul><li><code>Generator</code> 函数<strong>体内</strong>有捕获该错误，则<strong>外部</strong>的<code>try...catch</code>就没有办法捕获该错误。</li><li>同时不会影响遍历器的下一次遍历。内部捕获了该错误后<strong>会自动执行下一次</strong> <code>next</code> 方法，所以<code>it.throw()</code>返回值为下一次<code>it.next()</code>的返回值</li></ul></blockquote></li></ul><pre><code>function* gen() &#123;  yield 1;  try &#123;    yield 2;  &#125; catch (e) &#123;    console.log(&quot;内部&quot;, e);  &#125;  yield 3;  yield 4;  yield 5;&#125;&gt;const it = gen();console.log(it.next()); // &#123;value: 1, done: false&#125;console.log(it.next()); // &#123;value: 2, done: false&#125;try &#123;  // 注意，throw的结果为 内部 a  &#123;value: 3, done: false&#125;  console.log(it.throw(&quot;a&quot;));&#125; catch (e) &#123;  console.log(&quot;错误&quot;, e);&#125;console.log(it.next()); // &#123;value: 4, done: false&#125;console.log(it.next()); // &#123;value: 5, done: false&#125;console.log(it.next()); // &#123;value: undefined, done: true&#125;</code></pre><blockquote><ul><li>上面的<code>it.thorw(&#39;a&#39;)</code>错误被<code>Generator</code>函数内部捕获，捕获后会<strong>自动执行一次</strong><code>next</code>方法，所以打印<code>it.throw()</code>的返回值为<code>&#123;value: 3, done: false&#125;</code>。</li><li>因为错误被<code>Generator</code>函数内部捕获，所以外部的<code>try...catch</code>句不会再捕获到错误，同时也<strong>不会影响</strong>遍历器的下一次遍历</li><li>注意：错误是在<code>yield 2</code>之后抛出的，<code>try...</code>里面要写<code>yield 2</code></li></ul></blockquote><blockquote><ul><li>我们再来分析下面这段代码</li></ul></blockquote><pre><code>function* gen() &#123;  yield 1;  try &#123;    yield 2;  &#125; catch (e) &#123;    console.log(&quot;内部&quot;, e);  &#125;  yield 3;  yield 4;  yield 5;&#125;&gt;const it = gen();console.log(it.next()); // &#123;value: 1, done: false&#125;console.log(it.next()); // &#123;value: 2, done: false&#125;try &#123;  // 注意，throw的结果为  内部 a   &#123;value: 3, done: false&#125;  console.log(it.throw(&quot;a&quot;));  console.log(it.throw(&quot;b&quot;)); // 错误 b&#125; catch (e) &#123;  console.log(&quot;错误&quot;, e);&#125;console.log(it.next()); // &#123;value: undefined, done: true&#125;console.log(it.next()); // &#123;value: undefined, done: true&#125;console.log(it.next()); // &#123;value: undefined, done: true&#125;</code></pre><blockquote><ul><li>上面的第一个错误<code>it.throw(&#39;a&#39;)</code>被<code>Generator</code>函数内部捕获，由于<code>Generator</code>函数内部的<code>try...catch</code>语句已经执行了，所以<strong>第二个错误</strong><code>it.throw(&#39;b&#39;)</code>被外部的<code>try...catch</code>语句捕获。错误被外部捕获，则遍历器终止。</li></ul></blockquote><blockquote><blockquote><p>总结：</p></blockquote><ul><li>遍历器调用<code>throw</code>方法抛出的错误如果没有捕获处理，其后代码就没办法执行。</li><li>遍历器调用<code>throw</code>方法抛出的错误如果<strong>没有</strong>在 <code>Generator </code>函数<strong>内部</strong>捕获处理，就会造成遍历器终止。</li><li>遍历器调用<code>throw</code>方法抛出的错误如果在<code>Generator</code>函数<strong>内部捕获</strong>处理，其处理后，还会<strong>自动执行</strong><code>next</code>方法</li></ul></blockquote><ol start="10"><li>遍历器的 <code>throw</code> 方法和全局 <code>throw</code> 命令<blockquote><ul><li><strong>全局</strong> <code>throw</code> 命令在 <code>Generator</code> <strong>体外</strong>抛出错误，并不能被 <code>Generator</code> 函数内部捕获，只能被外部的<code>try..catch</code>捕获</li></ul></blockquote></li></ol><ul><li><strong>全局</strong><code>throw</code>命令在<code>Generator</code><strong>体外</strong>抛出错误，内部捕获不到该错误，如果在外部捕获，则不影响遍历器的运行</li></ul><pre><code>function* gen() &#123;  yield 1;  try &#123;    yield 2;  &#125; catch (e) &#123;    console.log(&quot;内部&quot;, e);  &#125;&gt;  yield 3;  yield 4;  yield 5;&#125;&gt;const it = gen();console.log(it.next()); // &#123;value: 1, done: false&#125;console.log(it.next()); // &#123;value: 2, done: false&#125;try &#123;  throw new Error(&quot;全局throw抛错&quot;);&#125; catch (e) &#123;  console.log(e); // Error: 全局throw抛错&#125;&gt;console.log(it.next()); // &#123;value: 3, done: false&#125;console.log(it.next()); // &#123;value: 4, done: false&#125;</code></pre><ul><li><strong>全局</strong><code>throw</code>命令在 <code>Generator</code><strong>体内</strong>抛出错误，内部<strong>没有捕获</strong>该错误，在外部捕获，则遍历器终止</li></ul><pre><code>function* gen() &#123;  yield 1;  throw new Error(&quot;全局throw抛错&quot;);  yield 2;  yield 3;  yield 4;  yield 5;&#125;&gt;const it = gen();console.log(it.next()); // &#123;value: 1, done: false&#125;try &#123;  console.log(it.next());&#125; catch (e) &#123;  console.log(e); // Error: 全局throw抛错&#125;&gt;console.log(it.next()); // &#123;value: undefined, done: true&#125;console.log(it.next()); // &#123;value: undefined, done: true&#125;</code></pre><blockquote><ul><li>抛错后，遍历器终止，<code>yield 2</code>及以后的代码都不会执行</li></ul></blockquote><ul><li><strong>全局</strong><code>throw</code>命令在<code>Generator</code><strong>体内</strong>抛出错误，内部<strong>有捕获</strong>该错误，则不影响遍历器的下一次遍历</li></ul><pre><code>function* gen() &#123;  yield 1;  try &#123;    throw new Error(&quot;全局throw抛错&quot;);    yield 2;  &#125; catch (e) &#123;    console.log(e);  &#125;  yield 3;  yield 4;  yield 5;&#125;&gt;const it = gen();console.log(it.next()); // &#123;value: 1, done: false&#125;console.log(it.next()); // Error: 全局 throw 抛错 &#123;value: 3, done: false&#125;console.log(it.next()); // &#123;value: 4, done: false&#125;console.log(it.next()); // &#123;value: 5, done: false&#125;</code></pre><blockquote><ul><li><code>try..catch</code>语句抛出错误后，就不会执行<code>yield 2</code>，直接处理错误。</li><li>但是遍历器调用throw方法抛出的错误如果在 <code>Generator</code> 函数<strong>内部</strong>捕获处理，其处理后，还会<strong>自动执行</strong> <code>next</code> 方法</li><li>所以执行第二个<code>console.log(it.next());</code>时，既会打印出错误，也会自动执行执行<code>yield 3</code></li></ul></blockquote><ul><li>全局 throw 命令在 Generator 体内抛出错误，<strong>内部没有</strong>捕获该错误，则遍历器终止</li></ul><pre><code>function* gen() &#123;  let result = yield 1;  yield result();  yield 3;  yield 4;&#125;&gt;const it = gen();console.log(it.next()); // &#123;value: 1, done: false&#125;try &#123;  console.log(    it.next(function () &#123;      throw new Error(&quot;a&quot;);    &#125;)  );&#125; catch (e) &#123;  console.log(&quot;错误&quot;, e); // 错误 Error: a&#125;&gt;console.log(it.next()); // &#123;value: undefined, done: true&#125;console.log(it.next()); // &#123;value: undefined, done: true&#125;</code></pre><blockquote><ul><li>第一个<code>console.log(it.next());</code>，执行<code>yield 1</code>,<code>result=undefined</code></li><li>第二个<code>console.log(it.next(function () &#123;throw new Error(&quot;a&quot;);&#125;));</code>，先计算表达式：<code>result()：</code>函数作为上一次<code>yield</code>的返回值被调用，相当于在<code>Generator</code>函数体内抛出错误，但函数体内没有捕获错误，所以，遍历器终止</li></ul></blockquote><ol start="11"><li>throw 方法总结<blockquote><p>注意：</p><ul><li><strong>遍历器的</strong><code>throw</code>方法在<code>Generator</code>函数<strong>体外</strong>抛出的错误，可以在<code>Generator</code>函数<strong>体内</strong>捕获处理</li><li><strong>全局</strong><code>throw</code>在<code>Generator</code>函数<strong>体外</strong>抛出的错误<strong>不能</strong>在<code>Generator</code>函数<strong>体内</strong>捕获</li></ul></blockquote></li></ol><ul><li>三种情况抛出错误的处理方式的区别</li></ul><table><thead><tr><th>三种情况</th><th>不处理</th><th>Generator 函数体内处理</th><th>Generator 函数体外处理</th></tr></thead><tbody><tr><td><code>Generator</code>函数体内抛出的错(不管是全局还是遍历器)</td><td>后续代码都没有办法执行</td><td>不会影响遍历器的下一次遍历</td><td>遍历器终止</td></tr><tr><td>遍历器的 <code>throw</code> 方法在 <code>Generator</code> 函数体外抛错</td><td>后续代码都没有办法执行</td><td>不会影响遍历器的下一次遍历</td><td>遍历器终止</td></tr><tr><td>全局的 <code>throw</code> 方法在 <code>Generator</code> 函数体外抛错</td><td>后续代码都没有办法执行</td><td>做不到</td><td>不会影响遍历器的下一次遍历</td></tr></tbody></table><blockquote><blockquote><p>注意以下两种情况，会自动执行一次<code>next</code></p></blockquote></blockquote><ul><li>情况一：遍历器调用<code>throw</code>方法抛出错误，在函数体内被捕捉处理后，会自动执行一次<code>next</code></li></ul><pre><code>function* gen() &#123;  yield 1;  try &#123;    yield 2;  &#125; catch (e) &#123;    console.log(&quot;内部&quot;, e);  &#125;  yield 3;  yield 4;  yield 5;&#125;&gt;const it = gen();console.log(it.next()); // &#123;value: 1, done: false&#125;console.log(it.next()); // &#123;value: 2, done: false&#125;try &#123;  // 注意，throw的结果为  内部 a   &#123;value: 3, done: false&#125;  console.log(it.throw(&quot;a&quot;));&#125; catch (e) &#123;  console.log(&quot;错误&quot;, e);&#125;console.log(it.next()); // &#123;value: 4, done: false&#125;console.log(it.next()); // &#123;value: 5, done: false&#125;console.log(it.next()); // &#123;value: undefined, done: true&#125;</code></pre><ul><li>情况二：在函数体内抛出全局错误，并在函数体内捕捉处理后会自动执行一次<code>next</code></li></ul><pre><code>function* gen() &#123;  yield 1;  try &#123;    throw new Error(&quot;全局throw抛错&quot;);    yield 2;  &#125; catch (e) &#123;    console.log(e);  &#125;  yield 3;  yield 4;  yield 5;&#125;&gt;const it = gen();console.log(it.next()); // &#123;value: 1, done: false&#125;console.log(it.next()); // Error: 全局 throw 抛错 &#123;value: 3, done: false&#125;console.log(it.next()); // &#123;value: 4, done: false&#125;console.log(it.next()); // &#123;value: 5, done: false&#125;</code></pre><blockquote><p><strong>测试题</strong></p></blockquote><ul><li>以下代码运行结果是：</li></ul><pre><code>function* gen() &#123;  yield 1;  try &#123;    throw new Error(&quot;a&quot;);    yield 2;  &#125; catch (e) &#123;    console.log(&quot;内部&quot;, e);  &#125;  yield 3;  yield 4;&#125;&gt;const it = gen();console.log(it.next());//&#123;value: 1, done: false&#125;try &#123;  it.next();//内部 Error: a  //console.log(it.next());//&#123;value: 3, done: false&#125;  it.throw(&quot;b&quot;);//外部 b&#125; catch (e) &#123;  console.log(&quot;外部&quot;, e);&#125;console.log(it.next());console.log(it.next());</code></pre><blockquote><ul><li>第一个<code>it.next()</code>执行<code>yield 1</code>：<code>&#123;value: 1, done: false&#125;</code></li><li>第二个<code>it.next()</code>：函数体内抛出错误，捕获错误，并自动执行一次<code>next</code>方法，<code>yield 2</code>不会执行；如果打印它，就会得到<code>&#123;value: 3, done: false&#125;</code></li><li>下一步：<code>it.throw(&quot;b&quot;);</code>在函数体外抛出遍历器错误，但函数没有捕获，由外部捕获，所以遍历器终止</li></ul></blockquote><ul><li>以下代码运行结果是：</li></ul><pre><code>function* gen() &#123;  yield 1;  try &#123;    throw new Error(&quot;a&quot;);    yield 2;  &#125; catch (e) &#123;    console.log(&quot;内部&quot;, e);  &#125;  yield 3;  yield 4;&#125;&gt;const it = gen();console.log(it.next());try &#123;  console.log(it.next());  throw new Error(&quot;b&quot;);&#125; catch (e) &#123;  console.log(&quot;外部&quot;, e);&#125;console.log(it.next());console.log(it.next());</code></pre><blockquote><ul><li>第一个<code>it.next()</code>，执行<code>yield 1</code>：<code>&#123;value: 1, done: false&#125;</code></li><li>第二个<code>console.log(it.next());</code>：函数体内抛出全局错误，并被捕获，所以自动执行一次<code>next，</code>yield 2;<code>不会被执行，打印出:</code>内部 a<code>、</code>{value: 3, done: false}&#96;</li><li>下一步：函数体外抛出全局错误，并在外部捕获，打印出：<code>外部 b</code>；遍历器继续运行</li></ul></blockquote><ul><li>以下代码运行结果：</li></ul><pre><code>function* gen() &#123;  let result = yield 1;  try &#123;    yield result() + 2;  &#125; catch (e) &#123;    console.log(e, &quot;内部捕获&quot;);  &#125;  yield 3;  yield 4;  yield 5;&#125;&gt;const it = gen();console.log(it.next()); // &#123;value: 1, done: false&#125;try &#123;  console.log(    it.next(function () &#123;      throw new Error(&quot;错误被&quot;);    &#125;)  );&#125; catch (e) &#123;  console.log(e, &quot;外部捕获&quot;);&#125;console.log(it.next()); // &#123;value: 4, done: false&#125;console.log(it.next()); // &#123;value: 5, done: false&#125;</code></pre><blockquote><ul><li>第一个<code>it.next()</code>，执行<code>yield 1</code>，打印出<code>&#123;value: 1, done: false&#125;</code>；result&#x3D;<code>undefined</code></li><li>第二个<code>it.next()</code>，函数作为上一次<code>yield</code>的返回值被传入，使<code>result</code>等于该函数；<ul><li>先计算表达式：调用<code>result</code>，在函数体内抛出错误，注意：<code>try...</code>里面的代码<code>yield result() + 2;</code>不会被执行，只会处理错误，打印出<code>错误被内部捕获</code></li><li>由于错误在函数体内抛出并捕获，所以<code>it.next()</code>照常执行，打印出<code>&#123;value: 3, done: false&#125;</code></li></ul></li><li>遍历器继续执行</li></ul></blockquote><ol start="12"><li>Generator 函数的 return 方法<blockquote><p><code>Generator</code>函数返回的遍历器对象有一个<code>return</code>方法，可以返回给定的值，并终结<code>Generator</code>的遍历。</p></blockquote></li></ol><pre><code>function* gen() &#123;  yield 1;  yield 2;  yield 3;&#125;&gt;const it = gen();console.log(it.next()); // &#123;value: 1, done: false&#125;console.log(it.return(&quot;停止&quot;)); // &#123;value: &#39;停止&#39;, done: true&#125;console.log(it.next()); // &#123;value: undefined, done: true&#125;</code></pre><blockquote><blockquote><p>上面代码中</p></blockquote><ul><li>遍历器对象<code>it</code>调用<code>return</code>方法后，其返回对象的<code>value</code>属性值为<code>return</code>方法的参数 “停止”，<code>done</code>属性值为<code>true</code>，表示遍历器对象终止遍历。之后再调用<code>next</code>方法，返回对象始终为<code>&#123;value: undefined, done: true&#125;</code></li><li>如果<code>Generator</code>函数内部有<code>try...finally</code>代码块，那么<code>return</code>方法会推迟到<code>finally</code>代码块执行完后再执行。</li></ul></blockquote><blockquote><p><strong>注意区分以下情况</strong></p></blockquote><ul><li>如果代码还没有执行到<code>try</code>语句，就调用了<code>return</code>方法，则后面所有代码都不会执行，遍历器终止</li></ul><pre><code>function* gen() &#123;  yield 1;  try &#123;    yield 2;    throw new Error(&quot;a&quot;);  &#125; catch (e) &#123;    console.log(&quot;内部&quot;, e);  &#125; finally &#123;    yield 4;    yield 5;  &#125;&#125;&gt;const it = gen();console.log(it.next());//&#123;value:1, done: false&#125;console.log(it.return(&quot;bc&quot;)); // 还没有执行到try...相关代码，就终止 &#123;value: &#39;bc&#39;, done: true&#125;console.log(it.next());//&#123;value: undefined, done: true&#125;console.log(it.next());//&#123;value: undefined, done: true&#125;console.log(it.next());//&#123;value: undefined, done: true&#125;</code></pre><ul><li>执行到<code>try</code>语句中，然后再<code>return</code>，则会先把<code>finally</code>中的代码执行完，再执行<code>return</code>方法，终止遍历器</li></ul><pre><code>const it = gen();console.log(it.next()); // &#123;value: 1, done: false&#125;console.log(it.next()); // &#123;value: 2, done: false&#125;console.log(it.return(&quot;bc&quot;)); // &#123;value: 4, done: false&#125;console.log(it.next()); // &#123;value: 5, done: false&#125;console.log(it.next()); // &#123;value: &#39;bc&#39;, done: true&#125;console.log(it.next()); // &#123;value: undefined, done: true&#125;</code></pre><ul><li>代码执行到<code>try&#123;&#125;</code>后，再调用<code>return</code>方法，则终止遍历器</li></ul><pre><code>function* gen() &#123;  yield 1;  try &#123;    yield 2;    throw new Error(&quot;a&quot;);  &#125; catch (e) &#123;    console.log(&quot;内部&quot;, e);  &#125; finally &#123;    yield 4;    yield 5;  &#125;  yield 6;&#125;&gt;const it = gen();console.log(it.next()); // &#123;value: 1, done: false&#125;console.log(it.next()); // &#123;value: 2, done: false&#125;console.log(it.next()); // 内部 Error: a &#123;value: 4, done: false&#125;console.log(it.return(&quot;bc&quot;)); // &#123;value: &#39;bc&#39;, done: true&#125;console.log(it.next()); // &#123;value: undefined, done: true&#125;</code></pre><blockquote><ul><li>注意：由于是执行了<code>finally</code>里面的一部分，再<code>return</code>的，所以，<code>finally</code>没执行完的代码就不会被执行了</li></ul></blockquote><ol start="12"><li>作为对象属性的 Generator 函数<blockquote><p>如果一个对象的属性是 <code>Generator</code> 函数</p><ul><li>那么可以简写成以下形式</li></ul></blockquote></li></ol><pre><code>const obj = &#123;  gen: function* () &#123;&#125;,&#125;;&gt;// 简写形式const obj = &#123;  *gen() &#123;&#125;,&#125;;</code></pre><ul><li>调用方式<blockquote><ul><li>调用<code>Generator</code>函数，并不会执行函数体中的任何代码，只是返回一个遍历器对象。只有调用遍历器对象的<code>next()</code>方法后，才会开始执行函数体内的代码。</li><li>或者使用<code>for..of</code>遍历</li></ul></blockquote></li></ul><pre><code>const obj = &#123;  // 对象属性为Generator函数  *gen() &#123;    yield 1;    yield 2;    yield 3;  &#125;,  num() &#123;    console.log(&quot;我是普通函数&quot;);  &#125;,&#125;;obj.num(); //我是普通函数obj.gen(); //不会执行函数里面的代码// for...of遍历for (let v of obj.gen()) &#123;  console.log(v); // 1 2 3&#125;const it = obj.gen();//返回迭代器对象console.log(it.next()); //&#123;value: 1, done: false&#125;console.log(it.next()); //&#123;value: 2, done: false&#125;console.log(it.next()); //&#123;value: 3, done: false&#125;</code></pre><ol start="13"><li>Generator 函数的实例</li></ol><ul><li><code>Generator</code> 函数不能用作构造函数，所以不能用 <code>new</code> 关键字来调用</li></ul><pre><code>function* Gen(a, b) &#123;  this.a = a;  this.b = b;&#125;const gen = new Gen(1, 2); //报错 Gen is not a constructor</code></pre><ul><li><code>Generator</code>函数和普通函数一样<blockquote><ul><li>直接调用<code>Generator</code>函数，其内部的<code>this</code>指向<code>window</code></li><li>作为对象的方法被调用，<code>this</code>为调用该方法的对象</li></ul></blockquote></li></ul><pre><code>function* gen() &#123;  console.log(this);&#125;const it = gen();it.next(); // window&gt;const obj = &#123;  // 对象属性为Generator函数  *gen() &#123;    console.log(this);  &#125;,&#125;;const it = obj.gen();console.log(it.next());//&#123;gen: ƒ&#125;//&#123;value: undefined, done: true&#125;</code></pre><ul><li>使<code>Generator</code>函数，返回的迭代器对象，既可以作为迭代器对象使用，又可以当成函数内部的<code>this</code>指向</li></ul><pre><code>function* gen() &#123;  this.a = 1;  this.b = 2;  yield 1;&#125;//一般情况下const it = gen();console.log(it.next()); //&#123;value: 1, done: false&#125;console.log(it.a); //undefined&gt;//用call方法const it = gen.call(gen.prototype);console.log(it.next()); //&#123;value: 1, done: false&#125;console.log(it.a); //1console.log(it.b); //2&gt;const it = gen.call(gen.prototype);console.log(it.a); //undefinedconsole.log(it.b); //undefinedconsole.log(it.next()); //&#123;value: 1, done: false&#125;</code></pre><blockquote><ul><li>注意：必须先调用<code>it.next()</code>，才会执行函数体内的代码</li></ul></blockquote><ul><li><code>Generator</code> 函数的返回值是一个遍历器。<blockquote><ul><li><code>ES6</code>规定这个遍历器是<code>Generator</code>函数的实例，它也继承了<code>Generator</code>函数的<code>prototype</code>对象上的方法。</li></ul></blockquote></li></ul><pre><code>function* gen() &#123;  yield 1;&#125;&gt;gen.prototype.sayHello = function () &#123;  console.log(&quot;大家好，我是Generator函数原型上的方法&quot;);&#125;;&gt;const it = gen();console.log(it instanceof gen); // trueit.sayHello(); // 大家好，我是Generator函数原型上的方法</code></pre><h3 id="二、Generator-函数应用"><a href="#二、Generator-函数应用" class="headerlink" title="二、Generator 函数应用"></a>二、Generator 函数应用</h3><blockquote><p>深入浅出 Generator 函数的实践和应用</p></blockquote><ol><li>Generator 函数实现 Iterator 接口<blockquote><p>在学习<code>Iterator</code>迭代器（遍历器）时，我们知道，一个对象要想成为可迭代对象，能够被<code>for..of</code>遍历，必须满足：<strong>“可迭代协议” 和 “迭代器协议”</strong></p><ul><li>“可迭代协议” 是指对象身上必需要有<code>[Symbol.iterator]</code>，其返回值为一个迭代器对象</li><li>“迭代器协议” 是指迭代器对象必需要有<code>next</code>方法，<code>next</code>方法的返回值必需是一个具有<code>value</code>和<code>done</code>两个属性的对象。<code>vaule</code>属性的值为每次迭代的成员，<code>done</code>的值为布尔值，用来标识所有成员是否全部迭代完成。</li></ul></blockquote></li></ol><blockquote><p>手动实现一个迭代器对象非常麻烦，而 Generator 函数可以轻松帮我们实现。</p><ul><li><code>Generator</code> 函数，本质就是一个<strong>生成器函数</strong>，用来生成遍历器对象。所以我们可以把对象的<code>[Symbol.iterator]</code>属性值设置为一个<code>Generator</code>函数</li></ul></blockquote><ul><li>用<code>yield</code></li></ul><pre><code>const obj = &#123;  data: [1, 2, 3, 4, 5],  // [Symbol.iterator]:function* ()&#123;&#125;  *[Symbol.iterator]() &#123;    for (let i = 0; i &lt; this.data.length; i++) &#123;      yield this.data[i];    &#125;  &#125;,&#125;;&gt;for (let v of obj) &#123;  console.log(v); // 1 2 3 4 5&#125;</code></pre><ul><li>简化版：用<code>yield*</code></li></ul><pre><code>const obj = &#123;  data: [1, 2, 3, 4, 5],  // 生成器函数，生成一个迭代器（遍历器）对象  *[Symbol.iterator]() &#123;    yield* this.data;  &#125;,&#125;;&gt;for (let v of obj) &#123;  console.log(v); // 1 2 3 4 5&#125;</code></pre><ol start="2"><li>将数组按深度扁平化</li></ol><ul><li>不指定深度</li></ul><pre><code>function* gen(arr) &#123;  if (Array.isArray(arr)) &#123;    //是个数组    for (let i = 0; i &lt; arr.length; i++) &#123;      yield* gen(arr[i]);    &#125;  &#125; else &#123;    //不是数组    yield arr;  &#125;&#125;let arr = [1, [2, 3], 4, [5, [6], 7], [8], [9], 10];for (let v of gen(arr)) &#123;  console.log(v);//1 2 3 4 5 6 7 8 9 10&#125;</code></pre><ul><li>指定深度</li></ul><pre><code>// 将数组展平function flat(arr, depth) &#123;  // Generator函数，将数组中所有嵌套元素展平列出  function* gen(arr, n = 0) &#123;    if (Array.isArray(arr)) &#123;      n--;      if (n &lt; -1) &#123;        yield arr;      &#125; else &#123;        for (let i = 0; i &lt; arr.length; i++) &#123;          yield* flat(arr[i], n);        &#125;      &#125;    &#125; else &#123;      yield arr;    &#125;  &#125;&gt;  // 结果数组  const arr2 = [];  for (let v of gen(arr, depth)) &#123;    arr2.push(v);  &#125;  return arr2;&#125;&gt;let arr = [1, [2, 3], 4, [5, [6], 7], [8], [9], 10];console.log(flat(arr, 1));//[1, 2, 3, 4, 5, Array(1), 7, 8, 9, 10]</code></pre><ol start="3"><li>深度优先遍历 DOM 树<blockquote><ul><li>深度优先：先深度，再广度</li></ul></blockquote></li></ol><pre><code>&gt;&lt;div id=&quot;container&quot;&gt;&gt;  &lt;ul&gt;&gt;    &lt;li&gt;&gt;      &lt;h3&gt;标题&lt;/h3&gt;&gt;      &lt;div class=&quot;box2&quot;&gt;&gt;        &lt;img src=&quot;&quot; alt=&quot;图片&quot; /&gt;&gt;        &lt;p&gt;描述&lt;/p&gt;&gt;        &lt;p&gt;&lt;span&gt;价格:&lt;/span&gt;&lt;i&gt;50&lt;/i&gt;&lt;/p&gt;&gt;      &lt;/div&gt;&gt;    &lt;/li&gt;&gt;  &lt;/ul&gt;&gt;&lt;/div&gt;&gt;&gt;&lt;script&gt;  function* getDomTree(node) &#123;    yield node.tagName;//DIV    if (node.children.length &gt; 0) &#123;      for (let i = 0; i &lt; node.children.length; i++) &#123;        yield* getDomTree(node.children[i]);      &#125;    &#125;  &#125;  const node = document.getElementById(&quot;container&quot;);  for (let el of getDomTree(node)) &#123;    console.log(el);  &#125;&gt;&lt;/script&gt;</code></pre><ul><li>带 <code>--</code> 前缀的</li></ul><pre><code>&gt;&lt;script&gt;  // node表示DOM节点  n用来控制标签前面--填充的个数  function* getDomTree(node, n = 0) &#123;    yield &quot;-&quot;.repeat(n) + node.tagName;    if (node.children.length &gt; 0) &#123;      n += 2; // 下一级--加2      for (let i = 0; i &lt; node.children.length; i++) &#123;        yield* getDomTree(node.children[i], n);      &#125;    &#125;  &#125;  const node = document.getElementById(&quot;container&quot;);  for (let el of getDomTree(node)) &#123;    console.log(el);  &#125;&gt;&lt;/script&gt;</code></pre><h2 id="Promise-用法、实例方法、原理与异步编程的实践应用"><a href="#Promise-用法、实例方法、原理与异步编程的实践应用" class="headerlink" title="Promise 用法、实例方法、原理与异步编程的实践应用"></a>Promise 用法、实例方法、原理与异步编程的实践应用</h2><blockquote><p>本节内容我们开始学习 <code>ES6</code> 中的 <code>Promise</code> 异步编程的解决方案。比传统的解决方案：回调函数和事件，更合理和更强大。<br>它由社区最早提出和实现，<code>ES6</code> 将其写进了语言标准，统一了用法，原生提供了<code>Promise</code>对象。</p></blockquote><h3 id="一、认识-Promise"><a href="#一、认识-Promise" class="headerlink" title="一、认识 Promise"></a>一、认识 Promise</h3><ol><li>什么是 Promise<blockquote><p><code>Promise</code>是异步编程的一种<strong>解决方案</strong>，关于异步编程的解决方案，在之前我们学习过，<strong>回调函数</strong>是解决异步操作的一种解决方案，但是他存在一些缺陷，而这些缺陷 <code>Promise</code> 可以完美解决。</p><ul><li>接下来我们通过一个案例来讲解，Promise 和回调函数相比他的优势在哪里<br><strong>异步加载一张图片</strong>——回调函数</li><li>通常在一张图片加载完成后，我们需要做相关的操作，这时候我们可以把相关的操作写入到回调函数中，等图片加载完成后，就会执行回调函数中的代码，做相关的操作</li></ul></blockquote></li></ol><ul><li>预加载一张图片，图片加载成功后，需要处理的事情在回调函数中处理</li></ul><pre><code>function preloadImage(url, resolve, reject) &#123;  let img = new Image();  img.onload = function () &#123;    resolve(img); // 加载成功，调用回调函数执行下一步操作  &#125;;  img.onerror = function () &#123;    reject(new Error(&quot;图片加载失败&quot;));  &#125;;  img.src = url;&#125;&gt;const url =  &quot;https://sce7a2b9c9d95a-sb-qn.qiqiuyun.net/files/course/2019/10-29/011138ab5ee2314108.png&quot;;// 预加载一张图片preloadImage(url, (data) =&gt; &#123;  document.body.appendChild(data);&#125;);</code></pre><ul><li>逐步加载 5 张图片，并插入到页面中<blockquote><ul><li>在一张图片加载成功后，插入到页面，然后再加载下一张，共加载 5 张</li></ul></blockquote></li></ul><pre><code>// 预加载一张图片，图片加载成功后，需要处理的事情在回调函数中处理function preloadImage(url, resolve, reject) &#123;  let img = new Image();  img.onload = function () &#123;    resolve(img); // 加载成功，调用回调函数执行下一步操作  &#125;;  img.onerror = function () &#123;    reject(new Error(&quot;图片加载失败&quot;));  &#125;;  img.src = url;&#125;&gt;const urls = [  &quot;https://sce7a2b9c9d95a-sb-qn.qiqiuyun.net/files/course/2022/08-29/210311f40bcf290736.jpg&quot;,  &quot;https://sce7a2b9c9d95a-sb-qn.qiqiuyun.net/files/course/2019/11-06/134028c28eb5212376.jpg&quot;,  &quot;https://sce7a2b9c9d95a-sb-qn.qiqiuyun.net/files/course/2020/02-08/145955bc3b00504448.jpg&quot;,  &quot;https://sce7a2b9c9d95a-sb-qn.qiqiuyun.net/files/course/2022/03-19/174949d70767470556.jpg&quot;,  &quot;https://sce7a2b9c9d95a-sb-qn.qiqiuyun.net/files/course/2022/02-19/16465934b475255075.jpg&quot;,];preloadImage(urls[0], (data) =&gt; &#123;  document.body.appendChild(data);  preloadImage(urls[1], (data) =&gt; &#123;    document.body.appendChild(data);    preloadImage(urls[2], (data) =&gt; &#123;      document.body.appendChild(data);      preloadImage(urls[3], (data) =&gt; &#123;        document.body.appendChild(data);        preloadImage(urls[4], (data) =&gt; &#123;          document.body.appendChild(data);        &#125;);      &#125;);    &#125;);  &#125;);&#125;);</code></pre><blockquote><blockquote><p>总结</p></blockquote><ul><li>通过上面的案例我们可以看到，如果只是加载 1 张图片，那回调函数的方式能很方便的帮我们实现。如果需要<strong>加载多张</strong>，就会出现层层嵌套的回调函数（<strong>回调地狱</strong><code>callback hell</code>）的问题也就出来。</li><li>如果需要加载的图片再多一些，那嵌套的级别会更深，不利于后期代码的维护，同时这种层层嵌套的写法也不符合正常代码的书写逻辑，而<code>Promise</code>就可以解决这个问题。</li></ul></blockquote><ol start="2"><li>什么时候使用 Promise<blockquote><p><code>Promise</code> 一般<strong>用来解决层层嵌套的回调函数</strong>（回调地狱 <code>callback hell</code>）的问题</p><ul><li>我们用 Promise 来改造下上面的回调函数的写法，代码如下</li></ul></blockquote></li></ol><pre><code>// 预加载一张图片，图片加载成功后，需要处理的事情在回调函数中处理function preloadImage(url) &#123;  return new Promise((resolve, reject) =&gt; &#123;    let img = new Image();    img.onload = function () &#123;      resolve(img); // 加载成功，调用回调函数执行下一步操作    &#125;;    img.onerror = function () &#123;      reject(new Error(&quot;图片加载失败&quot;));    &#125;;    img.src = url;  &#125;);&#125;&gt;const urls = [  &quot;https://sce7a2b9c9d95a-sb-qn.qiqiuyun.net/files/course/2022/08-29/210311f40bcf290736.jpg&quot;,  &quot;https://sce7a2b9c9d95a-sb-qn.qiqiuyun.net/files/course/2019/11-06/134028c28eb5212376.jpg&quot;,  &quot;https://sce7a2b9c9d95a-sb-qn.qiqiuyun.net/files/course/2020/02-08/145955bc3b00504448.jpg&quot;,  &quot;https://sce7a2b9c9d95a-sb-qn.qiqiuyun.net/files/course/2022/03-19/174949d70767470556.jpg&quot;,  &quot;https://sce7a2b9c9d95a-sb-qn.qiqiuyun.net/files/course/2022/02-19/16465934b475255075.jpg&quot;,];&gt;preloadImage(urls[0])  .then((data) =&gt; &#123;    document.body.appendChild(data);    return preloadImage(urls[1]);  &#125;)  .then((data) =&gt; &#123;    document.body.appendChild(data);    return preloadImage(urls[2]);  &#125;)  .then((data) =&gt; &#123;    document.body.appendChild(data);    return preloadImage(urls[3]);  &#125;)  .then((data) =&gt; &#123;    document.body.appendChild(data);    return preloadImage(urls[4]);  &#125;)  .then((data) =&gt; &#123;    document.body.appendChild(data);  &#125;);</code></pre><blockquote><p>注：</p><ul><li>Promise 改造后的代码是按正常的代码书写逻辑，从上往下来书写，解决了“回调地狱 callback hell”问题。他使得异步操作能<strong>以同步操作的流程</strong>表达出来。</li></ul></blockquote><h3 id="二、Promise-的基本用法"><a href="#二、Promise-的基本用法" class="headerlink" title="二、Promise 的基本用法"></a>二、Promise 的基本用法</h3><ol><li>创建 Promise 实例<blockquote><p><code>ES6</code> 规定，<code>Promise</code>对象是一个<strong>构造函数</strong>，用来生成 <code>Promise</code>实例。</p></blockquote></li></ol><ul><li>构造函数接受一个函数作为参数，该函数有两个参数，分别是<code>resolve</code>和<code>reject</code></li></ul><pre><code>const promise = new Promise(function (resolve, reject) &#123;&#125;);// 参数resolve和reject是两个形参，名字可自定义，为了更符合语义，建议使用resolve和reject来命名</code></pre><ul><li><code>Promise</code>对象一旦创建，就会<strong>立即执行</strong>构造函数参数中的函数（我们称此函数为执行器 <code>executor</code> 函数）</li></ul><pre><code>const promise = new Promise(function (resolve, reject) &#123;  console.log(&quot;立马执行&quot;);&#125;);// 输入结果： 立马执行</code></pre><ul><li><code>resolve</code>和<code>reject</code>参数分别为两个函数，异步操作成功时调用<code>resolve</code>，失败时调用<code>reject</code></li></ul><pre><code>const p1 = new Promise(function (resolve, reject) &#123;  // 创建图片对象  let img = new Image();  // 图片加载成功触发onload事件  img.onload = function () &#123;    resolve(img); // 图片加载成功，就把图片作为参数传出去,对外如何接收数据并操作，后面讲  &#125;;  // 图片加载失败，触发onerror事件  img.onerror = function () &#123;    reject(new Error(&quot;图片加载失败&quot;)); // 图片加载失败，把错误对象传出去  &#125;;  // 给图片添加地址，就会发送http请求下载图片  img.src = &quot;http://www.xxx.com&quot;;&#125;);</code></pre><blockquote><blockquote><p>注：</p></blockquote><ul><li>异步操作成功时，我们通常需要把成功的结果传出去，再做后需操作</li><li>异步操作失败时，我们通常需要把错误对象传递出去，知道问题出在哪里。</li><li>至于对外如何拿到成功或失败后传递的数据，后面会讲到 <code>promise</code> 的 <code>then</code> 方法，<code>then</code> 方法可以处理</li></ul></blockquote><ol start="2"><li>Promise 的三种状态<blockquote><p><code>Promise</code>代表一种异步操作，他有三种状态，分别代表异步操作的三种状态</p><ul><li>待定（pending）：初始状态，既没有被兑现，也没有被拒绝。</li><li>已兑现（fulfilled）：意味着操作成功完成。</li><li>已拒绝（rejected）：意味着操作失败。<blockquote><p>通过查看 <code>Promise</code> 对象身上的<code>[[PromiseState]]</code>属性，可以了解 <code>Promise</code> 的状态</p></blockquote></li></ul></blockquote></li></ol><ul><li>刚创建一个 <code>Promise</code> 对象，他的的状态为 <code>pending</code> 待定或正在进行中。</li></ul><pre><code>const promise = new Promise(function (resolve, reject) &#123;&#125;);console.log(promise);</code></pre><blockquote><img src="pending.png"></blockquote><ul><li>调用<code>resolve</code>函数，<code>Promise</code>的状态由<code>pending</code> （待定）变为<code>fulfilled</code>（成功）</li></ul><pre><code>const promise = new Promise(function (resolve, reject) &#123;  resolve(); // 调用resolve，promise状态由pending变为fulfilled&#125;);console.log(promise);</code></pre><blockquote><img src="fulfilled.png"></blockquote><ul><li>调用<code>reject</code>函数，<code>Promise</code> 的状态由<code>pending</code>（待定）变为 <code>rejected</code>（失败）</li></ul><pre><code>const promise = new Promise(function (resolve, reject) &#123;  reject(); // 调用resolve，promise状态由pending变为rejected&#125;);console.log(promise);</code></pre><blockquote><img src="rejected.png"></blockquote><ol start="3"><li>注意事项</li></ol><ul><li><p><code>Promise</code> 的状态一旦由 <code>pending</code>变为<code>rejected</code>或<code>fulfilled</code>，就<strong>不可能再发生改变</strong>了。</p></li><li><p><code>Promise</code><strong>内部抛出错误</strong>，<code>promise</code> 的状态也会由<code>pending</code>变为<code>rejected</code></p></li></ul><ol start="4"><li>then 方法的简单应用<blockquote><p><code>then</code>方法的作用是为<code>Promise</code>实例添加<strong>状态改变时</strong>的回调函数。<code>then</code>方法中有两个参数，这两个参数分别为两个回调函数。</p><ul><li>第一个回调函数在<code>Promise</code>的状态变为<code>fulfilled</code>的时调用，表示成功的回调。</li><li>第二个回调函数在<code>Promise</code>的状态变为<code>rejected</code>的时候调用，表示失败的回调。</li></ul></blockquote></li></ol><pre><code>const promise = new Promise(function (resolve, reject) &#123;  resolve(); // Promise状态由pending--&gt;fulfilled ,调用then方法的第一个回调函数&#125;);&gt;promise.then(  // promise状态变为fulfilled时，调第一个回调  (data) =&gt; &#123;    console.log(&quot;成功的回调&quot;);  &#125;,  // promise状态变为rejected时，调第二个回调  (data) =&gt; &#123;    console.log(&quot;失败的回调&quot;);  &#125;);// 打印结果： 成功的回调</code></pre><pre><code>const promise = new Promise(function (resolve, reject) &#123;  reject(); // Promise状态由pending--&gt;rejected 调用then方法的第二个回调函数&#125;);&gt;promise.then(  (data) =&gt; &#123;    console.log(&quot;成功的回调&quot;);  &#125;,  (data) =&gt; &#123;    console.log(&quot;失败的回调&quot;);  &#125;);// 打印结果： 失败的回调</code></pre><ol start="5"><li>resolve 和 reject 参数<blockquote><p><code>resolve</code>和<code>reject</code>参数分别为两个函数，这两个函数的作用分别用来在异步操作成功和失败时调用。</p></blockquote></li></ol><table><thead><tr><th>参数</th><th>作用</th></tr></thead><tbody><tr><td><code>resolve</code>函数</td><td>当异步操作成功时调用<code>resolve</code>函数，他可以将<code>Promise</code>的状态由<code>pending</code>变为<code>fulfilled</code>，同时将异步操作的结果作为<code>resolve</code>函数的参数传递出去。<code>resolve</code>函数通常带一个参数，其参数会被传递到<code>then</code>方法的第一个回调函数的参数</td></tr><tr><td><code>reject</code>函数</td><td>当异步操作失败时调用<code>reject</code>函数，他可以将 <code>Promise</code>的状态由<code>pending</code>变为<code>reject</code>，同时将异步操作的结果作为<code>reject</code>函数的参数传递出去。<code>reject</code>函数通常带一个参数，其参数会被传递到<code>then</code>方法的第二个回调函数的参数</td></tr></tbody></table><ul><li><code>resolve</code>函数</li></ul><pre><code>const promise = new Promise(function (resolve, reject) &#123;  resolve(1); // 1被传递给then方法的第一个回调函数的参数data.&#125;);promise.then(  (data) =&gt; &#123;    console.log(&quot;成功&quot;, data); // 成功 1  &#125;,  (data) =&gt; &#123;    console.log(&quot;失败&quot;, data);  &#125;);// 打印结果：成功 1</code></pre><ul><li><code>reject</code>函数</li></ul><pre><code>const promise = new Promise(function (resolve, reject) &#123;  reject(0); // 0被传递给then方法的第二个回调函数的参数data.  // reject(new Error(&#39;操作失败&#39;))&#125;);promise.then(  (data) =&gt; &#123;    console.log(&quot;成功&quot;, data); // 成功 1  &#125;,  (data) =&gt; &#123;    console.log(&quot;失败&quot;, data);  &#125;);// 打印结果： 失败 0// 打印结果： 失败 Error: 操作失败</code></pre><blockquote><blockquote><p>温馨提示：</p></blockquote><ul><li><code>reject</code>主要是用来在异步操作失败时调用，所以他的参数通常是一个<strong>错误对象</strong></li><li><code>reject</code> 和 <code>resolve</code> 函数的参数，保存在<code>promise</code>对象的<code>[[PromiseResult]]</code>属性中，我们称为<code>promise</code>实例对象的<strong>返回值</strong></li></ul></blockquote><pre><code>const promise = new Promise((resolve, reject) =&gt; &#123;  resolve(&quot;hello&quot;);&#125;);console.log(promise);</code></pre><blockquote><img src="promiseResult.png"></blockquote><ol start="6"><li>resolve 和 reject 函数的参数<blockquote><p><code>resolve</code>函数的<strong>参数为不同类型时</strong>，其传递给<code>then</code>方法的值会有所不同</p><blockquote><p>注意：</p></blockquote><ul><li><code>Promise</code>函数里的<code>resolve</code>和<code>reject</code>函数，在调用时，如果括号内有参数，就会传递给<code>then</code>方法；</li><li><code>then</code>方法的<code>return</code>和<code>resolve</code>&#x2F;<code>reject</code>函数的参数，使用原理是一样的</li><li>主要分以下四种情况<table><thead><tr><th>参数类型</th><th>说明</th></tr></thead><tbody><tr><td>不带任何参数</td><td><code>then</code>方法第一个回调函数接受到的参数值为<code>undefined</code></td></tr><tr><td>一般类型（非<code>thenable</code>对象和<code>Promise</code>对象）</td><td><code>then</code>方法第一个回调函数接收到的参数值为这个参数</td></tr><tr><td><code>Promise</code>实例</td><td>该参数的状态和返回值决定了后面<code>then</code>的回调函数和参数值</td></tr><tr><td><code>thenable</code>对象</td><td>先将<code>thenable</code>对象转换为<code>Promise</code>对象，然后立即执行<code>thenable</code>对象的<code>then</code>方法，改变<code>Promise</code>的状态。该<code>Promise</code>的状态决定了后面<code>then</code>方法的回调和参数值</td></tr></tbody></table></li></ul></blockquote></li></ol><ul><li>不带任何参数</li></ul><pre><code>const p = new Promise((resolve, reject) =&gt; &#123;  resolve();&#125;);p.then((data) =&gt; &#123;  console.log(data); // undefined&#125;);</code></pre><ul><li>参数为一般类型</li></ul><pre><code>const p = new Promise((resolve, reject) =&gt; &#123;  resolve(&quot;hello&quot;);&#125;);p.then((data) =&gt; &#123;  console.log(data); // hello&#125;);</code></pre><ul><li>参数是一个 Promise 对象</li></ul><pre><code>const p1 = new Promise(function (resolve, reject) &#123;  setTimeout(function () &#123;    reject(2);  &#125;, 3000);&#125;);const p2 = new Promise(function (resolve, reject) &#123;  resolve(p1);&#125;);&gt;p2.then(  (data) =&gt; &#123;    console.log(&quot;成功&quot;, data);  &#125;,  (data) =&gt; &#123;    console.log(&quot;失败&quot;, data);  &#125;);// 打印结果： 失败 2</code></pre><blockquote><p><strong>代码解析：</strong></p><ul><li>上面代码中，p1 和 p2 都是<code>promise</code>对象，但 p2 的 <code>resolve</code>方法将 p1 作为参数，此时 p2 的状态和返回结果都由 p1 来决定。</li><li>在 3s 后 p1 的状态改变，此时才会执行下面 then 方法中的回调，由于 p1 中调用的是<code>reject(2)</code>，其状态为失败，所以最后调 then 的第二个回调，其参数<code>data=2</code>。最后在控制台输出 ：“失败 2”</li></ul></blockquote><ul><li>thenable 对象<blockquote><ul><li>所谓的 <code>thenable</code> 对象是指：具有 <code>then</code> 方法的对象，如下面这个对象</li></ul></blockquote></li></ul><pre><code>let thenable = &#123;  name: &quot;icoding&quot;,  b: 2,  then(resolve, reject) &#123;    resolve(this.name);  &#125;,&#125;;</code></pre><blockquote><ul><li>如果<code>then</code>回调函数中的返回的值为<code>thenable</code>对象，会先将<code>thenable</code>对象转换为<code>Promise</code>对象，然后<strong>立即执行</strong><code>thenable</code>对象的<code>then</code>方法，改变<code>Promise</code>的状态。该 <code>Promise</code>的状态决定了后面<code>then</code>方法的回调和参数值</li></ul></blockquote><pre><code>let thenable = &#123;  name: &quot;icoding&quot;,  b: 2,  then(resolve, reject) &#123;    resolve(this.name);  &#125;,&#125;;const p = new Promise((resolve, reject) =&gt; &#123;  resolve(thenable);  //相当于：new Promise((resolve,reject)=&gt;&#123;  //thenable.then(resolve,reject)&#123;  //   resolve(&quot;icoding&quot;);//改变p的状态，将&quot;icoding&quot;作为参数传给下一个then  //  &#125;  //&#125;)&#125;);&gt;p.then((data) =&gt; &#123;  console.log(data); // icoding&#125;);</code></pre><blockquote><ul><li><code>Promise</code>函数里的<code>resolve</code>给第一个<code>then</code>方法传递出的是<code>thenable</code></li><li>但<code>thenable</code>是一个对象，所以，这个对象会自动调用自己的<code>then</code>方法，将<code>resolve</code>的参数<code>icoding</code>传给第一个<code>then</code>方法</li></ul></blockquote><blockquote><ul><li>resolve 方法的参数为 thenable 对象时，其内部实现大致如下</li></ul></blockquote><pre><code>// 模拟Promise的resolve方法，其参数为thenable对象时function resolve(obj) &#123;  return new Promise((resolve, reject) =&gt; &#123;    obj.then(resolve, reject);  &#125;);&#125;</code></pre><h3 id="三、Promise-的实例方法"><a href="#三、Promise-的实例方法" class="headerlink" title="三、Promise 的实例方法"></a>三、Promise 的实例方法</h3><blockquote><p>深入浅出<code>Promise</code>实例的方法：<code>then()</code> ，<code>catch()</code>，<code>finally()</code>方法</p></blockquote><table><thead><tr><th>实例方法</th><th>说明</th></tr></thead><tbody><tr><td>then</td><td>为 promise 添加被兑现和被拒绝状态的回调函数，并返回一个新的 promise 对象</td></tr><tr><td>catch</td><td>为 promise 添加一个被拒绝状态的回调函数，并返回一个新的 promise</td></tr><tr><td>finally</td><td>为 promise 添加一个回调函数，不管 promise 状态是兑现还是拒绝，都会凋用这个回调函数，并返回一个新的 promise</td></tr></tbody></table><h4 id="then-方法"><a href="#then-方法" class="headerlink" title="then 方法"></a>then 方法</h4><blockquote><p>then 方法的作用是为 promise 添加被兑现和被拒绝状态的回调函数，并返回一个新的 promise 对象<br>接下来，我们从以下几个方面深入学习 then 方法</p><ul><li>什么时候执行</li><li>then 方法的简写</li><li>then 方法执行后的返回值</li><li>then 方法向后传值</li></ul></blockquote><ol><li><code>then</code> 方法什么时候执行<blockquote><p><code>then</code>方法相当于一个<strong>异步方法</strong>（是一个<strong>微任务</strong>），内部的回调函数并不会立即执行，只有 <code>Promise</code> 的状态<strong>改变之后</strong>，<strong>没有同步代码</strong>需要执行时，才会执行。</p><ul><li>不过它会优先于<code>setTimeOut</code>（<strong>宏任务</strong>）方法前执行</li><li><code>Promise</code> 状态由 <code>pending -&gt; fulfilled</code>（成功） 时，执行 <code>then</code> 的第一个回调函数</li><li><code>Promise</code> 状态由 <code>pending -&gt; rejected</code>（失败） 时，执行 <code>then</code> 的第二个回调函数<blockquote><p>代码执行顺序：</p></blockquote></li><li>自上而下执行，遇到异步方法就添加到队列中去，在等待队列中有两种，一种是微任务，一种是宏任务，微任务优先于宏任务</li><li>顺序：自上而下执行同步代码—&gt;(同步代码执行完成后)执行异步任务中的微任务—&gt;异步任务中的宏任务</li></ul></blockquote></li></ol><ul><li>例1</li></ul><pre><code>setTimeout(function () &#123;  console.log(1);&#125;, 0);&gt;const promise = new Promise(function (resolve, reject) &#123;  console.log(3);  resolve(); // 调用then方法的第一个回调函数&#125;);&gt;promise.then(  (data) =&gt; &#123;    console.log(&quot;成功的回调&quot;);  &#125;,  (data) =&gt; &#123;    console.log(&quot;失败的回调&quot;);  &#125;);&gt;console.log(2);//代码执行顺序：//3 2 成功的回调 1</code></pre><blockquote><ul><li>第一步，执行同步代码：打印出 3 2；<blockquote><p>注意：<code>Promise</code>对象一旦创建，就会立即执行构造函数参数中的函数， 创建<code>Promise</code>实例是同步任务，<code>then</code>方法是异步任务</p></blockquote></li><li>第二步，执行微任务，调用<code>resolve()</code>，打印出”成功的回调”</li><li>第三步，执行宏任务——定时器，打印出 1</li></ul></blockquote><ul><li>例2</li></ul><pre><code>setTimeout(function () &#123;  console.log(1);&#125;, 0);&gt;const promise = new Promise(function (resolve, reject) &#123;  console.log(3);  setTimeout(function () &#123;    resolve(); // 3秒后调用then方法的第一个回调函数  &#125;, 3000);&#125;);&gt;promise.then(  (data) =&gt; &#123;    console.log(&quot;成功的回调&quot;);  &#125;,  (data) =&gt; &#123;    console.log(&quot;失败的回调&quot;);  &#125;);&gt;console.log(2);//代码执行顺序：//3 2 1 成功的回调 </code></pre><blockquote><ul><li>第一步，将定时器加入异步队列</li><li>第二步，创建<code>Promise</code>对象，立即打印出 3，将定时器加入异步队列</li><li>执行<code>console.log(2);</code>，打印出 2</li><li>同步代码都执行完成，异步队列中有两个定时器，第一个定时器延迟时间为0，所以先执行它，打印出 1</li><li>三秒后，调用<code>resolve()</code>函数，<code>Promise</code>状态改变，<code>then</code>的第一个回调函数被添加到异步队列中，等同步代码执行完之后才会执行，所以此时打印出”成功的回调”</li></ul></blockquote><ol start="2"><li>then 方法的简写<blockquote><p><code>then</code> 方法的两个回调函数并不一定都要写</p><ul><li>如果只需要处理<strong>成功</strong>的回调，那只写一个回调就好</li></ul></blockquote></li></ol><pre><code>const p1 = new Promise(function (resolve, reject) &#123;  resolve(1);&#125;);&gt;// 只需要处理成功的回调p1.then((data) =&gt; &#123;  console.log(&quot;成功&quot;, data);&#125;);</code></pre><blockquote><ul><li>如果只需要处理<strong>失败</strong>的回调，第一个回调函数可以用 <code>null</code>代替</li></ul></blockquote><pre><code>const p1 = new Promise(function (resolve, reject) &#123;  reject(1);&#125;);// 只需要处理失败的回调p1.then(null, (data) =&gt; &#123;  console.log(&quot;失败&quot;, data);&#125;);</code></pre><ol start="3"><li><code>then</code> 方法返回值</li></ol><ul><li><code>then</code>方法的返回值为一个新的<code>Promise</code>对象，所以<code>then</code>方法支持<strong>链式调用</strong></li></ul><pre><code>const p1 = new Promise(function (resolve, reject) &#123;  resolve(1);&#125;);&gt;p1.then().then().then();</code></pre><ul><li>then方法的返回值默认为一个<strong>新的成功的</strong><code>Promise</code>对象。</li></ul><pre><code>const p1 = new Promise(function (resolve, reject) &#123;  reject(1); // 状态为失败&#125;);&gt;p1.then(null, () =&gt; &#123;  console.log(&quot;a&quot;); // 返回一个新的成功状态的Promise&#125;)  .then(() =&gt; &#123;    console.log(2); // 返回一个新的成功状态的Promise  &#125;)  .then(() =&gt; &#123;    console.log(3); // 返回一个新的成功状态的Promise  &#125;);</code></pre><blockquote><blockquote><p>如何才能返回一个失败状态的 Promise 对象呢 ？后边会给出答案</p></blockquote></blockquote><ol start="4"><li>then 方法向后传值<blockquote><p><code>then</code>方法回调函数的<strong>返回值</strong>，会用<code>return</code>来传递给下一个<code>then</code>方法的回调函数的<strong>参数</strong>。不过参数的类型不同，其结果会有所不同。</p><ul><li>then 方法向后传值，分以下四种情况<table><thead><tr><th>return 返回值</th><th>说明</th></tr></thead><tbody><tr><td>不带任何参数</td><td><code>then</code>方法第一个回调函数接受到的参数值为 <code>undefined</code></td></tr><tr><td>一般类型（非<code>thenable</code>对象和<code>Promise</code>对象）</td><td>then方法第一个回调函数接收到的参数值为这个参数</td></tr><tr><td><code>Promise</code> 实例</td><td>该参数的状态和返回值决定了后面 then 的回调函数和参数值</td></tr><tr><td><code>thenable</code>对象</td><td>先将 thenable 对象转换为 Promise 对象，然后立即执行 thenable 对象的 then 方法，改变 Promise 的状态。该 Promise 的状态决定了后面 then 方法的回调和参数值</td></tr></tbody></table></li></ul></blockquote></li></ol><ul><li>不带任何参数</li></ul><pre><code>const p = new Promise(function (resolve, reject) &#123;  resolve(3);&#125;);p.then((data) =&gt; &#123;  console.log(data); // 3&#125;).then((data) =&gt; &#123;  console.log(data); // undefined&#125;);</code></pre><ul><li>一般类型<blockquote><ul><li>then 方法回调函数的返回值，值会传递给下一个 then 方法的回调函数的参数</li></ul></blockquote></li></ul><pre><code>const p1 = new Promise(function (resolve, reject) &#123;  reject(1);&#125;);&gt;p1.then(null, (data) =&gt; &#123;  console.log(data); // 1  // 相当于返回 new Promise((resolve,reject)=&gt;resolve(new Error(&quot;错误&quot;)))  return new Error(&quot;错误&quot;);&#125;)  .then((data) =&gt; &#123;    console.log(data); // Error: 错误    // 相当于返回 new Promise((resolve,reject)=&gt;resolve(3))    return 3;  &#125;)  .then((data) =&gt; &#123;    console.log(data); // 3    // 相当于返回 new Promise((resolve,reject)=&gt;resolve(&#123; a: 1 &#125;))    return &#123; a: 1 &#125;;  &#125;)  .then((data) =&gt; &#123;    console.log(data); // &#123; a: 1 &#125;    // 相当于返回 new Promise((resolve,reject)=&gt;resolve(undefined))  &#125;)  .then((data) =&gt; &#123;    console.log(data); // undefined  &#125;);</code></pre><ul><li>Promise 对象<blockquote><ul><li>如果 then 的回调函数的返回值为 Promise 对象，则后面的 then 的回调和参数的值是由这个 Promise 对象的<strong>状态和返回值</strong>决定。</li><li>如果这个 Promise 对象的状态为<strong>成功</strong>的，则执行后面 then 的<strong>第一个</strong>回调，回调中的参数为这个 Promise 的返回值</li><li>如果这个 Promise 对象的状态为<strong>失败</strong>的，则执行后面 then 的第<strong>二个</strong>回调，回调中的参数为这个 Promise 的返回值</li></ul></blockquote></li></ul><pre><code>const p1 = new Promise(function (resolve, reject) &#123;  resolve(1);&#125;);&gt;const p2 = new Promise(function (resolve, reject) &#123;  reject(2);&#125;);&gt;const p3 = new Promise(function (resolve, reject) &#123;  resolve(3);&#125;);&gt;p1.then((data) =&gt; &#123;  console.log(&quot;第一个then&quot;, data); // 第一个then 1  return p2;&#125;)  .then(    (data) =&gt; &#123;      console.log(&quot;第二个then&quot;, data);    &#125;,    (err) =&gt; &#123;      console.log(&quot;第二个then错误&quot;, err); // 第二个then错误 2      return p3;    &#125;  )  .then((data) =&gt; &#123;    console.log(&quot;第三个then&quot;, data); // 第三个then 3  &#125;);</code></pre><blockquote><p><strong>代码解析</strong></p><ul><li>上面 p1 的状态为成功状态，则执行 then 的第一个回调，输出：“第一个 then 1”，其返回值为 p2。</li><li>p2 的状态决定了下一个 then 的回调，p2 的状态为失败，则执行 then 的第二个回调，输出：“第二个 then 2”，其返回值为 p3</li><li>p3 的状态决定了他的下一个 then、p3 的状态为成功，则执行 then 的第一个回调，输出：“第三个 then 3”</li></ul></blockquote><ul><li><code>thenable</code> 对象<blockquote><ul><li>先将<code>thenable</code>对象转换为<code>Promise</code>对象，然后立即执行 <code>thenable</code>对象的<code>then</code>方法，改变<code>Promise</code>的状态。该 <code>Promise</code>的状态决定了后面<code>then</code>方法的回调和参数值</li></ul></blockquote></li></ul><pre><code>const p = new Promise(function (resolve, reject) &#123;  resolve(3);&#125;);p.then((data) =&gt; &#123;  console.log(data); // 3  // 返回值为thenable对象  return &#123;    then(resolve, reject) &#123;      resolve(&quot;清心&quot;);    &#125;,  &#125;;&#125;).then((data) =&gt; &#123;  console.log(data); // 清心&#125;);</code></pre><ol start="5"><li><code>then</code>返回失败的<code>Promise</code><blockquote><p>如果<code>then</code>需要返回一个<strong>失败的</strong><code>Promise</code>对象，有以下三种实现方式：</p><ul><li><code>then</code>方法回调函数的返回值为一个<strong>失败的</strong><code>Promise</code>对象</li><li><code>then</code>方法的回调函数中<strong>主动抛出错误</strong></li><li><code>then</code>方法的回调函数返回一个<code>thenable</code>对象,且<code>thenable</code>对象的的<code>then</code>中调用的是<code>reject</code>方法<blockquote><p>提示： 除了以上三种情况下，其它情况下<code>then</code>的返回的都是<strong>成功的</strong><code>Promise</code>对象</p></blockquote></li></ul></blockquote></li></ol><pre><code>const p1 = new Promise(function (resolve, reject) &#123;  resolve(1);&#125;);p1.then(() =&gt; &#123;  throw new Error(1); // 抛出错误  // return new Promise((resolve,reject)=&gt;reject(1))  返回一个失败的Promise对象  // return &#123;then(resolve,reject)&#123;reject(1)&#125;&#125;  // 返回一个thenable对象，对象的then方法中调用的是reject方法&#125;).then(  (data) =&gt; &#123;    console.log(&quot;成功&quot;, data);  &#125;,  (err) =&gt; &#123;    console.log(&quot;失败&quot;, err);  &#125;);// 打印结果：失败 Error: 1</code></pre><ol start="6"><li>测试题</li></ol><pre><code>const p = new Promise((resolve, reject) =&gt; &#123;  resolve(1);   // Promise状态由 pending---&gt;fulfilled&#125;);&gt;p.then((data) =&gt; &#123;  console.log(data); // 1  // 没有返回值 相当于then返回了一个成功的Promise,Promise的返回值为 undefined  // new Promise((resolve,reject)=&gt;&#123;resolve()&#125;)&#125;)  .then((data) =&gt; &#123;    console.log(data); // undefined    return 3;    // 相当于then返回了一个成功的Promise，Promise的返回值是3    // new Promise((resolve,reject)=&gt;resolve(3))  &#125;)  .then((data) =&gt; &#123;    console.log(data); // 3    return new Promise((resolve, reject) =&gt; reject(4));    // then返回了一个失败的Promise，Promise的返回值是4  &#125;)  .then(null, (err) =&gt; &#123;    console.log(err); // 4    return &#123;      then(resolve, reject) &#123;        resolve(&quot;清心&quot;);      &#125;,    &#125;;    // new Promise((resolve,reject)=&gt; resolve(&quot;清心&quot;);)  &#125;)  .then((data) =&gt; &#123;    console.log(data); // 清心  &#125;);</code></pre><h4 id="catch-方法"><a href="#catch-方法" class="headerlink" title="catch 方法"></a>catch 方法</h4><blockquote><p>重点了解：<code>catch()</code> 方法的好处和基本用法。</p><ul><li><code>Promise.prototype.catch()</code>方法是<code>.then(null, rejection)</code>或<code>.then(undefined, rejection)</code>的别名，用于指定<strong>发生错误（失败）时的回调函数</strong>。</li></ul></blockquote><pre><code>const p1 = new Promise(function (resolve, reject) &#123;  reject(1);&#125;);p1.then(null, (err) =&gt; &#123;  console.log(err);&#125;);&gt;// 上面写法，改成catch方法如下p1.catch((err) =&gt; &#123;  console.log(err);&#125;);</code></pre><ol><li>如果 catch 方法前没有错误，就不会执行 catch 方法，其会自动被忽略</li></ol><pre><code>const p1 = new Promise(function (resolve, reject) &#123;  resolve(1); // 成功回调&#125;);p1.then((data) =&gt; &#123;  console.log(data); // 1  return 3;&#125;)   .catch((err) =&gt; &#123;// 前面代码没有抛出错误，则此处的catch会被忽略，并不会执行    console.log(&quot;错误&quot;);    return 4;  &#125;)  .then((data) =&gt; &#123;    // 此处的data为第一个then方法中的返回值    console.log(data); // 3  &#125;);</code></pre><ol start="2"><li>catch 方法的返回值和向后传值原理与 then 方法<strong>完全一样</strong>。<blockquote><ul><li>catch 方法<strong>默认</strong>返回一个<strong>成功的</strong> Promise 对象，其回调函的返回值会向下传递给下一个 then 或 catch 方法的回调函数的参数</li></ul></blockquote></li></ol><pre><code>const p1 = new Promise(function (resolve, reject) &#123;  resolve(1);&#125;);p1.then((data) =&gt; &#123;  console.log(data); // 1  return new Promise((resolve, reject) =&gt; reject(4)); // 返回一个失败状态的Promise&#125;)  .catch((err) =&gt; &#123;    console.log(err); // 4    return 3;  &#125;)  .then((data) =&gt; &#123;    console.log(data); //3    throw new Error(&quot;2&quot;); // 主动抛出错误  &#125;)  .catch((err) =&gt; &#123;    console.log(err); // Error:2  &#125;);</code></pre><ol start="3"><li>如果 Promise 的失败状态在 then 方法中没有调用回调函数处理，则<strong>错误会向下传递</strong>，直到遇到 then 的第二个回调或 catch 方法才会被处理，如果一直没有处理，则最后会将错误抛出来<blockquote><ul><li><code>reject()</code>函数，相当于抛出错误</li></ul></blockquote></li></ol><pre><code>const p1 = new Promise(function (resolve, reject) &#123;  reject(1);&#125;);// p1状态为失败,then中没有处理,则向下传递p1.then((data) =&gt; &#123;  console.log(&quot;成功的回调&quot;, data);&#125;) // then中没有处理,向下传递  .then((data) =&gt; &#123;    console.log(&quot;不会执行2&quot;, data);  &#125;) // then中没有处理,向下传递  .then((data) =&gt; &#123;    console.log(&quot;不会执行2&quot;, data);  &#125;) // 遇到catch被处理  .catch((err) =&gt; &#123;    console.log(&quot;失败的回调&quot;, err);  &#125;);// 打印结果：失败的回调 1</code></pre><blockquote><blockquote><p>代码解析：</p></blockquote><ul><li>代码从上往下执行，p1 的状态为失败（相当于抛出一个错误），第一个 then 中没有书写第二个回调来处理这个错误，所以错误会向下传递，往后的第二个，三个 then 方法中都没有书写第二个回调来处理错误</li><li>所以错误继续向下传递，遇到 catch 后，被处理，然后打印输出结果：”失败的回调 1”</li></ul></blockquote><blockquote><blockquote><p>注意</p></blockquote><ul><li>在错误被抛出后和错误被处理之间的多个<code>then</code>方法中的第一个回调会被忽略，因为then方法的第一个回调函数只处理成功的回调</li></ul></blockquote><ol start="4"><li>catch 方法有什么好处<blockquote><ul><li>如果<strong>只需要处理失败（错误）的回调</strong>，则可以用只调用 catch 方法就好，不用调用 then 方法。</li><li>如果成功与失败的回调都要处理，则可以采用<strong>链式调用</strong>写法，相当更直观，简洁。</li></ul></blockquote></li></ol><pre><code>const p1 = new Promise(function (resolve, reject) &#123;  // resolve(1);  reject(2);&#125;);&gt;p1.then((data) =&gt; &#123;  console.log(&quot;成功的回调&quot;, data);&#125;).catch((err) =&gt; &#123;  console.log(&quot;失败的回调&quot;, err);&#125;);// 打印结果： 失败的回调 2</code></pre><ol start="5"><li>总结<blockquote><ul><li><code>catch()</code> 方法主要用来捕获它前面的错误<br>在实际开发中，一般总是建议，Promise 对象后面要跟 <code>catch()</code>方法（一个或多个 catch 方法），这样可以处理 Promise 内部发生的错误。</li></ul></blockquote></li></ol><blockquote><blockquote><p>注：</p></blockquote><ul><li>catch 方法主要是用来捕获它前面的错误，promise 抛出一个错误，就被catch()方法指定的回调函数捕获，如果没有错误，就不会执行 catch 方法。</li></ul></blockquote><h4 id="finally方法"><a href="#finally方法" class="headerlink" title="finally方法"></a>finally方法</h4><blockquote><p>需要重点了解：finally()方法什么时候执行，本质是什么 ?</p><ul><li>finally()方法用于指定不管 Promise 对象最后状态如何，都会执行的操作。该方法是 ES2018 引入标准的。在实际开发中用得不多，仅做了解。</li></ul></blockquote><pre><code>const p1 = new Promise(function (resolve, reject) &#123;  // resolve(&quot;成功&quot;);  reject(&quot;失败&quot;);&#125;);&gt;p1.finally((data) =&gt; &#123;  console.log(&quot;执行了&quot;);  console.log(data);&#125;);</code></pre><blockquote><blockquote><p>注：</p></blockquote><ul><li>finally 方法并不会接受任何参数，也不处理错误，只是用来执行 finally 方法回调函数中的代码。他常用来处理不关异步操作成功还是失败，最后都要做的操作。</li><li>比如：常见的数据库操作，不关最后操作成功还是失败，都需要关闭数据库。</li></ul></blockquote><h3 id="四、Promise-的实践和应用"><a href="#四、Promise-的实践和应用" class="headerlink" title="四、Promise 的实践和应用"></a>四、Promise 的实践和应用</h3><blockquote><p>异步任务的执行分为并发和继发<br><strong>继发</strong></p><ul><li>定义：指等上一个异步操作结束之后，才开始执行下一个异步任务</li><li>应用：一般在执行异步任务时需要上一个异步操作的结果，只有等上一个异步任务得到结果后，才能执行下一个异步任务，就需要采用继发模式。<br><strong>并发</strong></li><li>定义：多个异步任务同时触发执行</li><li>应用：如果多个异步任务之间没有依赖关系，各自可以独立进行的时候，应该让他们同时触发，就需要采用并发模式</li></ul></blockquote><ol><li>Promise 实现<strong>继发</strong>加载 5 张图片</li></ol><pre><code>function preloadImage(url) &#123;  return new Promise((resolve, reject) =&gt; &#123;    let img = new Image();    img.style.cssText = &quot;width:200px&quot;;    img.onload = function () &#123;      resolve(img);    &#125;;    img.onerror = function () &#123;      // reject(new Error(&quot;图片地址错误&quot;));      reject(null);    &#125;;    img.src = url;  &#125;);&#125;&gt;let urls = [  &quot;https://sce7a2b9c9d95a-sb-qn.qiqiuyun.net/files/course/2020/04-23/1339186404a1276893.jpg&quot;,  &quot;https://sce7a2b9c9d95a-sb-qn.qiqiuyun.net/files/course/2019/10-29/011138ab5ee2314108.png&quot;,  &quot;https://sce7a2b9c9d95a-sb-qn.qiqiuyun.net/files/course/2019/11-06/134028c28eb5212376.jpg&quot;,  &quot;https://sce7a2b9c9d95a-sb-qn.qiqiuyun.net/files/course/2022/08-29/210311f40bcf290736.jpg&quot;,  &quot;https://sce7a2b9c9d95a-sb-qn.qiqiuyun.net/files/course/2022/03-19/174949d70767470556.jpg&quot;,];preloadImage(urls[0])  .then((data) =&gt; &#123;    if (data) document.body.appendChild(data);    // 加载第二张    return preloadImage(urls[1]);  &#125;)  .catch(() =&gt; &#123;&#125;)  .then((data) =&gt; &#123;    if (data) document.body.appendChild(data);    // 加载第三张    return preloadImage(urls[2]);  &#125;)  .catch(() =&gt; &#123;&#125;)  .then((data) =&gt; &#123;    if (data) document.body.appendChild(data);    // 加载第四张    return preloadImage(urls[3]);  &#125;)  .catch(() =&gt; &#123;&#125;)  .then((data) =&gt; &#123;    if (data) document.body.appendChild(data);    // 加载第五张    return preloadImage(urls[4]);  &#125;)  .catch(() =&gt; &#123;&#125;)  .then((data) =&gt; &#123;    if (data) document.body.appendChild(data);  &#125;);</code></pre><blockquote><blockquote><p>注：</p></blockquote><ul><li>上面代码中每个<code>then</code>方法后面都跟了一个<code>catch</code>，主要是为了防止图片加载失败后，其错误没有处理而造成后面的<code>then</code> 方法直接被忽略，从而造成后面的图片都没有办法加载。</li></ul></blockquote><ol start="2"><li>Promise 实现<strong>并发</strong>加载 5 张图片</li></ol><pre><code>function preloadImage(url) &#123;  return new Promise((resolve, reject) =&gt; &#123;    let img = new Image();    img.style.cssText = &quot;width:200px&quot;;    img.onload = function () &#123;      resolve(img);    &#125;;    img.onerror = function () &#123;      // reject(new Error(&quot;图片地址错误&quot;));      reject(null);    &#125;;    img.src = url;  &#125;);&#125;&gt;let urls = [  &quot;https://sce7a2b9c9d95a-sb-qn.qiqiuyun.net/files/course/2020/04-23/1339186404a1276893.jpg&quot;,  &quot;https://sce7a2b9c9d95a-sb-qn.qiqiuyun.net/files/course/2019/10-29/011138ab5ee2314108.png&quot;,  &quot;https://sce7a2b9c9d95a-sb-qn.qiqiuyun.net/files/course/2019/11-06/134028c28eb5212376.jpg&quot;,  &quot;https://sce7a2b9c9d95a-sb-qn.qiqiuyun.net/files/course/2022/08-29/210311f40bcf290736.jpg&quot;,  &quot;https://sce7a2b9c9d95a-sb-qn.qiqiuyun.net/files/course/2022/03-19/174949d70767470556.jpg&quot;,];preloadImage(urls[0])  .then((data) =&gt; &#123;    document.body.appendChild(data);  &#125;)  .catch(() =&gt; &#123;&#125;);preloadImage(urls[1])  .then((data) =&gt; &#123;    document.body.appendChild(data);  &#125;)  .catch(() =&gt; &#123;&#125;);preloadImage(urls[2])  .then((data) =&gt; &#123;    document.body.appendChild(data);  &#125;)  .catch(() =&gt; &#123;&#125;);preloadImage(urls[3])  .then((data) =&gt; &#123;    document.body.appendChild(data);  &#125;)  .catch(() =&gt; &#123;&#125;);preloadImage(urls[4])  .then((data) =&gt; &#123;    document.body.appendChild(data);  &#125;)  .catch(() =&gt; &#123;&#125;);</code></pre><ol start="3"><li>Generator 函数实现继发加载 5 张图片<blockquote><p>实现的基本思想</p><ul><li>通过<code>Generator</code>函数生成的遍历器对象的<code>next</code>方法的参数，把外部的值传到<code>Generator</code>函数内部来，然后做相关操作，最后再接着执行下一步的异步操作。</li></ul></blockquote></li></ol><ul><li>基础版</li></ul><pre><code>// 预加载一张图片，图片加载成功后，需要处理的事情在回调函数中处理function preloadImage(url) &#123;  let img = new Image();  img.style.cssText = &quot;width:200px;margin:10px&quot;;  img.onload = function () &#123;    it.next(img);  &#125;;  img.onerror = function () &#123;    it.next(null);  &#125;;&gt;  img.src = url;&#125;&gt;const urls = [  &quot;https://sce7a2b9c9d95a-sb-qn.qiqiuyun.net/files/course/2022/08-29/210311f40bcf290736.jpg&quot;,  &quot;https://sce7a2b9c9d95a-sb-qn.qiqiuyun.net/files/course/2019/11-06/134028c28eb5212376.jpg&quot;,  &quot;https://sce7a2b9c9d95a-sb-qn.qiqiuyun.net/files/course/2020/02-08/145955bc3b00504448.jpg&quot;,  &quot;https://sce7a2b9c9d95a-sb-qn.qiqiuyun.net/files/course/2022/03-19/174949d70767470556.jpg&quot;,  &quot;https://sce7a2b9c9d95a-sb-qn.qiqiuyun.net/files/course/2022/02-19/16465934b475255075.jpg&quot;,];/*function* gen() &#123;    let img = yield preloadImage(urls[0]);    if (img) document.body.appendChild(img);    img = yield preloadImage(urls[1]);    if (img) document.body.appendChild(img);    img = yield preloadImage(urls[2]);    if (img) document.body.appendChild(img);    img = yield preloadImage(urls[3]);    if (img) document.body.appendChild(img);    img = yield preloadImage(urls[4]);    if (img) document.body.appendChild(img);&#125;*//* 上面Generator函数可以简写成下面形式 */function* gen() &#123;  let img;  for (let v of urls) &#123;    img = yield preloadImage(v);    if (img) document.body.appendChild(img);  &#125;&#125;// 生成遍历器const it = gen();it.next(); // 开始执行代码</code></pre><ul><li>优化版<blockquote><ul><li>以下形式的写法，前提是，每一次加载图片成功后，操作的内容是一样的</li></ul></blockquote></li></ul><pre><code>// 预加载一张图片，图片加载成功后，需要处理的事情在回调函数中处理function preloadImage(url) &#123;  let img = new Image();  img.style.cssText = &quot;width:200px;margin:10px&quot;;  img.onload = function () &#123;    document.body.appendChild(img);  &#125;;  img.onerror = function () &#123;&#125;;  img.src = url;&#125;&gt;const urls = [  &quot;https://sce7a2b9c9d95a-sb-qn.qiqiuyun.net/files/course/2022/08-29/210311f40bcf290736.jpg&quot;,  &quot;https://sce7a2b9c9d95a-sb-qn.qiqiuyun.net/files/course/2019/11-06/134028c28eb5212376.jpg&quot;,  &quot;https://sce7a2b9c9d95a-sb-qn.qiqiuyun.net/files/course/2020/02-08/145955bc3b00504448.jpg&quot;,  &quot;https://sce7a2b9c9d95a-sb-qn.qiqiuyun.net/files/course/2022/03-19/174949d70767470556.jpg&quot;,  &quot;https://sce7a2b9c9d95a-sb-qn.qiqiuyun.net/files/course/2022/02-19/16465934b475255075.jpg&quot;,];&gt;function* gen() &#123;  yield preloadImage(urls[0]);  yield preloadImage(urls[1]);  yield preloadImage(urls[2]);  yield preloadImage(urls[3]);  yield preloadImage(urls[4]);&#125;&gt;// 生成遍历器const it = gen();it.next(); // 加载第1张图片it.next(); // 加载第2张图片it.next(); // 加载第3张图片it.next(); // 加载第4张图片it.next(); // 加载第5张图片</code></pre><ul><li>Generator 函数与自动化管理</li></ul><pre><code>// 预加载一张图片，图片加载成功后，需要处理的事情在回调函数中处理function preloadImage(url) &#123;  return function thunk(resolve, reject) &#123;    let img = new Image();    img.style.cssText = &quot;width:200px;margin:10px&quot;;    img.onload = function () &#123;      resolve(img);    &#125;;    img.onerror = function () &#123;      reject(null);    &#125;;    img.src = url;  &#125;;&#125;&gt;const urls = [  &quot;https://sce7a2b9c9d95a-sb-qn.qiqiuyun.net/files/course/2022/08-29/210311f40bcf290736.jpg&quot;,  &quot;https://sce7a2b9c9d95a-sb-qn.qiqiuyun.net/files/course/2019/11-06/134028c28eb5212376.jpg&quot;,  &quot;https://sce7a2b9c9d95a-sb-qn.qiqiuyun.net/files/course/2020/02-08/145955bc3b00504448.jpg&quot;,  &quot;https://sce7a2b9c9d95a-sb-qn.qiqiuyun.net/files/course/2022/03-19/174949d70767470556.jpg&quot;,  &quot;https://sce7a2b9c9d95a-sb-qn.qiqiuyun.net/files/course/2022/02-19/16465934b475255075.jpg&quot;,];&gt;//   const it = gen();//   it.next().value(function (data) &#123;//     document.body.appendChild(data);//     it.next().value(function (data) &#123;//       document.body.appendChild(data);//       it.next().value(function (data) &#123;//         document.body.appendChild(data);//         it.next().value(function (data) &#123;//           document.body.appendChild(data);//         &#125;);//       &#125;);//     &#125;);//   &#125;);&gt;function* gen() &#123;  yield preloadImage(urls[0]);  yield preloadImage(urls[1]);  yield preloadImage(urls[2]);  yield preloadImage(urls[3]);  yield preloadImage(urls[4]);&#125;&gt;// 采取自动化管理function run(gen) &#123;  let it = gen();  function next() &#123;    let result = it.next();    if (result.done) return;    result.value(function (data) &#123;      document.body.appendChild(data);      // next(); // 写在这里是继发    &#125;);    next(); // 写在这里是并发  &#125;  next();&#125;&gt;run(gen);</code></pre><h3 id="五、Promise-的构造函数方法"><a href="#五、Promise-的构造函数方法" class="headerlink" title="五、Promise 的构造函数方法"></a>五、Promise 的构造函数方法</h3><blockquote><p>深入浅出<code>Promise</code>的构造函数方法，<code>Promise.resolve()</code>和<code>Promise.reject()</code>、<code>Promise.all()</code>、<code>Promise.race()</code>和<code>Promise.allSettled()</code>、<code>Promise.any()</code></p><ul><li>重点学习<code>Promise.resolve()</code>和<code>Promise.reject()</code>这个两个方法的：本质，参数 和 在 then 方法中的应用</li></ul></blockquote><ol><li><code>Promise.resolve()</code>方法<blockquote><p>有时需要将一个对象转为成功的 <code>Promise</code> 对象，<code>Promise.resolve</code>方法就可以起到这个作用。</p><ul><li><code>Promise.resolve()</code>方法是<strong>成功状态</strong><code>Promise</code>的一种简写形式</li></ul></blockquote></li></ol><pre><code>Promise.resolve(&quot;hello&quot;);// 等价于new Promise((resolve, reject) =&gt; &#123;  resolve(&quot;hello&quot;);&#125;);</code></pre><p><strong>基本用法</strong></p><ul><li>创建一个成功的 Promise 对象</li></ul><pre><code>// 创建一个成功的Promise对象Promise.resolve(&quot;hello&quot;).then((data) =&gt; &#123;  console.log(data); // hello&#125;);</code></pre><ul><li>then 的回调函数中返回一个成功的 Promise 对象</li></ul><pre><code>const p = new Promise((resolve, reject) =&gt; &#123;  resolve(22);&#125;);p.then((data) =&gt; &#123;  return Promise.resolve(&quot;icoding&quot;); // 返回一个成功的Promise&#125;).then((data) =&gt; &#123;  console.log(data); // icoding&#125;);</code></pre><p><strong>resolve方法的参数</strong></p><blockquote><ul><li>resolve 方法的参数分以下 4 种情况展开讲解</li></ul></blockquote><table><thead><tr><th>参数类型</th><th>说明</th></tr></thead><tbody><tr><td>不带任何参数</td><td>直接返回一个成功状态的 Promise 对象</td></tr><tr><td>一般类型（非 thenable 对象和 Promise 对象））</td><td>直接返回一个成功状态的 Promise 对象</td></tr><tr><td>Promise 实例</td><td>直接返回这个 Promise 实例</td></tr><tr><td>thenable 对象</td><td>先将 thenable 对象转换为 Promise 对象，然后立即执行 thenable 对象的 then 方法，改变 Promise 的状态。</td></tr></tbody></table><ul><li>不带任何参数</li></ul><pre><code>Promise.resolve();// 等价于new Promise((resolve, reject) =&gt; resolve());</code></pre><ul><li>参数为一般类型</li></ul><pre><code>Promise.resolve(&quot;hello&quot;);// 等价于new Promise((resolve, reject) =&gt; &#123;  resolve(&quot;hello&quot;);&#125;);</code></pre><ul><li>参数为 Promise 实例</li></ul><pre><code>const p1 = new Promise((resolve, rejcet) =&gt; resolve(&quot;hello&quot;));const p3 = Promise.resolve(p1);console.log(p3 === p1); // true&gt;// 与下面代码做区分const p1 = new Promise((resolve, rejcet) =&gt; resolve(&quot;hello&quot;));const p2 = new Promise((resolve, rejcet) =&gt; resolve(p1));console.log(p1 === p2); // false</code></pre><blockquote><blockquote><p>注意区分：</p></blockquote><ul><li><code>Promise.resolve()</code>方法是直接返回<code>Promise实例</code>，所以参数实例和接收到的实例是同一个</li></ul></blockquote><ul><li>参数为 thenable 对象<blockquote><ul><li>将 thenable 对象作为 <code>Promise.resolve</code> 的参数，则会先将 thenable 对象转换为 Promise 对象，然后立即执行 thenable 对象的 then 方法，从而改变 Promise 的状态。</li></ul></blockquote></li></ul><pre><code>let thenable = &#123;  name: &quot;icoding&quot;,  b: 2,  then(resolve, reject) &#123;    resolve(this.name);  &#125;,&#125;;&gt;Promise.resolve(thenable).then((data) =&gt; &#123;  console.log(data);&#125;);// 打印结果： icoding</code></pre><ol start="2"><li>Promise.reject() 方法<blockquote><p>有时需要将一个对象转为<strong>失败的</strong> Promise 对象，Promise.reject方法就可以起到这个作用。</p><ul><li>Promise.reject() 是失败状态 Promise 的一种简写形式</li></ul></blockquote></li></ol><pre><code>Promise.reject(new Error(&quot;错误&quot;));// 等价于new Promise((resolve, reject) =&gt; reject(&quot;错误&quot;));</code></pre><p><strong>基本用法</strong></p><blockquote><ul><li>当我们需要在 then 方法中返回一个失败的 Promise 时，就可以用 Promise.reject 方法</li></ul></blockquote><pre><code>Promise.reject(new Error(&quot;地址错误&quot;))  .catch((err) =&gt; &#123;    console.log(err); // Error: 地址错误    return 3;  &#125;)  .then((data) =&gt; &#123;    console.log(data); // 3    // 抛出错误的Promise    return Promise.reject(new Error(&quot;内部错误&quot;));  &#125;)  .catch((err) =&gt; &#123;    console.log(err); // Error: 内部错误  &#125;);</code></pre><p><strong>参数问题</strong></p><blockquote><ul><li>Promise.reject()的参数不管是什么类型都会<strong>原封不动</strong>传递给新创建的 Promise 回调函数的 reject 参数的参数。这一点与<code>Promise.resolve()</code>方法<strong>不一样</strong>喽</li><li>参数为thenable对象</li></ul></blockquote><pre><code>obj = &#123;  then(resolve, reject) &#123;    resolve(22);  &#125;,&#125;;&gt;Promise.reject(obj).catch((data) =&gt; console.log(data));// 打印结果：&#123;then:f&#125;</code></pre><blockquote><ul><li>如果是<code>Promise.resolve()</code>方法，则会打印出22</li></ul></blockquote><blockquote><ul><li>参数为 Promise 实例</li></ul></blockquote><pre><code>const p1 = new Promise((resolve, reject) =&gt; resolve(&quot;hello&quot;));&gt;const p2 = Promise.reject(p1);console.log(p1 === p2); // falsep2.catch((data) =&gt; &#123;  console.log(data); // p1&#125;);</code></pre><blockquote><blockquote><p>与<code>resolve()</code>方法对比</p></blockquote></blockquote><pre><code>const p1 = new Promise((resolve, reject) =&gt; resolve(&quot;hello&quot;));&gt;const p2 = Promise.resolve(p1);console.log(p1 === p2); // falsep2.then((data) =&gt; &#123;  console.log(data); // hello&#125;);</code></pre><ol start="3"><li>Promise.all() 方法<blockquote><p><code>Promise.all()</code>方法用于关注多个<code>Promise</code>对象的状态变化。其参数只要是一个迭代器对象或可遍历对象就可以。迭代的每个成员如果不是 Promise 对象，则会先将其转换为 Promise 对象，再做处理。<br><strong>语法</strong></p></blockquote></li></ol><pre><code>const p = Promise.all(iterable);</code></pre><p><strong>基本用法</strong></p><pre><code>const p = Promise.all([p1,p2,p3,...]) ; // p1 p2 p3都是promise对象</code></pre><blockquote><blockquote><p>注：<br>上面代码中，<code>Promise.all</code>接受一个数组作为参数，数组的成员都是<code>Promise</code>对象，如果其成员不是<code>Promise</code>对象，会将其转换为成功的<code>Promise</code>对象，再进一步处理。<br>返回值 p 为一个新的 Promise 对象，其状态由 p1,p2,p3 决定，<strong>分两种情况</strong></p></blockquote><ul><li>只有 p1,p2,p3 的状态<strong>都是<code>fulfilled</code><strong>，p 的状态才会变成<code>fulfilled</code>, 此时 p1,p2,p3 的返回值（<code>[[PromiseResult]]</code>属性值）组成一个</strong>数组</strong>，传递给到<code>p.then</code>的回调函数</li><li>只要 p1,p2,p3 中<strong>有一个</strong>的状态是 <code>rejected</code>，p 的状态就会变成 <code>rejected</code>，此时**第一个状态变为 <code>rejected</code>**的promise实例的返回值（<code>[[PromiseResult]]</code>属性值）传递给 <code>p.then</code> 的回调函数</li></ul></blockquote><ul><li>代码演示一：<blockquote><ul><li><code>Promise.all()</code>方法参数中的所有<code>Promise</code>对象状态都变为<code>fulfilled</code>的情况</li></ul></blockquote></li></ul><pre><code>const p1 = new Promise((resolve, reject) =&gt; &#123;  setTimeout(() =&gt; &#123;    resolve(1);  &#125;, 1000);&#125;);p1.then(() =&gt; &#123;  console.log(&quot;p1成功&quot;);&#125;);&gt;const p2 = new Promise((resolve, reject) =&gt; &#123;  setTimeout(() =&gt; &#123;    resolve(2);  &#125;, 2000);&#125;);p2.then((data) =&gt; &#123;  console.log(&quot;p2成功&quot;);&#125;);&gt;const p3 = new Promise((resolve, reject) =&gt; &#123;  setTimeout(() =&gt; &#123;    resolve(3);  &#125;, 3000);&#125;);p3.then((data) =&gt; &#123;  console.log(&quot;p3成功&quot;);&#125;);&gt;const p = Promise.all([p1, p2, p3]);p.then((data) =&gt; &#123;  console.log(&quot;成功&quot;, data);&#125;).catch((err) =&gt; &#123;  console.log(&quot;失败&quot;, err);&#125;);&gt;// p1,p2,p3状态都为fulfilled时,p的状态改变fulfilled,然后执行他的then方法</code></pre><blockquote><blockquote><p>代码解释：</p></blockquote><ul><li>1s 后 p1 的状态变为 fulfiled，打印出：”p1 成功”</li><li>2s 后 p2 的状态变为 fulfilled，打印出：”p2 成功”</li><li>3s 后 p3 的状态变为 fulfilled,打印出：”p3 成功”</li><li>当 p1,p2,p3 的状态都变为 fulfilled 时， p 的状态变为 fulfilled，然后调用 then 方法的第一个回调，打印出：”成功 [1,2 ,3]”</li></ul></blockquote><ul><li>代码演示二：<blockquote><p>-<code> Promise.all()</code>方法参数中的 Promise 对象状态有一个变为 rejected 的情况</p></blockquote></li></ul><pre><code>const p1 = new Promise((resolve, reject) =&gt; &#123;  setTimeout(() =&gt; &#123;    resolve(1);  &#125;, 1000);&#125;);p1.then(() =&gt; &#123;  console.log(&quot;p1成功&quot;);&#125;);&gt;const p2 = new Promise((resolve, reject) =&gt; &#123;  setTimeout(() =&gt; &#123;    reject(2);  &#125;, 2000);&#125;);p2.catch((err) =&gt; &#123;  console.log(&quot;p2失败&quot;);&#125;);&gt;const p3 = new Promise((resolve, reject) =&gt; &#123;  setTimeout(() =&gt; &#123;    resolve(3);  &#125;, 3000);&#125;);p3.then((data) =&gt; &#123;  console.log(&quot;p3成功&quot;);&#125;);&gt;const p = Promise.all([p1, p2, p3]);p.then((data) =&gt; &#123;  console.log(&quot;成功&quot;, data);&#125;).catch((err) =&gt; &#123;  console.log(&quot;失败&quot;, err);&#125;);&gt;// 当p2状态为reject时，p的状态也变为rejected,同时执行catch方法</code></pre><blockquote><blockquote><p>代码解释：</p></blockquote><ul><li>1s 后 p1 的状态变为 fulfiled，打印出：”p1 成功”</li><li>2s 后 p2 的状态变为 rejected，打印出：”p2 失败”。</li><li>此时 p 的状态变为 rejected，然后调用 catch 方法，打印出：“失败 2”</li><li>3s 后 p3 的状态变为 fulfilled，打印出”p3 成功”。<br><strong>总结：</strong></li><li>只要 p1,p2,p3 中有一个的状态率先变为 rejected 的，则 p 的状态就会变为 rejected 的。但并不会因为 p 的状态变为 rejected 的，其后没有执行完的 Promise 就不执行了，后面的 Promise<strong>该如何执行还得如何执行完</strong>。</li></ul></blockquote><ul><li>Promise.all() 最常用的场景<blockquote><ul><li>通过 Ajax 或其他方式从前端向后端获取数据的时候会用到<br>如：同时获取多个数据，所有数据都获取到了，都显示出来。如果没获取到再次处理 ，类似应用用的到比较多的地方。</li><li>目前只需要知道即可</li></ul></blockquote></li></ul><ol start="4"><li>Promise.race() 方法<blockquote><p>Promise.race 方法（race 翻译过来为“竞赛”）用来关注多个 Promise 的状态，<strong>看哪个 Promise 的状态先改变</strong>，然后返回一个新的 Promise 对象，新的 Promise 的状态和返回值与最先改变的那个 Promise 对象一致。</p></blockquote></li></ol><p><strong>语法</strong></p><pre><code>const p = Promise.race(iterable);</code></pre><blockquote><p><strong>参数：</strong><code>iterable</code></p><ul><li>表示一个迭代器对象或可遍历对象就可以。不过迭代的每个成员如果不是 Promise 对象，则会先将其转换为 Promise 对象，再做处理。</li></ul></blockquote><p><strong>基本用法</strong></p><pre><code>const p = Promise.race([p1, p2, p3,...]);</code></pre><blockquote><p><strong>上面代码中</strong></p><ul><li>p,p1,p2,p3 为 Promise 对象，p 的状态由 p1,p2,p3 的状态决定。</li><li>只要 p1,p2,p3 中有一个先改变状态，p 的状态就跟着改变。p 的状态和返回值与第一个先改变状态的 Promise 对象的状态和返回值是一致的。</li></ul></blockquote><ul><li>代码演示</li></ul><pre><code>const p1 = new Promise((resolve, reject) =&gt; &#123;  setTimeout(() =&gt; &#123;    resolve(1);  &#125;, 1000);&#125;);p1.then(() =&gt; &#123;  console.log(&quot;p1成功&quot;);&#125;);&gt;const p2 = new Promise((resolve, reject) =&gt; &#123;  setTimeout(() =&gt; &#123;    reject(new Error(&quot;地址出错了&quot;));  &#125;, 2000);&#125;);p2.catch(() =&gt; &#123;  console.log(&quot;p2失败&quot;);&#125;);&gt;const p3 = new Promise((resolve, reject) =&gt; &#123;  setTimeout(() =&gt; &#123;    resolve(3);  &#125;, 3000);&#125;);p3.then(() =&gt; &#123;  console.log(&quot;p3成功&quot;);&#125;);&gt;const p = Promise.race([p1, p2, p3]);p.then((data) =&gt; &#123;  console.log(&quot;p成功&quot;, data);&#125;).catch((err) =&gt; &#123;  console.log(&quot;p失败&quot;, err);&#125;);</code></pre><blockquote><p><strong>代码解析：</strong></p><ul><li>1s 后 p1 的状态改变，变为fulfilled，然后调用 then 方法，打印： “p1 成功”</li><li>因为 p1 状态改变fulfilled，则 p 的状态也变为fulfilled，然后调用 then 方法，打印： “p 成功 1”</li><li>2s 后 p2 的状态改变，变为“rejected”，然后调用 catch 方法，打印：”p2 失败“</li><li>2s 后 p3 的状态改变，变为 “fulfilled”，然后调用 then 方法，打印：”p3 成功“<br><strong>提示：</strong></li><li>不管第一个改变状态的 Promise，其状态是成功或还是失败，p 的状态都会在第一个状态改变的 Promise 之后马上改变。</li><li>但对其它没有操作完成的 Promise 没有影响。</li></ul></blockquote><ul><li>Promise.race() 应用<blockquote><p>我们经常会有这样的需求，如果某个异步请求在 3s 内还没有响应结果，则把 Promise 的状态改变为 rejected 的，再次发送请求。</p><ul><li>如果 3s 内的响应为失败，也重新发送一次请求。</li></ul></blockquote></li></ul><pre><code>// 预加载图片function preloadImage(url) &#123;  return new Promise((resolve, reject) =&gt; &#123;    const img = new Image();    img.onload = function () &#123;      resolve(img);    &#125;;    img.onerror = function () &#123;      reject(new Error(&quot;图片加载失改&quot;));    &#125;;    img.src = url;  &#125;);&#125;&gt;const p2 = new Promise((resolve, reject) =&gt; &#123;  setTimeout(() =&gt; &#123;    reject(&quot;超时,重新发送&quot;);  &#125;, 3000);&#125;);&gt;const url =  &quot;https://sce7a2b9c9d95a-sb-qn.qiqiuyun.net/files/system/2019/09-25/22132557f330499313.png?version=22.3.7&quot;;const p = Promise.race([preloadImage(url), p2]);p.then((data) =&gt; &#123;  console.log(&quot;一次成功&quot;);  document.body.appendChild(data);&#125;)  .catch((err) =&gt; &#123;    console.log(err);    return preloadImage(url);//再次请求  &#125;)  .then((data) =&gt; &#123;    if (data) document.body.appendChild(data);  &#125;);</code></pre><blockquote><blockquote><p>代码解析：</p></blockquote><ul><li>如果 preloadImage 方法中返回的 Promise 对象在 3 秒内状态改变</li><li>如果状态为成功，则 p 的状态为成功，执行 p 的 then 方法，把图片插入到页面中。下一个 then 方法的参数值为 undefined，则不会执行插入 dom 操作。</li><li>如果状态为失败，则 p 的状态为失败，执行 p 的 catch 方法，重新发送一次请求，请求成功将图片，插入页面，请求失败，抛出错误。</li><li>如果 preloadImage 方法返回的 Promise 对象在 3s 秒后状态才改变，则先改变状态的是 p2，p2 为失败的 Promise 对象，p 的状态为失败，执行 catch 方法，重新发送一次请求，请求成功将图片，插入页面，请求失败，抛出错误。</li></ul></blockquote><ol start="5"><li>Promise.allSettled() 方法<blockquote><p>Promise.allSettled 方法用来记录多个 Promise 的状态，他只忠于记录各个 Promise 的状态，<strong>其自身状态永远不受其他 Promise 状态的影响</strong>，返回的新的 Promise 实例<strong>永远为成功</strong>状态。</p></blockquote></li></ol><p><strong>语法</strong></p><pre><code>const p = Promise.allSettled(iterable);</code></pre><p><strong>基本用法</strong></p><pre><code>const p = Promise.allSettled([p1, p2, p3]);</code></pre><blockquote><blockquote><p>以上代码中</p></blockquote><ul><li>p,p1,p2,p3 都是 Promise 对象，当 p1,p2,p3 的状态都改变后，p 的状态才变为fulfilled</li><li>其 p 的返回值是一个数组，数组的每个成员都是一个对象，用来记录每个 promise 的状态，其对象顺序与传入的参数的顺序一样。</li></ul></blockquote><blockquote><blockquote><p>对象都有以下属性</p></blockquote><ul><li>status 表示对应 promise 的状态，要么是 “fulfilled”，要么是 “rejected”</li><li>value 仅当 status 为 “fulfilled”，才存在，表示 promise 成功时才有的值</li><li>reason 仅当 status 为 “rejected”，才存在，在 promsie 失败时才有 reason</li></ul></blockquote><pre><code>const p1 = new Promise((resolve, reject) =&gt; &#123;  setTimeout(() =&gt; &#123;    resolve(1);  &#125;, 1000);&#125;);p1.then(() =&gt; &#123;  console.log(&quot;p1状态改变&quot;);&#125;);&gt;const p2 = new Promise((resolve, reject) =&gt; &#123;  setTimeout(() =&gt; &#123;    reject(2);  &#125;, 2000);&#125;);&gt;p2.catch((err) =&gt; &#123;  console.log(&quot;p2状态改变&quot;);&#125;);&gt;const p3 = new Promise((resolve, reject) =&gt; &#123;  setTimeout(() =&gt; &#123;    resolve(3);  &#125;, 3000);&#125;);&gt;p3.then((err) =&gt; &#123;  console.log(&quot;p3状态改变&quot;);&#125;);&gt;const p = Promise.allSettled([p1, p2, p3]);&gt;p.then((data) =&gt; &#123;  console.log(data);&#125;);</code></pre><blockquote><img src="Promise.allSettled方法.png"></blockquote><ol start="6"><li>Promise.any() 方法<blockquote><p>Promise.any 用于关注多个 Promise 对象状态的改变</p><ul><li>只要<strong>其中有一个</strong> Promise 的状态变为 fulfilled，则这个方法返回的 Promise 对象的状态就变立马变为 fulfilled，其返回值为首个状态变为 fulfilledPromise 的返回值。</li><li>如果<strong>所有</strong> Promise 的状态都变为了 rejected,则这个方法返回的 Promise 对象的状态变为 rejected 的。其返回值为 <code>AggregateError</code> 实例，这是<code>Error</code>的子类，用于把单一的错误集合在一起。<blockquote><p>他主要用于多个 Promise 中最先成功的那一个。不过 <code>Promise.any</code> 方法还是一个实验性，<strong>并不被所有浏览器支持</strong>。</p></blockquote></li></ul></blockquote></li></ol><ul><li>代码演示一</li></ul><pre><code>const p1 = new Promise((resolve, reject) =&gt; &#123;  setTimeout(() =&gt; &#123;    reject(1);  &#125;, 1000);&#125;);p1.catch(() =&gt; &#123;  console.log(&quot;p1失败&quot;);&#125;);&gt;const p2 = new Promise((resolve, reject) =&gt; &#123;  setTimeout(() =&gt; &#123;    resolve(2);  &#125;, 2000);&#125;);&gt;p2.then((data) =&gt; &#123;  console.log(&quot;p2成功&quot;);&#125;);&gt;const p3 = new Promise((resolve, reject) =&gt; &#123;  setTimeout(() =&gt; &#123;    resolve(3);  &#125;, 3000);&#125;);&gt;p3.then((data) =&gt; &#123;  console.log(&quot;p3成功&quot;);&#125;);&gt;const p = Promise.any([p1, p2, p3]);p.then((data) =&gt; &#123;  console.log(&quot;p成功&quot;, data);&#125;).catch((err) =&gt; &#123;  console.log(&quot;p失败&quot;, err);&#125;);</code></pre><blockquote><blockquote><p>代码解析：</p></blockquote><ul><li>1s 后 p1 的状态变为失败，调用 catch 方法，打印：”p1 失败“</li><li>2s 后 p2 的状态变为成功，调用 then 方法，打印：”p2 成功“</li><li>因为 p2 状态为成功，所以 p 的状态马上变为成功，并调用 then 方法，打印：”p 成功 2“</li><li>3s 后 p3 的状态变为成功，调用 then 方法，打印：”p3 成功“<br><strong>注意：</strong></li><li>只要 p1,p2,p3 中有一个成功，则 p 的状态就变为成功，同时他的状态并不影其它 Promis 的正常执行。</li></ul></blockquote><ul><li>代码演示二：</li></ul><pre><code>const p1 = new Promise((resolve, reject) =&gt; &#123;  setTimeout(() =&gt; &#123;    reject(1);  &#125;, 1000);&#125;);p1.catch((err) =&gt; &#123;  console.log(&quot;p1失败&quot;);&#125;);&gt;const p2 = new Promise((resolve, reject) =&gt; &#123;  setTimeout(() =&gt; &#123;    reject(2);  &#125;, 2000);&#125;);&gt;p2.catch((err) =&gt; &#123;  console.log(&quot;p2失败&quot;);&#125;);&gt;const p3 = new Promise((resolve, reject) =&gt; &#123;  setTimeout(() =&gt; &#123;    reject(3);  &#125;, 3000);&#125;);&gt;p3.catch((err) =&gt; &#123;  console.log(&quot;p3失败&quot;);&#125;);&gt;const p = Promise.any([p1, p2, p3]);console.log(p);p.then((data) =&gt; &#123;  console.log(&quot;p成功&quot;, data);&#125;).catch((err) =&gt; &#123;  console.log(&quot;p失败&quot;, err);&#125;);</code></pre><blockquote><ul><li>因为 p1,p2,p3 都为失败，所以 p 为失败<img src="Promise.any方法.png"></li></ul></blockquote><blockquote><blockquote><p>注意：当传入的对象为空时</p></blockquote><ul><li>all、allSettled的状态是<code>fullfilled</code>会返回空数组</li><li>any的状态是<code>rejected</code>，会返回AggregateError实例，它的子类里面是<code>[]</code></li><li>race的状态是<code>pendding</code>，不会返回任何值</li></ul></blockquote><pre><code>const p = Promise.race([]);p.then((data) =&gt; &#123;  console.log(&quot;p成功&quot;, data);&#125;).catch((err) =&gt; &#123;  console.log(&quot;p失败&quot;, err);&#125;);//any方法：p失败 AggregateError: All promises were rejected//all方法：p成功 []//allSettled：p成功 []//race方法：空</code></pre><ol start="7"><li>经典面试题<blockquote><p>定义一个方法，方法传入一个参数，参数的类型只要是 <code>iterable</code>就行，这个方法用来</p><ul><li>①、返回物理上第一个成功的<code>promise</code>的结果</li><li>②、若全部为失败，则返回物理上最后一个<code>promise</code>的结果</li></ul></blockquote></li></ol><blockquote><p><strong>解题思路</strong></p><ul><li>定义的方法返回一个<code>promise</code>对象，然后在<code>promise</code>中遍历传入的<code>iterable</code>对象，如果其成员中有一个是成功的，就改变<code>promise</code>的状态，状态一旦改变就不可逆。</li><li>如果成员是失败的就记录失败的个数，当失败的个数与<code>iterable</code>成员个数相同时，则这个失败的成员就是最后一个失败的成员，调用<code>reject()</code>方法，改变<code>promise</code>对象的状态，然后将最后一个失败的<code>promise</code>返回值传入。</li></ul></blockquote><blockquote><p><strong>具体实现细节：</strong></p></blockquote><ul><li><p>定义两个变量<code>rejectTimes</code>和<code>length</code></p><blockquote><ul><li><code>rejectTimes</code>变量：用来记录失败的<code>promise</code>个数</li><li><code>length</code>变量：用来记录参数<code>iterable</code>的迭代成员个数</li></ul></blockquote></li><li><p>判断参数类型</p><blockquote><ul><li>如果参数<code>iterable</code>为空、null、undefined，就调用<code>reject</code>报错：<code>iterable==null</code>，注意是两个等号</li><li>如果参数<code>iterable</code>不是迭代器对象或可迭代对象，就调用<code>reject</code>报错<blockquote><p>怎么判断是否为迭代器对象或可迭代对象</p></blockquote></li><li>用鸭子类型检测(长得像)，并不严格满足迭代器协议和可迭代协议</li><li><code> typeof iterable.next !== &quot;function&quot; &amp;&amp;typeof iterable[Symbol.iterator] !== &quot;function&quot;</code></li></ul></blockquote></li><li><p>利用<code>for...of</code>来遍历<code>iterable</code>，</p><blockquote><ul><li>遍历过程中 <code>length++</code>，用来记录参数<code>iterable</code>的迭代成员个数</li><li>遍历中要判断遍历的成员类型，如果不是<code>promise</code>对象，则直接调用<code>resolve</code>,并将成员作为<code>resolve</code>的参数<ul><li>判断是否为<code>promise</code>对象：<code>p instanceof Promise</code></li></ul></li><li>如果是<code>promise</code>对象，则给遍历成员添加 <code>then</code> 和 <code>catch</code> 方法，<code>then</code> 中直接调用<code>resolve(data)</code>。<code>catch</code> 方法中将遍历 <code>rejectTimes++</code>，然后判断，如果<code>if(rejectTimes === length)</code>说明所有的<code>promise</code>都是失败的，则将最后一次的失败的<code>promise</code>返回值传入<code>reject()</code>中<blockquote><p><code>length++</code>在<code>for...of</code>里面，它属于同步代码，而<code>then</code>方法属于异步代码；所以在<code>rejectTimes++</code>前，他就能得到所有成员个数；只有异步代码全部执行完，才可能满足<code>length === rejectTimes</code></p></blockquote></li><li>注意特殊情况，就是<code>iterable</code>中没有一个成员，如果 <code>length === 0</code>，就说明<code>iterable</code>中没有一个成员，则调用<code>reject()</code>方法。</li></ul></blockquote></li></ul><pre><code>Promise._any = function (iterable) &#123;  let rejectTimes = 0; // 用来记录失败的个数  let length = 0; // 有来记录迭代器成员个数  return new Promise((resolve, reject) =&gt; &#123;    // 判断是否传值或传值为null    if (iterable == null) &#123;      return reject(new TypeError(`$&#123;iterable&#125; is not iterable`));    &#125;    // 判断传的成员是否是迭代器对象或可迭代成员，不是，则调用reject    if (      typeof iterable.next !== &quot;function&quot; &amp;&amp;      typeof iterable[Symbol.iterator] !== &quot;function&quot;    ) &#123;      return reject(new TypeError(`$&#123;iterable&#125; is not iterable`));    &#125;&gt;    // 对iterable进行for遍历    for (let v of iterable) &#123;      length++; // 同步代码      // 判断其类型是否为Promise      if (v instanceof Promise) &#123;        v.then((data) =&gt; &#123;          resolve(data);        &#125;).catch((err) =&gt; &#123;          rejectTimes++; // 异步中代码          // 如果 length===rejectTimes，说明所有Promise都失败了          if (length === rejectTimes) &#123;            reject(err);          &#125;        &#125;);      &#125; else &#123;        resolve(v);//一般类型都是成功态      &#125;    &#125;    // 判断传过的迭代对象中成员是否为空，如果为空，直接reject    if (length === 0) &#123;      reject(new Error(&quot;AggregateError: All promises were rejected&quot;));    &#125;  &#125;);&#125;;&gt;// 应用Promise._any([1, 2])  .then((data) =&gt; &#123;    console.log(data); // 1  &#125;)  .catch((err) =&gt; &#123;    console.log(err);  &#125;);&gt;Promise._any([Promise.reject(33), 2])  .then((data) =&gt; &#123;    console.log(data); // 2  &#125;)  .catch((err) =&gt; &#123;    console.log(err);  &#125;);&gt;Promise._any([Promise.reject(33), Promise.reject(44)])  .then((data) =&gt; &#123;    console.log(data);  &#125;)  .catch((err) =&gt; &#123;    console.log(err); // 44  &#125;);</code></pre><h3 id="六、总结"><a href="#六、总结" class="headerlink" title="六、总结"></a>六、总结</h3><ol><li><p>认识 Promise</p><blockquote><p>Promise 是什么 ？</p><ul><li>Promise 是异步操作的一种解决方案</li><li>Promise 一般用来解决层层嵌套的回调函数的问题（回调地狱）</li><li>Promise 解决的不是回调函数，而是回调地狱</li></ul></blockquote></li><li><p>Promise 3 种状态</p><blockquote><ul><li>pending （未完成）</li><li>resolved&#x2F;fulfilled（已成功）</li><li>rejected（已失败）<br><strong>状态转换</strong></li><li>只有从 pending（未完成）转到 resolved&#x2F;fulfilled（已成功）</li><li>或 pending（未完成）转到 rejected（已失败）<blockquote><p>Promise 状态一旦变化，就不会再改变了。</p></blockquote></li></ul></blockquote></li><li><p>Promise 的基本用法</p></li></ol><pre><code>const p = new Promise((resolve, reject) =&gt; &#123;  return resolve(&quot;成功 ！&quot;);  return reject(new Error(&quot;失败&quot;));&#125;).then(  (data) =&gt; &#123;&#125;,  (err) =&gt; &#123;&#125;);</code></pre><blockquote><p><strong>以上代码解读</strong>：</p><ul><li>使用 Promise 时，用的不是它的构造函数，而是实例化的构造函数生成的 Promise 对象</li><li>在实例化的过程中，构造函数中传的是一个回调函数，该回调函数有两个参数，resolve 和 reject</li><li>resolve 调用后，状态由 pending（未完成）转为 esolved&#x2F;fulfilled（已成功）状态。状态改变后：成功态，执行 then 的第一个回调函数</li><li>reject 调用后，状态由 pending （未完成）转为 rejected（已失败）。状态改变后：失败态，执行 then 的第二个回调函数</li></ul></blockquote><blockquote><blockquote><p><strong>注：</strong></p></blockquote><ul><li>resolve 和 reject 在调用的时候，是可以传递参数的，这个参数会在 then 方法中接收到。我们建议在调用 resolve 和 reject 时，直接通过 return 返回，这样即使后边还有代码也不会被执行</li><li>因此，我们推荐在调用 resolve 和 reject 函数的时候加上 <code>return</code></li></ul></blockquote><ol start="4"><li>Promise 的实例方法<blockquote><p><code>then()</code> 方法</p><ul><li>pending -&gt; resolved 时，执行 then 的第一个回调函数</li><li>pending -&gt; rejected 时，执行 then 的第二个回调函数</li><li>状态不改变，then() 的回调函数都不会被执行</li><li>then() 执行后返回一个新的 Promise 对象</li><li>可以通过 return 语句 改变返回的 Promise 对象的状态，默认情况下都是成功状态</li><li>then() 方法是可以向后传值的</li></ul></blockquote></li></ol><blockquote><p><code>catch()</code> 方法</p><ul><li>catch 专门用来处理 rejected 失败状态</li><li>catch 本质上是 <code>then</code> 的<strong>特例</strong></li><li>建议 Promise 对象后面要跟 catch 方法，这样可以处理 Promise 内部发生的错误<br><strong>注</strong>：</li><li>catch默认返回一个<strong>成功的</strong> Promise 对象，其回调函的返回值会向下传递给下一个 then 或 catch 方法的回调函数的参数</li><li>如果 catch 方法前没有错误，就不会执行 catch 方法，其会自动被忽略</li><li>catch 是可以捕获错误信息的，当前的错误只要没有被前面的 catch 或 then 的第二个回调所捕获的，错误是一直会传递下去的，不会消失，直到被某一个 catch 或 then 的回调捕获之后，后边就没有错误了。</li></ul></blockquote><blockquote><p><code>finally()</code> 方法</p><ul><li>当 Promise 状态发生变化时，不论如何变化都会执行</li><li>finally() 本质上是 then() 的特例</li></ul></blockquote><ol start="5"><li>Promise 的构造函数方法<blockquote><p><code>Promise.resolve()</code> 方法</p><ul><li>本质是成功状态 Promise 的一种简写形式</li><li>它会改变<code>Promise</code>的状态</li></ul></blockquote></li></ol><pre><code>new Promise((resolve) =&gt; resolve(&quot;成功&quot;));// 等价于Promise.resolve(&quot;成功&quot;);</code></pre><blockquote><p><code>Promise.resolve()</code> 的参数</p><ul><li>参数是 Promise 实例对象时，<strong>直接返回这个 Promise 对象</strong></li><li>参数是具有 then 方法的对象时，会立即执行它的 then 方法</li><li>参数是其他值时，相当于通过 resolve 函数传参</li></ul></blockquote><blockquote><p><code>Promise.reject()</code>方法</p><ul><li>本质是失败状态 Promise 的一种简写形式</li><li>它会改变<code>Promise</code>的状态，<strong>并抛错</strong></li></ul></blockquote><pre><code>new Promise((resolve, reject) =&gt; reject(&quot;失败 ！&quot;));// 等价于Promise.reject(&quot;失败 ！&quot;);</code></pre><blockquote><blockquote><p>不管什么参数，都会原封不动的向后传递，作为后续方法的参数</p></blockquote></blockquote><blockquote><p><code>Promise.all、race、allSettled()</code>方法</p><ul><li>只要是可遍历的，都可作为参数</li><li>参数的 “集合” 中若有成员不是 Promise 对象，内部会将其转变为 Promise 对象</li><li>返回一个新的 Promise 实例对象</li></ul></blockquote><blockquote><p><code>Promise.all()</code>方法</p><ul><li>所有状态都变成 resolved 成功时，最终的状态才会变成 resolved 成功</li><li>只要有一个变成 rejected 失败时，最终的状态就会变成 rejected 失败</li></ul></blockquote><blockquote><p><code>Promise.race()</code>方法</p><ul><li>最终的状态取决于第一个完成的 Promise 实例对象</li><li>如果第一个完成的成功了，那最终的就成功</li></ul></blockquote><blockquote><p><code>Promise.allSettled()</code>方法</p><ul><li>最终的状态永远都是成功的，与传入的 Promise 对象状态无关</li><li>会记录下各个 Promise 的表现</li></ul></blockquote>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JS核心知识点（二十二）</title>
      <link href="/2023/12/12/JS%E6%A0%B8%E5%BF%83%E7%9F%A5%E8%AF%86%E7%82%B9%EF%BC%88%E4%BA%8C%E5%8D%81%E4%BA%8C%EF%BC%89/"/>
      <url>/2023/12/12/JS%E6%A0%B8%E5%BF%83%E7%9F%A5%E8%AF%86%E7%82%B9%EF%BC%88%E4%BA%8C%E5%8D%81%E4%BA%8C%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<span id="more"></span><h2 id="设计模式-迭代器模式和-Iterator-遍历器与-for…of-循环"><a href="#设计模式-迭代器模式和-Iterator-遍历器与-for…of-循环" class="headerlink" title="设计模式 - 迭代器模式和 Iterator 遍历器与 for…of 循环"></a>设计模式 - 迭代器模式和 Iterator 遍历器与 for…of 循环</h2><blockquote><p>在学习 Iterator 遍历器之前，我们先来学习下 JS 设计模式中的迭代器模式。</p></blockquote><h3 id="一、设计模式：迭代器模式"><a href="#一、设计模式：迭代器模式" class="headerlink" title="一、设计模式：迭代器模式"></a>一、设计模式：迭代器模式</h3><blockquote><p>设计模式（Design pattern）代表了最佳的实践，通常被有经验的面向对象的开发人员所采用。</p><ul><li>设计模式是开发人员在开发过程中面临的一般问题的解决方案。项目中合理地运用设计模式可以完美地解决很多问题，每种模式在现实中都有相应的原理来与之对应，每种模式都描述了一个在我们周围不断重复发生的问题，以及该问题的核心解决方案，这也是设计模式能被广泛应用的原因。</li></ul></blockquote><h4 id="什么是迭代器模式"><a href="#什么是迭代器模式" class="headerlink" title="什么是迭代器模式"></a>什么是迭代器模式</h4><blockquote><p>迭代器模式是指提供一种方法<strong>顺序</strong>访问一个聚合对象中的各个元素，而又<strong>不需要暴露该对象的内部结构</strong>。也就是说，即使不了解对象的内部结构，也可以按顺序访问其中的每个元素。</p><ul><li>比如我们想要有序的访问数组中的每个成员，我们可以选择用<code>for</code>循环或<code>forEach</code>来实现。<blockquote><p>注意： for 循环并不遵顺迭代器模式，而 forEach 是符合迭代器模式的，为什么呢 ？</p></blockquote></li><li>for 循环遍历数组中的每个成员，需要知道数组的长度，同时还需要知道以什么形式访问数组中的成员</li><li>forEach 遍历数组中的成员，并不需要知道数组的长度和访问数组中成员的形式（即不需要知道对象的内部结构）</li></ul></blockquote><pre><code>const arr = [&quot;A&quot;, &quot;B&quot;, &quot;C&quot;];// 需要知道数组长度 arr.lengthfor (let i = 0; i &lt; arr.length; i++) &#123;  console.log(arr[i]); // 需要知道访问数组成员的形式&#125;&gt;// 并不需要知道数组的内部结构，也可以按顺序访问其中的每个成员arr.forEach((value) =&gt; &#123;  console.log(value);&#125;);</code></pre><blockquote><blockquote><p>迭代器模式必需要满足条件：<br>在<strong>不暴露对象的内部结构</strong>时，<strong>有序的</strong>访问对象中成员。所以 <code>for</code> 循环并遵顺迭代器模式，<code>forEach</code> 是符合的。</p></blockquote></blockquote><h4 id="区分：迭代器模式和迭代器"><a href="#区分：迭代器模式和迭代器" class="headerlink" title="区分：迭代器模式和迭代器"></a>区分：迭代器模式和迭代器</h4><blockquote><ul><li>迭代器模式：可以理解为在不需要了解对象的内部结构情况下，解决有序访问对象中成员的一种<strong>思想</strong>。</li><li>迭代器：可以理解为迭代器模式的一种具体方案的实现。 比如上面数组的<code>forEach</code>方法，可以看作是一个简易的迭代器。</li></ul></blockquote><h4 id="迭代器的分类"><a href="#迭代器的分类" class="headerlink" title="迭代器的分类"></a>迭代器的分类</h4><blockquote><p>迭代器可以分为<strong>内部</strong>迭代器和<strong>外部</strong>迭代器，它们分别有各自的适用场景</p></blockquote><blockquote><p><strong>内部迭代器：</strong></p><ul><li>内部迭代器通常被定义成一个方法，他是被动的，我们不需要关心内部迭代器的规则，只需要调用这个方法，就能有序的访问对象中的所有成员。</li><li>优点：使用非常简单</li><li>缺点：其灵活性相对较差。没有办法手动控制每一次迭代。其次不能与<code>break、continue、return</code>关键字配合使用，终止迭代器</li><li>上面的<code>forEach</code>函数就属于内部迭代器。</li></ul></blockquote><blockquote><p><strong>外部迭代器：</strong></p><ul><li>外部迭代器是主动的，我们必须知道他的内部实现，同时必须显示的请求迭代下一个元素。</li><li>优点：其灵活性相对较好，我们可以手动控制迭代的过程或顺序。可以与<code>break、continue、return</code>关键字配合使用，终止迭代器</li><li>缺点：使用起来相对比较麻烦</li><li>后面 ES6 中要学习到的数组的<code>[Symbol.iterator]</code>方法，就是一个外部迭代器</li></ul></blockquote><blockquote><p>因为外部迭代器使用其来很麻烦，而且需要了解其内部的实现。所以在实际开发中，我们通常是<strong>暴露一个内部迭代器对外使用</strong>。</p><ul><li>但由于内部迭代器不能与<code>break、continue、return</code>关键字配合使用。</li><li>所以在 ES6 中新增了<code>for...of</code>循环语句，<code>for...of</code>主要就是用来消费外部迭代器。（具体如何使用，后面学习）</li></ul></blockquote><h4 id="实现一个内部迭代器"><a href="#实现一个内部迭代器" class="headerlink" title="实现一个内部迭代器"></a>实现一个内部迭代器</h4><blockquote><p>数组的<code>forEach</code>方法可以看作是一个简易的迭代器，那我们来手动实现下数组的<code>forEach()</code>方法</p></blockquote><pre><code>const arr = [&quot;A&quot;, &quot;B&quot;, &quot;C&quot;];Array.prototype.forEach = function (callBack) &#123;  for (let i = 0; i &lt; this.length; i++) &#123;    callBack(this[i], i, this);  &#125;&#125;;&gt;arr.forEach((value, index, arr) =&gt; &#123;  console.log(value, index, arr);&#125;);</code></pre><blockquote><p>不过内部迭代器也有自己的问题，就是<strong>灵活性相对较差</strong>。</p><ul><li>比如，我们想要同时迭代两个数组，然后比较两个数组是否完全相等。上面的<code>forEach()</code>方法就没有办法实现，只能人为的再定义一个方法，在这个方法内部结合<code>forEach()</code>方法来一起实现。</li></ul></blockquote><ul><li>比较两个数组中的元素是否完全相等</li></ul><pre><code>const arr = [&quot;A&quot;, &quot;B&quot;, &quot;C&quot;];const arr2 = [&quot;A&quot;, &quot;B&quot;, &quot;C&quot;];Array.prototype.compare = function (arr2) &#123;  if (this.length !== arr2.length) &#123;    throw new Error(`两个数组不相等`);  &#125;  // 遍历来对比  this.forEach((value, index) =&gt; &#123;    if (value !== arr2[index]) &#123;      throw new Error(`两个数组不相等`);    &#125;  &#125;);  // 上面没有抛错，说明下面则是相等的  console.log(&quot;两个数组相等&quot;);&#125;;&gt;arr.compare(arr2);</code></pre><blockquote><ul><li>上面不完美之处在于，我们必须知道 <code>arr2</code> 数组的<strong>内部结构</strong>，才能与数组 arr 作比较。</li></ul></blockquote><h4 id="手动实现外部迭代器"><a href="#手动实现外部迭代器" class="headerlink" title="手动实现外部迭代器"></a>手动实现外部迭代器</h4><blockquote><p>外部迭代器是主动的，我们必须知道他的<strong>内部实现</strong>，同时必须<strong>显示的请求迭代下一个元素</strong>。其灵活性相对较好，我们可以手动控制迭代的过程或顺序。</p></blockquote><ul><li>手动实现一个外部迭代器，按顺序显示迭代数组中的每一个元素</li></ul><ol><li>基础版<blockquote><p><strong>实现思路：</strong></p><ul><li>在 Array 的原型上定义一个<code>getIterator</code>方法，当<code>数组.getIterator()</code>方法，返回一个<strong>对象</strong>（迭代器对象），<code>迭代器对象.next()</code>方法显示迭代数组的下一个元素。</li><li>当数组中元素全部迭代完成，返回值为<code>undefined</code></li></ul></blockquote></li></ol><pre><code>Array.prototype.getIterator = function () &#123;  let index = 0; // 相当于指针，最开始指向数组中的第一个元素的下标  let self = this; // 保存this  return &#123;    next() &#123;      return self[index++];    &#125;,  &#125;;&#125;;const arr = [&quot;A&quot;, &quot;B&quot;, &quot;C&quot;];let it = arr.getIterator(); // 返回迭代器对象// it.next() 显示请示迭代下一个元素console.log(it.next()); // Aconsole.log(it.next()); // Bconsole.log(it.next()); // Cconsole.log(it.next()); // undefined</code></pre><blockquote><p>上面代码中</p><ul><li>需要有序访问数组中的成员，只能先通过<code>数组.getIterator()</code>方法返回迭代器对象，然后通过<code>迭代器对象.next()</code>方法手动的迭代数组中的下一个元素。<br><strong>缺陷：</strong></li><li>上面的迭代器<strong>没有办法结合while循</strong>环一次性有序的遍历出数组的所有成员，<strong>因为没有办法判断对象中的成员是否迭代完成</strong>，所以我们需要对上面的代码做相关的修改。</li></ul></blockquote><ol start="2"><li>优化一：添加 <code>isDone</code> 和改进 <code>next</code> 方法<blockquote><ul><li>给迭代器对象添加一个<code>isDone</code>方法，用来判断当前对象中的成员是否全部迭代完成</li><li>同时修改<code>next()</code>方法体中的代码</li></ul></blockquote></li></ol><pre><code>Array.prototype.getIterator = function () &#123;  let index = 0; // 相当于指针，最开始指向数组中的第一个元素的下标  let self = this; // 保存this  return &#123;    isDone() &#123;      // 返回值为true，表示对象中成员全部迭代完成，false表示没有迭代完成      return index &gt; self.length - 1; // index &gt;= self.length    &#125;,    next() &#123;      if (!this.isDone()) &#123;        return self[index++];      &#125;    &#125;,  &#125;;&#125;;const arr = [&quot;A&quot;, &quot;B&quot;, &quot;C&quot;];const it = arr.getIterator();console.log(it.next()); // Aconsole.log(it.next()); // Bconsole.log(it.next()); // Cconsole.log(it.next()); // undefined</code></pre><blockquote><ul><li>利用 <code>while</code> 循环，一次性有序的迭代出数组中的所有成员</li></ul></blockquote><pre><code>const it = arr.getIterator();while (!it.isDone()) &#123;  console.log(it.next());&#125;</code></pre><blockquote><p><strong>缺陷：</strong></p><ul><li>如果我们想要在while循环中结合<code>break</code>,<code>continue</code>,<code>return</code>关键字终止迭代器（退出循环） 时，以上迭代器没有办法实现。</li></ul></blockquote><pre><code>const arr = [&quot;A&quot;, &quot;B&quot;, &quot;C&quot;];const it = arr.getIterator();while (!it.isDone()) &#123;  if (it.next() === &quot;B&quot;) &#123;    break;  &#125;  console.log(it.next());&#125;// 输出结果 B undefined</code></pre><blockquote><p>以上代码输出结果 :<code>B undefined</code>并不是我们所期望的，我们期望的结果是 <code>A</code>。<br><strong>为什么呢</strong> ？</p><ul><li>while 循环第一次，<code>it.next()</code>的结果为 A，肯定不等于 B，所以执行 <code>console.log(it.next())</code>，这里的<code>it.next()</code>相当于迭代下一个元素，结果为 <code>B</code>。所以并没有得到我们想要的 A 。</li></ul></blockquote><ol start="3"><li>优化二：next() 方法返回值为对象<blockquote><p>把<code>next()</code>方法的返回结果改成如下结构的对象</p></blockquote></li></ol><pre><code>&#123;    value: &quot;数组成员&quot;, // 值表示数组成员&#125;</code></pre><blockquote><ul><li>具体代码实现如下：</li></ul></blockquote><pre><code>Array.prototype.getIterator = function () &#123;  let index = 0; // 相当于指针，最开始指向数组中的第一个元素的下标  let self = this; // 保存this  return &#123;    isDone() &#123;      // 返回值为true，表示对象中成员全部迭代完成，false表示全部元素没有迭代      return index &gt; self.length - 1; // index&gt;=self.length    &#125;,    next() &#123;      if (!this.isDone()) &#123;        return &#123;          value: self[index++],        &#125;;      &#125;    &#125;,  &#125;;&#125;;const arr = [&quot;A&quot;, &quot;B&quot;, &quot;C&quot;];let it = arr.getIterator(); // 返回迭代器对象console.log(it.next()); // &#123;value: &#39;A&#39;&#125;console.log(it.next()); // &#123;value: &#39;B&#39;&#125;console.log(it.next()); // &#123;value: &#39;C&#39;&#125;console.log(it.next()); // &#123;value: undefined&#125;</code></pre><blockquote><ul><li>利用 <code>while</code> 循环，一次性有序的迭代出数组中的所有成员</li></ul></blockquote><pre><code>const arr = [&quot;A&quot;, &quot;B&quot;, &quot;C&quot;];// while循环，实现一次性有序的遍历出数组的所有成员let it = arr.getIterator();while (!it.isDone()) &#123;  obj = it.next();  console.log(obj.value);&#125;// 输出结果： A  B  C</code></pre><blockquote><ul><li><code>while</code> 循环与<code>break、continue、return</code>结合终止迭代器或退出 <code>while</code> 循环</li></ul></blockquote><pre><code>const arr = [&quot;A&quot;, &quot;B&quot;, &quot;C&quot;];// while循环，实现一次性有序的遍历出数组的所有成员let it = arr.getIterator();while (!it.isDone()) &#123;  obj = it.next();  if (obj.value === &quot;B&quot;) &#123;    //   break;    continue;  &#125;  console.log(obj.value);&#125;&gt;// 使用break关键字执行结果： A// 使用continue关键字执行结果： A C</code></pre><blockquote><p><strong>缺陷</strong>：</p><ul><li>如果我手动调用迭代器的<code>next()</code>方法来迭代下一个元素时，如果<strong>数据结构中的成员值</strong>为<code>undefined</code>，则我们没有办法区分返回的值<code>undefined</code>是数据结构本身的元素，还是表示没有下一个元素可以迭代了。所以还可以再优化。</li></ul></blockquote><ol start="4"><li>优化三：修改 next 方法返回结果<blockquote><p>把·方法的返回结果修改为以下结构的对象</p></blockquote></li></ol><pre><code>&#123;    value: &quot;数组成员&quot;, // 值表示数组成员，当done为true时，其值为undefined    done: false, // false 表示没有遍历完，true表示遍历完成&#125;</code></pre><blockquote><p><strong>具体代码实现如下：</strong></p></blockquote><pre><code>Array.prototype.getIterator = function () &#123;  let index = 0; // 相当于指针，最开始指向数组中的第一个元素的下标  let self = this; // 保存this  return &#123;    isDone() &#123;      // 返回值为true，表示对象中成员全部迭代完成，false表示没有      return index &gt; self.length - 1; // index&gt;=self.length    &#125;,    next() &#123;      let that = this;      if (!this.isDone()) &#123;        return &#123;          value: self[index++],          done: false,        &#125;;      &#125; else &#123;        return &#123;          value: undefined,          done: true,        &#125;;      &#125;    &#125;,  &#125;;&#125;;&gt;const arr = [&quot;A&quot;, &quot;B&quot;, &quot;C&quot;];let it = arr.getIterator(); // 返回迭代器对象console.log(it.next());console.log(it.next());console.log(it.next());console.log(it.next());</code></pre><blockquote><ul><li>while 循环与break、continue、return结合终止迭代器或退出 while 循环</li></ul></blockquote><pre><code>let it2 = arr.getIterator(); // 返回迭代器对象while (!it2.isDone()) &#123;  let obj = it2.next();  if (obj.value === &quot;B&quot;) &#123;    //   break;    continue;  &#125;  console.log(obj.value);&#125;//  输出结果为：A C</code></pre><h4 id="迭代器实际应用场景"><a href="#迭代器实际应用场景" class="headerlink" title="迭代器实际应用场景"></a>迭代器实际应用场景</h4><blockquote><p>通过上面的学习，我们知道<strong>迭代器模式</strong>是一种解决在不需要知道对象的内部结构情况下，有序遍历出对象中成员的一种解决思想。</p><ul><li>而<strong>迭代器</strong>是实现这种思想的一种具体解决方案</li></ul></blockquote><blockquote><p><strong>实现一个迭代器的基本思路：</strong></p><ul><li>创建一个方法 —-&gt; 这个方法返回一个对象（迭代器对象）—-&gt; 调用迭代器对象身上的方法（通常有<code>next</code>或<code>isDone</code>）可以显示迭代下一个成员，或判断成员是否全部迭代完成。</li></ul></blockquote><blockquote><p><strong>备注：</strong></p><ul><li>如果迭代器对象还需要其它功能，可自己添加相关方法。</li></ul></blockquote><ol><li>创建 Stack 类，添加一个外部迭代器<blockquote><ul><li>外部迭代器在while循环中可以与<code>break、continue、return</code>关键字配合使用，功能更强大</li></ul></blockquote></li></ol><pre><code>class Stack &#123;  #length; // 私有属性  #data = []; // 私有成员，存储入栈成员  constructor(length) &#123;    this.#length = length;  &#125;  // 返回#lenght属性，只能访问，不能修改  get length() &#123;    return this.#length;  &#125;  // 判断栈是否空  isEmpty() &#123;    return this.#data === 0;  &#125;  // 栈满  isFull() &#123;    return this.#data.length === this.#length;  &#125;  // 入栈  push(value) &#123;    if (this.isFull()) throw new Error(&quot;栈满，不能再添加元素&quot;);    this.#data.push(value);    return this; // 支持链式调用  &#125;  // 出栈  pop() &#123;    if (this.isEmpty()) throw new Error(&quot;栈空，不能再添加元素&quot;);    return this.#data.pop();  &#125;  // 迭代器方法，用来生成迭代器对象  getIterator() &#123;    let index = 0;    let self = this;    return &#123;      isDone() &#123;        return index &gt;= self.#data.length;      &#125;,      next() &#123;        if (!this.isDone()) &#123;          return &#123;            value: self.#data[index++],            done: false,          &#125;;        &#125; else &#123;          return &#123; value: undefined, done: true &#125;;        &#125;      &#125;,    &#125;;  &#125;&#125;&gt;const stack = new Stack(5);const stack2 = new Stack(3);stack.push(1).push(2).push(3).push(4).push(5);stack.pop();stack.pop();// 访问栈容器长度stack.length = 999;console.log(stack.length); //  5// 生成迭代器对象 itconst it = stack.getIterator();console.log(it.next());console.log(it.next());console.log(it.next());console.log(it.next());&gt;// while循环，一次性有序的迭代出对象的所有成员const it2 = stack.getIterator();let obj = it2.next();while (!obj.done) &#123;  console.log(obj.value);  obj = it2.next();&#125;</code></pre><ol start="2"><li>为 Stack 类添加内部迭代器 forEach 方法<blockquote><p>外部迭代器相对于内部迭代器灵活性更高，但是使用起来相对麻烦。所以我们通常<strong>会暴露内部迭代器</strong>对外使用。</p><ul><li>接下来我们给<code>Stack</code>类添加内部迭代器<code>forEach</code>方法</li></ul></blockquote></li></ol><pre><code> // 内部迭代器  forEach(callBack) &#123;    for (var i = 0; i &lt; this.#data.length; i++) &#123;      callBack(this.#data[i], i, this);    &#125;  &#125;</code></pre><blockquote><ul><li>完整代码</li></ul></blockquote><pre><code>class Stack &#123;  #length; // 私有属性  #data = []; // 私有成员，存储入栈成员  constructor(length) &#123;    this.#length = length;  &#125;  // 返回#lenght属性，只能访问，不能修改  get length() &#123;    return this.#length;  &#125;  // 判断栈是否空  isEmpty() &#123;    return this.#data === 0;  &#125;  // 栈满  isFull() &#123;    return this.#data.length === this.#length;  &#125;  // 入栈  push(value) &#123;    if (this.isFull()) throw new Error(&quot;栈满，不能再添加元素&quot;);    this.#data.push(value);    return this; // 支持链式调用  &#125;  // 出栈  pop() &#123;    if (this.isEmpty()) throw new Error(&quot;栈空，不能再添加元素&quot;);    return this.#data.pop();  &#125;  // 迭代器方法，用来生成迭代器对象  getIterator() &#123;    let index = 0;    let self = this;    return &#123;      isDone() &#123;        return index &gt;= self.#data.length;      &#125;,      next() &#123;        if (!this.isDone()) &#123;          return &#123;            value: self.#data[index++],            done: false,          &#125;;        &#125; else &#123;          return &#123; value: undefined, done: true &#125;;        &#125;      &#125;,    &#125;;  &#125;  // 内部迭代器  forEach(callBack) &#123;    for (var i = 0; i &lt; this.#data.length; i++) &#123;      callBack(this.#data[i], i, this);    &#125;  &#125;&#125;&gt;const stack = new Stack(5);const stack2 = new Stack(3);stack.push(1).push(2).push(3).push(4).push(5);stack.forEach((v) =&gt; &#123;  console.log(v); // 1 2 3 4 5&#125;);</code></pre><h4 id="将-class（数据类）与-迭代器类分离"><a href="#将-class（数据类）与-迭代器类分离" class="headerlink" title="将 class（数据类）与 迭代器类分离"></a>将 class（数据类）与 迭代器类分离</h4><blockquote><p>我们很多时候会有这样的需求，我可能有 10 个类，每个类都有一个自己的外部迭代器，这些迭代器的内部实现都是相同的。<br>如果我们把迭代器与某个类绑定死，那就意味着这个迭代器没有办法供 10 个类重用，只能为每个类单独写一个。</p><ul><li>所以我们可以将迭代器分类出去，单独定义成一个类，然后在其它类的内部来使用这个迭代器</li></ul></blockquote><pre><code>// 迭代器类  创建迭代器对象class DataIterator &#123;  // 私有属性  #data; // 接受传递过来用来遍历的数据对象  #index = 0; // 下标  constructor(data) &#123;    this.#data = data;  &#125;  // 判断元素是否迭代完成  isDone() &#123;    return this.#index &gt;= this.#data.length;  &#125;  // 返回下一个元素  next() &#123;    return this.isDone()      ? &#123; value: undefined, done: true &#125;      : &#123; value: this.#data[this.#index++], done: false &#125;;  &#125;&#125;&gt;// 数据类class DataContainer &#123;  #data; // 私有属性  constructor(data = []) &#123;    if (Array.isArray(data)) &#123;      this.#data = data;    &#125; else &#123;      throw new Error(&quot;传入的参数只能是一个数组&quot;);    &#125;  &#125;  // 生成迭代器对象的方法  getIterator() &#123;    return new DataIterator(this.#data);  &#125;  //..... 对象其它方法自行添加&#125;&gt;// 创建实例对象const obj = new DataContainer([&quot;A&quot;, &quot;B&quot;, &quot;C&quot;]);// 生成一个迭代器对象const it = obj.getIterator();// 调用next方法，手动遍历下一个元素console.log(it.next());console.log(it.next());console.log(it.next());console.log(it.next());&gt;const it2 = obj.getIterator();// while循环while (!it2.isDone()) &#123;  const obj = it2.next();  console.log(obj.value);&#125;</code></pre><blockquote><p><strong>解读：</strong><code>DataIterator</code> 类<br><code>DataIterator</code>类用来创建迭代器对象，有<code>#data</code>和<code>#index</code>两个私有属性，同时有<code>isDone()</code>和<code>next()</code>两个实例方法。</p><ul><li><code>#data</code>用来接受需要迭代的数据对象</li><li><code>#index</code>用来控制访问元素的下标，相当于一个指针。</li><li><code>isDone()</code>方法用来判断数据对象的成员是否迭代完成</li><li><code>next()</code>方法用来返回下一个数据对象的下一个成员</li></ul></blockquote><blockquote><p><strong>解读：</strong> <code>DataContainer</code>类<br><code>DataContainer</code>类用来模拟一个数据类，他有 <code>#data</code> 私有属性和<code>getIterator()</code>实例方法。</p><ul><li><code>#data</code>属性，用来保存 <code>DataContainer</code> 类实例化对象的数据，其类型必需是一个数组。</li><li><code>getIterator()</code> 方法用来生成一个迭代器对象，它的返回值为<code>new DataIterator(this.#data);</code>其中的<code>this.#data</code>参数为需要迭代的数据对象。</li></ul></blockquote><blockquote><p><strong>迭代器的应用</strong></p><ul><li>当我们创建一个类时，可以为这个类添加<strong>外部迭代器</strong>和<strong>内部迭代器</strong>，这样就可以在<strong>不暴露数据结构</strong>的内部结构情况下<strong>有序的</strong>访问其成员。</li><li>我们可以将数据容器类与外部迭代器类<strong>分离</strong>，这样就可以实现迭代器类的复用。</li></ul></blockquote><h3 id="二、Iterator-是什么-？"><a href="#二、Iterator-是什么-？" class="headerlink" title="二、Iterator 是什么 ？"></a>二、Iterator 是什么 ？</h3><blockquote><p><code>ES6</code>中的<code>Iterator</code>遍历器（迭代器）其实就是参考了<code>JS</code>设计模式中的迭代器模式。</p></blockquote><ol><li><p>寻找 Iterator</p><blockquote><p>查看数组原型链上继承的方法</p><ul><li>在控制台打印一个数组，查看原型</li><li>数组原型上的<code>[Symbol.iterator]</code>属性就是一个方法，也就是<code>JS</code>内置的一种外部迭代器，这个方法<strong>返回一个迭代器对象</strong>。</li></ul></blockquote></li><li><p>使用 <code>Itertaor</code></p><blockquote><p>数据结构的<code>[Symbol.iterator]</code>属性是一个函数，用来返回一个迭代器对象</p><ul><li>迭代器对象身上有一个<code>next</code>方法，调用迭代器对象的<code>next()</code>方法，返回一个<strong>对象</strong></li><li>对象有两个属性，分别为<code>value</code>和<code>done</code></li><li><code>value</code>属性值为<strong>当前成员的值</strong>，</li><li><code>done</code>属性是一个布尔值，<strong>表示遍历是否结束</strong>，false 表示未结束，true 表示结束。</li><li><code>Symbol.iterator</code>本身是一个表达式，返回<code>Symbol</code>对象的<code>iterator</code>属性，这是一个预定义好的特殊的<code>Symbol</code>类型的值。</li><li>所以作为对象的属性时，要写在<code>[]</code>方括号中</li></ul></blockquote></li></ol><pre><code>// 数组let arr = [1, 2, 3];const iterator = arr[Symbol.iterator](); // 生成可遍历对象// 调用可遍历对象的 next方法,迭代出下一个成员console.log(iterator.next());console.log(iterator.next());console.log(iterator.next());console.log(iterator.next());</code></pre><ul><li><code>while</code>循环配合迭代器，一次性有序的迭代出数组中的所有成员<blockquote><ul><li>注意：<code>[Symbol.iterator]</code>返回的迭代器对象，没有<code>isDone</code>方法，所以这里用<code>while</code>循环的方式和我们手写的外部迭代器不一样</li></ul></blockquote></li></ul><pre><code>const it = arr[Symbol.iterator]();let obj = it.next();while (!obj.done) &#123;  console.log(obj.value);  obj = it.next(); // 1  2  3&#125;</code></pre><ol start="3"><li><p><code>Iterator</code> 是什么 ？</p><blockquote><p><code>Iterator</code>是一个遍历的过程，具体如下</p><ul><li>调用数据的<code>Symbol.iterator</code>（可遍历对象的生成方法）—-&gt; 生成<code>iterator</code>（迭代器对象）—-&gt; 调用<code>iterator.next()</code> —&gt; <code>iterator.next()</code> —-&gt; …. 直到<code>next</code>方法返回值对象的<code>done</code>属性值为<code>true</code>时，才停止遍历，这样的一个完整过程称之为<code>Iterator</code><blockquote><p>数组的<code>Symbol.iterator</code>方法，可以理解为可遍历对象的生成方法，生成迭代器对象</p></blockquote></li></ul></blockquote></li><li><p>手动实现数组的<code>Symbol.iterator</code>方法</p><blockquote><p>其内部实现原理与我们讲的设计模式中的迭代器模式完全相同</p><ul><li>只是代码上稍微有一些差异，因为数组的<code>Symbol.iterator</code>方法，生成的迭代器对象只有<code>next</code>方法，<strong>没有</strong><code>isDone</code>方法。</li></ul></blockquote></li></ol><pre><code>Array.prototype[Symbol.iterator] = function () &#123;  let index = 0;  let self = this;  return &#123;    next() &#123;      return index &lt; self.length        ? &#123;            value: self[index++],            done: false,          &#125;        : &#123; value: undefined, done: true &#125;;    &#125;,  &#125;;&#125;;&gt;const arr = [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;];const it = arr[Symbol.iterator]();console.log(it.next());console.log(it.next());console.log(it.next());console.log(it.next());console.log(it.next());&gt;// 一次性迭代出数组的所有成员const it2 = arr[Symbol.iterator]();let obj = it2.next();while (!obj.done) &#123;  console.log(obj.value);  obj = it2.next();&#125;</code></pre><ul><li>用<code>while</code>循环，遍历出数组成员<blockquote><ul><li>特别注意，用<code>continue</code>的时候，避免进入死循环</li></ul></blockquote></li></ul><pre><code>//breakwhile (!obj.done) &#123;  if (obj.value === &quot;c&quot;) &#123;    break;  &#125;  console.log(obj.value);  obj = it.next();&#125;//continuewhile (!obj.done) &#123;  if (obj.value === &quot;c&quot;) &#123;    obj = it.next();    continue;  &#125;  console.log(obj.value);  obj = it.next();&#125;</code></pre><h3 id="三、for-of"><a href="#三、for-of" class="headerlink" title="三、for ... of"></a>三、<code>for ... of</code></h3><blockquote><p>通过上面的学习，我们知道，<code>Iterator</code>的使用特别的麻烦，难道以后，我们都需要那样来使用 <code>Iterator</code> 吗 ？那肯定是不用的，如果这么麻烦，那估计早就没人用了。</p><ul><li>官方也不推荐直接使用<code>Iterator</code>。所以 <code>ES6</code> 中提供了<code>for...of</code>循环来消费<code>Iterator</code>。</li></ul></blockquote><ol><li>for … of 遍历迭代器对象<blockquote><ul><li><code>for...of</code>用来遍历<strong>迭代器对象</strong>，比如数组的<code>[Symbol.iterator]</code>方法，调用这个方法，可以生成一个迭代器对象。</li></ul></blockquote></li></ol><pre><code>const arr = [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;];const it = arr[Symbol.iterator]();for (let v of it) &#123;  console.log(v);&#125;</code></pre><blockquote><p><code>ES6</code> 中的<code>数组、Set、Map</code>都有<code>keys、values、entries</code>方法，这三个方法调用后，<strong>都返回一个迭代器对象</strong>，所以可以用<code>for...of</code>来遍历他们</p></blockquote><table><thead><tr><th>方法</th><th>说明</th></tr></thead><tbody><tr><td>keys()</td><td>返回一个遍历器对象，用来遍历所有的键名</td></tr><tr><td>values()</td><td>返回一个遍历器对象，用来遍历所有的键值</td></tr><tr><td>entries()</td><td>返回一个遍历器对象，用来遍历 [键名，键值] 成的数组。</td></tr></tbody></table><pre><code>const s = new Set();console.log(s.keys());</code></pre><blockquote><img src="keys方法生成的的迭代器对象.png">- 其他方法也类似</blockquote><ul><li>数组<blockquote><ul><li>用<code>for...of</code>遍历数组的<code>keys()</code>方法可以遍历数组的下标</li><li></li></ul></blockquote></li></ul><pre><code>const arr = [1, 2, 3];console.log(arr); //arr是一个可迭代对象console.log(arr.keys()); //arr.keys()会返回一个迭代器对象for (let k of arr.keys()) &#123;  console.log(k); //0 1 2&#125;for (let k of arr.values()) &#123;  console.log(k); //1 2 3&#125;for (let k of arr.entries()) &#123;  console.log(k); // [0, 1] [1, 2] [2, 3]&#125;</code></pre><ul><li>Set<blockquote><ul><li><code>Set</code>对象没有键名，所以返回成员值</li></ul></blockquote></li></ul><pre><code>const s = new Set([1, 2, 3]);for (let k of s.keys()) &#123;  console.log(k); // 1 2 3&#125;for (let v of s.values()) &#123;  console.log(v); // 1 2 3&#125;for (let [k, v] of s.entries()) &#123;  console.log(k, v); // 1 1  2 2  3 3&#125;</code></pre><ul><li>Map</li></ul><pre><code>const m = new Map([  [&quot;数组&quot;, [&quot;a&quot;, &quot;b&quot;]],  [&quot;对象&quot;, &#123; a: 1, b: 2 &#125;],  [&quot;函数&quot;, function () &#123;&#125;],]);&gt;for (let k of m.keys()) &#123;  console.log(k);&#125;for (let v of m.values()) &#123;  console.log(v);&#125;for (let [k, v] of m.entries()) &#123;  console.log(`$&#123;k&#125;=&gt;$&#123;v&#125;`);&#125;</code></pre><blockquote><blockquote><p>注意：</p></blockquote><ul><li>迭代器对象遍历完，就不能再次使用了，因为<code>done</code>已经变成<code>true</code>了</li></ul></blockquote><ol start="2"><li>for … of 遍历可迭代对象<blockquote><p>只要一个对象身上有<code>[Symbol.iterator]</code>属性，则就可以用<code>for...of</code>来遍历对象，我们把带有<code>[Symbol.iterator]</code>属性的对象称为<strong>可遍历（迭代）对象</strong></p><ul><li>也就是说，当用<code>for...of</code>来遍历某个对象时，内部会自动调用对象的<code>[Symbol.iterator]</code>方法来<strong>生成一个迭代器对象</strong>，然后按顺序迭代对象的成员。</li><li>数组原生自带<code>[Symbol.iterator]</code>属性，所以我们可以用<code>for...of</code>来遍历其成员</li></ul></blockquote></li></ol><pre><code>const arr = [1, 2, 3];for (let v of arr) &#123;  console.log(v); // 1 2 3&#125;</code></pre><ol start="3"><li>原生可遍历对象<blockquote><p>原生可遍历对象，是指<code>JS</code>中原生自带<code>[Symbol.iterator]</code>属性的对象。<br>JS 中具原生可遍历对象有：</p><ul><li>Array 数组</li><li>Set</li><li>Map</li><li>String 字符串</li><li>arguments 、NodeList 等 类数组对象<br>因为这些数据结构原生自带<code>[Symbol.iterator]</code>属性，所以都可以利用<code>for...of</code>来遍历。</li></ul></blockquote></li></ol><ul><li>Set</li></ul><pre><code>const set = new Set([1, 2, 3]);const iterator = set[Symbol.iterator]();console.log(iterator.next());//&#123;value: 1, done: false&#125;console.log(iterator.next());//&#123;value: 2, done: false&#125;console.log(iterator.next());//&#123;value: 3, done: false&#125;console.log(iterator.next());//&#123;value: 4, done: false&#125;</code></pre><ul><li>Map</li></ul><pre><code>const map = new Map([  [[1, 3, 3], &quot;数组&quot;],  [&#123; a: 1, b: 2 &#125;, &quot;对象&quot;],]);const iterator = map[Symbol.iterator]();console.log(iterator.next());console.log(iterator.next());console.log(iterator.next());</code></pre><ul><li>String</li></ul><pre><code>const str = &quot;hello&quot;;for (let v of str) &#123;  console.log(v);&#125;// 结果: h e l l o</code></pre><ul><li>类数组</li></ul><pre><code>function sum() &#123;  for (let v of arguments) &#123;    console.log(v);  &#125;&#125;sum(1, 2, 3, 4);// 结果 1 2 3 4</code></pre><blockquote><blockquote><p>特别强调：</p></blockquote><ul><li>Object 对象，没有<code>[Symbol.iterator]</code>属性，则<strong>不能</strong>用<code>for...of</code>来遍历。</li></ul></blockquote><ol start="4"><li><p>可迭代协议和迭代器协议</p><blockquote><p><strong>可迭代协议：</strong></p><ul><li>可以理解为一个对象如果想要用<code>for...of</code>来遍历，那他身上必需要有<code>[Symbol.itrerator]</code>属性，否则是不能用<code>for...of</code>来遍历的。<br><strong>迭代器协议：</strong> </li><li>是指<strong>迭代器对象</strong>必需要有<code>next()</code>方法，其方法的返回值必需为一个<strong>对象</strong>，对象有<code>value</code>和<code>done</code>两个属性，<code>value</code>表示每次迭代的成员，<code>done</code>用来标识成员是否迭代完成。</li></ul></blockquote></li><li><p>为对象添加迭代器接口</p><blockquote><p>如果对象要能用<code>for...of</code>来遍历，则需要遵顺<strong>可迭代协议</strong>和<strong>迭代器协议</strong>。</p><ul><li>即对象身上要有<code>[Symbol.iterator]</code>属性，其为一个函数，调用该函数会返回一个<strong>迭代器对象</strong>。</li><li>迭代器对象要遵顺<strong>迭代器协议</strong>，即迭代器对象有<code>next</code>方法，方法返回值为一个对象，对象有<code>value</code>和<code>done</code>两个属性等。</li></ul></blockquote></li></ol><pre><code>const obj = &#123;  data: [1, 2, 3, 4],  [Symbol.iterator]() &#123;    let index = 0;    self = this;    return &#123;      next() &#123;        if (index &lt; self.data.length) &#123;          return &#123;            value: self.data[index++],            done: false,          &#125;;        &#125; else &#123;          return &#123;            value: undefined,            done: true,          &#125;;        &#125;      &#125;,    &#125;;  &#125;,&#125;;&gt;let it = obj[Symbol.iterator]();console.log(it.next());console.log(it.next());console.log(it.next());console.log(it.next());console.log(it.next());&gt;// 当用 for...of 来遍历obj对象时，其内部会自动调用obj的 [Symbol.iterator]方法来生成一个迭代器对象，来对其data数据中的成员遍历。for (let v of obj) &#123;  console.log(v);&#125;</code></pre><blockquote><blockquote><p>注意：</p></blockquote><ul><li>自定义的<code>[Symbol.iterator]</code>方法，单独调用，<strong>其生成的迭代器对象</strong>，不能用<code>for...of</code>来遍历。</li></ul></blockquote><pre><code>let it = obj[Symbol.iterator]();for (let v of it) &#123;  console.log(v);//报错&#125;</code></pre><ol start="6"><li>退出 for … of 循环<blockquote><p>在for…of循环语句中，可以使用</p><ul><li>break关键字退出整个循环</li><li>continue关键字来跳过当次循环</li><li>throw关键字抛出错误，同时退出循环</li><li>当在 <code>for ... of</code> 循环在一个<strong>函数体</strong>中时，可以在 <code>for ... of</code> 循环体中使用<code>return</code>关键字，返回函数的返回值</li></ul></blockquote></li></ol><ul><li>break 关键字</li></ul><pre><code>const arr = [1, 2, 3, 4, 5];for (let v of arr) &#123;  if (v === 3) &#123;    break;  &#125;  console.log(v);&#125;// 结果：  1  2</code></pre><ul><li>continue 关键字</li></ul><pre><code>const arr = [1, 2, 3, 4, 5];for (let v of arr) &#123;  if (v === 3) &#123;    continue;  &#125;  console.log(v);&#125;// 结果  1  2  4  5</code></pre><ul><li>throw 关键字</li></ul><pre><code>const arr = [1, 2, 3, 4, 5];for (let v of arr) &#123;  if (v === 3) &#123;    throw new Error(&quot;抛出错误，退出循环&quot;);  &#125;  console.log(v);&#125;// 结果  1  2  Uncaught Error: 抛出错误，退出循环</code></pre><ul><li>return 关键字</li></ul><pre><code>function fn() &#123;  const arr = [1, 2, 3, 4, 5];  for (let v of arr) &#123;    if (v === 3) &#123;      return &quot;停止&quot;;    &#125;    console.log(v);  &#125;&#125;console.log(fn());// 结果  1  2  停止</code></pre><ol start="7"><li>总结</li></ol><ul><li>可迭代对象与迭代器对象<blockquote><p><strong>可迭代对象</strong></p><ul><li>定义：带有<code>[Symbol.iterator]</code>属性的对象</li><li>与迭代器对象的关系：调用可迭代对象的<code>[Symbol.iterator]</code>方法会自动生成一个迭代器对象</li><li>原生可迭代对象包括：<code>Array</code> 数组、<code>Set</code>、<code>Map</code>、<code>String</code>字符串、<code>arguments</code> 、<code>NodeList</code>等类数组对象</li><li>可迭代协议：对象身上必需要有<code>[Symbol.itrerator]</code>属性</li></ul><p><strong>迭代器对象</strong></p><ul><li>定义：迭代器对象身上有一个<code>next</code>方法，调用这个方法，返回一个对象；对象有两个属性，分别为<code>value</code>和<code>done</code></li><li>迭代器对象包括：<ul><li>数组、<code>Set</code>、<code>Map</code>都有<code>keys、values、entries</code>方法，这三个方法调用后，都返回一个迭代器对象</li><li>调用可迭代对象的<code>[Symbol.iterator]</code>方法生成的迭代器对象</li></ul></li><li>迭代器协议：是指迭代器对象必需要有<code>next()</code>方法，其方法的返回值必需为一个对象，对象有<code>value</code>和<code>done</code>两个属性，<code>value</code>表示每次迭代的成员，<code>done</code>用来标识成员是否迭代完成。</li></ul></blockquote></li></ul><pre><code>//arr是Array的实例，自带[Symbol.iterator]方法，所以arr是可迭代对象const arr = [1, 2, 3];//调用[Symbol.iterator]方法的时候，会自动生成迭代器对象，也就是itconst it = arr[Symbol.iterator]();</code></pre><ul><li><code>for...of</code>循环<blockquote><ul><li><code>for...of</code>既可以遍历<strong>迭代器对象</strong>，也可以遍历<strong>可迭代对象</strong></li><li>如果对象要能用<code>for...of</code>来遍历，则需要遵循可迭代协议和迭代器协议<blockquote><p>因此，为对象添中迭代器接口的方式，就是使他遵循可迭代协议和迭代器协议</p></blockquote></li></ul></blockquote></li></ul><blockquote><p><strong>遍历迭代器对象：有两种</strong></p><ul><li>遍历 调用<code>[Symbol.iterator]</code>方法的时候，生成的迭代器对象</li></ul></blockquote><pre><code>const arr = [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;];const it = arr[Symbol.iterator]();for (let v of it) &#123;  console.log(v);&#125;</code></pre><blockquote><ul><li>遍历<code>keys、values、entries</code>方法调用后，返回的迭代器对象<ul><li>keys是键名，value是键值，entries是[键名，键值]的数组</li></ul></li></ul></blockquote><pre><code>const s = new Set([1, 2, 3]);for (let k of s.keys()) &#123;  console.log(k); // 1 2 3&#125;</code></pre><blockquote><p><strong>遍历可迭代对象</strong></p><ul><li>也就是原生的可迭代对象：<code>Array</code> 数组、<code>Set</code>、<code>Map</code>、<code>String</code>字符串、<code>arguments</code> 、<code>NodeList</code>等类数组对象</li></ul></blockquote><pre><code>const arr = [1, 2, 3];for (let v of arr) &#123;  console.log(v); // 1 2 3&#125;</code></pre><blockquote><ul><li>遍历<code>Array</code>的实例时，实际上是在遍历<code>valus()</code>生成的迭代器</li><li>遍历<code>Set</code>的实例时，实际上是在遍历<code>valus()</code>生成的迭代器</li><li>遍历<code>Map</code>的实例时，实际上是在遍历<code>entries()</code>生成的迭代器<blockquote><p>所以他们得到的值是一样的</p></blockquote></li></ul></blockquote><blockquote><blockquote><p>注意：</p></blockquote><ul><li>虽然可以手动为对象添中迭代器接口，也就是使他遵循可迭代协议和迭代器协议</li><li>但是调用自定义的<code>[Symbol.iterator]</code>方法，其生成的迭代器对象，不能用<code>for...of</code>来遍历。</li></ul></blockquote><blockquote><ul><li>退出<code>for ... of</code>循环的方式有<code>break</code>、<code>continue</code>、<code>throw</code>、<code>return</code></li></ul></blockquote><h3 id="四、有哪些场景使用了-Iterator-？"><a href="#四、有哪些场景使用了-Iterator-？" class="headerlink" title="四、有哪些场景使用了 Iterator ？"></a>四、有哪些场景使用了 Iterator ？</h3><blockquote><p>在<code>JS</code>这门语方中，有很多地方用到了<code>Iterator</code>，主要有</p><ul><li>for…of 循环</li><li>数组的展开运算符</li><li>数组解构赋值</li><li>Set 和 Map 构造函数的参数</li><li>Array.from()</li><li>Promise.all()</li><li>Promise.race()</li><li>yield*操作符，在生成器中使用</li></ul></blockquote><ol><li>验证方案<blockquote><p><strong>我们知道</strong></p><ul><li><strong>数组的解构赋值</strong>，等号的右边只要是一个可迭代对象就可以</li><li><strong>数组的扩展运算符</strong>后面只要是一个可迭代对象就可以<blockquote><p>其本质都是调用了对象身上的<code>[Symbol.iterator]</code>方法，生成迭代器对象，然后遍历取出对象中的成员。<br><strong>怎么验证？</strong></p></blockquote></li><li>修改对象身上的[Symbol.iterator]方法</li></ul></blockquote></li></ol><ul><li>修改前：</li></ul><pre><code>let str = &quot;hello&quot;;const [a, b] = str; // 解构赋值console.log(a, b); // h econsole.log(...str); //h e l l o</code></pre><ul><li>修改后：</li></ul><pre><code>// 接下来我们修改字符串原型上的[Symbol.iterator]方法String.prototype[Symbol.iterator] = function () &#123;  index = 0;  return &#123;    next() &#123;      if (index &lt; 3) &#123;        return &#123;          value: index++,          done: false,        &#125;;      &#125; else &#123;        return &#123;          value: undefined,          done: true,        &#125;;      &#125;    &#125;,  &#125;;&#125;;&gt;let str = &quot;hello&quot;;const [x, y] = str; // 解构赋值console.log(x, y); // 0 1&gt;// 解构赋值内部相当于执行了以下代码// const it = str[Symbol.iterator]();// x = it.next().value;// y = it.next().value;&gt;// 展开运算符console.log(...str); // 0 1 2</code></pre><blockquote><ul><li>修改了<code>String.prototype[Symbol.iterator]</code>方法，所以在解构赋值时 其结果并不是输入<code>h e</code>，而是输出了<code>0 1</code>。</li><li>说明解构赋值时，其内部就是自动调用了<code>String.prototype[Symbol.iterator]</code>方法，然后迭代内部的成员来完成解构赋值的。</li></ul></blockquote><blockquote><p><strong>关于以下使用场景</strong></p><ul><li>Set 和 Map 构造函数的参数</li><li>Array.from()</li><li>Promise.all()</li><li>Promise.race()</li><li>yield*操作符，在生成器中使用<br>其原理和上面的数组的解构赋值原理是一样的，都是调用了对象身上的<code>[Symbol.iterator]</code>方法，生成了一个迭代器对象，然后<strong>迭代内部的成员</strong>来完成相关操作。</li></ul></blockquote><ol start="2"><li>面试题<blockquote><p>编写相关代码，使下面代码成立，并且<code>a,b</code>成功赋值</p></blockquote></li></ol><pre><code>const [a, b] = &#123; a: 1, b: 2 &#125;;</code></pre><blockquote><p><strong>答案解析</strong></p><ul><li>数组的解构赋值 <code>=</code> 号右边只要是一个可迭代对象就可以，但<code>&#123;a:1, b:2&#125;</code>是一个<code>Object</code>类型的对象，他不是一个可迭代对象，也就是说他没有<code>[Symbol.iterator]</code>属性。</li><li>所以如果要使代码成立，并且 <code>a,b</code> 能成功赋值，则需要手动为<code>&#123;a:1, b:2&#125;</code>对象添加 <code>iterator</code> 接口。</li><li>迭代器是按顺序迭代成员，但对象是无序的；所以有两种方法</li></ul></blockquote><ul><li>方法一：</li></ul><pre><code>Object.prototype[Symbol.iterator] = function () &#123;  let index = -1;  const self = this;  return &#123;    next() &#123;      index++;      if (index === 0) &#123;        return &#123; value: 1, done: false &#125;;      &#125; else if (index === 1) &#123;        return &#123; value: 2, done: false &#125;;      &#125; else &#123;        return &#123; value: undefined, done: true &#125;;      &#125;    &#125;,  &#125;;&#125;;const [a, b, c] = &#123; a: 1, b: 2 &#125;;console.log(a, b, c); //1 2 undefined</code></pre><ul><li>方式二：<blockquote><ul><li><code>Object.keys(obj)</code>：返回obj的属性名</li></ul></blockquote></li></ul><pre><code>Object.prototype[Symbol.iterator] = function () &#123;  let key = Object.keys(this);  let index = 0;  const self = this;  return &#123;    next() &#123;      if (index &lt; key.length) &#123;        return &#123; value: self[key[index++]], done: false &#125;;      &#125; else &#123;        return &#123; value: undefined, done: true &#125;;      &#125;    &#125;,  &#125;;&#125;;const [a, b, c] = &#123; a: 1, b: 2 &#125;;console.log(a, b, c); //1 2 undefined</code></pre><h3 id="五、迭代器对象的-return-、throw-方法"><a href="#五、迭代器对象的-return-、throw-方法" class="headerlink" title="五、迭代器对象的 return 、throw 方法"></a>五、迭代器对象的 return 、throw 方法</h3><blockquote><p>迭代器对象除了具有<code>next()</code>方法，还可以具有<code>return</code>方法和<code>throw</code>方法。</p><ul><li>如果自己定义迭代器对象，则必需要有<code>next()</code>方法，但是 <code>return</code>和<code>throw</code>方法则是可选的。</li></ul></blockquote><ol><li><code>return</code>方法<blockquote><p>如果迭代器提前关闭时，则会<strong>自动调用</strong><code>return</code>方法。提前退出迭代器情况如下：</p><ul><li>遇到<code>break，throw，return</code>关键字时，会提前退出循环时<br>解构赋值时，未能消费所有值时<br><strong>注：</strong></li><li><code>return</code>方法的<strong>返回值，必需是一个对象</strong>，这是<code>Generator</code>规格决定的。</li><li><code>return</code>应用场景：如果一个对象在完成遍历前做某些操作，则可以为迭代器对象添加<code>return</code>方法。</li></ul></blockquote></li></ol><pre><code>class DataContainer &#123;  data = [1, 2, 3, 4];  [Symbol.iterator]() &#123;    let index = 0;    let data = this.data;    return &#123;      next() &#123;        if (index &lt; data.length) &#123;          return &#123;            value: data[index++],            done: false,          &#125;;        &#125; else &#123;          return &#123;            value: undefined,            done: true,          &#125;;        &#125;      &#125;,      return() &#123;        console.log(&quot;提前提出for...of,return方法被调用&quot;);        return &#123; done: true &#125;;      &#125;,    &#125;;  &#125;&#125;&gt;for (let v of new DataContainer()) &#123;  if (v === 2) &#123;    break;  &#125;  console.log(v);&#125; //1 //  提前提出for...of,return方法被调用</code></pre><ol start="2"><li>不能关闭的迭代器<blockquote><p>因为 <code>return</code> 方法是可选的，所以数组、<code>Set</code>、<code>Map</code>、<code>String</code>，类数组的迭代器对象上<strong>都没有</strong><code>return</code>方法。<br>当<code>for...of</code>遍历时遇到<code>break、continue、return、throw</code>，<strong>都不会关闭迭代器</strong>。</p><blockquote><p>如果一个迭代器<strong>没关闭</strong>，则还可以<strong>继承</strong>从上次离开的地方继承迭代。</p></blockquote></blockquote></li></ol><pre><code>const arr = new Set([&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;]);const it = arr[Symbol.iterator]();for (let v of it) &#123;  console.log(v); // a b  if (v === &quot;b&quot;) &#123;    break;  &#125;&#125;&gt;// 上面的迭代器没有关闭，下面继承迭代for (let v of it) &#123;  console.log(v); // c d&#125;</code></pre><h3 id="六、为什么需要迭代器和-for-…-of"><a href="#六、为什么需要迭代器和-for-…-of" class="headerlink" title="六、为什么需要迭代器和 for … of"></a>六、为什么需要迭代器和 for … of</h3><blockquote><p>在 JS 中遍历的方法有<code>for、forEach、for...in</code>，为什么还有要<code>for...of</code>呢 ？ 也就是说，为什么需要迭代器呢 ？</p><ul><li>因为迭代器主要是供<code>for...of</code>来消费的。</li></ul></blockquote><ol><li><p>对比不同的遍历方式</p><blockquote><p>那接下来我们就通过对比来了解不同遍历方式之间的差异，从而就能知道为什么还需要迭代器和<code>for...of</code></p><table><thead><tr><th>遍历方法</th><th>说明</th></tr></thead><tbody><tr><td>for</td><td>for 循环可以用来遍历数组或类数组对象，但是都需要了解其 length 属性和访问元素的方式。也就是都需要了解其内部结构。写起来也比较麻烦</td></tr><tr><td>forEach</td><td>forEach 可以用来遍历数组、Map、Set，其不需要暴露它们的内部结构，但是他只限于访问数组、Map、Set。其次 forEach 没有办法和 break、continue、return 关键字使用退出循环。</td></tr><tr><td>for…in</td><td>for…in主要是用来遍历 Object 类型的对象而用的，当然也可以用来遍历数组，但是其遍历得到的是数组的键名，而非数组的成员。其次还会遍历手动添加到数组身上的键，也会遍历原型上的键。</td></tr><tr><td>for…of</td><td>有for…in一样简洁的语法，但没有for…in的那些缺点；不同于 forEach 方法，可以与 break、continue、return 配合使用；不同于 for 循环，其遍历不需要暴露对象的内部结构；for…of提供了遍历所有数据的统一操作接口。</td></tr></tbody></table></blockquote></li><li><p>迭代器作用</p><blockquote><p>迭代器<strong>主要作用</strong>有以下 3 点：</p><ul><li>为各种不同的数据结构（对象）提供了统一的，简便的访问接口。</li><li>数据结构的成员以一定的顺序遍历出来</li><li><code>Iterator</code> 接口，主要供<code>for...of</code>消费，一个对象只要有<code>iterator</code>接口，就可以利用<code>for...of</code>来遍历</li><li>以后我们如果不想暴露对象的内部结构，而有希望能用<code>for...of</code>这种统一的方式来遍历数据成员，就可以为对象添加<code>iterator</code>接口。</li></ul></blockquote></li></ol><h2 id="ES6字符串、数组、对象的新增方法和常见应用"><a href="#ES6字符串、数组、对象的新增方法和常见应用" class="headerlink" title="ES6字符串、数组、对象的新增方法和常见应用"></a>ES6字符串、数组、对象的新增方法和常见应用</h2><h3 id="一、字符串的新增方法"><a href="#一、字符串的新增方法" class="headerlink" title="一、字符串的新增方法"></a>一、字符串的新增方法</h3><table><thead><tr><th>方法</th><th>说明</th><th>是否更改原数组</th></tr></thead><tbody><tr><td>padEnd</td><td>用一个字符串从当前字符串的末尾来填充当前字符串，使字符串达到指定长度。返回结果为填充后的新字符串。</td><td>否</td></tr><tr><td>padStart</td><td>用一个字符串从当前字符串的左侧来填充当前字符串，使字符串达到指定长度。</td><td>否</td></tr><tr><td>trimStart</td><td>方法会删除字符串开头的空白字符</td><td>否</td></tr><tr><td>trimEnd</td><td>方法会删除字符串末尾的空白字符</td><td>否</td></tr><tr><td>trim</td><td>方法从字符串的两端清除空格</td><td>否</td></tr><tr><td>startsWith</td><td>方法用来判断当前字符串是否以另外一个给定的子字符串开头</td><td>否</td></tr><tr><td>endsWith</td><td>方法用来判断当前字符串是否是以另外一个给定的子字符串“结尾”的</td><td>否</td></tr><tr><td>repeat</td><td>构造并返回一个新字符串，该字符串包含被连接在一起的指定数量的字符串的副本</td><td>否</td></tr></tbody></table><ol><li>padStart<blockquote><p>用一个字符串从当前字符串的<strong>左侧</strong>来填充当前字符串，使字符串达到指定长度。</p><ul><li>返回结果为填充后的新字符串</li></ul></blockquote></li></ol><ul><li>语法</li></ul><pre><code>padEnd(targetLength[, padString])</code></pre><blockquote><ul><li><code>targetLength</code>当前字符串需要填充到的目标长度</li><li><code>padString</code>填充字符串，如果需要的话，会反复多次来填充，默认值为空格<code> </code></li></ul></blockquote><ul><li>基本用法</li></ul><pre><code>console.log(&quot;abcd&quot;.padStart(7, &quot;*&quot;)); // ***abcdconsole.log(&quot;abcd&quot;.padStart(7, &quot;@#&quot;)); // @#@abcd</code></pre><ul><li>注意事项<blockquote><ul><li>如果<code>targetLength</code>的值<code>&lt;=</code>当前字符串的长度，则返回当前字符串本身</li></ul></blockquote></li></ul><pre><code>console.log(&quot;abcd&quot;.padStart(4, &quot;*&quot;)); // abcd</code></pre><blockquote><ul><li>如果 padString 长度过长，只会保留最左侧部分，其他部分会被截断</li></ul></blockquote><pre><code>console.log(&quot;abcd&quot;.padStart(8, &quot;01234&quot;)); // 0123abcd</code></pre><ol start="2"><li>padEnd<blockquote><p>用一个字符串从当前字符串的<strong>末尾</strong>来填充当前字符串，使字符串达到指定长度。</p><ul><li>返回结果为填充后的新字符串</li></ul></blockquote></li></ol><ul><li>语法</li></ul><pre><code>padEnd(targetLength[, padString])</code></pre><blockquote><ul><li><code>targetLength</code>当前字符串需要填充到的目标长度</li><li><code>padString</code>填充字符串，如果需要的话，会反复多次来填充</li></ul></blockquote><ul><li>基本用法</li></ul><pre><code>let str = &quot;清心&quot;.padEnd(6, &quot;爱你&quot;);console.log(str); // 清心爱你爱你&gt;let str2 = &quot;清心&quot;.padEnd(5, &quot;52&quot;);console.log(str2); // 清心525</code></pre><ul><li>注意事项<blockquote><ul><li>如果 targetLength 的值 &lt;&#x3D; 当前字符串的长度，则返回当前字符串本身</li></ul></blockquote></li></ul><pre><code>let str = &quot;清心&quot;.padEnd(2, &quot;爱你&quot;);console.log(str); // 清心</code></pre><blockquote><ul><li>如果 padString 长度过长，只会保留最左侧部分，其他部分会被截断</li></ul></blockquote><pre><code>str = &quot;清心&quot;.padEnd(5, &quot;520def&quot;);console.log(str); // 清心520</code></pre><ul><li>案例应用<blockquote><p>将以下 map 数据，在控制台以以下图形式显示出来</p></blockquote></li></ul><pre><code>const map = new Map([  [&quot;luobo&quot;, 5],  [&quot;baicai&quot;, 2.5],  [&quot;doujiao&quot;, 3],  [&quot;huacai&quot;, 5],]);</code></pre><pre><code>for ([k, v] of map) &#123;  console.log(k.padEnd(20, &quot;-&quot;) + v);&#125;</code></pre><ol start="3"><li>trimStart<blockquote><p><code>trimStart()</code>方法会删除<strong>字符串开头</strong>的空白字符。<code>trimLeft()</code>是此方法的别名</p></blockquote></li></ol><pre><code>let str = &quot;   love   &quot;;console.log(str.length); // 10str = str.trimStart(); // 去掉前面的空白字符console.log(str); // &quot;love   &quot;console.log(str.length); // 7</code></pre><ol start="4"><li>trimEnd<blockquote><p><code>trimEnd()</code>方法会删除字符串<strong>末尾</strong>的空白字符。<code>trimRight()</code>是这个方法的别名。</p></blockquote></li></ol><pre><code>let str = &quot;   love   &quot;;console.log(str.length); // 10str = str.trimEnd(); // 去掉字符串后面的空白字符console.log(str); // &quot;   love&quot;console.log(str.length); // 7</code></pre><ol start="5"><li>trim<blockquote><p><code>trim()</code>方法从字符串的<strong>两端</strong>清除空格，返回一个新的字符串，而不修改原始字符串</p><blockquote><p>这三个方法都是返回新字符串，不会改变原始字符串</p></blockquote></blockquote></li></ol><pre><code>let str = &quot;   love   &quot;;console.log(str.length); // 10str = str.trim();console.log(str); // &quot;love&quot;console.log(str.length); // 4</code></pre><ol start="6"><li>startsWith<blockquote><p><code>startsWith()</code>方法用来判断当前字符串是否以另外一个给定的子字符串<strong>开头</strong>。如果是返回<code>true</code>，否则返回<code>false</code>。</p><ul><li>注意：此方法，严格区分大小写</li></ul></blockquote></li></ol><ul><li>语法</li></ul><pre><code>str.startsWith(searchString[, position])</code></pre><blockquote><ul><li><code>searchString</code> 要搜索的子字符串</li><li><code>position</code> 可选参数在<code>str</code>中搜索<code>searchString </code>的开始位置，默认值为<code>0</code></li></ul></blockquote><ul><li>基本用法</li></ul><pre><code>console.log(&quot;data_iconfont&quot;.startsWith(&quot;data_&quot;)); // trueconsole.log(&quot;data_iconfont&quot;.startsWith(&quot;data-&quot;)); // falseconsole.log(&quot;data_iconfont&quot;.startsWith(&quot;icon&quot;, 4)); // falseconsole.log(&quot;data_iconfont&quot;.startsWith(&quot;icon&quot;, 5)); // true</code></pre><ol start="7"><li>endsWith<blockquote><p><code>endsWith()</code>方法用来判断当前字符串是否是以另外一个给定的子字符串<strong>“结尾”</strong>的。</p><ul><li>如果是，返回结果为true，否则为 false。</li><li>注意：此方法，严格区分大小写</li></ul></blockquote></li></ol><ul><li>语法</li></ul><pre><code>str.endsWith(searchString[, length])searchString : 要搜索的子字符串length ： 作为 str 的长度。默认值为 str.length</code></pre><ul><li>基本用法</li></ul><pre><code>console.log(&quot;data_iconfont&quot;.endsWith(&quot;font&quot;)); // trueconsole.log(&quot;data_iconfont&quot;.endsWith(&quot;t&quot;)); // trueconsole.log(&quot;data_iconfont&quot;.endsWith(&quot;con&quot;, 9)); // trueconsole.log(&quot;data_iconfont&quot;.startsWith(&quot;con&quot;, 10)); // false</code></pre><ol start="8"><li>repeat 方法<blockquote><p>构造并返回一个新字符串，该字符串包含被连接在一起的<strong>指定数量</strong>的字符串的副本。</p></blockquote></li></ol><ul><li>语法</li></ul><pre><code>str.repeat(count);</code></pre><blockquote><ul><li><code>count</code>是介于<code>0</code>和<code>+Infinity</code>之间的整数。表示在新构造的字符串中<strong>重复了多少遍</strong>原字符串。</li></ul></blockquote><pre><code>// &quot;abc&quot;.repeat(-1); // 报错console.log(&quot;abc&quot;.repeat()); // &quot;&quot;console.log(&quot;abc&quot;.repeat(0)); // &quot;&quot;console.log(&quot;abc&quot;.repeat(1)); // abcconsole.log(&quot;abc&quot;.repeat(2)); // abcabcconsole.log(&quot;abc&quot;.repeat(3)); // abcabcabc</code></pre><h3 id="二、数组新增方法"><a href="#二、数组新增方法" class="headerlink" title="二、数组新增方法"></a>二、数组新增方法</h3><ul><li>数组相关的实例方法<table><thead><tr><th>实例方法</th><th>说明</th><th>是否更改原数组</th></tr></thead><tbody><tr><td>map</td><td>创建一个新数组，这个新数组由原数组中的每个元素都调用一次提供的函数后的返回值组成。</td><td>否</td></tr><tr><td>some</td><td>方法测试数组中是不是至少有 1 个元素通过了被提供的函数测试</td><td>否</td></tr><tr><td>every</td><td>测试一个数组内的所有元素是否都能通过某个指定函数的测试</td><td>否</td></tr><tr><td>reduce</td><td>reducer 逐个遍历数组元素，每一步都将当前元素的值与上一步的计算结果做相关操作，直到没有更多元素相加</td><td>否</td></tr><tr><td>reduceRight</td><td>与 reduce 一样，只是他默认的从数组的尾元素开始，即从右向左</td><td></td></tr><tr><td>keys</td><td>返回一个遍历器对象，用来遍历所有的键名</td><td>否</td></tr><tr><td>values</td><td>返回一个遍历器对象，用来遍历所有的键值</td><td>否</td></tr><tr><td>entries</td><td>返回一个遍历器对象，用来遍历**[键名，键值]**组成的数组</td><td>否</td></tr><tr><td>fill</td><td>方法用一个固定值填充一个数组中从起始索引到终止索引内的全部元素。不包括终止索引。</td><td>是</td></tr><tr><td>copyWithin</td><td>访方法浅复制数组的一部分到同一数组中的另一个位置，会覆盖原数组成员，但不会改变原数组的长度。返回改变后的原数组</td><td>是</td></tr><tr><td>flat</td><td>flat 方法用于将数组按指定层级来扁平化（展开）。返回值为一个新的数组</td><td>否</td></tr><tr><td>flatMap</td><td>flatMap 方法相当于数组的 map 方法和 flat 方法的合并用法</td><td>否</td></tr><tr><td>at</td><td>返回数组指定索引的元素。索引值允许正数和负数。</td><td>否</td></tr></tbody></table></li></ul><blockquote><ul><li>关于数组的：includes、find、findIndex 方法，之前讲完，这里就不再重复</li></ul></blockquote><ul><li>数组的静态方法<table><thead><tr><th>静态方法</th><th>说明</th></tr></thead><tbody><tr><td>Array.from</td><td>对一个类似数组或可迭代对象创建一个新的，浅拷贝的数组实例。</td></tr><tr><td>Array.of</td><td>通过可变数量的参数创建一个新的<code>Array</code>实例</td></tr></tbody></table></li></ul><ol><li>map 方法<blockquote><p><code>map()</code>方法创建一个新数组，这个新数组由原数组中的每个元素都调用一次提供的函数后的<strong>返回值</strong>组成。</p></blockquote></li></ol><ul><li>语法</li></ul><pre><code>map(function (element, index, array) &#123;  /* … */&#125;, thisArg);// 或map((element, index, array) =&gt; &#123;&#125;);</code></pre><blockquote><ul><li>回调函数中的三个参数<ul><li>element 表示数组中正在处理的当前元素</li><li>index 数组中正在处理的当前元素的索引</li><li>array 调用 map 方法的数组</li></ul></li><li>thisArg 可选参数，用来更改回调函数中的 this 指向，如果回调函数为箭头函数，则 this 更改无效</li></ul></blockquote><ul><li>基础应用<blockquote><ul><li>将数组中每个元素乘以 2</li></ul></blockquote></li></ul><pre><code>const arr = [1, 2, 3];const newArr = arr.map((value) =&gt; value * 2);console.log(newArr); // [2, 4, 6]</code></pre><blockquote><ul><li>求数组中每个元素的平方<blockquote><p><code>Math.pow(value,n)</code>：求value的n次方</p></blockquote></li></ul></blockquote><pre><code>const arr = [1, 2, 3];const newArr = arr.map((value) =&gt; Math.pow(value, 2));console.log(newArr); // [1, 4, 9]</code></pre><blockquote><ul><li>获取字符串中每个字符对应的<code>ASCII</code>码的映射关系<blockquote><p>让字符串使用数组的方法：调用数组的原型方法，改变<code>this</code>指向<br><code>charCodeAt(index)</code>方法获取<code>ASCII</code> 码</p></blockquote></li></ul></blockquote><pre><code>const str = &quot;hello&quot;;const charCods = Array.prototype.map.call(str, (value) =&gt; &#123;  return &#123;    [value]: value.charCodeAt(0),  &#125;;&#125;);console.log(charCods);</code></pre><ul><li>回调函数中 this 指向</li></ul><pre><code>const arr = [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;];const obj = &#123; a: 1, b: 2 &#125;;arr.map(() =&gt; &#123;  console.log(this); // window&#125;, obj);&gt;arr.map(function () &#123;  console.log(this); // &#123; a: 1, b: 2 &#125;&#125;, obj);</code></pre><ol start="2"><li>some 方法<blockquote><p><code>some()</code>方法测试数组中是不是<strong>至少有 1 个元素</strong>通过了被提供的函数测试。</p><ul><li>即：只要有一个通过测试，返回值就为 true，否则为 false</li></ul></blockquote></li></ol><ul><li>语法</li></ul><pre><code>some(function (element, index, array) &#123;  /* … */&#125;, thisArg);// 或some((element, index, array) =&gt; &#123;  /* … */&#125;);</code></pre><blockquote><ul><li>回调函数中的三个参数<ul><li>element 表示数组中正在处理的当前元素</li><li>index 数组中正在处理的当前元素的索引</li><li>array 调用some方法的数组</li></ul></li><li>thisArg 可选参数，用来更改回调函数中的 this 指向，如果回调函数为箭头函数，则 this 更改无效</li></ul></blockquote><ul><li>基本用法<blockquote><ul><li>测试数组中是否存在偶数</li></ul></blockquote></li></ul><pre><code>const result = [1, 3, 5, 7, 9].some((value) =&gt; value % 2 === 0);console.log(result); // false&gt;const result2 = [1, 4, 5, 7, 9].some((value) =&gt; value % 2 === 0);console.log(result2); // true</code></pre><ul><li>检测以下数组中，蔬菜价格是否有大于 10 元的</li></ul><pre><code>const arr = [  &#123; name: &quot;白菜&quot;, price: 7 &#125;,  &#123; name: &quot;西蓝花&quot;, price: 11 &#125;,  &#123; name: &quot;豆角&quot;, price: 9 &#125;,];&gt;const result = arr.some((v) =&gt; v.price &gt;= 10);console.log(result); //true</code></pre><ol start="3"><li>every 方法<blockquote><p><code>every()</code>方法测试一个数组内的<strong>所有元素</strong>是否都能通过某个指定函数的测试</p><ul><li>即：只有数组中所有元素通过测试，返回值才为 true，否则为 false</li></ul></blockquote></li></ol><ul><li>语法</li></ul><pre><code>every(function (element, index, array) &#123;  /* … */&#125;, thisArg);// 或every((element, index, array) =&gt; &#123;  /* … */&#125;);</code></pre><blockquote><ul><li>回调函数中的三个参数<ul><li>element 表示数组中正在处理的当前元素</li><li>index 数组中正在处理的当前元素的索引</li><li>array 调用every方法的数组</li></ul></li><li>thisArg 可选参数，用来更改回调函数中的 this 指向，如果回调函数为箭头函数，则 this 更改无效</li></ul></blockquote><ul><li>基本用法<blockquote><ul><li>检测数组中是否所有元素都小于 100</li></ul></blockquote></li></ul><pre><code>const result1 = [20, 30, 40, 50, 120].every((v) =&gt; v &lt; 100);console.log(result1); // false&gt;const result2 = [20, 30, 40, 50, 10].every((v) =&gt; v &lt; 100);console.log(result2); // true</code></pre><ol start="4"><li>reduce 方法<blockquote><p><code>reduce()</code>方法对数组中的每个元素<strong>按序执行</strong>一个由您提供的 <code>reducer</code> 函数，每一次运行 <code>reducer</code> 会将<strong>先前元素</strong>的计算结果作为参数传入，最后将其结果汇总为单个返回值。</p></blockquote></li></ol><blockquote><ul><li>第一次执行回调函数时，不存在“上一次的计算结果”。如果不需要回调函数从数组索引为<code>0</code>的元素开始执行，就传递初始值。</li><li>否则，数组索引为 <code>0</code> 的元素将被作为初始值 <code>initialValue</code>，迭代器将从第二个元素开始执行（索引为 1 而不是 0）</li></ul></blockquote><ul><li>语法</li></ul><pre><code>reduce(function (previousValue, currentValue, currentIndex, array) &#123;  /* … */&#125;, initialValue);</code></pre><blockquote><ul><li><code>initialValue</code>可选参数，作为第一次调用<code>callback</code>函数时参数<code>previousValue</code>的值</li><li>回调函数中的 4 个参数，分别表示：<table><thead><tr><th>参数</th><th>说明</th></tr></thead><tbody><tr><td>previousValue</td><td>上一次调用 callbackFn 时的返回值。在第一次调用时，若指定了初始值 initialValue，其值则为 initialValue，否则为数组索引为 0 的元素 array[0]</td></tr><tr><td>currentValue</td><td>数组中正在处理的元素。在第一次调用时，若指定了初始值 initialValue，其值则为数组索引为 0 的元素 array[0]，否则为 array[1]</td></tr><tr><td>currentIndex</td><td>数组中正在处理的元素的索引。若指定了初始值 initialValue，则起始索引号为 0，否则从索引 1 起始</td></tr><tr><td>array</td><td>用于遍历的数组</td></tr></tbody></table></li></ul></blockquote><ul><li>基本用法<blockquote><ul><li>没有传入<code>initialValue</code>参数时，第一次调用 <code>callBackFn</code>，即<code>previousValue = array[0]</code>、<code>currentValue = array[1]</code></li></ul></blockquote></li></ul><pre><code>const result = [1, 2, 3, 4].reduce(  (previousValue, currentValue, currentIndex, array) =&gt; &#123;    console.log(previousValue, currentValue, currentIndex, array);    return previousValue;  &#125;);</code></pre><blockquote><table><thead><tr><th>回调函数调用</th><th>previousValue</th><th>currentValue</th><th>currentIndex</th><th>array</th><th>返回值</th></tr></thead><tbody><tr><td>第一次</td><td>1</td><td>2</td><td>1</td><td>[1, 2, 3, 4]</td><td>1</td></tr><tr><td>第二次</td><td>1</td><td>3</td><td>2</td><td>[1, 2, 3, 4]</td><td>1</td></tr><tr><td>第三次</td><td>1</td><td>4</td><td>3</td><td>[1, 2, 3, 4]</td><td>1</td></tr></tbody></table><blockquote><p>最终返回值为最后一次回调函数的返回值： 1</p></blockquote></blockquote><ul><li>传入<code>initialValue</code>参数时，即<code>previousValue = initialValue、currentValue = array[0]</code></li></ul><pre><code>const result = [1, 2, 3, 4].reduce(  (previousValue, currentValue, currentIndex, array) =&gt; &#123;    console.log(previousValue, currentValue, currentIndex, array);    return previousValue;  &#125;,  10);console.log(result);</code></pre><table><thead><tr><th>回调函数调用</th><th>previousValue</th><th>currentValue</th><th>currentIndex</th><th>array</th><th>返回值</th></tr></thead><tbody><tr><td>第一次</td><td>10</td><td>1</td><td>0</td><td>[1, 2, 3, 4]</td><td>10</td></tr><tr><td>第二次</td><td>10</td><td>2</td><td>1</td><td>[1, 2, 3, 4]</td><td>10</td></tr><tr><td>第三次</td><td>10</td><td>3</td><td>2</td><td>[1, 2, 3, 4]</td><td>10</td></tr><tr><td>第四次</td><td>10</td><td>4</td><td>3</td><td>[1, 2, 3, 4]</td><td>10</td></tr></tbody></table><blockquote><blockquote><p>最终返回值为最后一次回调函数的返回值： 10</p></blockquote></blockquote><ul><li>案例应用<blockquote><ul><li>求数组中所有元素之和</li></ul></blockquote></li></ul><pre><code>const result = [10, 20, 30, 40].reduce((previousValue, currentValue) =&gt; &#123;  return previousValue + currentValue;&#125;);console.log(result);</code></pre><blockquote><ul><li>数组去重</li></ul></blockquote><pre><code>const result = [1, 2, 2, 3, 3, 4, 5].reduce((prev, current) =&gt; &#123;  if (!prev.includes(current)) &#123;    prev.push(current);  &#125;  return prev;&#125;, []);console.log(result); // [1, 2, 3, 4, 5]</code></pre><blockquote><ul><li>求数组中最大值</li></ul></blockquote><pre><code>const result = [1, 2, 10, 4, 5, 40].reduce((prev, current) =&gt; &#123;  return Math.max(prev, current);&#125;);console.log(result); // 40</code></pre><blockquote><ul><li>计算数组中每个元素出现的次数</li></ul></blockquote><pre><code>const result = [&quot;a&quot;, &quot;b&quot;, &quot;a&quot;, &quot;c&quot;, &quot;b&quot;, &quot;d&quot;].reduce((prev, current) =&gt; &#123;  prev.set(current, (prev.get(current) || 0) + 1);  return prev;&#125;, new Map());console.log(result); // Map(4) &#123;&#39;a&#39; =&gt; 2, &#39;b&#39; =&gt; 2, &#39;c&#39; =&gt; 1, &#39;d&#39; =&gt; 1&#125;</code></pre><ol start="5"><li>keys、values、entries 方法<table><thead><tr><th>方法</th><th>说明</th></tr></thead><tbody><tr><td>keys()</td><td>返回一个遍历器对象，用来遍历所有的键名</td></tr><tr><td>values()</td><td>返回一个遍历器对象，用来遍历所有的键值</td></tr><tr><td>entries()</td><td>返回一个遍历器对象，用来遍历 [键名，键值] 组成的数组。</td></tr></tbody></table></li></ol><pre><code>const arr = [&quot;a&quot;, &quot;b&quot;, &quot;a&quot;];&gt;// 遍历数组的所有键名for (let k of arr.keys()) &#123;  console.log(k); // 0 1 2&#125;// 遍历数组的所有键值for (let v of arr.values()) &#123;  console.log(v); // a b a&#125;// 遍历由数组的 [键名，键值] 组成的数组，然后参于数组的解构赋值for (let [k, v] of arr.entries()) &#123;  console.log(`$&#123;k&#125; =&gt; $&#123;v&#125;`);  // 结果  // 0 =&gt; a    1 =&gt; b   2 =&gt; a&#125;</code></pre><ol start="6"><li>fill 方法<blockquote><p><code>fill()</code>方法用一个<strong>固定值</strong>填充一个数组中从起始索引到终止索引内的全部元素。不包括终止索引。</p><ul><li>返回结果：修改后的数组。</li></ul></blockquote></li></ol><ul><li>语法：</li></ul><pre><code>fill(value, start, end); // 参数 start 和 end为可选参数</code></pre><blockquote><ul><li>value：用来填充数组元素的值</li><li>start：可选参数，起始索引，默认值为 0 ，如果值为<strong>负数</strong>，则索引值会被自动计算为数组<code>length+start</code></li><li>end: 可选参数，终止索引，默认值为 <code>arr.length</code>, 如果值为<strong>负数</strong>，则索引值会被自动计算为数组<code>length+start</code></li></ul></blockquote><pre><code>console.log([1, 2, 3].fill(&quot;a&quot;)); //  [&#39;a&#39;, &#39;a&#39;, &#39;a&#39;]console.log([1, 2, 3].fill(&quot;a&quot;, 1)); // [1, &#39;a&#39;, &#39;a&#39;]console.log([1, 2, 3, 4, 5].fill(&quot;a&quot;, 1, 4)); //  [1, &#39;a&#39;, &#39;a&#39;, &#39;a&#39;, 5]console.log([1, 2, 3, 4, 5].fill(&quot;a&quot;, -4, -1)); // [1, &#39;a&#39;, &#39;a&#39;, &#39;a&#39;, 5]console.log([1, 2, 3, 4, 5].fill(&quot;a&quot;, -1, -4)); //4&gt;1  [1, 2, 3, 4, 5]</code></pre><blockquote><blockquote><p>如果自动计算后，起始索引&gt;结束索引，那就返回原数组</p></blockquote></blockquote><ul><li>注意事项<blockquote><ul><li><code>fill()</code>方法被设计为一个<strong>通用</strong>方法，其方法内部的 <code>this</code> 不一定非要是数组，可以利用 <code>call</code> 来修改，也就是说，<code>fill()</code>方法，可以用来操作<strong>类数组对象</strong></li><li>类数组对象：<blockquote><p>必须要有<code>length</code>属性</p></blockquote></li></ul></blockquote></li></ul><pre><code>console.log([].fill.call(&#123; a: 1, b: 2, c: 3, length: 3 &#125;, 8));//&#123;0: 8, 1: 8, 2: 8, a: 1, b: 2, c: 3, length: 3&#125;console.log([].fill.call(&#123; length: 3 &#125;, 8));//&#123;0: 8, 1: 8, 2: 8, length: 3&#125;</code></pre><blockquote><ul><li>默认情况下，<code>value</code>按<code>length</code>属性的长度填充，键名为从0开始的数字，键值为<code>value</code></li><li>如果有起始&#x2F;结束索引，规则和上面一样，最长为<code>length</code>属性规定的长度</li></ul></blockquote><ul><li><code>fill()</code>中用来填充的数据，如果是一个<strong>引用类型</strong>，会导致执行同一个引用</li></ul><pre><code>const arr = [1, 2, 3, 4];arr.fill(&#123;&#125;, 1);console.log(arr); // [1,&#123;&#125;,&#123;&#125;,&#123;&#125;]console.log(arr[1] === arr[2]); //true&gt;arr[1].a = 1;console.log(arr); // [1,&#123;a:1&#125;,&#123;a:1&#125;,&#123;a:1&#125;]</code></pre><ol start="7"><li>copyWithin<blockquote><p><code>copyWithin()</code>方法<strong>浅复制</strong>数组的一部分到同一数组中的另一个位置，会覆盖原有成员。不会改变原数组的长度。</p><ul><li>返回结果为改变后的<strong>原数组</strong></li></ul></blockquote></li></ol><ul><li>语法</li></ul><pre><code>copyWithin(target, start, end);</code></pre><blockquote><ul><li>target 目标索引，从该位置开始替换数据<ul><li>如果为<strong>负数</strong>，其值相当于等于<code>arr.length + start</code></li><li>如果<strong>大于</strong><code>arr.length</code>，将不发生拷贝。</li><li>如果在<code>start</code>和<code>end</code>之后，复制的序列将被修改长度，超出部分去掉，以符合<code>arr.length</code></li></ul></li><li>start 可选，从该位置开始读取数据。默认值为 0 ，如果为<strong>负数</strong>，其值等于<code>arr.length + start</code></li><li>end 可选，到该位置停止读取数据。默认值为<code>arr.length</code>， 如果为<strong>负数</strong>，其值等于 <code>arr.length + end</code><blockquote><p>如果自动计算后，起始索引&gt;结束索引，那就返回原数组</p></blockquote></li></ul></blockquote><ul><li>基本用法</li></ul><pre><code>[1, 2, 3, 4, 5].copyWithin(0, 2); //  [3, 4, 5, 4, 5][1, 2, 3, 4, 5, 6].copyWithin(2, 3, 5); // [1, 2, 4, 5, 5, 6][1, 2, 3, 4, 5, 6].copyWithin(4, 2, 5); // [1, 2, 3, 4, 3, 4];[1, 2, 3, 4, 5, 6].copyWithin(1, -4, -2); // [1, 3, 4,4, 5, 6];[1, 2, 3, 4, 5, 6].copyWithin(1, -2, -4); //  不变 [1, 2, 3, 4, 5, 6]</code></pre><blockquote><ul><li><code>copyWithin</code>方法，利用<code>call</code>方法改变内部<code>this</code>，也可以用来操作类数组对象</li></ul></blockquote><pre><code>let obj = &#123; 0: &quot;a&quot;, 1: &quot;b&quot;, 2: &quot;c&quot;, 3: &quot;d&quot;, 4: &quot;e&quot;, length: 5 &#125;;obj = [].copyWithin.call(obj, 0, 1, 3);console.log(obj); // &#123;0: &#39;b&#39;, 1: &#39;c&#39;, 2: &#39;c&#39;, 3: &#39;d&#39;, 4: &#39;e&#39;, length: 5&#125;</code></pre><blockquote><ul><li>只替换键值</li></ul></blockquote><ol start="8"><li>flat 方法<blockquote><p><code>flat</code>方法用于将数组<strong>按指定层级</strong>来扁平化（展开）。</p><ul><li>返回值为一个新的数组</li></ul></blockquote></li></ol><ul><li>语法</li></ul><pre><code>flat(depth);</code></pre><blockquote><ul><li><code>depth</code>可选参数，默认值为1，用来指定数组的展开层级。如果值<code>&lt;= 0</code>，表示不展开</li><li><code>depth</code>是几，就表示去掉几个<code>[]</code></li></ul></blockquote><ul><li>基本应用<blockquote><ul><li>扁平化嵌套数组<blockquote><p>使用<code>Infinity</code>，可以展开任意深度的嵌套</p></blockquote></li></ul></blockquote></li></ul><pre><code>const arr1 = [1, [2, [3, 4]], 5];const arr2 = arr1.flat();console.log(arr2);console.log(arr1 === arr2); // false&gt;console.log([1, [2, [3, 4]], 5].flat(2)); //  [1, 2, 3, 4, 5]&gt;// 使用 Infinity，可以展开任意深度的嵌套const arr = [1, [2, [3, 4, [5, [6], 7], 8], 9]];console.log(arr.flat(Infinity)); // [1, 2, 3, 4, 5, 6, 7, 8, 9]</code></pre><blockquote><ul><li>移除数组中的空项<blockquote><p>在最外层的空项才会被移除</p></blockquote></li></ul></blockquote><pre><code>const arr = [1, [, , [, 2, 3, ,], 4], 5, 6];console.log(arr.flat(0)); //[1, [, , [, 2, 3, ,], 4], 5, 6]console.log(arr.flat(1)); // [1, [, 2, 3, ,], 4, 5, 6]console.log(arr.flat(2)); //[1, 2, 3, 4, 5, 6]</code></pre><ol start="9"><li>flatMap 方法<blockquote><p><code>flatMap</code> 方法相当于数组的 <code>map</code> 方法和 <code>flat</code> 方法的<strong>合并</strong>用法。<br>数组调用<code>flatMap</code>方法，相当于<strong>先</strong>调用数组的<code>map</code>，然后再将返回的结果数组<strong>再</strong>调用 <code>flat()</code> 方法展开，展开深度为 <code>1</code>。</p><ul><li>返回值为一个新的数组。</li></ul></blockquote></li></ol><ul><li>语法</li></ul><pre><code>flatMap(function (currentValue, index, array) &#123;  /* … */&#125;, thisArg);</code></pre><blockquote><ul><li>callBack 回调函数的三个参数<ul><li>currentValue： 当前正在数组中处理的元素</li><li>index：可选的。数组中正在处理的当前元素的索引</li><li>array：可选的。被调用的 map 数组</li></ul></li><li>thisArg 可选的，用来更改 callBack 回调函数中的 this 指向</li></ul></blockquote><ul><li>基本用法：</li></ul><pre><code>const arr = [1, 2, 3, 4];const res = arr.flatMap((x) =&gt; [x * 2]);console.log(res); // [2, 4, 6, 8]&gt;// 上面代码 arr.flatMap((x) =&gt; [x * 2]) 的内部相当于执行了以下两步const arr2 = arr.map((x) =&gt; [x * 2]);const res2 = arr2.flat();console.log(res2);// [2, 4, 6, 8]</code></pre><blockquote><ul><li>将几句话的数组拆份成单个词组成的新数组</li></ul></blockquote><pre><code>const arr = [&quot;Happy New Year&quot;, &quot;May you be happy and prosperous&quot;];const word = arr.flatMap((v) =&gt; v.split(&quot; &quot;));console.log(word); // [&#39;Happy&#39;, &#39;New&#39;, &#39;Year&#39;, &#39;May&#39;, &#39;you&#39;, &#39;be&#39;, &#39;happy&#39;, &#39;and&#39;, &#39;prosperous&#39;]</code></pre><ol start="10"><li>at 方法<blockquote><p>返回数组<strong>指定索引</strong>的元素。索引值允许正数和负数。<strong>负数</strong>表示从末尾开始。</p></blockquote></li></ol><ul><li>语法</li></ul><pre><code>at(index); // index为整数，正数负数都可以</code></pre><ul><li>基本用法</li></ul><pre><code>[1, 2, 3].at(1); // 2[1, 2, 3].at(-1); // 3</code></pre><ol start="11"><li>Array.from 方法<blockquote><p><code>Array.form()</code>方法对一个类似数组或可迭代对象创建一个新的，<strong>浅拷贝</strong>的<strong>数组实例</strong>。</p><ul><li>返回值：一个新的数组实例</li></ul></blockquote></li></ol><ul><li>语法</li></ul><pre><code>Array.from(  arrayLike,  function mapFn(element, index) &#123;    /* … */  &#125;,  thisArg);</code></pre><ul><li><p>参数</p><blockquote><ul><li>arrayLike：想要转换成数组的伪数组对象或可迭代对象</li><li>mapFn：如果指定了该参数，新数组中的每个元素会执行该回调函数。相当于对新生成的数组实例，再调用 map 方法</li><li>thisArg：可选参数，执行回调函数 mapFn 时 this 对象。 默认 this 指向<code>window</code></li></ul></blockquote></li><li><p>基本应用</p><blockquote><ul><li>string 类型生成数组</li></ul></blockquote></li></ul><pre><code>Array.from(&quot;hello&quot;);// [&#39;h&#39;, &#39;e&#39;, &#39;l&#39;, &#39;l&#39;, &#39;o&#39;]</code></pre><blockquote><ul><li>Set 生成数组</li></ul></blockquote><pre><code>const set = new Set([&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;]);console.log(Array.from(set)); // [&#39;a&#39;, &#39;b&#39;, &#39;c&#39;, &#39;d&#39;]</code></pre><ul><li>Map 生成二维数组</li></ul><pre><code>const map = new Map([  [&quot;a&quot;, 1],  [&quot;b&quot;, 2],  [&quot;c&quot;, 3],]);console.log(Array.from(map)); // [[&quot;a&quot;, 1],[&quot;b&quot;, 2],[&quot;c&quot;, 3]]&gt;// 传入第二个参数let res = Array.from(map, (v) =&gt; v[1]);console.log(res); // [1, 2, 3]&gt;// 传入第三个参数，修改this指向let res = Array.from(map, (v, i) =&gt; this[i], [&quot;foo&quot;, &quot;bar&quot;, &quot;zoo&quot;]);console.log(res); // [undefined, undefined, undefined]&gt;// 修改this只能是普通函数let res2 = Array.from(  map,  function (v, i) &#123;    return this[i];  &#125;,  [&quot;foo&quot;, &quot;bar&quot;, &quot;zoo&quot;]);console.log(res2);</code></pre><ol start="12"><li>Array.of 方法<blockquote><p><code>Array.of()</code>方法通过可变数量的参数创建一个新的<code>Array</code>实例，而不考虑参数的数量或类型。</p></blockquote></li></ol><ul><li>语法</li></ul><pre><code>Array.of(element0, element1, /* … ,*/ elementN);</code></pre><ul><li>基本用法</li></ul><pre><code>Array.of(); // []Array.of(1); // [1]Array.of(1, 2, 3); // [1, 2, 3]</code></pre><blockquote><blockquote><p>此方法主要目的是：</p></blockquote><ul><li>弥补数组构造函数 Array() 的不足</li><li><code>Array.of()</code>和<code>Array()</code>构造函数之间的<strong>区别</strong>在于对单个参数的处理：<ul><li>Array.of(7) 创建一个具有单个元素 7 的数组</li><li>而 Array(7) 创建一个 length 为 7 的空数组</li></ul></li><li>这意味着一个由7个空槽组成的数组，而不是具有实际 <code>undefined</code>值的槽</li></ul></blockquote><pre><code>Array.of(7); // [7]new Array(7); //  [empty × 7]</code></pre><ul><li>模拟 ArrayOf 方法</li></ul><pre><code>Array.of = function () &#123;  return [].slice.call(arguments);&#125;;</code></pre><h3 id="三、对象新增方法"><a href="#三、对象新增方法" class="headerlink" title="三、对象新增方法"></a>三、对象新增方法</h3><blockquote><p>对象的静态方法</p><table><thead><tr><th>静态方法</th><th>说明</th></tr></thead><tbody><tr><td><code>Object.is()</code></td><td>方法判断两个值是否为同一个值</td></tr><tr><td><code>Object.assign()</code></td><td>方法用于将源(source)对象的所有可枚举的自有属性复制到目标 target 对象</td></tr><tr><td><code>Object.freeze</code></td><td>方法可以冻结一个对象</td></tr><tr><td><code>Object.keys()</code></td><td>返回一个由一个给定对象的自身可枚举属性组成的数组</td></tr><tr><td><code>Object.values()</code></td><td>返回一个给定对象自身的所有可枚举属性值的数组</td></tr><tr><td><code>Object.entrie()</code></td><td>返回一个给定对象自身可枚举属性的键值对数组</td></tr><tr><td><code>Object.getOwnPropertyDescriptor()</code></td><td>方法返回指定对象上一个自有属性对应的属性描述符</td></tr><tr><td><code>Object.getOwnPropertyDescriptors()</code></td><td>方法用来获取一个对象的所有自身属性的描述符</td></tr><tr><td><code>Object.getOwnPropertyNames()</code></td><td>返回一个由指定对象的所有自身属性的属性名（包括不可枚举属性但不包括 Symbol 值作为名称的属性）组成的数组</td></tr><tr><td><code>Object.getOwnPropertySymbols()</code></td><td>方法返回一个给定对象自身的所有 Symbol 属性的数组</td></tr><tr><td><code>Object.fromEntries()</code></td><td>方法把键值对列表转换为一个对象</td></tr><tr><td><code>Object.setPrototypeOf()</code></td><td>设置一个指定的对象的原型（即，内部<code>[[Prototype]]</code>属性）到另一个对象或 null</td></tr><tr><td><code>Object.getPrototypeOf()</code></td><td>方法返回指定对象的原型</td></tr></tbody></table></blockquote><ol><li>Object.is 方法<blockquote><p><code>Object.is()</code>方法判断两个值是否为同一个值。如果是同一个值，返回 <code>true</code>,否则返回 <code>false</code>。</p><ul><li>其判断标准与<code>===</code>相似，唯一的差别在于他两对<strong>零值</strong>和<code>NaN</code>的判断不同</li><li><code>===</code>中认为<code>0</code>,<code>-0</code>,<code>+0</code>是同一个值，<code>NaN</code>和<code>NaN</code> 是不同的值</li><li><code>Object.is()</code>中认为0,-0,+0 三者中<strong>只有0、+0是同值</strong>，<code>NaN</code>和<code>NaN</code> 是相同的值</li></ul></blockquote></li></ol><pre><code>console.log(Object.is(1, 1)); // trueconsole.log(Object.is(true, 1)); // falseconsole.log(Object.is([], [])); // false&gt;console.log(NaN === NaN); // falseconsole.log(0 === -0); // trueconsole.log(0 === +0); // trueconsole.log(-0 === +0); // true&gt;console.log(Object.is(NaN, NaN)); // trueconsole.log(Object.is(0, -0)); // falseconsole.log(Object.is(0, +0)); // trueconsole.log(Object.is(-0, +0)); // false</code></pre><ol start="2"><li>Objec.assign 方法<blockquote><p><code>Object.assign()</code>方法用于将源（source）对象的所有<strong>可枚举的自有属性</strong>复制到目标<code>target</code>对象。</p><ul><li>返回值：为 target 目标对象</li></ul></blockquote></li></ol><ul><li>语法</li></ul><pre><code>Object.assign(target, sources1, sources1,...)</code></pre><blockquote><ul><li>target：目标对象，接收源对象属性的对象，也是修改后的返回值</li><li>sources1, sources1,…： 为源对象</li></ul></blockquote><ul><li>基本用法</li></ul><pre><code>const obj1 = &#123; a: 1, b: 2 &#125;;const obj2 = &#123; c: 3, d: 4 &#125;;Object.assign(obj1, obj2);console.log(obj1); // &#123;a: 1, b: 2, c: 3, d: 4&#125;&gt;// 注意区分以下写法的不同Object.assign(obj1, obj2); // 将obj2合并到obj1const obj = &#123; ...obj1, ...obj2 &#125;; // 将obj1和obj2合并到一个新对象，然后赋值给obj&gt;// 用Object.assign实现 const obj= &#123;...obj1,...obj2&#125; 写法如下const obj = Object.assign(&#123;&#125;, obj1, obj2);</code></pre><ul><li>如果<code>Object.assign</code>方法只有一个参数<blockquote><ul><li>该参数为一个对象，直接将该对象作为返回值返回。</li><li>如果该参数不是一个对象类型，会先转换为对象类型，然后将其作为返回值返回。</li><li>如果该参数是<code>null</code>或<code>undefined</code>，因为<code>null</code>和<code>undefined</code>不能转换为对象，所以会报错。</li></ul></blockquote></li></ul><pre><code>// 只有一个参数，且为对象类型，直接将该对象作为返回值返回const obj1 = Object.assign(&#123; a: 1, b: 2 &#125;);console.log(obj1); // &#123;a: 1, b: 2&#125;&gt;//只有一个参数，且为基本数据类型，将其转换为对象然后作为返回值返回const obj2 = Object.assign(2);console.log(obj2); // Number &#123;2&#125;&gt;// 由于null和undefined不能转换为对象，报错const obj3 = Object.assign(null); // 报错const obj4 = Object.assign(undefined); // 报错</code></pre><ul><li><code>Object.assign</code>方法的<strong>源对象位置</strong>的参数<blockquote><ul><li>如果是非对象类型的参数，则会将其自动转换为对象</li><li>如果是<code>null</code>和<code>undefined</code>，则会直接忽略，并不会报错</li></ul></blockquote></li></ul><pre><code>const obj1 = &#123; a: 1, b: 2 &#125;;Object.assign(obj1, 1, &quot;hello&quot;, null, undefined, true);console.log(obj1); // &#123;0: &#39;h&#39;, 1: &#39;e&#39;, 2: &#39;l&#39;, 3: &#39;l&#39;, 4: &#39;o&#39;, a: 1, b: 2&#125;</code></pre><ol start="3"><li><code>Object.assign</code> 的注意事项</li></ol><ul><li>如果目标对象与源对象具有相同的属性，则目标对象中的属性将被源对象属性<strong>覆盖</strong></li></ul><pre><code>const obj1 = &#123;  color: [&quot;红色&quot;, &quot;黑色&quot;],  a: 1,  b: 2,&#125;;const obj2 = &#123;  color: [&quot;白色&quot;, &quot;蓝色&quot;],  b: 3,  c: 4,&#125;;&gt;Object.assign(obj1, obj2);console.log(obj1);</code></pre><ul><li>将源对象中的属性复制到目标对象，其本质是<strong>浅拷贝</strong></li></ul><pre><code>const obj1 = &#123;&#125;;const obj2 = &#123;  arr: [1, 2],&#125;;Object.assign(obj1, obj2);obj2.arr.push(3); // 修改obj2的arr属性，其相当于修改了obj1的arr属性console.log(obj1.arr); //  [1, 2, 3]</code></pre><ul><li><code>Object.assign</code>方法将只能将源对象上的<strong>自身可枚举属性</strong>复制到目标对象，只要是自身的可枚举属性，其属性名为 <code>Symbol</code>类型也会被复制</li></ul><pre><code>const obj = &#123; a: 1, b: 2 &#125;;const obj2 = &#123; c: 3, [Symbol()]: &quot;Symbol&quot; &#125;;// 为obj2添加两个自身属性Object.defineProperties(obj2, &#123;  name: &#123;    value: &quot;清心&quot;, // 属性值    writable: true, // 可写    configurable: false, // 不可重匹配    enumerable: true, // 可枚举  &#125;,  age: &#123;    value: 33,    writable: true,    configurable: false,    enumerable: false, // 不可枚举  &#125;,&#125;);&gt;console.log(obj2); // &#123;c: 3, name: &#39;清心&#39;, age: 33, Symbol(): &#39;Symbol&#39;&#125;Object.assign(obj, obj2);console.log(obj); // &#123;a: 1, b: 2, c: 3, name: &#39;清心&#39;, Symbol(): &#39;Symbol&#39;&#125;</code></pre><blockquote><ul><li>不可枚举的<code>age</code>属性不会被复制到目标对象</li></ul></blockquote><ul><li>如果源对象上有 get 和 set 函数，其相当于<strong>新增一个属性</strong>合并到原型中，但没有 get 和 set 函数</li></ul><pre><code>const obj1 = &#123;  a: 1,  b: 2,&#125;;const obj2 = &#123;  _x: &quot;a&quot;,  get x() &#123;    return this._x;  &#125;,  set x(value) &#123;    if (x === 3) &#123;      throw new Error(&quot;值不能为3&quot;);    &#125; else &#123;      this._x = value;    &#125;  &#125;,&#125;;&gt;Object.assign(obj1, obj2);console.log(obj1); // &#123;a: 1, b: 2, _x: &#39;a&#39;, x: &#39;a&#39;&#125;obj1.x = 3;//不会报错，因为此时x已经等于&quot;a&quot;了console.log(obj1.x);//3</code></pre><ol start="4"><li>Object.assign 的常见应用<blockquote><p>常用合并默认参数和用户参数</p></blockquote></li></ol><pre><code>// userOptions为用户参数const userInfo = (userOptions) =&gt; &#123;  // 默认参数  const DEFAULTS = &#123;    username: &quot;icoding&quot;,    age: 0,    sex: &quot;male&quot;,  &#125;;&gt;  // 合并默认参数和用户参数  const options = Object.assign(&#123;&#125;, DEFAULTS, userOptions);  console.log(options);&#125;;&gt;userInfo(); // &#123;username: &#39;icoding&#39;, age: 0, sex: &#39;male&#39;&#125;userInfo(&#123;&#125;); // &#123;username: &#39;icoding&#39;, age: 0, sex: &#39;male&#39;&#125;userInfo(&#123; username: &quot;arry&quot; &#125;); // &#123;username: &#39;arry&#39;, age: 0, sex: &#39;male&#39;&#125;userInfo(&#123; username: &quot;清心&quot;, age: 18, sex: &quot;female&quot; &#125;); // &#123;username: &#39;清心&#39;, age: 18, sex: &#39;female&#39;&#125;</code></pre><ol start="6"><li>keys、values、entries<table><thead><tr><th>方法</th><th>说明</th></tr></thead><tbody><tr><td>keys</td><td>返回一个由一个给定对象的自身可枚举属性<strong>（不包括 Symbol类型）</strong>组成的数组，数组中属性名的排列顺序和正常循环遍历该对象时返回的顺序一致</td></tr><tr><td>values</td><td>方法返回一个给定对象自身的所有可枚举属性值的数组，值的顺序与使用 for…in 循环的顺序相同（区别在于 for-in 循环枚举原型链中的属性）</td></tr><tr><td>entries</td><td>方法返回一个给定对象自身可枚举属性的键值对数组，其排列与使用 for…in 循环遍历该对象时返回的顺序一致（区别在于 for-in 循环还会枚举原型链中的属性</td></tr></tbody></table></li></ol><pre><code>const obj = &#123;  a: 1,  b: 2,  c: 3,&#125;;// 定义自身属性Object.defineProperties(obj, &#123;  name: &#123;    value: &quot;清心&quot;,    enumerable: true,  &#125;,  age: &#123;    value: 33,  &#125;,&#125;);&gt;const keys = Object.keys(obj);console.log(keys); // [&#39;a&#39;, &#39;b&#39;, &#39;c&#39;, &#39;name&#39;]&gt;const values = Object.values(obj);console.log(values); // [1, 2, 3, &#39;清心&#39;]&gt;const entries = Object.entries(obj);console.log(entries); // [Array(2), Array(2), Array(2), Array(2)]</code></pre><ul><li>与 for…of 的结合应用<blockquote><ul><li>因为对象的<code>Object.keys()</code>、<code>Object.values()</code>、<code>Object.entries()</code>返回的是数组，数组是可迭代对象</li></ul></blockquote></li></ul><pre><code>const obj = &#123;  a: 1,  b: 2,  c: 3,&#125;;// 遍历对象的所有自身可枚举属性名for (let key of Object.keys(obj)) &#123;  console.log(key);&#125;// 遍历对象的所有自身可枚举属性值for (let values of Object.values(obj)) &#123;  console.log(values);&#125;// 遍历对象的属性名与对应的属性值for (let [key, value] of Object.entries(obj)) &#123;  console.log(`$&#123;key&#125; =&gt; $&#123;value&#125;`);&#125;</code></pre><blockquote><blockquote><p>注意和数组、Set、Map 的<code>keys、values、entries</code>方法<strong>对比</strong><br>调用方式的不同</p></blockquote><ul><li>对象是构造函数的方法，将对象传入的方式<code>Object.keys(obj)</code></li><li>数组是实例的方法，通过实例对象就可以调用方法<code>[1, 2, 3].keys()</code>，而对象是没有的<br><strong>返回值的不同</strong></li><li>对象的<code>Object.keys()</code>、<code>Object.values()</code>、<code>Object.entries()</code>等方法是构造函数方法，返回的都是<strong>数组</strong></li><li>数组的<code>keys()</code>、<code>values()</code>、<code>entries()</code>等方法是实例方法，返回的统一都是数组的遍历对象<code>Iterator</code></li></ul></blockquote><pre><code>console.log([1, 2, 3].keys()); // Array Iterator &#123;&#125;console.log([1, 2, 3].values()); // Array Iterator &#123;&#125;console.log([1, 2, 3].entries()); // Array Iterator &#123;&#125;</code></pre><ol start="7"><li>Object.getOwnPropertyDescriptor<blockquote><p>方法返回指定对象上一个指定的自有属性对应的<strong>属性描述符</strong>，如果对象身上有这个属性，返回其属性描述符对象，否则返回<code>undefined</code></p></blockquote></li></ol><ul><li>语法</li></ul><pre><code>Object.getOwnPropertyDescriptor(obj, prop);// obj 需要查找的目标对象// prop 目标对象内属性名称</code></pre><pre><code>const obj = &#123;  name: &quot;清心&quot;,  get sex() &#123;    return this._sex;  &#125;,  set sex(value) &#123;    this._sex = value;  &#125;,&#125;;Object.defineProperty(obj, &quot;age&quot;, &#123;  value: 33,  configurable: false,  enumerable: true,  writable: false,&#125;);&gt;let desc1 = Object.getOwnPropertyDescriptor(obj, &quot;name&quot;);console.log(desc1);let desc2 = Object.getOwnPropertyDescriptor(obj, &quot;sex&quot;);console.log(desc2);let desc3 = Object.getOwnPropertyDescriptor(obj, &quot;age&quot;);console.log(desc3);</code></pre><ol start="8"><li>Object.getOwnPropertyDescriptors<blockquote><p>获取一个对象的所有自身属性的描述符。如果没有属性，则返回空对象</p></blockquote></li></ol><ul><li>语法</li></ul><pre><code>const obj = &#123;  name: &quot;清心&quot;,  get sex() &#123;    return this._sex;  &#125;,  set sex(value) &#123;    this._sex = value;  &#125;,&#125;;Object.defineProperty(obj, &quot;age&quot;, &#123;  value: 33,  configurable: false,  enumerable: true,  writable: false,&#125;);&gt;let descAll = Object.getOwnPropertyDescriptors(obj);console.log(descAll);</code></pre><blockquote><p>浅拷贝一个对象</p><ul><li><code>Object.assign()</code>方法只能拷贝源对象的可枚举的自身属性，同时拷贝时无法拷贝属性的特性们，而且访问器属性会被转换成数据属性，也无法拷贝源对象的原型。</li><li>而<code>Object.getOwnPropertyDescriptors</code>方法配合 <code>Object.create()</code>方法可以实现上面说的这些。</li></ul></blockquote><pre><code>Object.create(  Object.getPrototypeOf(obj),  Object.getOwnPropertyDescriptors(obj));</code></pre><pre><code>const obj = &#123;  name: &quot;清心&quot;,  get sex() &#123;    return this._sex;  &#125;,  set sex(value) &#123;    if (value &lt; 33) &#123;      throw new Error(&quot;年龄不符&quot;);    &#125; else &#123;      this._sex = value;    &#125;  &#125;,&#125;;Object.defineProperty(obj, &quot;age&quot;, &#123;  value: 33,  configurable: false,  enumerable: true,  writable: false,&#125;);&gt;const obj2 = Object.create(  Object.getPrototypeOf(obj),  Object.getOwnPropertyDescriptors(obj));console.log(obj2);//&#123;name: &#39;清心&#39;, age: 33&#125;并带有get set方法obj2.sex = 22;//报错：年龄不符</code></pre><ol start="9"><li>Object.getOwnPropertyNames<blockquote><p>返回一个由指定对象的所有自身属性的属性名（包括不可枚举属性但不包括 <code>Symbol</code> 值作为名称的属性）组成的数组。</p></blockquote></li></ol><table><thead><tr><th>方法</th><th>原型</th><th>自身</th><th>自身 Symbol</th><th>可枚举</th><th>不可枚举</th></tr></thead><tbody><tr><td>Object.getOwnPropertyNames</td><td></td><td>✔</td><td></td><td>✔</td><td>✔</td></tr></tbody></table><ul><li>语法</li></ul><pre><code>Object.getOwnPropertyNames(obj);// 在 ES2015 中，非对象参数被强制转换为对象</code></pre><pre><code>const obj = &#123;  [Symbol()]: &quot;Symbol&quot;,  name: &quot;清心&quot;,//可枚举&#125;;Object.defineProperty(obj, &quot;sex&quot;, &#123;  value: &quot;女&quot;,//不可枚举&#125;);&gt;const desc = Object.getOwnPropertyNames(obj);console.log(desc); // [&#39;name&#39;, &#39;sex&#39;]</code></pre><blockquote><blockquote><p>如果只想获取对象的自身可枚举属性，可以使用<code>Object.keys</code>方法。</p></blockquote></blockquote><blockquote><ul><li>在 ES2015 中，非对象参数被强制转换为对象</li></ul></blockquote><pre><code>Object.getOwnPropertyNames(1); // []Object.getOwnPropertyNames(&quot;hello&quot;); //  [&#39;0&#39;, &#39;1&#39;, &#39;2&#39;, &#39;3&#39;, &#39;4&#39;, &#39;length&#39;]</code></pre><blockquote><blockquote><p>注意：</p></blockquote><ul><li>直接定义在对象身上的属性，以上属性特性的默认值分别为：<code>writable:true</code>、<code>value:undefined</code>、<code>configurable：true</code>、<code>enumerable:true</code></li><li>通过<code>Object.defineProperty</code>方式定义的属性，其属性特性的默认值分别为：<code>writable:false</code>、<code>value:undefined</code>、<code>configurable：false</code>、<code>enumerable:false</code></li></ul></blockquote><ol start="10"><li>Object.getOwnPropertySymbols<blockquote><p>返回一个给定对象自身的所有<code>Symbol</code>属性的数组</p><table><thead><tr><th>方法</th><th>原型</th><th>自身</th><th>自身 Symbol</th><th>可枚举</th><th>不可枚举</th></tr></thead><tbody><tr><td>Object.getOwnPropertySymbols</td><td></td><td></td><td>✔</td><td>✔</td><td>✔</td></tr></tbody></table></blockquote></li></ol><ul><li>语法</li></ul><pre><code>Object.getOwnPropertySymbols(obj);</code></pre><pre><code>const obj = &#123;  [Symbol()]: &quot;Symbol&quot;,  name: &quot;清心&quot;,&#125;;Object.defineProperty(obj, &quot;sex&quot;, &#123;  value: &quot;女&quot;,&#125;);&gt;const desc = Object.getOwnPropertySymbols(obj);console.log(desc); // [Symbol()]</code></pre><ol start="11"><li><p>四种获取对象属性方法的对比</p><table><thead><tr><th>方法</th><th>原型</th><th>自身</th><th>自身 Symbol</th><th>可枚举</th><th>不可枚举</th></tr></thead><tbody><tr><td>Object.keys()</td><td></td><td>✔</td><td></td><td>✔</td><td></td></tr><tr><td>for…in</td><td>✔</td><td>✔</td><td></td><td>✔</td><td></td></tr><tr><td>Object.getOwnPropertyNames</td><td></td><td>✔</td><td></td><td>✔</td><td>✔</td></tr><tr><td>Object.getOwnPropertySymbols</td><td></td><td></td><td>✔</td><td>✔</td><td>✔</td></tr></tbody></table></li><li><p>Object.freeze</p><blockquote><p><code>Object.freeze()</code>方法可以冻结一个对象。一个被冻结的对象<strong>再也不能被修改</strong>。</p></blockquote></li></ol><pre><code>const obj = &#123;  a: 1,  b: 2,  arr: [1, 2, 3],&#125;;Object.freeze(obj); // 冻结对象obj.a = 3; // 修改属性值无效delete obj.b; // 不能删除属 性obj.c = 4; // 不能添加属性console.log(obj); // &#123;a: 1, b: 2, arr: [1, 2, 3]&#125;</code></pre><ul><li><code>Object.freeze()</code>冻结对象，属于<strong>浅冻结</strong>。如果对象的属性是一个引用类型，修改属性值指向的对象的属性是可以。</li></ul><pre><code>const obj = &#123;  a: 1,  b: 2,  arr: [1, 2, 3],&#125;;Object.freeze(obj); // 冻结对象obj.arr.push(&quot;abc&quot;);console.log(obj.arr); // [1, 2, 3, &#39;abc&#39;]</code></pre><ul><li>深度冻结<blockquote><ul><li>以下代码来自 MDN 官方文档</li></ul></blockquote></li></ul><pre><code>// 深冻结函数。function deepFreeze(obj) &#123;  // 取回定义在 obj 上的属性名  var propNames = Object.getOwnPropertyNames(obj);&gt;  // 在冻结自身之前冻结属性  propNames.forEach(function (name) &#123;    var prop = obj[name];    // 如果 prop 是个对象，冻结它    if (typeof prop == &quot;object&quot; &amp;&amp; prop !== null) deepFreeze(prop);  &#125;);&gt;  // 冻结自身 (no-op if already frozen)  return Object.freeze(obj);&#125;&gt;obj2 = &#123;  internal: &#123;&#125;,&#125;;&gt;deepFreeze(obj2);obj2.internal.a = &quot;anotherValue&quot;;obj2.internal.a; // undefined</code></pre><ol start="13"><li>Object.fromEntries<blockquote><p><code>Object.fromEntries()</code>方法把<strong>键值对列表</strong>转换为一个<strong>对象</strong>。其返回值为一个新的对象。</p></blockquote></li></ol><ul><li>语法</li></ul><pre><code>Object.fromEntries(iterable);</code></pre><blockquote><ul><li><code>iterable</code>可以理解为一个可迭代对象或一个迭代器对象。可迭代对象或迭代器对象的返回值<strong>必须是一个双元素数组</strong>。如:二维数组，<code>Map</code>，<code>Object.entries()</code>的返回值等</li></ul></blockquote><ul><li>基本用法<blockquote><ul><li>二维数组转对象</li></ul></blockquote></li></ul><pre><code>const arr = [  [&quot;a&quot;, 1],  [&quot;b&quot;, 2],  [&quot;c&quot;, 3],];const obj = Object.fromEntries(arr);console.log(obj); // &#123;a: 1, b: 2, c: 3&#125;</code></pre><blockquote><ul><li>Map 转 Object</li></ul></blockquote><pre><code>let map = new Map([  [&quot;a&quot;, 1],  [&quot;b&quot;, 2],  [&quot;c&quot;, 3],]);const obj = Object.fromEntries(map);console.log(obj); // &#123;a: 1, b: 2, c: 3&#125;</code></pre><blockquote><ul><li>迭代器对象转对象</li></ul></blockquote><pre><code>function* gen() &#123;  yield [&quot;a&quot;, 1];  yield [&quot;b&quot;, 2];  yield [&quot;c&quot;, 3];&#125;const obj = Object.fromEntries(gen());console.log(obj);</code></pre><blockquote><blockquote><p>总结：</p></blockquote><ul><li><code>Object.fromEntries()</code>与<code>Object.entries</code>是<strong>互逆</strong>的操作</li></ul></blockquote>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JS核心知识点（二十一）</title>
      <link href="/2023/12/11/JS%E6%A0%B8%E5%BF%83%E7%9F%A5%E8%AF%86%E7%82%B9%EF%BC%88%E4%BA%8C%E5%8D%81%E4%B8%80%EF%BC%89/"/>
      <url>/2023/12/11/JS%E6%A0%B8%E5%BF%83%E7%9F%A5%E8%AF%86%E7%82%B9%EF%BC%88%E4%BA%8C%E5%8D%81%E4%B8%80%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<span id="more"></span><h3 id="一、初始-Class-类"><a href="#一、初始-Class-类" class="headerlink" title="一、初始 Class 类"></a>一、初始 Class 类</h3><ol><li><p>什么是类</p><blockquote><p>类可以看做是对象的模板，用一个类可以创建出许多不同的对象。<br>如下：</p><table><thead><tr><th>类</th><th>对象</th></tr></thead><tbody><tr><td>人</td><td>小明，小红，清心，arry</td></tr><tr><td>鸟</td><td>麻雀、鹦鹉、鸽子、燕子、画眉</td></tr><tr><td>狗</td><td>柴犬、法斗、英斗、拉布拉多、边牧</td></tr></tbody></table></blockquote></li><li><p>Class 类的由来</p><blockquote><p><code>JavaScript</code> 语言中，生成实例对象的传统方法是通过<strong>构造函数</strong>。</p></blockquote></li></ol><pre><code>function Point(x, y) &#123;  this.x = x;  this.y = y;&#125;&gt;Point.prototype.toString = function () &#123;  console.log(`($&#123;this.x&#125;,$&#123;this.y&#125;)`);&#125;;let point = new Point(1, 2);point.toString(); // (1,2)</code></pre><blockquote><ul><li>上面这种写法跟传统的面向对象语言（比如 C++ 和 Java）差异很大，很容易让新学习这门语言的程序员感到困惑。</li></ul></blockquote><blockquote><p><code>ES6</code> 提供了更接近传统语言的写法，引入了 <code>Class</code>（类）这个概念，作为对象的模板。通过<code>class</code>关键字，可以定义类。<br>基本上，<code>ES6</code> 的<code>class</code>可以看作只是一个<strong>语法糖</strong>，它的绝大部分功能，<code>ES5</code> 都可以做到，新的class写法只是让对象原型的写法更加清晰、更像面向对象编程的语法而已。</p><ul><li>上面的代码用 <code>ES6</code> 的<code>class</code>改写，就是下面这样。</li></ul></blockquote><pre><code>// 定义一个Point 类class Point &#123;  constructor(x, y) &#123;    this.x = x;    this.y = y;  &#125;  toString() &#123;    console.log(`($&#123;this.x&#125;,$&#123;this.y&#125;)`);  &#125;&#125;let point = new Point(1, 2);point.toString(); // (1,2)</code></pre><blockquote><p>上面代码定义了一个<strong>“类”</strong>，</p><ul><li>可以看到里面有一个<code>constructor()</code>方法，这就是<strong>构造方法</strong>，内部的<code>this</code>关键字则代表实例对象。</li><li>这种新的 <code>Class</code> 写法，本质上与本章开头的 <code>ES5</code> 的构造函数<code>Point</code>是一致的。</li><li><code>Point</code>类除了构造方法，还定义了一个<code>toString()</code>方法。</li><li>定义**”类”的方法**时，前面不需要加上<code>function</code>这个关键字，直接把函数定义放进去了就可以了。</li><li>另外，方法与方法之间不需要逗号分隔，加了会报错。<blockquote><p><code>ES6</code> 的类，完全可以看作构造函数的另一种写法。</p></blockquote></li></ul></blockquote><ol start="3"><li>Class 类的基本用法</li></ol><ul><li>语法</li></ul><pre><code>// 类的声明是 class + 类名&#123;&#125;// class 是关键字// Person 是类名一般首字母大写class Person &#123;&#125;</code></pre><ul><li>基本用法：<blockquote><ul><li>一般在构造方法中定义属性，<strong>不会定义方法</strong>，<ul><li>因为会造成方法不能共享</li><li>而且会在内存中开辟不同的空间来存储，每<code>new</code>一个新的对象就会多开辟一个空间，非常浪费资源和消耗内存的，严重影响性能</li></ul></li><li>建议在Class类内部定义各个实例共享的方法</li></ul></blockquote></li></ul><pre><code>class Person &#123;  constructor(username, age) &#123;    this.username = age;    this.age = age;    //不推荐这样定义方法    this.sayHello = () =&gt; &#123;&#125;;  &#125;&gt;  // 各实例共享的方法  eat() &#123;    console.log(&quot;Eat apples&quot;);  &#125;&#125;&gt;const qxin = new Person(&quot;清心&quot;, 19);// 调用方法qxin.eat(); // Eat applesconst allen = new Person(&quot;allen&quot;, 18);// 调用方法allen.eat(); // Eat apples&gt;//arry对象和allen对象的 eat 方法不相等,说明它们不是同一个引用console.log(arry.sayHello === allen.sayHello); //false// arry对象和allen对象的 eat 方法 此时就是相等的，即同一个引用console.log(qxin.eat === allen.eat); // true</code></pre><blockquote><ul><li>以上 ES6 的类，完全可以看作传统构造函数的另一种写法。如下</li></ul></blockquote><pre><code>function Person(username, age) &#123;  this.username = username;  this.age = age;&gt;  // 注意：同理，一般只会在构造函数中定义属性，方法不在构造函数中定义  // this.sayHello = () =&gt; &#123;&#125;;&#125;&gt;Person.prototype.eat = function () &#123;&#125;;</code></pre><blockquote><ul><li>类的数据类型就是函数，类本身就指向构造函数。写在 Class 类内部的方法，本质就是写在构造函数的原型上</li></ul></blockquote><pre><code>class Person &#123;  constructor(username, age) &#123;    this.username = age;    this.age = age;  &#125;  eat() &#123;    console.log(&quot;Eat apples&quot;);  &#125;&#125;&gt;// 通过以下类型判断和对比看到，类的数据类型就是函数，类本身就指向构造函数。console.log(typeof Person); // functionconsole.log(Person === Person.prototype.constructor); // true// 同样可以在 Person 的原型对象上找到 eat 方法console.log(Person.prototype.eat);</code></pre><ol start="4"><li>constructor 方法<blockquote><p><code>constructor</code> 方法是类的<strong>默认方法</strong>，通过 <code>new</code> 关键字生成对象实例时会自动调用该方法。</p><ul><li>一个类必须有 <code>constructor</code> 方法，如果没有显示定义，则会默认添加的一个空的 <code>constructor</code> 方法</li></ul></blockquote></li></ol><pre><code>class Point &#123;&#125;&gt;// 等同于class Point &#123;  constructor() &#123;&#125;&#125;</code></pre><blockquote><blockquote><p>注意：</p></blockquote><ul><li><code>constructor</code> 方法默认返回实例对象(即<code>this</code>)，不过可以<strong>人为指定</strong>返回一个新对象——修改return，不过必须返回的是对象</li><li>如果 <code>constructor</code> 的返回值人为指定<strong>非引用数据类型</strong>，则其返回值采用默认值（实例对象）</li></ul></blockquote><pre><code>class Point &#123;  constructor(x, y) &#123;    this.x = x;    this.y = y;    return [1, 2, 3]; // new Point()后返回值为 该数组    //  return function () &#123;&#125;;   // new Point()后，返回值为该函数    //  return 12; // 不起作用，new Point()后，默认返回实例对象  &#125;&#125;&gt;const point = new Point(2, 2);console.log(point); // [1, 2, 3]</code></pre><ol start="5"><li>Class 的两种写法<blockquote><ul><li>声明形式（重点学习这个）也是最常用的，以上讲的就是</li><li>表达式形式（了解即可）</li></ul></blockquote></li></ol><ul><li>Class 的声明形式</li></ul><pre><code>class Person &#123;  // 构造方法  constructor() &#123;&#125;&gt;  // 自定义方法  eat() &#123;&#125;&#125;</code></pre><ul><li>表达式形式（了解即可）</li></ul><pre><code>const MyPerson = class Person &#123;  constructor() &#123;    console.log(&quot;执行构造方法 ！&quot;);  &#125;  eat() &#123;&#125;&#125;;&gt;// 真正有效的类名为 MyPerson 而非 Person// new Person();  报错new MyPerson();&gt;// 所以表达式写法，可以简写如下const MyPerson = class &#123;  constructor() &#123;    console.log(&quot;执行构造方法 ！&quot;);  &#125;  eat() &#123;&#125;&#125;;new MyPerson();</code></pre><ul><li>表达式形式的用法：<blockquote><ul><li>模拟立即执行函数，来模拟立即执行的类（了解即可）</li></ul></blockquote></li></ul><pre><code>// 回顾，立即执行函数的写法const fn = (function () &#123;  console.log(&quot;foo&quot;);&#125;)();// 类似常规调用执行一个函数 fn()&gt;// 立即执行的类（模拟立即执行函数而来）const Person = new (class &#123;  constructor() &#123;    console.log(&quot;执行构造方法 ！&quot;);  &#125;&#125;)();// 类似执行 new Person()</code></pre><h3 id="二、Class-类的属性和方法"><a href="#二、Class-类的属性和方法" class="headerlink" title="二、Class 类的属性和方法"></a>二、Class 类的属性和方法</h3><h4 id="实例属性"><a href="#实例属性" class="headerlink" title="实例属性"></a>实例属性</h4><blockquote><p>类的实例对象身上的属性称为实例属性。</p><ul><li>直接定义在类内部的最顶层或在<code>constructor()</code>方法中用<code>this</code>定义的属性</li></ul></blockquote><pre><code>class Person &#123;  // 实例属性  age = 33;  constructor(username, sex) &#123;    // 实例属性    this.username = username;    this.sex = sex;  &#125;&#125;&gt;const p = new Person(&quot;清心&quot;, &quot;女&quot;);console.log(p); // Person &#123;age: 33, username: &#39;清心&#39;, sex: &#39;女&#39;&#125;</code></pre><blockquote><ul><li>上面代码中，实例属性<code>age</code>直接定义在类内部，实例属性<code>username</code>和<code>sex</code>定义在<code>constructor()</code>方法里面的<code>this</code>上面。</li><li>上面的实例属性<code>age</code>是实例对象自身的属性，并不是在实例对象的原型上面。</li></ul></blockquote><h4 id="实例方法（原型方法）"><a href="#实例方法（原型方法）" class="headerlink" title="实例方法（原型方法）"></a>实例方法（原型方法）</h4><blockquote><p>直接定义在类里面的方法，本质就是定义在类的原型上，供类的所有实例对象共享，即为实例方法（或原型方法）</p><ul><li>或在<code>constructor</code>方法中用<code>this</code>定义的方法，为实例方法，但这种方式定义的方法没有办法共享，内存占用过大，<strong>通常不用</strong>，只做了解。</li></ul></blockquote><pre><code>class Person &#123;  constructor(username) &#123;    this.username = username;    // 实例方法-不推荐使用，只做了解    this.sayHello = function () &#123;      console.log(`大家好，我是$&#123;this.username&#125;`);    &#125;;  &#125;  // 原型方法（实例方法）  eat() &#123;    console.log(`$&#123;this.username&#125;正在吃苹果`);  &#125;&#125;&gt;const p = new Person(&quot;清心&quot;);console.log(p);</code></pre><h4 id="私有属性"><a href="#私有属性" class="headerlink" title="私有属性"></a>私有属性</h4><blockquote><p>所谓私有属性是指：只能在类的内部访问的属性，外部不能访问。</p><ul><li>即构造函数的<strong>内部或原型方法的内部</strong>可以访问的属性。</li></ul></blockquote><h5 id="ES5-写法"><a href="#ES5-写法" class="headerlink" title="ES5 写法"></a><strong>ES5 写法</strong></h5><blockquote><p><strong>面试题：</strong></p><ul><li>如何用 <code>ES5</code> 实现 <code>ES6</code> 的 <code>class</code> 的 <code>static</code> 和 <code>private</code>（百度）<blockquote><p>在 ES6 之前不提供相关私有属性的写法，只能通过变通方式来模拟实现。</p></blockquote></li></ul></blockquote><table><thead><tr><th>方法</th><th>缺点（或优点）</th></tr></thead><tbody><tr><td>在属性名前加<code>_</code>来区分</td><td>这种方式只是人为约定的一种写法，但并不保险 ，在类的外部还是可以访问</td></tr><tr><td>将变量移到构造函数外，利用闭包来实现</td><td>这种方式所有实例对象操作的是同一个私有属性。本质上不能算是模拟私有变量。（当作了解）</td></tr><tr><td>利用 <code>Symbol</code></td><td>值的唯一性，将变量名改为 <code>Symbol</code> 类型相对安全，但是如果非要访问，也是可以在类的外部访问到。比如：<code>getOwnPropertySymbols()</code>或<code>Reflect.ownKeys()</code>都可以拿到</td></tr><tr><td>利用 <code>weakMap</code> 来实现</td><td>非常完美如果有多个私有属性，则要把所有私有属性绑定到一个对象上。</td></tr></tbody></table><ol><li>在变量名前加_来区分私有属性和实例属性<blockquote><ul><li>这种方式只是人为约定的一种写法，但并不保险 ，在类的外部还是可以调用</li></ul></blockquote></li></ol><pre><code>function Person(username, age) &#123;  this._money = 2000; // 模拟私有属性  this.username = username; // 实例属性（公有属性）  this.age = age; // 实例属性（公有属性）&#125;&gt;const p = new Person(&quot;清心&quot;, 33);console.log(p._money); // 2000 以下划线形式访问，依然可以访问到&gt;// class类中class Person &#123;  constructor(username, age) &#123;    this._money = 2000;    this.username = username;    this.age = age;  &#125;&#125;&gt;const p = new Person(&quot;清心&quot;, 33);console.log(p._money); // 2000 以下划线形式访问，依然可以访问到</code></pre><ol start="2"><li>将变量移到构造函数外，利用闭包来实现<blockquote><ul><li>这种方式所有实例对象操作的是同一个私有属性。</li></ul></blockquote></li></ol><pre><code>const Person = (function () &#123;  let _money = 2000; // 模拟私有属性&gt;  function Person(username, age) &#123;    this.username = username; // 实例属性（公有属性）    this.age = age; // 实例属性（公有属性）  &#125;  Person.prototype.getMoney = function (number) &#123;    _money -= number;    console.log(`取出$&#123;number&#125;元，账户剩余$&#123;_money&#125;元`);  &#125;;  return Person;&#125;)();&gt;const p1 = new Person(&quot;清心&quot;, 33);p1.getMoney(200); // 取出200元，账户剩余1800元const p2 = new Person(&quot;arry&quot;, 33);p2.getMoney(300); // 取出300元，账户剩余1500元</code></pre><blockquote><ul><li>以上<code>p1</code>和<code>p2</code>本质上操作的都是同一个变量<code>_money</code>。本质上不能算作是实例对象的属性，更像是一个局部变量。</li></ul></blockquote><pre><code>// Person.js文件// class类中 ，模块化导出let _money = 2000; // 模拟私有属性export default class Person &#123;  constructor(username, age) &#123;    this.username = username; // 实例属性（公有属性）    this.age = age; // 实例属性（公有属性）  &#125;  getMoney(number) &#123;    _money -= number;    console.log(`取出$&#123;number&#125;元，账户剩余$&#123;_money&#125;元`);  &#125;&#125;&gt;&lt;!-- index.html页面 --&gt;&gt;&lt;script type=&quot;module&quot;&gt;  import Person from &quot;./Person.js&quot;;  const p1 = new Person(&quot;清心&quot;, 33);  p1.getMoney(200); // 取出200元，账户剩余1800元  const p2 = new Person(&quot;arry&quot;, 33);  p2.getMoney(300); // 取出300元，账户剩余1500元&gt;&lt;/script&gt;</code></pre><ol start="3"><li>利用 <code>Symbol</code> 值的唯一性，将属性名改为 <code>Symbol</code> 类型</li></ol><pre><code>let _money = Symbol(&quot;账户&quot;); // 创建Symbol类型function Person(username, age) &#123;  this[_money] = 2000; // 模拟私有属性  this.username = username; // 实例属性（公有属性）  this.age = age; // 实例属性（公有属性）&#125;Person.prototype.getMoney = function (number) &#123;  this[_money] -= number;  console.log(`取出$&#123;number&#125;元，账户剩余$&#123;this[_money]&#125;元`);&#125;;&gt;const p = new Person(&quot;清心&quot;, 33);const money = Object.getOwnPropertySymbols(p)[0]; // 获取Symbol属性值p[money] = 4000; // 修改属性值p.getMoney(200); // 取出200元，账户剩余3800元</code></pre><blockquote><ul><li>这种方式还是能拿到私有属性，所以一般会再套一层函数，利用闭包实现</li></ul></blockquote><blockquote><ul><li>class 类的写法</li></ul></blockquote><pre><code>//  Person.js文件let _money = Symbol(&quot;账户&quot;); // 创建Symbol类型export default class Person &#123;  constructor(username, age) &#123;    this[_money] = 2000; // 模拟私有属性    this.username = username; // 实例属性（公有属性）    this.age = age; // 实例属性（公有属性）  &#125;  getMoney(number) &#123;    this[_money] -= number;    console.log(`取出$&#123;number&#125;元，账户剩余$&#123;this[_money]&#125;元`);  &#125;&#125;&gt;&gt;&lt;script type=&quot;module&quot;&gt;  import Person from &quot;./Person.js&quot;;  const p = new Person(&quot;清心&quot;, 33);  const money = Object.getOwnPropertySymbols(p)[0]; // 获取Symbol属性值  p[money] = 4000; // 修改属性值  p.getMoney(200); // 取出200元，账户剩余3800元&gt;&lt;/script&gt;</code></pre><ol start="4"><li>利用 WeakMap 来实现<blockquote><p>如果有多个私有属性，则要把所有私有属性绑定到一个<strong>对象</strong>上。对于私有属性有一个统一的管理</p></blockquote></li></ol><pre><code>const privates = new WeakMap(); // 用来保存私有属性function Person(username, age) &#123;  privates.set(this, &#123; _money: 2000 &#125;);  this.username = username; // 实例属性（公有属性）  this.age = age; // 实例属性（公有属性）&#125;Person.prototype.getMoney = function (number) &#123;  if (privates.has(this)) &#123;    privates.get(this)._money -= number;  &#125;  console.log(`取出$&#123;number&#125;元，账户剩余$&#123;privates.get(this)._money&#125;元`);&#125;;&gt;const p = new Person(&quot;清心&quot;, 33);p.getMoney(200); // 取出200元，账户剩余1800元</code></pre><h5 id="ES6-写法"><a href="#ES6-写法" class="headerlink" title="ES6 写法"></a><strong>ES6 写法</strong></h5><blockquote><p><code>ES2022</code> 正式为 <code>class</code> 添加了私有属性，其写法是在属性名之前使用<code>#</code>号表示。</p><ul><li>私有属性可以先指定初始值，也可以不指定。</li></ul></blockquote><pre><code>class Person &#123;  #money = 2000; // 私有属性  定义同时赋初始值  #count; // 私有属性，没有赋初始值  constructor(username, age) &#123;    this.username = username; // 实例属性（公有属性）    this.age = age; // 实例属性（公有属性）  &#125;  getMoney(number) &#123;    // 访问私有属性时，要注意用this打点来访问    this.#money -= number;    console.log(`取出$&#123;number&#125;元，账户剩余$&#123;this.#money&#125;元`);  &#125;&#125;&gt;const p = new Person(&quot;清心&quot;, 33);p.getMoney(200);console.log(p);// console.log(p.#money); // 报错</code></pre><blockquote><ul><li>上面的<code>#money</code>就是私有属性，只能在类的内部使用<code>(this.#money)</code>，如果在类的外部读取或写入私有属性<code>#money</code>，就会报错。</li></ul></blockquote><pre><code>console.log(p.#money); // 报错p.#money = 300; // 报错</code></pre><blockquote><blockquote><p>注意：</p></blockquote><ul><li>如果读取一个不存在的<strong>私有属性</strong>，不管在类的内部或外部，都会报错，这一点与实例属性不同。</li><li>访问一个不存在的<strong>实例属性</strong>返回<code>undefined</code>，写入一个不存在的实例属性，相当于给对象添加一个新属性。</li></ul></blockquote><h4 id="私有方法"><a href="#私有方法" class="headerlink" title="私有方法"></a>私有方法</h4><blockquote><p>所谓私有方法是指：只能在类的内部访问的方法，外部不能访问。即构造函数的内部或原型方法的内部可以访问的方法。</p></blockquote><h5 id="ES5-的构造函数中模拟私有方法的写法"><a href="#ES5-的构造函数中模拟私有方法的写法" class="headerlink" title="ES5 的构造函数中模拟私有方法的写法"></a>ES5 的构造函数中模拟私有方法的写法</h5><blockquote><ul><li>在 ES6 之前不提供相关私有方法的写法，只能通过变通方式来模拟实现。</li></ul></blockquote><table><thead><tr><th>方法</th><th>缺点或优点</th></tr></thead><tbody><tr><td>在方法名前加<code>_</code>来区分</td><td>这种方式只是人为约定的一种写法，但并不保险 ，在类的外部还是可以调用</td></tr><tr><td>将方法移出构造函数，利用闭包来实现</td><td>需要用 <code>call</code> 方法，改变函数内部的 <code>this</code> 指向</td></tr><tr><td>利用 <code>Symbol</code></td><td>值的唯一性，将方法名改为 <code>Symbol</code> 类型相对安全，但是如果非要访问，也是可以在类的外部访问到。比如：<code>getOwnPropertySymbols()</code>都可以拿到</td></tr><tr><td>利用 <code>WeakMap</code> 来实现</td><td>如果有多个私有属性，则要把所有私有属性绑定到一个对象上。注意用<code>bind</code>来改变函数内部的 <code>this</code> 指向</td></tr></tbody></table><ol><li>在方法名前加<code>_</code>来区分<blockquote><ul><li>这种方式只是人为约定的一种写法，但并不保险 ，在类的外部还是可以调用</li></ul></blockquote></li></ol><pre><code>function Foo(x, y) &#123;  this._x = x;  this._y = y;&#125;// 模拟私有方法Foo.prototype._sum = function () &#123;  return this._x + this._y;&#125;;&gt;// 公有方法Foo.prototype.printSum = function () &#123;  console.log(this._sum());&#125;;&gt;const foo = new Foo(2, 4);foo.printSum();console.log(foo._sum()); // 本质上还是能访问到</code></pre><ol start="2"><li>将方法移出构造函数，利用闭包来实现</li></ol><pre><code>const Foo = (function () &#123;  // 构造函数  function Foo(x, y) &#123;    this._x = x;    this._y = y;  &#125;&gt;  // 模拟私有方法  function _sum() &#123;    return this._x + this._y;  &#125;&gt;  // 公有方法  Foo.prototype.printSum = function () &#123;    console.log(_sum.call(this));  &#125;;  return Foo;&#125;)();&gt;const foo = new Foo(2, 4);foo.printSum();</code></pre><ol start="3"><li>利用 Symbol 值的唯一性，将方法名改为 Symbol 类型<blockquote><ul><li>相对安全，但是如果非要访问，也是可以在类的外部访问到。比如：<code>getOwnPropertySymbols()</code>都可以拿到</li></ul></blockquote></li></ol><pre><code>const Foo = (function () &#123;  const s = Symbol();  // 构造函数  function Foo(x, y) &#123;    this._x = x;    this._y = y;  &#125;  // 私有方法   方法名为Symbol类型  Foo.prototype[s] = function () &#123;    return this._x + this._y;  &#125;;  // 公有方法  Foo.prototype.printSum = function () &#123;    console.log(this[s]());  &#125;;  return Foo;&#125;)();&gt;const foo = new Foo(2, 4);// 获取原型上的Symbol类型的属性let s = Object.getOwnPropertySymbols(foo.__proto__)[0];console.log(foo[s]()); // 6</code></pre><blockquote><blockquote><p>注意：这里使用<code>getOwnPropertySymbols()</code>的方式与模拟私有属性那不同；这里要到构造函数的原型上拿</p></blockquote></blockquote><ol start="4"><li>利用 WeakMap 来实现</li></ol><pre><code>const Foo = (function () &#123;  let privates = new WeakMap();  // 构造函数  function Foo(x, y) &#123;    this._x = x;    this._y = y;    // 特别注意要用bind改变函数内部的this指向    privates.set(this, _sum.bind(this));  &#125;  // 私有方法  function _sum() &#123;    return this._x + this._y;  &#125;  // 公有方法  Foo.prototype.printSum = function () &#123;    console.log(privates.get(this)());  &#125;;  return Foo;&#125;)();&gt;const foo = new Foo(2, 4);foo.printSum(); // 6</code></pre><h5 id="ES6-写法-1"><a href="#ES6-写法-1" class="headerlink" title="ES6 写法"></a>ES6 写法</h5><blockquote><p>私有方法 ES6 目前不提供，也只能通过变通的方法来模拟实现。可以采取与 ES5 相同的方式来模拟 class 类的私有方法。</p><ul><li>提案只规定了，私有属性是在属性名之前加 <code>#</code>，很自然的，也可以用这种方式来编写私有方法。</li><li>我们只需要在方法名前添加 # 号，就表示这个方法是一个私有方法。</li></ul></blockquote><pre><code>class Foo &#123;  #x; // 私有属性  #y; // 私有属性  constructor(x, y) &#123;    this.#x = x;    this.#y = y;  &#125;  // 私有方法  #sum() &#123;    return this.#x + this.#y;  &#125;  // 公有方法  printSum() &#123;    console.log(this.#sum());  &#125;&#125;const foo = new Foo(2, 4);foo.printSum(); // 6foo.#sum(); // 报错</code></pre><h4 id="静态属性"><a href="#静态属性" class="headerlink" title="静态属性"></a>静态属性</h4><blockquote><p>静态属性是指<code>Class</code>本身的属性，通过<code>类名.属性名</code>来设置或访问</p></blockquote><pre><code>class Person &#123;  constructor() &#123;    Person.children++; // 创建一个实例对象，就+1  &#125;&#125;// 静态属性  用来统计实例化对象的个数Person.children = 0;&gt;const p1 = new Person();const p2 = new Person();console.log(Person.children); // 2</code></pre><blockquote><ul><li>新提案提供了类的静态属性，在实例属性的前面添加<code>static</code>关键字，表示该属性为静态属性</li></ul></blockquote><pre><code>class Person &#123;  constructor() &#123;    Person.children++; // 创建一个实例对象，就+1  &#125;  // 静态属性  用来统计实例化对象的个数  static children = 0;&#125;&gt;const p1 = new Person();const p2 = new Person();console.log(Person.children); // 2</code></pre><blockquote><ul><li>新写法，在属性前加<code>static</code>关键字，更符合相关代码应该放在一起的代码组织原则。所有代码都写在的 <code>class</code> 类的<code>&#123;&#125;</code>的大括号中</li></ul></blockquote><ul><li>ES5写法</li></ul><pre><code>function Person()&#123;&#125;//静态属性Person.length=0;</code></pre><h4 id="静态方法"><a href="#静态方法" class="headerlink" title="静态方法"></a>静态方法</h4><blockquote><p>静态方法是指<code>Class</code>本身的方法，通过<code>类名.方法名()</code>来调用</p><ul><li>在一个实例方法的前面添加<code>static</code>关键字，就表示该方法为静态方法，只能通过类来调用</li></ul></blockquote><pre><code>class Person &#123;  // 静态方法  static getMoney(number) &#123;    console.log(`我取了$&#123;number&#125;元`);  &#125;&#125;Person.getMoney(200); // 我取了200元</code></pre><blockquote><ul><li>静态方法内部的<code>this</code>指向类本身，而不是实例</li></ul></blockquote><pre><code>class Person &#123;  static money = 2000; // 静态属性  money = 1000; // 实例属性  // 静态方法  static getMoney(number) &#123;    // this指向 Person类  this.money 相当于 Person.money    this.money -= number;    console.log(`我取了$&#123;number&#125;元，目前账户剩余$&#123;this.money&#125;元`);  &#125;&#125;Person.getMoney(200); // 我取了200元，目前账户剩余1800元</code></pre><ul><li>ES5写法</li></ul><pre><code>function Person()&#123;&#125;//静态方法Person.sum = function()&#123;  return 3;&#125;;</code></pre><h4 id="静态私有属性和静态私有方法"><a href="#静态私有属性和静态私有方法" class="headerlink" title="静态私有属性和静态私有方法"></a>静态私有属性和静态私有方法</h4><blockquote><p>在私有属性和私有方法前面，如果加上<code>static</code>关键字，表示这是一个静态的私有属性或私有方法。<br>静态的私有属性和方法只能在<strong>类的内部</strong>（实例方法，私有方法、静态方法）中调用，外部调用会报错。</p></blockquote><pre><code>class A &#123;  static #num = 4; // 静态的私有属性  // 实例方法  sum() &#123;    return A.#num;  &#125;  // 静态私有方法  static #getNum() &#123;    console.log(this === A); //true    return this.#num;  &#125;  //静态方法  static num() &#123;    return A.#getNum();  &#125;&#125;const a = new A();console.log(a.sum()); //4console.log(A.num()); // 4console.log(A.#num); // 报错， 类的外部不能调用静态的私有属性</code></pre><ul><li>ES5写法</li></ul><pre><code>const privates = new WeakMap();function A() &#123;&#125;//sum：静态私有属性 foo:静态私有方法privates.set(A, &#123; _sum: 4, _foo &#125;);//利用实例方法 返回静态私有属性A.prototype.sum = function () &#123;  return privates.get(A)._sum;&#125;;//静态私有方法function _foo() &#123;  return 2;&#125;//利用实例方法 返回静态私有方法A.prototype.Foo = function () &#123;  return privates.get(A)._foo();&#125;;const a = new A();console.log(a.sum()); //4console.log(a.Foo()); //2</code></pre><h4 id="取值函数和存值函数"><a href="#取值函数和存值函数" class="headerlink" title="取值函数和存值函数"></a>取值函数和存值函数</h4><blockquote><p>与 <code>ES5</code> 一样，在 “类” 的内部可以使用 get 和 set 关键字来对某个属性设置存值函数和取值函数，拦截该属性的存取行为。</p></blockquote><pre><code>class Foo &#123;  #count = 0; // 私有属性  // 取值函数  get count() &#123;    return this.#count;  &#125;  // 存值函数  set count(value) &#123;    if (value &lt; 0) &#123;      this.#count = 0;    &#125; else &#123;      this.#count = value;    &#125;  &#125;&#125;&gt;const foo = new Foo();foo.count = -3;console.log(foo.count); // 0foo.count = 44;console.log(foo.count); // 44</code></pre><ul><li>ES5设置存取函数<blockquote><ul><li>利用<code>Object.defineProperty(obj, 属性名, descriptor)</code></li></ul></blockquote></li></ul><pre><code>Object.defineProperty(obj, &quot;sex&quot;, &#123;  set: function (value) &#123;    this._sex = value;    if (value === &quot;女&quot;) &#123;      this.identity = &quot;女士&quot;;    &#125; else &#123;      this.identity = &quot;先生&quot;;    &#125;  &#125;,  get: function () &#123;    return this._sex;  &#125;,&#125;);</code></pre><h4 id="将以下构造函数写法改成-ES6-的-class-写法"><a href="#将以下构造函数写法改成-ES6-的-class-写法" class="headerlink" title="将以下构造函数写法改成 ES6 的 class 写法"></a>将以下构造函数写法改成 ES6 的 class 写法</h4><blockquote><p>如果你能轻松简单的将下面的 ES6 代码转换成 ES5 的构造函数写法，说明你对 class 的基础语法已经掌握了。</p></blockquote><pre><code>class A &#123;  // 静态私有属性，统计实例化成员个数  static #num = 0;  // 构造方法  constructor(x, y) &#123;    this.x = x;    this.y = y;    A.#num++; // 实例化时，统计数加1  &#125;  #count = 5; // 私有属性  // 取值函数  get count() &#123;    return this.#count;  &#125;  // 存值函数  set count(value) &#123;    // 相当处理省略    this.#count = value;  &#125;  // 私有方法  #Foo() &#123;    return 2;  &#125;  // 实例方法  sum() &#123;    console.log(this.x + this.y);  &#125;  // 静态方法  static children() &#123;    console.log(this.#num);  &#125;  // 实例方法  bar() &#123;    console.log(this.#Foo());  &#125;&#125;&gt;const a1 = new A(1, 2);const a2 = new A(2, 3);A.children(); // 2a1.sum(); // 3a2.bar(); // 2a1.count = 6;console.log(a1.count); // 6</code></pre><ul><li>ES5的构造函数实现</li></ul><pre><code>const A = (function () &#123;  const privates = new WeakMap();  function A(x, y) &#123;    // 实例属性    this.x = x;    this.y = y;    //私有属性、方法    privates.set(this, &#123; _count: 5, Foo &#125;);    //静态私有属性num 实例化时+1    privates.set(A, privates.get(A) + 1);    //存取函数    Object.defineProperty(this, &quot;count&quot;, &#123;      get() &#123;        return privates.get(this)._count;      &#125;,      set(value) &#123;        privates.get(this)._count = value;      &#125;,    &#125;);  &#125;  //私有方法  function Foo() &#123;    return 2;  &#125;  //静态私有属性num 统计实例化成员  privates.set(A, 0);  //实例方法  A.prototype.sum = function () &#123;    console.log(this.x + this.y);  &#125;;  //实例方法 返回私有方法Foo  A.prototype.bar = function () &#123;    console.log(privates.get(this).Foo());  &#125;;  //静态方法  A.children = function () &#123;    console.log(privates.get(A));  &#125;;  return A;&#125;)();&gt;const a1 = new A(1, 2);const a2 = new A(8, 2);const a3 = new A(8, 5);a1.sum(); //3a1.bar(); //2A.children(); //2console.log(a1.count); //5a1.count = 15;console.log(a1.count); //15</code></pre><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><table><thead><tr><th></th><th>ES5</th><th>ES6</th><th>this指向</th></tr></thead><tbody><tr><td>实例属性</td><td>在构造函数内部通过<code>this.属性名</code>定义</td><td>在类内部的最顶层或在<code>constructor()</code>方法中用<code>this</code>定义</td><td>实例</td></tr><tr><td>实例方法</td><td>在构造函数<code>prototype</code>原型上</td><td>在类的原型上</td><td>实例</td></tr><tr><td>私有属性</td><td>构造函数的内部或原型方法的内部可以访问的属性，用<code>WeakMap</code>模拟最完美</td><td>在类的内部，在属性名之前使用<code>#</code>号标识，在类的内部使用<code>this.#属性名</code>调用</td><td>没有</td></tr><tr><td>私有方法</td><td>构造函数的内部或原型方法的内部可以访问的方法，用<code>WeakMap</code>模拟最完美,私有方法的<code>this</code>指向<code>window</code>，所以要用<code>bind</code>改变指向</td><td>在类的内部，在方法名之前使用<code>#</code>号标识,this指向类本身</td><td></td></tr><tr><td>静态属性</td><td>通过<code>函数名.属性名</code>来定义和访问</td><td>实例属性的前面添加<code>static</code>关键字来定义,通过<code>类名.属性名</code>来访问</td><td>没有</td></tr><tr><td>静态方法</td><td>通过<code>函数名.方法名</code>来定义和访问</td><td>在一个实例方法的前面添加static关键字，通过<code>类名.方法名()</code>来调用</td><td><code>this</code>指向类本身</td></tr><tr><td>静态私有属性</td><td>用<code>WeakMap</code>保存在构造函数里</td><td>用<code>static #属性名</code>的方式定义</td><td>没有</td></tr><tr><td>静态私有方法</td><td>用<code>WeakMap</code>保存在构造函数里,<code>this</code>指向<code>window</code></td><td>用<code>static #方法名</code>的方式定义,<code>this</code>指向类</td><td></td></tr><tr><td>取值函数和存值函数</td><td>利用<code>Object.defineProperty(obj, 属性名, descriptor)</code></td><td>在“类”的内部可以使用<code>get</code>和<code>set</code> 关键字来对某个属性设置存值函数和取值函数</td><td><code>this</code>指向类本身</td></tr></tbody></table><ol><li>ES5写法</li></ol><ul><li>私有属性 _num+ 存取函数num<blockquote><ul><li>用<code>WeakMap</code>声明私有变量<code>privates</code>，根据不同对象<code>this</code>或是构造函数，有不同映射关系；但是同一个对象只能<code>set</code>一次，否则后面的会覆盖前面的</li><li>ES5的存取函数用<code>Object.defineProperty()</code></li></ul></blockquote></li></ul><pre><code> let privates = new WeakMap();   function A(x, y) &#123;    //实例属性    this.x = x;    this.y = y;    //私有属性    privates.set(this, &#123; _num: 0, _sum: 500 &#125;);&gt;    //存值函数 使用私有属性    Object.defineProperty(this, &quot;num&quot;, &#123;      get() &#123;        return privates.get(this)._num;      &#125;,      set(value) &#123;        if (value &lt; 0) &#123;          privates.get(this)._num = 0;        &#125; else &#123;          privates.get(this)._num = value;        &#125;      &#125;,    &#125;);   &#125;</code></pre><ul><li>私有属性_sum+私有方法<code>foo</code>+实例方法<code>printSum</code><blockquote><ul><li>私有属性保存在通过<code>WeakMap</code>声明私有变量<code>privates</code>里的<code>this</code>对象里</li><li>私有方法保存通过<code>WeakMap</code>声明私有变量<code>privates</code>里的构造函数里</li><li>私有方法在全局作用域下声明，所以要把<code>this</code>指向改为实例对象，这样才能拿到私有属性<code>_sum</code></li><li>实例方法作为该私有变量对外访问的接口,调用函数<code>foo</code>并返回</li></ul></blockquote></li></ul><pre><code>let privates = new WeakMap();function A(x, y) &#123;  //实例属性  this.x = x;  this.y = y;  //私有属性  privates.set(this, &#123; _num: 0, _sum: 500 &#125;);  //改变静态私有方法this指向  privates.set(A, foo.bind(this));&#125;//静态私有方法function foo() &#123;  return privates.get(this)._sum;&#125;//用实例方法 使用静态私有方法A.prototype.printSum = function () &#123;  return privates.get(A)();&#125;;</code></pre><ul><li>静态私有属性 +静态方法 ：统计实例化成员个数</li></ul><pre><code>let privates = new WeakMap();//count 统计实例化成员个数function A(x, y) &#123;  //实例属性  this.x = x;  this.y = y;  //统计实例化成员个数  privates.set(A, privates.get(A) + 1);&#125;// 静态的私有属性privates.set(A, 0);//静态方法 获取实例化成员个数A.getCount = function () &#123;  // console.log(privates.get(A));  return privates.get(A);&#125;;</code></pre><h4 id="new-target-属性"><a href="#new-target-属性" class="headerlink" title="new.target 属性"></a><code>new.target</code> 属性</h4><blockquote><p><code>ES6</code> 为 <code>new</code> 命令引用了<code>new.target</code>属性，在构造函数中，返回<code>new</code> 命令所作用的构造函数。</p><ul><li>如果构造函数不通过<code>new</code>命令调用，那么<code>new.target</code>会返回<code>undefined</code>，因此这个属性可以<strong>确定构造函数是如何调用的</strong>。</li></ul></blockquote><ul><li>构造函数</li></ul><pre><code>function Fn() &#123;  console.log(new.target);&#125;const fn = new Fn();&gt;// 如果构造函数，不是以new关键字调用，则抛出错误function Fn(name) &#123;  if (new.target === undefined) &#123;    throw new Error(&quot;必须使用new调用Fn&quot;);  &#125;  this.name = name;&#125;const fn = new Fn(&quot;icoding&quot;);Fn(); // Uncaught Error: 必须使用new调用Fn</code></pre><ul><li><code>class</code>类<blockquote><ul><li><code>class</code> 内部调用<code>new.target</code>，返回当前<code> class</code></li></ul></blockquote></li></ul><pre><code>class Point &#123;  constructor() &#123;    console.log(new.target === Point);  &#125;&#125;const point = new Point(); // true</code></pre><blockquote><ul><li>需要注意的是，<strong>子类继承父类时</strong>，<code>new.target</code>返回的是子类</li></ul></blockquote><pre><code>// 父类class Point &#123;  constructor() &#123;    console.log(new.target === Point);    console.log(new.target === ColorPoint);  &#125;&#125;&gt;// 子类class ColorPoint extends Point &#123;  constructor() &#123;    super();  &#125;&#125;&gt;const point = new Point(); // true falseconst colorPoint = new ColorPoint(); // false true</code></pre><ul><li>应用：抽象基类<blockquote><p>有时候可能需要定义这样一个类，它可供其他类继承，但本身不能实例化。我们把这种类称为抽象基类<br>利用子类继承父类时，<code>new.target</code>会返回子类这个特点，可以写出不能独立使用，而必须继承后才能使用的类，阻止对抽象基类的实例化</p></blockquote></li></ul><pre><code>// 父类class Point &#123;  constructor() &#123;    if (new.target === Point) &#123;      throw new Error(&quot;本类不能实例化，必需被继承&quot;);    &#125;  &#125;&#125;// 子类class ColorPoint extends Point &#123;  constructor() &#123;    super();  &#125;&#125;const colorPoint = new ColorPoint();const point = new Point(); // Uncaught Error: 本类不能实例化，必需被继承</code></pre><h4 id="静态块"><a href="#静态块" class="headerlink" title="静态块"></a>静态块</h4><ol><li>它的出现是为了解决什么问题<blockquote><p>通过前面的学习，我们了解到 Class 的内部，只能声明属性和方法，<strong>不能直接书写其它代码块</strong>。</p></blockquote></li></ol><pre><code>class A &#123;  // console.log(1)  错误写法，不支持直接书写代码块&#125;</code></pre><blockquote><p>如果其中一个静态属性需要根据另一个静态属性的值来初始化值时，那我们只能写在类的外部，或写在<code>constructor()</code>方法里面</p></blockquote><ul><li>写在类的外部</li></ul><pre><code>class A &#123;  static rand = (Math.random() * 2) &gt;&gt; 0;  static str;  constructor() &#123;&#125;&#125;&gt;// 静态属性str的值需要根据rand的值来决定if (A.rand === 1) &#123;  A.str = &quot;喜欢我&quot;;&#125; else &#123;  A.str = &quot;不喜欢我&quot;;&#125;&gt;console.log(A.str);</code></pre><blockquote><ul><li>写在类的外部确实可以轻松实现，但是将类的内部逻辑写到外部显然是不理想的</li></ul></blockquote><ul><li>写在 <code>constructor()</code> 中</li></ul><pre><code>class A &#123;  static rand = (Math.random() * 2) &gt;&gt; 0;  static str;  constructor() &#123;    // 静态属性str的值需要根据rand的值来决定    if (A.rand === 1) &#123;      A.str = &quot;喜欢我&quot;;    &#125; else &#123;      A.str = &quot;不喜欢我&quot;;    &#125;  &#125;&#125;console.log(A.str); // undefinednew A();console.log(A.str); // 喜欢我</code></pre><blockquote><ul><li>必须要<strong>先创建类的实例</strong>后，才能成功给静态属性赋值，同时每 <code>new</code> 都要运行一次代码，肯定也是不合理的。</li></ul></blockquote><ol start="2"><li>静态块的作用<blockquote><p>ES6 为了解决这个问题，<code>ES2022</code>引入了静态块(<code>static block</code>)，允许在类的内部设置一个代码块，在类生成时运行且只运行一次。</p></blockquote></li></ol><ul><li>作用一：用来给静态属性初始化赋值<blockquote><p><strong>语法</strong></p></blockquote></li></ul><pre><code>class A &#123;  // 静态块  static &#123;    // 可以书写任意的代码块  &#125;&#125;</code></pre><pre><code>class A &#123;  static rand = (Math.random() * 2) &gt;&gt; 0;  static str;  constructor() &#123;&#125;  // 静态块  static &#123;    // 静态属性str的值需要根据rand的值来决定    if (A.rand === 1) &#123;      A.str = &quot;喜欢我&quot;;    &#125; else &#123;      A.str = &quot;不喜欢我&quot;;    &#125;  &#125;&#125;</code></pre><ul><li>作用二：将私有属性与类的外部代码分享</li></ul><pre><code>let getMoney;class Person &#123;  #money = 2000;  static &#123;    getMoney = (obj) =&gt; obj.#money;  &#125;&#125;const p = new Person();console.log(getMoney(p)); // 2000</code></pre><ol start="3"><li>注意事项<blockquote><ul><li>静态块只允许访问<strong>静态块声明之前</strong>的静态属性</li><li>静态块的内部不能有 <code>return</code> 语句</li><li>静态块内部可以使用 <code>this</code>，<code>this</code> 指代<strong>当前类</strong></li><li>一个类中，可以有<strong>多个</strong>静态块</li></ul></blockquote></li></ol><pre><code>class A &#123;  static &#123;    console.log(this === A); // this指向类本身    console.log(this.count); // 访问不到在静态块之后定义的静态属性  &#125;  static &#123;    console.log(&quot;第二个&quot;);    // return  不能使用return，语法错误  &#125;  static count = 2;&#125;</code></pre><h3 id="三、ES5-中继承问题及解决方案"><a href="#三、ES5-中继承问题及解决方案" class="headerlink" title="三、ES5 中继承问题及解决方案"></a>三、ES5 中继承问题及解决方案</h3><blockquote><p>复习 ES5 中的寄生组合继承，了解 ES6 中新增的<code>Object.getPrototypeOf()</code>和<code>Object.setPrototypeOf()</code>两个方法，用这两个方法来解决 <code>ES5</code> 中不能实现静态属性和方法继承问题</p></blockquote><ol><li>ES5 寄生组合继承<blockquote><ul><li>实例属性继承：在子类的构造函数中调用父类的构造函数，然后利用<code>call</code>方法改变父类构造函数中的<code>this</code>指向</li><li>原型方法继承：以父类的原型对象为原型，创建出一个新的对象，然后将子类的原型指向新创建出来的对象</li></ul></blockquote></li></ol><pre><code>/ 父类  人类function People(name, age) &#123;  this.name = name;  this.age = age;&#125;&gt;// 子类  学生类function Student(name, age, scholl, sid) &#123;  // 继承属性  People.call(this, name, age);  this.scholl = scholl;  this.sid = sid;&#125;&gt;// 继承方法var prototype = Object.create(People.prototype);prototype.constructor = Student;Student.prototype = prototype;</code></pre><ol start="2"><li><code>ES5</code> 中无法实现静态属性和方法的继承<blockquote><p>在 <code>ES5</code> 中，我们没有办法实现子类继承父类的<strong>静态属性和静态方法</strong>。</p><ul><li>你可能会认为，要实现<code>Student</code>子类继承<code>People</code>父类的静态属性和方法，只需要添加<code>Student.__proto__=People</code>代码即可。</li><li>确实，添加了<code>Student.__proto__=People</code>代码后，<code>Student</code>类就可以打点调用<code>People</code>类身上的静态属性和方法了。<blockquote><p>具体代码如下：</p></blockquote></li></ul></blockquote></li></ol><pre><code>// 父类  人类function People() &#123;&#125;// 静态属性People.count = 33;// 静态方法People.sum = function () &#123;  console.log(&quot;sum方法&quot;);  console.log(this);&#125;;// 子类  学生类function Student() &#123;&#125;&gt;// 子类继承父类的静态属性和方法，但__proto__不是JS原生实现的，是各在浏览器厂商具体实现的// 所以 __proto__不建议在生产环境中使用Student.__proto__ = People;&gt;console.log(Student.count); // 33Student.sum(); //  sum方法   Student</code></pre><blockquote><ul><li>但由于<code>__proto__</code>并不是语言本身的特性，而是各大厂商具体实现时添加的<strong>私有属性</strong>，虽然各大浏览器的 <code>JS</code> 引擎都提供了这个私有属性，但不建议在<strong>生产中</strong>使用该属性，<strong>避免对环境产生依赖</strong></li><li>所以 <code>ES5</code> 之前<strong>本质上是没有办法实现子类继承父类的静态属性和方法的</strong>。但是在 <code>ES6</code> 中是可以实现的，因为 <code>ES6</code> 中新增了<code>Object.setPrototypeOf()</code>方法来设置对象的原型。</li></ul></blockquote><ol start="3"><li>Object.getPrototypeOf() 方法<blockquote><p><code>Object.getPrototypeOf()</code>是<code>ES6</code>新增的方法，用来获取指定对象的原型，即<code>对象.__proto__</code>值,如果没有，则返回 <code>null</code>。</p></blockquote></li></ol><ul><li>语法：</li></ul><pre><code>Object.getPrototype(object);// 获取对象object的原型，即object.__proto__的值&gt;const obj = &#123;&#125;;const __proto__ = Object.getPrototypeOf(obj);console.log(__proto__ === obj.__proto__); // trueconsole.log(__proto__ === Object.prototype); // true</code></pre><ul><li>异常<blockquote><ul><li>其参数必须是一个对象，在 <code>ES5</code> 如果参数不是一个对象类型，将抛出 <code>TypeError</code> 异常，在 <code>ES2015</code> 中，参数会被<strong>强制转换为一个对象</strong>。</li></ul></blockquote></li></ul><pre><code>// 1被强制转换成 Number&#123;&#125; 包装对象const __proto__ = Object.getPrototypeOf(1);console.log(__proto__ === Number.prototype); // true</code></pre><blockquote><blockquote><p>以后想要在生产环境下获取对象的原型，请使用<code>Object.getPrototypeOf()</code>方法</p></blockquote></blockquote><ol start="4"><li>Object.setPrototypeOf() 方法<blockquote><p><code>Object.setPrototypeOf()</code>是 <code>ES6</code> 新增的方法，用来设置某个对象的原型到别一个对象或 <code>null</code>。返回值为该对象</p></blockquote></li></ol><ul><li>语法</li></ul><pre><code>Object.setPrototypeOf(object, prototype);// 相当于 object.__proto__=prototype// object 要设置其原型的对象// prototype 为 object对象的新原型// 返回值 object</code></pre><pre><code>const obj1 = &#123;  a: 1,  b: 2,&#125;;const obj2 = &#123;  c: 3,&#125;;Object.setPrototypeOf(obj2, obj1); // 相当于obj2.__proto__=obj1console.log(obj2.__proto__ === obj1); // trueconsole.log(obj2.a); // 1</code></pre><blockquote><p>以上代码中</p><ul><li><code>Object.setPrototypeOf(obj2, obj1)</code>相当于<code>obj2.__proto__=obj1</code></li><li>所以<code>obj2.a</code>可以通过原型链查找到<code>obj1</code>上，在<code>obj1</code>上找到了属性<code>a</code>,所以返回结果为<code>1</code></li></ul></blockquote><ul><li>异常<blockquote><ul><li>如果<code>setPrototypeOf(obj,prototype)</code>的参数 <code>obj</code>,不是一个可以修改原型的特异对象，如<code>Object.prototype</code>或<code>window</code>，则会抛出异常</li><li>如果参数<code>prototype</code>不是对象或<code>null</code>，也会抛出异常</li></ul></blockquote></li></ul><pre><code>// window对象是浏览器的实例，其原型不允许更改Object.setPrototypeOf(window, &#123;&#125;); // 抛出错误&gt;// Object原型的原型指向原型链的终点，为nullconsole.log(Object.prototype.__proto__); // nullObject.setPrototypeOf(Object.prototype, null); // 这里不算更改，本身就是nullObject.setPrototypeOf(Object.prototype, &#123;&#125;); // 抛出错误</code></pre><blockquote><blockquote><p>以后想要在生产环境更改或设置对象原型，请使用<code>Object.setPrototypeOf()</code>方法</p></blockquote></blockquote><ol start="5"><li>构造函数之间实现静态属性和方法继承<blockquote><p>ES6 中提供的<code>Object.setPrototypeOf()</code>方法，要实现构造函数之间静态属性和方法的共享，就变得非常简单了。<br>具体代码如下：</p></blockquote></li></ol><pre><code>// 父类function Person() &#123;&#125;// 静态属性Person.count = 3;// 静态方法Person.sum = function () &#123;  console.log(this);&#125;;&gt;// 子类function Student() &#123;&#125;&gt;// Student子类继承父类Person的静态属性和方法Object.setPrototypeOf(Student, Person); // 相当于 Student.__proto__=Person&gt;// 访问静态属性和方法console.log(Student.count); // 3Student.sum(); //  ƒ Student() &#123;&#125;</code></pre><h3 id="四、Class-的继承"><a href="#四、Class-的继承" class="headerlink" title="四、Class 的继承"></a>四、Class 的继承</h3><h4 id="extends-继承"><a href="#extends-继承" class="headerlink" title="extends 继承"></a>extends 继承</h4><blockquote><p><code>Class</code>可以通过<code>extends</code>关键字实现继承，让子类继承父类的属性和方法。<code>extends</code>的写法比<code>ES5</code>的原型链继承，要清晰和方便很多。</p></blockquote><pre><code>// 人类class Person &#123;&#125;// 学生类 继承 人类class Student extends Person &#123;&#125;</code></pre><blockquote><ul><li>表示：Person是父类，Student是子类，它通过extends关键字，继承Person父类的所有属性和方法。</li></ul></blockquote><pre><code>// 人类class Person &#123;  constructor(username) &#123;    this.username = username;  &#125;  sayHello() &#123;    console.log(`大家好，我是$&#123;this.username&#125;`);  &#125;&#125;// 学生类 继承人类class Student extends Person &#123;  constructor(username, school) &#123;    super(username);    this.school = school;  &#125;  exam() &#123;    console.log(`$&#123;this.username&#125;正在考试`);  &#125;&#125;&gt;const xiaoming = new Student(&quot;小明&quot;, &quot;高新一中&quot;);xiaoming.sayHello(); // 大家好，我是小明xiaoming.exam(); // 小明正在考试</code></pre><blockquote><p><strong>上面代码中：</strong></p><ul><li><code>Person</code>是父类，<code>Student</code>是子类，它通过<code>extends</code>关键字，继承<code>Person</code>父类的实例属性<code>username</code>，继承了Person父类的实例方法<code>sayHello</code></li></ul></blockquote><ol><li><code>super()</code>做了什么</li></ol><pre><code>// 人类class Person &#123;  Foo = &quot;父类实例属性&quot;;  constructor(username) &#123;    //1、创建了一个父类的实例对象&#123;&#125;,this为&#123;&#125;    //2、执行以下代码：    console.log(this); //Student&#123;&#125;    console.log(this.Foo); //父类实例属性    this.username = username;  &#125;&#125;// 学生类 继承人类class Student extends Person &#123;  constructor(username, school) &#123;    //   console.log(this);//报错    super(username);    console.log(this); //Student &#123;Foo: &#39;父类实例属性&#39;, username: &#39;小明&#39;&#125;    this.school = school;  &#125;&#125;const xiaoming = new Student(&quot;小明&quot;, &quot;高新一中&quot;);</code></pre><blockquote><ul><li>在用<code>extends</code>实现继承时，子类的<code>constructor</code>是没有自己的<code>this</code>，它的<code>this</code>要通过调用<code>super()</code>来执行父类构造函数才能得到</li><li>在执行<code>super()</code>后，父类构造函数会创建一个空的实例对象<code>&#123;&#125;</code>，然后执行父类<code>constructor</code>里面的代码，将父类的属性和方法添加到实例身上</li><li>因此在父类里面<code>this.Foo</code>，才能得到父类的属性</li><li>因为是要给子类使用，所以在JS引擎内部，把父类的实例<code>this</code>修饰成子类的实例<code>Student&#123;&#125;</code>，其内部的<code>constructor</code>也会进行修改</li></ul></blockquote><ol start="2"><li>为什么子类的构造函数中一定要调用<code>super()</code><blockquote><p><code>ES6</code>的继承机制，是先将父类的属性和方法，添加到一个空的对象上面，然后将该对象作为子类的实例，即 <strong>“继承在前，实例在后”</strong>。</p><ul><li>这就是为什么 <code>ES6</code> 的继承必须先调用<code>super()</code>方法，因为这一步会生成一个继承父类的<code>this</code>对象，没有这一步无法继承父类。<blockquote><p>如果不调用<code>super()</code>方法，子类就得不到自己的<code>this</code>对象</p></blockquote></li></ul></blockquote></li></ol><pre><code>// 人类class Person &#123;&#125;// 学生类 继承人类class Student extends Person &#123;  constructor() &#123;&#125;&#125;const xiaoming = new Student(); // 报错</code></pre><blockquote><p>这一点与 <code>ES5</code> 的继承完全不一样，<code>ES5</code> 中关于属性和方法的继承：</p><ul><li>属性继承：在子类的构造函数中调用父类的构造函数，然后利用<code>call</code>方法改变父类构造函数中的<code>this</code>指向，是<strong>“实例在前，继承在后”</strong></li></ul></blockquote><pre><code>// 继承属性People.call(this, name, age);</code></pre><blockquote><ul><li>方法继承： 以父类的原型对象为原型，创建出一个新的对象，然后将子类的原型指向新创建出来的对象</li></ul></blockquote><pre><code>// 继承方法var prototype = Object.create(People.prototype);prototype.constructor = Student;Student.prototype = prototype;</code></pre><ol start="3"><li>注意</li></ol><ul><li><p>子类构造函数中<code>this</code>关键字，只能出现在<code>super()</code>之后</p><blockquote><ul><li>因为子类实例的构造，必须先完成父类的继承，只有调用<code>super()</code>方法后，得到对应的对象，然后将该对象作为子类的实例，子类构造函数中才会有自己的<code>this</code></li></ul></blockquote></li><li><p>子类没有定义<code>constructor()</code>，会默认添加，并且里面会自动调用<code>super()</code></p></li></ul><pre><code>// 计算类class Compute &#123;  // 加  add(x, y) &#123;    console.log(x + y);  &#125;  // 减  minus(x, y) &#123;    console.log(x - y);  &#125;&#125;&gt;// 计算器类 继承 计算类  获得计算类原型上的方法class Calculator extends Compute &#123;&#125;&gt;const calculator = new Calculator();calculator.add(1, 2); // 3calculator.minus(1, 2); // -1</code></pre><h4 id="私有属性和私有方法的继承"><a href="#私有属性和私有方法的继承" class="headerlink" title="私有属性和私有方法的继承"></a>私有属性和私有方法的继承</h4><blockquote><ul><li>父类的私有属性和方法不能被继承</li><li>只有父类的实例方法中读写了私有属性，则子类可以通过这些方法，读写私有属性</li></ul></blockquote><pre><code>// 超类（父类）class SuperType &#123;  #count = 20; // 私有属性  // 私有方法  #sum() &#123;    console.log(&quot;调用父类私有方法sum&quot;);  &#125;  getCount() &#123;    console.log(`读写父类的私有属性#count的值=$&#123;this.#count&#125;`);    this.#sum(); //调用私有方法  &#125;  setCount(value) &#123;    this.#count = value;  &#125;&#125;// 子类class SubType extends SuperType &#123;  constructor() &#123;    super();    // console.log(this.#count);//报错  &#125;&#125;const sub1 = new SubType();sub1.getCount();//读写父类的私有属性#count的值=20//调用父类私有方法sumsub1.setCount(2000);sub1.getCount();//读写父类的私有属性#count的值=2000//调用父类私有方法sum</code></pre><h4 id="静态与实例（属性和方法）的继承"><a href="#静态与实例（属性和方法）的继承" class="headerlink" title="静态与实例（属性和方法）的继承"></a>静态与实例（属性和方法）的继承</h4><blockquote><p>父类的所有属性和方法（公有，静态）都会被子类继承，除了私有属性和私有方法不能被继承。</p><ul><li>注意：静态属性的继承，是通过浅拷贝实现的。所以要特别注意静态属性值是引用类型的情况</li></ul></blockquote><pre><code>// 超类（父类）class SuperType &#123;  constructor(x, y) &#123;    this.x = x;    this.y = y;  &#125;  // 实例方法  point() &#123;    console.log(`($&#123;this.x&#125;,$&#123;this.y&#125;)`);  &#125;// 静态属性  static num = 0;   static arr = [1, 2, 3];  // 静态方法  static getInfo() &#123;    console.log(&quot;父类静态方法getInfo&quot;);  &#125;&#125;&gt;// 子类class SubType extends SuperType &#123;&#125;const sub = new SubType(1, 2);console.log(sub);sub.point(); // 调用实例方法&gt;SubType.num = 3; // 操作静态属性SubType.getInfo(); // 调用静态方法// 静态属性的继承是通过浅浅拷贝实现，所以要特别注意静态属性值如果是引用类型的情况console.log(SubType.num); // 3console.log(SuperType.num); // 0&gt;SubType.arr.push(4);console.log(SubType.arr); // [1, 2, 3, 4]console.log(SuperType.arr); // [1, 2, 3, 4]</code></pre><h4 id="class-属性与方法的继承"><a href="#class-属性与方法的继承" class="headerlink" title="class 属性与方法的继承"></a>class 属性与方法的继承</h4><blockquote><p><code>class</code>作为构造函数的语法糖，同时有<code>prototype</code>和<code>__proto__</code>属性，因此同时存在两条继承链</p><ul><li>子类的<code>__proto__</code>属性表示构造函数的继承（继承父类的静态方法和属性），总是指向父类</li><li>子类的<code>prototype</code>属性的<code>__proto__</code>属性表示方法的继承，总是指向父类的<code>prototype</code>属性<img src="class属性与方法的继承.png"></li></ul></blockquote><ul><li>class 子类继承父类，主要通过以下三条路径来实现<blockquote><ul><li><strong>实例方法</strong>（原型方法）：设置子类的 <code>prototype</code> 属性的原型指向父类的原型，来继承<strong>父类原型上的方法和属性</strong></li></ul></blockquote></li></ul><pre><code>// subType为子类，superType为父类Object.setPrototypeOf(SubType.prototype, SuperType.prototype);// 上面代码，相当于 SubType.prototype.__proto__=SuperType.prototype</code></pre><blockquote><ul><li><strong>静态</strong>属性和方法：设置子类的原型指向父类，来继承父类的静态方法和属性</li></ul></blockquote><pre><code>// subType为子类，superType为父类Object.setPrototype(SubType, Super);// 上面代码，相当于 SubType.__proto__=Super</code></pre><blockquote><ul><li><strong>实例属性</strong>：在子类的构造函数中，调用<code>super()</code>方法，来继承父类实例的属性</li></ul></blockquote><pre><code>// 父类class SuperType &#123;  constructor(x, y) &#123;&#125;&#125;// 子类class SubType extends SuperType &#123;  constructor(x, y) &#123;    super(x, y);  &#125;&#125;</code></pre><blockquote><ul><li>在子类的构造函数中调用<code>super()</code>方法，相当于调用父类 <code>SuperType</code>的构造函数，即 <code>SuperType.prototype.constructor.call(this)</code></li><li>但是，真实情况是先调用<code>super()</code>，在 <code>super</code> 内部会创建一个对象，然后添加父类的实例属性，最后将这个对象返回，作为子类的 <code>this</code>(实例对象)，最后添加子类实例属性。</li></ul></blockquote><h4 id="判断一个类是否继承另一个类"><a href="#判断一个类是否继承另一个类" class="headerlink" title="判断一个类是否继承另一个类"></a>判断一个类是否继承另一个类</h4><blockquote><p>如果<code>Object.getPrototypeOf(类1) === 类2</code>，则说明<code>类1</code>继承<code>类2</code></p></blockquote><pre><code>// 超类（父类）class SuperType &#123;  static arr = [1, 2, 3];&#125;&gt;// 子类class SubType extends SuperType &#123;&#125;&gt;console.log(Object.getPrototypeOf(SubType) === SuperType);//true</code></pre><h4 id="super-关键字"><a href="#super-关键字" class="headerlink" title="super 关键字"></a>super 关键字</h4><blockquote><p>super这个关键字<strong>只能在子类中</strong>使用，既可以当作<strong>函数</strong>使用，也可以当作<strong>对象</strong>使用。在这两种情况下，它的用法完全不同。</p><ul><li>我们来看下<code>super</code>的以下几个应用场景，<code>super</code>分别代表什么</li></ul></blockquote><table><thead><tr><th>场景一</th><th>说明</th></tr></thead><tbody><tr><td><code>super</code>作为函数调用</td><td><code>super</code>在子类的<code>constructor()</code>中作为函数调用，代表父类的构造函数，内部<code>this</code>指向子类的实例对象</td></tr><tr><td><code>super</code>在子类的实例方法中作为对象使用</td><td><code>super</code>在实例方法中作为对象使用，代表父类的原型对象，用<code>super</code>调用的方法，内部的<code>this</code>指向当前子类实例。如果用<code>super</code>对属性赋值，<code>super</code>代表子类实例对象，如果用<code>super</code>读取属性值，<code>super</code>表示父类的原型对象，则读取子类实例属性返回undefined;</td></tr><tr><td><code>super</code>在子类的静态方法中作为对象使用</td><td><code>super</code>在静态方法中，如果用<code>super</code>读取属性值，则<code>super</code>表示父类本身，如果用<code>super</code>来设置某个属性，<code>super</code>表示子类本身。在子类的静态方法中通过<code>super</code>调用父类的方法时，方法内部的<code>this</code>指向当前的子类，而不是子类的实例。</td></tr></tbody></table><ol><li>super 作为函数调用<blockquote><ul><li><code>super</code>在子类的<code>constructor()</code>中作为函数调用，代表<strong>父类的构造函数</strong>。</li><li>但其内部<code>this</code>指向<strong>子类的实例对象</strong>。</li></ul></blockquote></li></ol><pre><code>class A &#123;  constructor(a, b) &#123;    console.log(this); //B &#123;&#125;    this.a = a;    this.b = b;    console.log(this); //B &#123;a: 1, b: 2&#125;  &#125;&#125;class B extends A &#123;  constructor(a, b, x, y) &#123;    super(a, b);    this.x = x;    this.y = y;  &#125;&#125;const b = new B(1, 2, 3, 4);</code></pre><blockquote><ul><li>执行<code>new B(1,2)</code>时，就会执行B类<code>constructor</code>中的<code>super()</code>方法。</li><li>此时<code>super</code>代表父类的构造函数，但内部的<code>this</code>指向<code>B</code>类的实例对象，相当于在<code>B</code>类的<code>constructor</code>方法中执行 <code>A.prototype.constructor.call(this)</code>，这里<strong>只是类比</strong>，目的为了方便理解。</li><li>因为实际 <code>B</code> 类的<code>this</code>是需要通过调用 <code>super</code> 后才能得到。</li></ul></blockquote><blockquote><p><strong>不过要特别注意下面这种特殊情况</strong></p></blockquote><pre><code>// 父类class A &#123;  name = &quot;A&quot;;  constructor(name) &#123;    console.log(this); //B &#123;name: &#39;A&#39;&#125;    console.log(this.name); //A  &#125;&#125;// B 子类class B extends A &#123;  name = &quot;B&quot;;  constructor() &#123;    super();    console.log(this.name); //B  &#125;&#125;const b = new B();console.log(b); //B &#123;name: &#39;B&#39;&#125;</code></pre><blockquote><ul><li>B 类的<code>constructor()</code>中的<code>super</code>代表父类的构造函数，在执行<code>super()</code>时，就会执行父类的<code>constructor</code></li><li>此时，<code>this</code>指向父类的实例，只不过JS对其进行了修饰，如果打印<code>this</code>，会得到<code>B</code>的实例</li><li>执行完父类的<code>constructor</code>后，需要将<code>B</code>的实例作为<code>this</code>，传给子类；</li><li>然后继续执行子类的<code>constructor</code>，此时如果有同名的函数或方法，就会替代</li></ul></blockquote><blockquote><blockquote><p>注意：作为函数调用时，<code>super()</code>只能用在<strong>子类的构造函数</strong>中，其他地方都会报错</p></blockquote></blockquote><ol start="2"><li>super 在子类的实例方法作为对象时<blockquote><ul><li><code>super</code>在子类的实例方法中作为<strong>对象</strong>使用，代表<strong>父类的原型对象</strong>。</li><li>所以 <code>super</code> 是没有办法访问子类实例对象自身的属性和方法。</li><li>不过有一点要值得注意的时，这种情况下用<code>super</code>调用的方法，内部的<code>this</code>指向当前<strong>子类实例</strong>。</li></ul></blockquote></li></ol><pre><code>// 父类class A &#123;  foo() &#123;    console.log(&quot;A中实例方法&quot;); //A中实例方法    console.log(this); //B &#123;count: 5&#125;  &#125;&#125;class B extends A &#123;  count = 5;  bar() &#123;    super.foo(); // super为父类的原型对象，能访问到原型上的方法    console.log(super.count); //undefined 访问不到实例对象上的属性  &#125;&#125;&gt;const b = new B();b.bar();</code></pre><blockquote><ul><li>B 类 bar方法中的<code>super= A.prototype</code>,再加上<code>foo</code>方法内部的<code>this</code>指向B类的实例对象。</li><li>所以<code>super.foo()</code>等同于<code>A.prototype.foo.call(this)</code></li></ul></blockquote><ul><li>super 对属性赋值和取值<blockquote><ul><li>如果用<code>super</code>对某个属性<strong>赋值</strong>，这里的<code>super</code>指代的就是 <code>this</code>（B 类的实例对象），所以赋值的属性会变成<strong>子类的实例属性</strong>。</li><li>但是如果用<code>super</code>来<strong>访问</strong>某个属性时，他指代的是父类的原型对象，只能访问父类原型上的属性，不能访问子类实例对象自身的属性。</li></ul></blockquote></li></ul><pre><code>// 父类class A &#123;&#125;// 子类class B extends A &#123;  bar() &#123;    super.x = 3; // super表示this 实例对象    console.log(super.x); // super表示父类的原型对象，原型上没有这个属性，返回值为undefined  &#125;&#125;&gt;const b = new B();b.bar(); // undefinedconsole.log(b.x); // 3</code></pre><ol start="3"><li>super 在子类的静态方法中，作为对象时<blockquote><ul><li>super 在静态方法中，如果用 super <strong>读取</strong>属性值，则 super 表示父类本身，如果用 super 来<strong>设置</strong>某个属性，super 表示子类本身。</li><li>在子类的静态方法中通过<code>super</code><strong>调用父类的方法</strong>时，<code>super</code>指的是父类，而方法内部的<code>this</code>指向当前的<strong>子类</strong>，而不是子类的实例。</li></ul></blockquote></li></ol><pre><code>// 父类class A &#123;  static count = 3; // 静态属性  static foo() &#123;    // this表示子类，所以$&#123;this.count&#125; 结果为 5    console.log(`返回子类的静态属性count的值$&#123;this.count&#125;`);  &#125;&#125;// 子类class B extends A &#123;  //实例属性  count = 10;  // 静态属性  static count = 5;  // 静态方法  static bar() &#123;    console.log(super.count); // 3   super表示父类    super.num = 44; // super表示子类，成功给子类添加静态属性num    console.log(super.num); // super表示父类，所以返回值为undefined    super.foo(); // super表示父类，其foo()中的this表示子类  &#125;&#125;B.bar();console.log(B.num);//44console.log(A.num);//undefined</code></pre><ol start="4"><li>super 注意事项<blockquote><ul><li>使用 super 的时候，必须<strong>显式指定</strong>是作为函数，还是作为对象使用，否则会报错。</li></ul></blockquote></li></ol><pre><code>// 父类class A &#123;&#125;// 子类class B extends A &#123;    constructor()&#123;        console.log(super) // 报错，因为super不知道是作为对象还是作为函数来使用    &#125;&#125;</code></pre><h4 id="extends-的继承目标"><a href="#extends-的继承目标" class="headerlink" title="extends 的继承目标"></a>extends 的继承目标</h4><blockquote><ul><li><code>extends</code> 关键字后面的值只要是一个有 <code>prototype</code> 属性的函数就可以实现继承。<blockquote><p>了解即可</p></blockquote></li></ul></blockquote><pre><code>function fn() &#123;&#125;fn.count = 2; //fn的静态属性class B extends fn &#123;&#125;console.log(new B()); //B &#123;&#125;console.log(B.__proto__ === fn); //trueconsole.log(B.count); //2</code></pre><h4 id="原生构造函数的继承"><a href="#原生构造函数的继承" class="headerlink" title="原生构造函数的继承"></a>原生构造函数的继承</h4><blockquote><p><strong>原生构造函数</strong>是指语言内置的构造函数，主要用来生成数据结构，常见的原生构造函数大致有：</p><ul><li>三大包装对象：Boolean()、Number()、String()</li><li>数组：Array()</li><li>日期：Date()</li><li>函数：Function()</li><li>对象：Object()</li><li>正则：RegExp()</li><li>错误处理相关：Error()、TypeError()、SyntaxError()、ReferenceError()、RangeError()、URIError()、</li><li>Map() 和 Set()<br>…..等<br>在 <code>ES6</code> 之前，原生构造函数是没有办法被继承的，比如，不能自己定义一个 <code>Array</code> 的子类</li></ul></blockquote><pre><code>function MyArray() &#123;  Array.apply(this, arguments);&#125;// 寄生组合继承let prototype = Object.create(Array.prototype);prototype.constructor = MyArray;MyArray.prototype = prototype;&gt;const arr = new MyArray(1, 2, 3, 4);console.log(arr); // MyArray &#123;&#125;</code></pre><ul><li>上面自定义的<code>MyArray</code>继承<code>Array</code>失败，有两个原因：<blockquote><ul><li>子类构造函数先生成自己的<code>this</code>，<code>this</code>是一个对象<code>&#123;&#125;</code>,然后再讲该对象作为<code>Array.apply()</code>的第一个参数，来改变<code>Array</code>内部的<code>this</code>指向。最后子类的<code>this</code>还是<code>&#123;&#125;</code>，不可能是<code>[]</code></li><li>其二，通过<code>Array.apply()</code>方式并不能改变原生构造函数 <code>Array()</code>的内部 <code>this</code> 指向。也就从而无法拿到原生构造函数的内部属性。</li></ul></blockquote></li></ul><h4 id="ES6-实现原生构造函数继承"><a href="#ES6-实现原生构造函数继承" class="headerlink" title="ES6 实现原生构造函数继承"></a>ES6 实现原生构造函数继承</h4><pre><code>class MyArray extends Array &#123;  //...args是用来接收剩余参数 args是数组  constructor(...args) &#123;    super(...args); //...是展开运算符 将args展开  &#125;&#125;let arr = new MyArray(1, 2, 3, 4);console.log(arr); //MyArray(4) [1, 2, 3, 4]arr.push(5, 6);console.log(arr); //MyArray(6) [1, 2, 3, 4, 5, 6]console.log(arr.length); //6</code></pre><blockquote><p><strong>以上代码中：</strong></p><ul><li>上面<code>MyArray</code>类完美的继承了<code>Array</code>类，是因为<code>ES6</code>是通过<code>super()</code>来完成<strong>实例属性</strong>的继承。</li><li><code>super()</code>调用时，会先新建父类的实例对象<code>this</code>，然后将父类的实例属性绑定到<code>this</code>上，最后用子类的构造函数修饰<code>this</code>，绑定子类的实例属性。</li></ul></blockquote><blockquote><blockquote><p>温馨提示：</p></blockquote><ul><li>如果想在原有的构造函数的基础上定义自己的数据结构，可以定义子类来继承原生构造函数。</li></ul></blockquote><ul><li>特别注意<blockquote><p>继承<code>Object</code>的子类，不能通过<code>super()</code>方法向父类<code>Object</code>传参。</p><ul><li>这是因为 <code>ES6</code> 中规定，如果 <code>Object</code>不是通过<code>new Object()</code>这种形式调用，则会<strong>忽略</strong><code>Object</code>构造函数的参数。</li></ul></blockquote></li></ul><pre><code>class NewObj extends Object &#123;  constructor(...args) &#123;    super(...args);  &#125;&#125;let obj = new NewObj(&#123; a: 1 &#125;);console.log(obj.a); // undefined ,如果传参成功，是返回结果 1&gt;obj = new Object(&#123; a: 1 &#125;);console.log(obj.a); // 1</code></pre><ul><li>应用：创建 Array 子类，添加洗牌算法<blockquote><ul><li>从最后一位数开始，将它和前面的任一位置的数字调换位置</li></ul></blockquote></li></ul><pre><code>class SuperArray extends Array &#123;  // 洗牌算法  shuffle() &#123;    for (let i = this.length - 1; i &gt; 0; i--) &#123;      const j = Math.floor(Math.random() * (i + 1));      [this[i], this[j]] = [this[j], this[i]];    &#125;  &#125;&#125;&gt;const arr = new SuperArray(...[1, 2, 3, 4, 5, 6, 7, 8, 9, 10]);console.log(arr);arr.shuffle();console.log(arr);</code></pre><h3 id="五、构造函数与-Class-类的不同点"><a href="#五、构造函数与-Class-类的不同点" class="headerlink" title="五、构造函数与 Class 类的不同点"></a>五、构造函数与 Class 类的不同点</h3><ol><li>构造函数可以直接调用也可以 new 调用，但 class 类只能 new 调用</li></ol><pre><code>function Fn() &#123;&#125;Fn();const fn=new Fn();class A &#123;&#125;const a=new A();A(); // 报错</code></pre><ol start="2"><li>class 类的内部定义的所有方法都是不可枚举的，而 ES5 中原型上定义的方法，都是可以枚举的</li></ol><pre><code>function Fn() &#123;&#125;Fn.prototype.say = function () &#123;&#125;;&gt;class A &#123;  say() &#123;&#125;&#125;&gt;for (let key in new Fn()) &#123;  console.log(key); // say&#125;&gt;for (let key in new A()) &#123;  console.log(key); // 啥也没有&#125;</code></pre><ol start="3"><li>class 类不存在变量提升，而 Es5 中的构造函数存在函数声明的提升<blockquote><ul><li>class类在继承时，父类必须在子类前声明</li></ul></blockquote></li></ol><pre><code>new A(); // 报错  因为 class类不存在变量提升new Fn();function Fn() &#123;&#125;class A &#123;&#125;&gt;function Son() &#123;  Fn.apply(this);&#125;function Fn() &#123;&#125;&gt;class B extends A &#123;&#125; //报错class A &#123;&#125;</code></pre><ol start="4"><li><code>class</code>类的静态方法，可以被子类继承，而<code>ES5</code>的继承方式，是没有办法实现这一点，需要借助<code>ES6</code>的<code>Object.setPrototypeOf()</code>来实现。<blockquote><ul><li><code>__proto__</code>是各浏览器实现的，并不是 JS 原生支持的，生产环境不建议用，会对环境产生依赖</li></ul></blockquote></li></ol><pre><code>function A() &#123;&#125;A.count = 2;A.say = function () &#123;  console.log(this);&#125;;function B() &#123;&#125;&gt;B.__proto__ = A; // 并非原生支持// ES6实现 Object.setPrototypeOf(B, A);console.log(B.count);B.say();</code></pre><ol start="5"><li>构造函数的方法都有<code>prototype</code>属性，而 <code>class</code> 类的方法是没有这个属性的</li></ol><pre><code>class A &#123;  say() &#123;&#125;&#125;const a = new A();console.log(a.say.prototype); // undefined&gt;function B() &#123;&#125;B.prototype.say = function () &#123;&#125;;const b = new B();console.log(b.say.prototype); // &#123;constructor: ƒ&#125;</code></pre><ol start="6"><li>ES5 中没有办法继承原生构造函数，而 ES6 中是可以的。</li></ol><h3 id="六、总结"><a href="#六、总结" class="headerlink" title="六、总结"></a>六、总结</h3><ol><li>class 的基本用法<blockquote><ul><li>class 定义一个类，其类名首字母大写，类中需要显示定义<code>constructor</code>函数。如果省略不写，<strong>默认自动添加空的</strong><code>constructor</code>函数。</li></ul></blockquote></li></ol><pre><code>class A &#123;&#125;// 或class A &#123;  constructor() &#123;&#125;&#125;</code></pre><blockquote><ul><li>class 的写法其实就是一个语法糖，本质上也是一个函数，底层还是使用的构造函数的机制。</li></ul></blockquote><pre><code>class A &#123;&#125;console.log(typeof A); // functionconsole.log(A.prototype.constructor === A); // true</code></pre><ol start="2"><li><p>class 的属性和方法(实例，静态、私有)</p><table><thead><tr><th>属性和方法</th><th><code>es6</code>的<code>class</code>写法</th><th><code>es5</code>写法</th></tr></thead><tbody><tr><td>实例属性</td><td>直接写在<code>class</code>体内的最顶部，或定义在<code>constructor</code>的<code>this</code>上</td><td>写在函数内部的属性</td></tr><tr><td>原型属性</td><td>写在<code>class</code>外部：<code>类名.prototype.属性名=属性值</code></td><td>写在函数外部：<code>函数名.prototype.属性名=属性值</code></td></tr><tr><td>实例方法(原型方法)</td><td>直接写在<code>class</code>体内,如:<code>函数名()&#123;&#125;</code></td><td>写在<code>函数名.prototype</code>上</td></tr><tr><td>静态属性和方法</td><td>在实例属性或方法前加上<code>static</code>关键字，表示该属性和方法为静态的</td><td>在函数外部，用<code>函数名.属性名/方法名</code>的方式定义</td></tr><tr><td>私有属性和私有方法</td><td>在实例属性或方法前加上<code>#</code>号，表示该属性和方法为私有的</td><td>只能模拟</td></tr><tr><td>静态的私有属性和方法</td><td>在私有属性或方法前加上 static关键字，表示该 属性和方法是静态私有属性或方法</td><td>只能模拟</td></tr></tbody></table></li><li><p>ES5 模拟私有属性和方法（重点掌握）</p><table><thead><tr><th>方法</th><th>缺点（或优点）</th></tr></thead><tbody><tr><td>在属性名前加<code>_</code>来区分</td><td>这种方式只是人为约定的一种写法，但并不保险 ，在类的外部还是可以访问</td></tr><tr><td>将变量移到构造函数外，利用闭包来实现</td><td>这种方式所有实例对象操作的是同一个私有属性。本质上不能算是模拟私有变量。（当作了解）</td></tr><tr><td>利用<code>Symbol</code>值的唯一性，将变量名改为<code>Symbol</code>类型</td><td>相对安全，但是如果非要访问，也是可以在类的外部访问到。比如：<code>getOwnPropertySymbols()</code>或<code>Reflect.ownKeys()</code>都可以拿到</td></tr><tr><td>利用 weakMap 来实现</td><td>非常完美如果有多个私有属性，则要把所有私有属性绑定到一个对象上。</td></tr></tbody></table></li><li><p><code>new.target</code> 属性</p><blockquote><p><code>new.target</code>表示在构造函数中，返回<code>new</code>命令所作用的构造函数。<br><strong>作用：</strong></p><ul><li>常判断 <code>new.target === 构造函数</code> 是否成立，来判断当前构造函数是否通过 <code>new</code> 来调用</li><li>常判断 <code>new.target === 子类</code> 是否成立，来保证当前类子能通过<strong>继承</strong>来使用</li></ul></blockquote></li><li><p>extends 继承</p><blockquote><p>ES6 中用 <code>extends</code> 来实现类与类之间的继承</p><ul><li>类与类之间可以实现实例属性、实例方法、静态属性和方法的继承。</li></ul></blockquote></li></ol><pre><code>class A &#123;&#125; // 父类Aclass B extends A &#123;&#125; // 子类B继承父类A</code></pre><ul><li>实际上<code>extends</code> 关键字后面只要是一个有<code>prototype</code>属性的构造函数，都可以实现继承。</li></ul><pre><code>function A() &#123;&#125;class B extends A &#123;&#125;new B();</code></pre><ol start="6"><li>super 关键字<blockquote><ul><li><code>super</code>既可以作为<strong>函数</strong>调用，又可以作为<strong>对象</strong>使用</li><li>使用<code>super</code>的时候，必须<strong>显式指定</strong>作为函数还是作为对象使用，否则会报错<br>以下是 <code>super</code> 的不同场景下，所表达的不同含义</li></ul></blockquote></li></ol><table><thead><tr><th>场景</th><th>说明</th></tr></thead><tbody><tr><td><code>super</code>作为函数调用</td><td><code>super</code>在子类的<code>constructor()</code>中作为函数调用，代表父类的构造函数，内部<code>this</code>指向子类的实例对象</td></tr><tr><td><code>super</code>在子类的实例方法中作为对象使用</td><td><code>super</code>在实例方法中作为对象使用，代表父类的原型对象，用<code>super</code>调用的方法，内部的<code>this</code>指向当前子类实例。如果用<code>super</code>对属性赋值，<code>super</code>代表子类实例对象，如果用<code>super</code>读取属性值，<code>super</code>表示父类的原型对象，则读取子类实例属性返回<code>undefined</code>;</td></tr><tr><td><code>super</code>在静态方法中作为对象使用</td><td><code>super</code>在静态方法中，如果用<code>super</code>读取属性值，则<code>super</code>表示父类本身，如果用<code>super</code>来设置某个属性，<code>super</code>表示子类本身。在子类的静态方法中通过<code>super</code>调用父类的方法时，方法内部的<code>this</code>指向当前的子类，而不是子类的实例。</td></tr></tbody></table><h3 id="七、测试题"><a href="#七、测试题" class="headerlink" title="七、测试题"></a>七、测试题</h3><ol><li>以下代码的运行结果是 ？</li></ol><pre><code>class A &#123;  color = &quot;red&quot;;  constructor(x, y) &#123;    this.x = x;    this.y = y;  &#125;  aSay() &#123;    console.log(this.x);  &#125;&#125;&gt;class B extends A &#123;  constructor(x, y) &#123;    super();  &#125;  bSay() &#123;    console.log(this.x);  &#125;&#125;&gt;const a = new A(1, 2);const b = new B(4, 5);a.aSay();b.bSay();</code></pre><blockquote><p><code>a.aSay();</code></p><ul><li>当a声明时，x&#x3D;1,y&#x3D;2，<code>this</code>代表实例a，所以<code>this.x=1</code><br><code>b.bSay();</code></li><li>当b声明时，x&#x3D;4,y&#x3D;5，调用bSay方法，<code>this</code>指的是实例b，也就是要打印<code>b.x</code>，B类里面并没有这个实例属性，由于B继承于A，所以还可以去A里面找，A有实例属性x，但是<code>super</code>并没有把值传进去，所以返回<code>undefined</code></li></ul></blockquote><ol start="2"><li>以下代码的运行结果是 ？</li></ol><pre><code>class A &#123;  //实例属性  color = &quot;red&quot;;  constructor(x) &#123;    this.x = x;  &#125;  //静态属性  static aSay() &#123;    console.log(this.x);  &#125;  //实例方法(原型方法)  aShow() &#123;    console.log(this.color);  &#125;&#125;&gt;class B extends A &#123;  constructor(x) &#123;    super(x);  &#125;  //静态方法  static bSay() &#123;    super.aSay();  &#125;  //实例方法(原型方法)  bShow() &#123;    super.aShow();    console.log(super.color);  &#125;&#125;&gt;const b = new B(11);B.bSay();//undefinedB.bSay();//red undefined</code></pre><blockquote><p><code>B.bSay();</code></p><ul><li><code>super</code>在静态方法作为对象调用父类的方法，<code>this</code>指向子类即：<code>B.x</code>，但B类没有这个静态属性，所以<code>undefined</code><br><code>b.bShow();</code></li><li><code>super.aShow()</code>：<code>super</code>在子类的实例方法里作为对象调用父类的方法，<code>super</code>代表父类的原型对象<code>A.prototype</code>，内部的<code>this</code>指向子类实例<code>b</code>,即<code>this.color=b.color</code>，b从A那里继承了这个实例属性，所以输出<code>this.color=red</code></li><li><code>console.log(super.color);``super</code>在子类的实例方法里作为对象时，如果读取属性值，<code>super</code>代表父类的原型对象<code>A.prototype</code>，<code>super.color</code>即：<code>A.prototype.color</code>，但A并没有这个原型属性，所以返回<code>undefined</code></li></ul></blockquote>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JS核心知识点（二十）</title>
      <link href="/2023/12/11/JS%E6%A0%B8%E5%BF%83%E7%9F%A5%E8%AF%86%E7%82%B9%EF%BC%88%E4%BA%8C%E5%8D%81%EF%BC%89/"/>
      <url>/2023/12/11/JS%E6%A0%B8%E5%BF%83%E7%9F%A5%E8%AF%86%E7%82%B9%EF%BC%88%E4%BA%8C%E5%8D%81%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<span id="more"></span><h3 id="一、Set-的核心基础"><a href="#一、Set-的核心基础" class="headerlink" title="一、Set 的核心基础"></a>一、Set 的核心基础</h3><blockquote><ul><li><code>Set</code>是<code>ES6</code>中指供的一种新的数据结构，<code>Set</code>对象允许你存储<strong>任何类型</strong>的唯一值。</li><li>我们常把 Set 与数组来做对比，Set 和数组在存储数据时，<strong>最大的区别</strong>就在于 Set 的成员是唯一的，而数组是可以重复的。</li><li>Set 本身是一个构造函数，用来生成 Set 数据结构</li></ul></blockquote><h4 id="Set-的基本用法"><a href="#Set-的基本用法" class="headerlink" title="Set 的基本用法"></a>Set 的基本用法</h4><ol><li>创建 Set，并初始化成员<blockquote><p><strong>重点提示：</strong></p><ul><li><code>Set</code>函数可以接受一个数组（或者<strong>可迭代对象</strong>）作为参数，用来初始化成员</li><li>常见的可迭代对象有：<code>数组、arguments、NodeList、Map、HTMLCollection、String 类型</code><blockquote><p>对象不是可迭代对象</p></blockquote></li></ul></blockquote></li></ol><pre><code>//  传入参数为数组，数组为可迭代对象const s1 = new Set([1, 2, 3]);console.log(s1); // Set(3) &#123;1, 2, 3&#125;&gt;// 传入参数为NodeList,NodeList为可迭代对象const list = document.querySelectorAll(&quot;ul li&quot;);const s2 = new Set(list);console.log(s2); // Set(4) &#123;li, li, li, li&#125;&gt;// 传入参数为arguments，arguments为可迭代对象function fn() &#123;  const s = new Set(arguments);  console.log(s); // Set(3) &#123;1, 2, &#39;ab&#39;&#125;&#125;fn(1, 2, &quot;ab&quot;);</code></pre><ul><li>对象为非迭代对象，但为对象添加迭代器，那对象也可以作为Set的参数</li></ul><pre><code>const obj = &#123;  a: 1,  b: 2,  arr: [3, 4, 5],&#125;;// 但为对象添加迭代器，那对象也可以作为Set的参数obj[Symbol.iterator] = function* () &#123;  for (let key in this) &#123;    yield this[key];  &#125;&#125;;const s3 = new Set(obj);console.log(s3); // Set(3) &#123;1, 2, Array(3)&#125;</code></pre><ol start="2"><li>创建<code>Set</code>，利用<code>add</code>方法添加成员</li></ol><pre><code>const s = new Set();// add方法向Set中添加成员s.add(1);s.add(2);s.add(3);console.log(s);// Set(3) &#123;1, 2, 3&#125;</code></pre><blockquote><blockquote><p>注意区分<code>Set</code>函数的参数和<code>Set</code> 成员</p></blockquote><ul><li>在使用<code>new Set()</code>来初始化的时候，其参数只能是数组或者可迭代对象，不能是对象</li><li>而<code>Set</code>成员可以是<strong>任何类型</strong>的唯一值，所以可以是对象</li></ul></blockquote><h4 id="Set-成员的唯一性"><a href="#Set-成员的唯一性" class="headerlink" title="Set 成员的唯一性"></a><code>Set</code> 成员的唯一性</h4><blockquote><p><code>Set</code> 中的成员必需是唯一的，其内部判断两个值是否相同<strong>类似</strong>于精确相等运算符 <code>===</code>，主要的<strong>区别</strong> <code>Set</code> 中认为 <code>NaN</code> 和 <code>NaN</code> 是相等的</p></blockquote><pre><code>const s = new Set([1, 2, 3, 3, NaN, 4, NaN]);// 因为Set成员必需是唯一的，所以3和NaN只保留了一个console.log(s); // Set(5) &#123;1, 2, 3, NaN, 4&#125;&gt;const s = new Set([&#123; a: 1 &#125;, 1, &#123; a: 1 &#125;, [&quot;A&quot;], +0, 0, -0]);console.log(s);//Set(5) </code></pre>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JS核心知识点（十九）</title>
      <link href="/2023/12/09/JS%E6%A0%B8%E5%BF%83%E7%9F%A5%E8%AF%86%E7%82%B9%EF%BC%88%E5%8D%81%E4%B9%9D%EF%BC%89/"/>
      <url>/2023/12/09/JS%E6%A0%B8%E5%BF%83%E7%9F%A5%E8%AF%86%E7%82%B9%EF%BC%88%E5%8D%81%E4%B9%9D%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<span id="more"></span><h2 id="ES6-箭头函数-和-对象自面量增强，大厂面试真题解析"><a href="#ES6-箭头函数-和-对象自面量增强，大厂面试真题解析" class="headerlink" title="ES6 箭头函数 和 对象自面量增强，大厂面试真题解析"></a>ES6 箭头函数 和 对象自面量增强，大厂面试真题解析</h2><h3 id="一、箭头函数"><a href="#一、箭头函数" class="headerlink" title="一、箭头函数"></a>一、箭头函数</h3><blockquote><p>我们先来了解什么是箭头函数，箭头函数的结构，以及如何将一般函数改写成箭头函数</p><ul><li>引入箭头函数有两个方面的作用：<strong>更简短</strong>的函数并且<strong>不绑定this</strong></li></ul></blockquote><h4 id="什么是箭头函数"><a href="#什么是箭头函数" class="headerlink" title="什么是箭头函数"></a>什么是箭头函数</h4><blockquote><ul><li>箭头函数也是函数，与之前学过的 ES5 中的 function 关键字定义的函数写法不同</li><li>ES6 规定了可以使用 “箭头” <code>=&gt;</code> 来定义一个函数，语法更加简洁。不用再书写 <code>function</code> 关键字</li><li>箭头函数的结构:<code>const/let 函数名 = (参数 )=&gt; 函数体</code></li></ul></blockquote><ol><li>如何将一般函数改写成箭头函数？<blockquote><ul><li>在 ES5 中我们学习过两种函数形式（函数声明形式、函数表达式形式）</li></ul></blockquote></li></ol><pre><code>// 声明形式function sum() &#123;&#125;// 函数表达式形式var sum = function () &#123;&#125;;// 函数表达式形式 -&gt; 箭头函数const sum = () =&gt; &#123;&#125;;&gt;// 箭头函数省略了function关键字，通过箭头 =&gt; 定义函数</code></pre><blockquote><blockquote><p>注意：</p></blockquote><ul><li><code>var</code>和<code>function</code>声明的变量和函数会存在变量和函数声明提升，而<code>let</code>和<code>const</code>声明的变量是<strong>不存在变量提升</strong>的。</li><li>所以用<code>let</code>和<code>const</code>声明的变量保存的箭头函数，一定要在<strong>声明后才能使用</strong></li></ul></blockquote><pre><code>//函数声明sum1(1, 2); //3 function sum1(a, b) &#123;   console.log(a + b); &#125;&gt;//函数表达式:sum2在预编译时是作为一个变量，值为undefined,如果在声明前作为函数调用，会报错 sum2(2, 3); //报错 var sum2 = function (a, b) &#123;   console.log(a + b); &#125;;&gt;//const、let没有变量提升 sum3(4, 5);//抛出引用错误 const sum3 = (a, b) =&gt; &#123;   console.log(a + b); &#125;;</code></pre><h4 id="箭头函数的注意事项"><a href="#箭头函数的注意事项" class="headerlink" title="箭头函数的注意事项"></a>箭头函数的注意事项</h4><blockquote><p>我们知道箭头函数比普通函数写起来更简洁，当满足一定条件的时候，箭头函数还可以写的更加简洁。</p></blockquote><ol><li>单个参数 ：单个参数可以省略圆括号</li></ol><pre><code>// 单个参数const sum = x =&gt; &#123;  return x + 1;&#125;;console.log(sum(1)); // 2</code></pre><blockquote><ul><li>如果使用vscode，则会自动加上</li></ul></blockquote><ol start="2"><li>无参数或多个参数：不能省略圆括号</li></ol><pre><code>// 无参数，不能省略圆括号const sum = () =&gt; &#123;  return 2 + 3;&#125;;console.log(sum()); // 5&gt;// 多参数，不能省略圆括号const sum = (a, b) =&gt; &#123;  return a + b;&#125;;console.log(sum(2, 3));</code></pre><ol start="3"><li><strong>单行</strong>函数体：可以同时省略 <code>&#123;&#125;</code> 和 <code>return</code></li></ol><pre><code>const sum = (a, b) =&gt; &#123;  return a + b; // 函数体内只有一条语句&#125;;&gt;// 以上单行函数体，可以同时省略 &#123;&#125; 和 returnconst sum = (a, b) =&gt; a + b;console.log(sum(2, 3)); // 5</code></pre><ol start="4"><li><strong>单行对象</strong>：（同属于单行函数体，会比较特殊）<blockquote><ul><li>如果箭头函数返回单行对象，可以在<code>&#123;&#125;</code>外面加上<code>()</code> ，让浏览器不再认为那是函数体的花括号</li><li>并且可以省略<code>return</code></li></ul></blockquote></li></ol><pre><code>// 单行对象const sum = (a, b) =&gt; &#123;  return &#123;    value: a + b,  &#125;;&#125;;console.log(sum(2, 3)); // &#123;value: 5&#125;//简化：const sum = (a, b) =&gt; (&#123; value: a + b &#125;);console.log(sum(2, 3)); //&#123;value: 5&#125;</code></pre><ol start="5"><li>单行数组<blockquote><ul><li>也属于单行函数体，一样可以省略花括号和<code>return</code></li></ul></blockquote></li></ol><pre><code>const sum = (a, b) =&gt; &#123;  return [a, b];&#125;;console.log(sum(2, 3)); // [2, 3]&gt;// 简写const sum = (a, b) =&gt; [a, b];console.log(sum(2, 3)); // [2, 3]</code></pre><ol start="6"><li>箭头函数的嵌套简写</li></ol><pre><code>function sum(a) &#123;  return function fn1(b) &#123;    return function fn2(c) &#123;      return function fn3(d) &#123;        return a + b + c + d;      &#125;;    &#125;;  &#125;;&#125;console.log(sum(1)(2)(3)(4));//10&gt;// 改写用箭头函数const sum2 = (a) =&gt; (b) =&gt; (c) =&gt; (d) =&gt; a + b + c + d;console.log(sum2(1)(2)(3)(4));//10</code></pre><blockquote><blockquote><p>不管箭头函数嵌套几层，只要记住，有几个<code>=&gt;</code>就有几个箭头函数，<code>=&gt;</code>函数<strong>左边是参数，右边是函数体</strong></p></blockquote></blockquote><h4 id="普通函数（非箭头函数）中的-this-指向"><a href="#普通函数（非箭头函数）中的-this-指向" class="headerlink" title="普通函数（非箭头函数）中的 this 指向"></a>普通函数（非箭头函数）中的 this 指向</h4><blockquote><p>普通函数（非箭头函数）中的 <code>this</code> 指向把函数当成方法调用的对象，<strong>谁把函数当成方法调用，this 指向谁。</strong></p><ul><li>具体不同场景下函数（非箭头）函数中 this 指向，如下表：</li></ul></blockquote><table><thead><tr><th>函数的调用方式</th><th>this 指向(非严格模式)</th><th>this 指向（严格模式）</th></tr></thead><tbody><tr><td>全局作用域下</td><td>window</td><td>window</td></tr><tr><td>函数()</td><td>window</td><td>undefined</td></tr><tr><td>对象.函数()</td><td>对象</td><td>对象</td></tr><tr><td>IIFE 立即执行函数</td><td>window</td><td>undefined</td></tr><tr><td>数组[下标 ]()</td><td>数组</td><td>数组</td></tr><tr><td>fn.call(thisArg,arg1,arg2)</td><td>thisArg</td><td>thisArg</td></tr><tr><td>fn.apply(thisArg，arry)</td><td>thisArg</td><td>thisArg</td></tr><tr><td>fn.bind(thisArg，arg1,arg2)</td><td>thisArg</td><td>thisArg</td></tr><tr><td>定时器中的回调函数</td><td>window</td><td>window</td></tr><tr><td>DOM 事件处理函数 element.onclick&#x3D;function(){ &#x2F;&#x2F; this指向 }</td><td>element</td><td>element</td></tr><tr><td>var obj&#x3D;new 函数()</td><td>obj</td><td>obj</td></tr></tbody></table><blockquote><ul><li>全局作用域下</li></ul></blockquote><pre><code>// 全局作用域下console.log(this); //window</code></pre><ul><li><code>函数()</code>自调用</li></ul><pre><code>// 函数()&quot;use strict&quot;;function sum() &#123;  console.log(this);&#125;sum(); // 严格模式下结果为 undefined  非严格模式下 window</code></pre><ul><li><code>对象.函数()</code></li></ul><pre><code>// 对象.函数()const obj = &#123;  name: &quot;清心&quot;,  getName: function () &#123;    console.log(this);  &#125;,&#125;;obj.getName(); // &#123;name: &#39;清心&#39;, getName: ƒ&#125;</code></pre><ul><li><code>IIFE</code> 立即执行函数</li></ul><pre><code>// IIFE 立即执行函数&quot;use strict&quot;;(function () &#123;  console.log(this); // 严格模式下结果为 undefined  非严格模式下 window&#125;)();</code></pre><ul><li><code>数组[下标 ]()</code></li></ul><pre><code>// 数组[下标 ]()function fn() &#123;  console.log(this);&#125;const arr = [fn, 1, 2];&gt;arr[0](); // [fn, 1, 2]fn(); // window</code></pre><ul><li>函数调用 call、apply、bind 方法</li></ul><pre><code>// 函数调用call,apply,bind方法const obj = &#123;  a: 1,  b: 2,&#125;;function sum(a, b) &#123;  console.log(this.a + this.b);  console.log(this);&#125;sum.call(obj, 3, 4); // 3  objsum.apply(obj, [3, 4]); // 3 objlet fn = sum.bind(obj);fn(); // 3  obj</code></pre><ul><li>回调函数</li></ul><pre><code>//  回调函数&quot;use strict&quot;;setTimeout(function () &#123;  console.log(this);// window&#125;, 1000);&gt;const arr = [1, 0, 3, 7, 5];let result = arr.find(function (value, index, arr) &#123;  console.log(this); // window  return value &gt; 2;&#125;);console.log(result);//3</code></pre><ul><li>事件处理函数</li></ul><pre><code>// 事件处理函数const box = document.querySelector(&quot;.box&quot;);box.onclick = function () &#123;  console.log(this); // &lt;div class=&quot;box&quot;&gt;点击我&lt;/div&gt;&#125;;</code></pre><ul><li>构造函数中</li></ul><pre><code>// new 函数()function Point(x, y) &#123;  this.x = x;  this.y = y;  console.log(this); //  &#123;x: 2, y: 3&#125;&#125;const point = new Point(2, 3);</code></pre><ul><li>分析以下代码中的 this 指向</li></ul><pre><code>// 判断以下函数中this指向谁 ？function sum() &#123;  console.log(this);&#125;// 声明一个 calc 计算器对象，add为对象的属性名，sum为上边的函数名const calc = &#123;  add: sum,&#125;;calc.add(); // &#123;add: ƒ&#125;  ，this 指向 calc 对象&gt;// 根据我们上边学过的，谁调用就指向谁，因此 this 指向 calc 对象&gt;// 判断以下this的指向const adder = calc.add;adder(); // undefined -&gt; window（在非严格模式下，浏览器帮我们将this指向从 undefined 转化成了 window）</code></pre><h4 id="箭头函数中的-this-指向"><a href="#箭头函数中的-this-指向" class="headerlink" title="箭头函数中的 this 指向"></a>箭头函数中的 this 指向</h4><blockquote><p>箭头函数中没有自己的<code>this</code>，在箭头函数中访问<code>this</code>，需要<strong>沿着作用域链向外查找</strong>。</p></blockquote><pre><code>const calc = &#123;  sum: () =&gt; &#123;    console.log(this);  &#125;,&#125;;calc.sum(); // window</code></pre><blockquote><blockquote><p>分析以上代码，思考：</p></blockquote><p>为什么<code>calc.sum()</code>调用函数时<code>this</code>的指向为<code>window</code> ？我们知道箭头函数没有自己的<code>this</code>，那为什么当前的 <code>this</code> 会指向 <code>window</code> 呢 ？<br>这时，就需要结合我们前面学过的<strong>作用域链的机制</strong>来分析了 。</p><ul><li>首先，箭头函数没有自己的 <code>this</code>，我们通过 <code>calc</code> 对象来调用 <code>sum()</code> 方法时（即：<code>calc.sum();</code>），就会执行<code>console.log(this);</code></li><li>这时 ，就会先在<strong>当前的</strong>箭头函数执行形成的函数作用域中来查找 <code>this</code> ，而箭头函数又没有自己的<code>this</code> 因此，在当前作用域中就找不到 <code>this</code>。根据作用域链的机制，就会往外层寻找</li><li>它的外层是 <code>calc</code> 对象，我们知道<strong>对象没有作用域</strong>，再往外找，就是全局作用域了</li><li>因此，当 <code>console.log(this);</code> 就找到了<strong>全局</strong>作用域中的<code>this</code> ，全局作用域中的 <code>this</code> 即指向 <code>window</code> 了</li></ul></blockquote><blockquote><ul><li>练习以下案例，深入分析函数中的 this 指向</li></ul></blockquote><pre><code>// &quot;use strict&quot;;const calc = &#123;  add: function () &#123;    const adder = () =&gt; &#123;      console.log(this);    &#125;;    adder();  &#125;,&#125;;calc.add(); // &#123;add: ƒ&#125; this指向 calc对象&gt;//不直接调用，而是赋值给一个新的函数const addFoo = calc.add;addFoo(); // undefined -&gt; window（在非严格模式下，浏览器帮我们将this指向从 undefined 转化成了 window）&gt;// 严格模式下，this 指向 undefined//相当于：const addFoo =function () &#123;    const adder = () =&gt; &#123;      console.log(this);    &#125;;    adder();  &#125;,</code></pre><blockquote><ul><li><code>calc.add();</code>：调用<code>calc</code>对象里的<code>add</code>方法，它是一个普通函数，按照谁调用<code>this</code>就指向谁的原则，现在<code>add</code>函数中的<code>this</code>指向<code>calc</code>；</li><li>调用<code>add</code>方法时，它里面的箭头函数也自动调用了，需要打印<code>this</code>，而箭头函数没有<code>this</code>，所以就会向外找，于是就拿到它的外层函数<code>add</code>的<code>this</code>：<code>calc</code></li></ul></blockquote><blockquote><ul><li>调用<code>addFoo();</code>，相当于调用<code>function</code>函数，它自己调用自己，没有<code>this</code>指向，所以需要向外找，在全局作用域里找到<code>window</code>(严格模式下，this 指向 undefined)</li><li>调用<code>add</code>方法时，它里面的箭头函数也自动调用了，需要打印<code>this</code>，而箭头函数没有<code>this</code>，所以就会向外找，于是就拿到它的外层函数<code>function</code>的<code>this</code>：<code>window</code>,(严格模式下，this 指向 undefined)</li></ul></blockquote><h4 id="不适用箭头函数的场景"><a href="#不适用箭头函数的场景" class="headerlink" title="不适用箭头函数的场景"></a>不适用箭头函数的场景</h4><blockquote><p>我们通过前边的学习发现，使用箭头函数用起来省时省力，非常方便 。在以后的 ES6 代码中，就可以使用箭头函数来代替一般的函数了。但并不是在所有的地方都可以使用箭头函数</p><blockquote><p>以下几种情况不适用箭头函数：</p></blockquote><ul><li>作为构造函数</li><li>需要 this 指向调用对象的时候</li><li>需要使用 arguments 的时候</li></ul></blockquote><ol><li>作为构造函数</li></ol><pre><code>const Person = () =&gt; &#123;&#125;;new Person(); // Uncaught TypeError: Person is not a constructor&gt;// 直接报错 Person不是构造函数</code></pre><blockquote><blockquote><p>因为</p></blockquote><ul><li>箭头函数没有<code>this</code>，而构造函数最重要的就是<code>this</code>，在实例化构造函数之后它里面的 <code>this</code> 指向就应该<strong>指向它实例化之后得到的实例对象</strong>，而箭头函数本身没有<code>this</code>，我们肯定就不能使用箭头函数来作为构造函数</li></ul></blockquote><ol start="2"><li>需要 this 指向调用对象的时候</li></ol><ul><li><strong>事件处理函数</strong>中的 <code>this</code> 一般都是<strong>指向绑定事件的对象</strong>，所以事件处理函数不要写成箭头函数</li></ul><pre><code>// 使用最原始的方式document.onclick = function () &#123;  console.log(this); // document&#125;;// 当点击浏览器任意位置是，this指向 document&gt;// 使用绑定监听事件的方式document.addEventListener(  &quot;click&quot;,  function () &#123;    console.log(this); // document  &#125;,  false);// 当点击浏览器任意位置是，this指向 document&gt;// 如果使用箭头函数时，箭头函数本身没有this// 根据作用域链的机制，就会往外层作用域中找。找到全局作用域中就指向 window了document.addEventListener(  &quot;click&quot;,  () =&gt; &#123;    console.log(this); // window  &#125;,  false);</code></pre><ul><li>对象方法中的<code>this</code>是<strong>需要指向调用方法的对象</strong>，所以对象的方法不要写成箭头函数</li></ul><pre><code>// 对象的方法使用箭头函数const obj = &#123;  num: 1,  sayHello: () =&gt; &#123;    console.log(this.num); // undefined  &#125;,&#125;;obj.sayHello();&gt;// 对象方法使用普通函数const obj = &#123;  num: 1,  sayHello: function () &#123;    console.log(this.num); // 1  &#125;,&#125;;obj.sayHello();</code></pre><ol start="3"><li>需要使用 arguments 的时候<blockquote><ul><li>在 ES6 中箭头函数里没有 <code>arguments </code></li></ul></blockquote></li></ol><pre><code>// 使用 arguments 来接受不确定实参，然后循环遍历arguments类数组function sum() &#123;  console.log(arguments);&#125;sum(1, 2, 3); // Arguments(3) [1, 2, 3, callee: ƒ, Symbol(Symbol.iterator): ƒ]&gt;// 如果将以上函数修改成 箭头函数const sum = () =&gt; &#123;  console.log(arguments); // Uncaught ReferenceError: arguments is not defined&#125;;sum();&gt;// 箭头函数中没有arguments</code></pre><blockquote><blockquote><p>注：<br>将以上函数修改成箭头函数后，报错 arguments 未定义。</p></blockquote><ul><li>因为，在 <code>ES6</code> 中箭头函数里没有 <code>arguments</code> 。那如果<strong>有不定参数的需求</strong>该怎么办呢 ？</li><li>既然 ES6 的箭头函数中取消了 arguments ，就可以使用其它的方式来解决</li><li>我们接下来会学到<strong>剩余参数</strong>就能解决，<strong>在一定程度上</strong>代替 <code>arguments</code>，如果一定要用，还是使用传统的方式就好。</li></ul></blockquote><h4 id="适合箭头函数的场景"><a href="#适合箭头函数的场景" class="headerlink" title="适合箭头函数的场景"></a>适合箭头函数的场景</h4><blockquote><p>箭头函数因为书写的便利，在很多场景下都可以代替原来的函数，除此之外还因为箭头函数没有自己的<code>this</code>这一特性，在实际开发中也有广泛的应用。</p><blockquote><p>以下情况，我们可以把普通函数改写成简单的箭头函数</p></blockquote><ul><li>函数中不会用到 <code>this</code>，则可以将此函数改成箭头函数</li><li>希望在当前函数中的<code>this</code>指向外层作用域中的<code>this</code> 时，可以将此函数改成箭头函数</li></ul></blockquote><ol><li>函数中不会用到 this</li></ol><ul><li>以下的**<code>IIFE</code>立即执行函数**中，并没有用到<code>this</code>，所以 <code>this</code>指向什么都没关系</li></ul><pre><code>//随机生成颜色const color = (() =&gt; &#123;  const arr = [&quot;red&quot;, &quot;yellow&quot;, &quot;green&quot;, &quot;blue&quot;];  const n = (Math.random() * arr.length) &gt;&gt; 0;  return arr[n];&#125;)();console.log(color);</code></pre><ul><li>当函数()的方式自调用时，其内部也没有用到 this，所以 this 指向什么都没关系</li></ul><pre><code>var sum = (a, b) =&gt; a + b;console.log(sum(1, 2)); // 3</code></pre><ul><li>常见 API 的回调函数，可以将其改写成箭头函数</li></ul><pre><code>const arr = [1, 3, 2, 7, 4, 5, 6];arr.sort(function (a, b) &#123;  console.log(this);  return a - b;&#125;);console.log(arr); // [1, 2, 3, 4, 5, 6, 7]&gt;// 箭头函数const arr2 = [1, 4, 3, 7, 8, 12, 76];arr2.sort((a, b) =&gt; a - b);console.log(arr2); // [1, 3, 4, 7, 8, 12, 76]</code></pre><ol start="2"><li>希望函数中 this 指向外层作用域 this<blockquote><p>我们一般希望在回调函数中<strong>拿到外层</strong>作用域中的<code>this</code>，因为箭头函数没有自己的<code>this</code>，所以箭头函数中的<code>this</code>默认就指向了外层作用域中的<code>this</code>。</p></blockquote></li></ol><ul><li>案例1：点击元素，元素在几种不同颜色之间随机切换<blockquote><ul><li>普通函数：</li></ul></blockquote></li></ul><pre><code>&gt;&lt;style&gt;  .box &#123;    width: 100px;    height: 100px;    background-color: red;  &#125;&gt;&lt;/style&gt;&gt;&lt;div class=&quot;box&quot;&gt;&lt;/div&gt;&gt;&lt;script&gt;  const box = document.querySelector(&quot;.box&quot;);  box.onclick = function () &#123;    const that = this; // 保存this    setInterval(function () &#123;      const arr = [&quot;red&quot;, &quot;blue&quot;, &quot;yellow&quot;, &quot;green&quot;];      const len = arr.length;      // that指向 box      that.style.backgroundColor = arr[(Math.random() * len) &gt;&gt; 0];    &#125;, 500);  &#125;;&gt;&lt;/script&gt;</code></pre><blockquote><ul><li>使用普通函数时，要在定时器的回调函数中拿到外层（事件处理函数）中的<code>this</code>，则需要在事件处理函数中<strong>添加变量</strong><code>that</code>来保存<code>this</code>，然后在回调函数中来使用</li></ul></blockquote><blockquote><ul><li>如果将定时器中的回调函数，改写成箭头函数，就不需要增加中间变量（代码如下）</li></ul></blockquote><pre><code>&gt;&lt;style&gt;  .box &#123;    width: 100px;    height: 100px;    background-color: red;  &#125;&gt;&lt;/style&gt;&gt;&lt;div class=&quot;box&quot;&gt;&lt;/div&gt;&gt;&lt;script&gt;  const box = document.querySelector(&quot;.box&quot;);  box.onclick = function () &#123;    setInterval(() =&gt; &#123;      const arr = [&quot;red&quot;, &quot;blue&quot;, &quot;yellow&quot;, &quot;green&quot;];      const len = arr.length;      // 箭头函数中没有自己的this，所以沿着作用域链向外找,找到了事件处理函数中的this      // 事件处理函数中的this指向绑定事件的对象box      this.style.backgroundColor = arr[(Math.random() * len) &gt;&gt; 0];    &#125;, 500);  &#125;;&gt;&lt;/script&gt;</code></pre><ul><li>案例2：当点击一个按钮时，从零开始计数</li></ul><pre><code>&gt;&lt;style&gt;    body &#123;        padding: 200px 0 0 300px;    &#125;    button &#123;        width: 70px;        height: 70px;        font-size: 20px;        cursor: pointer;    &#125;    span &#123;        font-size: 30px;        padding: 30px;    &#125;&gt;&lt;/style&gt;&gt;&gt;&lt;button id=&quot;btn&quot;&gt;点击开始&lt;/button&gt;&gt;&lt;span id=&quot;result&quot;&gt;0&lt;/span&gt;&gt;&gt;&lt;script&gt;    // 获取按钮    const btn = document.getElementById(&quot;btn&quot;);    // 获取存放数字的容器    const result = document.getElementById(&quot;result&quot;);&gt;    const timer = &#123;        time: 0,        start: function () &#123;            btn.addEventListener(                &quot;click&quot;,                function () &#123;                    setInterval(function () &#123;                        console.log(this); // undefined -&gt; window（在非严格模式下，浏览器帮我们将this指向从 undefined 转化成了 window）                        this.time++;                        result.innerHTML = this.time;                    &#125;, 1000);                &#125;,                false            );        &#125;,    &#125;;    timer.start();&gt;&lt;/script&gt;</code></pre><blockquote><ul><li>当我们点击开始按钮时，数字变成 <code>NaN</code> 了，因为定时器<code>setInterval(function()&#123;&#125;)</code> 中 <code>this</code> 指向 <code>window</code> ，我希望这里的 <code>this</code> 指向是 <code>timer</code> 对象才对（我们需要用到 <code>timer</code> 对象中的 <code>time</code> 属性）。<blockquote><p>本质就是，这里的 this 指向只要是 timer 就能正常运行了</p></blockquote></li></ul></blockquote><blockquote><ul><li>传统方法是声明一个<code>that</code>变量来保存我们想要的<code>this</code>，然后再需要对应 <code>this</code> 的时候，替换成我们声明的变量即可实现</li><li>在<code>ES6</code>中，箭头函数没有自己的<code>this</code>，我可以通过这个特性来实现：</li></ul></blockquote><pre><code>&gt;&lt;script&gt;  // 获取按钮  const btn = document.getElementById(&quot;btn&quot;);  // 获取存放数字的容器  const result = document.getElementById(&quot;result&quot;);&gt;  const timer = &#123;    time: 0,    start: function () &#123;      console.log(this); // this指向 timer ，找到了，timer.start(); 调用start()方法，即指向 timer对象      btn.addEventListener(        &quot;click&quot;,        () =&gt; &#123;          console.log(this); // 箭头函数没有自己的this ，往上一层找          setInterval(() =&gt; &#123;            console.log(this); // 箭头函数没有自己的this ，往上一层找            this.time++;            result.innerHTML = this.time;          &#125;, 1000);        &#125;,        false      );    &#125;,  &#125;;  timer.start();&gt;&lt;/script&gt;</code></pre><h3 id="二、箭头函数面试题"><a href="#二、箭头函数面试题" class="headerlink" title="二、箭头函数面试题"></a>二、箭头函数面试题</h3><ol><li>箭头函数可以用 call 或者 apply 改变 this 指向吗 ？（百度）<blockquote><p><strong>解题思路：</strong></p><ul><li>说说箭头函数中的 <code>this</code> 指向，普通函数中的 <code>this</code> 指向。</li><li>为什么普通函数调用 <code>call</code> 和 <code>apply</code> 能改变 <code>this</code>，说下其实现原理，能否手写实现下 <code>call</code> 方法？</li><li>结合手写的 <code>call</code> 方法，来说明箭头函数不能改变 <code>this</code> 指向的本质原因。</li></ul></blockquote></li></ol><blockquote><p><strong>答：</strong></p><ul><li>箭头函数不能用 <code>call</code> 和 <code>apply</code> 改变 <code>this</code> 指向，因为箭头函数中没有自己的 <code>this</code>，箭头函数中的 <code>this</code> 指向箭头函数声明时所在的作用域中的 <code>this</code>。而普通函数内部的 <code>this</code>，指向把函数当成方法调用的对象。</li><li>普通函数调用 <code>call</code> 和 <code>apply</code> 能改变函数内部的 <code>this</code> 指向，其<strong>本质</strong>是把函数当成 <code>call</code> 或 <code>apply</code> 后面第一个参数的方法来调用。</li></ul></blockquote><ul><li><code>obj.方法()</code>方法为<strong>普通函数</strong>，其内部的 this 指向 obj</li></ul><pre><code>const obj = &#123;  a: 1,  b: 2,&#125;;&gt;function sum(a, b) &#123;  console.log(this.a + this.b);&#125;sum.call(obj, 4, 5); // 相当于  obj.sum(4,5) ，sum为普通函数，this指向被调用的对象,即相当于&gt;/*obj=&#123;    a:1,    b:2,    sum:function(a,b)&#123;         console.log(this.a+this.b);  // this指向obj    &#125;&#125;*/</code></pre><ul><li><code>obj.方法()</code>方法为<strong>箭头函数</strong>，其 this 指向箭头函数声明时所在作用域中的 this</li></ul><pre><code>const obj = &#123;  a: 1,  b: 2,&#125;;&gt;const sum = (a, b) =&gt; &#123;  console.log(this.a + this.b);&#125;;sum.call(obj, 4, 5); // 相当于  obj.sum(4,5)  但sum是箭头函数，this指向window,即相当于&gt;/*obj=&#123;    a:1,    b:2,    sum:(a,b)=&gt;&#123;         console.log(this.a+this.b);  // this指向window    &#125;&#125;*/</code></pre><ul><li>以下代码是根据此原理来实现手写 <code>call</code> 方法<blockquote><ul><li><code>call</code> 内部实现原理：把调用 <code>call</code> 的函数当成 <code>call</code> 方法的第一个参数的方法来使用</li></ul></blockquote></li></ul><pre><code>// 手写call方法Function.prototype.call = function (context, ...args) &#123;  // ....相关判断省略  // 创建一个唯一的值，用来当做对象的属性名  const key = Symbol();  // call是一个普通函数，内部的this指向调用call方法的对象  // 把调用call方法的对象绑定成 call方法第一个参数的方法  context[key] = this;  // 调用方法,并将返回值保存在变量中  let result = context[key](...args);  //删除被新增的属性  delete context[key];  // 返回结果  return result;&#125;;</code></pre><ol start="2"><li>箭头函数和普通函数的区别（招银、百度、知乎、字节）<blockquote><ul><li>箭头函数和普通函数主要有以下几个方面的区别<table><thead><tr><th>区别</th><th>说明</th></tr></thead><tbody><tr><td>this 指向</td><td>箭头函数中没有自己的 this，箭头函数中的 this 指向箭头函数声明时所在的作用域中的 this</td></tr><tr><td>arguments</td><td>箭头函数中没有 arguments，如果需要接受对应的实参列表，可以用 rest 剩余参数</td></tr><tr><td>构造函数</td><td>箭头函数不能用做构造函数，不能使用 new 调用</td></tr><tr><td>prototype</td><td>箭头函数没有原型对象 prototype 这个属性</td></tr><tr><td>super</td><td>因为箭头函数不能用做构造函数，也就没有自己的 super</td></tr><tr><td>yield 命令</td><td>因为箭头函数不能用作 Generator 函数，所以不可以使用 yield 命令</td></tr></tbody></table></li></ul></blockquote></li></ol><h3 id="三、对象字面量增强"><a href="#三、对象字面量增强" class="headerlink" title="三、对象字面量增强"></a>三、对象字面量增强</h3><h4 id="对象字面量是什么-？"><a href="#对象字面量是什么-？" class="headerlink" title="对象字面量是什么 ？"></a>对象字面量是什么 ？</h4><blockquote><p>对象字面量就是对象的一种写法，对象一般有两种写法</p></blockquote><ol><li>通过实例化构造函数来生成对象</li></ol><pre><code>// 实例化构造函数生成对象const student = new Object();student.username = &quot;清心&quot;;student.age = 18;student.code = function () &#123;&#125;;</code></pre><ol start="2"><li>对象字面量方式创建对象</li></ol><pre><code>// 对象字面量const student = &#123;  username: &quot;清心&quot;,  age: 18,  code: function () &#123;&#125;,&#125;;</code></pre><blockquote><ul><li>我们日常开发中，很少使用实例化构造函数来生成对象，更多使用对象字面量的方式来生成对象，因为它更直观，我们用的也更多。</li></ul></blockquote><h4 id="属性的简洁表示法-增强"><a href="#属性的简洁表示法-增强" class="headerlink" title="属性的简洁表示法 - 增强"></a>属性的简洁表示法 - 增强</h4><ul><li>当对象属性的<strong>键名</strong>和<strong>变量或常量名</strong>一样的时候，可以只写一个</li></ul><pre><code>let username = &quot;清心&quot;;let age = 18;const obj = &#123;  username: username,  age: age,&#125;;console.log(obj); // &#123;username: &#39;清心&#39;, age: 18&#125;&gt;// 以下简写形式，当属性名和变量名相同时，可以只写一个const obj = &#123;  username, // 相当于 username: username  age, // 相当于  age: age&#125;;console.log(obj); // &#123;username: &#39;清心&#39;, age: 18&#125;</code></pre><ul><li>这种简写用于函数的返回值会非常方便</li></ul><pre><code>function getCurrentDate() &#123;  var nowDate = new Date();  var year = nowDate.getFullYear();  var month = nowDate.getMonth() + 1;  var date = nowDate.getDate();&gt;  return &#123; year, month, date &#125;; // 属性的简写形式&#125;console.log(getCurrentDate()); // &#123;year: 2023, month: 1, date: 5&#125;</code></pre><h4 id="方法的简洁表示法-增强"><a href="#方法的简洁表示法-增强" class="headerlink" title="方法的简洁表示法-增强"></a>方法的简洁表示法-增强</h4><ol><li>es6 中，对象的方法可以省略<strong>冒号</strong>和<code>function</code>关键字</li></ol><pre><code>const obj=&#123;  say: function(a,b)&#123;    console.log(&quot;123&quot;);  &#125;,&#125;;//简写const obj = &#123;  say(a, b) &#123;    console.log(&quot;123&quot;);  &#125;,&#125;;obj.say(); //123</code></pre><pre><code>const student = &#123;  name: &quot;清心&quot;,  code: function () &#123;    console.log(`$&#123;this.name&#125;正在写代码`);  &#125;,&#125;;student.code(); // 清心正在写代码&gt;// 以下是简写形式，可以省略方法名后面的:和function关键字const student = &#123;  name: &quot;清心&quot;,  code() &#123;    console.log(`$&#123;this.name&#125;正在写代码`);  &#125;,&#125;;student.code(); // 清心正在写代码</code></pre><ol start="2"><li>方法的简法，对于 get 获取函数和 set 设置函数也适用</li></ol><ul><li><code>ES5</code>中 <code>get</code>和<code>set</code>函数是写在<code>Object.defineProperty</code>方法的第三个参数中</li></ul><pre><code>const obj = &#123;  _sex: &quot;男&quot;,&#125;;Object.defineProperty(obj, sex, &#123;  get: function () &#123;    return this._sex;  &#125;,  set: function (value) &#123;    this._sex = value;  &#125;,&#125;);</code></pre><ul><li><code>ES6</code> 支持的最完美的 <code>get</code> 和 <code>set</code> 函数的简写形式</li></ul><pre><code>const obj = &#123;  _sex: &quot;男&quot;,  // get函数的简写  get sex() &#123;    return this._sex;  &#125;,  // set 函数的简写  set sex(value) &#123;    this._sex = value;  &#125;,&#125;;</code></pre><h4 id="方括号语法-增强"><a href="#方括号语法-增强" class="headerlink" title="方括号语法 - 增强"></a>方括号语法 - 增强</h4><ol><li><code>ES5</code> 中方括号语法的用法<blockquote><ul><li>在<code>ES5</code>中定义对象属性有两种方式：点符号法和方括号表示法</li></ul></blockquote></li></ol><pre><code>const obj = &#123;&#125;;// 方式一：点符号法  obj.属性名=属性值obj.name = &quot;清心&quot;; // 等价于 obj[&#39;name&#39;]=&#39;清心&#39;// 方式二：方括号表示法  obj[变量]=属性值, 这种情况变量的值为属性名let myage = &quot;age&quot;;obj[myage] = 18; // 这种情况只能使用方括号法</code></pre><blockquote><ul><li>但 <code>ES5</code> 中，对象字面量写法中<strong>不能</strong>使用<code>[]</code>方括号法来定义属性名</li></ul></blockquote><pre><code>const obj = &#123;  name: &quot;清心&quot;,  [&quot;myage&quot;]: 19, // ES5中不允许这种写法&#125;;</code></pre><blockquote><blockquote><p>现在是因为es6才可以用的</p></blockquote></blockquote><ol start="2"><li>ES6 中方括号语法 - 增强<blockquote><ul><li>在 ES6 中允许字面量定义对象时使用<code>[]</code>方括号的方式来定义属性名</li><li>方括号中可以放的内容和模板字符串中的注入<code>$&#123;&#125;</code>中可以放的内容一样，可以放<strong>值</strong>或<strong>通过计算可以得到值的（表达式）</strong>都可以</li><li>但其实方括号只能放字符串和<code>Symbol</code>，除<code>Symbol</code>类型以外的<strong>值</strong>或<strong>通过计算可以得到值的（表达式）</strong>都会被转化为字符串</li></ul></blockquote></li></ol><pre><code>let person = &#123;  [1 + 3]: 3,  [&#123;&#125;]: 4,  [[]]: 5,  [function () &#123;&#125;]: 6,  [(foo = () =&gt; &#123;&#125;)]: 7,  [&quot;s&quot; + &quot;sex&quot;]: 8,&#125;;console.log(person);for (let key in person) &#123;  console.log(key);  console.log(typeof key); //全都是 string&#125;// &quot;4&quot; &quot;[object Object]&quot; &quot;&quot; &quot;function () &#123;&#125;&quot;//&quot;() =&gt; &#123;&#125;&quot;  &quot;ssex&quot;&gt;const s = Symbol();let animal = &#123;  [s]: 19,&#125;;const key = Object.getOwnPropertySymbols(animal);console.log(key); //[Symbol()]console.log(typeof key); //object</code></pre><ul><li>只能采用方括号表示法的情况<blockquote><ul><li>在<strong>获取</strong>属性时，当属性名不是合法标识符时，就只能采用方括号表示法。</li><li>在<strong>获取</strong>属性时，如果使用变量或者常量保存属性名时，就只能采用方括号表示法</li></ul></blockquote></li></ul><pre><code>const obj = &#123;  age: 18,  &quot;123username&quot;: &quot;icoding&quot;,&#125;;// 123username 不是合法标识符，所以只能用方括号方式来获取console.log(obj[&quot;123username&quot;]);// 定义一个常量property，值为ageconst property = &quot;age&quot;;// 当属性为变量或常量时，必须通过方括号语法，即：obj[property]，使用property保存的值age，所以等价于obj.age这种写法console.log(obj[property]); // 18// 当属性为变量或常量时，如果通过点语法，会将property看做字符串，表示访问obj对象下的property属性，而不是访问obj下的age属性，而obj对象中没有property属性，所以返回结果为undefinedconsole.log(obj.property); // undefined</code></pre><blockquote><ul><li>使用字面量方式创建对象时，如果使用变量或者常量<strong>保存属性名</strong>时，就只能使用方括号语法</li></ul></blockquote><pre><code>let username = &quot;username&quot;;const age = &quot;age&quot;;const obj = &#123;  [username]: &quot;清心&quot;,  [age]: 18,&#125;;console.log(obj); // &#123;username: &#39;清心&#39;, age: 18&#125;</code></pre><ol start="3"><li>方括号语法和点语法的区别<blockquote><ul><li><strong>点语法是方括号语法的特殊形式</strong>。也就是说：如果不使用点语法，只使用方括号来给对象字面量添加属性或方法没有任何问题。</li><li>属性或方法名是合法标识符时，可以使用点语法，而且点语法用起来更简单。所以，能用点语法时，我们会<strong>优先使用点语法</strong>。<blockquote><p>标识符命名规范： 只能以<code>字母，数字，_下划线，$</code>组成，但<strong>不能</strong>以数字开头</p></blockquote></li></ul></blockquote></li></ol><pre><code>// 对象字面量const student = &#123;&#125;;&gt;// 使用点语法给对象字面量添加属性student.age = 18; // 等价于 student[&quot;age&quot;] = 18;console.log(student); // &#123;age: 18&#125;&gt;// 使用方括号给对象字面量添加属性student[&quot;username&quot;] = &quot;icoding&quot;; // 等价于 student.username=&#39;icoding&#39;console.log(student); // &#123;age: 18, username: &#39;icoding&#39;&#125;</code></pre><h2 id="ES6-解构赋值，函数参数默认值，在项目中的应用场景"><a href="#ES6-解构赋值，函数参数默认值，在项目中的应用场景" class="headerlink" title="ES6 解构赋值，函数参数默认值，在项目中的应用场景"></a>ES6 解构赋值，函数参数默认值，在项目中的应用场景</h2><h3 id="一、认知解构赋值"><a href="#一、认知解构赋值" class="headerlink" title="一、认知解构赋值"></a>一、认知解构赋值</h3><blockquote><p>解构赋值语法是一种<code>JavaScript</code>表达式。可以将数组中的值或对象的属性值取出，赋值给其他变量。</p><ul><li>我们把传统方式的取值赋值和解构赋值的方式来对比，看解构赋值的优点</li></ul></blockquote><ul><li>传统方式取值赋值<blockquote><ul><li>传统方式只能把数组中的值一个一个取出来，然后分别赋值给到对应的变量</li></ul></blockquote></li></ul><pre><code>// 传统方式，取出数组中的值const arr = [1, 2, 3];let a = arr[0];let b = arr[1];let c = arr[2];console.log(a, b, c); // 1,2,3</code></pre><ul><li>ES6 中，通过解构赋值来获取数组中元素<blockquote><ul><li>解构赋值本质是属于<strong>“模式匹配”</strong> ，只要等号两边的<strong>结构模式</strong>相同，<strong>左边的变量</strong>就会被赋予对应的值。</li></ul></blockquote></li></ul><pre><code>const arr = [1, 2, 3, 4];let [a, b, c] = arr;// 解构赋值 let [a,b,c]=[1,2,3,4]console.log(a, b, c); //1 2 3</code></pre><blockquote><ul><li><strong>解构的目的</strong>：是为了简化提取数据的过程，增强代码的可读性。把变量放在<code>[]</code>或者<code>&#123;&#125;</code>中来获取目标对象上的对应的值。</li></ul></blockquote><h3 id="二、两种解构模式"><a href="#二、两种解构模式" class="headerlink" title="二、两种解构模式"></a>二、两种解构模式</h3><blockquote><ul><li>对于对象和数组的解构，有两种解构模式：<strong>绑定模式</strong>和<strong>赋值模式</strong>，他们的语法略有不同。</li></ul></blockquote><h4 id="绑定模式"><a href="#绑定模式" class="headerlink" title="绑定模式"></a>绑定模式</h4><blockquote><p>在绑定模式中，模式<strong>以声明关键字（var、let 或 const）开始</strong>。然后按照相应的模式匹配，只要等号两边的模式相同，左边的变量就会被赋予对应的值</p></blockquote><blockquote><ul><li>数组解构赋值，左边声明变量，用来接受右边对应结构位置上的值</li></ul></blockquote><pre><code>// 数组解构赋值，左边相当于声明了两个变量a和c 用来接受右边对应结构位置上的值const [a, , c] = [1, 2, 3];console.log(a, c);</code></pre><blockquote><ul><li>对象解构赋值的内部机制是：先找属性名，看等号右边对象中有没有对应的属性名，然后再将对象对应的属性值赋值给到对应变量。<blockquote><p>和属性值对应的才是变量</p></blockquote></li></ul></blockquote><pre><code>// 以下代码等号左边的x,y为对象属性名， _x 和 _z 才是新声明的变量，const &#123; x: _x, y: _y &#125; = &#123; x: 1, y: 2 &#125;;console.log(_x, _y);</code></pre><blockquote><ul><li>在绑定模式中，所有变量<strong>共享相同的声明</strong>，如果希望两个变量分别用 let 和 const 声明，则需要解构两次</li></ul></blockquote><pre><code>var arr = [1, 2, 3];let [a] = arr;console.log(a); // 1&gt;const [, , c] = arr;console.log(c); // 3</code></pre><h4 id="赋值模式"><a href="#赋值模式" class="headerlink" title="赋值模式"></a>赋值模式</h4><blockquote><p>在赋值模式中，模式<strong>不以关键字开头</strong>，赋值语句中的<strong>变量已提前声明</strong>好了。然后按照相应的模式匹配，只要只要等号两边的<strong>模式相同</strong>，左边的变量就会被赋予对应的值。</p><blockquote><p>注：</p></blockquote><ul><li>1、赋值模式中，当对<strong>对象</strong>解构赋值时，必需用<code>(....)</code>赋值语句包裹起来。否则 <code>JS</code> 引擎会把<code>&#123; &#125;</code>理解成一个代码块，从而发生语法错误。</li><li>2、如果(赋值语句)前面的代码没有以<code>;</code>分号结尾，有可能会造成它被当前<strong>前一行</strong>的函数执行</li></ul></blockquote><pre><code>// 数组解构赋值let a,b;[a,b]=[1,2,3];console.log(a,b); // 1 2&gt;// 对象解构赋值  ，记得一定要用()将赋值语句包裹起来，否则会报错let _x, _y;(&#123; x: _x, y: _y &#125; = &#123; x: 1, y: 2 &#125;);console.log(_x, _y);&gt;// 以下这种情况，如果省略括号前; 相当于执行 x(x:_x)这个函数，所以一定要在()前加上;号let x;(x:_x)=&#123;x:1,y:2&#125;</code></pre><h3 id="三、数组的解构赋值"><a href="#三、数组的解构赋值" class="headerlink" title="三、数组的解构赋值"></a>三、数组的解构赋值</h3><blockquote><p>数组的解构赋值是，通过<strong>新建一个数组</strong>，数组内的变量和目标数组是<strong>一一对应</strong>的，按照<strong>索引</strong>的方式去获取值，然后赋值给指定索引上的变量。</p></blockquote><h4 id="模式（结构）匹配"><a href="#模式（结构）匹配" class="headerlink" title="模式（结构）匹配"></a>模式（结构）匹配</h4><blockquote><p>数组解构赋值首先要遵顺 <strong>“模式匹配”</strong>，即 等号的左边是数组，右边只要是<strong>可迭代对象</strong>都可以，但不能是其它值<br><strong>可迭代对象有：</strong></p><ul><li>数组</li><li>类数组（arguments、NodeList）</li><li>Set</li><li>Map</li><li>… 等</li></ul></blockquote><pre><code>let [] = [1, 2, 3]; // 左右两边都必需为数组类型，不过也有特殊的情况，后面会讲到&gt;// 以下情况，模式匹配失败，则会抛出错误let [] = 1; // 报错let [] = &#123;&#125;; // 报错</code></pre><ul><li>数组解构赋值 &#x3D; 等号右边只要是可迭代对象就行。<blockquote><ul><li>以下内容没讲，后面会讲，有基础的当复习</li></ul></blockquote></li></ul><pre><code>// Set为可迭代对象const [a, b, c] = new Set([1, 2, 3]);console.log(a, b, c);&gt;// Map为可迭代对象const [x, y] = new Map([  [&quot;a&quot;, 1],  [&quot;b&quot;, 2],]);console.log(x); // [&#39;a&#39;, 1]console.log(y); // [&#39;b&#39;, 2]&gt;// arguments类数组对象function f() &#123;  let [a, b, c] = arguments;  console.log(a, b, c);&#125;f(1, 2, 3); // 1 2 3&gt;// 对象为非迭代对象，但给对象添加了迭代器后，就变成了可迭代对象，就可以用数组方式解构赋值const obj = &#123;  a: &quot;one&quot;,  b: &quot;two&quot;,  c: &quot;three&quot;,&#125;;&gt;// 给对象添加跌迭器Object.prototype[Symbol.iterator] = function* () &#123;  for (var key in this) &#123;    yield this[key];  &#125;&#125;;&gt;const [x, y, z] = obj;console.log(x, y, z); // one two three</code></pre><h4 id="索引值相同完成赋值"><a href="#索引值相同完成赋值" class="headerlink" title="索引值相同完成赋值"></a>索引值相同完成赋值</h4><ul><li>等号右边数组中的索引值和左边数组中的常量或变量一一对应就能完成赋值</li></ul><pre><code>// 数组解构赋值遵守模式匹配，即：等号两边的模式相同。let [a, b, c] = [1, 2, 3];console.log(a, b, c); // 1 2 3&gt;let [x, , y] = [1, 2, 3];console.log(x, y); // 1 3&gt;let [m, n, [l]] = [1, 2, [4, 5]];console.log(m, n, l); // 1 2 4</code></pre><blockquote><ul><li>注意数组嵌套的情况，不仅外层要模式匹配，内层也要</li></ul></blockquote><pre><code>const [a, [b, c], d] = [1, [2], 3];console.log(a, b, d); //123console.log(a, c, d); //1 undefined 3&gt;const [a, [b, c], d] = [1, 2, 3];console.log(a, b, c, d); //number 2 is not iterable</code></pre><ul><li>如果不取值的，可以直接用逗号跳过</li></ul><pre><code>// 数组解构赋值遵守模式匹配，即：等号两边的模式相同。// 如果不取值的，可以直接用逗号跳过const [, , a] = [1, [2, 3, 5], 6];console.log(a); // 6&gt;const [a, [, , b], c] = [1, [2, 3, 5], 6];console.log(a, b, c); // 1 5 6</code></pre><ul><li>如果解构不成功，则默认值为<code>undefined</code></li></ul><pre><code>let [a, b, c] = [1, 2];console.log(a, b, c); // 1 2 undefined// 上面的变量c没有取到值，则其默认值为undefined</code></pre><h4 id="数组解构的默认值"><a href="#数组解构的默认值" class="headerlink" title="数组解构的默认值"></a>数组解构的默认值</h4><ol><li>默认值的基本用法<blockquote><p>数组解构时，如果变量的取值为<code>undefined</code>时，我们想为变量采用其它值，则就可以为变量指定默认值。</p><ul><li>当解构赋值时，变量对应的值<code>严格等于=== undefind</code>时(没有值或值为undefined)，其默认值才会生效</li></ul></blockquote></li></ol><pre><code>// 对空数组 [] 解构赋值let [a, b] = [];console.log(a, b); // undefined undefined&gt;// 变量x的默认值=1，y的默认值=2let [x = 1, y = 2] = [];console.log(x, y); // 1,2&gt;// 变量x的默认值=1，y的默认值=3let [x = 1, y = 3] = [8, undefined];console.log(x, y); // 8 3</code></pre><ol start="2"><li>默认值为表达式<blockquote><p>如果默认值是一个表达式，那这个表达式是<strong>惰性求值</strong>的。也就是变量的取值为<code>undefined</code>时，表达式才会执行求值，否则不会执行。</p></blockquote></li></ol><pre><code>const fn = () =&gt; &#123;  console.log(&quot;执行&quot;);  return 3;&#125;;let [x = fn()] = [];console.log(x); //执行 3&gt;const fn = () =&gt; &#123;  console.log(&quot;执行&quot;);  return 3;&#125;;let [x = fn()] = [4];console.log(x); // 4</code></pre><ol start="3"><li>默认值引用解构值的其他变量<blockquote><ul><li>默认值可以引用解构值的其他变量，但该变量必需要<strong>已经声明</strong></li></ul></blockquote></li></ol><pre><code>let [a = 1, b = a] = [];console.log(a, b); // 1 1let [x = 1, y = x] = [2];console.log(x, y); // 2 2&gt;let [m = 1, n = m] = [2, 3];console.log(n, m); // 2  3&gt;let [i = j, j = 2] = []; // 报错 ,因为当i用到j时,j还没有被声明</code></pre><h3 id="四、对象的解构赋值"><a href="#四、对象的解构赋值" class="headerlink" title="四、对象的解构赋值"></a>四、对象的解构赋值</h3><blockquote><p>对象的解构赋值等号两边必需<strong>同为对象类型</strong>，同时对象中的属性<strong>没有次序</strong>，所以不能像数组那样通过位置来决定变量的取值。要取到对象属性中的值，变量名必需与属性名同名。</p><ul><li>数组是根据索引一一对应，但对象是根据属性名来找属性值</li></ul></blockquote><ol><li>模式（结构）匹配<blockquote><p>等号两边必需同为<strong>对象类型</strong></p><ul><li>与数组区分，数组模式匹配时，等号右边只要是可迭代对象就行</li></ul></blockquote></li></ol><pre><code>let &#123;&#125; = &#123;&#125;;// 或let &#123;&#125; = [1, 3, 3];// 或let &#123;&#125; = new String(&quot;hello&quot;);</code></pre><blockquote><ul><li>注意：字符串、数组、布尔值等其实都是对象，如果它们出现在等号右边，会自动转化为包装类对象</li></ul></blockquote><pre><code>let &#123; a &#125; = [];console.log(a); //undefinedlet &#123;&#125; = &quot;111&quot;;let &#123;&#125; = true;let &#123;&#125; = new String();let &#123;&#125; = new Boolean();let &#123;&#125; = new Number();let &#123;&#125; = Symbol();let &#123;&#125; = BigInt; //BigInt是类，但BigInt()不行,BigInt()是个函数，里面要放值</code></pre><ol start="2"><li>属性名相同完成赋值<blockquote><ul><li>对象解构赋值的内部机制是：先找属性名，看等号右边对象中有没有对应的属性名，然后再将对象对应的属性值赋值给到对应变量。</li><li>如果找不到同名的属性名，则变量名的默认值为 undefined</li><li><code>let&#123;属性名:变量&#125;=&#123;属性名:变量&#125;</code></li></ul></blockquote></li></ol><pre><code>let &#123; myname: _name, age: _age, sex: _sex &#125; = &#123; myname: &quot;icoding&quot;, age: 3 &#125;;console.log(_name, _age); // icoding 3 undefined// 注意，myname、age、sex不是变量名</code></pre><blockquote><ul><li>如果变量名与属性名同名，可以采用简写形式</li></ul></blockquote><pre><code>let &#123;x,y&#125;相当于let&#123;x:x,y:y&#125;//属性名:变量</code></pre><pre><code>// 简写形式let &#123; myname, age &#125; = &#123; myname: &quot;icoding&quot;, age: 3 &#125;;console.log(myname, age); // icoding 3&gt;// 上面代码，等价于下面代码let &#123; myname: myname, age: age &#125; = &#123; myname: &quot;icoding&quot;, age: 3 &#125;;console.log(myname, age); // icoding 3</code></pre><ol start="3"><li>区分模式与变量<blockquote><p>在对象解构赋值时，我们是通过<strong>对象的属性名</strong>来完成解构赋值的，所以<strong>对象的属性名我们可以看成是匹配模式的一部分。</strong></p><blockquote><p>用来接收对象属性值的才是新声明的变量。</p></blockquote></blockquote></li></ol><pre><code>// a,b是模式,匹配的是对象的属性  _a,_b是变量,用来接受属性的值var &#123; a: _a, b: _b &#125; = &#123; a: 1, b: 2 &#125;;console.log(_a); // 1console.log(_b); // 2console.log(a); // a is not definedconsole.log(b); // b is not defined</code></pre><ul><li>属性名相同时，是可以多次匹配的</li></ul><pre><code>//  第一个foo是变量 第二个foo是匹配模式  第一个start是变量let &#123;  foo,  foo: &#123; start &#125;,&#125; = &#123; foo: &#123; start: 33 &#125; &#125;;console.log(foo, start); // &#123;start: 33&#125; 33//相当于：let &#123;  foo:foo,  foo: &#123; start &#125;，&#125; = &#123; foo: &#123; start: 33 &#125; &#125;;</code></pre><blockquote><ul><li>第一个变量foo往等号右边找，找到<code>foo=&#123; start: 33 &#125;</code></li><li>第二个<code>foo</code>，先往等号右边找同名属性名，还是找到了<code>foo=&#123;start: 33&#125;</code>，所以<code>&#123;start&#125;=&#123;start: 33&#125;</code>；<code>start</code>是个与属性名相同的变量，与等号右边的<code>start</code>匹配后，解构赋值得到<code>start=33</code></li></ul></blockquote><ul><li>我们来看下面代码中，那些是匹配模式，那些是变量</li></ul><pre><code>const obj = &#123;  arr: [&quot;1&quot;, [&quot;一&quot;, &quot;二&quot;, &quot;三&quot;], &#123; name: &quot;icoding&quot;, age: 23 &#125;],&#125;;&gt;let &#123;  arr: [a, , &#123; name, age: _age, sex &#125;],&#125; = obj;&gt;// a  name  _age  sex是变量// arr age 是匹配模式&gt;console.log(a, name, _age, sex); // 1 icoding 23 undefined</code></pre><pre><code>const obj = &#123;  foo: &#123;    bar: &#123;      start: &#123;        number: 1,      &#125;,    &#125;,  &#125;,&#125;;&gt;var &#123;  foo,  foo: &#123; bar &#125;,  foo: &#123;    bar: &#123;      start: &#123; number &#125;,    &#125;,  &#125;,&#125; = obj;// 第一个foo，第一个bar ,number是变量，其它的都是匹配&gt;console.log(foo);//&#123;bar: &#123;...&#125;&#125;console.log(bar);//&#123;start: &#123;...&#125;&#125;console.log(number);//1</code></pre><ol start="4"><li>复杂结构的嵌套取值<blockquote><p>取出如下结构中<code>z</code>属性值和<code>z</code>中的<code>b</code>属性值及<code>y</code>属性中的第 <code>3</code>个值</p></blockquote></li></ol><pre><code>const obj = &#123;  x: 1,  y: [2, 3, 4],  z: &#123; a: 5, b: 6 &#125;,&#125;;&gt;// 对象解构赋值const &#123;  z,  z: &#123; b &#125;,  y: [, , c],&#125; = obj;&gt;console.log(z); // &#123;a: 5, b: 6&#125;console.log(b); // 6console.log(c); // 4</code></pre><ol start="5"><li>对象解构的默认值<blockquote><p>对象解构时，如果变量的取值为<code>undefined</code>时，我们想为变量采用其它值，则就可以为变量<strong>指定默认值</strong>。</p><ul><li>当解构赋值时，变量对应的值<code>严格等于=== undefind</code>时，其默认值才会生效</li></ul></blockquote></li></ol><pre><code>let &#123; a: _a = 0, b: _b = 0 &#125; = &#123; a: 1, b: 2 &#125;;console.log(_a, _b); // 1 2&gt;let &#123; x: _x = 0, y: _y = 0 &#125; = &#123; x: 3 &#125;;// _x 和 _y 解构取值为undefined，则会采用默认值console.log(_x, _y); // 3 0</code></pre><blockquote><ul><li>解构赋值的简写形式（为变量指定默认值）</li></ul></blockquote><pre><code>let &#123; a = &quot;A&quot;, b = &quot;B&quot;, c = &quot;C&quot; &#125; = &#123; a: 2, b: 3 &#125;;console.log(a, b, c);//2,3,&quot;C&quot; &gt;//   上面代码等价于;let &#123; a: a = &quot;A&quot;, b: b = &quot;B&quot;, c: c = &quot;C&quot; &#125; = &#123; a: 2, b: 3 &#125;;console.log(a, b, c);//2,3,&quot;C&quot; &gt;let &#123;x = 3 , y = 4 &#125; = &#123;&#125;;console.log(x,y);//3 4//相当于let &#123;x : x = 3 , y : y = 4 &#125; = &#123;&#125;;</code></pre><ol start="6"><li>默认值为表达式<blockquote><ul><li>如果默认值为表达式，那这个表达式<strong>惰性求值</strong></li></ul></blockquote></li></ol><pre><code>const fn = () =&gt; 3;let &#123; a = fn() &#125; = &#123; a: 1 &#125;;console.log(a); // 1   a能成功赋值,所以fn()函数不会被执行&gt;let &#123; b = fn() &#125; = &#123;&#125;;console.log(b); // 执行  3// b求值不成功,则采用默认值,即fn()函数执行</code></pre><ol start="7"><li>解构原型链上属性</li></ol><pre><code>// 对&#123;&#125;空对象进行解构赋值const &#123; x &#125; = &#123;&#125;;console.log(x); // undefined 是取不到值的&gt;const &#123; valueOf, toString &#125; = &#123;&#125;;console.log(valueOf); // ƒ valueOf() &#123; [native code] &#125;console.log(toString); // ƒ toString() &#123; [native code] &#125;</code></pre><blockquote><p>在之前的对象解构赋值的模式匹配时，我们说等号的左右两边只要都是对象类型就可以。</p><blockquote><p>接下来我们看下面这几种情况，他们是如何完成解构赋值。</p></blockquote></blockquote><pre><code>// 数组本质也是一个对象，他身上有length属性，原型上有push属性（方法）等let &#123; length, push &#125; = [1, 3, 3];console.log(length, push);//3 ƒ push() &#123; [native code] &#125;</code></pre><blockquote><ul><li>变量<code>length</code>去等号右边找<code>length</code>属性，虽然没在数组里找到，但是它可以拿到数组身上的length属性</li><li>同理，也可以拿到数组身上的<code>push</code>属性(方法)</li></ul></blockquote><pre><code>let &#123; 0: x, 1: y, at &#125; = new String(&quot;hello&quot;);console.log(x, y, at); // h e ƒ at() &#123; [native code] &#125;</code></pre><blockquote><ul><li><code>new String(&quot;hello&quot;)</code>是一个包装对象：</li><li>会被转化为：<code>String&#123;0 : &quot;h&quot; , 1 : &quot;t&quot;,...&#125;</code></li><li>而<code>at</code>是<code>String</code>身上的一个方法</li></ul></blockquote><h3 id="五、其它数据类型解构赋值"><a href="#五、其它数据类型解构赋值" class="headerlink" title="五、其它数据类型解构赋值"></a>五、其它数据类型解构赋值</h3><ol><li>字符串的解构赋值<blockquote><p>字符串的解构赋值有两种形式：既可以按照<strong>对象形式</strong>解构赋值，也可以按照<strong>数组的形式</strong>解构赋值</p></blockquote></li></ol><ul><li>数组的形式解构赋值</li></ul><pre><code>// 把字符串icoding当做一个数组，[i,c,o,d,i,n,g]const [x, y, , , , , z] = &quot;icoding&quot;;console.log(x, y, z); // i c g</code></pre><ul><li>对象形式的解构赋值<blockquote><ul><li>解构赋值时，对象的属性名为数组的索引值（下标）</li></ul></blockquote></li></ul><pre><code>// 0 -&gt; i , 1 -&gt; c ...  length 表示数组的长度const &#123; 0: x, 1: y, length &#125; = &quot;icoding&quot;;console.log(x, y, length); // i c 7</code></pre><blockquote><ul><li>上面的”icoding”包装成对象后，再用对象形式解构赋值。”icoding”包装成对象如下</li></ul></blockquote><pre><code>//相当于var str = new String(&quot;icoding&quot;);console.log(str);</code></pre><img src="字符串的解构赋值.png"><ol start="2"><li>数值和布尔值的解构赋值<blockquote><p>用对象模式解构赋值时，如果等号右边是数值或布尔值，是会<strong>先转为对象</strong>，再用参于对象的解构赋值</p><ul><li>数值和布尔值，与字符串不同，它们拿不到数值&#x2F;布尔值，只能得到<code>undefined</code></li></ul></blockquote></li></ol><pre><code>let &#123; 0 : x, toFixed &#125; = 124;console.log(x); // undefinedconsole.log(toFixed); // ƒ toFixed() &#123; [native code] &#125;</code></pre><pre><code>let &#123; 0 : x, toString &#125; = true;console.log(x); // undefinedconsole.log(toString); //ƒ toString() &#123; [native code] &#125;</code></pre><ol start="3"><li>undefined 和 null 的解构赋值<blockquote><p>由于 <code>undefined</code> 和 <code>null</code> 没有对应的包装对象，所以无法通过它们转换成相应的对象。</p><ul><li>因此，对它们进行解构赋值，都会报错。</li></ul></blockquote></li></ol><pre><code>const &#123; toString &#125; = undefined; // 报错，undefined的原型上没有toString方法const &#123; toString &#125; = undefined; // 报错</code></pre><h3 id="六、解构赋值在实际开发中的应用场景"><a href="#六、解构赋值在实际开发中的应用场景" class="headerlink" title="六、解构赋值在实际开发中的应用场景"></a>六、解构赋值在实际开发中的应用场景</h3><ol><li>交换变量的值</li></ol><pre><code>let a = 2;let b = 3;let c = 4;[a, b, c] = [b, c, a]; // a、b、c 已经声明了，这里就不用再添加 let 等关键字声明了console.log(a, b, c); // 3 4 2</code></pre><ul><li>解构赋值实现变量交换的本质是：<blockquote><ul><li><code>[a, b, c] = [b, c, a]</code> <strong>先</strong>把<code>=</code>号右边的<strong>变量值取到</strong>，即<code>[a, b, c] = [3,4,2]</code>，<strong>然后再解构赋值</strong>给到左边对应的变量。</li></ul></blockquote></li></ul><ol start="2"><li>从函数返回多个值<blockquote><p>函数只能返回一个值，如果要返回多个值，只能将它们放在<strong>数组或对象</strong>里返回，可以使用解构赋值，非常方便的取出这些值。</p></blockquote></li></ol><ul><li>返回一个数组</li></ul><pre><code>const foo = () =&gt; [5, 6, 7];let [x, y, z] = foo(); // 函数返回结果一个数组，对该数组进行解构，获取里面的每个值//相当于let [x, y, z] =[5, 6, 7];console.log(x, y, z); // 5 6 7</code></pre><ul><li>返回一个对象</li></ul><pre><code>const fun = () =&gt; (&#123;  foo: 2,  bar: 3,&#125;);&gt;let &#123; foo, bar &#125; = fun(); // 函数返回结果一个对象，对该对象进行解构，获取里面的每个值//相当于let &#123; foo, bar &#125; = &#123;foo: 2, bar: 3&#125;;console.log(foo, bar); // 2 3</code></pre><ol start="3"><li>函数参数的解构<blockquote><p>可以方便地将一组参数与变量名对应起来</p></blockquote></li></ol><ul><li>如果传入函数的参数是数组时，可以对参数进行解构，获取数组中每一项的值</li></ul><pre><code>function f([a, b, c]) &#123;  // 相当于  let  [a, b, c]=[5, 6, 7]  console.log(a, b, c);&#125;f([5, 6, 7]); // 5 6 7</code></pre><ul><li>传入函数的参数是对象时，可以对参数进行解构，获取对象中对应的属性值</li></ul><pre><code>function f(&#123; a, b, c &#125;) &#123;  // 相当于 &#123; a, b, c &#125;=&#123; c: 5, a: 6, b: 7 &#125;  console.log(a, b, c); // 6 7 5&#125;f(&#123; c: 5, a: 6, b: 7 &#125;);</code></pre><h3 id="七、函数参数的默认值"><a href="#七、函数参数的默认值" class="headerlink" title="七、函数参数的默认值"></a>七、函数参数的默认值</h3><blockquote><p><strong>提示：</strong></p><ul><li>在 <code>ES6</code> 之前，<strong>不能</strong>直接为函数参数指定默认值，因为我们在实际开发中经常需要用到，所以在之前的课程中，我们把默认值相关内容已经讲了。<blockquote><p>但并没有讲完整，所以这里我们再来完善下相关内容</p></blockquote></li></ul></blockquote><ol><li>函数参数的默认值写法<blockquote><ul><li>如果调用函数时传入了对应的参数，就用传递的参数，如果没有传，就用默认值</li></ul></blockquote></li></ol><ul><li>在 <code>ES6</code> 之前，<strong>不能</strong>直接为函数参数指定默认值，我们通常采用以下变通方法</li></ul><pre><code>function sum(a, b) &#123;  if (a === undefined) a = 0;  if (b === undefined) b = 0;  console.log(`$&#123;a&#125;+$&#123;b&#125;=$&#123;a + b&#125;`);&#125;sum(); // 0+0=0sum(1, 3); // 1+3=4</code></pre><ul><li><code>ES6</code>中，函数指定默认值，非常简单，直接在形参后面赋值</li></ul><pre><code>function sum(a = 0, b = 0) &#123;  console.log(`$&#123;a&#125;+$&#123;b&#125;=$&#123;a + b&#125;`);&#125;sum(); // 0+0=0sum(1, 3); // 1+3=4</code></pre><blockquote><ul><li>这种写法不仅简单，也可以一眼就能意识到那些参数是可以省略不传值的。</li></ul></blockquote><ul><li>默认值生效的<strong>条件</strong>：参数没有赋值，或赋值为 <code>undefined</code></li></ul><pre><code>function sum(a = 0, b = 0) &#123;  console.log(`$&#123;a&#125;+$&#123;b&#125;=$&#123;a + b&#125;`);&#125;sum(); // 0+0=0sum(undefined, &quot;B&quot;); //0+B=0B</code></pre><ol start="2"><li>函数参数默认值是惰性求值的<blockquote><ul><li>如果默认值是表达式，默认值表达式是惰性求值的</li></ul></blockquote></li></ol><pre><code>let x = 1;function fn(a = x++) &#123;  console.log(x);&#125;fn(2); // 1   x++不会执行fn(); // 2   x++被执行fn(undefined); // 3   x++被执行</code></pre><ol start="3"><li>参数默认值的<strong>位置</strong><blockquote><p>通常情况下，定义了默认值的参数应该是函数的<strong>尾参数</strong>。因为这样容易看出，哪些参数是可以省略不传值的。</p><ul><li>如果非尾部的参数设置了默认值，实际上我们是<strong>无法跳过</strong>此参数，设置其后参数的值的。除非显示传入<code>undefined</code>值</li></ul></blockquote></li></ol><pre><code>function fn(a = 1, b, c) &#123;  console.log(a, b, c);&#125;fn(); // 1 undefined undefinedfn(2); // 2 undefined undefinedfn(undefined, 4, 5); // 1 4 5// fn(,3,3); // 报错</code></pre><blockquote><ul><li>参数如果设置了默认值，能往后放，一定放在后面为好，按实际需要调整</li><li>之前设置默认值的参数如果放前面，可能会出现语法错误，现在这个<code>bug</code>已经修复</li></ul></blockquote><ol start="4"><li>函数的 length 属性<blockquote><p>函数的 <code>lenght</code> 属性用来返回<strong>没有指定默认值</strong>的参数个数。</p><ul><li>同时，<code>rest</code> 参数也不会计入 <code>length</code> 属性<img src="函数的length属性1.png"></li></ul></blockquote></li></ol><blockquote><ul><li>注意：如果设置了默认值的参数是不是尾参数，那其后的参数也不会被计入到<code>length</code>属性中<img src="函数的length属性2.png"></li></ul></blockquote><ol start="5"><li>默认参数形成作用域<blockquote><p>一旦参数<strong>设置了默认值</strong>，函数进行声明初始化时，参数会形成一个<strong>单独的作用域</strong>。等到<strong>初始化结束时</strong>，这个作用域就会消失。</p><ul><li>不过这种语法行为在不设置参数默认值时是不会出现的。</li></ul></blockquote></li></ol><pre><code>let a = 1;const f = (a, b = a) =&gt; &#123;  console.log(b);&#125;;f(3); // 3</code></pre><blockquote><ul><li>函数被调用时，在进入函数作用域之前，参数会形成单独的作用域</li><li>在这个作用域内：<code>&#123;let a; let b=a;&#125;</code>，在这个作用域里，执行<code>b=a</code>时，会<strong>先在本作用域内</strong>找a，没找到就去<strong>全局</strong>作用域找，还没找到就报错。<strong>不会</strong>去函数作用域内找；</li></ul></blockquote><pre><code>let a = 1;const f = (b = a) =&gt; &#123;  let a = 33;  console.log(b);&#125;;// 因为没有传入对应实参，则会启用默认值b=a,此时参数会形成一个单独的作用域，在此作用域中没有变量a,所以最终沿着作用域向外查找到全局作用域中的a=1,即b=1f(); // 1f(2); // 2  b没有启用默认值，而是传过来的实参2</code></pre><ul><li>注意区分以下几种错误写法：<blockquote><p><strong>第一种</strong></p></blockquote></li></ul><pre><code>const f = (b = a) =&gt; &#123;  let a = 33;  console.log(b);&#125;;f(); // 报错</code></pre><blockquote><ul><li>因为没有传入对应实参，则会启动默认值<code>b=a</code></li><li>在参数单独形成的作用域内，没有找到<code>a</code>，沿着作用域链往外找，在全局作用域里也没有找到，所以会报错</li></ul></blockquote><blockquote><p><strong>第二种</strong></p></blockquote><pre><code>let a = 5;const f = (a = a) =&gt; &#123;  console.log(a);&#125;;f(4); // 4f(); // 报错</code></pre><blockquote><ul><li>因为没有传入对应实参，则会启动默认值<code>a=a</code></li><li>在参数单独形成的作用域内，<code>let a=a</code>；在a没有完成声明前调用a，就会形成暂时性死区</li><li>在变量a的声明语句还没有执行完成前，就去取a的值，导致报错</li></ul></blockquote><ul><li>如果参数的默认值是一个函数，该函数的作用域也遵守这个规则。</li></ul><pre><code>let c = 4;function f(a = 2, fn = () =&gt; c + a) &#123;  let c = 5;  console.log(fn());&#125;f(); // 6</code></pre><blockquote><ul><li><code>f()</code>没有传入对应的实参，则会启用默认值，因为参数设置了默认值，所以参数会形成一个作用域</li><li>此时作用域中相当于<code>let a=2,fn=()=&gt;c+a;</code>函数返回值中的<code>a</code>为当前作用域中的<code>2</code>，<code>c</code>为全局作用域中的<code>4</code>，最后<code>fn()</code>调用，输出结果为<code>6</code></li></ul></blockquote><pre><code>let a = 1;function fn() &#123;  a = 5;&#125;function f(a, b = fn) &#123;  // let a=55; 会报错  var a = 55;  b();  console.log(a);&#125;f(); // 55console.log(a);//5</code></pre><blockquote><ul><li>在调用<code>f()</code>时，没有传入参数，所以启动默认值</li><li>在参数作用域内，<code>let a=1; let b=fn</code>；(此时b&#x3D;fn是赋值，不是声明)</li><li>进入到函数作用域内<ul><li>如果是<code>var a=55;</code>，用的是<code>var</code>，所以替代了参数作用域里声明的<code>a</code>；执行<code>b()</code>时，因为<code>fn</code>是在全局作用域中声明的，所以调用<code>b()</code>时，修改的是全局作用域中的的<code>a</code>,而函数体中的<code>console.log(a)</code>访问的是当前函数作用域中的 <code>a</code>,所以打印结果为<code>55</code></li><li>如果是<code>let a=55</code>，在参数作用域内声明的<code>let a=1</code>，会和函数体内的<code>let a=55</code>冲突；所以报错<code>Identifier &#39;a&#39; has already been declared</code></li></ul></li></ul></blockquote><blockquote><blockquote><p><code>JS</code>是<strong>静态</strong>作用域，函数在哪里声明，它的作用域就在哪里；函数里面的参数也是沿着函数作用域向外查找</p></blockquote><ul><li><code>fn</code>是在全局作用域下声明的，所以函数体内的<code>a</code>会向外找到全局作用域下声明的<code>a</code>；</li></ul></blockquote><blockquote><ul><li>如果fn是在参数作用域声明的，那情况就另当别论了：</li></ul></blockquote><pre><code>let a = 1;function fn() &#123;  a = 5;&#125;function f(a, b = function fn1()&#123;a=3&#125;) &#123;  //let a,let b=function fn1()&#123;a=3&#125; 在b没有被调用前,a就不会被赋值  var a = 55;  b();  //b调用后 参数作用域内声明的a被赋值3，但改变不了函数体内声明的a  console.log(a);&#125;f(); // 55console.log(a);//1</code></pre><blockquote><ul><li>在调用<code>f()</code>时，没有传入参数，所以启动默认值</li><li>在参数作用域内，<code>&#123;let a; let b=function fn1()&#123;a=3&#125;&#125;</code>，<code>fn1</code>在参数作用域内声明，一旦被调用，那它改变的是参数作用域内声明的a的值</li><li>由于函数体内又用<code>var</code>改变了a的值，所以即使<code>b()</code>，也改变不了函数体内a的值</li><li>而外面的a由于函数<code>fn</code>没有被调用，所以值不变</li></ul></blockquote><ol start="6"><li>函数参数的默认值与解构赋值结合使用<blockquote><p>指定参数的默认值，就避免了在函数体内部再去判断传入的参数是否有值了。</p><ul><li>不过要区分以下 3 种不同方式</li></ul></blockquote></li></ol><blockquote><p><strong>第一种</strong></p><ul><li>如果不传实参就会报错</li></ul></blockquote><pre><code>function foo(&#123; a = 1, b = 3 &#125;) &#123;  console.log(a, b);&#125;&gt;// foo(); // 报错// 相当于  let &#123;a = 1, b = 3&#125;=undefined&gt;foo(&#123;&#125;); // 1 3// 相当于 let &#123;a = 1, b = 3&#125;=&#123;&#125; 没有对应值，则用默认值&gt;foo(&#123; a: &quot;A&quot; &#125;); // A 3// 相当于 let &#123;a = 1, b = 3&#125;=&#123; a: &quot;A&quot; &#125; a有值，用传的值，b无值，用默认值&gt;foo(&#123; a: &quot;A&quot;, b: &quot;B&quot; &#125;); // A B// 相当于 let &#123;a = 1, b = 3&#125;=&#123; a: &quot;A&quot;, b: &quot;B&quot; &#125; a与b都有值，用传的值</code></pre><blockquote><p><strong>第二种</strong></p></blockquote><pre><code>function foo(&#123; a = 1, b = 3 &#125; = &#123;&#125;) &#123;  console.log(a, b);&#125;foo(); // 1 3// 相当于 let &#123; a = 1, b = 3 &#125; = &#123;&#125;&gt;foo(&#123;&#125;); // 1 3// 相当于 let &#123; a = 1, b = 3 &#125;=&#123;&#125;&gt;foo(&#123; a: &quot;A&quot; &#125;); // A 3// 相当于 let &#123; a = 1, b = 3 &#125;=&#123; a: &quot;A&quot; &#125;&gt;foo(&#123; a: &quot;A&quot;, b: &quot;B&quot; &#125;); // A B// 相当于 let &#123; a = 1, b = 3 &#125;=&#123; a: &quot;A&quot;, b: &quot;B&quot; &#125;</code></pre><blockquote><p><strong>第三种</strong></p><ul><li>传空值或者只传一个就会得到<code>undefinded</code></li></ul></blockquote><pre><code>function foo(&#123; a, b &#125; = &#123; a: 1, b: 3 &#125;) &#123;  console.log(a, b);&#125;&gt;foo(); // 1 3// 相当于 let &#123; a, b &#125; = &#123; a: 1, b: 3 &#125;&gt;foo(&#123;&#125;); // undefined undefined// 相当于 let &#123; a, b &#125; = &#123;&#125;&gt;foo(&#123; a: &quot;A&quot; &#125;); // A  undefined// 相当于 let &#123; a, b &#125; =&#123; a: &quot;A&quot; &#125;&gt;foo(&#123; a: &quot;A&quot;, b: &quot;B&quot; &#125;); // A B// 相当于 let &#123; a, b &#125;=&#123; a: &quot;A&quot;, b: &quot;B&quot; &#125;</code></pre><h2 id="ES6-剩余参数-和-展开运算符在实际开发中的应用"><a href="#ES6-剩余参数-和-展开运算符在实际开发中的应用" class="headerlink" title="ES6 剩余参数 和 展开运算符在实际开发中的应用"></a>ES6 剩余参数 和 展开运算符在实际开发中的应用</h2><h3 id="一、剩余参数"><a href="#一、剩余参数" class="headerlink" title="一、剩余参数"></a>一、剩余参数</h3><ol><li>什么是剩余参数<blockquote><p><code>ES6</code>中引入了 <code>rest</code>（剩余）参数，允许将<strong>不确定部分的参数</strong>合成一个数组。其写法为 <code>...变量名</code>，变量是一个<strong>数组</strong>，用来保存不确定部分的参数，变量名自己取。</p><ul><li>简单理解：rest 参数，就是把用逗号隔开的值合成一个数组，保存在变量中。</li></ul></blockquote></li></ol><pre><code>// ...args 为剩余参数，其中变量args表示一个数组,用来接受传过来的所有实参const sum = (...args) =&gt; &#123;  console.log(args);&#125;;sum(1, 2, 3, 4); //  [1, 2, 3, 4]sum(); // []&gt;// ...args 为剩余参数，其中变量args表示一个数组，用于接受第3个（包含）之后的所有实参const f = (a, b, ...args) =&gt; &#123;  console.log(a); // 1  console.log(b); // 2  console.log(args); // [3, 4, 5]&#125;;f(1, 2, 3, 4, 5);</code></pre><blockquote><blockquote><p>注：</p></blockquote><ul><li>我们要确定剩余参数对应的参数，<strong>先要把确定的参数排除</strong>，剩下的不确定参数就全部归剩余参数。</li></ul></blockquote><ol start="2"><li>剩余参数的本质<blockquote><p>剩余参数中的变量本质是一个数组，即使没有值，也是一个空数组，所以<strong>数组所有的方法这个变量都可以用</strong></p></blockquote></li></ol><pre><code>const f = (a, ...args) =&gt; &#123;  console.log(args); // [2, 3, 4, 5]  args.push(a);  console.log(args); //[2, 3, 4, 5, 1]&#125;;f(1, 2, 3, 4, 5);</code></pre><ol start="3"><li>剩余参数的注意事项<blockquote><ul><li>剩余参数之后不能再有其它参数，即剩余参数<strong>必须是最后一个参数</strong>，否则会报错</li></ul></blockquote></li></ol><pre><code>const f = (a,...args,b)=&gt;&#123;&#125; // 报错</code></pre><blockquote><ul><li>当箭头函数中只有一个剩余参数时，其圆括号也不能省略</li></ul></blockquote><pre><code>// const f = ...args =&gt; args;  错误写法const f = (...args) =&gt; args;console.log(f(1, 2, 3)); // [1, 2, 3]</code></pre><blockquote><ul><li>在箭头头函数中没有<code>arguments</code>，所以<code>rest</code>剩余参数可以在箭头或普通函数中<strong>替代</strong> <code>arguments</code> 来接受对应的实参列表。</li><li><code>arguments</code>是类数组对象，很多时候要把他转换为数组再用，而剩余参数本身就是数组，用起来就很方便</li></ul></blockquote><ul><li>之前用<code>arguments</code><blockquote><ul><li>要先将类数组转化为数组</li></ul></blockquote></li></ul><pre><code>function sum() &#123;  let result = 0; // 累加器  //将arguments转化为数组  Array.prototype.forEach.call(arguments, (item) =&gt; &#123;    result += item;  &#125;);  return result;&#125;console.log(sum(1, 2, 3, 4));</code></pre><ul><li>现在用剩余参数+箭头函数更加方便、简洁</li></ul><pre><code>const sum = (...args) =&gt; &#123;  let result = 0;  args.forEach((item) =&gt; (result += item));  return result;&#125;;console.log(sum(1, 2, 3, 4)); //10</code></pre><blockquote><ul><li>函数的<code>length</code>属性用来保存未设置默认值参数的个数，<code>rest</code>剩余参数<strong>不计入其中</strong><blockquote><p>注意：上节有讲到<code>length</code>只会保存从左往右，遇到的第一个有默认值参数之前的参数的个数</p></blockquote></li></ul></blockquote><pre><code> const f = (a, b, c = 2, ...args) =&gt; &#123;&#125;; console.log(f.length); // 2 const fn = (a, b = 1, c, ...args) =&gt; &#123;&#125;; console.log(fn.length); //1</code></pre><blockquote><p><strong>总结</strong></p><table><thead><tr><th>注意事项</th><th>说明</th></tr></thead><tbody><tr><td>剩余参数的位置</td><td>剩余参数必须是最后一个参数</td></tr><tr><td>箭头函数中只有一个剩余参数</td><td>箭头函数中只有一个剩余参数，也不能省略圆括号</td></tr><tr><td>剩余参数与<code>arguments</code></td><td>箭头函数中没有<code>arguments</code>，在往后的开发中，我们会利用剩余参数来替代<code>arguments</code>，因为剩余参数本身就是一个数组，用起来更方便</td></tr><tr><td>函数<code>length</code>属性不计算<code>rest</code>参数</td><td>函数的<code>length</code>属性用来保存未设置默认值参数的个数，<code>rest</code>剩余参数不计入其中</td></tr></tbody></table></blockquote><ol start="4"><li>剩余参数在实际开发中的应用</li></ol><ul><li>根据实参传递的个数来求和</li></ul><pre><code>const sum = (...args) =&gt; &#123;  let result = 0;  args.forEach((item) =&gt; (result += item));  return result;&#125;;console.log(sum(1, 2, 3, 4)); //10</code></pre><ul><li>剩余参数与<strong>数组</strong>的解构赋值的结合应用</li></ul><pre><code>// 绑定模式let [a, b, ...c] = [1, 2, 3, 4, 5, 6];console.log(a); // 1console.log(b); // 2console.log(c); //  [3, 4, 5, 6]&gt;// 赋值模式let a, b, c;[a, b, ...c] = [1, 2, 3, 4, 5, 6];console.log(a); // 1console.log(b); // 2console.log(c); //  [3, 4, 5, 6]</code></pre><ul><li>剩余参数与与对象的解构赋值结合应用<blockquote><ul><li>剩余元素与对象解构赋值结合时，它不是数组，而是<strong>对象</strong></li><li>同时解构赋值时，剩余元素<strong>不会复制原型对象上的属性</strong></li></ul></blockquote></li></ul><pre><code>// 绑定模式const &#123; a, b, ...c &#125; = &#123; a: 1, b: 2, c: 3, d: 5 &#125;;console.log(a); // 1console.log(b); // 2console.log(c); // &#123;c: 3, d: 5&#125;&gt;// 赋值模式const a, b, c;(&#123; a, b, ...c &#125; = &#123; a: 1, b: 2, c: 3, d: 5 &#125;);console.log(a); // 1console.log(b); // 2console.log(c); // &#123;c: 3, d: 5&#125;</code></pre><blockquote><blockquote><p>总结：</p></blockquote><ul><li>剩余参数不一定非要作为函数参数使用，解构赋值也可以使用</li><li>当剩余参数与<strong>解构赋值</strong>结合使用时，我们称他为<strong>剩余元素</strong>。</li><li>同时在与解构赋值结合时，也只能是最后一个元素，之后不能再有其他参数，否则会报错</li></ul></blockquote><ul><li>我们来看下面这种情况，以下<code>args</code>是剩余参数还是剩余元素</li></ul><pre><code>function fn([a, ...args1], ...args2) &#123;  console.log(args1); // [2, 3, 4] 剩余元素  console.log(args2); // [&#39;A&#39;, &#39;B&#39;] 剩余参数&#125;fn([1, 2, 3, 4], &quot;A&quot;, &quot;B&quot;);</code></pre><blockquote><ul><li><code>[a, ...args1]</code>由数组包裹，所以是解构赋值；因此里面<code>...args</code>只能是剩余元素</li><li><code>...args2</code>作为函数参数使用，所以是剩余参数</li></ul></blockquote><blockquote><blockquote><p>总结</p></blockquote><ul><li>剩余参数和剩余元素的书写格式都是使用<code>…变量名</code>的方式</li><li>不同的是：剩余参数是直接作为函数参数使用的。剩余元素是在解构赋值时，用来接收剩下的元素。</li></ul></blockquote><h3 id="二、数组的扩展（展开）运算符"><a href="#二、数组的扩展（展开）运算符" class="headerlink" title="二、数组的扩展（展开）运算符"></a>二、数组的扩展（展开）运算符</h3><ol><li>什么是数组扩展运算符<blockquote><p>数组扩展运算符（spread）是三个点<code>...</code>,他可以将数组<strong>展开</strong>为用逗分隔的参数序列。</p></blockquote></li></ol><pre><code>const arr = [1, 2, 3];console.log(...arr); // 1 2 3// ...arr 相当于把数组展开以逗号分隔的序列 console.log(1,2,3)&gt;console.log(1, ...[&quot;A&quot;, &quot;B&quot;, &quot;C&quot;], 2); // 1 &#39;A&#39; &#39;B&#39; &#39;C&#39; 2</code></pre><ul><li>如果扩展运算符后面是一个空数组，则不会产生任何效果</li></ul><pre><code>const arr = [1, 2, ...[], 3];console.log(arr); // [1, 2, 3]//不要以为它是[1, 2, , 3]</code></pre><blockquote><ul><li>注意！！！不要以为<code>...[]</code>会占一个值，它没有效果<strong>不占空间</strong></li></ul></blockquote><ul><li>数组扩展运算符后面可以放置<strong>表达式</strong></li></ul><pre><code>let a = 1;let b = 3;const arr = [...(a &gt; b ? [a] : [b])];console.log(arr); // [3]</code></pre><ol start="2"><li>区分扩展运算符和剩余参数<blockquote><p>我们上边学习的展开运算符，发现它和剩余参数在语法上是一样的，都是前边加上<code>...</code>这样就会导致我们经常分不清楚。</p><ul><li>接下来我们来看剩余参数和展开运算符的<strong>根本区别</strong>。</li></ul></blockquote></li></ol><ul><li>展开运算符：展开运算符是将数组展开成一个个以逗号分隔的序列。</li></ul><pre><code>[6,2,3] -&gt; 6,2,3</code></pre><ul><li>剩余参数：将参数列表的形式转换成数组形式</li></ul><pre><code>6,2,3 -&gt; [6,2,3]</code></pre><ul><li>区分以下代码中，哪些是扩展运算符，哪些是剩余参数</li></ul><pre><code>const sum = (...args) =&gt; &#123;  // ...args：剩余参数 args是由所有实参组成的数组  console.log(args); // [6, 2, 3]  // 展开运算符，...args 相当于 ...[6, 2, 3] 将数组展开成 6,2,3  console.log(...args); // 6 2 3&#125;;sum(6, 2, 3);</code></pre><ul><li>以下代码中的第一个<code>...arg1</code>、<code>...arg2</code>、第二个<code>...arg1</code>，分别是表示什么 ？</li></ul><pre><code>const f = ([...arg1], ...arg2) =&gt; &#123;  console.log(arg2);  console.log(...arg1);&#125;;f([1, 2, 3], &quot;A&quot;, &quot;B&quot;, [&quot;x&quot;, &quot;y&quot;]);</code></pre><blockquote><ul><li><code>[...arg1], ...arg2</code>共同作为函数的参数</li><li><code>[...arg1]</code>由数组包裹，与解构赋值结合，所以<code>...arg1</code>肯定是剩余元素，<code>arg1</code>是由剩余元素组成的数组</li><li><code>...arg2</code>是剩余参数，用来接受除第一个参数之外的其它参数；<code>arg2</code>是由剩余参数组成的数组</li><li>因为<code>arg1</code>是由剩余元素组成的数组,所以函数体内的<code>...arg1</code>是为了将第一个<code>arg1</code>对应的数组展开</li></ul></blockquote><ol start="4"><li>数组展开运算符在实际开发中的应用</li></ol><ul><li>复制数组</li></ul><pre><code>const arr = [1, 2, 3, 4, 5];// 展开运算符复制数组const arr1 = [...arr];console.log(arr1); // [1, 2, 3, 4, 5]</code></pre><blockquote><ul><li>复制数组本质：在原来的数组中展开数组即可，展开也是浅复制(浅拷贝)</li></ul></blockquote><ul><li>合并数组</li></ul><pre><code>// 合并数组const x = [1];const y = [2, 3];const z = [5, 6, 8];&gt;// 展开运算符合并数组console.log([...x, ...y, ...z]); // [1, 2, 3, 5, 6, 8]// 随意调换顺序console.log([...y, ...x, ...z]); // [2, 3, 1, 5, 6, 8]console.log([...z, ...x, ...y]); // [5, 6, 8, 1, 2, 3]// 还可以根据自己的需求增加数组的值console.log([...z, 10, ...x, 20, ...y, 30]); // [5, 6, 8, 10, 1, 20, 2, 3, 30]</code></pre><ul><li>字符串转为数组<blockquote><ul><li>字符串可以按照数组的形式展开</li></ul></blockquote></li></ul><pre><code>// 字符串可以看做是一个类数组，因此字符串是可以按照数组的形式展开const str = &quot;icoding&quot;;// 使用展开运算符将字符串展开console.log(...str); // i c o d i n g&gt;// 将字符串转为数组，只需要将展开字符串放到数组[]中即可const arr = [...str];console.log(arr); // [&#39;i&#39;, &#39;c&#39;, &#39;o&#39;, &#39;d&#39;, &#39;i&#39;, &#39;n&#39;, &#39;g&#39;]</code></pre><blockquote><blockquote><p>为什么要将字符串转数组呢 ？</p></blockquote><ul><li>因为，数组中有很多好用的方法，我们就可以把字符串转为数组，即<strong>可使用数组的方法</strong>。用完之后再把数组转为字符串，这样就非常方便了。</li></ul></blockquote><ul><li>常见的类数组转化为数组<blockquote><ul><li><code>arguments</code>类数组</li></ul></blockquote></li></ul><pre><code>function foo() &#123;  // 在数组中展开 arguments 即可 将类数组转为数组  console.log([...arguments]);&#125;foo(1, 2, 3); // [1, 2, 3]</code></pre><blockquote><ul><li><code>NodeList</code> 类数组</li></ul></blockquote><pre><code>// NodeList 是类数组没有数组相关方法const p = document.querySelectorAll(&quot;p&quot;);// 使用展开运算符转为数组const arr = [...p];console.log(arr); // [p, p, p]</code></pre><blockquote><blockquote><p>注意：任何<code>Iterator</code>接口的对象都可以用扩展运算符转为真正的数组</p></blockquote></blockquote><ul><li>将数组转换为函数的参数<blockquote><ul><li>由于扩展运算符可以展开数组，所以不再需要使用 <code>apply</code> 方法将一个数组转为函数的参数了。可以直接用扩展运算符来实现。<br><strong>案例：求数组中的最大值和最小值</strong></li><li>先来复习两个Math对象上的方法</li></ul></blockquote></li></ul><pre><code>let max = Math.max(1, 2, 5); // 返回参数列表中的最大值let min = Math.min(1, 2, 5); // 返回参数列表中的最小值console.log(max, min); // 5 1</code></pre><blockquote><ul><li>没有扩展运算符之前，实现代码如下:</li></ul></blockquote><pre><code>const arr = [17, 5, 1, 8, 3, 20];let max = Math.max.apply(null, arr);let min = Math.min.apply(null, arr);console.log(max, min); // 20 1</code></pre><blockquote><ul><li>利用扩展运算符实现，代码如下</li></ul></blockquote><pre><code>const arr = [17, 5, 1, 8, 3, 20];let max = Math.max(...arr);let min = Math.min(...arr);console.log(max, min); // 20 1</code></pre><h3 id="三、对象的扩展（展开）运算符"><a href="#三、对象的扩展（展开）运算符" class="headerlink" title="三、对象的扩展（展开）运算符"></a>三、对象的扩展（展开）运算符</h3><ol><li>什么是对象的扩展运算符<blockquote><p>扩展运算符<code>...</code>用于取出对象的<strong>所有可遍历属性</strong>，并将其复制到当前对象之中。</p><ul><li>也就是说 <strong>对象不能直接展开或在数组中展开</strong>，必须在<code>&#123;&#125;</code>对象中展开。</li></ul></blockquote></li></ol><pre><code>const student = &#123;  username: &quot;icoding&quot;,  age: 18,  sex: &quot;male&quot;,  addr: &quot;北京&quot;,&#125;;&gt;console.log(&#123; ...student &#125;); // &#123;username: &#39;icoding&#39;, age: 18, sex: &#39;male&#39;, addr: &#39;北京&#39;&#125;// 对象不能使用以下方式展开console.log(...student); // 报错console.log([...student]); // 报错</code></pre><blockquote><p><strong>或</strong></p></blockquote><pre><code>const obj = &#123;  a: 1,  ...&#123; b: 2, c: 3 &#125;,  d: 4,&#125;;console.log(obj); // &#123;a: 1, b: 2, c: 3, d: 4&#125;</code></pre><ol start="2"><li>对象扩展运算符的注意事项</li></ol><ul><li>空对象的展开<blockquote><blockquote><p>如果展开一个空对象，没有任何效果</p></blockquote></blockquote></li></ul><pre><code>console.log(&#123; ...&#123;&#125; &#125;); // &#123;&#125;&gt;// 空对象 和 属性的合并console.log(&#123; ...&#123;&#125;, x: 123 &#125;); // &#123;x: 123&#125;</code></pre><ul><li>非对象的展开，自动转换为对象<blockquote><blockquote><p>如果展开的不是对象，则会<strong>自动将其转为对象</strong>，再将其属性罗列出来</p></blockquote><ul><li>数值、<code>undefined</code>、<code>null</code>、<code>boolean</code></li></ul></blockquote></li></ul><pre><code>// 数值类型console.log(&#123; ...2 &#125;); // &#123;&#125;// undefinedconsole.log(&#123; ...undefined &#125;); // &#123;&#125;// nullconsole.log(&#123; ...null &#125;); // &#123;&#125;// booleanconsole.log(&#123; ...true &#125;); // &#123;&#125;</code></pre><blockquote><ul><li>对象扩展运算符的参数是<code>null</code>或<code>undefined</code>时，这两个值会被忽略，但不会报错</li></ul></blockquote><blockquote><ul><li>字符串类型</li></ul></blockquote><pre><code>// 对象中展开运算符后边是字符串console.log(&#123; ...&quot;arry&quot; &#125;); // &#123;0: &#39;a&#39;, 1: &#39;r&#39;, 2: &#39;r&#39;, 3: &#39;y&#39;&#125;// 数组中展开运算符后边是字符串console.log([...&quot;arry&quot;]); // [&#39;a&#39;, &#39;r&#39;, &#39;r&#39;, &#39;y&#39;]// 直接展开字符串console.log(...&quot;arry&quot;); // a r r y&gt;// 对象中展开运算符后边是数组console.log(&#123; ...[1, 2, 3] &#125;); // &#123;0: 1, 1: 2, 2: 3&#125;//在数组中展开对象：报错</code></pre><ul><li>对象展开属于浅复制（浅拷贝）<blockquote><ul><li>对象展开的本质：就是把对象的属性复制罗列出来，用逗号分隔，放到一个<code>&#123;&#125;</code>中，不过在复制属性时，属于浅复制（浅拷贝）</li></ul></blockquote></li></ul><pre><code>const obj = &#123;  a: 1,  b: 2,  arr: [&quot;A&quot;, &quot;B&quot;, &quot;C&quot;],&#125;;// 将obj在一个对象中展开const obj2 = &#123; ...obj &#125;;console.log(obj2); // &#123;a: 1, b: 2, arr: [&quot;A&quot;, &quot;B&quot;, &quot;C&quot;]&#125;console.log(obj === obj2); // falseobj.arr.push(&quot;D&quot;);console.log(obj2); // &#123;a: 1, b: 2, arr: [&quot;A&quot;, &quot;B&quot;, &quot;C&quot;,&quot;D&quot;]&#125;console.log(obj.arr === obj2.arr); // true&gt;// 当我们给obj中的arr数组后面添加一个新的元素&quot;D&quot;时，obj2中的arr数组中的元素也更改了，本质上obj.arr与obj2.arr 是完全相等的</code></pre><ul><li>合并对象，同名属性会<strong>覆盖</strong><blockquote><ul><li>如果展开的对象中有与现有对象中同名的属性，则会发生覆盖。覆盖原则以<strong>写在后面的覆盖前面</strong>。</li></ul></blockquote></li></ul><pre><code>const obj = &#123;  a: 1,  b: 2,  c: 3,&#125;;const obj2 = &#123;  a: &quot;清心&quot;,  ...obj,  c: &quot;icoding&quot;,&#125;;console.log(obj2);&gt;// obj中的属性a覆盖了obj2中同名的a，obj2中的属性c，覆盖了obj中同名的属性c</code></pre><ul><li>扩展运算符的参数对象之中如果有取值函数<code>get</code>，这个函数将会被执行</li></ul><pre><code>let obj = &#123;  _x: 1,  get x() &#123;    return this._x;  &#125;,  set x(value) &#123;    if (value === 3) &#123;      this._x = &quot;不通过&quot;;    &#125; else &#123;      this._x = value;    &#125;  &#125;,&#125;;const obj2 = &#123; ...obj &#125;;console.log(obj2); // &#123;_x: 1, x: 1&#125;obj2.x = 3; // 丢失了set函数的功能,原本应该=&quot;不通过&quot;console.log(obj2); // &#123;_x: 1, x: 3&#125;</code></pre><ol start="3"><li>对象展开运算符在实际开发中的应用</li></ol><ul><li>复制对象（浅复制）</li></ul><pre><code>const x = &#123; a: 1, b: 2 &#125;;// 使用展开运算符复制对象const y = &#123; ...x &#125;;console.log(y); // &#123;a: 1, b: 2&#125;console.log(y === x); // false 只是复制对象</code></pre><ul><li>用户参数与默认参数合并<blockquote><p>如果我们想写一个提供给用户使用的函数或方法时，就会涉及用户参数和默认参数。即：</p><ul><li><strong>用户参数</strong>： 是用户调用方法时实际传递的参数都叫做用户参数，也就是我们之前提到的实参。</li><li><strong>默认参数</strong>： 如果函数参数有三个，用户只传递了两个，剩余的默认参数就会生效，这样可以让用户少传递不必要的参数，可以让用户使用函数变得更方便</li></ul></blockquote></li></ul><blockquote><p><strong>方法1</strong></p></blockquote><pre><code>// 之前讲过的做法，给对象设置默认值 &#123;&#125;const person = (&#123; username = &quot;icoding&quot;, age = 0, sex = &quot;male&quot; &#125; = &#123;&#125;) =&gt; &#123;  console.log(username, age, sex);&#125;;&gt;person(); // icoding 0 male // 默认值生效person(&#123; username: &quot;arry&quot; &#125;); // arry 0 male</code></pre><blockquote><ul><li>这种方法需要在函数的参数括号里写</li></ul></blockquote><blockquote><p><strong>方法2</strong></p><ul><li>统一用一个<strong>对象的形式</strong>来设置<strong>默认参数</strong></li><li>利用<code>写在后面的会覆盖前面的</code>原理，解构赋值</li></ul></blockquote><pre><code>const person = (userParam) =&gt; &#123;// 统一用一个对象的形式来设置默认参数  const defaultParam = &#123;    username: &quot;icoding&quot;,    age: 18,    sex: &quot;女&quot;,  &#125;;// 最终的参数,将用户参数和默认参数合并,将userParam写到后边  const &#123; username, age, sex &#125; = &#123; ...defaultParam, ...userParam &#125;;  console.log(username, age, sex);&#125;;person(); //icoding 18 女  默认值生效&gt;const myDate = &#123;  username: &quot;小明&quot;,  age: 20,  sex: &quot;男&quot;,&#125;;person(myDate); //小明 20 男</code></pre>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JS核心知识点（十八）</title>
      <link href="/2023/12/09/JS%E6%A0%B8%E5%BF%83%E7%9F%A5%E8%AF%86%E7%82%B9%EF%BC%88%E5%8D%81%E5%85%AB%EF%BC%89/"/>
      <url>/2023/12/09/JS%E6%A0%B8%E5%BF%83%E7%9F%A5%E8%AF%86%E7%82%B9%EF%BC%88%E5%8D%81%E5%85%AB%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<span id="more"></span><h2 id="ECMAScript、ES6-简史，let、const、var-区别和应用"><a href="#ECMAScript、ES6-简史，let、const、var-区别和应用" class="headerlink" title="ECMAScript、ES6 简史，let、const、var 区别和应用"></a>ECMAScript、ES6 简史，let、const、var 区别和应用</h2><h3 id="一、什么是-ES"><a href="#一、什么是-ES" class="headerlink" title="一、什么是 ES"></a>一、什么是 ES</h3><blockquote><p><strong>我们首先来看 ECMA 是什么</strong></p><ul><li>ECMA，读音类似“埃科妈”，是欧洲计算机制造商协会（European Computer Manufacturers Association）的简称，是一家国际性会员制度的信息和电信标准组织。1994 年之后，由于组织的标准牵涉到很多其他国家，为了体现其国际性，更名为 <strong>Ecma 国际</strong>（Ecma International），因此 Ecma 就不再是首字母缩略字了。</li><li>了解了这段历史，为了技术书写的专业性，如果文章中提到 <code>Ecma</code>的时候，可以写成<code>Ecma</code>或者<code>ecma</code>，不要写成全大写的<code>ECMA</code>，除非是<code>ECMAScript</code>或<code>ECMA-XXX</code>这类专有名词。</li></ul></blockquote><blockquote><p><strong>什么是 Javascript?</strong></p><ul><li>1995 年，著名的网景公司（Netscape）的<code>Brendan Eich</code> 开发了一种脚本语言，最初命名为<code>Mocha</code>，后来改名为 <code>LiveScript</code>，最后为了蹭当时火热的<code>Java</code>热度重命名为了 <code>JavaScript</code>。</li></ul></blockquote><blockquote><p><strong>什么是 ECMAScript?</strong></p><ul><li>了解了 <code>Ecma</code> 国际和 <code>JavaScript</code>，就方便了解 <code>ECMAScript</code> 了，<code>ECMAScript</code> 是一种由 <code>Ecma 国际</code>在标准 <code>ECMA-262</code> 中定义的 脚本语言 规范。这种语言往往被称为 J<code>avaScript</code> 或 <code>JScript</code> ，但实际上 <code>JavaScript</code> 和 <code>JScript</code> 是 <code>ECMA-262</code> 标准的实现和扩展。</li></ul></blockquote><blockquote><p><strong>一句话总结ES</strong><br><code>ES</code>是指<code>ECMAScript</code>，<code>Ecma</code> 是一个专门为技术制定标准的组织。<code>ECMAScript</code> 是由 <code>Ecma 国际</code>通过 <code>ECMA-262</code> 标准化的脚本程序设计语言。</p><ul><li><code>ECMAScript</code> 是一种标准或者说叫做一种<strong>规范</strong></li><li><code>JavaScript</code> 是 <code>ECMAScript</code> 的一种<strong>实现</strong>，也就是说 <code>JavaScript</code>是一门遵循了<code>ECMAScript</code>语言规范而设计的编程语言</li></ul></blockquote><ol><li><p>什么是神秘的 ECMA-262</p><blockquote><ul><li>Ecma 国际的标准都会以 <code>Ecma-Number</code> 命名，<code>ECMA-262</code> 就是 <code>ECMA 262 号标准</code>，具体就是指 <code>ECMAScript</code> 遵照的标准。1996 年 11 月，网景公司将 JavaScript 提交给 Ecma 国际进行标准化。ECMA-262 的第一个版本于 1997 年 6 月被 Ecma 国际采纳。</li><li>Ecma 国际制定了许多标准，而 ECMA-262 只是其中的一个，所有标准列表查看</li><li>官网：<code>https://www.ecma-international.org/</code></li></ul></blockquote></li><li><p>语法提案的批准流程</p><blockquote><p>任何人都可以向标准委员会（又称 TC39 委员会）提案，要求修改语言标准。<br>一种新的语法从提案到变成正式标准，需要经历五个阶段。每个阶段的变动都需要由 TC39 委员会批准。</p><ul><li>Stage 0 - Strawman（展示阶段）</li><li>Stage 1 - Proposal（征求意见阶段）</li><li>Stage 2 - Draft（草案阶段）</li><li>Stage 3 - Candidate（候选人阶段）</li><li>Stage 4 - Finished（定案阶段）<br>一个提案只要能进入 Stage 2，就差不多肯定会包括在以后的正式标准里面。ECMAScript 当前的所有提案，可以在 TC39 的官方网站</li></ul></blockquote></li><li><p>探秘 TC39 神秘组织</p><blockquote><p>TC39 是<code>Technical Committee 39</code>的简称，它是制定 <code>ECMAScript</code> 标准的委员会。<br>TC39（Technical Committee 39）是推进 ECMAScript 发展的委员会。其会员都是公司。TC39 定期召开会议，会议由会员公司的代表与特邀专家出席。<br>由各个主流浏览器厂商的代表构成，主席团三人分别来自 <code>Bloomberg</code>、<code>Igalia</code> 和 <code>Microsoft</code>，下设三个工作组（task group） <code>TC39-TG1</code>（通用语言）、 <code>TC39-TG2</code>（国际化 API 规范） 、<code>TC39-TG3</code>（安全）。</p><ul><li><code>TC39-TG1</code> 工作组主要工作是通用、跨平台、供应商中立的编程语言 ECMAScript® （JavaScriptTM&gt;） 的标准化。这包括语言语法、语义以及支持该语言的库和补充技术。</li><li><code>TC39-TG2</code> 工作组 ECMAScript® 国际化 API 标准。支持需要适应不同人类语言和国家&#x2F;地区使用的语言和文化约定的程序。</li><li><code>TC39-TG3</code> 工作组 ECMAScript® （TM） 安全模型对当前和未来不断变化的威胁形势有效。</li></ul></blockquote></li><li><p>ECMAScript 版本</p><blockquote><p>ECMAScript &#x3D; 由 ECMA 这个标准化组织制定的一个语言标准<br>语言标准就是：语法 和 API</p><ul><li>语法：如，规定了如何声明变量、如何声明常量、如何声明函数还规定了我们有哪些数据类型（基本数据类型，应用数据类型等 … 还有其他很多东西）</li><li>API：如，方法和函数（如数组的方法，对象，全局的 …）<br>从<code>2015</code>年开始<code>ECMA</code>组织决定每一年都会发布一个新的版本，这个新的版本就会包括：<code>ES</code>新特性，用于语法的升级或弥补之前一些语法的缺陷。<br>从命名上看，<code>ES6</code> 被命名为 <code>ECMAScript2015</code>，通过命名可以体现出当前这个版本所对应的年份。所以我们经常说的 <code>ES6</code> 和 <code>ES2015</code> 就指的是同一个版本，以后每一年发布的版本我们都会使用年份去命名。</li><li>按 ES 的命名方式：ES6 -&gt; ES7 -&gt; ES8 -&gt; ES9 -&gt; … &#x3D; 这些都可以统称为 ES6+</li><li>按年份的命名方式：ES2015 -&gt; ES2016 -&gt; ES2017 -&gt; ES2018 -&gt; …<img src="ECMAScript版本.png"></li></ul></blockquote></li></ol><blockquote><p>不论使用哪一种命名方式都是可以的，都不重要，只要我们清楚他们对应的方式就 OK 的</p><ul><li>比如 6 对应的 2015 ，7 对应的 2016 即可</li><li>当我们看到对应的文章或描述的时候能对应上，知道别人在讲什么就好</li><li>同时也需要知道 ES6 才是 ES6+的基础，如：ES7、ES8、ES9 本质都是在 ES6 的基础上扩展的语法或 API（升级或弥补之前一些语法的缺陷）</li><li>我们学习的重心还是要放在 ES6 上，不要本末倒置就好<br>每年的ES新版本都会引入很多新特性，如下<table><thead><tr><th>版本</th><th>发布时间</th><th>主要更新内容</th></tr></thead><tbody><tr><td>ES6（ES2015）</td><td>2015年</td><td>改动最多，具有里程碑意义；新增变量 let 和 const，箭头函数、新增数组方法，如：map、filter 等、解构赋值，快速复制数组和对象，模板字符串、模块化，面向对象，Promise 等</td></tr><tr><td>ES7（ES2016）</td><td>2016 年</td><td>数组扩展：<code>Array.prototype.includes()</code> ，幂运算符</td></tr><tr><td>ES8（ES2017）</td><td>2017 年</td><td>异步编程解决方案、新增 async、await、对象扩展：<code>Object.values()</code> ，<code>Object.entries()</code>、对象属性描述：<code>Object.getOwnPropertyDescriptors()</code>、字符串扩展：<code>String.prototype.padStart()</code>，<code>String.prototype.padEnd()</code>、尾逗号<code>Trailing commas</code></td></tr><tr><td>ES9（ES2018）</td><td>2018 年</td><td>异步迭代：<code>for await of</code>，<code>Symbol.asyncIterator</code>、正则表达式扩展：dotAll，具名组匹配，后行断言、对象扩展：Rest &amp; Spread、Promise 扩展：<code>Promise.prototype.finally()</code>、字符串扩展：放松模板字符串文字限制</td></tr><tr><td>ES10（ES2019）</td><td>2019 年</td><td>对象扩展：<code>Object.fromEntries()</code>、字符串扩展：<code>String.prototype.trimStart()</code> ，<code>String.prototype.trimEnd()</code>、数组扩展：<code>Array.prototype.flat()</code>，<code>Array.prototype.flatMap()</code>、修订 <code>Function.prototype.toString()</code>、可选的 Catch Binding：省略 catch 绑定的参数和括号、JSON 扩展：JSON superset，<code>JSON.stringify()</code>增强能力、Symbol 扩展：<code>Symbol.prototype.description</code></td></tr><tr><td>ES11（ES2020）</td><td>2020 年</td><td>全局模式捕获：<code>String.prototype.matchAll()</code>、动态&#x2F;按需导入：<code>Dynamic import()</code>、新的原始数据类型：BigInt、Promise 扩展：<code>Promise.allSettled()</code> ，<code>allSettled() vS all()</code>、全局对象：globalThis、可选链：Optional chaining、空值合并运算符：Nullish coalescing Operator</td></tr><tr><td>ES12（ES2021）</td><td>2021 年</td><td><code>String.prototype.replaceAll</code>：替换字符不用写正则了、<code>Promise.any()</code>、WeakRefs：使用弱引用对象、逻辑运算符和赋值表达式：&#96;</td></tr><tr><td>ES13（ES2022）</td><td>2022 年</td><td>Top-level Await（顶级 await）、Object.hasOwn()、at()、error.cause、正则表达式匹配索引、类 class：公共实例字段，私有实例字段，私有方法、静态公共字段、静态私有字段、静态私有方法，类静态块</td></tr></tbody></table></li></ul></blockquote><ol start="5"><li><p>ES6 之前的历史版本</p><blockquote><p>之前的版本中有 <code>ES1 ~ ES3</code>， <code>ES5 ~ ES6</code> 唯独跳过了 ES4，因为</p><ul><li>ES4 被废弃了 ，因为 ES4 是一次非常大胆的改革。但是因为太激进了，导致了 ES4 和 ES3 像两门截然不同的语言，跨度太大以至于被废弃了。</li><li>它的一些不太激进的部分被吸收进了 ES5</li><li>激进一些的被吸收进了 ES6</li><li>更激进一些就在后边的版本，接着吸收<br>ES1 和 ES2 都是比较原始的版本，都还不太成熟，真正成熟的是 ES3，我们现在用的最多其实就是 ES3，可能你以为我们用的 ES5 比较多，但在 ES6 之前你用的最多的还是 ES3 里边的内容<br>比如：我们现在用的最多的 ES3 中的内容</li><li>do while</li><li>switch</li><li>正则表达式</li><li>等等 … 一系列我们用得到的语法和 API<br>而我们感觉用的比较多的 ES5 如下方法反而用的不多，可能都没有用到过，当然这个跟我们关系不大，因为这是跟兼容性有关的，因为之前的 ES3 兼容性是非常好的，因此用的更多。</li><li>forEach</li><li>map</li><li>filter</li><li>Object.create</li><li>Object.defineProperty</li><li>等 …<table><thead><tr><th>版本</th><th>发布时间</th><th>主要内容</th></tr></thead><tbody><tr><td>ES1</td><td>1997年</td><td>制定了语言的基本语法</td></tr><tr><td>ES2</td><td>1998年</td><td>较小的改动，只改变编辑方式</td></tr><tr><td>ES3</td><td>1999年</td><td>引入正则表达式、异常处理try&#x2F;catch、格式化输出等，IE 开始支持</td></tr><tr><td>ES4</td><td>2007年</td><td>过于激进，未发布</td></tr><tr><td>ES5</td><td>2009年</td><td>引入严格模式、JSON，扩展对象、数组、原型、字符串、日期方法等</td></tr></tbody></table></li></ul></blockquote></li><li><p>ES、ES6 与 JavaScript 的关系</p><blockquote><ul><li>JavaScript（浏览器端）&#x3D; ECMAScript（语法+API）+ DOM（文档对象模型） + BOM（浏览器对象模型）</li><li>ES 等同于 ECMAScript ，是语言的标准，6 是版本号，即 ES6 &#x3D; ECMAScript 这门语言的第 6 代标准</li></ul></blockquote></li><li><p>ES6 的兼容性</p><blockquote><ul><li>主流浏览器的最新版几乎全部支持 ES6</li><li>IE 老版本等不支持的浏览器，可以用<code>Babel</code>转码</li><li>因此，放心大胆的使用 ES6 即可</li><li>兼容性检测查询地址：<code>http://kangax.github.io/compat-table/es6/</code></li></ul></blockquote></li><li><p>ES6 环境搭建</p><blockquote><p>目前各大浏览器基本上都支持 ES6 的新特性，其中 Chrome 和 Firefox 浏览器对 ES6 新特性最友好，IE7~11 不支持 ES6</p></blockquote></li></ol><blockquote><p><strong>如果浏览器不支持 ES 新的语法时，怎么办</strong><br>从 ES6、ES7、ES8、ES9、ES10、ES11、ES12、ES13 … 到未来更多新的语法<br>ES 每一年都会不断的更新，我们的目的是希望这些语法都能被浏览器所识别，但问题是这些新的语法并不能被所有的浏览器非常好的识别。<br>因为，我们的浏览器也是用代码写的，ES 这些新的语法之所以能被浏览器识别是因为浏览器的代码能够识别 ES 新的方法、函数、API 等。但并不是每一个浏览器厂商都会随着 ES 的更新而同步升级的。</p><ul><li>其中做的最好的是 Google 浏览器，因此强烈建议大家在进行前端开发的时候，首选 Google 浏览器，并进行调试。同时 Google 浏览器的调试功能也非常强大，我们可以很方便的定位问题或分析网页的性能等问题。</li><li>当 ES 新的语法不能被浏览器识别时，我们就会配置相应的工具来将 ES 新的语法转换成浏览器能够识别的代码。</li><li>我们都知道 ES5 是可以很好的被浏览器识别的，我们通过 <code>Babel</code>将ES6及最新版本的语法转换成ES5就能够被浏览器识别了。</li><li>一般<code>Babel</code>都会配合<code>Webpack</code>来一起使用。因此，我们先专注学完 <code>ES6+</code>相关语法后，再来学习<code>Webpack</code>和<code>Babel</code></li></ul></blockquote><h3 id="二、let-和-const"><a href="#二、let-和-const" class="headerlink" title="二、let 和 const"></a>二、let 和 const</h3><blockquote><p>ES6（ES2015）新增加了两个重要的 JavaScript 关键字: let 和 const。</p></blockquote><ol><li><p>什么是 let 和 const ？</p><blockquote><p>let 和 const 是用来声明变量或声明常量的，在 ES6 之前我们声明变量都是使用 var，在 ES6 中</p><ul><li><code>let</code>替代<code>var</code>，声明<strong>变量</strong></li><li><code>const</code> 声明<strong>常量</strong>，<code>constant</code>的缩写</li></ul></blockquote></li><li><p>let 和 const 的用法</p><blockquote><p>let 和 const 的用法与 var 一样</p></blockquote></li></ol><pre><code>var username = &quot;清心老师&quot;;let age = 18;const sex = &quot;female&quot;;console.log(username, age, sex); // 清心老师 18 female</code></pre><ol start="3"><li>什么是变量，什么是常量 ？<blockquote><ul><li><code>var</code>、<code>let</code> 声明的就是变量，变量一旦初始化之后，<strong>还可以重新赋值</strong></li><li><code>const</code> 声明的就是常量，常量一旦初始化，就<strong>不能重新赋值</strong>了，否则就会报错</li></ul></blockquote></li></ol><pre><code>var username = &quot;小明&quot;;username = &quot;小花&quot;;console.log(username); //小花&gt;let age = &quot;22&quot;;age = &quot;30&quot;;let arr1 = [1];arr1.push(2);console.log(age, arr1); //30  [1, 2]&gt;const arr2 = [&quot;A&quot;];arr2.push(&quot;B&quot;);console.log(arr2); //[&#39;A&#39;, &#39;B&#39;]const sex = &quot;男&quot;;sex = &quot;女&quot;; // 控制台报错 Uncaught TypeError: Assignment to constant variable. 错误意思：给常量赋值了console.log(sex);</code></pre><ol start="4"><li>const 的注意事项<blockquote><ul><li>使用 const 声明常量，一旦声明，就必须立即初始化，不能留到以后赋值</li></ul></blockquote></li></ol><pre><code>// 以下错误演示const sex; // Uncaught SyntaxError: Missing initializer in const declaration 未捕获语法错误：const声明中缺少初始值设定项sex = &#39;male&#39;;&gt;// 正确的做法是：声明+初始化应该一气呵成const sex = &#39;male&#39;;</code></pre><blockquote><ul><li>const 声明的常量，允许在不重新赋值的情况下修改它的值</li></ul></blockquote><ul><li>情况一：const 声明的是基本数据类型<blockquote><ul><li>对于基本数据类型来说，我们是没有办法在不重新赋值的情况下修改它的值</li></ul></blockquote></li></ul><pre><code>// 基本数据类型const sex = &quot;male&quot;;sex = &quot;female&quot;; // Uncaught TypeError: Assignment to constant variable.</code></pre><ul><li>情况二：const 声明的是引用数据类型<blockquote><ul><li><code>const</code>声明常量为引用类型，不可以重新赋值，但可以<strong>修改</strong>里面的值。</li></ul></blockquote></li></ul><pre><code>// 引用数据类型const person = &#123;username: &quot;清心&quot;&#125;;// 对person重新赋值，通过前边的学习，我们知道对于const声明的常量来说是不被允许的// person = &#123;&#125;; // 报错了 Uncaught TypeError: Assignment to constant variable.&gt;// 但，引用数据类型不一定要通过重新赋值的方式来修改值// 可以直接找到对应的属性，对它完成修改person.username = &quot;arry&quot;;console.log(person); // 正确输出修改后的对象 &#123;username: &#39;arry&#39;&#125;</code></pre><ol start="5"><li>为什么需要 const ？<blockquote><p><strong>思考：</strong></p><ul><li>我们为什么需要常量，难道不够用吗 ？</li><li>如果够用的话谁还用 const 呢 ？</li></ul></blockquote></li></ol><pre><code>// 假如只有let的情况，我们期望声明的 sex 值一旦声明后就是不变的。// 当然性别一般情况下就是不变的，也符合常识let sex = &quot;male&quot;;// ... 经历很多程序之后，如果不小心修改了 sex 的值，浏览器也不会报错sex = &quot;semale&quot;;console.log(sex); // semale&gt;// 我们可以看到 sex 的值被修改了，其实它按我们的期望来讲就是隐形一个错误// 也就是说这样的错误很可能发生，并没有任何提示，但它确实是一个错误，会造成我们的程序出现问题，类似这样的问题在过去么有什么很好的办法解决，只能通过开发者自己小心来定义</code></pre><blockquote><ul><li>但，const 的出现就不会有以上的问题了</li></ul></blockquote><pre><code>// 我们现在使用 const 将 sex 声明为常量const sex = &quot;male&quot;;// ... 如果不小心完成了以下赋值操作，就报错了sex = &quot;semale&quot;; // Uncaught TypeError: Assignment to constant variable.console.log(sex);</code></pre><blockquote><blockquote><p>使用 const 就直接从语法层面杜绝了类似错误的发生，我们在实际开发中也不需要为这些问题而小心翼翼了，这就是我们为什么需要 const 的原因。</p></blockquote><ul><li>const 的设计初衷：const 就是为了那些一旦初始化就不希望重新赋值的情况而设计的</li></ul></blockquote><ol start="6"><li>什么时候用 const ，什么时候用 let<blockquote><p>什么时候用 const 声明常量，什么时候用 let 声明变量，这个在实际开发中经常会困扰大家。之前我们只有一个 var 没得选，好处就是用就完了。</p><blockquote><p>那么，现在有得选了，到底使用 const 好呢 ？还是用 let 好呢 ？</p></blockquote></blockquote></li></ol><blockquote><ul><li>对于一些比较简单情况我们一眼能够看出进来的，就直接使用就好，没必要考虑什么 。如下下代码， 就直接用 let 就好</li></ul></blockquote><pre><code>for (let i = 0; i &lt; 5; i++) &#123;&#125;</code></pre><blockquote><ul><li>对于一些在刚开始写代码的时候，我们也不清楚到底是用 let 还是 const<blockquote><p><strong>实际开发中的经验总结</strong></p></blockquote></li><li>当你不知道用什么的时候，我们可以先用 <code>const</code> 来声明，即使不修改也不会报错，<strong>如果后边发生了修改。这时，也不用担心 ！因为程序会报错，再修改成 let 也是来得及的。</strong></li><li>只要错误不被淹没都可以随时修改。这样的好处就是，即使发生了错误也不会漏掉。</li><li>如果一开始就用 <code>let</code> ，不小心值就发生了改变，但这并不是我们希望发生的。</li><li>因此，推荐大家在实际开发中不知如何抉择时，可以使用这个的方式。</li></ul></blockquote><h3 id="三、let、const-和-var-的区别"><a href="#三、let、const-和-var-的区别" class="headerlink" title="三、let、const 和 var 的区别"></a>三、let、const 和 var 的区别</h3><blockquote><p>let、const 和 var 的区别总共有 6 点：</p><table><thead><tr><th>区别</th><th>说明</th></tr></thead><tbody><tr><td>用处不同</td><td>let用来替代var来声明变量,const用来声明常量；const声明的变量，必须在声明时完成赋值；</td></tr><tr><td>重复声明</td><td>在同一作用域下，var允许重复声明变量,let和const不允许重复声明变量和常量</td></tr><tr><td>变量提升</td><td>var存在变量提升,let和const不存在变量提升,所以let和const声明的变量必须要在声明后才能使用，否则就会报错</td></tr><tr><td>暂时性死区</td><td>只要作用域内存在let、const，他们所声明的变量或常量就自动<strong>绑定</strong>这个区域，不再受到外部作用域的影响；在当前作用域的let或const声明前操作对应变量或常量就会报错。var不存在暂时性死区</td></tr><tr><td>window对象关联</td><td>在全局作用域中var声明的变量会自动成为window对象的属性。而let和const声明的变量和常量与window不会有任何关联，但仍是全局变量，在任何位置都可以访问它</td></tr><tr><td>块级作用域</td><td>var不存在块级作用域。let和const声明的变量或常量会形成块级作用域，但形成块级作用域的前提是let或const必须在<code>&#123;&#125;</code>中。有两种情况不会形成作用域，一个是函数，一个是对象</td></tr></tbody></table></blockquote><blockquote><ul><li>不允许重复声明</li><li>不存在变量提升</li><li>暂时性死区</li><li>window 对象的属性和方法（全局作用域中）</li><li>块级作用域<br>其中<strong>块级作用域</strong>是 let、const 和 var 之间<strong>最重要</strong>的一个区别了。</li></ul><p>这也是我们面试真题中高频面试题了，能否真正给出有竞争力的回答，就看我们是否有真正的理解到位了。</p></blockquote><h4 id="不允许重复声明"><a href="#不允许重复声明" class="headerlink" title="不允许重复声明"></a>不允许重复声明</h4><blockquote><ul><li>重复声明：是指在同一作用域下已经存在的变量或常量，又声明了—遍</li><li>同一作用域下，var 允许重复声明，let、const 不允许</li></ul></blockquote><ol><li>场景一</li></ol><pre><code>// 如：使用var重复声明变量var i = 1;// ... 在写了很多行代码之后，突然忘记了之前有声明过a变量，又声明了一次var i = 2;console.log(i); // 2 ，这里最可气的是 控制台居然没有报错，还给我们修改了值&gt;// 如：使用 let 或 const 重复声明变量let n = 1;// ...let n = 2; // Uncaught SyntaxError: Identifier &#39;n&#39; has already been declared 已声明标识符 &quot;n&quot;console.log(n);&gt;// 使用 const 声明与 let 类似</code></pre><ol start="2"><li>场景二</li></ol><pre><code>// 声明一个函数（以函数参数的形式声明的变量）function foo(i) &#123;  let i = 2; // Uncaught SyntaxError: Identifier &#39;i&#39; has already been declared 已声明标识符 &quot;i&quot;&#125;foo();</code></pre><blockquote><blockquote><p>注：<br>以上 let 或 const 重复声明变量时，直接报错，会明确的告诉我们该变量已被声明了，不能再重复声明一遍。这样，就从语法层面直接杜绝了错误的发生。<br>我们可以看到，使用 let 和 const 声明都是类似的。因此在学习后边的区别学习中，就不单独把 const 拿出来讲了，let 已经可以代表了，let 和 const 的表现是一致的。</p></blockquote></blockquote><h4 id="不存在变量提升"><a href="#不存在变量提升" class="headerlink" title="不存在变量提升"></a>不存在变量提升</h4><blockquote><ul><li><code>var</code>命令会发生<strong>“变量提升”</strong>现象，即变量可以在声明之前使用，值为<code>undefined</code>。这种现象多多少少是有些奇怪的，按照一般的逻辑，变量应该在声明语句之后才可以使用。</li><li>为了纠正这种现象，<code>let</code>命令改变了语法行为，它所声明的变量<strong>一定要在声明后使用</strong>，否则报错。</li></ul></blockquote><ol><li>var 会提升变量的声明到当前作用域的顶部<blockquote><ul><li>不声明，直接使用：会报错</li></ul></blockquote></li></ol><pre><code>// 不声明变量，直接使用console.log(a); // Uncaught ReferenceError: a is not defined</code></pre><blockquote><ul><li>先输出，后声明：不会报错</li></ul></blockquote><pre><code>console.log(a); // undefinedvar a = 1;// 没有报错，输出了 undefined ，这就涉及到了变量提升&gt;// 以上代码通过变量提升后，实际的相当于如下步骤var a;console.log(a); // undefineda = 1;console.log(a); // 1&gt;// 其实变量提升带给我们更多的是困惑，因为它会和我们的想法和逻辑是不相符的，这也是我们学习JS需要记住的点</code></pre><ol start="2"><li>let、const 不存在变量提升</li></ol><pre><code>console.log(a); // Uncaught ReferenceError: Cannot access &#39;a&#39; before initialization 初始化之前无法访问 “a”let a = 1;</code></pre><blockquote><blockquote><p>总结</p></blockquote><ul><li><code>let</code> 和 <code>const</code> 之所以不存在变量提升，还是为了让我们养成良好的编程习惯。</li><li>对于所有的变量或常量，我们一定要做到<strong>先声明，后使用</strong></li></ul></blockquote><h4 id="暂时性死区"><a href="#暂时性死区" class="headerlink" title="暂时性死区"></a>暂时性死区</h4><blockquote><ul><li>只要作用域内存在<code>let</code>、<code>const</code> ，它们所声明的变量或常量就自动 “绑定” 这个区域，不再受到外部作用域的影响</li><li><code>let</code>、<code>const</code>存在暂时性死区，<code>var</code>不存在</li></ul></blockquote><pre><code>let a = 1;function foo() &#123;  console.log(a); // Uncaught ReferenceError: Cannot access &#39;a&#39; before initialization 初始化之前无法访问“a”  let a = 2;&#125;foo();&gt;// 以上代码存在全局变量 a ，但函数作用域内 let 又声明了一个局部变量 a ，导致后者绑定这个函数作用域// 所以在 let 声明变量前，输出 a 会报错</code></pre><blockquote><p><strong>ES6 明确规定</strong></p><ul><li>如果区块中存在 <code>let</code> 和 <code>const</code> 命令，则这个区块对这些命令声明的变量<strong>从一开始就形成封闭作用域</strong>。只要在声明之前就使用这些变量，就会报错。</li><li>总之，在代码块内，使用 <code>let</code> 命令声明变量之前，该变量都是不可用的。这在语法上称为 “暂时性死区” （temporal dead zone ，简称 <code>TDZ</code>）</li></ul></blockquote><ol><li>场景一</li></ol><pre><code>if (true) &#123;  // TDZ开始  tmp = &quot;abc&quot;; // ReferenceError  console.log(tmp); // ReferenceError&gt;  let tmp; // TDZ结束  console.log(tmp); // undefined&gt;  tmp = 123;  console.log(tmp); // 123&#125;&gt;// 上面代码中，在let命令声明变量tmp之前，都属于变量tmp的 “死区”</code></pre><ol start="2"><li>场景二<blockquote><ul><li>有些“死区”比较隐蔽，不太容易发现</li></ul></blockquote></li></ol><pre><code>function bar(x = y, y = 2) &#123;  return [x, y];&#125;&gt;bar(); // 报错bar(2, 3); // 不报错&gt;// 上面代码中，调用bar函数之所以报错，是因为参数x默认值等于另一个参数y，而此时y还没有声明，属于“死区”。// 如果y的默认值是x，就不会报错，因为此时x已经声明了。&gt;function bar(x = 2, y = x) &#123;  return [x, y];&#125;bar(); // [2, 2]</code></pre><ol start="3"><li>场景三<blockquote><ul><li>使用let&#x2F;const声明变量时，只要变量在<strong>还没有声明完成前</strong>使用，就会报错。</li></ul></blockquote></li></ol><pre><code>// 不报错var x = x;&gt;// 报错let x = x;// ReferenceError: x is not defined&gt;// 上面代码报错，也是因为暂时性死区。使用let声明变量时，只要变量在还没有声明完成前使用，就会报错。// 上面这行就属于这个情况，在变量x的声明语句还没有执行完成前，就去取x的值，导致报错&quot;x 未定义&quot;。</code></pre><blockquote><blockquote><p>注：</p></blockquote><ul><li>ES6 规定<strong>暂时性死区</strong>和let、const语句<strong>不出现变量提升</strong>，主要是<strong>为了减少运行时错误</strong>，防止在变量声明前就使用这个变量，从而导致意料之外的行为。这样的错误在 ES5 是很常见的，现在有了这种规定，避免此类错误就很容易了。</li><li>总之，let、const 存在暂时性死区，暂时性死区的本质是：在当前作用域，所要使用的变量已经存在，<strong>不会再访问该作用域以外的同名变量</strong>，并且<strong>只有在声明变量之后，才可以获取和使用该变量</strong>，否则就会报错。</li><li>同样，只要养成良好的编程习惯，对于所有的变量或常量，做到先声明，后使用就没有问题。</li></ul></blockquote><h4 id="window-对象的属性和方法"><a href="#window-对象的属性和方法" class="headerlink" title="window 对象的属性和方法"></a>window 对象的属性和方法</h4><blockquote><p>全局作用域中，<code>var</code> 声明的变量，通过 <code>function</code> 声明的函数，会自动变成<code>window</code> 对象的属性或方法</p></blockquote><pre><code>// 全局作用域中，var声明的变量，通过function声明的函数，会自动变成window对象的属性或方法var age = 20;function add() &#123;&#125;console.log(window.age);//20console.log(window.add === add);//true</code></pre><blockquote><p>全局作用域中，<code>let</code>、<code>const</code> 声明的变量 或 <code>function</code> 声明的函数，<strong>不会</strong>自动变成window 对象的属性或方法</p></blockquote><pre><code>// 全局作用域中，let、const 声明的变量 或 function声明的函数，不会自动变成window对象的属性或方法let age = 20;const add = function () &#123;&#125;;console.log(window.age); // undefinedconsole.log(window.add === add); // false</code></pre><h4 id="块级作用域"><a href="#块级作用域" class="headerlink" title="块级作用域"></a>块级作用域</h4><blockquote><p><code>let</code>、<code>const</code> 和 <code>var</code> <strong>最重要的区别</strong>即：是否拥有块级作用域。<br>在深入了解它们的区别前，我们需要了解一下，在 JavaScript 中有哪些作用域：</p><ul><li>全局作用域</li><li>函数作用域&#x2F;局部作用域</li><li>块级作用域（ES6 新增）</li></ul><p>上面是 <code>JavaScript</code> 中的三种作用域，那什<strong>么是作用域呢</strong> ？</p><ul><li>首先要明白的是：几乎所有的编程语言都存在在变量中储值的能力，存储完就需要使用这些值。所以，<strong>作用域就是一套规则，按照这套规则可以方便地去存储和访问变量。</strong><blockquote><p>在 ES5 中的作用域有全局作用域和函数作用域，而块级作用域是 ES6 的概念。</p></blockquote></li></ul></blockquote><ol><li>全局作用域<blockquote><p>全局作用域顾名思义，就是在任何地方都能访问到它，在浏览器中能通过 <code>window</code> 对象拿到的变量就是全局作用域下声明的变量</p></blockquote></li></ol><pre><code>var username = &quot;icoding&quot;;console.log(window.username); // icoding&gt;// 使用 var 定义的变量，可以在 window 对象上拿到此变量// 这里的 name 就是全局作用域下的变量</code></pre><ol start="2"><li>函数作用域<blockquote><ul><li>函数作用域，也称为局部作用域，所有写在函数内部的代码，就是在函数作用域中</li><li>声明在函数作用域中的变量为<strong>局部变量</strong>，从外层是无法直接访问函数内部的变量</li></ul></blockquote></li></ol><pre><code>function foo() &#123;  var username = &quot;icoding&quot;;&#125;console.log(username); // Uncaught ReferenceError: username is not defined</code></pre><blockquote><blockquote><p>在函数内部定义的 username 变量，在函数外部是访问不了的。要想在函数外部访问函数内部的变量可以通过 <code>return</code> 的方式返回出来。</p></blockquote></blockquote><ol start="3"><li>块级作用域（ES6 新增）<blockquote><p>块级作用域是 ES6 的概念，它的产生是要<strong>有一定的条件的</strong></p><ul><li>在花括号<code>&#123;&#125;</code>中，使用 <code>let</code> 或 <code>const</code> 声明的变量，才会产生块级作用域。<br><strong>这里需要注意的是</strong></li><li>块级作用域的<strong>产生</strong>是 <code>let</code> 或 <code>const</code> 带来的，而不是花括号，花括号的作用是限制 <code>let</code> 或 <code>const</code> 的<strong>作用域范围</strong>。</li><li>当不在大括号中声明时， <code>let </code>或 <code>const</code> 的作用域范围是<strong>全局，但是不在 window 对象身上</strong></li></ul></blockquote></li></ol><blockquote><ul><li>在使用 var 声明的情况下，可以看出，外层的 age 会被 {} 中的 age 覆盖，所以没有块级作用域的概念</li></ul></blockquote><pre><code>// var声明的变量，不会产生块级作用域var age = 18;&#123;  var age = 20;  console.log(age); // 20&#125;console.log(age); // 20</code></pre><blockquote><ul><li>使用 <code>let</code> 方式声明时，<code>&#123;&#125;</code>内外是互不干涉和影响的，如果在声明<code>age</code>的前面进行打印的话，还会报错，这个时候，<code>age</code> 处于暂存死区，是不能被使用的，</li></ul></blockquote><pre><code>let age = 18;&#123;  console.log(age); // Uncaught ReferenceError: Cannot access &#39;age&#39; before initialization  let age = 20;  console.log(age); // 20&#125;console.log(age); // 18</code></pre><blockquote><ul><li>在低版本浏览器中不支持 ES6 语法，通常需要把 ES6 语法转换成 ES5，使用 babel 把上面的代码转换后得到如下结果：</li></ul></blockquote><pre><code>var age = 18;&#123;  console.log(_age); // undefined  var _age = 20;  console.log(_age); // 20&#125;console.log(age); // 18</code></pre><blockquote><blockquote><p>从上面的代码中可以看出：<br>虽然在 ES6 语法使用的是相同的变量名字，但是底层JS进行编译时会认为他们是不同的变量。也就是说即使花括号中声明的变量和外面的变量是相同的名字，但是在编译过程它们是<strong>没有关系</strong>的。</p></blockquote></blockquote><ul><li>ES6 允许块级作用域的任意嵌套</li></ul><pre><code>&#123;  &#123;    &#123;      &#123;        let username = &quot;icoding&quot;;        &#123;          let username = &quot;icoding&quot;;        &#125;      &#125;    &#125;  &#125;&#125;</code></pre><blockquote><ul><li>上面代码使用了一个五层的块级作用域，每一层都是一个单独的作用域。第四层作用域无法读取第五层作用域的内部变量。</li><li>所以，内层作用域可以定义外层作用域的同名变量。</li></ul></blockquote><blockquote><ul><li>块级作用域的出现，实际上使得获得广泛应用的<strong>匿名立即执行函数表达式（匿名 IIFE）不再必要了</strong>。以前我们想要将某个全局变量变成私有的，我们会用 IIFE 来实现，现在有了块级作用域，我们只需要用块级作用域来解决就好。</li></ul></blockquote><pre><code>// IIFE 写法(function () &#123;  var age = ...;  ...&#125;());&gt;// 块级作用域写法&#123;  let age = ...;  ...&#125;</code></pre><ol start="4"><li>为什么需要块级作用域 ？<blockquote><p>我们通过之前的学习知道，ES5 只有全局作用域和函数作用域，没有块级作用域，这带来很多不合理的场景。所以在 ES6 中新增了块级作用域。</p></blockquote></li></ol><ul><li>第一种不合理场景： 内层变量可能会覆盖外层变量</li></ul><pre><code>var atmp = 2;&gt;function foo() &#123;  console.log(atmp);  if (false) &#123;    var atmp = &quot;hello world&quot;;  &#125;&#125;&gt;foo(); // undefined&gt;// 上面代码的原意是，if代码块的外部使用外层的atmp变量，内部使用内层的atmp变量。// 但是，函数foo执行后，输出结果为undefined，原因在于变量提升，导致内层的atmp变量覆盖了外层的atmp变量。</code></pre><blockquote><ul><li>let 和 const 有块级作用域，就可以避免这种问题产生<blockquote><p>if里面是一个块级作用域</p></blockquote></li></ul></blockquote><pre><code>let atmp = 2;function foo() &#123;  console.log(atmp);  if (false) &#123;    let atmp = &quot;hello world&quot;;  &#125;&#125;foo(); // 2</code></pre><ul><li>第二种不合理场景： 用来计数的循环变量泄露为全局变量</li></ul><pre><code>for (var i = 0; i &lt; 2; i++) &#123;  console.log(&quot;循环内：&quot; + i);&#125;console.log(&quot;循环外：&quot; + i); // 2&gt;// 上面代码中，变量i只用来控制循环，但是循环结束后，它并没有消失，泄露成了全局变量。</code></pre><blockquote><ul><li>let 和 const 有块级作用域，就可以必免这种问题产生</li></ul></blockquote><pre><code>for (let i = 0; i &lt; 2; i++) &#123;  console.log(&quot;循环内：&quot; + i);&#125;console.log(&quot;循环外：&quot; + i); // Uncaught ReferenceError: i is not defined&gt;// 之所以会报错，是因为使用 let 或 const 声明的变量是有块级作用域的</code></pre><blockquote><ul><li><code>let</code>声明的 <code>i</code> 和 <code>for()&#123;&#125;</code> 共同构成了块级作用域，因此在块级作用域内定义的变量 <code>i</code> 只能在for的<code>&#123;&#125;</code>内可访问</li><li>执行完<code>for</code>循环后，该作用域就销毁了，我们在全局作用域中就找不到<code>i</code>，就报错了</li></ul></blockquote><ol start="5"><li>深入理解块级作用域<blockquote><p>很多人对于<code>for(let i=0; i&lt;5; i++)&#123; &#125;</code>这里不理解，不理解为什么外面就访问不到 i 了。我们说这是 es6 的语法规定的，let 可以形成块级作用域。</p><ul><li>那如果没有 es6，那我们要实现相同的功能，用 es5 如何模拟呢 ？</li></ul></blockquote></li></ol><pre><code>// es6版本for (let i = 0; i &lt; 5; i++) &#123;  console.log(i);&#125;console.log(i);&gt;// babel转换成对应的es5版本(&quot;use strict&quot;);&gt;for (var _i = 0; _i &lt; 5; _i++) &#123;  console.log(_i);&#125;console.log(i);</code></pre><blockquote><ul><li>很多人对于<code>for(let i=0; i&lt;5; i++)&#123; &#125;</code><strong>每次迭代都会创建一个新的块级作用域</strong>不太理解，这里我们将 es6 的语法代码用 babel 转换成 es5 的语法来看下</li></ul></blockquote><pre><code>// es6版本 for 循环一共创建了5个块级作用域for (let i = 0; i &lt; 5; i++) &#123;  setTimeout(function () &#123;    console.log(i);  &#125;, 1000);&#125;console.log(i);&gt;// babel转换成对应的es5版本(&quot;use strict&quot;);&gt;var _loop = function _loop(i) &#123;  setTimeout(function () &#123;    console.log(i);  &#125;, 1000);&#125;;for (var _i = 0; _i &lt; 5; _i++) &#123;  _loop(_i);&#125;console.log(i);</code></pre><ol start="6"><li>作用域链的复习<blockquote><p>关于变量的查找会涉及到作用域链，我们再次来复习一下</p></blockquote></li></ol><pre><code>function foo() &#123;  // 函数作用域  for (let i = 0; i &lt; 2; i++) &#123;    console.log(i); // 0 1    // 块级作用域  &#125;  console.log(i); // Uncaught ReferenceError: i is not defined&#125;&gt;// 全局作用域&gt;foo();console.log(i); // Uncaught ReferenceError: i is not defined</code></pre><img src="复习作用域链.png"><blockquote><p><strong>代码解读</strong></p><ul><li>首先最外层会有一个<strong>全局作用域</strong></li><li>当函数 <code>foo()</code> 被调用时，会形成一个<strong>函数作用域</strong>，注：<strong>只有当函数被调用时</strong>，才会形成函数作用域，函数调用结束函数作用域就销毁</li><li>继续执行<code>for</code>循环，<code>for()&#123;&#125;</code>和<code>let</code>共同构成了一个<strong>块级作用域</strong></li><li>这时，我们就有了一个嵌套的三层的作用域，最内层是块级作用域，外层是函数作用域，最外层是全局作用域</li><li>当在<code>for</code>循环中打印输出<code>i</code> ，首先会在当前的块级作用域中去查找是否存在<code>i</code>如果找到了就输出，如果查找到<code>i</code>不存在，那就往上一层作用域中查找或向外层作用域中查找（即<code>foo</code>函数构成的函数作用域中查找），如果还没有，就继续往外层查找（到全局作用域中查找 <code>i</code>）如果还是找不到就报错了，这时就终止了</li><li>这样的过程就构成了一个链条的形式，由<strong>内层 -&gt; 到外层 -&gt; 一直到最外层</strong>，这些作用域的节点和节点之间就构成了一个链条，这就是变量或常量的查找的一个链条。</li><li>首先在当前作用域中找，找到了就不会再找了，就跟外层作用域没关系了，如果找不到就会往外找，一直找到最外层，找到全局作用域中才截止。</li><li>因此，<code>for</code> 循环中找到了块级作用域中 <code>i</code> 就输出 <code>0 1</code> 就不会往外层查找了</li><li>在函数作用域中打印输出 <code>i</code> 依次往外层查找，发现没有找到 <code>i</code> 就报错了，这时程序就终止了</li><li>如果，前边都没有报错，当 <code>foo()</code> 函数执行完毕后，最后在全局作用域中打印输出 <code>i </code>同样也会报错</li><li>要注意：变量的查找<strong>只能由内往外</strong>，不能由外往内查找</li></ul><p><strong>总结</strong></p><ul><li>作用域链的流程：内层（块级）作用域 -&gt; 外层（函数）作用域 -&gt; … -&gt; 全局作用域<blockquote><p>我们是以这样的顺序去查找变量或常量的，当然也不会一直查下去，一但找到就终止了</p></blockquote></li></ul></blockquote><ol start="7"><li>ES6 中有哪些块级作用域<blockquote><ul><li><strong>大部分</strong>具有花括号<code>&#123;&#125;</code>的结构，都可以构成块级作用域</li></ul></blockquote></li></ol><pre><code>&#123;  let age = 20;  console.log(age); // 20&#125;console.log(age); // Uncaught ReferenceError: age is not defined</code></pre><blockquote><ul><li>报错原因：<code>&#123;&#125;</code>花括号就是一个块级作用域， 它执行完毕之后就会被销毁</li></ul></blockquote><blockquote><ul><li>还具有<code>&#123;&#125;</code>块级作用域的结构，如：<code>&#123;&#125;</code>、<code>for()&#123;&#125;</code>、<code>while()&#123;&#125;</code>、<code>do&#123;&#125;while()</code>、<code>if()&#123;&#125;</code>、<code>switch()&#123;&#125;</code></li><li>其中 <code>function()&#123;&#125;</code> 也有<code>&#123;&#125;</code> 但属于函数作用域，<strong>不属于块级作用域</strong></li><li>另外，还有对象也有 <code>&#123;&#125;</code> 如：<code>const person = &#123;&#125;</code>。注：<strong>对象是不构成任何作用域的</strong>，我们知道 <code>JavaScript</code> 的作用域就 3 个，块级作用域、函数作用域、全局作用域<blockquote><p>注：以上这些结构<strong>只有和 let、const 配合使用</strong>才会有块级作用域，<code>var</code> 是没有块级作用域的。</p></blockquote></li></ul></blockquote><blockquote><blockquote><p>总结：</p></blockquote><ul><li>块级作用域是<code>ES6</code>中新增的一个作用域，指在花括号<code>&#123;&#125;</code>里面使用 <code>let</code> 或 <code>const</code> 关键字声明变量或常量，就会形成一个块级作用域。</li><li>但有两个需要特殊记忆，<strong>函数</strong>和<strong>对象</strong>的花括号<code>&#123;&#125;</code>不属于块级作用域。</li></ul></blockquote><h3 id="四、let、const-在实际开发中的应用"><a href="#四、let、const-在实际开发中的应用" class="headerlink" title="四、let、const 在实际开发中的应用"></a>四、let、const 在实际开发中的应用</h3><blockquote><p>应用实现需求：</p><ul><li>有 3 个按钮，点击 0 号按钮打印索引值为 0，点击 1 号按钮打印索引值为 1，点击 2 号按钮打印索引值为 2</li></ul></blockquote><h4 id="在-ES6-之前使用-var-如何实现"><a href="#在-ES6-之前使用-var-如何实现" class="headerlink" title="在 ES6 之前使用 var 如何实现"></a>在 ES6 之前使用 var 如何实现</h4><ol><li>实现方式一</li></ol><pre><code>&gt;&lt;style&gt;  .btn &#123;    width: 50px;    height: 50px;    font-size: 30px;  &#125;&gt;&lt;/style&gt;&gt;&gt;&lt;button class=&quot;btn&quot;&gt;0&lt;/button&gt;&gt;&lt;button class=&quot;btn&quot;&gt;1&lt;/button&gt;&gt;&lt;button class=&quot;btn&quot;&gt;2&lt;/button&gt;&gt;&lt;script&gt;  var btns = document.querySelectorAll(&quot;.btn&quot;);  for (var i = 0; i &lt; btns.length; i++) &#123;    btns[i].onclick = function () &#123;      console.log(i);    &#125;;  &#125;&gt;&lt;/script&gt;</code></pre><blockquote><ul><li>运行以上程序，分别点击 0，1，2 三个按钮都会输出 <code>3</code> ，而不是按我们想象的 0，1，2 来输出</li><li>因为点击事件发生时，函数作用域内找不到i，就会往外找；i是在全局作用域下声明的变量，在for循环结束后，在全局作用域下i&#x3D;3；</li></ul></blockquote><ol start="2"><li>在 ES6 之前，我们该如何解决这个问题 ？<blockquote><ul><li>利用立即执行函数，形成闭包</li></ul></blockquote></li></ol><pre><code>&gt;&lt;script&gt;  var btns = document.querySelectorAll(&quot;.btn&quot;);  for (var i = 0; i &lt; btns.length; i++) &#123;    (function (index) &#123;      btns[index].onclick = function () &#123;        console.log(index);      &#125;;    &#125;)(i);  &#125;&gt;&lt;/script&gt;</code></pre><blockquote><ul><li>运行以上代码，分别点击 0，1，2 三个按钮会正确输出 0，1，2</li></ul></blockquote><blockquote><p><strong>代码分析</strong></p><ul><li>首先我们可以看到声明的<strong>立即执行函数</strong>会在 for 循环中循环执行 3 次</li><li>for 循环中的 var 声明的变量 i 是全局变量，当循环 3 次后 i 在全局作用域中 依然还是 i &#x3D; 3</li><li>当 for 循环 3 次，其中的立即执行的匿名函数<code>(function(index)&#123; ... &#125;)(i)</code>; 就调用了 3 遍，调用函数就会创建函数作用域，这样就会创建 3 个函数作用域。并且<strong>每一个</strong>函数作用域中就会有一个 <code>index</code></li><li>当点击 0，1，2 三个按钮时，就会调用事件处理函数对应的内部 <code>function()&#123;console.log(index);&#125;</code> 函数，这时就会形成自己的函数作用域</li><li>开始打印输出 <code>console.log(index);</code> 这是就会一层层的往外找，找到立即执行匿名函数作用域中的<code>index</code> 找到了，就打印输出 0，1，2 ，这时候就<strong>不会</strong>再到外层全局作用域中去找 i &#x3D; 3了</li><li>这时候，你会发现这里的实现方式和第一种方式都是通过<strong>作用域链</strong>的查找机制来查找变量，但<strong>唯一的区别在于</strong>，这里通过 <code>IIFE</code>立即执行函数形成了闭包，将全局变量转换为了局部变量来实现。</li></ul></blockquote><h4 id="ES6出现后"><a href="#ES6出现后" class="headerlink" title="ES6出现后"></a>ES6出现后</h4><blockquote><ul><li>使用 ES6 中的 let、const 完成此需求</li></ul></blockquote><pre><code>&gt;&lt;script&gt;  var btns = document.querySelectorAll(&quot;.btn&quot;);  //es6  for (let i = 0; i &lt; btns.length; i++) &#123;    btns[i].onclick = function () &#123;      console.log(i);    &#125;;  &#125;&gt;&lt;/script&gt;</code></pre><blockquote><p><strong>代码分析</strong></p><ul><li>let与<code>&#123;&#125;</code>结合形成块级作用域，for循环三次，就形成了三个块级作用域；</li><li>此时，i是块级作用域下的一个变量，每个块级作用域保存了不同的i；</li><li>当点击事件触发时，就会调用事件处理函数，<code>console.log(i);</code>先在当前函数作用域找，没有找到，就往外找，直到找到块级作用域中的局部变量i；</li></ul></blockquote><h3 id="测试题"><a href="#测试题" class="headerlink" title="测试题"></a>测试题</h3><ol><li><p>关于以下描述正确的选项是 ？<br>A、let 是替代 var 用来声明变量的关键字<br>B、const 是替代 var 用来声明常量的关键字<br>C、变量声明之后，可以重新赋值<br>D、常量声明之后，不可以被重新赋值</p><blockquote><ul><li>B选项错误：var没有声明常量的功能，所以不能称为替代</li></ul></blockquote></li><li><p>const的值一定是不能改变的吗</p><blockquote><ul><li>const声明的常量不能被重新赋值，但如果其保存的是一个引用数据类型，在不重新赋值(不修改保存在堆内存中的地址)的前提下，是可以修改它的值的</li></ul></blockquote></li></ol><h2 id="Symbol、BigInt、模板字符串的应用场景和底层原理"><a href="#Symbol、BigInt、模板字符串的应用场景和底层原理" class="headerlink" title="Symbol、BigInt、模板字符串的应用场景和底层原理"></a>Symbol、BigInt、模板字符串的应用场景和底层原理</h2><h3 id="一、原始数据类型-Symbol"><a href="#一、原始数据类型-Symbol" class="headerlink" title="一、原始数据类型 Symbol"></a>一、原始数据类型 Symbol</h3><blockquote><p>ES5 的对象属性名都是字符串，这容易造成<strong>属性名的冲突</strong>。比如，你使用了一个他人提供的对象，但又想为这个对象添加新的方法（mixin 模式），新方法的名字就有可能与现有方法产生冲突。<br>如果有一种机制，能保证每个属性的名字都是独一无二的就好了，这样就从根本上防止属性名的冲突。</p><blockquote><p>这就是 ES6 引入Symbol的原因。</p></blockquote></blockquote><h4 id="什么是-Symbol-？"><a href="#什么是-Symbol-？" class="headerlink" title="什么是 Symbol ？"></a>什么是 Symbol ？</h4><blockquote><p><code>Symbol</code>（符号、象征） 是 <code>ES6</code> 中引入的一种新的基本（原始）数据类型，用于表示一个独一无二的值。它是 <code>JavaScript</code> 中的第七种数据类型，与 <code>undefined</code>、<code>null</code>、<code>Number</code>（数值）、<code>String</code>（字符串）、<code>Boolean</code>（布尔值）、<code>Object</code>（对象）并列。</p><ul><li>创建一个 Symbol 值的方式如下：</li></ul></blockquote><pre><code>&gt;const s=Symbol();&gt;console.log(s);//Symbol();&gt;console.log(typeof s);//Symbol</code></pre><blockquote><ul><li><code>Symbol</code>值通过<code>Symbol()</code>函数生成，上面代码中，变量s就是一个<strong>独一无二</strong>的值。</li><li><code>typeof</code>运算符的结果，表明变量s是<code>Symbol</code>数据类型，而不是字符串之类的其他类型。</li></ul></blockquote><h4 id="Symbol-的语法规范"><a href="#Symbol-的语法规范" class="headerlink" title="Symbol 的语法规范"></a>Symbol 的语法规范</h4><ol><li>方式一：<blockquote><ul><li>通过上边的学习，使用以下语法可创建一个 Symbol 变量</li></ul></blockquote></li></ol><pre><code>let s = Symbol();console.log(s); // Symbol()</code></pre><blockquote><ul><li>我们说 <code>Symbol()</code> 生成的是一个独一无二的值，所以如果用 <code>Symbol()</code> 创建多个 <code>Symbol</code> 值时，即使他们长的完全一样，但是值是不相同的。</li></ul></blockquote><pre><code>let s = Symbol();let m = Symbol();&gt;console.log(s); // Symbol()console.log(m); // Symbol()&gt;console.log(s === m); // false</code></pre><blockquote><ul><li>通过以上代码可知，虽然它们在控制台的输出是一样的，但变量 s 和变量 m 并不是同一个值</li></ul></blockquote><ol start="2"><li>方式二：<blockquote><p>以上的方式不利于我们区分两个变量，同时我们也不知道 Symbol 象征或代表的是什么 ？</p><ul><li>为此，我们可以在调用<code>Symbol</code>的时候传入一个<strong>字符串</strong>作为对当前<code>Symbol</code>变量的<strong>描述</strong></li></ul></blockquote></li></ol><pre><code>let s = Symbol(&quot;color&quot;);let m = Symbol(&quot;message&quot;);&gt;console.log(s); // Symbol(color)console.log(m); // Symbol(message)</code></pre><blockquote><ul><li>不过还是要特别注意，即使Symbol 的变量的描述是一样的，也是两个不同的值</li></ul></blockquote><pre><code>const s = Symbol(&quot;a&quot;);const m = Symbol(&quot;a&quot;);console.log(s);console.log(m);console.log(s === m);</code></pre><blockquote><ul><li>Symbol 的描述符，如果传入的不是字符串类型，则会转换为对应的字符串</li></ul></blockquote><pre><code>let s1 = Symbol(&quot;abc&quot;);let s2 = Symbol(111);let s3 = Symbol([1, 2, 3]);let s4 = Symbol(&#123;&#125;);console.log(s1, s2, s3, s4);//Symbol(abc) Symbol(111) Symbol(1,2,3) Symbol([object Object])</code></pre><blockquote><ul><li>注意：<code>Symbol</code>是基本数据类型，调用<code>Symbol</code>时不可以使用 <code>new</code>关键字</li></ul></blockquote><pre><code>const b = new Symbol(); // 报错 Symbol is not a constructor ，Symbol 不是构造函数</code></pre><h4 id="Symbol-for"><a href="#Symbol-for" class="headerlink" title="Symbol.for()"></a><code>Symbol.for()</code></h4><blockquote><ul><li>有时，我们希望重新使用<strong>同一个</strong><code>Symbol</code>值，<code>Symbol.for()</code>方法可以做到这一点。</li><li><code>Symbol</code>提供的一种可以创建相同 <code>Symbol</code> 的机制，就是使用 <code>Symbol.for()</code>方法进行注册。</li><li>当我们使用<code>Symbol.for()</code>来创建 <code>Symbol</code> 值时，首先会在<strong>全局环境中</strong>搜索，检测给定的 <code>key</code>（描述符）是否已存在<ul><li>如果<strong>不存在</strong>才会创建一个新的<code>Symbol</code>值，并且会在全局环境中登记。</li><li>如果<strong>已存在</strong>，则会使用已存在的 <code>Symbol </code>值。</li></ul></li><li><strong>不管<code>Symbol.for()</code>在哪里调用，最后都会登记注册在全局环境中</strong></li></ul></blockquote><pre><code>function fn() &#123;  const s1 = Symbol.for(&quot;color&quot;);  return s1;&#125;const s1 = fn();const s2 = Symbol.for(&quot;color&quot;);console.log(s1 === s2); //true</code></pre><h4 id="Symbol-keyFor"><a href="#Symbol-keyFor" class="headerlink" title="Symbol.keyFor()"></a><code>Symbol.keyFor()</code></h4><blockquote><ul><li><code>Symbol.keyFor()</code>返回一个<strong>全局注册</strong>的<code>Symbol</code>的描述符</li></ul></blockquote><pre><code>let s = Symbol.for(&quot;icoding&quot;);let m = Symbol.keyFor(s);console.log(m); // icoding&gt;const m = Symbol(color);const k = Symbol.keyFor(m); //报错 color is not definedconsole.log(k);</code></pre><blockquote><ul><li>只有在全局作用域下注册过的<code>Symbol</code>描述符才能被找到，否则就会报错</li></ul></blockquote><h4 id="Symbol-与基本数据类型转换"><a href="#Symbol-与基本数据类型转换" class="headerlink" title="Symbol 与基本数据类型转换"></a>Symbol 与基本数据类型转换</h4><blockquote><ul><li>Symbol 不能转成数字</li><li>使用 Number 对 Symbol 值转换会报错</li></ul></blockquote><pre><code>const s = Symbol(&quot;123&quot;);console.log(Number(s)); // Cannot convert a Symbol value to a number</code></pre><blockquote><ul><li>Symbol 可以转成 布尔值 和 字符串</li></ul></blockquote><pre><code>let s = Symbol(&quot;123&quot;);console.log(typeof s); // symbol&gt;let str = String(s);console.log(str); // Symbol(123)console.log(typeof str); // string&gt;let bool = Boolean(s);console.log(bool); // trueconsole.log(typeof bool); // boolean</code></pre><h4 id="Symbol-属性的遍历"><a href="#Symbol-属性的遍历" class="headerlink" title="Symbol 属性的遍历"></a>Symbol 属性的遍历</h4><blockquote><ul><li>以<code>Symbol</code>类型的变量作为<strong>对象属性</strong>时，该属性不会出现在 <code>for … in</code>、<code>for … of</code>循环中（后面会讲解<code>for…of</code>循环的）。也不会被<code>Object.keys()</code>、<code>Object.getOwnPropertyNames()</code>返回。</li><li>我们可以通过<code>Object.getOwnPropertySymbols()</code>方法返回一个数组，成员是当前对象的<strong>所有</strong>用作<strong>属性名</strong>的 <code>Symbol</code> 值。</li><li>如果想要一次性获取到<strong>对象自身的所有属性</strong>，可以利用<code>Reflect.ownKeys(obj)</code>，但原型上的获取不到</li></ul></blockquote><pre><code> let s = Symbol(&quot;ss&quot;); let m = Symbol(&quot;mm&quot;); // 由于 s 和 m 是变量，而不是字符串，因此需要使用中括号括起来（否则它会被当做字符串使用） let obj = &#123;   username: &quot;icoding&quot;,   [s]: 18,   [m]: function () &#123;&#125;, &#125;;&gt; // for ... in 循环遍历 obj for (key in obj) &#123;   console.log(key); //username &#125;&gt; // getOwnPropertySymbols()方法 const arr1 = Object.getOwnPropertySymbols(obj); console.log(arr1); //[Symbol(ss), Symbol(mm)]&gt; // Reflect.ownKeys()方法 const arr2 = Reflect.ownKeys(obj); console.log(arr2); // [&#39;username&#39;, Symbol(ss), Symbol(mm)]</code></pre><h4 id="Symbol-的应用"><a href="#Symbol-的应用" class="headerlink" title="Symbol 的应用"></a>Symbol 的应用</h4><blockquote><p>因为 Symbol 产生的是独一无二的值，所以我们可以利用这个特性解决以下<strong>三大问题</strong></p><ul><li>消除对象同名属性之间覆盖问题</li><li>使对象的属性不能单独访问</li><li>消除魔术字符串</li></ul></blockquote><ol><li>消除对象同名属性之间覆盖问题<blockquote><ul><li>由于每一个<code>Symbol</code>值都是不相等的，这意味着<code>Symbol</code>值可以作为标识符，用于对象的属性名，就能<strong>保证不会出现同名的属性</strong>。</li><li>如果我们对一个对象身上有哪些属性不清楚，但我们想再给对象添加一个新属性时，有可能新属性名与对象原有的属性名相同，而造成同名属性的覆盖，如果用 <code>Symbol</code> 就可以解决这个问题。</li></ul></blockquote></li></ol><pre><code>// addMethod方法为obj对象添加某个属性，属性值为fnfunction addMethod(obj, fn) &#123;  // ....  // 为对象obj添加了唯一的属性s  const s = Symbol(&quot;color&quot;);  obj[s] = fn;&#125;</code></pre><blockquote><blockquote><p>注意：使用 Symbol 作为对象属性时，需要使用<strong>方括号</strong>语法去访问对应的属性，而不是字符串。</p></blockquote></blockquote><ol start="2"><li>使对象的属性不能单独对外访问<blockquote><p>以<code>Symbol</code>值作为对象的属性名不会被常规的方法遍历得到，所以我们可以利用这个特性为对象定义一组非私有属性，但这些属性又希望<strong>只用于内部方法</strong>的效果。</p></blockquote></li></ol><ul><li>用ES5的方式模拟私有变量<blockquote><ul><li>利用闭包</li></ul></blockquote></li></ul><pre><code>const Person = (function () &#123;  var m = Symbol(&quot;m&quot;);  function Person() &#123;    this[m] = 100; //  &#125;  Person.prototype.getM = function () &#123;    return this[m];  &#125;;  return Person;&#125;)();&gt;const p = new Person();console.log(p.getM());</code></pre><ul><li>在ES6里配合模块化实现</li></ul><pre><code>// person.jsconst m = Symbol(&quot;m&quot;);export default class Person &#123;  constructor(name) &#123;    this.name = name;    this[m] = 100;  &#125;  getM() &#123;    return this[m];  &#125;&#125;// export &#123; Person &#125;;&gt;// index.html  页面导入模块import Person from &quot;./person.js&quot;;const p = new Person(&quot;icoding&quot;);console.log(p.getM());for (let key in p) &#123;  console.log(key);&#125;</code></pre><ol start="3"><li>消除魔术字符串<blockquote><ul><li>魔术字符串是指：在代码之中<strong>出现多次</strong>、与代码形成<strong>强耦合</strong>的某一个具体的字符串或数值。</li><li>风格良好的代码，应该尽量消除魔术字符串，而由含义清晰的变量代替</li></ul></blockquote></li></ol><blockquote><ul><li>如果我们要计算不同形状的面积，我们可以写下面这个方法来实现</li></ul></blockquote><pre><code>function getArea(shape, options) &#123;  let area = 0; // 保存最终计算得到的面积  switch (shape) &#123;    case &quot;rectangle&quot;: // 魔术字符串      area = options.width * options.height;      break;    case &quot;triangle&quot;: // 魔术字符串      area = (options.width * options.height) / 2;      break;    case &quot;circle&quot;: // 魔术字符串      area = Math.PI * options.radius * options.radius;      break;  &#125;  return area;&#125;&gt;getArea(&quot;rectangle&quot;, &#123; width: 100, height: 100 &#125;);</code></pre><blockquote><ul><li>以上代码中的字符串 <code>&quot;rectangle&quot;</code>、<code>“triangle”</code>、<code>&quot;circle&quot;</code>就是魔术字符串，它多次出现，与代码形成强耦合，不利于将来的修改和维护。</li></ul></blockquote><blockquote><ul><li>常用来消除魔术字符串的方法，就是把它<strong>写成一个变量</strong>。我们定义一个<strong>对象</strong></li></ul></blockquote><pre><code>let shapeType = &#123;  rectangle: &quot;rectangle&quot;,  triangle: &quot;triangle&quot;,  circle: &quot;circle&quot;,&#125;;</code></pre><blockquote><ul><li>然后我再把代码中的魔术字符串改成 shapeType 的属性值</li></ul></blockquote><pre><code>// 计算图形的面积function getArea(shape, options) &#123;  let area = 0; // 保存最终计算得到的面积  switch (shape) &#123;    case shapeType.rectangle: // 魔术字符串      area = options.width * options.height;      break;    case shapeType.triangle: // 魔术字符串      area = (options.width * options.height) / 2;      break;    case shapeType.circle: // 魔术字符串      area = 2 * Math.PI * options.radius;      break;  &#125;  return area;&#125;&gt;getArea(shapeType.rectangle, &#123; width: 100, height: 100 &#125;);</code></pre><blockquote><ul><li>我们知道，其实 <code>shapeType</code> 中每个属性对应的值是多少，根本不重要，只要保存这些属性的值都是<strong>唯一的就行</strong>（与其它属性值不相同），所以我们可以把他们的值改成 <code>Symbol()</code></li></ul></blockquote><pre><code>// 完整版代码&gt;let shapeType = &#123;  rectangle: Symbol(),  triangle: Symbol(),  circle: Symbol(),&#125;;&gt;// 计算图形的面积function getArea(shape, options) &#123;  let area = 0; // 保存最终计算得到的面积  switch (shape) &#123;    case shapeType.rectangle: // 魔术字符串      area = options.width * options.height;      break;    case shapeType.triangle: // 魔术字符串      area = (options.width * options.height) / 2;      break;    case shapeType.circle: // 魔术字符串      area = 2 * Math.PI * options.radius;      break;  &#125;  return area;&#125;&gt;console.log(getArea(shapeType.rectangle, &#123; width: 100, height: 100 &#125;));</code></pre><h3 id="二、原始数据类型-BigInt"><a href="#二、原始数据类型-BigInt" class="headerlink" title="二、原始数据类型 BigInt"></a>二、原始数据类型 <code>BigInt</code></h3><blockquote><p><code>bigint</code> 是 ES6 中新增的一种原始数据类型，它是 JavaScript 中的第八种数据类型，与 undefined、null、Number（数值）、String（字符串）、Boolean（布尔值）、Object（对象）、Symbol 并列。</p></blockquote><ol><li>为什么要有 <code>BigInt</code> 类型<blockquote><ul><li>在之前的课程中我们了解到，JS 能表示的最大的<strong>安全正整数</strong>保存在<code>Number.MAX_SAFE_INTEGER</code>中，他的值 等于<code>2^53-1=9007199254740991</code></li><li>如果 JS 中整数的范围一旦超过这个范围，就无法精确表示。</li></ul></blockquote></li></ol><pre><code>let n = Number.MAX_SAFE_INTEGER;console.log(n); // 9007199254740991let n1 = 9007199254740991 + 1;let n2 = 9007199254740991 + 2;console.log(n1 === n2); // true</code></pre><blockquote><ul><li>以上的 n1 显然和 n2 不相等，但是最后的结果显示的为 true，说明 JS 已经无法安全的识别这是两个不同的数了。</li></ul></blockquote><blockquote><ul><li>为了解决这个问题，JS 中引用了 <code>BigInt</code> 这种原始数据类型。他可以表示大于<code>2^53 - 1</code> 的整数。它<strong>只用来表示整数</strong>，同时<strong>没有位数的限制</strong>，任何位数的整数都可以精确表示。</li></ul></blockquote><ol start="2"><li>如何定义<code>BigInt</code>类型数据<blockquote><ul><li>可以在一个整数的字面量后面加<code>n</code>的方式定义一个<code>BigInt</code></li><li>也可以调用函数<code>BigInt()</code>并传递一个整数值或字符串值</li></ul></blockquote></li></ol><pre><code>let n1 = 3n;let n2 = BigInt(&quot;3&quot;);let n3 = BigInt(3);let n4 = BigInt(3n);&gt;console.log(typeof n1); // bigintconsole.log(typeof n2); // bigintconsole.log(typeof n2); // bigint&gt;console.log(n1); //3nconsole.log(n2); //3nconsole.log(n3); //3nconsole.log(n4); //3n&gt;console.log(n1 === n2); //trueconsole.log(n3 === n2); //trueconsole.log(n4 === n3); //true&gt;console.log(3 == n1); //trueconsole.log(3 == n2); //trueconsole.log(3 == n3); //trueconsole.log(3 == n4); //true//由于类型不同，不能全等console.log(3 === n1); //false</code></pre><blockquote><ul><li>以上的<code>3n</code>表示的就是3，只是在后面加了<code>n</code>后，表示的类型不再是<code>number</code>而是<code>bigint</code></li></ul></blockquote><blockquote><ul><li>不过我们最好不要用<code>==</code>来比较<code>bigint</code>和<code>number</code>类型，因为当<code>number</code>类型超出安全范围就会出错</li></ul></blockquote><pre><code>let n1 = 9007199254740993;let n2 = 9007199254740992n;console.log(n1 == n2); // true</code></pre><ol start="3"><li>注意事项<blockquote><ul><li><code>BigInt</code>只能用来表示整数，如果是小数，则会自动忽略小数部分或者报错</li></ul></blockquote></li></ol><pre><code>let n = 2.3; // 抛出语法类型错误let n = BigInt(&quot;2.33&quot;); // 抛出语法类型错误&gt;const num = 3n / 2n;console.log(num); //1n</code></pre><blockquote><ul><li>超出 <code>2^53-1</code> 的整数，能精确表示</li></ul></blockquote><pre><code>let n1 = 9007199254740992n;let n2 = 9007199254740994n;console.log(n1 === n2);//false</code></pre><blockquote><ul><li><code>BigInt</code>类型不能与<code>Number</code>类型进行混合运算</li></ul></blockquote><pre><code>let n1 = 1 + 2n; // 抛出语法错误</code></pre><blockquote><ul><li>二进制、八进制、十六进制的表示法后面都要加上后缀 n<blockquote><p>八进制以<code>0o</code>开头</p></blockquote></li></ul></blockquote><pre><code>let num1 = 0b000100n;console.log(num1); //4nlet num2 = 0o10n;console.log(num2); //8nlet num3 = 0xan;console.log(num3); //10n</code></pre><blockquote><p>几乎所有 <code>Number</code> 运算符都可以有 <code>bigint</code> 中使用</p><ul><li>但 <code>&gt;&gt;&gt;</code> 无符号右位移运算和一元求正运算符 <code>+</code>不可以</li><li>如果是参于<code>/</code>除法运算，最后会丢掉小数部分，<strong>只取整数部分</strong></li></ul></blockquote><pre><code>console.log(2n + 3n); // 5nconsole.log(2n * 3n); // 6nconsole.log(5n / 2n); // 2nconsole.log(5n % 2n); // 1nconsole.log(5n || 0n); // 5nconsole.log(5n &amp;&amp; 0n); // 0n&gt;console.log(+3n); // 抛出类型错误console.log(2n &gt;&gt;&gt; 0); // 抛出类型错误</code></pre><blockquote><ul><li><code>&gt;&gt;&gt;</code>运算抛出错误，是因为<code>&gt;&gt;&gt;</code>要求最高位补<code>0</code>，但<code>bigin</code>类型<strong>没有最高位</strong></li></ul></blockquote><h3 id="三、模板字符串"><a href="#三、模板字符串" class="headerlink" title="三、模板字符串"></a>三、模板字符串</h3><blockquote><p>我们在 ES5 之前使用的普通字符串如下</p></blockquote><pre><code>// 我们常用的普通字符串，使用单引号 &#39;&#39; 或 双引号 &quot;&quot; 的形式&quot;icoding&quot;;&quot;icoding&quot;;</code></pre><blockquote><ul><li>模板字符串相当于加强版的字符串，把原来的<code>&#39;&#39;</code>或<code>&quot;&quot;</code><strong>替换</strong>成反引号&#96;将内容引用起来即可，这样就变成 模板字符串了。</li></ul></blockquote><h4 id="普通字符串和模板字符串的简单用法"><a href="#普通字符串和模板字符串的简单用法" class="headerlink" title="普通字符串和模板字符串的简单用法"></a>普通字符串和模板字符串的简单用法</h4><blockquote><ul><li>如果只是简单的用法，普通字符串和模板字符串之间没有什么区别</li></ul></blockquote><pre><code>// 定义模板字符串，使用 `` 反引号`icoding`;// 我们可能有疑惑，模板字符串和普通字符串有什么区别呢 ？ 其实，简单写法没啥区别// 如下常量声明：const brand1 = &quot;icoding&quot;; // 普通字符串声明const brand2 = `icoding`; // 使用模板字符串声明&gt;// 观察 brand1 和 brand2 之间是否有区别console.log(brand1, brand2, brand1 === brand2); // icoding icoding trueconsole.log(typeof brand2); // string</code></pre><h4 id="模板字符串与普通字符串的区别"><a href="#模板字符串与普通字符串的区别" class="headerlink" title="模板字符串与普通字符串的区别"></a>模板字符串与普通字符串的区别</h4><blockquote><ul><li>ES5 之前，我们基本都是使用拼接字符串的方式，如果一旦内容多了，拼起来就费时费力</li></ul></blockquote><pre><code>// 声明一个person对象const person = &#123;  username: &quot;icoding&quot;,  age: 20,  sex: &quot;male&quot;,&#125;;// 通过普通字符串拼接const msg =  &quot;我叫：&quot; +  person.username +  &quot; ，性别是：&quot; +  person.sex +  &quot;，今年：&quot; +  person.age +  &quot; 岁了&quot;;console.log(msg); // 我叫：icoding ，性别是：male，今年：20 岁了</code></pre><blockquote><ul><li>在 ES6 中，我们使用模板字符串来完成，如下</li></ul></blockquote><pre><code>// 声明一个person对象const person = &#123;  username: &quot;icoding&quot;,  age: 20,  sex: &quot;male&quot;,&#125;;// 通过模板字符串拼接const msg = `我叫：$&#123;person.username&#125; ，性别是：$&#123;person.sex&#125;，今年：$&#123;person.age&#125; 岁了`;console.log(msg); // 我叫：icoding ，性别是：male，今年：20 岁了</code></pre><blockquote><ul><li>有了模板字符串后，就直接通过反引号中直接定义<strong>多行字符串</strong>和<strong>变量</strong>的拼接，凡是使用<code>+</code>拼接的都可以替换成模板字符串。</li><li>如果是变量就包裹在<code>$&#123;&#125;</code>的大括号中即可</li></ul></blockquote><blockquote><blockquote><p>总结：</p></blockquote><ul><li>和其他东西一起使用时，使用模板字符串，方便注入</li><li>其他情况下使用模板字符串或普通字符串都行</li></ul></blockquote><h4 id="模板字符串的注意事项"><a href="#模板字符串的注意事项" class="headerlink" title="模板字符串的注意事项"></a>模板字符串的注意事项</h4><blockquote><p>模板字符串在实际开发过程中应该注意哪些 ？</p></blockquote><ol><li>输出多行字符串<blockquote><ul><li>普通字符串</li></ul></blockquote></li></ol><pre><code>// 普通字符串const msg = &quot;第1行\n第2行&quot;;console.log(msg);// 输出结果如下</code></pre><img src="输出多行字符串.png"><blockquote><ul><li>模板字符串</li></ul></blockquote><pre><code>// 模板字符串const msg = `第1行\n第2行`;console.log(msg);// 输出结果如下</code></pre><img src="输出多行字符串.png"><blockquote><ul><li>模板字符串，添加空格、换行或缩进</li></ul></blockquote><pre><code>const msg = `第1行第2行`;console.log(msg);</code></pre><img src="模板字符串换行.png"><blockquote><blockquote><p>总结：</p></blockquote><ul><li>在模板字符串中，所有的空格、换行或缩进都会被保留并输出，简单说：<strong>格式会原样输出</strong></li></ul></blockquote><ol start="2"><li>输出 &#96; 和 \ 等特殊字符<blockquote><ul><li>在模板字符串中要输出特殊字符，同样需要用到转义符<code>\</code>反斜杠来进行转义，才能正常输出</li></ul></blockquote></li></ol><pre><code>// 输出 反引号 `const msg = `\``;console.log(msg); // `// 输出 反斜杠const msg1 = `\\`;console.log(msg1); // \// 输出 &#39; 单引号const msg2 = `&#39;`; // 类似 &#39;&#39; &quot;&quot; 不属于特殊字符console.log(msg2); // &#39;</code></pre><blockquote><ul><li><code>&quot;</code>、<code>&quot;&quot;</code>、<code>&#39;</code>、<code>&#39;&#39;</code>不属于特殊字符，不需要使用转义符</li></ul></blockquote><ol start="3"><li>模板字符串的注入<blockquote><p>在注入过程中，我们会使用 <code>$&#123;&#125;</code></p><blockquote><p>模板字符串中到底可以放什么内容，有没有规律呢 ？</p></blockquote><ul><li>其实只<strong>要最终可以得出一个值</strong>的就可以通过<code>$&#123;&#125;</code>注入到模板字符串中</li></ul></blockquote></li></ol><pre><code>// 模板字符串的注入，使用 $&#123;&#125;const username = &quot;icoding&quot;;const person = &#123; age: 20, sex: &quot;male&quot; &#125;;const getSex = function (sex) &#123;  return sex === &quot;male&quot; ? &quot;男&quot; : &quot;女&quot;;&#125;;&gt;const msg = `我叫 $&#123;username&#125; ，今年 $&#123;person.age + 6&#125; 岁了，我是 $&#123;getSex(  person.sex)&#125; 生`;console.log(msg); // 我叫 icoding ，今年 26 岁了，我是 男 生</code></pre><ol start="4"><li>模板字符串在实际开发中的应用<blockquote><ul><li>通过模板字符串动态注入数据，遍历动态数据</li><li>用模板字符串拼接的方式，搭建HTML结构；代替之前先创建标签，再插入内容的方式；提升性能</li></ul></blockquote></li></ol><pre><code>&gt;&lt;title&gt;学生信息表 - 模板字符串的应用&lt;/title&gt;&gt;&lt;style&gt;   table &#123;     border-collapse: collapse;     width: 860px;     margin: 50px auto;   &#125;   table tr th,   td &#123;     border: 1px solid #dfe2e5;     text-align: center;     padding: 0.6em 1em;   &#125;   caption &#123;     font-size: 22px;   &#125;&gt;&lt;/style&gt;&gt;&gt;&lt;table&gt;&gt;  &lt;thead&gt;&gt;    &lt;caption&gt;&gt;      大一班学生信息表&gt;    &lt;/caption&gt;&gt;    &lt;tr&gt;&gt;      &lt;th&gt;姓名&lt;/th&gt;&gt;      &lt;th&gt;性别&lt;/th&gt;&gt;      &lt;th&gt;年龄&lt;/th&gt;&gt;      &lt;th&gt;户籍所在地&lt;/th&gt;&gt;    &lt;/tr&gt;&gt;  &lt;/thead&gt;&gt;  &lt;tbody id=&quot;stu-list&quot;&gt;&gt;    &lt;!-- &lt;tr&gt;&gt;      &lt;td&gt;arry&lt;/td&gt;&gt;      &lt;td&gt;男&lt;/td&gt;&gt;      &lt;td&gt;18&lt;/td&gt;&gt;      &lt;td&gt;北京&lt;/td&gt;&gt;    &lt;/tr&gt; --&gt;&gt;    &lt;tr&gt;&gt;      &lt;td colspan=&quot;4&quot;&gt;信息正在加载中 ...&lt;/td&gt;&gt;    &lt;/tr&gt;&gt;  &lt;/tbody&gt;&gt;  &lt;tfoot&gt;&gt;    &lt;tr&gt;&gt;      &lt;th&gt;备注&lt;/th&gt;&gt;      &lt;td colspan=&quot;3&quot;&gt;新学期开学，学生信息表&lt;/td&gt;&gt;    &lt;/tr&gt;&gt;  &lt;/tfoot&gt;&gt;&lt;/table&gt;&gt;&gt;&lt;script&gt;  // 数据，目前作为演示，在实际开发中这些数据都会用过 Ajax 动态的加载  const students = [    &#123;      username: &quot;arry&quot;,      age: 18,      sex: &quot;male&quot;,      city: &quot;北京&quot;,    &#125;,    &#123;      username: &quot;清心&quot;,      age: 20,      sex: &quot;female&quot;,      city: &quot;湖南&quot;,    &#125;,    &#123;      username: &quot;allen&quot;,      age: 21,      sex: &quot;male&quot;,      city: &quot;深圳&quot;,    &#125;,    &#123;      username: &quot;jack&quot;,      age: 22,      sex: &quot;female&quot;,      city: &quot;上海&quot;,    &#125;,  ];&gt;  // 获取将要填充数据的容器  const dataList = document.getElementById(&quot;stu-list&quot;);  // 声明变量来保存拼接的字符串  let html = &quot;&quot;;  // 循环遍历拼接数据  for (let i = 0; i &lt; students.length; i++) &#123;    // 使用模板字符串拼接    html += `&lt;tr&gt;            &lt;td&gt;$&#123;students[i].username&#125;&lt;/td&gt;            &lt;td&gt;$&#123;students[i].age&#125;&lt;/td&gt;            &lt;td&gt;$&#123;students[i].sex === &quot;male&quot; ? &quot;男&quot; : &quot;女&quot;&#125;&lt;/td&gt;            &lt;td&gt;$&#123;students[i].city&#125;&lt;/td&gt;            &lt;/tr&gt;`;  &#125;&gt;  // 查看模板字符串注入后的数据  //   console.log(html);&gt;  // 将拼接注入的数据填充到容器中  dataList.innerHTML = html;&gt;&lt;/script&gt;</code></pre><h4 id="四、标签模板"><a href="#四、标签模板" class="headerlink" title="四、标签模板"></a>四、标签模板</h4><blockquote><ul><li>模板字符串还可以紧跟在一个函数后面，该函数将被调用，用来处理这个模板字符串，这被称为<strong>“标签模板”</strong>功能。</li><li>标签模板其实是<strong>函数的一种特殊形式</strong>。“标签”指的就是函数，紧跟在后面的模板字符串就是它的参数。</li><li>但是，如果模板字符串中有变量<code>$&#123;&#125;</code>，就不再是简单的调用了，而是将模板字符串先处理成多个参数，再调用函数。</li></ul></blockquote><ol><li>模板字符串中没有变量<blockquote><p>函数后面紧跟的模板字符串中没有变量，则模板字符串为<strong>函数的参数</strong></p></blockquote></li></ol><pre><code>function tagFn(string) &#123;  console.log(arguments);  console.log(arguments[0][0]);  console.log(string);&#125;tagFn`模板字符串内容`;</code></pre><img src="标签模板-无变量.png"><ol start="2"><li>模板字符串中有变量<blockquote><p>函数后面紧跟的模板字符串中包含变量，则模板字符串将会被处理成<strong>多个参数</strong>，再调用函数</p></blockquote></li></ol><table><thead><tr><th>参数</th><th>说明</th></tr></thead><tbody><tr><td>第一个参数</td><td>第一个参数是一个<strong>类数组对象</strong>，其内部包含一个数组，数组成员为模板字符串中那些<strong>没有变量替换的部分</strong>，你可以理解为被<code>$&#123;...&#125;</code>这种表达式分隔的字符串组成的数组</td></tr><tr><td>其余参数</td><td>其它参数都是模板字符串中${…}被替换后对应的值</td></tr></tbody></table><pre><code>function sayHello(string, value1, value2, value3) &#123;  // 类数组对象，其内包含一个数组，数组成员是由$&#123;...&#125;分隔后的字符串组成的  console.log(string);  // string.raw为一个数组，数组成员是由$&#123;...&#125;分隔后的字符串组成的  console.log(string.raw);  console.log(value1); // 对应模板字符串中$&#123;username&#125;解析后的值  console.log(value2); // 对应模板字符串中$&#123;city&#125;解析后的值  console.log(value3); // 没有对应的变量被解析，则值为undefined&#125;&gt;let username = &quot;清心&quot;;let city = &quot;北京&quot;;sayHello`Hello$&#123;username&#125;,欢迎你来到$&#123;city&#125;`;</code></pre><img src="标签模板有变量.png"><blockquote><ul><li><code>arguments</code>的第一个参数是一个类数组对象，对象中包含一个数组，数组中对应的是模板字符串中那些<strong>没有变量替换的部分</strong></li><li><code>arguments</code>第一个参数之后是变量值</li><li>所以<strong>类数组中的每一项内容</strong>在模板字符串中后面紧跟随的变量值为第二个，第三个等参数。</li><li>注意如果模板字符串以变量结尾，那类数组对象的最后一个值就<code>&#39;&#39;</code><blockquote><p>根据上面的对应关系，我们来写一个函数，通过函数的参数来还原原模板字符串。</p></blockquote></li></ul></blockquote><ol start="3"><li>函数内还原原模板字符串</li></ol><pre><code>&gt;const obj = &#123;&gt;username: &quot;清心&quot;,&gt;age: 18,&gt;sex: &quot;女&quot;,&gt;&#125;;&gt;&gt;function getString(strArr) &#123;&gt;//arguments:[strArr 变量值1 变量值2]&gt;let result = &quot;&quot;;&gt;let i = 0;&gt;while (i &lt; strArr.length) &#123;&gt;result += strArr[i++]; // i是先赋值，再自增 &gt;if (i &lt; arguments.length) &#123;&gt;result += arguments[i];&gt;&#125;&gt;&#125;&gt;return result;&gt;&#125;&gt;&gt;let result = getString`大家好，我是$&#123;obj.username&#125;,性别$&#123;obj.sex&#125;,今年$&#123;obj.age&#125;岁了`;&gt;console.log(result); // 大家好，我是清心,性别女,今年18岁了</code></pre><ol start="4"><li><p>标签模板应用场景</p><blockquote><ul><li>当我们需要对模板字符串<code>$&#123;...&#125;</code>中的内容需要进<strong>一步的验证和加工</strong>时，就可以利用到标签模板功能来处理。</li></ul></blockquote></li><li><p>案例：根据数据渲染荣誉展示模块</p><blockquote><p><strong>后台返回的数据如下：</strong></p></blockquote></li></ol><pre><code>const data = [  &#123;    username: &quot;刘梦宇&quot;, // 用户名    projectName: &quot;槐里集团&quot;, // 项目名    role: 3, // 用户角色，角色有 技术总监 、项目经理、 项目组长 、工程师    time: 1669824000000, // 时间戳    honour: 1,  &#125;,  &#123;    username: &quot;王妍&quot;,    projectName: &quot;槐里集团&quot;,    role: 4,    time: 1669824000000,    honour: 2,  &#125;,  &#123;    username: &quot;许尹阳&quot;,    projectName: &quot;槐里集团&quot;,    role: 4,    time: 1669824000000,    honour: 2,  &#125;,  &#123;    username: &quot;侯天帅&quot;,    projectName: &quot;槐里集团&quot;,    role: 4,    time: 1669824000000,    honour: 3,  &#125;,  &#123;    username: &quot;王薇&quot;,    projectName: &quot;槐里集团&quot;,    role: 4,    time: 1669824000000,    honour: 4,  &#125;,];</code></pre><blockquote><p><strong>其中角色和荣誉后对应的内容如下:</strong></p></blockquote><pre><code>// 角色处理const role = &#123;  1: &quot;技术总监&quot;,  2: &quot;项目经理&quot;,  3: &quot;项目组长&quot;,  4: &quot;工程师&quot;,&#125;;&gt;// 荣誉const honour = &#123;  1: &quot;年度卓越贡献奖&quot;,  2: &quot;最佳效率奖&quot;,  3: &quot;最佳创意奖&quot;,  4: &quot;最佳贡献奖&quot;,&#125;;</code></pre><ul><li><strong>实现思路</strong><blockquote><ul><li><strong>第一步</strong>：确认每一条信息的相同点和不同点，得出对应的模板字符串结构如下：</li></ul></blockquote></li></ul><pre><code>恭喜xxx同学，在xxxx年xxx月参于的xxxx项目中担任xxx一职，表现优异，认真负责，荣获xxxx奖</code></pre><blockquote><ul><li>其中，动态内容有：人名，时间，项目名、角色，奖项。 需要我们用<code>$&#123;...&#125;</code>向模板字符串中注入对应内容</li></ul></blockquote><blockquote><ul><li>根据后台数据可知，动态内容还需要进行进一步处理</li><li><strong>第二步</strong>，声明一个函数对动态内容进行处理；使用标签模板，将后台数据传入该函数</li><li><strong>第三步</strong>，渲染页面，使用模板字符串，构建HTML结构，并将其渲染到容器中</li></ul></blockquote><ul><li>HTML布局和CSS样式<blockquote><ul><li>需要变红色的元素加<code>text</code>类名</li></ul></blockquote></li></ul><pre><code>&gt;&lt;style&gt;  body &#123;    margin: 0;  &#125;  .honour &#123;    margin: 50px;  &#125;  /* 字体颜色变红 */  span.text &#123;    color: red;  &#125;&gt;&lt;/style&gt;&gt;&lt;div class=&quot;honour&quot;&gt;&gt; &lt;h3&gt;荣誉展示&lt;/h3&gt;&gt; &lt;ul id=&quot;J_honour&quot;&gt;&lt;/ul&gt;&gt;&lt;/div&gt;</code></pre><ul><li>处理动态内容<blockquote><ul><li>需要加样式的变量，用模板字符串构建<code>span</code>标签，并加上类样式</li><li>将处理好的内容，与不需要处理的内容<strong>重新拼接</strong>，并返回</li></ul></blockquote></li></ul><pre><code>function honour(    strArr,    usernameExp,    timeExp,    projectExp,    roleExp,    honourExp  ) &#123;    // 名字处理    let username = `&lt;span class=&#39;text&#39;&gt;$&#123;usernameExp&#125;&lt;/span&gt;`;    // 角色处理    const role = &#123;      1: &quot;技术总监&quot;,      2: &quot;项目经理&quot;,      3: &quot;项目组长&quot;,      4: &quot;工程师&quot;,    &#125;;    let strRole = role[roleExp];&gt;    // 时间处理    const time = new Date(timeExp);    let strTime = `$&#123;time.getFullYear()&#125;年$&#123;time.getMonth() + 1&#125;月`;&gt;    // 荣誉    const honour = &#123;      1: &quot;年度卓越贡献奖&quot;,      2: &quot;最佳效率奖&quot;,      3: &quot;最佳创意奖&quot;,      4: &quot;最佳贡献奖&quot;,    &#125;;    const strHonour = `&lt;span class=&#39;text&#39;&gt;$&#123;honour[honourExp]&#125;&lt;/span&gt;`;    // 输出内容......    let output = strArr[0]; // 添加被$&#123;...&#125;分隔出来的第一个内容    [username, strTime, projectExp, strRole, strHonour].forEach(function (      item,      index    ) &#123;      output += item; // 添加$&#123;...&#125;解析出来的内容      output += strArr[++index]; // 添加以$&#123;...&#125;分隔出来的内容    &#125;);    return output; // 返回拼接后的字符串  &#125;</code></pre><ul><li>渲染页面<blockquote><ul><li>在这里调用处理动态内容的函数，并传入data数据</li></ul></blockquote></li></ul><pre><code>// DOM渲染function render(obj, data) &#123;  let html = &quot;&quot;; // 拼接li结构字符串  // 遍历数据，对数据做处理  data.forEach(function (item) &#123;    let result = honour`恭喜$&#123;item.username&#125;同学，在$&#123;item.time&#125;参于的&lt;&lt;$&#123;item.projectName&#125;&gt;&gt;项目中担任$&#123;item.role&#125;一职，表现优异，认真负责，荣获$&#123;item.honour&#125;。`;    html += `&lt;li&gt;$&#123;result&#125;&lt;/li&gt;`; // 拼接每一个li  &#125;);  obj.innerHTML = html; //添加到页面中&#125;&gt;// 获取DOM元素const ul = document.getElementById(&quot;J_honour&quot;);render(ul, data); // 开始渲染</code></pre><blockquote><blockquote><p><code>Array.forEach(callbackFn)</code>方法对数组的每个元素执行一次给定的函数。<code>callbackFn(el,index)</code>，el:数组中正在处理的当前元素。index:数组中正在处理的当前元素的索引。</p></blockquote></blockquote><ul><li>完整代码</li></ul><pre><code>&gt;&lt;style&gt;  body &#123;    margin: 0;  &#125;  .honour &#123;    margin: 50px;  &#125;  /* 字体颜色变红 */  span.text &#123;    color: red;  &#125;&gt;&lt;/style&gt;&gt;&gt;&lt;div class=&quot;honour&quot;&gt;&gt;  &lt;h3&gt;荣誉展示&lt;/h3&gt;&gt;  &lt;ul id=&quot;J_honour&quot;&gt;&lt;/ul&gt;&gt;&lt;/div&gt;&gt;&lt;script&gt;  function honour(    strArr,    usernameExp,    timeExp,    projectExp,    roleExp,    honourExp  ) &#123;    // 名字处理    let username = `&lt;span class=&#39;text&#39;&gt;$&#123;usernameExp&#125;&lt;/span&gt;`;    // 角色处理    const role = &#123;      1: &quot;技术总监&quot;,      2: &quot;项目经理&quot;,      3: &quot;项目组长&quot;,      4: &quot;工程师&quot;,    &#125;;    let strRole = role[roleExp];&gt;    // 时间处理    const time = new Date(timeExp);    let strTime = `$&#123;time.getFullYear()&#125;年$&#123;time.getMonth() + 1&#125;月`;&gt;    // 荣誉    const honour = &#123;      1: &quot;年度卓越贡献奖&quot;,      2: &quot;最佳效率奖&quot;,      3: &quot;最佳创意奖&quot;,      4: &quot;最佳贡献奖&quot;,    &#125;;    const strHonour = `&lt;span class=&#39;text&#39;&gt;$&#123;honour[honourExp]&#125;&lt;/span&gt;`;    // 输出内容......    let output = strArr[0]; // 添加被$&#123;...&#125;分隔出来的第一个内容    [username, strTime, projectExp, strRole, strHonour].forEach(function (      item,      index    ) &#123;      output += item; // 添加$&#123;...&#125;解析出来的内容      output += strArr[++index]; // 添加以$&#123;...&#125;分隔出来的内容    &#125;);    return output; // 返回拼接后的字符串  &#125;&gt;  // DOM渲染  function render(obj, data) &#123;    let html = &quot;&quot;; // 拼接li结构字符串    // 遍历数据，对数据做处理    data.forEach(function (item) &#123;      let result = honour`恭喜$&#123;item.username&#125;同学，在$&#123;item.time&#125;参于的&lt;&lt;$&#123;item.projectName&#125;&gt;&gt;项目中担任$&#123;item.role&#125;一职，表现优异，认真负责，荣获$&#123;item.honour&#125;。`;      html += `&lt;li&gt;$&#123;result&#125;&lt;/li&gt;`; // 拼接每一个li    &#125;);    obj.innerHTML = html; //添加到页面中  &#125;&gt;  // 获取DOM元素  const ul = document.getElementById(&quot;J_honour&quot;);  const data = [    &#123;      username: &quot;刘梦宇&quot;, // 用户名      projectName: &quot;槐里集团&quot;, // 项目名      role: 3, // 用户角色，角色有 技术总监 、项目经理、 项目组长 、工程师      time: 1669824000000, // 时间戳      honour: 1,    &#125;,    &#123;      username: &quot;王妍&quot;,      projectName: &quot;槐里集团&quot;,      role: 4,      time: 1669824000000,      honour: 2,    &#125;,    &#123;      username: &quot;许尹阳&quot;,      projectName: &quot;槐里集团&quot;,      role: 4,      time: 1669824000000,      honour: 2,    &#125;,    &#123;      username: &quot;侯天帅&quot;,      projectName: &quot;槐里集团&quot;,      role: 4,      time: 1669824000000,      honour: 3,    &#125;,    &#123;      username: &quot;王薇&quot;,      projectName: &quot;槐里集团&quot;,      role: 4,      time: 1669824000000,      honour: 4,    &#125;,  ];  render(ul, data); // 开始渲染&gt;&lt;/script&gt;</code></pre><h3 id="五、模板字符串面试真题解析-和-扩展知识"><a href="#五、模板字符串面试真题解析-和-扩展知识" class="headerlink" title="五、模板字符串面试真题解析 和 扩展知识"></a>五、模板字符串面试真题解析 和 扩展知识</h3><blockquote><p>深入浅出互联网大厂 ES6 高频面试真题解析 和 相关扩展知识<br>面试真题是检验自己学习成果和查缺补漏的最好方式之一，同时也是了解企业对求职者技能要求的风向标 </p></blockquote><h4 id="手写-ES6-的模板字符串（百度）"><a href="#手写-ES6-的模板字符串（百度）" class="headerlink" title="手写 ES6 的模板字符串（百度）"></a>手写 ES6 的模板字符串（百度）</h4><blockquote><ul><li>手写一个方法，能成功解析字符串中的${}方式注入的内容</li></ul></blockquote><pre><code>let obj = &#123;  name: &quot;清心&quot;,  age: 23,&#125;;// 以下字符串中的$&#123;obj.name&#125;和$&#123;obj.age&#125; 能成功被解析成 清心和 23let str = &quot;大家好，我是$&#123;obj.name&#125;,今年$&#123;obj.age&#125;岁了&quot;;</code></pre><blockquote><p><strong>实现思路：</strong></p><ul><li>首先我们要用正则表达式，提取字符串中${}包裹的内容，正则如下</li></ul></blockquote><pre><code>const reg = /\$&#123;(.+?)&#125;/g; // 正则表达式</code></pre><blockquote><ul><li>把<strong>正则表达式</strong>中子表达式<code>(.+?)</code>的内容提取出来，然后解析成对应的内容，如<code>obj.name</code>解析成<code>清心</code>,<code>obj.age</code> 解析成<code>23</code></li><li>最后用子表达式解析成功的内容替换正则匹配到的<code>$&#123;&#125;</code>内容</li></ul></blockquote><ol><li>实现方法一：正则与 eval() 函数结合<blockquote><p>如果对<code>eval()</code>函数不了解，可以参考后面的扩展知识，给大家提供了相关的文档</p></blockquote></li></ol><pre><code>// 自定义字符串解析方法，可以解析string中$&#123;&#125;方式，读取变量中值function strParse(string) &#123;  const reg = /\$&#123;(.+?)&#125;/g; // 正则表达式  let newStr = string.replace(reg, function (v, p1) &#123;    // eval(obj.name) 返回解析后的字符串内容 如： obj.name解析成清心    return eval(p1);  &#125;);  return newStr; // 返回替换成功的字符串&#125;&gt;let obj = &#123;  name: &quot;清心&quot;,  age: 23,&#125;;let str = &quot;大家好，我是$&#123;obj.name&#125;,今年$&#123;obj.age&#125;岁了&quot;;console.log(strParse(str)); // 大家好，我是清心,今年23岁了&gt;let a = 2;let b = 3;let str2 = `a+b=$&#123;a + b&#125;`;console.log(strParse(str2)); // a+b=5</code></pre><blockquote><ul><li>如果想成功解析字符串中的<code>&#123;&#123;&#125;&#125;</code>结构，只需将正则替换为如下</li></ul></blockquote><pre><code>const reg = /\&#123;&#123;(.+?)&#125;&#125;/g; // 正则表达式,解析字符串中的&#123;&#123; &#125;&#125;模式// let str = &quot;大家好，我是&#123;&#123;obj.name&#125;&#125;,今年&#123;&#123;obj.age&#125;&#125;岁了&quot;;</code></pre><ol start="2"><li>实现方法二：正则与Function构造函数<blockquote><ul><li>Function构造函数知识点在后面</li></ul></blockquote></li></ol><blockquote><ul><li>基础版</li></ul></blockquote><pre><code>let obj = &#123;  name: &quot;清心&quot;,  age: 23,&#125;;let str = &quot;大家好，我是$&#123;obj.name&#125;,今年$&#123;obj.age&#125;岁了&quot;;console.log(strParse(str)); //&gt;// strParse函数能成功解析字符串中的$&#123;&#125;function strParse(string) &#123;  const reg = /\$&#123;(.+?)&#125;/g; // 正则表达式  let newStr = string.replace(reg, function (v, p1) &#123;    // 生成函数 function anonymous()&#123;return obj.name&#125; 然后自调用    return Function(&quot;return &quot; + p1)();  &#125;);  return newStr;&#125;</code></pre><blockquote><ul><li>注意：<code>return</code>后面记得空一格</li><li>上面的 <code>obj</code> 为全局作用域中的变量，如果 <code>obj</code> 不在全局作用域中，那最后就得不到想要的结果，因为 <code>Function</code> 创建的函数<strong>只能访问当前作用域中局部变量和全局作用域中变量</strong>。</li></ul></blockquote><blockquote><ul><li>所以我们需要将对应的数据当成函数的参数，传入到函数的内部，具体代码如下<blockquote><p>不过这种方式，<strong>所有变量需要成为对象的属性</strong>，否则也是读取不到的</p></blockquote></li></ul></blockquote><pre><code>// dataname 数据对象名   data数据对象   string需要处理的字符串function strParse(dataname, data, string) &#123;  const reg = /\$&#123;(.+?)&#125;/g; // 正则表达式  let newStr = string.replace(reg, function (v, p1) &#123;    // 创建函数 function anonymous(obj)&#123; return obj.name&#125; 然后自调用，传入数据    return Function(dataname, &quot;return &quot; + p1)(data);  &#125;);  return newStr;&#125;&gt;function fn() &#123;  let obj = &#123;    name: &quot;清心&quot;,    age: 23,  &#125;;  let str = &quot;大家好，我是$&#123;obj.name&#125;,今年$&#123;obj.age&#125;岁了&quot;;  let newStr = strParse(&quot;obj&quot;, obj, str);  console.log(newStr);&#125;fn();</code></pre><ol start="3"><li>实现方法三：正则与 Function 构造函数<blockquote><p>这一步我们想要解决的是，能成功解析字符串<code>$&#123;...&#125;</code>的内容，但<code>$&#123;...&#125;</code>中的内容是<strong>直接引用对象的属性</strong>，而不是<code>对象.属性</code>的方式。</p></blockquote></li></ol><pre><code>let obj = &#123;  name: &quot;清心&quot;,  age: 23,  arr: [1, 2, 3],&#125;;// let str1 = &quot;大家好，我是$&#123;obj.name&#125;,今年$&#123;obj.age&#125;岁了$&#123;obj.arr[0]&#125;&quot;;let str2 = &quot;大家好，我是$&#123;name&#125;,今年$&#123;age&#125;岁了$&#123;arr[0]&#125;&quot;;// str2字符串中的$&#123;name&#125; $&#123;age&#125; $&#123;arr[0]&#125; 要能被成功解析为 清心 23  1</code></pre><blockquote><ul><li>如果按照上一个方法，当前作用域中没有<code>name</code>,<code>age</code>,<code>arr</code>变量，所以肯定访问不到，最终报错。</li><li>所以我们需要将这些变量<strong>作为函数的参数传进来</strong>，而这些变量名正好对应<code>obj</code>对象的属性名，所以我们可以把对象的<strong>属性名</strong>当做函数的<strong>形参</strong>，对象属性名对应的<strong>属性</strong>值，当成<strong>实参</strong>传入。</li></ul></blockquote><blockquote><ul><li>先看new Function要创建什么函数</li></ul></blockquote><pre><code>  (function anonymous(name,age,arr)&#123;    return name;//age/arr[0];  &#125;)(&quot;清心&quot;,23,[1,2,3]);</code></pre><blockquote><ul><li><code>let str2 = &quot;大家好，我是$&#123;name&#125;,今年$&#123;age&#125;岁了$&#123;arr[0]&#125;&quot;;</code></li><li>因为字符串是这样的，p1拿到的就是<code>name、age、arr[0]</code></li><li>Function函数里面没有这些变量，也不能放全局里，所以只能传进去；作为形参，名字肯定要对应才能找得到：<code>name,age,arr</code>，也就是对象的属性名；</li><li>作为实参的话，要把对象的属性值传进去</li><li>所以我们要先根据传进来的obj，拿到对象的属性名和属性值；然后再将Function函数返回，执行函数体内的代码，替换<code>$&#123;...&#125;</code>的内容</li></ul></blockquote><pre><code> function strParse(str, obj) &#123;   const reg = /\$&#123;(.+?)&#125;/g;   let newStr = str.replace(reg, function (v, p1) &#123;     const keys = Object.keys(obj);     const values = Object.values(obj);     return Function(...keys, &quot;return &quot; + p1)(...values);   &#125;);   return newStr; &#125;&gt; function fn() &#123;   let obj = &#123;     name: &quot;清心&quot;,     age: 23,     arr: [1, 2, 3],   &#125;;   let str = &quot;大家好，我是$&#123;name&#125;,今年$&#123;age&#125;岁了$&#123;arr[0]&#125;&quot;;   return strParse(str, obj); &#125; console.log(fn()); // 大家好，我是清心,今年23岁了1</code></pre><blockquote><blockquote><p>总结：通过这个面试题，我们重点掌握以下三个思想</p></blockquote><ul><li>如何利用<strong>正则</strong>匹配符合模式的内容</li><li>如何把一个字符串，像正常的 JS 代码一样去<strong>执行</strong></li><li><code>Function</code>函数创建的函数相当于是在全局作用域中被创建的，所以他只能访问当前函数内的局部变量和全局变量，所以我们要把创建出来的函数体中用到<strong>变量</strong>，全都都当成<strong>参数</strong>给他传进去，同时还要把对应参数的实参也要传进去。</li></ul></blockquote><h4 id="扩展知识：eval、Function-构造函数"><a href="#扩展知识：eval、Function-构造函数" class="headerlink" title="扩展知识：eval、Function 构造函数"></a>扩展知识：eval、Function 构造函数</h4><ol><li>eval() 函数<blockquote><ul><li><code>eval()</code>函数 将传入的字符串当成<code>JS</code>脚本代码来执行</li><li>如果参数是一个表达式，<code>eval()</code>函数将执行表达式。如果参数是 <code>JavaScript</code>语句，<code>eval()</code>将执行 <code>JavaScript</code>语句（代码）。</li><li>语法：<code>eval(string); </code></li></ul></blockquote></li></ol><pre><code>// eval中的字符串会被当成正常的JS脚本来执行eval(&quot;let a=1;let b=2; console.log(a+b);&quot;); // 3&gt;const a = 3;const b = 4;console.log(eval(&quot;a+b&quot;)); // 7 对表达式求值，并将结果返回&gt;const obj = &#123; a: 1 &#125;;console.log(eval(obj.a)); // 1 对表达式求值，并将结果返回</code></pre><ol start="2"><li>Function 构造函数<blockquote><p><code>Function</code>构造函数用来创建一个新的函数对象，可以直接调用<code>Function</code>构造函数，也可以用<code>new </code>关键字来调用</p></blockquote></li></ol><pre><code>let fn1=new Function(arg1,arg2,arg3...,functionBody);let fn2=Function(arg1,arg2,arg3...,functionBody);</code></pre><blockquote><ul><li><code>fn1</code> 和 <code>fn2</code> 为新创建出来的函数</li><li><code>arg1，arg2，arg3...</code> 都是一个个<strong>字符串</strong>(需要双引号包裹)，为新创建出来的函数的形参</li><li><code>functionBody</code> 是 <code>Function()</code> 构造函数的最后一个参数，表示新创建出来的函数的函数体代码</li><li>如果<code>Function()</code>或 <code>new Function()</code>中只一个参数，那这个参数就是函数体代码，这个新创建出来的函数没有参数。</li></ul></blockquote><pre><code>// 以下代码相当于创建了匿名函数  sum= function anonymous(a,b)&#123;return a+b&#125;var sum = new Function(&quot;a&quot;, &quot;b&quot;, &quot;return a+b&quot;);console.log(sum(1, 2)); // 3&gt;// 相当于创建了匿名函数// sayHell=function anonymous()&#123;console.log(&quot;大家好，我是...&quot;)&#125;var sayHello = new Function(&#39;console.log(&quot;大家好，我是...&quot;)&#39;);sayHello(); // 大家好，我是...</code></pre><ol start="3"><li>Function 构造函数注意事项<blockquote><p><code>Function</code>构造函数创建的函数，总是被<strong>创建于全局环境</strong>（全局作用域），因此<strong>运行此函数时</strong>只能访问到当前函数作用域中的局部变量和全局变量。</p></blockquote></li></ol><pre><code> const a = 0; function createFn() &#123;   const a = 3;   const b = 4;   // return Function(&quot;return a&quot;); //0   // return Function(&quot;return &quot; + a); //3   return Function(&quot;b&quot;, &quot;return b&quot;); //2 &#125; console.log(createFn()(2));</code></pre><blockquote><ul><li>Function函数创建后需要调用，要么在调用外层函数时写两个<code>()</code>，要么在创建时调用：<code>return Function()()</code></li><li>第一个<code>return Function(&quot;return a&quot;)</code>是在Function函数体<strong>内</strong>调用a，此时只能访问到Function函数体内或者全局作用域下的变量，所以它返回了0</li><li>第二个<code>return Function(&quot;return &quot; + a);</code>，此时的a是在运行Function函数<strong>前</strong>就读取到了，所以这种情况下可以得到外层函数的变量</li><li>第三个<code>return Function(&quot;b&quot;, &quot;return b&quot;);</code>，此时的b是作为参数从外面传进去的，它是Function函数体内的变量</li></ul></blockquote><blockquote><blockquote><p>推荐阅读：</p></blockquote><ul><li>里面会讲到 <code>eval()</code> 和 <code>Function()</code> 之间的对比，还有更多替代 <code>eval</code> 实现复杂效果的方法</li><li><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/eval">https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/eval</a></li></ul></blockquote>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JS底层原理</title>
      <link href="/2023/12/08/JS%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86/"/>
      <url>/2023/12/08/JS%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86/</url>
      
        <content type="html"><![CDATA[<span id="more"></span><blockquote><ul><li>首先，我们要知道 JavaScript 是一门解释性语言，也就是边解析（编译），边执行。</li><li>你可以理解为一段 JS 代码在正式执行前需要被 JavaScript 引擎编译，编译完成之后，才会进入执行阶段。<img src="解释性语言.png"></li></ul></blockquote><blockquote><p>我们把 JavaScript 引擎在执行前的编译过程，程为JS 的预编译,在 JS 的编译阶段，会做以下三件事</p></blockquote><ol><li>语法检查<blockquote><ul><li>JS 引擎会检查你的代码有没有什么低级的<strong>语法错误</strong>，以消除一些歧义。</li><li>如果有语法错误，则<strong>不会往下执行</strong>，直接抛出“语法错误”。如以下代码：</li></ul><pre><code>var a = 1;console.log(a);var b = 3； // b后面的; 分号是中文状态下的// 代码并不会执行，打印出1，因为在预编译阶段有语法错误，所以直接抛出了误法错误</code></pre></blockquote></li><li>创建执行上下文 （Execution context）<blockquote><ul><li><strong>执行上下文</strong>是 JavaScript 执行一段代码时所处的<strong>运行环境</strong></li><li>关于执行上下文的相关细节，我们待会在下面详细讲解，这也是本章的重点。</li></ul></blockquote></li><li>生成可执行代码<blockquote><ul><li>JavaScript 引擎并不认识我们写的 JS 代码，所以需要将 JS 代码转换为计算机能读懂的机器码（二进制文件）</li></ul></blockquote></li></ol><h3 id="一、什么是执行上下文"><a href="#一、什么是执行上下文" class="headerlink" title="一、什么是执行上下文"></a>一、什么是执行上下文</h3><blockquote><ul><li>执行上下文是 JavaScript 执行<strong>一段代码</strong>时所处的<strong>运行环境</strong></li><li>MDN 官网中提到：<strong>作用域</strong>是当前的执行上下文</li></ul></blockquote><blockquote><ul><li>接下来我们就来明确下，哪些情况下代码才算是 “一段” 代码，才会在执行前进行预编译过程，并创建执行上下文环境。</li><li>主要有以下三种情况：<img src="执行上下文.png"></li></ul></blockquote><ol><li><p>全局执行上下文</p><blockquote><ul><li>当 JavaScript 执行<strong>全局作用域</strong>中的代码时，会编译全局代码并创建全局执行上下文</li><li>整个页面的生命周期内，全局执行上下文<strong>只有一份</strong>。</li><li>只有当整个页面<strong>关闭后</strong>，全局执行上下文才会被<strong>销毁</strong>。即页面没有关闭前，这些变量对应的数据都保存在<strong>内存</strong>中。<blockquote><p>引用的js文件等都在全局执行上下文里</p></blockquote></li></ul><pre><code>// 代码在执行前，会预编译，并会创建全局执行上下文// 以下代码在页面没有关闭前，是不会被销毁的，即当前数据还保存在内存中var a = 1;var b = 2;function sum(a, b) &#123;  console.log(a + b);&#125;</code></pre></blockquote></li><li><p>函数执行上下文</p><blockquote><ul><li>当<strong>调用</strong>一个函数时，函数体内的代码会被编译，并创建函数执行上下文。</li><li>一般情况下，函数执行<strong>结束</strong>之后，创建的函数执行上下文就会被<strong>销毁</strong>。</li></ul><pre><code>var a = 1;var b = 2;function sum(a, b) &#123;  var c = a;  var d = b;  console.log(c + d);&#125;sum(2, 3); // 调用函数</code></pre><blockquote><p>以上代码创建了 全局执行上下文和 函数执行上下文</p><ul><li>代码执行前，会预编译，并创建<strong>全局执行上下文</strong>，然后从上往下执行代码</li><li>执行到sum(2,3)时，他<strong>调用函数</strong>，调用函数时会对函数体内代码预编译，同时创建<strong>函数执行上下文</strong></li><li>执行函数体中代码，执行完后，函数执行上下文就会被<strong>销毁</strong>,即函数体内的变量c和d不再占据内存空间</li></ul></blockquote></blockquote></li><li><p>eval 执行上下文</p><blockquote><ul><li>在<strong>严格模式</strong>下，当使用 eval 函数时，eval 的代码会被编译，并创建eval执行上下文。</li><li>考虑安全性能问题，现在 eval 被<strong>禁用</strong></li></ul></blockquote></li></ol><blockquote><ul><li>eval() 函数可以接受一个<strong>字符串</strong>为参数，并将其中的内容视为好像在书写时就存在整个程序中这个位置的代码。</li><li>eval 通常被用来执行<strong>动态创建</strong>的代码，但是安全风险过高，如果传过来的是一段 JS 木马呢 ？</li></ul><pre><code>function foo() &#123;  eval(&quot;var a=1;var b=2;&quot;);  console.log(a + b);&#125;foo(); // 在控制台输出 3</code></pre></blockquote><blockquote><ul><li>在严格模式下，eval()在运行时会有自己的执行上下文</li><li>此时，外部作用域是访问不到内部作用域的，所以<code>console.log(a + b);</code>找不到a,b的值</li></ul><pre><code>function foo() &#123;  &quot;use strict&quot;;  eval(&quot;var a=1;var b=2;&quot;);  console.log(a + b); // 直接抛出错误 a is not defined&#125;foo();</code></pre></blockquote><h3 id="二、执行上下文栈"><a href="#二、执行上下文栈" class="headerlink" title="二、执行上下文栈"></a>二、执行上下文栈</h3><blockquote><p>什么是 栈 <code>LIFO</code> ？在算法那一章我们学习过栈这种数据结构，这里我们回顾下</p></blockquote><ol><li>什么是栈<blockquote><ul><li><strong>栈</strong>是一种<strong>先进后出</strong>的数据结构，要弄明白什么是栈，我们先举一个生活中的例子来帮助大家理解</li><li>假如你现在有一个长长的圆筒，圆筒的一端是封闭的，另一端是开口，现在往圆筒底部放气球，那先放的是不是在圆筒的底部，后放的是不是在靠近圆筒的位置。<img src="栈.jpg"></li></ul></blockquote></li></ol><blockquote><blockquote><p>详细解读：</p></blockquote><ul><li>我们现在要从圆筒中取出气球，那我们是不是得先取离圆筒出口最近的一个，即取球时的顺序正好和放的时候的顺序是反的。</li><li>我们把圆筒比喻从栈，那放气球的过程叫<strong>入栈</strong>，拿气球的过程叫<strong>出栈</strong>；圆筒的底部称为栈底，圆筒出口的第一个气球位置叫栈顶。<blockquote><p>栈 LIFO ： 是一种先进后出的一种数据结构。 插入一般称为入栈（PUSH），删除则称为出栈（POP）</p></blockquote></li></ul></blockquote><ol start="2"><li>什么是执行上下文栈（调用栈）<blockquote><ul><li>我们知道, 函数里面可以嵌套函数, 不同的函数调用又会形成不同的执行上下文环境</li><li>这些不同的执行上下文环境，我们统一放进一个<strong>栈</strong>中来管理。<blockquote><p>我们把这种用来<strong>管理</strong>执行上下文的栈，称为<strong>执行上下文栈</strong>，又称调用栈</p></blockquote></li><li>栈底为<strong>全局</strong>执行上下文, 每当有一次函数调用, 形成的函数执行上下文就会被 <code>push</code> 进栈顶，即<strong>压栈</strong></li><li>函数执行完, 该函数所对应的函数上下文将会被 <code>pop</code> 出上下文栈,即<strong>出栈</strong></li></ul></blockquote></li></ol><ul><li>我们用下面这个代码来演示，整个执行上下文栈的压栈和出栈过程<blockquote><pre class=" language-js"><code class="language-js"><span class="token keyword">var</span> a <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span><span class="token keyword">function</span> <span class="token function">fn1</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">"fn1"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token keyword">function</span> <span class="token function">fn2</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">"fn2"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>  <span class="token function">fn2</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span><span class="token function">fn1</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre></blockquote></li></ul><blockquote><p><strong>进栈</strong></p><ul><li>当页面打开，就会<strong>创建</strong>全局执行上下文，并将其<strong>压入</strong>执行上下文栈底。</li><li>然后<strong>执行</strong>全局上下文中代码，遇到<strong>fn1()调用</strong>，则会创建 fn1 的函数执行上下文, 压入执行上下文栈</li><li>然后执行 fn1 中代码，遇到<strong>fn2()调用</strong>，创建 fn2 的函数执行上下文,压入执行上下文栈。</li><li>接着执行 fn2 中的代码<img src="执行上下文压栈.png"></li></ul></blockquote><blockquote><p><strong>出栈</strong></p><ul><li>fn2 执行完毕后, 对应的执行上下文从执行上下文栈中 pop 出</li><li>此时 fn1 也被执行完，对应的执行上下文也从上下文栈中 pop 出</li><li>全局上下文要在浏览器关闭后才会被销毁<img src="执行上下文出栈.png"></li></ul></blockquote><ul><li>通过调试工具，来查看整个的压栈和出栈过程<img src="调试工具.png"></li></ul><ol start="3"><li>栈溢出<blockquote><ul><li>执行上下文栈是用来管理执行上下文的数据结构，不过要注意的是<strong>执行上下文栈是有大小的</strong></li><li>当入栈的执行上下文<strong>超过一定的数目</strong>，栈对应的内存空间被占满后，JavaScript 引擎就会报错，我们把这种错误叫做<strong>栈溢出</strong><blockquote><p>递归代码，很容易出现栈溢出情况，如下代码</p></blockquote></li></ul><pre><code>var i = 0;function a() &#123;  i++;&#125;a();</code></pre><blockquote><p>注：</p><ul><li>不同的浏览为栈分配的内存空间大小是不—样的。</li><li>所以我们在使用递归时，要特别注意这一点，确保递归压栈时不会造成栈溢出。</li></ul></blockquote></blockquote></li></ol><h3 id="三、-执行上下文组成"><a href="#三、-执行上下文组成" class="headerlink" title="三、 执行上下文组成"></a>三、 执行上下文组成</h3><blockquote><p>执行上下文中包含了四个部分：</p><ul><li>变量环境： 其实就是我们之前提到的<strong>变量和函数提升</strong>，在代码执行前变量和函数会被提升到当前作用域的最前面。</li><li>外部环境： 其实就是我们之前了解的<strong>作用域链</strong>，他记录了当前作用域及他的外层作用域之间的关系，我们查找变量在当前作用域中找（当前变量环境中找）找不到再到外部外境（沿着作用域链去查找）</li><li>this： 就是我们前面讲的this，<strong>函数上下文对象</strong>，谁把函数当成方法来调用，this 就指向谁</li><li>词法环境： ES6 中需要学习到的<strong>let 和 const 声明</strong>的变量，是保存在词法环境中。</li></ul></blockquote><h4 id="变量环境"><a href="#变量环境" class="headerlink" title="变量环境"></a>变量环境</h4><blockquote><ul><li>在变量环境中存在一个<strong>变量环境对象</strong>（viriable Environment），叫<strong>变量对象</strong> 。英文全称 variable Object 简称 <code>VO</code></li><li>在这个执行上下文中，所有由<strong>var声明的变量和函数</strong>等都存在于这个 “变量对象” 上。</li><li>JavaScript 代码<strong>不能直接访问</strong>该 “变量对象” ，但是可以直接访问该对象的成员。(除全局上下文的变量对象window以外)<img src="变量对象.png"></li></ul></blockquote><ol><li><p>全局执行上下文中 - 变量对象</p><blockquote><ul><li>全局上下文是<strong>最外层</strong>的上下文，全局执行上下文中的<strong>变量对象</strong>就是<strong>window对象</strong></li><li>因此全局变量和全局函数都会成为 window 对象的属性和方法。</li><li>在<code>Node</code>环境中，全局执行环境是<code>global</code>对象</li><li>在全局上下文中，<code>this</code>指向 window 对象<blockquote><p>注意： JavaScript 中没法直接访问到 “变量对象” ，除全局上下文的变量对象window以外</p></blockquote></li></ul><pre><code>var a = 1;function fn() &#123;  console.log(2);&#125;console.log(this === window); // true 全局上下文中，this指向windowconsole.log(window.a); // 1  通过window对象的属性a可以访问到变量awindow.fn(); // 2 通过window对象的方法fn可以访问到fn函数</code></pre></blockquote></li><li><p>函数上下文中 - 变量对象</p><blockquote><ul><li>在函数执行上下文中，变量对象常常被称为“<strong>活动对象</strong>（Activation Object）简称 <code>AO</code>” ，因为变量对象是在进入函数执行上下文时被创建的（被激活）的。</li><li>刚开始，活动对象上只有 <code>arguments</code> 这一个属性，其后函数中的变量、函数、参数都被保存在这个 <strong>活动对象（AO）</strong> 上，成为了这个活动对象的 <strong>属性 和 方法</strong><blockquote><p>我们直接访问函数中的变量，参数，函数，arguments，本质就是在访问 “活动对象” 上的属性。</p></blockquote></li></ul></blockquote></li></ol><blockquote><pre><code>function sum(c) &#123;  var a = 2;  var b = 3;  console.log(arguments);  console.log(a, b, c);&#125;sum(1);</code></pre></blockquote><p>&#x2F;&#x2F; 当前会创建全局执行上下文，然后执行到sum(1)时，会创建函数执行上下文<br>&#x2F;&#x2F; 函数执行上下文中会创建一个活动对象，其内变量a,b和参数c，arguments都是活动对象的属性,包括 this</p><blockquote><pre><code>&gt;在函数执行上下文中，this 对象保存在活动对象上的 this 属性上。</code></pre></blockquote><ol start="3"><li><p>eval 执行上下文 - 变量对象</p><blockquote><ul><li>创建 eval 函数是为了将字符串转换为可执行的 JavaScript 代码。虽然看起来很强大，但不建议使用这个功能，因为我们无法控制它的权限。</li><li>eval 函数的使用可能会使您的应用程序或服务受到注入攻击。 eval 函数接收到的字符串可能是恶意字符串，可以完全破坏您的数据库或应用程序。</li><li>这就是为什么不推荐使用 eval 函数的原因,也就不做介绍。</li></ul></blockquote></li><li><p>变量对象的创建过程</p><blockquote><pre class=" language-js"><code class="language-js"><span class="token keyword">var</span> sum<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span><span class="token keyword">function</span> <span class="token function">fn</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span>n<span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>  <span class="token keyword">var</span> b <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span>   <span class="token keyword">function</span> <span class="token function">num</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span><span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>   <span class="token keyword">var</span> c <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span><span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span><span class="token punctuation">;</span>   b <span class="token operator">=</span> <span class="token number">3</span><span class="token punctuation">;</span> <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span><span class="token function">fn</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span> </code></pre></blockquote></li></ol><p><strong>全局执行上下文中变量创建过程</strong></p><blockquote><ul><li>当页面打开，碰到script标签，就会开始解析里面的代码，开始预编译</li><li>创建全局执行上下文，并创建window这个变量对象</li><li>全局执行上下文中声明的变量和函数，就成为了window对象上的属性和方法<ul><li>window.sum&#x3D;undefined; window.fn&#x3D;fn</li></ul></li><li>预编译结束，开始从上往下<strong>执行代码</strong><ul><li>window.sum&#x3D;1 </li><li>碰到fn(1) 开始调用函数</li></ul></li></ul></blockquote><p><strong>函数内部的变量对象创建过程</strong></p><ul><li>函数被调用，会创建函数执行上下文，并创建活动对象AO<blockquote><ul><li><code>var AO = &#123;&#125;; </code></li></ul></blockquote></li><li>初始化活动对象的第一个属性arguments<blockquote><pre><code>// 1、创建 AO 变量对象AO = &#123;// 2、创建arguments属性，其属性值为Arguments对象arguments: &#123;  0: 1, // 实参  length: 1, // 实参个数  // ..... 其它属性省略&#125;,&#125;;</code></pre></blockquote></li><li>处理形参与实参<blockquote><ul><li>函数的 所有形参的名称和实参对应 组成变量对象的属性,</li><li>如果没有实参，属性值设为 undefined。</li></ul><pre><code>// 1、创建 AO 变量对象AO = &#123;  // 2、创建arguments属性，其属性值为Arguments对象  arguments: &#123;      0: 1, // 实参      length: 1, // 实参个数      // ..... 其它属性省略  &#125;，  // 3、 寻找函数形参，作为变量对象的属性，同时赋值  a:1,  n:undefined,&#125;</code></pre></blockquote></li><li>处理函数体内的函数声明<blockquote><ul><li>函数体内的<strong>函数声明</strong>的名称和对应值变成变量对象的属性和值</li><li>如果变量对象已经存在相同名称的属性，则会完全替换这个属性。</li><li>没加var的是全局变量，不执行<blockquote><p>上面这个过程，就是我们之前提到变量与函数提升</p><ul><li>函数声明提升的优先级是高于变量提升，本质就是在变量对象初始化属性时，同名的方法会替换掉同名的属性。</li><li>如果是同名的函数，则以后面写在后面的为主。</li></ul></blockquote></li></ul><pre><code>// 1、创建 AO 变量对象AO = &#123;  // 2、创建arguments属性，其属性值为Arguments对象  arguments: &#123;      0: 1, // 实参      length: 1, // 实参个数      // ..... 其它属性省略  &#125;，  // 3、 寻找函数形参，作为变量对象的属性，同时赋值  a:1,  n:undefined,  // 4、寻找函数声明 function num()&#123; &#125;，将num为变量对象属性，值为函数本身 num: function () &#123;&#125;,&#125;</code></pre></blockquote></li><li>处理函数体内的变量声明<blockquote><ul><li>变量声明的名称和对应值（undefined）组成变量对象的属性</li><li>到了执行阶段才会赋值，此时变量值都是undefined</li><li>如果变量名称与已经声明的形参或函数名相同，则变量声明<strong>不会覆盖</strong>已经存在的这类属性。<blockquote><p>原因：变量与函数提升</p><ul><li>变量对象的创建过程，就是我们之前提到的变量的提升，变量提升,提升的是变量，并不会提升值，所以创建出来的属性，默认值是 undefined</li><li>同时同名的变量不会覆盖同名函数，同名的变量和变量本质覆盖与不覆盖没有区别。</li></ul></blockquote></li></ul><pre><code>// 1、创建 AO 变量对象AO = &#123;  // 2、创建arguments属性，其属性值为Arguments对象  arguments: &#123;      0: 1, // 实参      length: 1, // 实参个数      // ..... 其它属性省略  &#125;，  // 3、 寻找函数形参，作为变量对象的属性，同时赋值  a:1,  n:undefined,  // 4、寻找函数声明 function num()&#123; &#125;，将num为变量对象属性，值为函数本身 num: function () &#123;&#125;,  // 5、寻找var声明的变量，将变量b作为变量对象的属性，值为undefinedb: undefined,c: undefined, &#125;</code></pre></blockquote></li><li>预编译结束，开始从上往下<strong>执行代码</strong><blockquote><ul><li>修改变量对象上属性 b 的值为 2</li><li>修改变量对象属性 c 的值</li><li>再次修改变量对象属性 b 的值</li></ul><pre><code>AO = &#123;arguments: &#123;  0: 1,  length: 1,  // ..... 其它属性省略&#125;,a: 1,//实质上是AO.an:undefined,num: function num() &#123;&#125;,b: 3, // 1、修改属性b的值c: function () &#123;&#125;,&#125;; </code></pre></blockquote></li><li>通过控制台，查看整个fn()函数执行完时，整个变量对象上的属性值<img src="变量对象创建过程.png"></li></ul><h4 id="外部环境（outer）"><a href="#外部环境（outer）" class="headerlink" title="外部环境（outer）"></a>外部环境（outer）</h4><blockquote><ul><li>其实，在 JS 中，每个函数都存在一个<strong>隐式属性</strong><code>[[scopes]]</code>, 这个属性用来保存<strong>当前函数</strong>的<strong>外部</strong>执行上下文中的变量对象身上的<strong>一些属性</strong>, 由于在数据结构上是链式的, 也被称为<strong>作用域链</strong>。</li><li>只有当<strong>内部</strong>执行上下文中<strong>引用</strong>了<strong>外部</strong>执行上下文中的<strong>变量</strong>（AO 对象上的属性或方法）时，其外部执行上下文中变量对象的属性值才会被<strong>记录</strong>在隐式属性<code>[[scopes]]</code>中,<strong>除</strong>全局执行上下文中的变量对象 <code>window</code> 外。</li></ul></blockquote><blockquote><pre><code>var a = 1;function fn1() &#123;  var b = 2;  var c = 3;  var d = 4;  function fn2() &#123;    console.log(b);  &#125;  fn2();&#125;fn1();</code></pre><img src="外部环境.png"></blockquote><blockquote><blockquote><p>作用域链</p></blockquote><ul><li>外部环境<strong>本质</strong>就是我们之前提到的作用域链，外部环境中记录了外部执行上下文中变量对象身上的一些属性和方法。</li><li>当我们在变量查找时，如果当前执行上下文的变量对象上找不到，则会去当前执行上下文的外部上下文的 <strong>“变量对象”（其实是闭包对象）</strong>上去查找。</li><li>如果找到就用，找不到就会一直找到全局执行上下文的变量对象 <code>window</code> 身上。还找不到，就会<strong>报错</strong>。</li></ul></blockquote><ol><li>变量查找过程<blockquote><pre><code>var a = 1;function fn1() &#123;  var b = 2;  var c = 3;  var d = 4;  function fn2() &#123; var e = 5; console.log(e + b + a);  &#125;  fn2();&#125;fn1();</code></pre></blockquote></li></ol><ul><li>第一步：创建全局执行上下文</li><li>第二步：执行全局上下文中的代码<blockquote><ul><li>从上往下执行代码，首先变量 a 赋值为 1</li><li>同时遇到<code>fn1()</code>，调用<code>fn1()</code>函数，<strong>创建</strong>函数执行上下文，并<strong>压入</strong>执行上下文栈</li></ul></blockquote></li><li>第三步：执行 fn1 函数上下文中的代码<blockquote><ul><li>首先给变量赋值 <code>b=2，c=3，d=4，fn1 = function()&#123;....&#125;</code></li><li>同时遇到<code>fn2()</code>，调用<code>fn2()</code>函数，创建函数执行上下文，并压入执行上下文栈</li></ul></blockquote></li><li>第四步：执行 fn2 函数执行上下文中的代码<blockquote><ul><li>首先给变量 e 赋值，<code>e=5</code></li><li>然后执行 <code>console.log(e+b+a);</code>代码</li><li>首先在<strong>当前作用域</strong>（执行上下文）中的<strong>词法环境</strong>中找变量 e，没有找到，再到<strong>变量环境的变量对象</strong>上找 e，找到e&#x3D;5，并使用</li><li>然后在当前作用域中的词法环境中去找变量 b，没有找到，则到变量环境中的变量对象上找变量 b，没有找到，则沿着<strong>外部环境</strong>去其外层的作用域中去查找。</li><li>在外层作用域中查找时，也是<strong>先到词法环境</strong>中找，找不到再到<strong>变量环境</strong>中找，再找不到就再到其<strong>外部环境</strong>中去找，一层一层找，找到就用，找不到一直找到全局作用域中，还没找到，就报错。</li><li>变量 e，b，a 的查找流程图如下<img src="变量查找过程.png"></li></ul></blockquote></li><li>第五步：fn2 执行完，开始出栈</li><li>第六步：fn1 执行完，开始出栈</li><li>全局执行上下文要等整个页面关闭后才会被销毁，才会出栈。</li></ul><ol start="2"><li>控制台演示<img src="外部环境控制台.png"></li></ol><blockquote><blockquote><p>详细解读</p></blockquote><ul><li>只有内部函数引用了外部函数中的部分变量，部分变量才会被保存在函数的<code>[[scopes]]</code>属性中</li><li>内部函数在变量查找时，在自己作用域中找，找不到再到<code>[[scopes]]</code>属性中一层一层向下找</li><li><code>[[scopes]]</code>属性中，本质记录的是全局作用域的变量对象 window 和每一次内部形成的闭包对象</li></ul></blockquote><h4 id="词法环境"><a href="#词法环境" class="headerlink" title="词法环境"></a>词法环境</h4><blockquote><ul><li><code>ES6</code>中利用<code>let</code>和<code>const</code>声明的变量，会放在词法环境中。</li><li>在变量查找时，<strong>首先</strong>会在词法环境中去查找，如果找不到，再到变量环境中查找。</li></ul><pre><code>var a = 1;let b = 2;const c = 3;console.log(a + b + c);</code></pre><img src="词法环境.png"></blockquote><h4 id="this-函数上下文"><a href="#this-函数上下文" class="headerlink" title="this 函数上下文"></a>this 函数上下文</h4><blockquote><ul><li>在函数中，其内部this指向把函数当成方法调用的上下文对象</li><li>参考下面的表格自己复习下<table><thead><tr><th>函数的调用方式</th><th>this 指向</th></tr></thead><tbody><tr><td>对象.函数()</td><td>对象</td></tr><tr><td>函数()</td><td>window</td></tr><tr><td>IIFE</td><td>立即执行函数</td></tr><tr><td>数组<a href="">下标</a></td><td>数组</td></tr><tr><td>call(对象,arg1,arg2)</td><td>对象</td></tr><tr><td>apply(对象，array)</td><td>对象</td></tr><tr><td>bind(对象，arg1,arg2)</td><td>对象</td></tr><tr><td>定时器中的回调函数</td><td>window</td></tr><tr><td>DOM 事件处理函数</td><td>添加事件监听的元素</td></tr><tr><td>new 函数()</td><td>对象的实例</td></tr></tbody></table></li></ul></blockquote><h3 id="四、闭包"><a href="#四、闭包" class="headerlink" title="四、闭包"></a>四、闭包</h3><blockquote><p>至于<strong>什么是闭包</strong>？我们暂且先放下，我们通过两个案例来理解，什么是闭包，什么情况下会形成闭包。</p></blockquote><h4 id="什么情况下会形成闭包"><a href="#什么情况下会形成闭包" class="headerlink" title="什么情况下会形成闭包"></a>什么情况下会形成闭包</h4><ol><li>形成闭包的条件——情况一<blockquote><ul><li>内部函数访问外部函数的变量时，其内部就会形成闭包。</li><li>但这种方式，并<strong>不能保持</strong>闭包，因为函数执行完就被销毁了，其闭包对象也被销毁。</li></ul><pre><code>function fn() &#123;  var a = 1;  var b = 2;  function fn2() &#123; // 内部函数访问了外部函数中的变量，这时候就形成了闭包， console.log(a);  &#125;  fn2();&#125;fn();</code></pre></blockquote></li></ol><ul><li>闭包形成过程<blockquote><ul><li>当调用fn()函数时，其内部的fn2函数<strong>引用</strong>了fn函数中的变量a，这时fn函数就会形成闭包。</li><li>他内部创建了一个<strong>新对象</strong>，把内部函数用到的变量a和对应的值成为了这个新对象的属性和值，这个新对象就是我们说的闭包<code>Closure</code></li></ul></blockquote></li><li>闭包带来的便利-方便变量查找<blockquote><ul><li>当fn2()函数调用时，就会访问变量a，他首先会在自己作用域（执行上下文）中找，找不到</li><li>然后就在闭包对象中去查找，找到中了变量a。最终在控制台输入 1</li><li>假设没有闭包对象，那他要去外层作用域中找，外层作用域中如果有 100 个就变量，那要从 100 个变量中找到一个方便 ，还是把用到的那一个存好，直接拿来用方便呢？肯定是后者。</li></ul></blockquote></li><li>闭包销毁<blockquote><ul><li>最后fn2执行完就销毁，其对应的闭包也就随着销毁</li><li>所以这种情况下会形成闭包，但闭包不能被保持。所以我们很多时候讨论的闭包并不是这种情况。<blockquote><p>但内部函数能快速访问到外部函数作用域中的变量，本质就是因为形成了闭包。</p></blockquote></li></ul></blockquote></li></ul><ol start="2"><li>形成闭包的条件——情况二<blockquote><ul><li><strong>内部</strong>函数使用了<strong>外部</strong>函数的<strong>变量</strong>，同时<strong>被返回</strong>到了外部函数的外面(被全局变量接收)，这时就会形成闭包</li><li>主要表现在于，在<strong>外部执行</strong>被返回的函数时，可以访问他在<strong>定义时</strong>所处环境中的变量</li><li>这种情况才是真正意义上的形成了闭包，因为闭包被保持下来，供后期使用</li></ul><pre><code>function fn() &#123;  var a = 1;  var b = 2;  function fn2() &#123; console.log(a);  &#125;  return fn2;&#125;var fn3 = fn(); // 被赋值fn3();</code></pre></blockquote></li></ol><ul><li><p>闭包形成过程</p><blockquote><ul><li>当代码执行到<code>fn3=fn()</code>时，fn()被调用了，因为fn2函数引用了fn函数中的变量a，这时fn函数就会形成闭包</li><li>他内部创建了一个<strong>新对象</strong>，把内部函数用到的变量a和对应的值成为了这个新对象的属性和值，这个新对象就是我们说的闭包（Closure）</li></ul></blockquote></li><li><p>闭包是如何保持的</p><blockquote><ul><li>然后 <code>fn2</code> 函数的隐式属性<code>[[Scopes]]</code>数组中，多了一个新的<strong>对象</strong>，这个对象指向上面 fn 创建出来的闭包。</li><li>然后fn2被当成返回值，返回给到了变量fn3。</li><li>fn()函数执行完，就被销毁了，<strong>但是</strong>他创建的闭包并没有销毁，一直存在内存中</li><li>因为fn3在何时调用，调用多少次这个说不定，只要 fn3 被调用，就会执行 fn2 中的代码，就会访问变量 a,所以 fn 函数形成的闭包并不会随着 fn 函数的销毁而被销毁，而是一直存在于内存中。</li></ul></blockquote></li><li><p>闭包带来的便利-<strong>函数体外</strong>可以访问函数内部的变量</p><blockquote><ul><li>只要我们执行fn3，就相当于执行fn2中的代码，就会访问变量a，他在当前fn2的作用域中找不到，就会去他的隐式属性<code>[[Scopes]]</code>即作用链中去查找，因为之间有闭包存在，所以他会先在闭包中找。找到了a，就打印出来。</li></ul></blockquote></li></ul><ol start="3"><li>总结闭包形成的两种情况</li></ol><ul><li>情况一：<blockquote><ul><li>当内部函数访问了外部函数的变量时，就会形成闭包，但这种情况下闭包不能保持，内部函数执行完，闭包就销毁了。</li></ul></blockquote></li><li>情况二：<blockquote><ul><li>内部函数使用了外部函数的变量，同时被返回到了外部函数的外面，这时就会形成闭包。这种情况下闭包能被保持，一直在保存在内存中。被返回到外部的函数，不管何时执行，执行多少次，都可以访问到他在定义时所在作用域中的变量。</li></ul></blockquote></li></ul><blockquote><blockquote><p>我们通常说说的闭包，指的是第二种情况下形成的闭包，因为第一种情况没有办法保持。</p></blockquote></blockquote><h4 id="什么是闭包"><a href="#什么是闭包" class="headerlink" title="什么是闭包"></a>什么是闭包</h4><blockquote><ul><li><strong>闭包</strong>（closure）是一个函数以及其捆绑的周边环境状态（lexical environment，<strong>词法环境</strong>）的引用的组合。</li><li>换而言之，闭包让开发者可以从内部函数访问外部函数的作用域。</li><li>在 JavaScript 中，闭包会随着函数的创建而被同时创建。<img src="闭包.png"></li></ul></blockquote><blockquote><blockquote><p>可以理解为是函数的一种性质，他能记住他在声明时所处的环境状态。那么不管后来函数在什么第三方被调用，他都能访问他在<strong>定义时</strong>所处作用域中的变量。</p></blockquote></blockquote><h4 id="闭包与作用域链的关系"><a href="#闭包与作用域链的关系" class="headerlink" title="闭包与作用域链的关系"></a>闭包与作用域链的关系</h4><blockquote><ul><li>每个函数身上都有一个<code>[[Scopes]]</code>属性， 这个属性用来保存<strong>当前函数</strong>所有用到的闭包对象和<strong>全局</strong>执行上下文对象(window)。<img src="隐式属性的值.png"></li></ul></blockquote><blockquote><ul><li>当内部函数引用了外部函数中的变量时，就会形成闭包，这个闭包对象中保存了内部函数引用外部函数中的那些变量。 当前函数身上的<code>[[Scopes]]</code>属性中，保持了对这个闭包对象的引用。</li><li>作用域链查找，本质就是先在当前作用域中找，如果找不到，就会去函数的<code>[[Scopes]]</code>属性中保存的闭包对象和全局对象中去找。</li></ul></blockquote><h4 id="闭包的用途"><a href="#闭包的用途" class="headerlink" title="闭包的用途"></a>闭包的用途</h4><blockquote><p>闭包有两大特性：记忆性、模拟私有变量</p><ul><li>记忆性： 当闭包产生时，函数所处环境的状态会始终保持在内存中，不会在外层函数调用后被自动清除，这就是闭包的记忆性。</li><li>模拟私有变量： 我们可以把一些不需要的全局变量封装成“私有变量”。</li></ul></blockquote><ol><li>闭包记忆性案例<blockquote><ul><li>创建体温检测函数 checkTemp(n)，可以检查体温 n 是否正常，函数会被返回布尔值，体温正常会返回true，体温不正常会返回false</li><li>但，不同的小区有不同的体温检测标准：</li><li>比如：A 小区体温合格线是 37.1 ℃，而 B 小区体温合格线是37.5 ℃，应该怎样编程呢 ？</li></ul><pre><code>function creatChack(standardTemp) &#123;return function checkTemp(Temp) &#123;  return Temp &lt; standardTemp;&#125;; &#125; //建立标准 var fn = creatChack(37.1); console.log(fn); //   f checkTemp(Temp) &#123; //       return Temp &lt; standardTemp;</code></pre></blockquote></li></ol><p> &#x2F;&#x2F;     };<br> &#x2F;&#x2F;输入体温<br> console.log(fn(38)); &#x2F;&#x2F;false</p><blockquote><pre><code></code></pre></blockquote><ol start="2"><li>模拟私有变量</li></ol><ul><li>题目：请定义一个变量 a，要求是能保证这个 a 只能被进行指定操作（如：加 1、乘 2），而不能进行其他操作，应该怎么编程呢 ？<blockquote><pre><code>function self() &#123; var a = 1; return &#123;   getA: function () &#123;     return a;   &#125;,   add: function () &#123;     a++;   &#125;,   pow: function () &#123;     a *= 2;   &#125;, &#125;; &#125; var obj = self(); // 如果想在fun函数外边使用变量a，唯一的方法就是调用getA()方法 console.log(obj.getA()); //1 // 如果需要变量+1只能调用add方法 obj.add(); //1+1 console.log(obj.getA()); //2 // 如果需要变量+1只能调用pow方法 obj.pow(); //2*2 console.log(obj.getA()); //4 obj.pow(); //4*2 console.log(obj.getA()); //8</code></pre></blockquote></li></ul><blockquote><blockquote><p>注意：</p></blockquote><ul><li>函数身上的<code>[[Scopes]]</code>属性是对闭包对象的引用</li><li>闭包是一个对象，是一个引用数据类型，存储在堆内存中</li><li>getA(),add(), pow()中的a都是指向同一个堆内存地址</li></ul></blockquote><h3 id="五、垃圾回收-GC"><a href="#五、垃圾回收-GC" class="headerlink" title="五、垃圾回收 GC"></a>五、垃圾回收 GC</h3><h4 id="什么是垃圾回收（Garbage-Collection）？"><a href="#什么是垃圾回收（Garbage-Collection）？" class="headerlink" title="什么是垃圾回收（Garbage Collection）？"></a>什么是垃圾回收（Garbage Collection）？</h4><blockquote><ul><li>在现实生活中，所谓的垃圾，就是指用过了，不会再用的东西，就可以当成垃圾被处理掉。</li><li>在 JS 中，所谓的垃圾，你可以理解为那些不会再被使用的数据，就会被当成垃圾回收掉</li><li>JavaScript 中 JS 引擎会<strong>自动回收</strong>不再使用的变量，释放其所占的内存，开发人员不需要手动的做垃圾回收的处理。<blockquote><p>但最艰难的任务是找到那些变量将不会再使用，释放其“占用的内存”</p></blockquote></li></ul></blockquote><ol><li>我们来看下面几个例子，分析下，其中的变量否会被当成垃圾回收掉</li></ol><ul><li><p>下面代码执行完后，其变量 a 和 obj 还会占用内存空间吗？</p><blockquote><pre><code>function fn() &#123;var a = 1;console.log(a);var obj = &#123;  name: &quot;张三&quot;,  age: 23,&#125;;console.log(obj);&#125;fn(); // 执行函数</code></pre></blockquote><p>&#x2F;&#x2F; 上面fn()函数执完后，变量中的a 和obj就会被销毁掉，不会再占用内存的空间了。<br>&#x2F;&#x2F; 当然垃圾回收，并不会立刻马上就回收，他可以马上，也可以会等一会儿，但时间不会太久<br>&#x2F;&#x2F; 函数执行完，里面的数据都不会再被其它对象引用，也就会当成垃圾被处理掉</p><blockquote><pre><code></code></pre></blockquote></li><li><p>下面代码执行完后，其变量 a 和 obj 还会占用内存吗 ？</p><blockquote><pre><code>function fn() &#123;var a = 1;var obj = &#123;  name: &quot;张三&quot;,  age: 23,&#125;;window.a = a;window.obj = obj;&#125;fn(); // 执行函数// fn()函数执行后，变量a和obj被赋值给了window对象的属性，也就是全局对象window保持了对变量a和obj的引用。说不定什么时候我们就可以需要用到window.a和window.obj// 所以这种情况下 变量a被销毁，但是window.a上的a属性和obj中的引用对象并不会被销毁// 但这里的obj和window.a并不是垃圾，因为我们在后面还需要用到他。// 以上变量占用内存，是符合用户预期的</code></pre></blockquote></li><li><p>下面代码执行完后，a 和 b 还会占用内存吗 ？</p><blockquote><pre><code>function fn() &#123;var a = 1;var b = 2;function sum() &#123;  console.log(a + b);&#125;return sum;&#125;var s = fn(); // 调用函数s(); // 调用函数</code></pre></blockquote><p>&#x2F;&#x2F; 上面代码执行完后，a，b并不会被销毁会，因为形成了闭包，我们不知道什么进候，我们还会调用s();<br>&#x2F;&#x2F; 如果我们把变量a,b销毁了的话，那我们后面如果要调用s()，那不就会报错吗？<br>&#x2F;&#x2F; 这种情况下闭包就会造成变量不能被销毁，一直占用内存。那这算是内存泄露吗？<br>&#x2F;&#x2F; 这种情况，我们是有意想要形成闭包，人为的希望局部变量a和b能一直保存在内存中，所以不能算内存泄露</p><blockquote><pre><code></code></pre></blockquote></li></ul><blockquote><blockquote><p>总结：</p></blockquote><ul><li>如果某些数据我们未来还有可能会用到，那么他一直占用内存是符合用户期望的，并不能算垃圾，所以也不能当成垃圾回收掉。</li><li>只有那些被执行完，未来不可能再用到的数据，就是垃圾，就可以当成垃圾被回收掉。</li><li>那 JS 是如何判断那些数据未来永远都不可能用到呢 ？然后把他当成垃圾回收掉呢 ？</li></ul></blockquote><h4 id="JS-中垃圾回收的两种策略"><a href="#JS-中垃圾回收的两种策略" class="headerlink" title="JS 中垃圾回收的两种策略"></a>JS 中垃圾回收的两种策略</h4><blockquote><p>垃圾回收主要有两种策略，标记清理和引用计数。</p></blockquote><ol><li>引用计数<blockquote><ul><li>引用计数其实是一种比较老的垃圾回收策略</li><li>引用计数就是追踪<strong>值</strong>被引用的次数。</li><li>声明变量并给它赋一个<strong>引用类型</strong>值时，这个值的引用数为 1，如果同一个值又被赋给另一个变量，那引用数+1</li><li>如果保存该值引用的变量被其它值<strong>覆盖</strong>了，则引用数减 1</li><li>当引用计数为 <code>0</code> 时，表示这个值不再用到，垃圾收集器就会回收他所占用的内存。</li></ul><pre><code>var a = [1, 2, 3]; // [1,2,3]的引用计数为1var b = a; // 变量b也引用了这个数组，所以[1,2,3]的引用数为2var a = null; // [1,2,3]的引用被切断，引用数-1，所以[1,2,3]的引用数为1// 如果只是到这里，那[1,2,3]不所占的内存不会被回收var b = null; // [1,2,3] 的引用被切断，引用数-1，所 [1,2,3]的引用数为0// 到这里，垃圾收集器在下一次清理内存时，就会把[1,2,3]所占的内存清理掉</code></pre></blockquote></li></ol><ul><li>但引用计数有一个很大的坑，就是循环引用时，会造成内存永远无法释放。<blockquote><pre><code>function fn() &#123;var obj1 = &#123;&#125;;var obj2 = &#123;&#125;;obj1.a = obj2;obj2.a = obj1;&#125;fn();// 这种情况下，fn函数执行完后，其内部的obj1和obj2已经没有用了，可以被回收了。// 但引用计数统计到他们引用数&gt;0,则 obj1和obj2就没有办法被清理了，因为引用数永远不可能为0</code></pre><img src="引用计数缺陷.png"></blockquote></li></ul><blockquote><ul><li>fn 执行上下文在代码执行完后，就<strong>出栈</strong>，意味着 obj1 与 obj2 被销毁，不会再有指向堆内存中的引用</li><li>但是堆内存中的数据，引用数&gt;0,所以永远都不会被销毁</li></ul></blockquote><ol start="2"><li>标记清理<blockquote><ul><li>这个算法假定设置一个叫做<strong>根（root）</strong>的对象（在 JavaScript 里，根是<strong>全局对象</strong> <code>window</code>）</li><li>垃圾回收器将定期从根开始，找所有从根开始引用的对象，然后找这些对象引用的对象……</li><li>从根开始，垃圾回收器将找到所有可以获得的对象和收集所有不能获得的对象。</li><li>那些<strong>无法</strong>从根对象查询到的对象都将被清除<br>如果用标记清理的方式来处理垃圾回收，则就不会出现上面循环引用的问题，造成垃圾不能回收了<br>因为函数调用之后，两个对象 obj1 和 obj2 <strong>都无法</strong>从全局对象出发获取。因些，他们将会被垃圾回收器回收掉。<blockquote><p>从 2012 年起，所有现代浏览器都使用了标记 - 清除垃圾回收算法</p></blockquote></li></ul></blockquote></li></ol><blockquote><blockquote><p>JS引擎的自动垃圾回收功能并不是全能的</p></blockquote></blockquote><h4 id="手动标记垃圾"><a href="#手动标记垃圾" class="headerlink" title="手动标记垃圾"></a>手动标记垃圾</h4><blockquote><ul><li>通过上面两种垃圾加收的策略，我们知道，在全局作用域中的变量永远都可以从全局对象上获取到。所以永远不会自动回收。</li><li>所以我们在写代码时，尽量要<strong>避免</strong>不要把一些变量设置为全局变量，如果实在要设为全局变量，那我们使用完后不再需要，那我们就需要<strong>手动将其标注为垃圾</strong>，让垃圾回收器回收掉。</li><li>手动标记垃圾的方式，本质就是<strong>切断引用</strong>，常用的方式就是把变量的值重新赋值为 <code>null</code></li></ul><pre><code>var obj = &#123;  name: &quot;张三&quot;,  age: 23,&#125;;// 标记为垃圾，垃圾回收器就会自动回收掉内存中的 &#123; name:&#39;张三&#39;,age:23&#125; 这个对象占用的空间obj = null;</code></pre></blockquote><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><blockquote><ul><li>所谓的垃圾可以理解为，<strong>非用户预期的内占存用</strong>，那么这些占用内存的数据就可以理解为垃圾，应该回收掉。如果是用户预期的内存占用，那都不能算是垃圾。</li><li>如果有些变量我们不再需要，而<strong>垃圾回收器无法识别</strong>，那我们就可以手动将其标记为垃圾。即把变量的值起来 <code>null</code></li></ul></blockquote><h4 id="闭包与内存管理"><a href="#闭包与内存管理" class="headerlink" title="闭包与内存管理"></a>闭包与内存管理</h4><blockquote><ul><li>我们经常听说闭包会造成内存泄露，所谓<strong>内存泄漏</strong>是指程序中已动态分配的内存由于某种原因<strong>未释放或无法释放</strong></li><li>那闭包会造成内存泄露吗 ？ 我们来看下这段代码：</li></ul><pre><code>// 设置当地的一个参考分数线，然后输入你的分数，查看是否超过分数线function compare(score1) &#123;  return function (score) &#123;    if (score1 &gt; score) return &quot;分数线过底不达标&quot;;    return &quot;恭喜，分数线超过一本&quot;;  &#125;;&#125;// 北京1本录取分数线var fn = compare(530);// 小明的分数是540console.log(fn(540));</code></pre></blockquote><ul><li>代码解读<blockquote><ul><li>上面代码中的 <code>score1</code> 变量在<strong>页面没有关闭前</strong>，永远都不会被销毁</li><li>因为内部函数作为返回值被返回，同时内部函数引用了变量 <code>score1</code>，所以就形成了<strong>闭包</strong>。闭包对象中包含了属性 <code>score1</code>，</li><li>但是，我们使用闭包，<strong>本质也是为了用他的这个特性，希望局部变量能被保存在内存中，不要销毁</strong>。如果从这个角度来看，闭包并不能说会造成内存泄露。</li></ul></blockquote></li></ul><blockquote><ul><li>本质上闭包是<strong>有意的</strong>将变量保存在内存中，是<strong>用户预期的内存占用</strong>，所以不能算是内存泄露。</li><li>如果因为<strong>不小心误用了闭包</strong>，而造成某些数据一直占用内存而不能被回收，那就可以理解为因为误用闭包而造成的内存泄露。因为闭包中的数据，肯定是不能被垃圾加收的。</li><li>不能滥用闭包，否则会造成网页的性能问题，严重时可能会导致内存泄漏</li></ul></blockquote><h4 id="区分内存泄露和内存溢出"><a href="#区分内存泄露和内存溢出" class="headerlink" title="区分内存泄露和内存溢出"></a>区分内存泄露和内存溢出</h4><blockquote><ul><li>内存泄露：是指程序在申请内存后，无法释放已申请的内存空间，一次内存泄露危害可以忽略，但<strong>内存泄露堆积</strong>后果很严重，无论多少内存，迟早会被占光。</li><li>内存溢出： 是指程序在申请内存时，没有足够的内存空间供其使用，内存不足。</li></ul></blockquote><h3 id="六、IIFE-立即执行函数"><a href="#六、IIFE-立即执行函数" class="headerlink" title="六、IIFE 立即执行函数"></a>六、IIFE 立即执行函数</h3><ol><li>什么是 IIFE 立即执行函数?<blockquote><ul><li>IIFE （Immediately Invoked Function Expression）（立即调用的<strong>函数表达式</strong>）</li><li>是一种特殊的 JavaScript 函数写法，一旦被定义，就立即被调用</li></ul></blockquote></li></ol><ul><li><strong>语法：</strong><blockquote><p>声明一个<strong>匿名函数</strong>，也就是没有名字的函数，然后用()把匿名函数转为 <strong>“函数表达式”</strong>，然后再调用</p></blockquote></li><li>写法：<blockquote><pre><code>// 写法一(function () &#123;// 函数体语句&#125;)();</code></pre></blockquote></li></ul><p>&#x2F;&#x2F; 写法二<br>(function () {<br>  &#x2F;&#x2F; 函数体语句<br>})();<br>&#x2F;&#x2F; 以下是错误写法<br>&#x2F;&#x2F; 函数不能直接加圆括号被调用<br>function(){<br>    &#x2F;&#x2F; 函数体语句<br>}();</p><blockquote><pre><code></code></pre></blockquote><blockquote><blockquote><p>温馨提示：</p></blockquote><ul><li>我们之前说，直接用 function 声明的函数称为函数声明，那这里为什么称为函数表达式呢 ？</li><li>是因为<code>()</code>括号的功能，他<strong>将函数变为了表达式</strong>，然后()括号后面的()括号，表示执行函数</li></ul></blockquote><ol start="2"><li>形成 IIFE 的其它方法<blockquote><ul><li>除了用<code>()</code>包裹函数声明，将函数声明转为“函数表达式”之外</li><li>我们还可以在函数声明前添加<code>-</code>或<code>+</code>号，来将函数声明转为“函数表达式”，然后再调用</li></ul><pre><code>(function () &#123;  // 函数体语句&#125;)();</code></pre></blockquote></li></ol><p>+(function () {<br>  &#x2F;&#x2F; 函数体语句<br>})();</p><p>-(function () {<br>  &#x2F;&#x2F; 函数体语句<br>})();</p><blockquote><pre><code></code></pre></blockquote><ol start="3"><li>IIFE 的作用一 ——为变量赋值<blockquote><ul><li>当我们给变量赋值时，其值需要一些较为复杂的计算才能得到，这时候就可以用立即执行函数来实现</li><li>使用 IIFE 显得语法更紧凑</li></ul><pre><code>// 获取一个随机颜色//写法1： var arr = [&quot;red&quot;, &quot;pink&quot;, &quot;skyblue&quot;, &quot;khaki&quot;]; function color() &#123;var i = (Math.random() * arr.length) &gt;&gt; 0;return arr[i]; &#125; console.log(color());</code></pre></blockquote> &#x2F;&#x2F;写法2：使用IIFE<br> var color &#x3D; (function () {<br>var arr &#x3D; [“red”, “pink”, “skyblue”, “khaki”];<br>var i &#x3D; (Math.random() * arr.length) &gt;&gt; 0;<br>return arr[i];<br> })();<br> console.log(color);<blockquote><pre><code></code></pre></blockquote></li></ol><blockquote><ul><li>以上写法，函数不会被其它对象引用，也不能在其它地方被执行。</li><li>如果你的某个函数只是为了一次求值，其它地方也不会再使用他，则可以用 <code>IIFE</code> 来实现。</li></ul></blockquote><ol start="4"><li>IIFE 的作用二 ——将全局变量变为局部变量<blockquote><p>在很多情况下，我们希望将<strong>全局变量转为局部变量</strong>保存起来。</p></blockquote></li></ol><ul><li><p>情况一：</p><blockquote><pre><code>var arr = [];for (var i = 0; i &lt;= 5; i++) &#123;arr.push(function () &#123;  console.log(i);&#125;);&#125;arr[0](); // 6arr[1](); // 6arr[2](); // 6arr[3](); // 6arr[4](); // 6</code></pre><ul><li>i是全局变量，i&#x3D;6;函数arr<a href="">i</a>内没有声明变量i,所以只能向外查找变量，得到i&#x3D;6</li></ul></blockquote></li><li><p>情况二：</p><blockquote><pre><code>var arr = [];for (var i = 0; i &lt;= 5; i++) &#123;// IIFE  本质是，在每一次循环，形成了一次闭包(function (i) &#123;//这里的i是形参，每次循环都会声明变量  arr.push(function () &#123;    console.log(i);  &#125;);&#125;)(i);//这里的i是实参&#125;</code></pre></blockquote><p>arr<a href="">0</a>; &#x2F;&#x2F;0</p><!-- var arr = []; // IIFE  本质是，在每一次循环，形成了一次闭包 (function (i) { i=0; //形成闭包 arr.push(function () {   console.log(i);//从闭包内获取值 }); })(0); --><blockquote></blockquote><p>arr<a href="">1</a>; &#x2F;&#x2F;1<br>arr<a href="">2</a>; &#x2F;&#x2F;2<br>arr<a href="">3</a>; &#x2F;&#x2F;3<br>arr<a href="">4</a>; &#x2F;&#x2F;4</p><blockquote><pre><code></code></pre></blockquote></li></ul><ol start="5"><li>arguments.callee<blockquote><ul><li>arguments 对象身上有一个 callee 属性，是指向 arguments 对象所在函数的指针。</li><li>通过arguments.callee能获取到 arguments 对象所在的<strong>函数</strong>。arguments.callee已经被<strong>弃用</strong>，不应该再使用了，这里只当了解。</li></ul></blockquote></li></ol><ul><li>arguments.callee 的作用<blockquote><ul><li>当我们需要在一个匿名函数内部，调用这个函数自身时，他就非常有用了</li></ul><pre><code>// 输入5的阶乘var n = (function (n) &#123;if (n == 1) return 1;return n * arguments.callee(n - 1);&#125;)(5);console.log(n);</code></pre><blockquote><p>通常在递归调用匿名函数时，就可以用<code>argument.callee</code>来找到匿名函数</p></blockquote></blockquote></li></ul><h3 id="七、JavaScript-错误处理"><a href="#七、JavaScript-错误处理" class="headerlink" title="七、JavaScript 错误处理"></a>七、JavaScript 错误处理</h3><h4 id="常见错误类型"><a href="#常见错误类型" class="headerlink" title="常见错误类型"></a>常见错误类型</h4><blockquote><p>代码执行过程中会发生各种类型的错误，每种类型的错误都对应一个<strong>错误对象</strong>，常见的错误类型有以上 8 种</p><ul><li>SyntaxError 语法错误</li><li>ReferenceError 引用错误</li><li>TypeError 类型错误</li><li>RangeError 范围错误</li><li>URIError URI 错误</li><li>EvalError eval 错误</li><li>InternalError 内部错误（非标准）</li><li>Error 错误对象，用于自定义错误</li></ul></blockquote><p>1、SyntaxError 语法错误</p><blockquote><ul><li>JavaScript 引擎发现了不符合语法规范的代码，会出现此错误</li></ul><pre><code>// 变量名不规范var this = 1;var 2a=3;</code></pre></blockquote><p>&#x2F;&#x2F; if 少了 }<br>if (1) {<br>    console.log(2);</p><blockquote><pre><code></code></pre></blockquote><ol start="2"><li><p>ReferenceError 引用错误</p><blockquote><ul><li>会在找不到对象时发生，比如常见的访问不存在的变量时，就会报引用错误</li></ul><pre><code>console.log(a); // a变量不存在var num = c; // c变是不存在</code></pre></blockquote></li><li><p>TypeError 类型错误</p><blockquote><ul><li>当变量不是预期类型时，就会引发这种类型错误。</li><li>比如常见引发这一错误的行为：把一个基本数据类型当函数调用。</li></ul><pre><code>var a = 1;a();</code></pre></blockquote><p>console.log(“name” in true); &#x2F;&#x2F; true不是一个对象</p><blockquote></blockquote><p>var arr &#x3D; [1, 2, 3];<br>console.log(arr.call(null)); &#x2F;&#x2F; arr 不是一个函数</p><blockquote><pre><code></code></pre></blockquote></li><li><p>RangeError 范围错误</p><blockquote><ul><li>当数字超出允许的值范围时，将会抛出此类型的错误</li></ul><pre><code>var arr = [1, 2, 3];arr.length = -1; // 数组长度</code></pre></blockquote><p>var num &#x3D; 1.233;<br>num.toFixed(-1); &#x2F;&#x2F; 参数在0-100之间</p><blockquote><pre><code></code></pre></blockquote></li><li><p>URIError URI 错误</p></li></ol><ul><li><p>在了解 URIError 错误之前，我们先来了解下什么是 URI、URL、URN</p><blockquote><ul><li>URI（Uniform Resource Identifier）：统一资源标识符 ，用来唯一标识资源，是一种语义上的抽象概念</li><li>URL（Uniform Resource Locator）：统一资源定位符，用来定位唯一的资源， 必须提供足够的定位信息</li><li>URN（Uniform Resource Name）：统一资源名称，定义了资源的身份（命名）<br><strong>他们三者的关系如下图</strong><img src="URI三者关系图.png"></li></ul></blockquote></li><li><p>如果用一个人来做比喻的话</p><blockquote><ul><li>URN 相当人的身份证号，唯 一标识。</li><li>URL 相当于找到这个人的方式，如住址: x 省 xx 市 xx 区 … xx 单元 xx 室的身份证号为 xxx 的人</li><li>URI 相当身份证，上面有身份证号，也有地址。</li></ul></blockquote></li><li><p>如果用一个网址来表示的话</p><blockquote><ul><li>URL: <a href="https://www.arryblog.com/guide/html5/html-html5-course.htm">https://www.arryblog.com/guide/html5/html-html5-course.htm</a></li><li>URN:guide&#x2F;html5&#x2F;html-html5-course.htm</li><li>URI: 可以是上面的 ULR，也可以是 URN</li></ul></blockquote></li><li><p>URIError 错误</p><blockquote><ul><li>URL 错误只会在<code>encodeURI()</code> 和 <code>decodeURI()</code> 传入了格式错误的 URI 时发生。但我们很难看到这种错误，因为前面两个函数非常稳键。</li><li><code>encodeURI()</code> 对传入的 URI 进行编码</li><li><code>decodeURI()</code> 对传入的 URI 进行解码</li></ul><pre><code> var url = &quot;https://www.arryblog.com/html/文档笔记.html&quot;; console.log(encodeURI(url)); console.log(decodeURI(&quot;dd78%&quot;));</code></pre></blockquote></li></ul><ol start="6"><li><p>EvalError eval 错误</p><blockquote><ul><li>在使用<code>eval()</code>函数时发生异常时抛出错误。因为eval被禁用，所以了解就好。</li></ul></blockquote></li><li><p>InternalError（非标准）内部错误</p><blockquote><ul><li>该错误在<strong>JS 引擎</strong>内部发生发生异常时会抛出。如果真发生了这种错误，很可能代码哪里弄错了或者有危险了。</li></ul></blockquote></li><li><p>Error 自定义错误</p><blockquote><pre><code>throw new Error(&quot;自定义错误&quot;);</code></pre></blockquote></li></ol><h4 id="try-…-catch-语句"><a href="#try-…-catch-语句" class="headerlink" title="try … catch 语句"></a>try … catch 语句</h4><blockquote><ul><li>try…catch 语句用来处理 JS 中的异常</li></ul></blockquote><ol><li>语法<blockquote><pre><code>try &#123;  // 可能会出错的代码&#125; catch (e) &#123;  // 出错时要做什么&#125;</code></pre></blockquote></li></ol><blockquote><ul><li>如果try块中的代码发生错误，则会<strong>立即退出执行</strong>，并跳到catch块中，catch块此时会接收到一个<strong>对象</strong>，这个对象包含发生错误的相关信息。</li><li>try捕获到错误后,不会再执行try错误后的代码，同时将错误交给catch来处理，然后再执行后面的代码</li></ul><pre><code>var a = 1;try &#123;  // 可能出错的代码  a();  console.log(22); // 不执行&#125; catch (e) &#123;  // 出错时要做的事  console.log(e); // 执行&#125;console.log(&quot;try后面代码&quot; + a); // 执行</code></pre></blockquote><ol start="2"><li>finally 子句<blockquote><ul><li><code>finally</code>子句是<code>try...catch</code>语句中的一部分，为<strong>可选</strong>的</li><li>不管try中代码是否发生错误，最终都会执行<code>finally</code>子句中的代码</li></ul></blockquote></li></ol><ul><li>语法<blockquote><pre><code>try &#123;// 可能会出错的代码&#125; catch (e) &#123;// 出错时要做什么&#125; finally &#123;//永远都会执行的代码&#125;</code></pre></blockquote></li></ul><blockquote><pre><code>var a = 1;function fn(a) &#123;  try &#123;    // 可能出错的代码    a();    return 1;//不执行  &#125; catch (e) &#123;    // 出错时要做的事    return 2;  &#125; finally &#123;    return 3;//执行  &#125;&#125;console.log(fn(a));</code></pre></blockquote><blockquote><ul><li>try和catch中的return 语句也无法阻止 finally 代码块的执行</li></ul></blockquote><h4 id="throw-抛出自定义错误"><a href="#throw-抛出自定义错误" class="headerlink" title="throw 抛出自定义错误"></a>throw 抛出自定义错误</h4><blockquote><ul><li>throw 操作符，用于抛出<strong>自定义错误</strong>。throw 操作符后面必须有一个<strong>值</strong>，值可以是<strong>任意类型</strong>。</li></ul><pre><code>throw &quot;123&quot;;throw &quot;abc&quot;;throw true;</code></pre></blockquote><p>console.log(2); &#x2F;&#x2F; 不会被执行</p><blockquote></blockquote><p>&#x2F;&#x2F; 使用 throw操作符时，代码立即停止执行，除非用try…catch捕获了抛出的错误</p><blockquote><pre><code></code></pre></blockquote><ul><li>throw 与 try…catch 结合<blockquote><ul><li>可以自定义一个错误类型的消息，浏览器会像处理自己生成的错误一样来处理这个自定义错误</li></ul><pre><code>//当输入的实参不是数组时会报错function fn(arr) &#123;try &#123;  return arr.slice(0, 1);&#125; catch (e) &#123;  throw new TypeError(&quot;arr参数，必须是一个数组&quot;);&#125;console.log(arr); // 上面抛出错误，这里不会执行&#125;fn(1);</code></pre></blockquote></li></ul><h3 id="八、LHS-和-RHS-查询"><a href="#八、LHS-和-RHS-查询" class="headerlink" title="八、LHS 和 RHS 查询"></a>八、LHS 和 RHS 查询</h3><blockquote><p>LHS字面理解是 <code>Left Hand Sid</code> 即左手边，RHS字面理解是 <code>Right Hand Side</code> 即右手边。</p></blockquote><ol><li>LHS 和 RHS <strong>片面</strong>的理解<blockquote><p>一般简单片面的理解为<strong>赋值操作符</strong>的左边和右边</p><ul><li>当<strong>变量</strong>出现在赋值操作符的左侧时进行LHS 查询，出现在右侧时进行RHS 查询</li><li>LHS 查询是试图找到变量的<strong>容器本身</strong>，然后对其<strong>赋值</strong></li><li>RHS 查询是试图找到变量的中<strong>对应的值</strong></li></ul></blockquote></li></ol><blockquote><pre><code>var a;var b;</code></pre></blockquote><p>a &#x3D; 1;<br>b &#x3D; a;</p><blockquote><pre><code></code></pre></blockquote><ul><li>代码解读</li></ul><p><strong>① 编译阶段</strong></p><blockquote><ul><li>会在当前作用域中声明 2 个变量 a 和 b</li></ul></blockquote><p><strong>② 执行阶段</strong></p><blockquote><ul><li>a &#x3D; 1，这里的 <code>a</code> 会进行 <code>LHS</code> 查询，查询<strong>是否存在</strong>变量 a，并不关心 a 的值是什么。如果变量 a 存在，就给他<strong>赋值</strong>为 1</li><li>b &#x3D; a，首先会对 <code>a</code> 进行 <code>RHS</code> 查询，查询是否存在变量 a，存在，并把对应的值 1 拿到</li><li><strong>然后</strong>再对 <code>b</code> 进行 <code>LHS</code> 查询，查询是否存在变量 b，存在，并把对应的值 1 赋值给到变量 b</li></ul></blockquote><ol start="2"><li>LHS 和 RHS 更准确的理解<blockquote><p>通过上面分析，我们知道</p><ul><li>LHS 查询只关心是否存在这个变量，并不关心变量对应的值是什么</li><li>RHS 查询除了关心变量是否存在之外，还关心变量中对应的值，因为最终就是为了找到变量对应值。<br><strong>所以，更准确的说</strong></li><li>LHS 查询可以理解为<strong>赋值操作的目标</strong>是谁 ？ 即我要把值赋值给谁</li><li>RHS 查询可以理解为<strong>赋值操作的源头</strong>是谁？ 我要用什么来内容完成赋值</li></ul></blockquote></li></ol><blockquote><pre><code>function fn(c) &#123;  console.log(c);  console.log(b);  console.log(a);  a = 1;  var b = a;  b();&#125;fn(2);</code></pre></blockquote><ul><li>代码解读</li><li>① 全局代码运行时</li></ul><p><strong>编译阶段</strong></p><blockquote><ul><li>声明函数 <code>fn</code>，fn 是 window 对象身上的属性，即<code>window.fn=function()&#123;......&#125;</code></li></ul></blockquote><p><strong>执行阶段</strong></p><blockquote><ul><li><code>fn(2)</code>在调用前，会对 fn 进行 RHS 查询，查询是否存在 fn，并拿到 fn 的值，然后开始执行</li></ul></blockquote><ul><li>② fn 函数调用时</li></ul><p><strong>编译阶段：</strong></p><blockquote><ul><li>在当前作用域中<strong>声明</strong> 2 个变量 <code>c</code> 和 <code>b</code>，同时<code>c = 2</code></li><li>这个过程 c 也会进行 LHS 查询，找到是否存在变量 c，然后存在将值 2 赋值给到他</li></ul></blockquote><p><strong>执行阶段：</strong></p><blockquote><ul><li>当执行到<code>console.log(c)</code>，会对 c 进行 RHS 查询，取得 c 的值为 2，还会对 console 进行 RHS 查询</li><li>当执行到 <code>console.log(b)</code>，会对 b 进行 RHS 查询，取得 c 的值为 undefined，对 console 进行 RHS 查询</li><li>当执行到<code>console.log(a)</code>，会对 c 进行 RHS 查询，发现找不到变量 a，然后报出 引用错误，….</li><li>当执行到a &#x3D; 1，会对 a 进行 LHS 查询，发现找不到变量 a<ul><li>在非严格模式下，此时会全局作用域中创建一个同名的变量，然后将 1 赋值给 a</li><li>在严格模式下，会报 引用错误，找不到变量 a</li></ul></li><li>当执行到b &#x3D; a<ul><li>首先对 a 进行 RHS 查询，找到变量 a，并取得 a 的值 1</li><li>然后对 b 进行 LHS 查询，找到变量 b，把对应的值 1 赋值给 b</li></ul></li><li>当执行到b()时，会对 b 进行 RHS 查询，找到了，但 b 的值不是一个函数，你对 b 执行函数调用，会抛出类型错误<code>（TypeError）</code></li></ul></blockquote><ol start="3"><li>总结：LHS 和 RHS<br><strong>LHS 查询</strong><blockquote><ul><li>只关心有没有要查找的变量，并不关心变量的值是多少</li><li>如果找到这个变量，就将对应值赋值给他。</li><li>如果找不到，在严格模式下，会报引用错误，非严格模式下，会在全局作用域中创建一个同名的变量</li><li>LHS 查询可以理解为 赋值操作的目标是谁 ？ 即我要把值赋值给谁</li></ul></blockquote></li></ol><p><strong>RHS 查询</strong></p><blockquote><ul><li>他不仅关心有没有要查找的变量，还关心变量的值是多少，最终是要取到变量的值。</li><li>如果找不到变量，则会报引用错误，如果找到，则把对应的值拿到</li><li>如果对找到的变量，做不合理的操作，会抛出类型错误（TypeError）</li><li>RHS 查询可以理解为 赋值操作的源头是谁 ？ 我要用什么来内容完成赋值<blockquote><p>JS 引擎在查找某个变量时，会先判断是要 LHS 查询还是 RHS 查询，然后再根据对应规则去查询变量，做相应处理</p></blockquote></li></ul></blockquote><h3 id="九、单线程的-JavaScript"><a href="#九、单线程的-JavaScript" class="headerlink" title="九、单线程的 JavaScript"></a>九、单线程的 JavaScript</h3><blockquote><p>我们都知道 JS 语言的一大特点就是<strong>单线程</strong>，也就是说，同一个时间只能做一件事。那 JS 为什么要设置成单线程的呢 ？为什么不设置成多线程呢 ？</p><ul><li>JavaScript 的单线程，与它的<strong>用途</strong>有关。作为浏览器脚本语言，JS 的主要用途是<strong>与用户交互，以及操作 DOM</strong>。这就决定了他只能是单线程的，否则会带来很多复杂的同步问题。</li><li>假设 JS 同时有两个线程，一个线程在某个 DOM 节点上添加内容，另一个线程删除了这个节点，这时浏览器应该以哪个线程为准 ？<blockquote><p>所以，为了避免复杂性，从一从一诞生，JavaScript 就是单线程，浏览器中的 JS 执行和 DOM 渲染共用一个线程。</p></blockquote></li></ul></blockquote><h3 id="十、同步任务与异步任务"><a href="#十、同步任务与异步任务" class="headerlink" title="十、同步任务与异步任务"></a>十、同步任务与异步任务</h3><blockquote><ul><li>JS 是单线程的，那就意味着所有的任务需要排队，前一个任务结束，才能执行后一个任务。如果前一个任务耗时很长，后一个任务就不得不一直等着。</li><li>如果因为计算量大，CPU 忙不过来，倒也算了，但是很多时候 CPU 是闲着的，因为 <code>IO</code> 设备（输入输出设备）很慢（比如受网络的影响，外部请求加载一张图片等会很慢），就不得不等着结果出来，再往下执行。这样就造成了 CPU 资源的浪费，因为 CPU 是闲着的，但后面还有很多任务要做又不能做，这样代码的执行效率就变得很低了，因为某个任务过长，就会造成主线程阻塞。</li><li>JS 的语言设计者也意识到了，这时主线程完全可以不管 IO 设备，挂起处于等待中的任务，先运行排在后面的任务。等到 IO 设备返回了结果，再回过头，把挂起的任务继续执行下去。</li></ul></blockquote><blockquote><p>于是，JS 中把任务分成两种：同步任务（synchronous）和异步任务（asynchronous）</p><ul><li>同步任务：是指在主线程上排队执行的任务，只有前一个任务执行完毕，才能执行后一个任务</li><li>异步任务：是指不进入主线程，而进入“任务队列”（task queue）的任务，只有等主线程任务执行完毕，”任务队列”开始通知主线程，请求执行任务，该任务才会进入主线程执行</li></ul></blockquote><blockquote><ul><li>JS 中那些任务是属于同步任务，那些属性异步任务呢 ？<table><thead><tr><th>同步任务</th><th>异步任务</th></tr></thead><tbody><tr><td>大部分代码都是同步任务</td><td>事件、setTimeout、setInterval、requestAnimationFrame、Ajax、fetch、MutationObserver、Promise 的 then 和 catch 方法、async 函数</td></tr></tbody></table><blockquote><p>你可能有这样的疑问：</p></blockquote></li><li>JS 是单线程的，那他的异步任务是谁来负责的，如何被加入到任务队列，这就需要了解浏览器的进程与线程。</li></ul></blockquote><h3 id="十一、浏览器进程与线程"><a href="#十一、浏览器进程与线程" class="headerlink" title="十一、浏览器进程与线程"></a>十一、浏览器进程与线程</h3><blockquote><ul><li>首先我们要知道 JS 是单线程的，所谓的单线程是指用来执行 JS 代码的线程只有一个。</li><li><strong>但浏览器是多线程的</strong>，所以 JS 执行时<strong>遇到异步任务</strong>，如http请求，这些请求是<strong>由浏览器的相关线程来完成的</strong>，等请求有结果时，再把需要 JS 线程来执行的任务（通常以回调函数的形式）加入到任务队列等着 JS 主线程空闲时来执行。</li></ul></blockquote><blockquote><blockquote><p>浏览器是多进程和多线程的，那进程和线程是什么关系呢 ？</p><table><thead><tr><th>分类</th><th>说明</th></tr></thead><tbody><tr><td>进程</td><td>是操作系统资源分配的最小单元。一个进程拥有的资源有自己的堆、栈、虚存空间（页表）、文件描述符等信息（可以把他理解为一个独立运行的程序）</td></tr><tr><td>线程</td><td>是操作系统能够进行运算调度的最小单元。它被包含在进程中，是进程中实际运行的单位。一个进程中可以并发多个线程，每个线程执行不同的任务</td></tr></tbody></table></blockquote></blockquote><blockquote><p><strong>生活类比 - 解释进程与线程</strong></p><ul><li>如果把进程看作<strong>一个部门</strong>，一个部门都需要完成指定的任务，那就会为完成这些任务配套相关的资源。</li><li>那线程就相当于<strong>这个部门的人</strong>，他们共享这个部门的资源，然后每个人又有自己不同的事情要做，多个人（多个线程）之间相互配合，然后一起把这个任务完成。</li></ul></blockquote><blockquote><p><strong>温馨提示：</strong></p><ul><li>线程共享进程资源，包括内存空间和操作系统的权限</li><li>进程中的任意一个线程执行出错，都会导致整个进程的崩溃</li><li>进程和进程之间也是可以互相通信，就好比部门和部门之间也是可以互相通信的一样<img src="浏览器进程与线程.png"></li></ul></blockquote><blockquote><blockquote><p>仅仅打开一个网页，就需要具有以下 4 个进程</p></blockquote></blockquote><table><thead><tr><th>进程</th><th>功能</th></tr></thead><tbody><tr><td>浏览器进程</td><td>主要负责界面显示、用户交互、子进程管理、同时提供存储等功能</td></tr><tr><td>渲染进程</td><td>核心任务是将 HTML、CSS 和 JS 转换为用户可以与之交互的网页，提成版引擎 Blink 和 JS 的 V8 引擎都是在该进程中，默认情况下，Chrome 会为每个 Tab 标签创建一个渲染进程。</td></tr><tr><td>GPU 进程</td><td>负责整个浏览器界面的渲染，早期主要是为了实现 3D CSS 效果</td></tr><tr><td>网络进程</td><td>主要负责页面的网络资源加载</td></tr></tbody></table><table><thead><tr><th>渲染进程中的线程</th><th>功能</th></tr></thead><tbody><tr><td>JS 引擎线程</td><td>JS 引擎线程也称为 JS 内核，负责处理 Javascript 脚本程序，解析 Javascript 脚本，运行代码；JS 引擎线程一直等待着任务队列中任务的到来，然后加以处理，一个 Tab 页中无论什么时候都只有一个 JS 引擎线程在运行 JS 程序</td></tr><tr><td>HTTP 请求线程</td><td>XMLHttpRequest 连接后通过浏览器新开一个线程请求；检测到状态变更时，如果设置有回调函数，异步线程就产生状态变更事件，将回调函数放入事件队列中，等待 JS 引擎空闲后执行</td></tr><tr><td>定时器触发线程</td><td>主要负责负 setTimeout，setInterval 定时器计时的，计时完毕后，将事件添加到处理队列的队尾，等待 JS 引擎空闲去处理</td></tr><tr><td>事件触发线程</td><td>用来控制事件循环，当 JS 引擎执行到点击事件，异步事件等等，都会将对应的任务添加到事件线程中，当事件符合触发条件时，会将事件添加到处理队列的队尾，等待 JS 引擎空闲后去执行（主要负责将准备好的事件交给 JS 引擎去执行）</td></tr><tr><td>GUI 线程</td><td>负责渲染浏览器页面，解析 HTML、CSS、构建 DOM 树，构建 CSSOM 树，构造渲染树和绘制页面。当界面需要重绘或某种操作引发回流时，该线程就会执行。<strong>不过要特别注意：</strong> GUI 线程和 JS 引擎线程是互斥的，当 JS 引擎执行时 GUI 线程会被挂起，GUI 更新会被保存在一个队列中等到 JS 引擎空闲时立即被执行</td></tr></tbody></table><h3 id="十二、同步与异步执行顺序"><a href="#十二、同步与异步执行顺序" class="headerlink" title="十二、同步与异步执行顺序"></a>十二、同步与异步执行顺序</h3><blockquote><p>首先 JS 会将所有同步任务执行完再去执行异步任务，如果在执行同步任务的过程中遇到了异步任务，会先把他交给<strong>浏览器的相关线程</strong>来完成，完成之后，再把需要 JS 线程来执行的任务放到 <strong>“任务队列”</strong> 中等着，等同步的代码全部执行完，再到任务队列取出异步任务，进入主线程并执行。</p><ul><li>异步任务的执行顺序是先加入队列的先拿出来执行<img src="同步与异步的执行顺序.png"></li></ul></blockquote><blockquote><pre><code>console.log(1);console.log(2);setTimeout(function () &#123;    console.log(&quot;定时器1000&quot;);&#125;, 1000);console.log(3);</code></pre></blockquote><p>setTimeout(function () {<br>    console.log(“定时器0”);<br>}, 0);<br>console.log(4);<br>……</p><blockquote></blockquote><p>&#x2F;&#x2F; 最后执行结果  1，2，3，4 定时器0  定时器1000</p><blockquote><pre><code></code></pre></blockquote><h3 id="十三、宏任务与微任务"><a href="#十三、宏任务与微任务" class="headerlink" title="十三、宏任务与微任务"></a>十三、宏任务与微任务</h3><blockquote><p>JS 中的任务分为同步与异步，其中异步任务又分为两种：</p><ul><li>宏任务（Macro-take）</li><li>微任务（Micro-take）<img src="微任务与宏任务.png"></li></ul></blockquote><table><thead><tr><th>宏任务</th><th>微任务</th></tr></thead><tbody><tr><td>script 标签（JS 整体代码）、setTimeout、setInterval、Ajax、DOM 事件等</td><td>Promise 的 then 和 catch 方法、MutaionObserver、async&#x2F;await 等</td></tr></tbody></table><blockquote><p><strong>任务队列的执行过程：</strong></p><ul><li>1、刚开始，调用栈空。微任务队列空，宏任务队列里有且只有一个 Script 脚本（整体 JS 代码）。这时首先执行的就是这个宏任务。（所以一开始程序执行时是没有微任务的）</li><li>2、整体代码作为宏任务进入调用栈，先执行同步代码，在执行的过程中遇到宏任务或微任务，就将他们加入分别加入到宏任务队列或微任务队列。</li><li>3、上一步的同步代码执行完后出栈，接着从微任务队列中取出微任务（先添加到微任务队列的先执行）并执行，在执行微任务过程中产生新的微任务，会添加到微任务队列，等微任务中的任务全部完成后，并不会马上执行宏任务，而是会进行 DOM 渲染</li><li>4、<strong>开始 DOM 渲染</strong>，把内容呈现在页面中，DOM 渲染结束。</li><li>5、接着从宏任务队列中取出宏任务（先加入到宏任务队列的先执行），并压入栈中执行。在执行宏任务时，也可能会产生新的宏任务和微任务。其执行过程重复上面操作。<blockquote><p>以上不断重复的过程就叫做<code>Event Loop</code>（事件循环）</p></blockquote></li></ul></blockquote><blockquote><blockquote><p>注意事项：</p></blockquote><ul><li>微任务是在下一轮 DOM 渲染之前执行，宏任务是在这之后执行。也就是说<strong>微任务与宏任务之间隔着一个 DOM 渲染</strong></li><li>所谓 DOM 渲染是指把内容绘制到页面上。<img src="代码执行顺序.png"></li></ul></blockquote><ol><li><p>代码分析 一</p><blockquote><pre><code>&lt;div&gt;正文内容&lt;/div&gt;&lt;script&gt;  console.log(&quot;同步开始---&quot;);  const div = document.createElement(&quot;div&quot;);  div.innerHTML = &quot;新加的内容&quot;;  document.body.appendChild(div);  const list = document.querySelectorAll(&quot;div&quot;);  console.log(&quot;div的个数----&quot;, list.length);</code></pre></blockquote><p>  setTimeout(() &#x3D;&gt; {<br> console.log(“timeout中代码”);<br> alert(“阻塞 timeout”);<br>  });<br>  console.log(“同步进行中—-“);<br>  Promise.resolve().then(() &#x3D;&gt; {<br> console.log(“Promise的then方法中代码”);<br> alert(“阻塞 Promise”);<br>  });<br>  console.log(“同步结束—-“);</p><blockquote><p></script></p><pre><code>- 在点击确认了`alert`的弹窗后(也就是执行完微任务后)，才会进行DOM渲染，接着执行宏任务</code></pre></blockquote></li><li><p>代码分析 二</p><blockquote><pre><code>console.log(&quot;同步1&quot;);</code></pre></blockquote><p>setTimeout(function fn1() {<br>  console.log(“定时器为宏任务”);<br>}, 0);</p><blockquote></blockquote><p>new Promise((resolve, reject) &#x3D;&gt; {<br>  console.log(“同步2”);<br>  resolve(“a”);<br>})<br>  .then(function fn2() {<br> console.log(“then方法为微任务1”);<br>  })<br>  .then(function fn3() {<br> console.log(“then方法为微任务2”);<br>  });</p><blockquote></blockquote><p>console.log(“同步3”);</p><blockquote><pre><code>分析上面代码的执行步骤：1、宏任务：执行整个代码（&lt;script&gt;标签中的代码）- （1）：先执行同步任务console.log(&quot;同步1&quot;)，输出 &quot;同步1&quot;- （2）：遇到 setTimeout，加入到宏任务队列- （3）：遇到 Promise 的构造函数，属于同步任务，输出 &quot;同步2&quot;- （4）：遇到 Promise 的 then 方法，加入微任务队列（1 个 then，加入微任务队列）- （5）：接着执行后面的同步代码 console.log(&quot;同步3&quot;);输出 &quot;同步 3&quot;2、微任务：执行微任务对列（promise 的 then 方法中的回调）- （1）： 从微任务队列中取出第一个任务（第一个 then 的回调）执行，输出：&quot;then方法为微任务1&quot; 这个 then 方法执行后又产生了一个微任务，加入到了微任务队列。- （2）：从微任务队列中取出刚加的微任务，并执行，输出 &quot;then方法为微任务2&quot;3、执行渲染操作，更新界面4、宏任务：取出宏任务队列中的任务（setTimeout 的回调函数 fn1）并执行，最后输出 &quot;定时器为宏任务&quot;</code></pre></blockquote></li><li><p>代码分析 三</p><blockquote><pre><code>setTimeout(() =&gt; &#123;  console.log(&quot;ok&quot;);&#125;);new Promise((resolve, reject) =&gt; &#123;  console.log(1);  resolve();&#125;)  .then(() =&gt; &#123; console.log(2);  &#125;)  .then(() =&gt; &#123; console.log(3);  &#125;)  .then(() =&gt; &#123; console.log(4);  &#125;)  .then(() =&gt; &#123; console.log(5);  &#125;);</code></pre></blockquote><p>new Promise((resolve, reject) &#x3D;&gt; {<br>  console.log(10);<br>  resolve();<br>})<br>  .then(() &#x3D;&gt; {<br> console.log(20);<br>  })<br>  .then(() &#x3D;&gt; {<br> console.log(30);<br>  })<br>  .then(() &#x3D;&gt; {<br> console.log(40);<br>  })<br>  .then(() &#x3D;&gt; {<br> console.log(50);<br>  });</p><blockquote></blockquote><p>&#x2F;&#x2F; 执行结果：1 10 2 20 3 30 4 40 5 50  ok</p><blockquote><pre><code>分析上面代码的执行步骤：宏任务：执行整个代码（&lt;script&gt;标签中的代码）- （1）：遇到异步的宏任务，添加到宏任务队列。然后接着向下执行代码- （2）：遇到同步任务，new Promise(...)，则打印 1 ，然后 Promise 的状态改变，向微任务队列中添加第 1 个微任务() =&gt; &#123; console.log(2); &#125;- （3）：接着遇到同步任务，new Promise(...),则打印 10，然后然后 Promise 的状态改变，向微任务队列中添加第 2 个微任务() =&gt; &#123; console.log(20);&#125;- （4）：同步任务执行完，开始从微任务队列中取出第 1 个微任务执行，打印 2，然后返回成功的 Promise 对象，向微任务队列中添加第 3 个微任务() =&gt; &#123; console.log(3);&#125;，出栈。- （5）：接着从微任务队列中取出第 2 个微任务执行，打印 20，然后然后返回成功的 Promise 对象，向微任务队列中添加第 4 个微任务() =&gt; &#123; console.log(30);&#125;，出栈。- （6）：接下来重复上面的步骤 3 和 4，不断取出对应的微任务执行，在执行的过程中又产生新的微任务。等所有微任务全部执行完，最后去宏任务队列取出宏任务，并执行，所以最后输出 “ok&quot;&gt;要注意：先添加微任务，再执行- **并不是**先把第一个`new Promise`里的微任务执行完再执行第二个`new Promise`里的微任务- 谁先添加到队列里，先执行谁</code></pre></blockquote></li><li><p>代码分析 四</p><blockquote><ul><li>这是一道经典的面试题，熟称让人失眠的一道面试题</li></ul><pre><code>const p2 = Promise.resolve()  .then(() =&gt; &#123; console.log(0); // 慢两拍 return Promise.resolve(4);  &#125;)  .then((data) =&gt; &#123; console.log(data);  &#125;);</code></pre></blockquote><p>Promise.resolve()<br>  .then(() &#x3D;&gt; {<br> console.log(1);<br>  })<br>  .then(() &#x3D;&gt; {<br> console.log(2);<br>  })<br>  .then(() &#x3D;&gt; {<br> console.log(3);<br>  })<br>  .then(() &#x3D;&gt; {<br> console.log(5);<br>  })<br>  .then(() &#x3D;&gt; {<br> console.log(6);<br>  });<br>&#x2F;&#x2F;0 1 2 3 4 5 6 </p><blockquote><pre><code>&gt;记住：- 在`then`方法里返回一个`Promise`对象，会**慢两拍**！</code></pre></blockquote></li></ol>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JS核心知识点（十七）</title>
      <link href="/2023/12/08/JS%E6%A0%B8%E5%BF%83%E7%9F%A5%E8%AF%86%E7%82%B9%EF%BC%88%E5%8D%81%E4%B8%83%EF%BC%89/"/>
      <url>/2023/12/08/JS%E6%A0%B8%E5%BF%83%E7%9F%A5%E8%AF%86%E7%82%B9%EF%BC%88%E5%8D%81%E4%B8%83%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<span id="more"></span><blockquote><p>如果我们想对字符串进行相关（增、删、改、查、检索）操作，就可以用接下来的正则表达式实现<br><strong>什么是正则表达式</strong></p><ul><li>正则表达式是用于匹配字符串中字符组合的模式</li><li>正则表达式通常被用来检索、替换那些符合某个模式（规则）的文本<blockquote><p>在实际开发中，我们需要检测用户输入的账号（邮箱或手机号）是否符合要求，就可以用到正则表达式来检测</p></blockquote></li></ul></blockquote><h3 id="一、创建正则表达式"><a href="#一、创建正则表达式" class="headerlink" title="一、创建正则表达式"></a>一、创建正则表达式</h3><blockquote><p>创建正则表达式有两种方式：<strong>字面量形式</strong>和<strong>构造函数</strong>形式</p><ul><li>字面量形式 ： 由两个斜杠<code>/ /</code> 包围 ，如 <code>/正则内容/</code></li><li>构造函数形式 ：使用<code>new RegExp(&#39;正则内容&#39;)</code>的形式创建<blockquote><p>正则表达式是<strong>对象</strong>（引用数据类型），使用<code>typeof</code>运算符检查正则表达式的类型，结果为<code>Object</code></p></blockquote></li></ul></blockquote><pre><code>// 需要检查的字符串var str1 = &quot;123a456&quot;;var str2 = &quot;12345a67&quot;;&gt;// 字面量形式创建正则表达式var reg1 = /\d&#123;5&#125;/; // 配的字符串中需要包含连续的5位数字// 构造函数形式var reg2 = new RegExp(&quot;\\d&#123;5&#125;&quot;);&gt;console.log(reg1.test(str1)); // falseconsole.log(reg1.test(str2)); // true&gt;console.log(reg2.test(str1)); // falseconsole.log(reg2.test(str2)); // true&gt;typeof /\d&#123;5&#125;/; // &#39;object&#39;</code></pre><blockquote><ul><li>能用字面量方式实现，就用字面量方式。如果字面量方式实现起来不方便，则可以考虑用<code>new RegExp</code>实现</li><li>如果正则表达式的规则是可变的，不固定的，可以把正则表达式以字符串形式保存在变量中，然后在<code>new RegExp</code>中引用这个变量。</li></ul></blockquote><pre><code> var str = &quot;uac&quot;; var val = &quot;a&quot;; // 字符串是否包含a var reg = new RegExp(val); console.log(reg.test(str)); //true val = &quot;b&quot;; // 字符串是否包含b var reg = new RegExp(val); console.log(reg.test(str)); //false</code></pre><ul><li>正则表达式“按位”描述规则<blockquote><ul><li>正则表达式 “按位” 描述规则，是指它是<strong>一位一位的</strong>描述字符串的构成形式</li></ul></blockquote></li></ul><pre><code> var reg1 = /^A\d\d\dB$/; //必须以A开头，中间三位数字，B结尾 console.log(reg1.test(&quot;A123B&quot;)); //true console.log(reg1.test(&quot;A1234B&quot;)); //false var reg2 = /^A\d\d\d$/; //必须以A开头，中间三位数字，以第三位数字结尾 console.log(reg2.test(&quot;A123&quot;)); //true console.log(reg2.test(&quot;A1234&quot;)); //false</code></pre><blockquote><blockquote><p>正则在线测试工具：<a href="https://regexr-cn.com可以用来测试自己写的正则/">https://regexr-cn.com可以用来测试自己写的正则</a></p></blockquote></blockquote><h3 id="二、边界限定字符"><a href="#二、边界限定字符" class="headerlink" title="二、边界限定字符"></a>二、边界限定字符</h3><table><thead><tr><th>字符</th><th>描述</th></tr></thead><tbody><tr><td>^</td><td>匹配输入字符串的开始位置</td></tr><tr><td>$</td><td>匹配输入字符串的结束位置</td></tr><tr><td>\b</td><td>匹配一个单词的边界,需要注意的是匹配的单词边界<strong>不包括</strong>在匹配中</td></tr><tr><td>\B</td><td>匹配非单词边界</td></tr></tbody></table><blockquote><ul><li>如果要控制字符串的个数，就在前后加上边界限定字符<code>^$</code><blockquote><p>注意：</p></blockquote></li><li>单词前后出现<code>（@ . - # $ % &amp; &lt;）</code>等特殊字符，这个单词都可以看作是独立的单词</li><li>如果单词前后出现 数字、字母、<code>_</code>则不会当成独立的单词</li></ul></blockquote><pre><code>// 匹配字符串中的独立的cat单词var reg1 = /\bcat\b/g;var str = &quot;cat 1cat cats cat. @cat -cat _cat&quot;;var res = str.replace(reg1, function (v) &#123;  //给独立的cat前加*  return &quot;*&quot; + v;&#125;);console.log(res); // *cat 1cat cats *cat. @*cat -*cat _cat</code></pre><ul><li>检测字符串是否是 5 位数字</li></ul><pre><code>var str1 = &quot;a12345&quot;;var str2 = &quot;12345b&quot;;var str3 = &quot;12345&quot;;&gt;var reg = /^\d&#123;5&#125;$/;console.log(reg.test(str1)); // falseconsole.log(reg.test(str2)); // falseconsole.log(reg.test(str3)); // trueconsole.log(reg.test(str4)); // false</code></pre><ul><li>检测字符串是否是以 m 开头，中间 5 位数字，以 n 结尾</li></ul><pre><code>var str1 = &quot;m12345&quot;;var str2 = &quot;m123456n&quot;;var str3 = &quot;m12345n&quot;;&gt;var reg = /^m\d&#123;5&#125;n$/;console.log(reg.test(str1)); // falseconsole.log(reg.test(str2)); // falseconsole.log(reg.test(str3)); // true</code></pre><ul><li>将字符串中独立的 cat 前后加上*号</li></ul><pre><code>var str = &quot;cat scats&quot;;var reg = /\bcat\b/g;console.log(str.match(reg)); //[&#39;cat&#39;]var res=str.replace(reg,&quot;*$&amp;*&quot;);console.log(res);//*cat* scats</code></pre><ul><li>找出以 icon 开头的单词，不包括 icon</li></ul><pre><code>var reg = /\bicon[a-z]+\b/gi;var str = &quot;i icons bicon iconasw icons1 icon&quot;;console.log(str.match(reg)); // [&#39;icons&#39;, &#39;iconasw&#39;]</code></pre><ul><li>把单词中出现的con换成*，但要求con不能出现在单词的开始和结束</li></ul><pre><code>var reg = /\Bcon\B/g;var str = &quot;content iconfont bacon&quot;;var res = str.replace(reg, &quot;*&quot;);console.log(res);//content i*font bacon</code></pre><h3 id="三、元字符"><a href="#三、元字符" class="headerlink" title="三、元字符"></a>三、元字符</h3><blockquote><ul><li>根据正则表达式语法规则，大部分字符仅能够描述自身，这些字符被称为<strong>普通字符</strong>，如所有的字母、数字等</li><li>元字符就是<strong>拥有特定功能</strong>的特殊字符，大部分需要<strong>加反斜杠</strong>进行标识，以便于普通字符进行区别</li><li>元字符是正则表达式中的最小元素，只代表单一（一个）字符<table><thead><tr><th>元字符</th><th>功能</th></tr></thead><tbody><tr><td>\d</td><td>匹配一个数字，等价于 <code>[0-9]</code></td></tr><tr><td>\D</td><td>匹配一个非数字字符 <code>[^0-9]</code></td></tr><tr><td>\w</td><td>匹配一个单字字符（字母、数字、下划线） 等价于<code>[A-Za-z0-9_]</code></td></tr><tr><td>\W</td><td>匹配一个非单字字符 <code>[^A-Za-z0-9_]</code></td></tr><tr><td>\s</td><td>匹配一个空白字符，包括（空格、制表符和换行符）</td></tr><tr><td>\S</td><td>匹配任意不是空白符的字符</td></tr><tr><td>.</td><td>匹配除换行符之外的任何单个字符</td></tr></tbody></table></li></ul></blockquote><ul><li>检测字符串是否满足：<code>123-4567-789</code> 格式</li></ul><pre><code>// 正则表达式var reg = /^\d\d\d-\d\d\d\d-\d\d\d$/;// var reg = /^\d&#123;3&#125;-\d&#123;4&#125;-\d&#123;3&#125;$/;   优化版&gt;// 测试字符串var str1 = &quot;123-9873-980&quot;;var str2 = &quot;123-9873-9803&quot;;console.log(reg.test(str1)); // trueconsole.log(reg.test(str2)); // false</code></pre><ul><li>检测字符串是否满足<code>xxx-xxxx-xxx</code>格式，其中 x 表示字母、数字、下划线</li></ul><pre><code>// 正则表达式var reg = /^\w\w\w-\w\w\w\w-\w\w\w$/;// var reg = /^\w&#123;3&#125;-\w&#123;4&#125;-\w&#123;3&#125;$/;&gt;// 测试字符串var str1 = &quot;123-a123-bc9&quot;;var str2 = &quot;abc-_e13-cde&quot;;var str3 = &quot;@bc-_ae13-cde&quot;;console.log(reg.test(str1)); // trueconsole.log(reg.test(str2)); // trueconsole.log(reg.test(str3)); // false</code></pre><ul><li>检测字符串中是否有空白字符</li></ul><pre><code>// 正则表达式var reg = /\s/;&gt;// 测试字符串var str1 = &quot;1 bc&quot;;var str2 = &quot; ab&quot;;var str3 = &quot;se1&quot;;console.log(reg.test(str1)); // trueconsole.log(reg.test(str2)); // trueconsole.log(reg.test(str3)); // false</code></pre><ul><li>检测字符串的开头是否有空白字符</li></ul><pre><code>// 正则表达式var reg = /^\s/;&gt;// 测试字符串var str1 = &quot;1 bc&quot;;var str2 = &quot; ab&quot;;var str3 = &quot;se1&quot;;console.log(reg.test(str1)); // falseconsole.log(reg.test(str2)); // trueconsole.log(reg.test(str3)); // false</code></pre><ol><li>注意事项 1：字符转义<blockquote><ul><li>如果想让某个特殊字符<strong>以字面意思理解</strong>（匹配），则可以在特殊字符前加<code>\</code>转义</li><li>在特殊字符之前的反斜杠<code>\</code>表示下一个字符不是特殊字符，应该按照字面理解</li><li><code>.</code>点在正则中是一个特殊字符，表示匹配除换行符之外的任何单个字符</li><li>如果我们想检测字符串是否有<code>.</code>，则需要在其前加<code>\</code>来转义</li></ul></blockquote></li></ol><pre><code>// 正则表达式var reg1 = /^a\.b$/; // 字符串要有.字符&gt;// 测试字符串var str1 = &quot;abc&quot;;var str2 = &quot;a.b&quot;;&gt;console.log(reg1.test(str1)); // falseconsole.log(reg1.test(str2)); // true</code></pre><blockquote><blockquote><p>不管一个<strong>符号</strong>(字母数字不行)有没有特殊意义，都可以在其之前加上一个<code>\</code>以确保它表达的是这个符号本身</p></blockquote></blockquote><ol start="2"><li>注意事项 2：字符串中的 \<blockquote><ul><li>字符串中的<code>\</code>是一个转义符，如果想在字符串中正确的输出<code>\</code>，需要在他的前面再添加<code>\</code>转义</li></ul></blockquote></li></ol><pre><code>var str1 = &quot;a\\b&quot;;console.log(str1); // a\b</code></pre><ol start="3"><li>注意事项 3：new RegExp() 中的 \<blockquote><ul><li>如果使用<code>new RegExp()</code>写法创建正则表达式，<strong>反斜杠需要多写一个</strong>，原因就是因为字符串中的<code>\</code>本身是一个转义符</li><li>如：<code>/^\d$/</code> 和 <code>new RegExp(&#39;^\\d$&#39;)</code> 是相同的意思</li></ul></blockquote></li></ol><pre><code>  var reg1 = /^\d&#123;5&#125;$/; //字符串是5位数字组成  var reg2 = new RegExp(&quot;^d&#123;5&#125;$&quot;); // 检测的字符串要是5个d  var reg3 = new RegExp(&quot;^\\d&#123;5&#125;$&quot;); // 字符串是5位数字组成&gt;  // 测试字符  var str1 = &quot;12345&quot;;  console.log(reg1.test(str1)); //true;  console.log(reg2.test(str1)); //false  console.log(reg2.test(&quot;ddddd&quot;)); //true  console.log(reg3.test(str1)); //true</code></pre><h3 id="四、方括号表示法"><a href="#四、方括号表示法" class="headerlink" title="四、方括号表示法"></a>四、方括号表示法</h3><blockquote><p>在正则表达式语法中，<code>[]</code>方括号表示字符范围，在方括号中可以包含多个字符，表示匹配方括号中出现的<strong>任意一个字符</strong></p></blockquote><ol><li>[] 中特殊字符<blockquote><ul><li>在 <code>[]</code> 方括号中，对于<code>. * ?|/</code> 等这些特殊符号，<strong>没有任何特殊意义</strong>(不需要用<code>\</code>)，只是表示字符本身的意思</li></ul></blockquote></li></ol><pre><code>var reg = /^a[123]b$/;console.log(reg.test(&quot;a1b&quot;)); // trueconsole.log(reg.test(&quot;a3b&quot;)); // trueconsole.log(reg.test(&quot;a4b&quot;)); // false</code></pre><ol start="2"><li><input disabled="" type="checkbox"> 中的破折号 -<blockquote><p>如果多个字符的编码顺序是连续的，可以仅指定开头和结尾字符，省略中间字符，使用破折号 <code>-</code>来<strong>指定字符范围</strong></p></blockquote></li></ol><table><thead><tr><th>字符范围</th><th>描述</th></tr></thead><tbody><tr><td>[0-9]</td><td>匹配0-9之间的一个数字 等价于\d</td></tr><tr><td>[a-z]</td><td>匹配小写 a-z 任何一个字母</td></tr><tr><td>[A-Z]</td><td>匹配大写 A-Z 任何一个字母</td></tr><tr><td>[A-Za-z0-9_]</td><td>匹配一个单字字符（字母、数字、下划线） 等价于 \w</td></tr><tr><td>[a-d]</td><td>表示匹配 a,b,c,d 中的任意一个</td></tr><tr><td>[0-4]</td><td>表示匹配 0，1，2，3，4中的任意一个</td></tr></tbody></table><blockquote><ul><li>字符串是否是<code>0-5</code>之间的任意一个数字</li></ul></blockquote><pre><code>var reg = /^[0-5]$/;console.log(reg.test(&quot;1&quot;)); // trueconsole.log(reg.test(&quot;2&quot;)); // trueconsole.log(reg.test(&quot;6&quot;)); // false</code></pre><blockquote><ul><li>验证字符串是否为 Java 或 java</li></ul></blockquote><pre><code>var reg = /^[Jj]ava$/;console.log(reg.test(&quot;java&quot;)); // trueconsole.log(reg.test(&quot;Java&quot;)); // trueconsole.log(reg.test(&quot;zJava&quot;)); // false</code></pre><ul><li>验证某字符串是否是 4 位小写字母，且最后一位不能是m</li></ul><pre><code>var reg = /^[a-z]&#123;3&#125;[a-ln-z]$/;&gt;console.log(reg.test(&quot;abcf&quot;)); // trueconsole.log(reg.test(&quot;1abc&quot;)); // falseconsole.log(reg.test(&quot;abcm&quot;)); //trueconsole.log(reg.test(&quot;abmc&quot;)); //true</code></pre><ol start="3"><li>取反：[ ] 内添加^前缀<blockquote><ul><li>如果在方括号内添加<code>^</code>前缀，表示只要不是当前范围内的任意一个字符</li></ul></blockquote></li></ol><table><thead><tr><th>字符范围</th><th>描述</th></tr></thead><tbody><tr><td>[^0-9]</td><td>匹配一个非数字字符 等价于\D</td></tr><tr><td>[^a-z]</td><td>匹配一个非小写 a-z 中的任何一个字符</td></tr><tr><td>[^A-Z]</td><td>匹配一个非大写 A-Z 任何一个字符</td></tr><tr><td>[^A-Za-z0-9_]</td><td>匹配一个非单字字符 等价于 \W</td></tr><tr><td>[^123]</td><td>匹配非 123 中的其它任何一个字符</td></tr></tbody></table><ul><li>检测某个字符串是否符合以下要求： <blockquote><ul><li>字符串有 3 位字符组成，以小写字母开头，中间 1 位不能是数字，最后一位不能是大写字母</li></ul></blockquote></li></ul><pre><code>var reg = /^[a-z][^\d][^A-Z]/;console.log(reg.test(&quot;asA&quot;));console.log(reg.test(&quot;a.s&quot;));</code></pre><p>4、匹配所有字符</p><blockquote><ul><li><code>[\d\D]</code> 可用来表示所有字符</li><li><code>[\s\S]</code> 可用来表示所有字符</li></ul></blockquote><pre><code>var str = &quot;12ab./@*&amp;^%#&quot;;var bool = /^[\s\S]+$/.test(str);console.log(bool);&gt;var res = str.match(/[\s\S]+/g);console.log(res); // [&#39;12ab./@*&amp;^%#&#39;]</code></pre><h3 id="五、量词"><a href="#五、量词" class="headerlink" title="五、量词"></a>五、量词</h3><blockquote><p>如果需要重复匹配一些内容时，我们就需要使用到量词，主要包括以下几种</p></blockquote><table><thead><tr><th>量词</th><th>描述</th></tr></thead><tbody><tr><td>*</td><td>匹配前一个表达式 0 次或多次，等价于{0,}</td></tr><tr><td>+</td><td>匹配前面一个表达式 1 次或多次，等价于{1,}</td></tr><tr><td>？</td><td>匹配前面一个表达式 0 次 1 次，等价于{0,1}</td></tr><tr><td>{n}</td><td>n 是一个正整数，匹配了前面一个字符刚好出现了 n 次</td></tr><tr><td>{n,}</td><td>n 是一个正整数，匹配前一个字符至少出现了 n 次</td></tr><tr><td>{n,m}</td><td>n 和 m 都是整数，匹配前面的字符至少次，最多 m 次</td></tr></tbody></table><blockquote><ul><li>验证字符串是否符合手机号码的规则：<code>11</code> 位数字，并且肯定要以 <code>1</code> 开头，第 2 位不能是 <code>1</code> 和 <code>2</code></li></ul></blockquote><pre><code>var reg = /^[1][^12]\d&#123;9&#125;$/;console.log(reg.test(13978903158)); // true</code></pre><blockquote><ul><li>判断某个字符串是否是 5 位，要求以大写字母开头，中间任意数字，最后以小写字母结尾</li></ul></blockquote><pre><code>var reg = /^[A-Z][0-9]&#123;3&#125;[a-z]$/;console.log(reg.test(&quot;A111z&quot;));// true</code></pre><ul><li>验证用户名是否符合以下规则：4-16位，只能是数字，字母，_下划线，- 减号组成</li></ul><pre><code>var reg3 = /^[\w-]&#123;4,16&#125;$/;console.log(reg.test(&quot;a123s@&quot;)); // false</code></pre><ul><li>判断某个字符串是否是以 http 或 https 开头</li></ul><pre><code>var reg = /^https?/;console.log(reg.test(&quot;http&quot;)); // true</code></pre><ul><li>判断某个字符是否是小数，比如 3.1 43.01</li></ul><pre><code>var reg4 = /^[0-9]+\.\d+$/;console.log(reg4.test(&quot;1.209&quot;));</code></pre><h3 id="六、选择符"><a href="#六、选择符" class="headerlink" title="六、选择符"></a>六、选择符</h3><table><thead><tr><th>选择符</th><th>说明</th></tr></thead><tbody><tr><td>&#96;</td><td>&#96;</td></tr></tbody></table><blockquote><blockquote><p><code>|</code> 选择符：一般会放在原子组<code>()</code>中来使用</p></blockquote><ul><li>不加括号时：<code>/^a|b$/</code>，代表要么是<code>^a</code>即以a开头，要么是<code>b$</code>即以b结尾，不限字符数</li><li>加括号时：<code>/^(a|b)$/</code>，代表只能是一个字符，要么是a，要么是b</li></ul></blockquote><blockquote><ul><li>匹配字符串中只要包含 a 或 b 就可以</li></ul></blockquote><pre><code>var reg = /a|b/;console.log(reg.test(&quot;b&quot;)); //trueconsole.log(reg.test(&quot;a&quot;)); //trueconsole.log(reg.test(&quot;ab&quot;)); //trueconsole.log(reg.test(&quot;ba&quot;)); //true</code></pre><ul><li>匹配字符串是否以 a 开始或 b 结尾</li></ul><pre><code>var reg = /^a|b$/;console.log(reg.test(&quot;b&quot;)); //trueconsole.log(reg.test(&quot;a&quot;)); //trueconsole.log(reg.test(&quot;ab&quot;)); //trueconsole.log(reg.test(&quot;ba&quot;)); //false</code></pre><ul><li>匹配字符串是否是 a 或 b</li></ul><pre><code>var reg = /^(a|b)$/; // 相当于只要匹配 /^a$/ 或/^b$/ 就可以console.log(reg.test(&quot;a&quot;)); // trueconsole.log(reg.test(&quot;b&quot;)); // trueconsole.log(reg.test(&quot;a11&quot;)); // falseconsole.log(reg.test(&quot;ssb&quot;)); // false</code></pre><ul><li>匹配字符串是否为 “current”或 “active”</li></ul><pre><code>var reg = /^(current|active)$/;console.log(reg.test(&quot;current&quot;)); // trueconsole.log(reg.test(&quot;active&quot;)); // trueconsole.log(reg.test(&quot;actives&quot;)); // false</code></pre><ul><li>匹配字符串是否为 hobby 或 hobbies</li></ul><pre><code>var reg = /^hobb(y|ies)$/;console.log(reg.test(&quot;hobby&quot;));console.log(reg.test(&quot;hobbies&quot;));console.log(reg.test(&quot;hobbes&quot;));</code></pre><ul><li>检测坐机电话是否是长沙或西安的 长沙区号：0731 、西安区号 029、北京区号 010</li></ul><pre><code>// var reg1 = /^0731|029-\d&#123;7,8&#125;$/; // 错误写法&gt;var reg2 = /^(0731|029)-\d&#123;7,8&#125;$/; // 正确写法console.log(reg1.test(&quot;0731&quot;)); // trueconsole.log(reg2.test(&quot;0731&quot;)); // falseconsole.log(reg2.test(&quot;0731-1234567&quot;)); // true</code></pre><ul><li>零或非零开头的数字</li></ul><pre><code>var reg =/^(0|[1-9][0-9]*)$/;</code></pre><h3 id="七、修饰符"><a href="#七、修饰符" class="headerlink" title="七、修饰符"></a>七、修饰符</h3><blockquote><p>修饰符也叫作标志（flags）通过标志，正则表达式可实现高级搜索</p></blockquote><table><thead><tr><th>标志</th><th>说明</th></tr></thead><tbody><tr><td>g</td><td>全局搜索</td></tr><tr><td>i</td><td>不区分大小写搜索</td></tr><tr><td>m</td><td>多行搜索；修饰符的作用是修改<code>^</code>和<code>$</code>在正则表达式中的作用，让它们分别表示行首和行尾。</td></tr><tr><td>s</td><td>允许<code>.</code>匹配换行符</td></tr><tr><td>u</td><td>使用 <code>unicode</code> 码的模式进行匹配</td></tr><tr><td>y</td><td>执行“粘性 (sticky)”搜索，匹配从目标字符串的当前位置开始</td></tr></tbody></table><ol><li>i 标志<blockquote><ul><li>检测字符串中是否包括<strong>大小写</strong>字母<code>a</code></li></ul></blockquote></li></ol><pre><code>var reg = /a/i;console.log(reg.test(&quot;Abc&quot;)); // trueconsole.log(reg.test(&quot;abc&quot;)); // true</code></pre><ol start="2"><li>g 标志<blockquote><ul><li>提取字符串中的数字</li></ul></blockquote></li></ol><pre><code>var reg = /\d+/g;var str = &quot;1ab23c345&quot;;var arr = str.match(reg); // 将匹配成功的内容组成一个新的数组，并将这个数组返回console.log(arr); //  [&#39;1&#39;, &#39;23&#39;, &#39;345&#39;]</code></pre><ol start="3"><li>修鉓符可以组合（叠加使用）</li></ol><pre><code>var str = &quot;I Love You 清心&quot;;var res1 = str.replace(/[a-z]+/g, &quot;*&quot;); // 将小写字母替换成 *console.log(res1); // I L* Y* 清心var res2 = str.replace(/[a-z]+/gi, &quot;*&quot;); //将字母（不区分大小）替换成 *console.log(res2); // * * * 清心</code></pre><ol start="4"><li>m 标志<blockquote><ul><li>用于将内容视为<strong>多行匹配</strong>，主要针对有 <code>^</code>和 <code>$</code> 修饰的表达式</li><li>m 修饰符的作用是修改<code>^</code>和<code>$</code>在正则表达式中的作用，让它们分别表<strong>行首和行尾</strong>示</li></ul></blockquote></li></ol><pre><code>// 提取字符串中##包裹的内容var str = `        #a1bs##        #s@wf#        #c09swwf#      `;&gt;var reg = /^\s*#([\s\S]+?)#\s*$/gm;var result = [];var res = str.replace(reg, function (v, p1) &#123;  result.push(p1);&#125;);console.log(result); // [&#39;a1bs&#39;, &#39;s@wf&#39;, &#39;c09swwf&#39;]&gt;// 以下方式更简单，但如果当前行超过两个#,就会出错var reg = /#([\s\S]+?)#/g;str.replace(reg, function (v, p1) &#123;  console.log(p1);&#125;);</code></pre><ul><li>提取第一行中数字前面紧跟随着$或￥的数字（包括小数）</li></ul><pre><code> var reg = /(?:(?&lt;=\$)|(?&lt;=\￥))(\d+(\.\d+)?)/g;  var str = ` 书￥20.00   笔$30.00 本子$52 尺子￥0.5元 总费用:50.5元 `; str.replace(reg, function (v, p1) &#123;   console.log(p1); &#125;);</code></pre><ol start="5"><li>s 标志<blockquote><ul><li>允许 <code>.</code> 匹配换行符<blockquote><p><code>.</code>：匹配除换行符之外的任何单个字符</p></blockquote></li></ul></blockquote></li></ol><pre><code>var str = `ab\n12`;var reg = /^ab.12$/s;console.log(reg.test(str)); // true</code></pre><ol start="6"><li>y 标志<blockquote><ul><li>执行<code>“粘性（sticky）”</code>搜索，匹配从目标字符串的当前位置开始</li><li>使用<code>g</code>模式匹配，会一直匹配，直到整个字符串都匹配完，而使用<code>y</code>模式后，如果从<code>lastIndex</code>开始匹配不成功，则后面有符合条件的也不匹配了</li><li><code>y</code>与<code>g</code>模式<strong>不能共存</strong>，只能二选一，同时<code>matchAll</code> 不能用 y 模式</li></ul></blockquote></li></ol><pre><code>var str = &quot;123b345ca&quot;;var reg = /\d&#123;2&#125;/g;console.log(reg.exec(str));console.log(reg.lastIndex); // 2console.log(reg.exec(str));console.log(reg.lastIndex); // 6console.log(reg.exec(str));console.log(reg.lastIndex); // 0&gt;var reg = /\d&#123;2&#125;/y;console.log(reg.exec(str));console.log(reg.lastIndex); // 2console.log(reg.exec(str)); // nullconsole.log(reg.lastIndex); // 0</code></pre><blockquote><ul><li>y 模式，主要用来提取要提取的内容是连续出现的，这样提取的效率会很高</li></ul></blockquote><pre><code>var str =  &quot;相关的学习QQ群:234566,90011933,30211123加入到对应群里可以获得相应的指导。以下是大神QQ群：34222222&quot;;&gt;var reg = /(\d+),?/y;reg.lastIndex = 9;var res = reg.exec(str);while (res) &#123;  console.log(res[1]);  res = reg.exec(str);&#125;</code></pre><blockquote><ul><li>结合 match 使用</li><li>要指定<code>lastIndex</code>，不然直接从0开始匹配，如果在0处没找到，就不会再找了</li><li>从<code>lastIndex</code>开始匹配，如果找到了，就返回第一个完整的匹配及相关的捕获组。（与 exec 方法返回结果一样）；</li></ul></blockquote><pre><code>var str =  &quot;相关的学习QQ群:234566,90011933,30211123加入到对应群里可以获得相应的指导。以下是大神QQ群：34222222&quot;;&gt;var reg = /(\d+),?/y;reg.lastIndex = 9;var res1 = str.match(reg);var res2 = str.match(reg);var res3 = str.match(reg);var res4 = str.match(reg);console.log(res1);console.log(res2);console.log(res3);console.log(res4);</code></pre><img src="y标志.png"><ol start="7"><li>u 标志<blockquote><ul><li>使用<code>unicode</code>码的模式进行匹配</li><li>使用<code>u</code>模式可以正确处理<code>4</code>个字节的<code>UTF-16</code>编码<br><strong>位、字节、字符：</strong></li><li>位（bit）：表示二进制位，位是计算机内部数据存储的最小单位，<code>11111111</code>是一个 8 位的二进制</li><li>字节（byte）：字节是计算机中数据处理的基本单位。计算机中以字节为单位存储和解释信息，规定一个字节由八个二进制位构成，即 1 个字节等于 8 个比特<code>（1Byte=8bit）</code>。八位二进制数最小为 <code>00000000</code>，最大为<code>11111111</code>，通常 1 个字节可以存入一个 ASCII 码，2 个字节可以存放一个汉字国标码</li><li>字符：字符（Character）计算机中使用的字母、数字、字和符号，比如<code>&#39;A&#39;、&#39;B&#39;、&#39;$&#39;、&#39;&amp;&#39;</code>等。 一般在英文状态下一个字母或字符占用一个字节，一个汉字用两个字节表示</li></ul></blockquote></li></ol><blockquote><p>Unicode 的编码</p><ul><li><code>Unicode</code> 为世界上所有字符都分配了一个唯一的数字编号，这个编号范围从<code>0x000000</code>到<code>0x10FFFF</code>（十六进制），有<code>110 多万</code></li><li>每个字符都有一个唯一的 <code>Unicode</code> 编号，这个编号一般写成 16 进制，</li><li>例如：“马” 的 <code>Unicode</code> 是 <code>9A6C</code></li><li>但 <code>Unicode</code> 本身只规定了每个字符的数字编号是多少，<strong>并没有规定这个编号如何存储</strong></li><li>中文对应的 Unicode 编码表：<a href="https://www.unicode.org/charts/PDF/U4E00.pdf">https://www.unicode.org/charts/PDF/U4E00.pdf</a></li><li>全世界所有字符对应的 Unicode 编码表：<a href="http://www.unicode.org/charts/">http://www.unicode.org/charts/</a></li></ul></blockquote><blockquote><p>Unicode 的编码的实现方式有三种 ：UTF-8、UTF-16、UTF-32</p><ul><li><code>UTF-8</code>编码中，一个英文和英文标点为一个字节，一个中文和中文标点为三个字节</li><li><code>UTF-16</code>编码中，一个英文字母字符或一个汉字字符存储都需要 2 个字节（<code>Unicode</code>扩展区的一些汉字存储需要<code>4</code>个字节）</li><li><code>UTF-32</code>编码中，世界上任何字符的存储都需要<code>4</code>个字节<blockquote><p>UTF 后的数字代表编码的最小单位，如<code>UTF-8</code>表示最小单位 <code>1</code>字节</p></blockquote></li><li><code>ASCII</code>码中，一个英文字母（不分大小写）为一个字节，一个中文汉字为两个字节</li></ul></blockquote><pre><code>let str = &quot;𝒳&quot;; // 占两个编码单元var reg1 = /^.$/g;var reg2 = /^.&#123;2&#125;$/g;var reg3 = /^.$/gu;console.log(str.match(reg1)); // nullconsole.log(str.match(reg2)); //[&#39;𝒳&#39;]console.log(str.match(reg3)); //[&#39;𝒳&#39;]</code></pre><blockquote><p>每个字符都有属性，但都需要结合 u 模式才有效。如</p><ul><li><code>L</code>属性表示是字母汉字，</li><li><code>P</code> 表示标点符号，</li><li><code>N</code>属性表示是数字，</li><li><code>Lu</code> 表示大写字母</li><li><code>Ll</code> 表示小写字母需要</li><li><code>Sc</code> 表示货币符号<code>￥</code>和<code>$</code><blockquote><p>常见的（一般类别）<code>General categories</code>，它们可匹配字母、数字、符号、标点符号、空格等等。<br>一般类别详见地址：<a href="https://unicode.org/reports/tr18/#General_Category_Property">https://unicode.org/reports/tr18/#General_Category_Property</a></p></blockquote></li><li>使用方法：</li></ul></blockquote><pre><code>var str = &quot;￥IBC艾编程电话：12033322,网址:https://www.icodingedu.com,$ &quot;;var reg1 = /\p&#123;L&#125;+/gu; //字母和汉字var reg2 = /\p&#123;N&#125;+/gu; // 数字var reg3 = /\p&#123;P&#125;+/gu; // 标点答号var reg4 = /\p&#123;Lu&#125;+/gu; // 大写字母var reg5 = /\p&#123;Ll&#125;+/gu; // 小写字母var reg6 = /\p&#123;Sc&#125;/gu; // 匹配￥console.log(str.match(reg1));console.log(str.match(reg2));console.log(str.match(reg3));console.log(str.match(reg4));console.log(str.match(reg5));console.log(str.match(reg6));</code></pre><blockquote><ul><li>字符也有<code>unicode</code>文字系统属性<code>Script = 文字系统</code>，下面是使用<code>\p&#123;sc=Han&#125;</code>获取中文字符<code>han</code>为中文系统，其他语言请查看<a href="http://www.unicode.org/standard/supported.html">http://www.unicode.org/standard/supported.html</a></li></ul></blockquote><pre><code>var str = &quot;IBC艾编程官方网址：https://www.icodingedu.com&quot;;var reg = /\p&#123;sc=Han&#125;+/gu;console.log(str.match(reg)); // [&#39;艾编程官方网址&#39;]</code></pre><blockquote><ul><li>常用于匹配中文的正则如下</li></ul></blockquote><pre><code>var reg = /[\u4e00-\u9fff]+/g;var str = &quot;IBC艾编程官方网址：https://www.icodingedu.com&quot;;console.log(str.match(reg)); // [&#39;艾编程官方网址&#39;]</code></pre><h3 id="八、正则相关方法"><a href="#八、正则相关方法" class="headerlink" title="八、正则相关方法"></a>八、正则相关方法</h3><table><thead><tr><th>方法</th><th>说明</th></tr></thead><tbody><tr><td>test()</td><td>测试某个字符串是否匹配正则表达式，匹配成功返回 true，否则返回 false</td></tr><tr><td>exec()</td><td>根据正则表达式，在字符串中进行查找，返回结果为 null 或数组</td></tr></tbody></table><blockquote><blockquote><p>test 方法，前面我们一直在用，这里就不介绍了</p></blockquote></blockquote><ol><li>exec 方法<blockquote><ul><li>在使用<code>exec</code>方法时，如果匹配失败，返回<code>null</code>，同时将正则表达式的<code>lastIndex</code>属性值重置为<code>0</code></li><li>如果匹配成功，则会返回一个数组，数组的第一项存放匹配成功的第一组文本，同时更新正则表达式的<code>lastIndex</code>属性值。</li><li>如果正则中使用了<code>g</code>标志，则<code>lastIndex</code>用来指定下一次匹配的起始索引值，</li><li>如果没有使用<code>g</code>标志，则一直返回的都是<code>lastIndex=0</code></li><li>如果给正则表达式加括号，就会形成捕获组</li></ul></blockquote></li></ol><p><strong>数组中对应项</strong></p><table><thead><tr><th>数组对应项</th><th>说明</th></tr></thead><tbody><tr><td>第一项</td><td>完全匹配成功的文本</td></tr><tr><td>第二项 … 第 n 项</td><td>每项对应一个匹配的捕获组</td></tr><tr><td>index</td><td>匹配成功的字符在原始字符串中的索引位置</td></tr><tr><td>input</td><td>匹配的原始字符串</td></tr><tr><td>groups</td><td>捕获组对象，其键是捕获组名，值是捕获组（值）。如果没有定义命名捕获组，则<code>groups</code>的值为<code>undefined</code></td></tr></tbody></table><blockquote><blockquote><p>exec 方法，默认只会输出第一次匹配成功的结果，如果后续还有匹配成功的结果，将不会输出</p></blockquote></blockquote><pre><code>var reg = /\d+[a-z]/;var str = &quot;ab23c345sa32&quot;;var arr = reg.exec(str);console.log(arr); // 返回结果见下图console.log(reg.lastIndex); // 0   下次匹配的起始索引值</code></pre><img src="exec方法-不加括号.png"><pre><code>var reg = /\d+[a-z]/;var str = &quot;ab23c345sa32&quot;;var arr = reg.exec(str);console.log(arr); // 返回结果见下图console.log(reg.lastIndex); // 0   下次匹配的起始索引值</code></pre><img src="exec方法-加括号.png"><pre><code>// 输出匹配成功的数组中的每一项的值console.log(arr[0]); // 拿到匹配成功的字符console.log(arr[1]); // 捕获组1console.log(arr[2]); // 捕获组1console.log(arr.index); // 匹配成功的字符串在原数组中的索引</code></pre><ol start="2"><li>exec() 方法的逐条遍历<blockquote><ul><li>当执行正则的 exec 方法时，如果正则中用g 修饰符，则 <code>RegExp</code> 对象是有状态的，也就是他会将上次成功匹配后的位置记录在他的<code>lastIndex</code>属性中</li><li>利用上面这个特性，我们可以对单个字符串中的多次匹配结果进行逐条的遍历</li></ul></blockquote></li></ol><pre><code>var reg = /\d+/g;var str = &quot;12ab23c345&quot;;var result1 = reg.exec(str);console.log(reg.lastIndex); // 2&gt;var result2 = reg.exec(str);console.log(reg.lastIndex); // 6&gt;var result3 = reg.exec(str);console.log(reg.lastIndex); // 10&gt;var result4 = reg.exec(str);console.log(reg.lastIndex); // 0&gt;console.log(result1, result2, result3, result4);//或者利用 while 循环来实现&gt;/**&gt; * search 将字符串中符合正则的字符组成数组输出&gt; * str 要搜索的字符串&gt; * reg 匹配的正则表达式&gt; */function search(str, reg) &#123;  var result = [];  var data = reg.exec(str);  while (data) &#123;    result.push(data[0]);    data = reg.exec(str);  &#125;  return result;&#125;&gt;// 应用var reg = /\d+/g;var str = &quot;12ab23c345&quot;;console.log(search(str, reg)); // [&#39;12&#39;, &#39;23&#39;, &#39;345&#39;]</code></pre><ol start="3"><li>注意事项<blockquote><ul><li>如果正则表达式在调用<code>exec</code>方法时，正则使用了<code>g</code>模式，则不要用<strong>同一个正则匹配多个字符串</strong></li><li>如果需要，则要修正<code>lastIndex</code>的值：<code>reg.lastIndex = 0</code></li><li>因为第二个字符串会从上一个字符串的结束位置开始找</li></ul></blockquote></li></ol><pre><code>var reg = /(\d+)([a-z])/g;var str1 = &quot;ab23c345sa32&quot;;var str2 = &quot;12ac345sa32&quot;;console.log(reg.exec(str1));console.log(reg.lastIndex);// 修正 lastIndex值reg.lastIndex = 0;console.log(reg.exec(str2));console.log(reg.lastIndex);</code></pre><blockquote><blockquote><p>温馨提示</p></blockquote><ul><li>在实际开发中，我们很少用到 <code>exec</code> 方法，你可以理解为 <code>exec</code> 为正则表达式的原始方法</li><li>许多其它的正则表达式方法会在内部调用<code>exec()</code>，包括一些字符串的方法</li></ul></blockquote><h3 id="九、字符串相关方法"><a href="#九、字符串相关方法" class="headerlink" title="九、字符串相关方法"></a>九、字符串相关方法</h3><blockquote><p>在字符串中有以下方法可以结合正则表达式来使用</p></blockquote><table><thead><tr><th>方法</th><th>描述</th></tr></thead><tbody><tr><td>search()</td><td>在字符串中根据正则表达式进行查找匹配，返回首次匹配到的位置索引，测试不到则返回<code>-1</code></td></tr><tr><td>match()</td><td>在字符串中根据正则表达式进行查找匹配，返回一个数组，找不到则返回 <code>null</code></td></tr><tr><td>matchAll</td><td>方法返回一个包含所有匹配正则表达式的结果及分组捕获组的迭代器。</td></tr><tr><td>replace()</td><td>使用替换字符串替换掉匹配到的子字符串，可以使用正则表达式</td></tr><tr><td>split()</td><td>分隔字符串为数组，可以使用正则表达式</td></tr></tbody></table><ol><li>search 方法<blockquote><ul><li>在字符串中根据正则表达式进行查找匹配，返回<strong>首次</strong>匹配到的位置索引，测试不到则返回 <code>-1</code></li><li>如果传入的参数不是正则表达式，也会将其转换为正则表达式对象来处理</li><li><code>str.search(regexp);</code></li></ul></blockquote></li></ol><blockquote><ul><li>search 方法检索 love 在字符串中的位置</li></ul></blockquote><pre><code>var str = &quot;I love you&quot;;//   var reg = /love/;var reg = &quot;love&quot;;console.log(str.search(reg)); //2</code></pre><blockquote><ul><li>search 方法检索字符串中 <code>icoding</code> 出现的位置，不分大小写</li></ul></blockquote><pre><code>var str = &quot;IcodingEdu&quot;;var reg1 = /icoding/i;var reg2 = &quot;icoding&quot;;console.log(str.search(reg1)); //0console.log(str.search(reg2)); //-1</code></pre><blockquote><ul><li>字符串不能做到不分大小写<blockquote><p>括号里既可以用字符串也可以用正则表达式，但正则表达式更加全能</p></blockquote></li></ul></blockquote><ol start="2"><li>match 方法<blockquote><ul><li>查找字符串中与正则表达式匹配的字符，返回结果为一个数组，找不到返回<code>null</code></li><li>如果正则使用<code>g</code>标志，则返回与正则表达式匹配的所有结果，但不会返回捕获组</li><li>如果正则未使用<code>g</code>标志，只返回第一个完整的匹配及相关的捕获组。（与<code>exec</code>方法返回结果一样）</li><li><code>str.match(regexp);</code></li></ul></blockquote></li></ol><blockquote><ul><li>提取出字符串中所有的 a</li></ul></blockquote><pre><code>var str = &quot;aabacaaadae&quot;;var reg1 = /a+/;var reg2 = /a+/g;console.log(str.match(reg1)); //[&#39;aa&#39;, index: 0, input: &#39;aabacaaadae&#39;, groups: undefined]console.log(str.match(reg2)); //[&quot;aa&quot;,&quot;a&quot;,&quot;aaa&quot;,&quot;a&quot;]</code></pre><blockquote><ul><li>提取颜色值中的数字</li></ul></blockquote><pre><code>var str = &quot;rbga(23,3,44,0.1)&quot;;var reg = /[\d]&#123;1,3&#125;(\.\d)?/g;console.log(str.match(reg)); //[&#39;23&#39;, &#39;3&#39;, &#39;44&#39;, &#39;0.1&#39;]</code></pre><ol start="3"><li>matchAll 方法<blockquote><ul><li><code>matchAll()</code>方法返回一个包含<strong>所有</strong>匹配正则表达式的结果及分组捕获组的<strong>迭代器</strong>。</li><li>正则对象<strong>必须</strong>是设置了全局模式<code>g</code>的形式，否则会抛出异常<code>TypeError</code></li><li>返回值一个迭代器（<strong>不可重用</strong>，结果耗尽需要再次调用方法，获取一个新的迭代器）<blockquote><p>matchAll 方法还存在浏览器的兼容问题</p></blockquote></li><li>在没有<code>matchAll</code>之前，通过在循环中调用<code>regexp.exec()</code> 来获取所有匹配项信息（<code>regexp</code> 需使用<code>/g</code>标志）</li><li><code>str.matchAll(regexp);</code></li></ul></blockquote></li></ol><blockquote><ul><li>该方法得到的是迭代器，因此需要用<code>for...of</code>拿到里面的值</li></ul></blockquote><pre><code>var str = &quot;12ab34scw563c&quot;;var reg = /\d+[a-z]/g;var matches = str.matchAll(reg); //得到的是迭代器console.log(matches);//可以用for...of拿到里面的值for (var item of matches) &#123;  console.log(item);&#125;</code></pre><img src="matchAll-1.png"><blockquote><ul><li>如果想得到表达式结果的一部分，就给那部分加括号</li></ul></blockquote><pre><code>var str = &quot;12ab34scw563c&quot;;var reg = /(\d+)[a-z]/g;var matches = str.matchAll(reg); //得到的是迭代器//可以用for...of拿到里面的值for (var item of matches) &#123;  console.log(item);  console.log(item[1]);&#125;</code></pre><img src="matchAll-2.png"><ol start="4"><li>replace 方法<blockquote><ul><li>使用替换字符串替换掉匹配到的子字符串</li><li><strong>第一个参数</strong>可以是一个正则表达式，也可以是一个字符串</li><li><strong>第二个参数</strong>，可以是一个字符串，也可以是一个<strong>函数</strong>，这个函数用来创建新子字符串，该函数的返回值将替换掉第一个参数匹配到的结果</li><li><code>str.replace(regexp|substr, newSubStr|function)</code></li></ul></blockquote></li></ol><blockquote><ul><li>&#x2F;&#x2F;将字符串中的字母全部替换成*</li></ul></blockquote><pre><code>var str = &quot;abc123fe4swfe56sw342&quot;;var reg = /[^0-9]/g;console.log(str.replace(reg, &quot;*&quot;)); //***123**4****56**342</code></pre><blockquote><ul><li>脏字过滤，将字符串中的所有垃圾，替换成*号</li></ul></blockquote><pre><code>var str = &quot;垃圾还是垃圾，把垃圾&quot;;console.log(str.replace(/垃圾/g, &quot;*&quot;)); //*还是*，把*</code></pre><blockquote><blockquote><p>replace 方法与原子组相关的结合，还有第二个参数为函数的情况，后面讲原子组是再细讲解</p></blockquote></blockquote><ol start="5"><li>split 方法<blockquote><ul><li>使用正则表达式或一个固定的字符串来分隔一个字符串，并将分隔后的子字符串存储到数组中</li><li>返回结果为分隔后的字符串形成的数组</li></ul></blockquote></li></ol><pre><code>str.split([separator[, limit]])// separator 分隔符// limit  整数，限定返回的分割片段数量`</code></pre><blockquote><ul><li>用数字来分隔字符串</li></ul></blockquote><pre><code>var str = &quot;ab12de34swfe4fe6&quot;;var result = str.split(/\d+/);console.log(result); // [&#39;ab&#39;, &#39;de&#39;, &#39;swfe&#39;, &#39;fe&#39;, &#39;&#39;]</code></pre><blockquote><ul><li>用<code>/</code>或<code>-</code>来分隔日期</li></ul></blockquote><pre><code>var str1 = &quot;2022/09/08&quot;;var str2 = &quot;2022-07-08&quot;;console.log(str1.split(/[\-/]/)); // [&#39;2022&#39;, &#39;09&#39;, &#39;08&#39;]console.log(str2.split(/[\-/]/)); // [&#39;2022&#39;, &#39;07&#39;, &#39;08&#39;]// 分隔后，我只想要年份和月份console.log(str1.split(/[\-/]/, 2)); // [&#39;2022&#39;, &#39;09&#39;]</code></pre><h3 id="十、原子组"><a href="#十、原子组" class="headerlink" title="十、原子组"></a>十、原子组</h3><blockquote><ul><li>在正则中我们可以利用<code>()</code>对匹配项进行分组，并能记住该匹配项等。</li><li><code>()</code>中的内容，我们也称为子表达式</li><li><strong>捕获</strong>：在正则表达式中，子表达式匹配到相应的内容时，系统会自动捕获这个行为，然后将子表达式匹配到的内容放入系统的缓存区中。我们把这个过程称之为<strong>“捕获”</strong></li></ul></blockquote><table><thead><tr><th>字符集</th><th>说明</th></tr></thead><tbody><tr><td><code>(x)</code></td><td>捕获组 匹配<code>x</code>并且记住匹配项。其中括号被称为<strong>捕获括号</strong>。正则中的 <code>\1、\2、... \n</code>分别表示<code>第一个、第二个、... 第n个</code>被捕获括号匹配的子字符串（也称<strong>反向引用</strong>）；在正则表达式的替换环节，即<code>str.replace(/(..)(...)/,&#39;$2 $1)</code>中，<code>$1</code>和<code>$2</code>分别表示第一个和第二被捕获括号匹配的子字符串；在正则表达式替换环节,<code>$&amp;</code>表示整个用于匹配的原字符串</td></tr><tr><td><code>(?:x)</code></td><td><strong>非捕获组</strong>匹配<code>x</code>但是不记住匹配项。这种括号叫作<strong>非捕获括号</strong>，使得你能够定义与正则表达式运算符一起使用的子表达式</td></tr><tr><td><code>(?&lt;name&gt;x)</code></td><td><strong>具名捕获组</strong>；匹配<code>x</code>并将其存储在返回的匹配项的<code>groups</code>属性中，该属性位于<code>&lt;name&gt;</code>指定的名称下</td></tr><tr><td><code>$反引号</code></td><td><code>$反引号</code>匹配成功的内容的左边</td></tr><tr><td><code>$&#39;</code></td><td><code>$单引号</code>匹配成功的内容的右边</td></tr></tbody></table><h4 id="x-捕获括号"><a href="#x-捕获括号" class="headerlink" title="(x) 捕获括号"></a>(x) 捕获括号</h4><blockquote><ul><li><code>(x)</code>用来表示捕获组，匹配<code>x</code>并且记住匹配项</li></ul></blockquote><ol><li>反向引用<blockquote><ul><li>正则中的<code>\1、\2、... \n</code>分别表示<code>第一个、第二个、... 第n个</code>被捕获括号匹配的<strong>子字符串</strong></li></ul></blockquote></li></ol><ul><li>案例： 匹配日期格式是否是以<code>-</code>或<code>/</code>相连，如：<code>2022-09-09</code>或<code>2022/09/08</code><blockquote><ul><li>上一节我们使用<code>[\-/]</code>来匹配<code>-</code>和<code>/</code>，但不能保证前后使用的符号相同</li></ul></blockquote></li></ul><pre><code>var dateString1 = &quot;2022-2/08&quot;;var reg = /^\d&#123;4&#125;([-/])\d&#123;1,2&#125;([-/])\d&#123;1,2&#125;$/;console.log(reg.test(dateString1)); //true</code></pre><blockquote><ul><li>在这里，可使用<code>\1</code>替换第二个<code>([-/])</code>，就可确保前后符号一样</li></ul></blockquote><pre><code>var dateString1 = &quot;2022-2/08&quot;;var dateString2 = &quot;2022-2-08&quot;;var reg = /^\d&#123;4&#125;([-/])\d&#123;1,2&#125;\1\d&#123;1,2&#125;$/;console.log(reg.test(dateString1)); //falseconsole.log(reg.test(dateString2)); //true</code></pre><ol start="2"><li>替换环节<blockquote><ul><li>在正则表达式的替换环节，即<code>str.replace(/(..)(...)/,&#39;$2 $1)</code>中，<code>$1</code>和<code>$2</code>分别表示第一个和第二被捕获括号匹配的子字符串</li></ul></blockquote></li></ol><ul><li>案例： 将日期2022-09-08 倒过来展示08-09-2022</li></ul><pre><code>var dateString = &quot;2022-09-08&quot;;var reg = /^(\d&#123;4&#125;)([\-/])(\d&#123;1,2&#125;)\2(\d&#123;1,2&#125;)$/;var rep = dateString.replace(reg, &quot;$4$2$3$2$1&quot;);console.log(rep); //08-09-2022</code></pre><ul><li>案例： 将(010)12398765 更改变010-12398765</li></ul><pre><code>var str = &quot;(010)12398765&quot;;var reg = /^\((\d&#123;3,4&#125;)\)(\d&#123;8&#125;)$/g;var rep = str.replace(reg, &quot;$1$2&quot;);console.log(rep); //01012398765</code></pre><blockquote><ul><li>在正则表达式替换环节，<code>$&amp;</code>表示整个用于匹配的<strong>原字符串</strong></li></ul></blockquote><ul><li>案例：将字符串中的艾编程添加链接<blockquote><blockquote><p><code>$&amp;</code>使得a标签中的文字和匹配文字一致</p></blockquote></blockquote></li></ul><pre><code>&gt;&lt;div class=&quot;info&quot;&gt;  艾编程是在大数据人工智能时代高速发展的今天成立的一家以提供各行业商业项目研发解决方案为核心的在线教育学习平台。&gt;&lt;/div&gt;&gt;&gt;&lt;script&gt;  var info = document.querySelector(&quot;.info&quot;);  var inner = info.innerHTML;  var reg = /艾编程/;  info.innerHTML = inner.replace(    reg,    &quot;&lt;a href=&#39;http://www.icodingedu.com&#39;&gt;$&amp;&lt;/a&gt;&quot;  );&gt;&lt;/script&gt;</code></pre><blockquote><blockquote><p>注意： 在数捕获括号时，从左往右数<code>(</code>括号个数</p></blockquote><ul><li>第一个<code>(</code>就代表<code>$1</code></li></ul></blockquote><pre><code>var str = &quot;12abs#B@12abs12#B@#B@&quot;;var reg = /^((\d+)[a-z]+)((#)([A-Z]@))\1\2\3\4\5$/;console.log(reg.test(str));// \1 ((\d+)[a-z]+)// \2 (\d+)// \3  ((#)([A-Z]@))  #B@// \4   (#)// \5  ([A-Z]@)</code></pre><ol start="3"><li>替换环节，第二个参数为函数<blockquote><ul><li>在正则表达式替换环节，<code>replace</code>方法的第二个参数如果是一个函数，则函数中参数详情如下：</li><li><code>str.replace(regexp,function(v,p1,p2,index,input,groups))</code></li><li>第一个参数v是匹配成功的那个字符串</li><li>参数p1,p2, …依次为第一个和第二被捕获括号匹配的子字符串;</li><li>index 为当前匹配成功项的开始索引</li><li>input 为原始匹配的字符串</li><li>groups 捕获组对象（具名捕获组组成的一个对象）</li></ul></blockquote></li></ol><pre><code>var str = &quot;12aw332sewe244sw&quot;;var reg = /(?&lt;number&gt;\d+)/g;str.replace(reg, function (v, p1, index, s, groups) &#123;  console.log(v, p1, index, s, groups);  console.log(groups.number);&#125;);</code></pre><img src="替换环节.png"><ul><li>不设捕获组时<blockquote><ul><li><code>str.replace(regexp,function(v,p1,p2,index,input,groups))</code>中的p1就会表示index的值，p2表示inputs的值，以此类推</li></ul></blockquote></li></ul><pre><code>var str = &quot;12aw332sewe244sw&quot;;var reg = /\d+[a-z]/g;str.replace(reg, function (v, p1, index, input, groups) &#123;  console.log(v, p1, index, input, groups);&#125;);//12a 0 12aw332sewe244sw undefined undefined//332s 4 12aw332sewe244sw undefined undefined//244s 11 12aw332sewe244sw undefined undefined</code></pre><h4 id="x-非捕获组"><a href="#x-非捕获组" class="headerlink" title="(?:x)非捕获组"></a><code>(?:x)</code>非捕获组</h4><blockquote><ul><li>非捕获组 匹配<code>x</code>但是<strong>不记住匹配项</strong>。这种括号叫作非捕获括号</li><li>使得你能够定义与正则表达式运算符一起使用的子表达式</li></ul></blockquote><pre><code>var str1 = &quot;ucaaauca&quot;;var reg1 = /uca+/g; // 表示a出现1次或多次var reg2 = /(uca)+/g; // 表示uca整体出现1次或多次console.log(str1.match(reg1));console.log(str1.match(reg2));</code></pre><blockquote><ul><li>如果不想记住<code>()</code>中的匹配项，则可以用<code>?:</code></li></ul></blockquote><pre><code>var str1 = &quot;ucaaauca&quot;;var reg1 = /(uca)+/g; // 表示uca整体出现1次或多次var reg2 = /(?:uca)+/g; // 表示uca整体出现1次或多次str1.replace(reg1, function (v, p1) &#123;  console.log(p1);&#125;);&gt;str1.replace(reg2, function (v, p1) &#123;  console.log(p1); //并没有捕获组内容，打印内容为捕获成功字符串的起始索引&#125;);</code></pre><h4 id="x-具名捕获组"><a href="#x-具名捕获组" class="headerlink" title="(?&lt;name&gt;x)具名捕获组"></a><code>(?&lt;name&gt;x)</code>具名捕获组</h4><blockquote><ul><li>匹配 “x” 并将其存储在返回的匹配项的<code>groups</code>属性中，该属性位于<code>&lt;name&gt;</code>指定的名称下</li></ul></blockquote><pre><code>var str = &quot;abc123def576&quot;;var reg = /[a-z]+(?&lt;number&gt;\d+)/g;var number = []; // 用来存放结果数据var arr = reg.exec(str);while (arr) &#123;  number.push(arr.groups.number); // 匹配的每一项的数字存到数组中  arr = reg.exec(str);&#125;console.log(number);</code></pre><blockquote><ul><li><strong>在正则表达式中，引用具名捕获组</strong>，可以使用<code>\k&lt;name&gt;</code>的写法，当然之前的<code>\n（n 是一个整数）</code>的写法也是可行的</li></ul></blockquote><pre><code>var str = &quot;a111222&quot;;var reg = /[a-z](?&lt;number&gt;1)\k&lt;number&gt;\1/g;console.log(str.match(reg)); // a111</code></pre><blockquote><ul><li>在 <code>replace</code> 方法中，使用<code>$&lt;name&gt;</code>引用具名组</li></ul></blockquote><pre><code>var str = &quot;a111222&quot;;var reg = /[a-z](?&lt;number&gt;1)\k&lt;number&gt;\1/g;console.log(str.replace(reg, &quot;*$&lt;number&gt;*&quot;)); // *1*222</code></pre><h4 id="表示匹配成功的内容的左边"><a href="#表示匹配成功的内容的左边" class="headerlink" title="&#96;$&#96;&#96;表示匹配成功的内容的左边"></a>&#96;$&#96;&#96;表示匹配成功的内容的<strong>左边</strong></h4><pre><code>var str = &quot;abcA123&quot;;var reg = /\A/;var res = str.replace(reg, &quot;$`&quot;);console.log(res); // abcabc123</code></pre><h4 id="’-表示匹配成功的内容的右边"><a href="#’-表示匹配成功的内容的右边" class="headerlink" title="$’ 表示匹配成功的内容的右边"></a>$’ 表示匹配成功的内容的右边</h4><pre><code>var str = &quot;abcA123&quot;;var reg = /\A/;var res = str.replace(reg, &quot;$&#39;&quot;);console.log(res); // abc123123</code></pre><h3 id="十一、？禁止贪婪"><a href="#十一、？禁止贪婪" class="headerlink" title="十一、？禁止贪婪"></a>十一、<code>？</code>禁止贪婪</h3><blockquote><p><code>？</code>如果紧跟在任何量词<code>\*、 +、? 或&#123;&#125;</code>的后面，将会使量词变为<strong>非贪婪</strong>（匹配尽量少的字符），和缺省使用的贪婪模式（匹配尽可能多的字符）正好相反</p><blockquote><p>匹配尽量少的字符，但并不等于只匹配一个</p></blockquote></blockquote><pre><code>var str = &quot;abcddddcdddd&quot;;var reg = /cd+?/g;var res = str.match(reg);console.log(res); // [&#39;cd&#39;, &#39;cd&#39;]</code></pre><pre><code>var str = &quot;abdacd&quot;;var reg1 = /\w+d/g;var reg2 = /\w+?d/g;console.log(str.match(reg1));//[&#39;abdacd&#39;]console.log(str.match(reg2));//[&#39;abd&#39;,&#39;acd&#39;]</code></pre><ul><li><p>拿到捕获组内容的方法</p><blockquote><ul><li>字符串相关方法：<code>matchAll</code>、<code>replace</code>(没有意义)</li><li>正则相关方法：<code>exec方法</code>+while循环</li></ul></blockquote></li><li><p>案例：匹配出 span 标签中的内容</p></li></ul><pre><code>&gt;&lt;div class=&quot;box&quot;&gt;&gt;  &lt;span&gt;清心&lt;/span&gt;&gt;  &lt;span&gt;艾编程&lt;/span&gt;&gt;  &lt;span&gt;前端&lt;/span&gt;&gt;&lt;/div&gt;&gt;&lt;script&gt;var box = document.querySelector(&quot;.box&quot;);var inner = box.innerHTML;var reg = /&lt;span&gt;([\s\S]+?)&lt;\/span&gt;/g;var result = [];&gt;//match方法var matches = inner.matchAll(reg);for (var item of matches) &#123;  result.push(item[1]);&#125;console.log(result);// [&#39;清心&#39;, &#39;艾编程&#39;, &#39;前端&#39;]&gt;//exec方法var item = reg.exec(inner);while (item) &#123;  result.push(item[1]);  item = reg.exec(inner);&#125;console.log(result);// [&#39;清心&#39;, &#39;艾编程&#39;, &#39;前端&#39;]&gt;&lt;/script&gt;</code></pre><ul><li>案例：匹配对应的标签</li></ul><pre><code>&gt;&lt;div class=&quot;box&quot;&gt;&gt;  我秒是我&gt;  &lt;p&gt;艾编程&lt;/p&gt;&gt;  &lt;h3&gt;清心老师&lt;/h3&gt;&gt;  &lt;div&gt;前端内容&lt;/div&gt;&gt;  &lt;p&gt;&lt;/p&gt;&gt;&lt;/div&gt;&gt;&gt;&lt;script&gt;  var box = document.querySelector(&quot;.box&quot;);  var innerHTML = box.innerHTML;  var reg = /&lt;([a-z]+\d?)&gt;[\s\S]*?&lt;\/\1&gt;/gi;  var res = innerHTML.match(reg);  console.log(res);&gt;&lt;/script&gt;</code></pre><h3 id="十二、断言匹配"><a href="#十二、断言匹配" class="headerlink" title="十二、断言匹配"></a>十二、断言匹配</h3><table><thead><tr><th>字符</th><th>说明</th></tr></thead><tbody><tr><td>x(?&#x3D;y)</td><td>先行断言：x的右边被y紧跟随之时匹配x</td></tr><tr><td>(?&lt;&#x3D;y)x</td><td>后行断言：x 的左边紧跟随y时，匹配x</td></tr><tr><td>x(?!y)</td><td>先行否定断言： x右边没有被y紧跟随之时匹配x</td></tr><tr><td>(?&lt;!y)x</td><td>后行否定断言： x的左边没有被y紧随时匹配x</td></tr></tbody></table><h4 id="x-y"><a href="#x-y" class="headerlink" title="x(?&#x3D;y)"></a>x(?&#x3D;y)</h4><blockquote><ul><li>先行断言（正向预查、正预测、前瞻）：<code>x</code>的右边被<code>y</code><strong>紧跟随之时</strong>匹配<code>x</code></li><li><code>y</code><strong>不是</strong>匹配结果的一部分</li><li>先行断言是<strong>从左往右</strong>看</li></ul></blockquote><ol><li>提取 x 字符后面紧跟随 xxx 字符的 x 字符<blockquote><ul><li>将字符串中a后面紧跟随c的a替换成*号</li></ul></blockquote></li></ol><pre><code>var str = &quot;abcacaecac&quot;;var reg = /a(?=c)/g;str = str.replace(reg, &quot;*&quot;);console.log(str); // abc*caec*c</code></pre><blockquote><ul><li>将字符串中<code>web前端</code>或<code>java</code>后面紧跟随<code>视频</code>的 web 前端和 java 变成红色 （字母不区分大小写）</li></ul></blockquote><pre><code>&gt;&lt;div class=&quot;box&quot;&gt;&lt;/div&gt;&gt;&lt;script&gt;  var box = document.querySelector(&quot;.box&quot;);  var str =    &quot;艾编程教育提供相关Web前端、java教程，相关视频地址：web前端视频，Java视频等&quot;;  var reg = /(?:web前端|java)(?=视频)/gi;  //box.innerHTML = str.replace(reg, &quot;&lt;span style=&#39;color:red&#39;&gt;$&amp;&lt;/span&gt;&quot;);  box.innerHTML = str.replace(reg, function (v) &#123;    return &quot;&lt;span style=&#39;color:red&#39;&gt;&quot; + v + &quot;&lt;/span&gt;&quot;;  &#125;);&gt;&lt;/script&gt;</code></pre><ol start="2"><li>理解<code>x(?=y)(?=z)</code>匹配<blockquote><ul><li>这是不成立的：<code>x(?=y)(?=z)</code>表示<code>x</code>的后面（右边）要紧跟随着<code>y</code>，同时又要紧跟随着<code>z</code></li><li>只有一种情况下成立：y&#x3D;z时</li></ul></blockquote></li></ol><pre><code>var reg = /1(?=a)(?=A)/g; //这种情况肯定是不成立的var str = &quot;1aA&quot;;console.log(str.match(reg)); // null&gt;// 添加i标志，也就是对a和A不区分大小写时，也就成立var reg = /1(?=a)(?=A)/gi;var str = &quot;1a&quot;;console.log(str.match(reg)); // [&#39;1&#39;]</code></pre><ol start="3"><li>理解<code>x((?=y)|(?=z))</code><blockquote><ul><li>如果要表示<code>x</code>的后面（右边）要紧跟随着<code>y</code>或紧跟随着<code>z</code></li></ul></blockquote></li></ol><ul><li>匹配 a 后面紧跟 1 或紧跟随 2 的 a，替换成 * 号</li></ul><pre><code>var reg = /a((?=1)|(?=2))/g;console.log(&quot;a1ab&quot;.replace(reg, &quot;*&quot;)); // *1abconsole.log(&quot;a2ac&quot;.replace(reg, &quot;*&quot;)); // *2acconsole.log(&quot;a3ad&quot;.replace(reg, &quot;*&quot;)); // a3ad</code></pre><ol start="4"><li>理解 <code>/(?=.*y)(?=.*z)/</code> 匹配<blockquote><ul><li><code>/(?=.*y)(?=.*z)/</code> 表示字符串中必须同时出现 <code>y</code> 和 <code>z</code> 字符</li></ul></blockquote></li></ol><ul><li>某个字符串中必需出现 艾编程</li></ul><pre><code>var reg = /艾编程/;console.log(reg.test(&quot;艾编程教育&quot;)); //trueconsole.log(reg.test(&quot;西安艾编程&quot;)); //trueconsole.log(reg.test(&quot;艾编程&quot;)); //true</code></pre><ul><li>匹配的字符串中必需包含：艾编程、前端 这两组词<blockquote><ul><li>由于不需要跟在谁后面，所以不写x</li></ul></blockquote></li></ul><pre><code>var reg = /(?=.*艾编程)(?=.*前端)/;console.log(reg.test(&quot;艾编程有前端课程&quot;));//trueconsole.log(&quot;艾编程有前端课程&quot;.match(reg)); //[&quot;&quot;]&gt;console.log(reg.test(&quot;前端方面的课程艾编程有&quot;));//trueconsole.log(&quot;前端方面的课程艾编程有&quot;.match(reg)); //[&quot;&quot;]&gt;console.log(reg.test(&quot;艾编程有web端&quot;)); //falseconsole.log(&quot;艾编程有web端&quot;.match(reg)); //null</code></pre><blockquote><blockquote><p>注意，同时限制长度和所包含内容时</p></blockquote><ul><li><code>/(?=.*y)(?=.*z)/</code>匹配到的字符是<code>&quot;&quot;</code>，所以不用把这个字符算进去</li></ul></blockquote><ul><li>字符串的长度为 8 位，但必需包含：艾编程、前端 这两组词</li></ul><pre><code>// 某个字符串中必需包含 艾编程、前端var reg = /^(?=.*艾编程)(?=.*前端).&#123;8&#125;$/g;console.log(reg.test(&quot;艾编程有前端课程&quot;)); // trueconsole.log(reg.test(&quot;艾编程有web前端&quot;)); // falseconsole.log(reg.test(&quot;艾编程前端&quot;)); // true&gt;var str1 = &quot;艾编程有前端课程&quot;;var str2 = &quot;艾编程有web前端&quot;;var str3 = &quot;艾编程前端&quot;;console.log(str1.match(reg)); //[&#39;艾编程有前端课程&#39;]console.log(str2.match(reg)); // nullconsole.log(str3.match(reg)); // null</code></pre><ul><li>匹配的字符串长度为6-8位的，但必须包含至少一个大写字母、一个小写字母和一个数字，同时不能有空白字符<blockquote><ul><li><code>\S</code>：匹配任意不是空白符的字符</li></ul></blockquote></li></ul><pre><code>var reg = /^(?=.*[a-z])(?=.*[A-Z])(?=.*\d)\S&#123;6,8&#125;$/;console.log(reg.test(&quot;A123q222&quot;)); // trueconsole.log(reg.test(&quot;2Wswee222&quot;)); // falseconsole.log(reg.test(&quot;sww1A&quot;)); // falseconsole.log(reg.test(&quot;sww1A2&quot;)); // true</code></pre><h4 id=""><a href="#" class="headerlink" title="(?&lt;&#x3D;y)x"></a>(?&lt;&#x3D;y)x</h4><blockquote><ul><li>后行断言：<code>x</code>的左边紧跟随<code>y</code>时，匹配<code>x</code></li><li><code>y</code>不是匹配结果的一部分</li><li>后行断言是<strong>从右往左看</strong>（先看右边，再看左边）</li></ul></blockquote><ol><li>提取 x 前面（左边）紧跟随 xxx 字符的 x</li></ol><ul><li>获取数字前面（左边）紧跟随字母的数字</li></ul><pre><code>var str = &quot;a12bc43bc32&quot;;var reg = /(?&lt;=\w)\d+/g;console.log(str.match(reg)); // [&#39;12&#39;, &#39;43&#39;, &#39;32&#39;]</code></pre><ul><li>将 11 位电话号码的后 4 位替换成 ****号</li></ul><pre><code>// 将电话号码的后四位改变****var tel = &quot;清心电话:12323457612&quot;;var reg = /(?&lt;=\d&#123;7&#125;)\d&#123;4&#125;/g;var res = tel.replace(reg, &quot;****&quot;);console.log(res); // 清心电话:1232345****</code></pre><ul><li>将视频的前面是前端的”视频”替换成”视频教程”</li></ul><pre><code>var reg = /(?&lt;=前端)视频/g;var str = &quot;艾编程前端视频,java视频&quot;;console.log(str.match(reg));var res = str.replace(reg, function (v) &#123;  return v + &quot;教程&quot;;&#125;);console.log(res);</code></pre><ol start="2"><li>理解(?&lt;&#x3D;y)(?&lt;&#x3D;z)x 匹配<blockquote><ul><li>这是不成立的：<code>(?&lt;=y)(?&lt;=z)x</code> 表示前面要紧跟着 <code>y</code> 同时又要紧跟随着 <code>z</code></li><li>只有一种情况下成立：y&#x3D;z时</li></ul></blockquote></li></ol><pre><code>var str = &quot;a1&quot;;var reg = /(?&lt;=A)(?&lt;=a)1/g; // 表示 1前面要紧跟随着A同时又要紧跟随着a,显然是不可能成立的console.log(str.match(reg)); // null&gt;var str = &quot;a1&quot;;var reg = /(?&lt;=A)(?&lt;=a)1/gi; // 添加了i标志，这样A和a不区分大小写，相当于是一样的console.log(str.match(reg)); // [&#39;1&#39;]</code></pre><ol start="3"><li>理解<code>((?=y)|(?=z))x</code><blockquote><ul><li>获取字符串中数字(包括小数)前被￥或$跟随的数字</li></ul></blockquote></li></ol><pre><code>var str = `书￥20.00  笔$30.00本子$52尺子￥0.5总费用:50.5元`;var reg = /((?&lt;=\$)|(?&lt;=￥))(\d+(\.\d)?\d*)/g;console.log(str.match(reg));</code></pre><ol start="4"><li>区分 <code>/(?&lt;=.*y)(?&lt;=.*z)x/</code> 与 <code>/(?&lt;=y.*)(?&lt;=z.*)x/</code><blockquote><ul><li><code>/(?&lt;=.*y)(?&lt;=.*z)x/</code>表示<code>x</code>前面<strong>紧跟随</strong>着<code>y</code>同时又要<strong>紧跟随</strong>着 x<blockquote><p>从右往左看，离x最近的是z和y</p></blockquote></li><li><code>/(?&lt;=y.*)(?&lt;=z.*)x/</code>表示 <code>x</code>前面必需<strong>包含</strong>y，同时又包含 z<blockquote><p>从右往左看，离x最近的是<code>.*</code></p></blockquote></li></ul></blockquote></li></ol><blockquote><ul><li>第一种情况，只有在y&#x3D;z时才成立</li></ul></blockquote><pre><code>var reg = /(?&lt;=.*a)(?&lt;=.*b)/g;var str = &quot;ab&quot;;console.log(str.match(reg)); // null&gt;//\d包含1var reg = /(?&lt;=.*\d)(?&lt;=.*1)/g;var str = &quot;a1&quot;;console.log(str.match(reg)); // [&#39;&#39;]</code></pre><ul><li>字符串中必需包含 a 和 b</li></ul><pre><code>var reg = /(?&lt;=a.*)(?&lt;=b.*)/g;console.log(&quot;ab&quot;.match(reg)); // [&#39;&#39;]console.log(&quot;1ab&quot;.match(reg)); // [&#39;&#39;]console.log(&quot;ab1&quot;.match(reg)); // [&#39;&#39;, &#39;&#39;]&gt;console.log(reg.test(&quot;ab&quot;)); // trueconsole.log(reg.test(&quot;1ab&quot;)); // trueconsole.log(reg.test(&quot;ab1&quot;)); // true</code></pre><blockquote><blockquote><p>注意：同时限制内容和长度时，长度按要求写，并写在最前面(与先行断言相反)</p></blockquote></blockquote><ul><li>检测字符串是否为6-8位，同时必需包含大写 A 和小写 a 和数字</li></ul><pre><code>var reg = /^.&#123;6,8&#125;(?&lt;=[A-Z].*)(?&lt;=[a-z].*)(?&lt;=[0-9].*)$/g;console.log(&quot;aAwwi9$@&quot;.match(reg));console.log(&quot;aAwwi9$@3&quot;.match(reg));console.log(&quot;aAww*&amp;&quot;.match(reg));console.log(&quot;aAww*1&quot;.match(reg));</code></pre><h4 id="x-y-1"><a href="#x-y-1" class="headerlink" title="x(?!y)"></a>x(?!y)</h4><blockquote><ul><li>先行否定断言（也称正向否定查找）：x 右边没有被y紧跟随之时匹配x</li></ul></blockquote><pre><code>var str = &quot;ab123abc&quot;;//后面没有数字的小写字母var reg = /[a-z]+(?!\d)/g;console.log(str.match(reg)); // [&#39;a&#39;, &#39;abc&#39;]</code></pre><h4 id="-1"><a href="#-1" class="headerlink" title="(?&lt;!y)x"></a>(?&lt;!y)x</h4><blockquote><ul><li>后行否定断言（也称反向否定查找）： x的左边没有被y紧随时匹配x</li></ul></blockquote><pre><code>var str = &quot;ab123abc&quot;;//前面没有数字的小写字母var reg = /(?&lt;!\d)[a-z]+/g;console.log(str.match(reg)); // [&#39;ab&#39;, &#39;bc&#39;]</code></pre><blockquote><ul><li>限定部分长度：同时使用先行否定断言和后行否定断言</li></ul></blockquote><ul><li>中国邮政编码 （中国邮政编码为 6 位数字，第一位不能是 0）</li></ul><pre><code>var str = &quot;A区邮政编码：123456  B区邮政编码：129832&quot;;var reg = /(?&lt;!\d)[1-9]\d&#123;5&#125;(?!\d)/g;console.log(str.match(reg));// [&#39;123456&#39;, &#39;129832&#39;]</code></pre><h3 id="十三、正则表达式应用案例"><a href="#十三、正则表达式应用案例" class="headerlink" title="十三、正则表达式应用案例"></a>十三、正则表达式应用案例</h3><ol><li>批量使用正则完成某个验证<blockquote><ul><li>这是一种思想，一种另辟蹊径的方式；当我们无法用一个正则表达式写出来的时候，可以尝试根据不同的要求，写出不同的表达式，然后将他们汇总</li><li>用户名只能是数字和字母组成，但必需包含一个大写字母</li></ul></blockquote></li></ol><pre><code>//用户名只能是6-8位数字和字母组成，但必需包含一个大写字母var str = &quot;abc12S&quot;;//   var reg1 = /[a-z0-9]&#123;6,8&#125;/;//   var reg2 = /[A-Z]/;var regs = [/^[a-z0-9]&#123;6,8&#125;$/i, /[A-Z]/];// state=true表示字符串能通过所有正则的检测 ，假设一开始为truevar state = true;for (var i = 0; i &lt; regs.length; i++) &#123;  state = regs[i].test(str);  if (!state) &#123;    break;  &#125;&#125;if (state) &#123;  console.log(&quot;字符串满足要求&quot;);&#125; else &#123;  console.log(&quot;字符串不满足要求&quot;);&#125;</code></pre><blockquote><ul><li>利用数组的 every 方法来实现</li></ul></blockquote><pre><code>var str = &quot;abc1234_s&quot;;const regs = [/^[a-z0-9_]&#123;5,10&#125;$/i, /[A-Z]/];var state = regs.every(function (item) &#123;  return item.test(str);&#125;);&gt;console.log(state);</code></pre><ol start="2"><li>用户注册密码验证，项目实践</li></ol><pre><code>&gt;&lt;style&gt;  body,  html,  p &#123;    margin: 0;    padding: 0;  &#125;  .register &#123;    width: 300px;    margin: 100px;  &#125;  .pwd input &#123;    box-sizing: border-box;    margin-bottom: 20px;    width: 100%;    height: 50px;    border-radius: 5px;    outline: none;    border: 1px solid #666;  &#125;  .pwd input::placeholder &#123;    font-size: 18px;    position: relative;    top: 2px;    left: 10px;  &#125;  .register .tip &#123;    border: 1px solid #50bdeb;    border-radius: 10px;    background-color: #dbecf5;    padding: 10px;    color: #666;  &#125;  .tip p &#123;    padding-left: 30px;    line-height: 30px;    background: url(../src/错叉_块.png) no-repeat;    background-size: 20px;    background-position: 0px 6px;  &#125;  .tip p.right &#123;    background-image: url(../src/对.png);    background-size: 25px;    background-position-y: 3px;    color: #56c4f3;  &#125;&gt;&lt;/style&gt;&gt;&gt;&lt;div class=&quot;register&quot;&gt;&gt;  &lt;div class=&quot;pwd&quot;&gt;&gt;    &lt;input type=&quot;text&quot; class=&quot;password&quot; placeholder=&quot;密码&quot; /&gt;&gt;  &lt;/div&gt;&gt;  &lt;div class=&quot;tip&quot;&gt;&gt;    &lt;p class=&quot;upper&quot;&gt;至少有一个大写字母&lt;/p&gt;&gt;    &lt;p class=&quot;lower&quot;&gt;至少有一个小写字母&lt;/p&gt;&gt;    &lt;p class=&quot;number&quot;&gt;至少有一个数字&lt;/p&gt;&gt;    &lt;p class=&quot;special&quot;&gt;至少有一个特殊字符&lt;/p&gt;&gt;    &lt;p class=&quot;blank-space&quot;&gt;不能以空白符开头&lt;/p&gt;&gt;    &lt;p class=&quot;length&quot;&gt;密码长度8-12之间&lt;/p&gt;&gt;  &lt;/div&gt;&gt;&lt;/div&gt;&gt;&lt;script&gt;  var input = document.querySelector(&quot;.password&quot;);  var upperEl = document.querySelector(&quot;.upper&quot;);  var lowerEl = document.querySelector(&quot;.lower&quot;);  var numberEl = document.querySelector(&quot;.number&quot;);  var specialEl = document.querySelector(&quot;.special&quot;);  var blankSpaceEl = document.querySelector(&quot;.blank-space&quot;);  var lengthEl = document.querySelector(&quot;.length&quot;);&gt;  //绑定keyup事件  input.onkeyup = function () &#123;    var value = this.value;    //至少有一个大写字母    var upper = /[A-Z]/;    if (upper.test(value)) &#123;      upperEl.classList.add(&quot;right&quot;);    &#125; else &#123;      upperEl.classList.remove(&quot;right&quot;);    &#125;    //至少有一个小写字母    var lower = /[a-z]/;    if (lower.test(value)) &#123;      lowerEl.classList.add(&quot;right&quot;);    &#125; else &#123;      lowerEl.classList.remove(&quot;right&quot;);    &#125;    //至少有一个数字    var number = /[0-9]/;    if (number.test(value)) &#123;      numberEl.classList.add(&quot;right&quot;);    &#125; else &#123;      numberEl.classList.remove(&quot;right&quot;);    &#125;    var special = /[-!\.@#\$%&amp;\^\*~]/;    if (special.test(value)) &#123;      specialEl.classList.add(&quot;right&quot;);    &#125; else &#123;      specialEl.classList.remove(&quot;right&quot;);    &#125;    //不能以空白符开头    var blankSpace = /^[\S]/;    if (blankSpace.test(value)) &#123;      blankSpaceEl.classList.add(&quot;right&quot;);    &#125; else &#123;      blankSpaceEl.classList.remove(&quot;right&quot;);    &#125;    //密码长度8-12之间    var length = /^.&#123;8,12&#125;$/;    if (length.test(value)) &#123;      lengthEl.classList.add(&quot;right&quot;);    &#125; else &#123;      lengthEl.classList.remove(&quot;right&quot;);    &#125;  &#125;;&gt;&lt;/script&gt;</code></pre><h3 id="十四、正则相关工具"><a href="#十四、正则相关工具" class="headerlink" title="十四、正则相关工具"></a>十四、正则相关工具</h3><blockquote><ul><li>正则在线测试工具：<a href="https://regexr-cn.com/">https://regexr-cn.com</a></li><li>VsCode 插件：any-rule 提供了常用的正则表达式，直接拿来即用</li></ul></blockquote><h4 id="校验数字的表达式"><a href="#校验数字的表达式" class="headerlink" title="校验数字的表达式"></a>校验数字的表达式</h4><blockquote><ul><li>1、数字：<code>^[0-9]*$</code></li><li>2、n 位的数字：<code>^\d&#123;n&#125;$</code></li><li>3、至少 n 位的数字：<code>^\d&#123;n,&#125;$</code></li><li>4、m-n位的数字：<code>^\d&#123;m,n&#125;$</code></li><li>5、零和非零开头的数字：<code>^(0|[1-9][0-9]*)$</code></li><li>6、非零开头的最多带两位小数的数字：<code>^([1-9][0-9]*)+(\.[0-9]&#123;1,2&#125;)?$</code></li><li>7、带1-2位小数的正数或负数：<code>^(\-)?\d+(\.\d&#123;1,2&#125;)$</code></li><li>8、正数、负数、和小数：<code>^(\-|\+)?\d+(\.\d+)?$</code></li><li>9、有两位小数的正实数：<code>^[0-9]+(\.[0-9]&#123;2&#125;)?$</code></li><li>10、有1~3位小数的正实数：<code>^[0-9]+(\.[0-9]&#123;1,3&#125;)?$</code></li><li>11、非零的正整数：<code>^[1-9]\d*$或^([1-9][0-9]*)&#123;1,3&#125;$或 ^\+?[1-9][0-9]*$</code></li><li>12、非零的负整数：<code>^\-[1-9][]0-9&quot;*$ 或^-[1-9]\d*$</code></li><li>13、非负整数：<code>^\d+$ 或^[1-9]\d*|0$</code></li><li>14、非正整数：<code>^-[1-9]\d*|0$或 ^((-\d+)|(0+))$</code></li><li>15、非负浮点数：<code>^\d+(\.\d+)?$或^[1-9]\d*\.\d*|0\.\d*[1-9]\d*|0?\.0+|0$</code></li><li>16、非正浮点数：<code>^((-\d+(\.\d+)?)|(0+(\.0+)?))$</code>或<code>^(-([1-9]\d*\.\d*|0\.\d*[1-9]\d*))|0?\.0+|0$</code></li><li>17、正浮点数：<code>^[1-9]\d*\.\d*|0\.\d*[1-9]\d*$ </code>或<code>^(([0-9]+\.[0-9]*[1-9][0-9]*)|([0-9]*[1-9][0-9]*\.[0-9]+)|([0-9]*[1-9][0-9]*))$</code></li><li>18、负浮点数：<code>^-([1-9]\d*\.\d*|0\.\d*[1-9]\d*)$</code> 或<code>^(-(([0-9]+\.[0-9]*[1-9][0-9]*)|([0-9]*[1-9][0-9]*\.[0-9]+)|([0-9]*[1-9][0-9]*)))$</code></li><li>19、浮点数：<code>^(-?\d+)(\.\d+)?$</code> 或 <code>^-?([1-9]\d*\.\d*|0\.\d*[1-9]\d*|0?\.0+|0)$</code></li></ul></blockquote><h4 id="校验字符的表达式"><a href="#校验字符的表达式" class="headerlink" title="校验字符的表达式"></a>校验字符的表达式</h4><blockquote><ul><li>1、汉字：<code>^[\u4e00-\u9fa5]&#123;0,&#125;$</code></li><li>2、英文和数字：<code>^[A-Za-z0-9]+$</code> 或 <code>^[A-Za-z0-9]&#123;4,40&#125;$</code></li><li>3、长度为 3-20 的所有字符：<code>^.&#123;3,20&#125;$</code></li><li>4、由 26 个英文字母组成的字符串：<code>^[A-Za-z]+$</code></li><li>5、由 26 个大写英文字母组成的字符串：<code>^[A-Z]+$</code></li><li>6、由 26 个小写英文字母组成的字符串：<code>^[a-z]+$</code></li><li>7、由数字和 26 个英文字母组成的字符串：<code>^[A-Za-z0-9]+$</code></li><li>8、由数字、26 个英文字母或者下划线组成的字符串：<code>^\w+$ 或 ^\w&#123;3,20&#125;$</code></li><li>9、中文、英文、数字包括下划线：<code>^[\u4E00-\u9FA5A-Za-z0-9_]+$</code></li><li>10、中文、英文、数字但不包括下划线等符号：<code>^[\u4E00-\u9FA5A-Za-z0-9]+$</code> 或<code>^[\u4E00-\u9FA5A-Za-z0-9]&#123;2,20&#125;$</code></li><li>11、可以输入含有<code>^%&amp;&#39;,;=?$\&quot;</code>等字符：<code>[\^%&amp;&#39;,;=?$\\]+</code></li><li>12、禁止输入含有<del>的字符：&#96;[^</del>]+&#96;</li></ul></blockquote><h4 id="特殊需求表达式"><a href="#特殊需求表达式" class="headerlink" title="特殊需求表达式"></a>特殊需求表达式</h4><blockquote><ul><li>1、Email 地址：<code>^\w+([-+.]\w+)*@\w+([-.]\w+)*\.\w+([-.]\w+)*$</code></li><li>2、域名：<code>[a-zA-Z0-9][-a-zA-Z0-9]&#123;0,62&#125;(\.[a-zA-Z0-9][-a-zA-Z0-9]&#123;0,62&#125;)+\.?</code></li><li>3、InternetURL：<code>[a-zA-z]+://[^\s]*</code>或 <code>^http://([\w-]+\.)+[\w-]+(/[\w-./?%&amp;=]*)?$</code></li><li>4、手机号码：<code>^(13[0-9]|14[01456879]|15[0-35-9]|16[2567]|17[0-8]|18[0-9]|19[0-35-9])\d&#123;8&#125;$</code></li><li>5、电话号码（”XXX-XXXXXXX”、”XXXX-XXXXXXXX”、”XXX-XXXXXXX”、”XXX-XXXXXXXX”、”XXXXXXX”和”XXXXXXXX）：<code>^(\(\d&#123;3,4&#125;-)|\d&#123;3.4&#125;-)?\d&#123;7,8&#125;$</code></li><li>6、国内电话号码（0511-4405222、021-87888822）：<code>\d&#123;3&#125;-\d&#123;8&#125;|\d&#123;4&#125;-\d&#123;7&#125;</code></li><li>7、电话号码正则表达式（支持手机号码，3-4 位区号，7-8 位直播号码，1－4 位分机号）: <code>((\d&#123;11&#125;)|^((\d&#123;7,8&#125;)|(\d&#123;4&#125;|\d&#123;3&#125;)-(\d&#123;7,8&#125;)|(\d&#123;4&#125;|\d&#123;3&#125;)-(\d&#123;7,8&#125;)-(\d&#123;4&#125;|\d&#123;3&#125;|\d&#123;2&#125;|\d&#123;1&#125;)|(\d&#123;7,8&#125;)-(\d&#123;4&#125;|\d&#123;3&#125;|\d&#123;2&#125;|\d&#123;1&#125;))$)</code></li><li>8、身份证号（15 位、18 位数字），最后一位是校验位，可能为数字或字符 X：<code>(^\d&#123;15&#125;$)|(^\d&#123;18&#125;$)|(^\d&#123;17&#125;(\d|X|x)$)</code></li><li>9、帐号是否合法（字母开头，允许 5-16 字节，允许字母数字下划线）：<code>^[a-zA-Z][a-zA-Z0-9_]&#123;4,15&#125;$</code></li><li>10、密码（以字母开头，长度在 6~18 之间，只能包含字母、数字和下划线）：<code>^[a-zA-Z]\w&#123;5,17&#125;$</code></li><li>11、强密码（必须包含大小写字母和数字的组合，不能使用特殊字符，长度在 8-10 之间）：<code>^(?=.*\d)(?=.*[a-z])(?=.*[A-Z])[a-zA-Z0-9]&#123;8,10&#125;$</code></li><li>12、强密码（必须包含大小写字母和数字的组合，可以使用特殊字符，长度在 8-10 之间）：<code>^(?=.*\d)(?=.*[a-z])(?=.*[A-Z]).&#123;8,10&#125;$</code></li><li>13、日期格式：<code>^\d&#123;4&#125;-\d&#123;1,2&#125;-\d&#123;1,2&#125;</code></li><li>14、一年的 12 个月（01 ～ 09 和 1 ～ 12）：<code>^(0?[1-9]|1[0-2])$</code></li><li>15、一个月的 31 天（01 ～ 09 和 1 ～ 31）：<code>^((0?[1-9])|((1|2)[0-9])|30|31)$</code></li><li>16、钱的输入格式： 有四种钱的表示形式我们可以接受：”10000.00” 和 “10,000.00”, 和没有 “分” 的 “10000” 和 “10,000” ：<code>^[1-9][0-9]*$</code></li><li>17、这表示任意一个不以 0 开头的数字，但是，这也意味着一个字符”0”不通过，所以我们采用下面的形式：<code>^(0|[1-9][0-9]*)$</code></li><li>18、一个 0 或者一个不以 0 开头的数字，我们还可以允许开头有一个负号：<code>^(0|-?[1-9][0-9]*)$</code></li><li>19、这表示一个 0 或者一个可能为负的开头不为 0 的数字，让用户以 0 开头好了.把负号的也去掉，因为钱总不能是负的吧。下面我们要加的是说明可能的小数部分：<code>^[0-9]+(.[0-9]+)?$</code></li><li>20、必须说明的是，小数点后面至少应该有 1 位数，所以”10.”是不通过的，但是 “10” 和 “10.2” 是通过的：<code>^[0-9]+(.[0-9]&#123;2&#125;)?$</code></li><li>21、这样我们规定小数点后面必须有两位,如果你认为太苛刻了，可以这样：<code>^[0-9]+(.[0-9]&#123;1,2&#125;)?$</code></li><li>22、这样就允许用户只写一位小数，下面我们该考虑数字中的逗号了，我们可以这样：<code>^[0-9]&#123;1,3&#125;(,[0-9]&#123;3&#125;)*(.[0-9]&#123;1,2&#125;)?$</code></li><li>23、1 到 3 个数字，后面跟着任意个 逗号+3 个数字，逗号成为可选，而不是必须：<code>^([0-9]+|[0-9]&#123;1,3&#125;(,[0-9]&#123;3&#125;)*)(.[0-9]&#123;1,2&#125;)?$</code></li><li>24、备注：这就是最终结果了，别忘了 “+”可以用”*”替代如果你觉得空字符串也可以接受的话（奇怪，为什么?）最后，别忘了在用函数时去掉去掉那个反斜杠，一般的错误都在这里</li><li>25、xml 文件：<code>^([a-zA-Z]+-?)+[a-zA-Z0-9]+\\.[x|X][m|M][l|L]$</code></li><li>26、中文字符的正则表达式：<code>[\u4e00-\u9fa5]</code></li><li>27、双字节字符：<code>[^\x00-\xff]</code>（包括汉字在内，可以用来计算字符串的长度（一个双字节字符长度计 2，ASCII 字符计 1 ））</li><li>28、空白行的正则表达式：<code>\n\s*\r</code> （可以用来删除空白行）</li><li>29、HTML 标记的正则表达式：<code>&lt;(\S*?)[^&gt;]*&gt;.*?|&lt;.*? /&gt;（首尾空白字符的正则表达式：^\s*|\s*$</code>或<code>(^\s*)|(\s*$)</code>（可以用来删除行首行尾的空白字符（包括空格、制表符、换页符等等），非常有用的表达式）</li><li>30、腾讯 QQ 号：<code>[1-9][0-9]&#123;4,&#125;</code>（腾讯 QQ 号从 10000 开始）</li><li>31、中国邮政编码：<code>[1-9]\d&#123;5&#125;(?!\d)</code> （中国邮政编码为 6 位数字）</li><li>32、IPv4 地址：<code>((2(5[0-5]|[0-4]\d))|[0-1]?\d&#123;1,2&#125;)(\.((2(5[0-5]|[0-4]\d))|[0-1]?\d&#123;1,2&#125;))&#123;3&#125;</code></li></ul></blockquote>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JS核心知识点（十六）</title>
      <link href="/2023/12/08/JS%E6%A0%B8%E5%BF%83%E7%9F%A5%E8%AF%86%E7%82%B9%EF%BC%88%E5%8D%81%E5%85%AD%EF%BC%89/"/>
      <url>/2023/12/08/JS%E6%A0%B8%E5%BF%83%E7%9F%A5%E8%AF%86%E7%82%B9%EF%BC%88%E5%8D%81%E5%85%AD%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<span id="more"></span><h3 id="一、Math-对象"><a href="#一、Math-对象" class="headerlink" title="一、Math 对象"></a>一、Math 对象</h3><blockquote><ul><li><code>Math</code> 是一个<strong>内置对象</strong>，它拥有一些数学常数属性和数学函数方法。</li><li>与其他全局对象不同的是，<code>Math</code> 不是一个构造器。即<strong>不能</strong>使用 <code>new</code> 关键字</li><li><code>Math</code> 的所有属性与方法都是<strong>静态</strong>的<blockquote><p>以下是 Math 对象上的一些常用的方法和属性</p></blockquote></li></ul></blockquote><table><thead><tr><th>属性</th><th>说明</th></tr></thead><tbody><tr><td>Math.PI</td><td>Math.PI 表示圆周率π，即一个圆的周长与直径的比例，约为 3.14159</td></tr></tbody></table><table><thead><tr><th>方法</th><th>说明</th></tr></thead><tbody><tr><td>Math.pow(x,y)</td><td>返回x的y次幂</td></tr><tr><td>Math.sqrt(x)</td><td>返回x的平方根</td></tr><tr><td>Math.ceil(x)</td><td>向上取整，返回大于等于x的最小整数</td></tr><tr><td>Math.floor(x)</td><td>向下取整，返回小于等于x的最大整数</td></tr><tr><td>Math.round(x)</td><td>返回x经过 4 舍 5 入后得到的最接近的整数</td></tr><tr><td>Math.max(a,b,c,[..])</td><td>返回给定数值中的最大数</td></tr><tr><td>Math.min(a,b,c,[..])</td><td>返回给定数值中的最小数</td></tr><tr><td>Math.abs()</td><td>返回一个数字的绝对值</td></tr><tr><td>Math.random()</td><td>生成一个（0-1）之间的随机数</td></tr><tr><td>Math.atan2</td><td>返回从原点（0,0） 到 （x,y） 点的线段与 x 轴正方向之间的平面角度（弧度值）</td></tr></tbody></table><ol><li>Math.PI 属性<blockquote><ul><li><code>Math.PI</code>表示圆周率<code>π</code>，即一个圆的周长与直径的比例，约为<code>3.14159</code></li></ul></blockquote></li></ol><pre><code>console.log(Math.PI); // 3.141592653589793</code></pre><ol start="2"><li>Math.pow(x,y)<blockquote><ul><li><code>Math.pow(x,y)</code> 返回 x 的 y 次幂</li></ul></blockquote></li></ol><pre><code>console.log(Math.pow(2, 3)); // 8  2的3次幂为8</code></pre><ol start="3"><li>Math.sqrt(x)<blockquote><ul><li>返回x的平方根</li></ul></blockquote></li></ol><pre><code>console.log(Math.sqrt(4)); // 2console.log(Math.sqrt(9)); // 3</code></pre><ol start="4"><li>Math.ceil<blockquote><ul><li>向上取整，返回大于等于 x 的最小整数</li></ul></blockquote></li></ol><pre><code>console.log(Math.ceil(2.2)); // 3console.log(Math.ceil(2.0001)); // 3console.log(Math.ceil(-2.1)); // -2console.log(Math.ceil(0.909)); // 1</code></pre><ol start="5"><li>Math.floor<blockquote><ul><li>向下取整，返回小于等于 x 的最大整数</li></ul></blockquote></li></ol><pre><code>console.log(Math.floor(2.2)); // 2console.log(Math.floor(2.0001)); // 2console.log(Math.floor(-2.1)); // -3console.log(Math.floor(0.909)); // 0</code></pre><ol start="6"><li>Math.round<blockquote><ul><li>返回<code>x</code>经过<strong>四舍五入</strong>后得到的最接近的整数，只需要看 <code>x</code> 的小数部分与 <code>0.5</code> 的关系<blockquote><p>特别注意：当x是负数是，如果小数部分是 0.5，则返回值为x的整数部分</p></blockquote></li></ul></blockquote></li></ol><pre><code>console.log(Math.round(10.49)); // 10console.log(Math.round(10.5)); // 11console.log(Math.round(-10.49)); // -10// 特殊情况，记下console.log(Math.round(-10.5)); // -10console.log(Math.round(-10.51)); // -11</code></pre><ol start="7"><li>Math.max<blockquote><ul><li>返回给定数值中的最大数，如果任一参数不能转换为数值，则返回<code>NaN</code></li><li>如果没有提供参数，返回 <code>-Infinity</code></li></ul></blockquote></li></ol><pre><code>console.log(Math.max(1, 2, 3, 7)); // 7console.log(Math.max()); // -Infinityconsole.log(Math.max(1, 2, &quot;a&quot;)); // NaN</code></pre><blockquote><p><strong>求数组中的最大值</strong></p></blockquote><pre><code>var arr = [1, 20, 5, 6, 3, 9, 10];var maxValue = Math.max.apply(null, arr);console.log(maxValue);</code></pre><blockquote><blockquote><p><code>Math.min</code>同样可以</p></blockquote></blockquote><ol start="8"><li>Math.min<blockquote><ul><li>返回给定数值中的最小数，如果任一参数不能转换为数值，则返回<code>NaN</code></li><li>如果没有提供参数，返回<code>Infinity</code></li></ul></blockquote></li></ol><pre><code>console.log(Math.min(1, 2, 3, 7)); // 1console.log(Math.min()); // -Infinityconsole.log(Math.min(1, 2, &quot;a&quot;)); // NaN</code></pre><ul><li><strong><code>Math.max</code>与<code>Math.min</code>常用于裁剪值</strong><blockquote><p>比如:</p><ul><li>元素的 <code>left</code> 值只能在<code>0 ~ 500</code>之间，则我们可以利用<code>Math.max</code> 和 <code>Math.min</code>来对值做裁剪</li></ul></blockquote></li></ul><pre><code>var left = 300;left = left &lt; 0 ? 0 : left;left = left &gt; 500 ? 500 : left;console.log(left);&gt;// 利用 Math.max和Math.min来实现left = Math.max(left, 0);left = Math.min(500, left);console.log(left);</code></pre><ol start="9"><li>Math.abs<blockquote><ul><li>返回一个数字的<strong>绝对值</strong>，如果不能转换的，则会转换为 <code>NaN</code>，能转的都会转换成对应的数字</li></ul></blockquote></li></ol><pre><code>console.log(Math.abs(-1)); // 1console.log(Math.abs(-1.2)); // 1.2console.log(Math.abs(null)); // 0console.log(Math.abs(true)); // 1console.log(Math.abs(false)); // 0console.log(Math.abs(undefined)); // NaNconsole.log(Math.abs([-3])); // 3console.log(Math.abs([2, -3])); // NaNconsole.log(Math.abs(&#123;&#125;)); // NaN</code></pre><ol start="10"><li>Math.random<blockquote><ul><li>返回一个 <code>0 ~ 1</code> 之间的随机数，不包括 0 和 1</li><li>返回指定范围<code>[a,b]</code>之间的随机整数公式，包括 a 和 b：</li></ul></blockquote></li></ol><pre><code>Math.random() * (b - a + 1) + a;</code></pre><pre><code>// 随机生成 0-6之间的随机整数,包括0和6var n = Math.floor(Math.random() * 7);&gt;// 随机生成 [2,6]之间的随机整数var n = Math.floor(Math.random() * (6 - 2 + 1) + 2);&gt;// 随机生成[-5,5]之间的整数var n = Math.floor(Math.random() * (5 - -5 + 1) - 5);</code></pre><ol start="11"><li>Math.atan2<blockquote><ul><li>返回从原点<code>(0,0)</code>到<code>(x,y)</code>点的线段与 x 轴正方向之间的平面角度<strong>（弧度值）</strong></li><li>假设圆的中心点为原点坐标<code>（0,0）</code>，即从原点到坐标<code>（x,y）</code>的线段与 x 轴正方向之间的角 θ 是一个负角（逆时针方向）</li><li>旋转角度的正负，是由 <code>y</code> 值决定的，<code>y &lt; 0</code>得到负角，<code>y &gt; 0</code>得到正角<blockquote><p>注意：这里的y轴与数学上的不一样；正值向下，负值向上；</p></blockquote></li></ul></blockquote></li></ol><img src="弧度值.png"><pre><code>Math.atan2(y, x); // 第一个参数是y坐标，第二个参数是x坐标</code></pre><blockquote><p><strong>因为</strong></p><ul><li><code>Math.atan2(y,x)</code>得到的是对应的弧度值，所以我们还需要将弧度值转换为对应的<strong>角度值</strong></li><li>弧度值转换成对应角度值的转换公式<ul><li>角度 &#x3D; 弧度 * (180&#x2F;Math.PI)</li><li>角度 &#x3D; 弧度 &#x2F; (Math.PI&#x2F;180)</li></ul></li></ul></blockquote><pre><code> rad1 = Math.atan2(-1, 1); deg1 = Math.atan2(-1, 1) * (180 / Math.PI); console.log(rad1, deg1); //-0.7853981633974483 -45&gt; rad2 = Math.atan2(-1, -1); deg2 = Math.atan2(-1, -1) * (180 / Math.PI); console.log(rad2, deg2); //-2.356194490192345 -135 &gt; rad3 = Math.atan2(1, -1); deg3 = Math.atan2(1, -1) * (180 / Math.PI); console.log(rad3, deg3); //2.356194490192345 135 &gt; rad4 = Math.atan2(1, 1); deg4 = Math.atan2(1, 1) * (180 / Math.PI); console.log(rad4, deg4); //0.7853981633974483 45</code></pre><ul><li>扩展知识：弧度与角度的关系<blockquote><ul><li>角的度量单位通常有两种：一种是角度制，另一种是弧度制</li><li>弧度制：我们把<strong>长度等于半径长</strong>的弧所对的圆心角叫<strong>1 弧度的角</strong>。 弧度常用<code>rad</code>表示</li><li>假设下图中圆的半径为 r ，弧 AB 的长为 L，如果L &#x3D; r， 则<code>∠AOB = L/r = 1 弧度</code><img src="弧度与角度的关系.png"></li></ul></blockquote></li></ul><blockquote><p><strong>1 弧度 &#x3D; ?角度呢</strong></p><ul><li><p>1弧度 &#x3D; 180deg&#x2F;π 约为 57.2958279deg<br><strong>推导过程</strong></p></li><li><p><code>周长 = 2πr</code> ， <code>周角 = 360deg</code></p></li><li><p><code>1弧度/360deg</code> &#x3D; <code>L/2πr</code> ；</p></li><li><p>因为L&#x3D;r–&gt;&gt; <code>1弧度/360deg</code> &#x3D; <code>r/2πr</code> </p></li><li><p>—&gt;&gt; <code>1弧度 = 180deg/π</code></p></li><li><p>通过 <code>1弧度 = 180deg/π</code> 得到</p></li><li><p><code>角度 = 弧度 * (180deg/π)</code></p></li><li><p><code>角度 = 弧度 / (π/180)</code></p></li><li><p><code>π = 180deg</code> ，<code>2π = 360deg</code> （弧度单位可以省略）</p></li></ul></blockquote><ul><li>案例：元素跟随鼠标旋转<blockquote><ul><li>当鼠标旋转时，元素也会跟着一起旋转。<img src="元素跟随鼠标旋转.png"></li></ul></blockquote></li></ul><p><strong>实现原理</strong></p><blockquote><ul><li>首先，我们知道，鼠标的坐标是距离浏览器左侧和上面的距离，也就是说，原点在浏览器的左上角，鼠标只能在第四象限移动</li><li>而我们要旋转元素，必须在每个象限都能移动，所以，我们需要把鼠标的坐标轴原点移动到<strong>元素的中心点</strong><ul><li>我们需要获取到元素中心点与浏览器左边和上边的距离</li><li>然后获取到鼠标与浏览左边和上边的距离</li><li>最后用鼠标对应位置减去元素中心点与浏览器对应位置，得到的 <code>x,y</code> 这样元素的中心点就相当于是<code>(0,0)</code>原点坐标，<code>（x,y）</code>就是<code>Math.atan2(y,x)</code>方法对应的 <code>x,y</code></li></ul></li></ul></blockquote><pre><code>// box中心点与浏览器左边和上边距离var centerX = box.offsetLeft + box.offsetWidth / 2;var centerY = box.offsetTop + box.offsetHeight / 2;&gt;document.onmousemove = function (e) &#123;  var clientY = e.clientY;  var clientX = e.clientX;&#125;;&gt;// 以元素的中心点为（0，0）坐标，来计算弧度值，最后转换为对应角度值x = clientX - centerX;y = clientY - centerY;&gt;</code></pre><blockquote><ul><li>用(x,y)计算弧度值和角度控制元素的旋转角度：<code>transform:rotate(deg)</code></li></ul></blockquote><pre><code>var rad = Math.atan2(y, x); // 弧度值var deg = rad * (180 / Math.PI); // 将弧度值转换为对应角度制</code></pre><blockquote><p><strong>完整源码</strong></p></blockquote><pre><code>&gt;&lt;style&gt;  .box &#123;    width: 200px;    height: 200px;    background-image: linear-gradient(to right, khaki, skyblue);    margin: 200px;    /* transform-origin: top left; */ /*改变旋转中心点*/  &#125;&gt;&lt;/style&gt;&gt;&gt;&lt;div class=&quot;box&quot;&gt;&lt;/div&gt;&gt;&lt;script&gt;  var box = document.querySelector(&quot;.box&quot;);  // box中心点与浏览器左边和上边距离  var centerX = box.offsetLeft + box.offsetWidth / 2;  var centerY = box.offsetTop + box.offsetHeight / 2;&gt;  // onmousemove事件  document.onmousemove = function (e) &#123;    // 鼠标与浏览器左边和右边距离    var clientY = e.clientY;    var clientX = e.clientX;&gt;    // 得到鼠标与元素中心点的x和y坐标    x = clientX - centerX;    y = clientY - centerY;&gt;    // 以元素的中心点为（0，0）坐标，来计算弧度值，最后转换为对应角度值    var rad = Math.atan2(y, x);    var deg = rad * (180 / Math.PI);&gt;    // 控制元素的旋转角度    box.style.transform = &quot;rotate(&quot; + deg + &quot;deg)&quot;;  &#125;;&gt;&lt;/script&gt;</code></pre><h3 id="二、Date-日期对象"><a href="#二、Date-日期对象" class="headerlink" title="二、Date 日期对象"></a>二、Date 日期对象</h3><blockquote><ul><li>Date 日期对象主要是用来处理日期</li></ul></blockquote><blockquote><ul><li>以下是与星期相关的英文单词，可以记下来<table><thead><tr><th>星期</th><th>英文</th><th>缩写</th></tr></thead><tbody><tr><td>星期一</td><td>Monday</td><td>Mon</td></tr><tr><td>星期二</td><td>Tuesday</td><td>Tue</td></tr><tr><td>星期三</td><td>Wednesday</td><td>Wed</td></tr><tr><td>星期四</td><td>Thursday</td><td>Thur</td></tr><tr><td>星期五</td><td>Friday</td><td>Fri</td></tr><tr><td>星期六</td><td>Saturday</td><td>Sat</td></tr><tr><td>星期七</td><td>Sunday</td><td>Sun</td></tr></tbody></table></li></ul></blockquote><blockquote><ul><li>以下是与月份相关的英文单词<table><thead><tr><th>月份</th><th>英文</th><th>简写</th></tr></thead><tbody><tr><td>一月</td><td>January</td><td>Jan</td></tr><tr><td>二月</td><td>February</td><td>Feb</td></tr><tr><td>三月</td><td>March</td><td>Mar</td></tr><tr><td>四月</td><td>April</td><td>Apr</td></tr><tr><td>五月</td><td>May</td><td>May</td></tr><tr><td>六月</td><td>June</td><td>Jun</td></tr><tr><td>七月</td><td>July</td><td>Jul</td></tr><tr><td>八月</td><td>August</td><td>Aug</td></tr><tr><td>九月</td><td>September</td><td>Sep</td></tr><tr><td>十月</td><td>October</td><td>Oct</td></tr><tr><td>十一月</td><td>November</td><td>Nov</td></tr><tr><td>十二月</td><td>December</td><td>Dec</td></tr></tbody></table></li></ul></blockquote><h4 id="new-Date-创建日期对象"><a href="#new-Date-创建日期对象" class="headerlink" title="new Date() 创建日期对象"></a>new Date() 创建日期对象</h4><blockquote><p>-<code>new Date()</code>可以用来创建一个日期对象</p><ul><li>它有四种使用方式：</li></ul></blockquote><ol><li><p><code>new Date()</code></p><blockquote><ul><li>没有提供任何参数，则返回结果为当前的日期和时间</li><li><code>console.log(new Date()); //Fri Aug 25 2023 17:11:59 GMT+0800 (中国标准时间)</code></li></ul></blockquote></li><li><p><code>new Date(value)</code></p><blockquote><ul><li><code>value</code> 是一个时间戳，他是一个整数值，表示从 <code>1970 年 1 月 1 日 00:00:00</code>UTC（the Unix epoch）开始算起的一个毫秒数。</li><li><code>console.log(new Date(5000));//Thu Jan 01 1970 08:00:05 GMT+0800 (中国标准时间)</code></li></ul></blockquote></li><li><p><code>new Date(dateString);</code></p><blockquote><ul><li><code>dateString</code>表示一个日期字符串，其中<code>2022-07-02</code>这种格式的日期(<code>-</code>和两位数同时存在)会被处理成 <code>UTC</code>，而不是本地时间(与中国相差八小时)</li><li>该方法会把<code>dateString</code>转化为：<code>星期 月 日 年 时间</code>的格式</li></ul></blockquote></li></ol><pre><code> console.log(new Date(&quot;2022-7-1&quot;)); //Fri Jul 01 2022 00:00:00 GMT+0800 console.log(new Date(&quot;2022/7/1&quot;)); //Fri Jul 01 2022 00:00:00 GMT+0800 console.log(new Date(&quot;2022-07-1&quot;)); //Fri Jul 01 2022 00:00:00 GMT+0800 console.log(new Date(&quot;2022-07-01&quot;)); //会被处理成UTC时间 Fri Jul 01 2022 08:00:00 GMT+0800</code></pre><ol start="4"><li><code>new Date((year, monthIndex [, day [, hours [, minutes [, seconds [, milliseconds]]]]]);)</code><blockquote><ul><li>分别提供日期和时间的每个成员，不过<strong>至少要</strong>提供年份与月份</li><li>如果<strong>没有提供</strong>的参数，<strong>日期</strong>默认值为<code>1</code>，<strong>时，分，秒</strong>默认值为<code>0</code><blockquote><p>注意事项：</p></blockquote></li><li><code>monthIndex</code>表示月份的整数值，从 0（1 月）到 11（12 月）</li><li><code>year</code>年份的整数值，<code>0</code>到<code>99</code>会被映射至 <code>1900</code> 年至 <code>1999</code>年，其它值代表实际年份</li></ul></blockquote></li></ol><pre><code> console.log(new Date(2023, 8, 25, 17, 23)); //Mon Sep 25 2023 17:23:00&gt; console.log(new Date(&quot;2023-08-25&quot;)); //Fri Aug 25 2023 08:00:00 console.log(new Date(&quot;2023/8/25&quot;)); //Fri Aug 25 2023 00:00:00&gt; console.log(new Date(2023, 15, 25)); //Thu Apr 25 2024 00:00:00 console.log(new Date(2023, 8, 40)); //Tue Oct 10 2023 00:00:00 console.log(new Date(2023, 8, 25, 30)); //Tue Sep 26 2023 06:00:00</code></pre><blockquote><blockquote><p>注意事项：</p></blockquote><ul><li>如果传入的是日期格式的字符串,它会自动转换格式；根据字符串的格式转换成UTC或者当地时间</li><li>当传入多个参数时，如果<strong>数值大于合理范围</strong>时，相邻的数值会被调整<ul><li>月超出范围<code>2023, 15, 25</code>：<code>15-12=3</code>,因为月份是<code>0-11</code>，所以是四月</li><li>日超出范围<code>2023, 8, 40</code>：会根据月份的长度调整，注意：月份的位置写的是<code>8</code>，那代表是<code>9</code>月，所以<code>40-30=10</code>，即10月10号</li><li>时超出范围<code>-24</code>，分秒超出范围<code>-60</code></li></ul></li></ul></blockquote><ul><li>实践应用<blockquote><ul><li>获取上一个月共有多少天，比如获取 2022 年 9 月的上一个月有多少天</li></ul></blockquote></li></ul><pre><code> // 获取2022年9月的上一个月有多少天 var date = new Date(2022, 8, 0); // 2022年9月的第0天就是8月的最后一天 console.log(date); // Wed Aug 31 2022 00:00:00 GMT+0800 var prevMonthDayCount = date.getDate(); // 获取当前日期的天 console.log(prevMonthDayCount); // 31</code></pre><blockquote><ul><li>获取当月一共有多少天，如比获取 2022 年 9 月一共有多少天</li></ul></blockquote><pre><code>// 获取2022年9月一共有多少天var date = new Date(2022, 9, 0); //2022年10月的第0天就是 2022年9月的最后一天console.log(date); // Fri Sep 30 2022 00:00:00 GMT+0800 (中国标准时间)var prevMonthDayCount = date.getDate(); // 获取当前日期的天console.log(prevMonthDayCount); // 30</code></pre><ol start="5"><li>扩展<blockquote><p><strong>UTC：</strong></p><ul><li>也就是我们所说的格林威治时间，指的是<code>time</code>中的<strong>世界时间标准</strong></li><li>JavaScript的时间由世界标准时间（UTC）<code>1970 年 1 月 1 日</code>开始，用毫秒计时，一天由<code>86,400,000</code>毫秒组成<br><strong>本地（当地）时间</strong></li><li>是指执行 JavaScript 的客户端电脑所设置的时间</li></ul></blockquote></li></ol><h4 id="日期格式化方法"><a href="#日期格式化方法" class="headerlink" title="日期格式化方法"></a>日期格式化方法</h4><blockquote><p>以下方法只需要了解即可</p><table><thead><tr><th>方法</th><th>说明</th></tr></thead><tbody><tr><td>toString()</td><td>返回一个字符串，以<strong>本地的时间</strong>表示当前的时间</td></tr><tr><td>toLocaleString()</td><td>根据当地语言规定返回代表着<strong>时间</strong>的字符串</td></tr><tr><td>toLocaleDateString()</td><td>根据当地语言规定返回代表着<strong>日期</strong>的字符串</td></tr><tr><td>toLocaleTimeString()</td><td>根据当地语言规定返回代表着时<strong>分秒</strong>的字符串</td></tr></tbody></table></blockquote><pre><code> var date = new Date(); console.log(date); // Thu Aug 08 2022 22:21:58 GMT+0800 (中国标准时间) console.log(date.toString()); // Thu Aug 08 2022 22:21:58 GMT+0800 (中国标准时间) console.log(date.toLocaleString()); // 2022/8/8 22:21:58 console.log(date.toLocaleDateString()); // 2022/8/8 console.log(date.toLocaleTimeString()); // 22:21:58</code></pre><h4 id="日期对象常见方法"><a href="#日期对象常见方法" class="headerlink" title="日期对象常见方法"></a>日期对象常见方法</h4><blockquote><p>如果我们想获取日期的指定部分，如：年，月，日，星期，时，分，秒等中的某个部分,则可以使用下面提供的方法</p></blockquote><table><thead><tr><th>方法</th><th>说明</th></tr></thead><tbody><tr><td>getFullYear()</td><td>根据<strong>本地时间</strong>，返回具体时间中的** 年份**</td></tr><tr><td>getMonth()</td><td>根据本地时间，返回具体时间中的 月份 <code>0-11</code> 表示 <strong>1-12 月</strong></td></tr><tr><td>getDate()</td><td>根据本地时间，返回具体时间中的<strong>日（天）</strong></td></tr><tr><td>getDay()根据本地时间，返回具体时间中的<strong>星期</strong>，<code>0-6</code> 表示星期天，一，二，三，… 六</td><td></td></tr><tr><td>getHours()</td><td>根据本地时间，返回具体时间中的 <strong>时</strong></td></tr><tr><td>getMinutes()</td><td>根据本地时间，返回具体时间中的 <strong>分钟数</strong></td></tr><tr><td>getSeconds()</td><td>根据本地时间，返回具体时间中的 <strong>秒数</strong></td></tr><tr><td>getMilliseconds()</td><td>根据本地时间，返回具体时间中的 <strong>毫秒数</strong></td></tr></tbody></table><blockquote><ul><li>以 “2023 年 09 月 08 日 12 时 04 分 05 秒 星期四” 格式输出对应的日期</li></ul></blockquote><pre><code> var d = new Date(); var year = d.getFullYear(); var month = d.getMonth() + 1; var date = d.getDate(); var day = d.getDay(); var hours = d.getHours(); var minutes = d.getMinutes(); var seconds = d.getSeconds();&gt; // 对日期不足两位的补0操作 month = padZero(month); date = padZero(date); hours = padZero(hours); minutes = padZero(minutes); seconds = padZero(seconds);&gt; var week = [   &quot;星期天&quot;,   &quot;星期一&quot;,   &quot;星期二&quot;,   &quot;星期三&quot;,   &quot;星期四&quot;,   &quot;星期五&quot;,   &quot;星期六&quot;, ];&gt; console.log(   year +     &quot;年&quot; +     month +     &quot;月&quot; +     date +     &quot;天 &quot; +     hours +     &quot;时&quot; +     minutes +     &quot;分&quot; +     seconds +     &quot;秒 &quot; +     week[day] ); // 输出结果格式： 2023年09月08天 23时12分16秒 星期四 &gt; // 补0 function padZero(str) &#123;   str = str + &quot;&quot;;   return str.padStart(2, &quot;0&quot;); &#125;</code></pre><h4 id="时间戳"><a href="#时间戳" class="headerlink" title="时间戳"></a>时间戳</h4><blockquote><ul><li>时间戳：表示 1970 年 1 月 1 日零点整<strong>距离某时刻</strong>的毫秒数</li><li><code>getTime</code>方法：可以把对应的日期时间转换为对应的时间戳</li></ul></blockquote><pre><code>//得到此时距1970 年 1 月 1 日零点整的毫秒数 var d1 = new Date(); console.log(d1.getTime()); //1692958123935//得到2023/8/26 距1970 年 1 月 1 日零点整的毫秒数 var d2 = new Date(&quot;2023 / 8 / 26&quot;); console.log(d2.getTime()); //1692979200000</code></pre><ol><li>应用：利用 getTime 方法，可以测试代码的执行时间</li></ol><pre><code>var start = new Date();for (var i = 0; i &lt; 1000; i++) &#123;  console.log(i);&#125;var end = new Date();// 代码执行时间，为两者时间之差（毫秒数）var time = end.getTime() - start.getTime();console.log(&quot;代码执行时间&quot; + time + &quot;毫秒&quot;); // 代码执行时间20毫秒</code></pre><ol start="2"><li>将一个日期转换为对应的时间戳 ，还有以下 4 种方法<table><thead><tr><th>时间戳方法</th><th>说明</th></tr></thead><tbody><tr><td>日期对象.getTime()</td><td>可以把对应的日期时间转换为对应的时间戳</td></tr><tr><td>日期对象.valueOf方法</td><td>返回 Date 对象的原始值，其功能和 getTime</td></tr><tr><td>+日期对象</td><td>这种是一种技巧，利用+号的特性，底层调用的是 valueOf 方法</td></tr><tr><td>Date.parse(“”)方法</td><td>静态方法，返回传递的日期的时间戳</td></tr><tr><td>Date.now() 方法</td><td>静态方法 返回<strong>当前的日期</strong>的时间戳</td></tr></tbody></table></li></ol><pre><code>var d = new Date(2022, 9, 9);console.log(d.valueOf()); // 1665244800000console.log(d.getTime()); // 1665244800000console.log(+d); // 1665244800000&gt;console.log(Date.now()); // 1665244823500&gt;console.log(Date.parse(&quot;2022-9-1&quot;)); // 本地时间  1661961600000console.log(Date.parse(&quot;2022/9/1&quot;)); // 本地时间  1661961600000console.log(Date.parse(&quot;2022-09-01&quot;)); // UTC 1661990400000</code></pre><blockquote><ul><li><code>Date.parse()</code>方法传入日期必须用引号包裹，并且根据不同的日期格式会返回UTC或者本地时间</li><li>其他方法，如果在<code>new Date()</code>里传入字符串格式的日期，根据不同的日期格式也会返回UTC或者本地时间</li></ul></blockquote><h4 id="案例：活动倒计时"><a href="#案例：活动倒计时" class="headerlink" title="案例：活动倒计时"></a>案例：活动倒计时</h4><blockquote><p>涉及知识点</p><ul><li>定时器</li><li>Date 对象、getTime() 方法</li><li>倒计时原理： 时间戳如何转换为对应的天数，小时，分钟，秒数</li></ul></blockquote><ol><li>CSS布局</li></ol><pre><code>&gt;&lt;style&gt;  .countDown &#123;    position: relative;    width: 190px;    height: 260px;    background-image: url(../src/miaosha.png);    margin: 100px;  &#125;  .countDown .title &#123;    font-size: 30px;    text-align: center;    padding-top: 50px;    color: #fff;    font-weight: bold;  &#125;  .countDown .main &#123;    position: absolute;    bottom: 50px;    width: 100%;    height: 30px;    text-align: center;    font-size: 0;  &#125;  .countDown .main span &#123;    position: relative;    display: inline-block;    width: 30px;    height: 30px;    margin: 0 8px;    font-size: 20px;    color: #fff;    background-color: #000;  &#125;  .main span::after &#123;    position: absolute;    top: 0;    right: -10px;    content: &quot;:&quot;;    display: block;  &#125;  .main span.second::after &#123;    content: &quot;&quot;;  &#125;&gt;&lt;/style&gt;&gt;&gt;&lt;div class=&quot;countDown&quot; id=&quot;J-countDown&quot;&gt;&gt;  &lt;!-- &lt;div class=&quot;title&quot;&gt;京东秒杀&lt;/div&gt;&gt;  &lt;div class=&quot;main&quot;&gt;&gt;    &lt;span class=&quot;hour&quot;&gt;00&lt;/span&gt;&gt;    &lt;span class=&quot;minute&quot;&gt;00&lt;/span&gt;&gt;    &lt;span class=&quot;second&quot;&gt;00&lt;/span&gt;&gt;  &lt;/div&gt; --&gt;&gt;&lt;/div&gt;</code></pre><ol start="2"><li><p>JS实现思路</p><blockquote><ul><li>倒计时需要三个时间：当前时间，活动开始时间，活动结束时间</li><li>活动没有开始前，活动版块不会出现在页面中；活动结束后，活动版块要在页面中删除</li><li><code>当前时间 &gt;= 活动开始时间</code>，表示当前活动正在进行，开始倒计时功能</li></ul><p><strong>倒计时实现原理</strong></p><ul><li><p>利用<strong>活动结束时间戳 - 当前时间戳</strong> ，得到的剩余时间（毫秒）</p></li><li><p>把<code>剩余时间（毫秒）/ 1000</code>得到对应的秒数，然后将秒数转换为对应的<strong>天、时、分、秒</strong></p></li><li><p>然后利用定时器，每过1秒钟就更新下时间</p></li><li><p>秒数转换成天、时、分、秒公式</p></li><li><p>我们知道 1天 &#x3D; 24小时，1小时 &#x3D; 60分，1分 &#x3D; 60秒，如果当前为 n 天，则 <code>总秒数 = n * 60 * 60 * 24</code></p></li><li><p>天数：<code>day = parseInt(总秒数 / 24 / 60 / 60)</code></p></li><li><p>小时：<code>hour = parseInt(总秒数 / 60 / 60 % 24 )</code></p></li><li><p><strong>如果不考虑天数</strong>，也就是所有天数的时间也按小时来算，<code>hour=parseInt(总秒数 / 60 / 60 )</code></p></li><li><p>分钟：<code>minutes=parseInt(总秒数 / 60 % 60)</code></p></li><li><p>秒数：<code>secondes=parseInt(总秒数 % 60)</code></p></li></ul></blockquote></li><li><p>实现步骤</p><blockquote><ul><li>第一步：创建DOM元素，添加到页面</li><li>第二步：创建 countDown 函数<ul><li>这个函数有两个参数，分别代表<strong>开始时间</strong>和<strong>结束时间</strong>，只要调用这个函数，传入对应实参，就能实现<strong>倒计时</strong>功能</li></ul></li><li>第三步：完善 countDown 函数功能<ul><li>检测是否传了两个参数</li><li>传的类型是否是时间对象</li><li>是否满足 <code>endDate</code> 大于 <code>startDate</code></li><li>如果不满足以上条件，则直接抛出对应的错误</li><li>同时开始定时器，每隔<code>1</code>秒更新下时间，实现倒计时功能,每隔一秒就检查活动是否开始&#x2F;结束。</li></ul></li><li>第四步：判断活动是否结束<ul><li><code>如果当前时间 &gt; 活动结束时间</code>，则表明活动结束，将活动版块从页面移除</li></ul></li><li>第五步：判断活动是否开始<ul><li>如果<code>活动开始时间 &gt; 当前时间</code>，则表示活动开始，在活动版块插入页面中（显示）</li><li>用<code>活动结束时间戳 - 当前时间戳</code>得到的毫秒数，转换成秒。</li><li>最后将秒数，换算成对应<strong>时，分，秒</strong>，更新到页面中</li></ul></li><li>第六步：优化细节<ul><li>如果<strong>时，分</strong>没有变化，则不需要再次更新 <code>DOM</code>，只有不相同时，才需要更新 <code>DOM</code></li><li>创建一个<strong>对象</strong>，用来前面的时，分，然后拿 <strong>对象中的时，分</strong>与<strong>现在的</strong>对比，如果不相同则更新 DOM，同时把自身的值也更新为最新的，否则啥也不做</li><li>用户刚打开页面，活动已经开始了，则需要立马显示倒计时，而不用等到 1 秒后，才开始显示元素，然后显示对应时间</li><li>所以把定时器需要执行的代码封装到函数<code>upDate</code> 中，然后在定时器之前，先调用下<code>upDate</code>函数</li></ul></li></ul></blockquote></li><li><p>完整 js代码</p></li></ol><pre><code>&gt;&lt;script&gt; var count = document.getElementById(&quot;J-countDown&quot;); //创建DOM元素，并插入到页面中 var frag = document.createDocumentFragment(); var title = document.createElement(&quot;div&quot;); title.innerText = &quot;京东秒杀&quot;; var main = document.createElement(&quot;div&quot;); var span1 = document.createElement(&quot;span&quot;); var span2 = document.createElement(&quot;span&quot;); var span3 = document.createElement(&quot;span&quot;); title.classList.add(&quot;title&quot;); main.classList.add(&quot;main&quot;); span1.classList.add(&quot;hour&quot;); span2.classList.add(&quot;minute&quot;); span3.classList.add(&quot;second&quot;); main.appendChild(span1); main.appendChild(span2); main.appendChild(span3); frag.appendChild(title); frag.appendChild(main); count.appendChild(frag);&gt;/**&gt; * countDown 倒计时函数&gt; * @param startDate 开始时间，日期对象&gt; * @param endDate 结束时间，日期对象&gt; */ function countDown(startDate, endDate) &#123;   //判断是否同时传了两个参数   if (startDate === undefined || endDate === undefined)     throw new Error(&quot;必须同时传入两个日期，作为活动的开始时间和结束时间&quot;);   //判断传入的是日期对象   if (!startDate instanceof Date || !endDate instanceof Date)     throw new Error(&quot;必须传入两个正确的日期对象&quot;);   //判断是否结束日期大于起始日期   if (startDate.getTime() &gt;= endDate.getTime())     throw new Error(&quot;结束日期必须大于起始日期&quot;);&gt;   // 用来记录前前面时，分   var time = &#123;     hour: &quot;00&quot;,     minute: &quot;00&quot;,   &#125;;   var timer = setInterval(upDate, 1000);   upDate(); //  进来就调用更新时间的函数   function upDate() &#123;     //判断活动是否结束     var nowDate = new Date();     if (nowDate.getTime() &gt; endDate.getTime()) &#123;       //活动结束，将元素从页面删除       count.parentNode.removeChild(&quot;count&quot;);       clearInterval(timer);     &#125;     //判断活动是否开始     if (nowDate.getTime() &gt;= startDate.getTime()) &#123;       //倒计时       var timeDiff = (endDate.getTime() - nowDate.getTime()) / 1000;       var hour = parseInt(timeDiff / 60 / 60);       var minute = parseInt((timeDiff / 60) % 60);       var second = parseInt(timeDiff % 60);       // 更新DOM元素,对于不足两位的数，前面补0,       if (time.hour != hour) &#123;         span1.innerText = (hour + &quot;&quot;).padStart(2, &quot;0&quot;);         time.hour = hour;       &#125;&gt;       if (time.minute != minute) &#123;         span2.innerText = (minute + &quot;&quot;).padStart(2, &quot;0&quot;);         time.minute = minute;       &#125;       span3.innerText = (second + &quot;&quot;).padStart(2, &quot;0&quot;);     &#125;   &#125; &#125; var startDate = new Date(&quot;2023/8/25&quot;); var endDate = new Date(&quot;2023/8/27&quot;); countDown(startDate, endDate);&gt;&lt;/script&gt;</code></pre><h3 id="案例-手写日历组件"><a href="#案例-手写日历组件" class="headerlink" title="案例-手写日历组件"></a>案例-手写日历组件</h3><ol><li>布局思路<blockquote><ul><li>其中<code>calendar-main</code>中的内容，是重点渲染的内容，后期通过 JS 动态生成</li></ul></blockquote></li></ol><ul><li>HTML布局</li></ul><pre><code>&gt;&lt;div class=&quot;calendar&quot;&gt;&gt;&lt;!-- calendar-menu start --&gt;&gt;&lt;div class=&quot;calendar-menu&quot;&gt;&gt;  &lt;span class=&quot;prev-year&quot;&gt;&amp;lt;&amp;lt;&lt;/span&gt;&gt;  &lt;span class=&quot;prev-month&quot;&gt;&amp;lt;&lt;/span&gt;&gt;  &lt;span class=&quot;current-date&quot;&gt;2022年12月&lt;/span&gt;&gt;  &lt;span class=&quot;next-month&quot;&gt;&amp;gt;&lt;/span&gt;&gt;  &lt;span class=&quot;next-year&quot;&gt;&amp;gt;&amp;gt;&lt;/span&gt;&gt;&lt;/div&gt;&gt;&lt;!--end calendar-menu --&gt;&gt;&lt;!-- calendar-week start --&gt;&gt;&lt;div class=&quot;calendar-week table&quot;&gt;&gt;  &lt;div class=&quot;tr&quot;&gt;&gt;    &lt;div class=&quot;th&quot;&gt;一&lt;/div&gt;&gt;    &lt;div class=&quot;th&quot;&gt;二&lt;/div&gt;&gt;    &lt;div class=&quot;th&quot;&gt;三&lt;/div&gt;&gt;    &lt;div class=&quot;th&quot;&gt;四&lt;/div&gt;&gt;    &lt;div class=&quot;th&quot;&gt;五&lt;/div&gt;&gt;    &lt;div class=&quot;th&quot;&gt;六&lt;/div&gt;&gt;    &lt;div class=&quot;th&quot;&gt;日&lt;/div&gt;&gt;  &lt;/div&gt;&gt;&lt;/div&gt;&gt;&lt;!-- end calendar-week  --&gt;&gt;&lt;!-- calendar-main start --&gt;&gt;&lt;div class=&quot;calendar-main&quot;&gt;&gt;  &lt;div class=&quot;table&quot;&gt;&gt;    &lt;div class=&quot;tr&quot;&gt;&gt;      &lt;div class=&quot;td prev-month&quot;&gt;28&lt;/div&gt;&gt;      &lt;div class=&quot;td prev-month&quot;&gt;29&lt;/div&gt;&gt;      &lt;div class=&quot;td prev-month&quot;&gt;30&lt;/div&gt;&gt;      &lt;div class=&quot;td&quot;&gt;1&lt;/div&gt;&gt;      &lt;div class=&quot;td&quot;&gt;2&lt;/div&gt;&gt;      &lt;div class=&quot;td&quot;&gt;3&lt;/div&gt;&gt;      &lt;div class=&quot;td&quot;&gt;4&lt;/div&gt;&gt;    &lt;/div&gt;&gt;    &lt;div class=&quot;tr&quot;&gt;&gt;      &lt;div class=&quot;td active&quot;&gt;5&lt;/div&gt;&gt;      &lt;div class=&quot;td&quot;&gt;6&lt;/div&gt;&gt;      &lt;div class=&quot;td&quot;&gt;7&lt;/div&gt;&gt;      &lt;div class=&quot;td&quot;&gt;8&lt;/div&gt;&gt;      &lt;div class=&quot;td&quot;&gt;9&lt;/div&gt;&gt;      &lt;div class=&quot;td&quot;&gt;10&lt;/div&gt;&gt;      &lt;div class=&quot;td&quot;&gt;11&lt;/div&gt;&gt;    &lt;/div&gt;&gt;    &lt;div class=&quot;tr&quot;&gt;&gt;      &lt;div class=&quot;td&quot;&gt;12&lt;/div&gt;&gt;      &lt;div class=&quot;td&quot;&gt;13&lt;/div&gt;&gt;      &lt;div class=&quot;td&quot;&gt;14&lt;/div&gt;&gt;      &lt;div class=&quot;td&quot;&gt;15&lt;/div&gt;&gt;      &lt;div class=&quot;td&quot;&gt;16&lt;/div&gt;&gt;      &lt;div class=&quot;td&quot;&gt;17&lt;/div&gt;&gt;      &lt;div class=&quot;td&quot;&gt;18&lt;/div&gt;&gt;    &lt;/div&gt;&gt;    &lt;div class=&quot;tr&quot;&gt;&gt;      &lt;div class=&quot;td&quot;&gt;19&lt;/div&gt;&gt;      &lt;div class=&quot;td&quot;&gt;20&lt;/div&gt;&gt;      &lt;div class=&quot;td&quot;&gt;21&lt;/div&gt;&gt;      &lt;div class=&quot;td&quot;&gt;22&lt;/div&gt;&gt;      &lt;div class=&quot;td&quot;&gt;23&lt;/div&gt;&gt;      &lt;div class=&quot;td&quot;&gt;24&lt;/div&gt;&gt;      &lt;div class=&quot;td&quot;&gt;25&lt;/div&gt;&gt;    &lt;/div&gt;&gt;    &lt;div class=&quot;tr&quot;&gt;&gt;      &lt;div class=&quot;td current&quot;&gt;26&lt;/div&gt;&gt;      &lt;div class=&quot;td&quot;&gt;27&lt;/div&gt;&gt;      &lt;div class=&quot;td&quot;&gt;28&lt;/div&gt;&gt;      &lt;div class=&quot;td&quot;&gt;29&lt;/div&gt;&gt;      &lt;div class=&quot;td&quot;&gt;30&lt;/div&gt;&gt;      &lt;div class=&quot;td&quot;&gt;31&lt;/div&gt;&gt;      &lt;div class=&quot;td next-month&quot;&gt;1&lt;/div&gt;&gt;    &lt;/div&gt;&gt;    &lt;div class=&quot;tr&quot;&gt;&gt;      &lt;div class=&quot;td next-month&quot;&gt;2&lt;/div&gt;&gt;      &lt;div class=&quot;td next-month&quot;&gt;3&lt;/div&gt;&gt;      &lt;div class=&quot;td next-month&quot;&gt;4&lt;/div&gt;&gt;      &lt;div class=&quot;td next-month&quot;&gt;5&lt;/div&gt;&gt;      &lt;div class=&quot;td next-month&quot;&gt;6&lt;/div&gt;&gt;      &lt;div class=&quot;td next-month&quot;&gt;7&lt;/div&gt;&gt;      &lt;div class=&quot;td next-month&quot;&gt;8&lt;/div&gt;&gt;    &lt;/div&gt;&gt;  &lt;/div&gt;&gt;&lt;/div&gt;&gt;&lt;!-- end calendar-main  --&gt;&gt;&lt;/div&gt;</code></pre><ul><li>CSS布局</li></ul><pre><code>&gt;&lt;style&gt;  .calendar &#123;    width: 300px;    border: 1px solid #ddd;    padding: 20px;    box-shadow: 0 0 5px #ddd;    border-radius: 5px;    margin: 100px;  &#125;  /* calendar-menu start */  .calendar-menu &#123;    display: flex;  &#125;  .calendar-menu span &#123;    color: #898484;    user-select: none;    cursor: pointer;  &#125;  .calendar-menu .current-date &#123;    color: #000;    flex-grow: 1;    text-align: center;  &#125;  .calendar-menu .prev-year &#123;    margin-right: 20px;  &#125;  .calendar-menu .next-year &#123;    margin-left: 20px;  &#125;  /* end calendar-menu */  /* calendar-week start */  .calendar .table &#123;    display: table;    width: 100%;  &#125;  .calendar .tr &#123;    display: table-row;  &#125;  .table .tr .th,  .table .tr .td &#123;    display: table-cell;    height: 35px;    font-size: 12px;    text-align: center;    vertical-align: middle;    cursor: pointer;  &#125;  .table .tr .th &#123;    padding-top: 15px;    border-bottom: 1px solid #ddd;  &#125;  /* end calendar-week */  /* calendar-main start */  .table .tr .td.prev-month,  .table .tr .td.next-month &#123;    color: rgb(194, 194, 194);  &#125;  /* 今日 */  .table .tr .td.current &#123;    background-color: rgb(232, 6, 6);    color: #fff;    font-weight: bold;  &#125;  /* 鼠标滑动 */  .table .tr .td:hover &#123;    outline: 1px solid #ddd;  &#125;  /* 鼠标点击 */  .table .tr .td.active &#123;    outline: 2px solid rgb(244, 31, 102);  &#125;  /* end calendar-main */&gt;&lt;/style&gt;</code></pre><ol start="2"><li><p>JS 实现思路</p><blockquote><p>关于日历的渲染，我们需要知道以下几方面信息</p><ul><li>1、<strong>当月有多少天</strong>，这样就可以知道当月从 1 号渲染到几号；并且通过这个函数可以知道上月最后一天的日期；</li><li>2、<strong>当月的第一天是星期几</strong>，这样就能知道当月 1 号的渲染位置</li><li>3、上月需要渲染天数对应的日期，（知道了当月第一天是星期几，就可以知道上月需要渲染的天数，同时还要知道上月最后一天是几号，就要以知道对应的日期）</li><li>4、下个月需要渲染的天数对应日期，保存在数组中。（<code>下月需要渲染天数 = 42 - 当月总天数 - 上月需要渲染的天数</code>，对应日期，从<code>1</code>号开始渲染到对应天数就可以）<blockquote><p>要注意：获取星期时，星期日的对应的数字是<code>0</code>，要处理</p></blockquote></li></ul></blockquote></li><li><p>书写相关的工具函数</p></li></ol><ul><li>获取对应年份的月份的总天数<blockquote><ul><li>既可以知道当月有多少天</li><li>也可以知道上月有多少天——&gt;得到上月最后一天的日期</li></ul></blockquote></li></ul><pre><code> function getMonthDay(year,month)&#123;  var date=new Date(year,month,0);  return date.getDate();&#125;</code></pre><ul><li>获取当月第一天是星期几</li></ul><pre><code> function getMonthWeek(year,month)&#123;  var date=new Date(year,month-1,1);  return date.getDay();   &#125;</code></pre><ul><li>将上月需要渲染天数对应的日期，保存在数组中</li></ul><pre><code> function getPrevMonth(year,month)&#123;  //需要知道当月第一天是星期几  var week=getMonthWeek(year,month);  //得到上月需要渲染的天数,如果week=0表示周日，则需要上个月需要渲染6天  weekCount=week===0?6:week-1;  //需要知道上月最后一天的日期  var prevCount=getMonthDay(year,month-1);  var prevDate=[];//保存上月需要渲染的日期  while(weekCount&gt;0)&#123;      //只要需要渲染的天数大于0就将上月的日期保存到数组中      prevDate.push(prevCount--);      weekCount--;  &#125;  return prevDate.reverse();&#125;</code></pre><ul><li>将下个月需要渲染的天数对应的日期，保存在数组中</li></ul><pre><code> function nextMonthDate(year,month)&#123;  //需要知道当月第一天是星期几  var week=getMonthWeek(year,month);  //得到上月需要渲染的天数,如果week=0表示周日，则需要上个月需要渲染6天  weekCount=week===0?6:week-1;  //得到当月天数  var monthDay=getMonthDay(year,month);&gt;  var nextDate=[];//保存下个月需要渲染的日期  var nextCount=42-monthDay-weekCount;  for(var i=1;i&lt;=nextCount;i++)&#123;      nextDate.push(i)  &#125;  return nextDate;&#125;</code></pre><ol start="4"><li>根据日期创建 td 结构数组<blockquote><ul><li>分别根据上月&#x2F;当月&#x2F;下月需要渲染的日期，生成对应 td 标签和样式，保存到不同数组里</li><li><code>map()</code>方法创建一个新数组，这个新数组由原数组中的每个元素都调用一次提供的函数后的返回值组成。</li><li>根据前面写的功能函数可知，上月、下月的日期已经保存在数组里，而当月需要渲染的日期有当月的天数决定</li></ul></blockquote></li></ol><pre><code>//根据上月需要渲染的日期，生成td标签和样式function creatTd1(arr)&#123;    return arr.map(function(item)&#123;        var td=document.createElement(&quot;div&quot;);        td.className=&quot;td prev-month&quot;;        td.innerText=item;        return td;    &#125;)&#125;//根据本月需要渲染的天数，生成td标签和样式function creatTd2(days)&#123;    return arr.map(function(item)&#123;        var td=document.createElement(&quot;div&quot;);        td.className=&quot;td&quot;;        td.innerText=item;        return td;    &#125;)&#125;//根据下月需要渲染的日期，生成td标签和样式function creatTd1(arr)&#123;    return arr.map(function(item)&#123;        var td=document.createElement(&quot;div&quot;);        td.className=&quot;td next-month&quot;;        td.innerText=item;        return td;    &#125;)&#125;</code></pre><ol start="5"><li>创建 render 渲染函数，根据对应年月来渲染出日历内容<blockquote><ul><li>调用功能函数得到需要渲染的日期</li><li>然后调用创建td结构的函数，得到保存了td结构和样式的数组</li><li>将上月、本月、下月的td结构数组拼接成一个新数组</li><li>根据新数组，创建6行7列的表格，并将这个表格插入到<code>table</code>里</li><li><strong>获取</strong><code>calendar-main</code>再把<code>table</code>插入到它里面<blockquote><p>注意：</p></blockquote></li><li>在渲染前，还要把原有内容清空</li></ul></blockquote></li></ol><pre><code>// 创建渲染函数，用来渲染 xxxx年xx月的日历表 function render(year,month)&#123;  //先拿到上月、当月、下月的日期  var prevMonth=getPrevMonth(year,month);  var currentMonth=getMonthDay(year,month);  var nextMonth=nextMonthDate(year,month);  //创建td结构  var td1=creatTd1(prevMonth);  var td2=creatTd2(currentMonth);  var td3=creatTd3(nextMonth);  //将td拼接成一个数组  var tds=td1.concat(td2,td3);  //获取calendar-main  var calendarMain=document.querySelector(&quot;.calendar-main&quot;);  //渲染前将原有内容清空  calendarMain.innerHTML=&quot;&quot;;  //将table插入到calendar-main中  calendarMain.appendChild(creatTable(tds))&gt;  //将tds插入到table中  function creatTable(tds)&#123;      var table=document.createElement(&quot;div&quot;);      table.className=&quot;table&quot;;      var n=0;      //行      for(var i=0;i&lt;6;i++)&#123;          var tr=document.createElement(&quot;div&quot;);          tr.className=&quot;tr&quot;;          //列          for(var j=0;j&lt;7;j++)&#123;              tr.appendChild(tds[n]);              n++;          &#125;          table.appendChild(tr);      &#125;      return table;  &#125;&#125;</code></pre><ul><li>创建函数，用来获取当前的日期</li></ul><pre><code>function getNowDate()&#123;    var nowDate=new Date();    return &#123;        year:nowDate.getFullYear(),        month:nowDate.getMonth()+1,        date:nowDate.getDate(),    &#125;&#125;</code></pre><ul><li>调用 render 函数，来生成对应日历<blockquote><ul><li>给render函数传入当前年月</li></ul></blockquote></li></ul><pre><code>render(getNowDate().year, getNowDate().month)</code></pre><ol start="6"><li><p>今天的日期，背景要变成红色</p><blockquote><ul><li>改写上面创建当月<code>td</code>结构的函数</li><li>形参改为年月，在render函数里调用时，传入实参</li><li>获取当前日期(年、月、日)</li><li>通过传入的实参，获取实参月的总天数</li><li>在for循环创建td结构时，如果传入的年份等于当前年，传入的月份等于当前月、当前日等于i时，给该td添加样式</li></ul></blockquote></li><li><p>完善 render 函数</p><blockquote><ul><li>当前日历表头的xxxx年xx月日期，要更新为当前渲染的日期</li></ul></blockquote></li></ol><pre><code>function render(year, month) &#123;  // 日历头部日期显示为渲染日期  var dateDom = document.querySelector(&quot;.calendar-menu .current-date&quot;);  dateDom.innerText = dateDom.innerText = year + &quot;年 &quot; + month + &quot;月&quot;;  // .....&#125;</code></pre><ol start="8"><li>年月切换按扭事件处理<blockquote><ul><li>注意切换到第0月和第13月的时候，要处理一下</li></ul></blockquote></li></ol><pre><code>  var date = getNowDate();  var currentYear = date.year;  var currentMonth = date.month;  var currentDate = date.date;  render(currentYear, currentMonth);&gt;  var prevYearDom = document.querySelector(&quot;.prev-year&quot;);  var nextYearDom = document.querySelector(&quot;.next-year&quot;);  var prevMonthDom = document.querySelector(&quot;.prev-month&quot;);  var nextMonthDom = document.querySelector(&quot;.next-month&quot;);&gt;  //上一年  prevYearDom.onclick = function () &#123;    currentYear--;    render(currentYear, currentMonth);  &#125;;  //下一年  nextYearDom.onclick = function () &#123;    currentYear++;    render(currentYear, currentMonth);  &#125;;  //上一月  prevMonthDom.onclick = function () &#123;    currentMonth--;    if (currentMonth === 0) &#123;      currentMonth = 12;      currentYear--;    &#125;    render(currentYear, currentMonth);  &#125;;  //下一月  nextMonthDom.onclick = function () &#123;    currentMonth++;    if (currentMonth === 13) &#123;      currentMonth = 1;      currentYear++;    &#125;    render(currentYear, currentMonth);  &#125;;</code></pre><ol start="9"><li>选中对应日期<blockquote><ul><li>使用事件委托</li><li>选中日期后，添加样式</li><li>打印出当前的日期</li></ul></blockquote></li></ol><pre><code>  //选中对应日期  var calendarMain = document.querySelector(&quot;.calendar-main&quot;);  var prevEl = null; //前一个被选中的元素  calendarMain.onclick = function (e) &#123;    var target = e.target;    var bool = target.classList.contains(&quot;td&quot;);    if (!bool) return;    //将前一个选中元素的样式清除    if (prevEl) prevEl.classList.remove(&quot;active&quot;);    //给被选中元素添加样式    target.classList.add(&quot;active&quot;);    prevEl = target;    console.log(         currentYear + &quot;年&quot; + currentMonth + &quot;月&quot; + target.innerText + &quot;日&quot;       );  &#125;</code></pre><ul><li>方式1：点击上月&#x2F;下月日期，不切换页面</li></ul><pre><code>calendarMain.onclick = function (e) &#123;  //如果点击上/月日期，不切换页面，则：  var _currentYear = currentYear;  var _currentMonth = currentMonth;  var prevBool = target.classList.contains(&quot;prev-month&quot;);  var nextBool = target.classList.contains(&quot;next-month&quot;);  if (prevBool) &#123;    _currentMonth--;    if (currentMonth === 0) &#123;      _currentMonth = 12;      _currentyear--;    &#125;  &#125;  if (nextBool) &#123;    _currentMonth++;    if (currentMonth === 13) &#123;      _currentMonth = 1;      _currentyear++;    &#125;  &#125;  //打印对应日期  console.log(    _currentYear + &quot;年&quot; + _currentMonth + &quot;月&quot; + target.innerText + &quot;日&quot;  );&#125;</code></pre><ul><li>方式2：点击上月&#x2F;下月日期，跳转到对应月份<blockquote><ul><li>再次修改创建当月td的函数，传入<code>selectDate</code>变量，里面保存当前选中的日</li><li>在for循环创建<code>td</code>时，如果i等于<code>selectDate</code>，就给它添加样式<blockquote><p>注意:</p></blockquote></li><li><code>selectDate</code>是字符串，i是数字，只能用<code>==</code>不能全等</li></ul></blockquote></li></ul><pre><code> calendarMain.onclick = function (e) &#123;  var target = e.target;  var bool = target.classList.contains(&quot;td&quot;);  if (!bool) return;  //将前一个选中元素的样式清除  if (prevEl) prevEl.classList.remove(&quot;active&quot;);  //给被选中元素添加样式  target.classList.add(&quot;active&quot;);  prevEl = target;  //如果点击上/月日期，切换页面，则：  var prevBool = target.classList.contains(&quot;prev-month&quot;);  var nextBool = target.classList.contains(&quot;next-month&quot;);&gt;  if (prevBool) &#123;    currentMonth--;    if (currentMonth === 0) &#123;      currentMonth = 12;      currentYear--;    &#125;    var selectDate = target.innerText; //保存被点击的日期    render(currentYear, currentMonth, selectDate);  &#125;  if (nextBool) &#123;    currentMonth++;    if (currentMonth === 13) &#123;      currentMonth = 1;      currentYear++;    &#125;    var selectDate = target.innerText; //保存被点击的日期    render(currentYear, currentMonth, selectDate);  &#125;  //打印对应日期  console.log(    currentYear + &quot;年&quot; + currentMonth + &quot;月&quot; + target.innerText + &quot;日&quot;  );&#125;;</code></pre><blockquote><p><strong>更新 render函数</strong></p></blockquote><pre><code>//selectDate 表示当前选中天数function render(year, month, selectDate) &#123;  if(selectDate)&#123;      var td2=creatTd2(year,month,selectDate);  &#125;else&#123;      var td2=creatTd2(year,month);  &#125;  //....&#125;</code></pre><blockquote><p><strong>更新 createTd3 函数</strong></p></blockquote><pre><code> //根据本月需要渲染的天数，生成td标签和样式 function creatTd2(year,month,selectDate)&#123;   var result=[];   var currentYear=getNowDate().year;   var currentMonth=getNowDate().month;   var currentDate=getNowDate().date;&gt;   var days=getMonthDay(year,month);   for(var i=1;i&lt;=days;i++)&#123;       var td=document.createElement(&quot;div&quot;);       if(year===currentYear&amp;&amp;month===currentMonth&amp;&amp;currentDate===i)&#123;           td.className=&quot;td current&quot;       &#125;else&#123;           td.className=&quot;td&quot;;       &#125;       if(selectDate &amp;&amp; selectDate==i) &#123;           td.classList.add(&quot;active&quot;);           prevEl=td;       &#125;       td.innerText=i;       result.push(td)   &#125;   return result;&#125;</code></pre><ol start="10"><li>优化<blockquote><ul><li>如果现在翻到12月，今天的日期在12月的页面可以看到。此时，今天的日期也应该有样式</li><li>把<code>creatTd1</code>、<code>creatTd3</code>也修改成<code>creatTd2</code>那样</li><li>参数为年月，根据传入的参数，得到上一个月的年月</li><li>参数为年月，根据传入的参数，得到下一个月的年月</li><li>在函数内获取今年今月今日，和上一个月(下月)的年月做比较，如果相同就加样式</li></ul></blockquote></li></ol><pre><code> //根据上月需要渲染的日期，生成td标签和样式 function creatTd1(year,month)&#123;   //获取今天的日期   var currentYear=getNowDate().year;   var currentMonth=getNowDate().month;   var currentDate=getNowDate().date;&gt;   //获取上个月的年月   var prevYear=year;   var prevMonth=month-1;   if(prevMonth===0)&#123;       prevMonth===12;       prevYear=year-1;   &#125;   var arr=getPrevMonth(year,month);&gt;   return arr.map(function(item)&#123;       var td=document.createElement(&quot;div&quot;);       td.className=&quot;td prev-month&quot;;        // 判断当前月的前一个月中的某个日期为当前日期时       if(currentYear===prevYear&amp;&amp;currentMonth===prevMonth&amp;&amp;currentDate===item)&#123;           td.classList.add(&quot;current&quot;)       &#125;       td.innerText=item;       return td;   &#125;)&#125; //根据下月需要渲染的日期，生成td标签和样式 function creatTd3(year,month)&#123;   //获取今天的日期   var currentYear=getNowDate().year;   var currentMonth=getNowDate().month;   var currentDate=getNowDate().date;&gt;   //获取上个月的年月   var nextYear=year;   var nextMonth=month+1;   if(nextMonth===13)&#123;       nextMonth===1;       nextYear=year+1;   &#125;   var arr=nextMonthDate(year,month);   return arr.map(function(item)&#123;       var td=document.createElement(&quot;div&quot;);       td.className=&quot;td next-month&quot;;       if(currentYear===nextYear&amp;&amp;currentMonth===nextMonth&amp;&amp;currentDate===item)&#123;           td.classList.add(&quot;current&quot;)       &#125;       td.innerText=item;       return td;   &#125;)&#125;</code></pre><ol start="11"><li>封装完整版工具函数 calendar.js<blockquote><ul><li>保存功能性函数</li></ul></blockquote></li></ol><pre><code>//1、获取当月的天数function getMonthDay(year,month)&#123;    var date=new Date(year,month,0);    return date.getDate();&#125;// console.log(getMonthDay(2023,8))&gt;//2、获取当月第一天是星期几function getMonthWeek(year,month)&#123;    var date=new Date(year,month-1,1);    return date.getDay();   &#125;// console.log(getMonthWeek(2023,8))&gt;//3、把上月需要渲染的日期存入数组：function getPrevMonth(year,month)&#123;    //需要知道当月第一天是星期几    var week=getMonthWeek(year,month);    //得到上月需要渲染的天数,如果week=0表示周日，则需要上个月需要渲染6天    weekCount=week===0?6:week-1;    //需要知道上月最后一天的日期    var prevCount=getMonthDay(year,month-1);    var prevDate=[];//保存上月需要渲染的日期    while(weekCount&gt;0)&#123;        //只要需要渲染的天数大于0就将上月的日期保存到数组中        prevDate.push(prevCount--);        weekCount--;    &#125;    return prevDate.reverse();&#125;// console.log(getPrevMonth(2023,7))&gt;// 4、下个月需要渲染的天数对应的日期，保存在数组中function nextMonthDate(year,month)&#123;     //需要知道当月第一天是星期几     var week=getMonthWeek(year,month);     //得到上月需要渲染的天数,如果week=0表示周日，则需要上个月需要渲染6天     weekCount=week===0?6:week-1;     //得到当月天数     var monthDay=getMonthDay(year,month);&gt;    var nextDate=[];//保存下个月需要渲染的日期    var nextCount=42-monthDay-weekCount;    for(var i=1;i&lt;=nextCount;i++)&#123;        nextDate.push(i)    &#125;    return nextDate;&#125;// console.log(nextMonthDate(2023,7))&gt;//根据上月需要渲染的日期，生成td标签和样式function creatTd1(year,month)&#123;    //获取今天的日期    var currentYear=getNowDate().year;    var currentMonth=getNowDate().month;    var currentDate=getNowDate().date;&gt;    //获取上个月的年月    var prevYear=year;    var prevMonth=month-1;    if(prevMonth===0)&#123;        prevMonth===12;        prevYear=year-1;    &#125;    var arr=getPrevMonth(year,month);&gt;    return arr.map(function(item)&#123;        var td=document.createElement(&quot;div&quot;);        td.className=&quot;td prev-month&quot;;         // 判断当前月的前一个月中的某个日期为当前日期时        if(currentYear===prevYear&amp;&amp;currentMonth===prevMonth&amp;&amp;currentDate===item)&#123;            td.classList.add(&quot;current&quot;)        &#125;        td.innerText=item;        return td;    &#125;)&#125;//根据本月需要渲染的天数，生成td标签和样式function creatTd2(year,month,selectDate)&#123;    var result=[];    var currentYear=getNowDate().year;    var currentMonth=getNowDate().month;    var currentDate=getNowDate().date;&gt;    var days=getMonthDay(year,month);    for(var i=1;i&lt;=days;i++)&#123;        var td=document.createElement(&quot;div&quot;);        if(year===currentYear&amp;&amp;month===currentMonth&amp;&amp;currentDate===i)&#123;            td.className=&quot;td current&quot;        &#125;else&#123;            td.className=&quot;td&quot;;        &#125;        if(selectDate &amp;&amp; selectDate==i) &#123;            td.classList.add(&quot;active&quot;);            prevEl=td;        &#125;        td.innerText=i;        result.push(td)    &#125;    return result;&#125;//根据下月需要渲染的日期，生成td标签和样式function creatTd3(year,month)&#123;    //获取今天的日期    var currentYear=getNowDate().year;    var currentMonth=getNowDate().month;    var currentDate=getNowDate().date;&gt;    //获取上个月的年月    var nextYear=year;    var nextMonth=month+1;    if(nextMonth===13)&#123;        nextMonth===1;        nextYear=year+1;    &#125;    var arr=nextMonthDate(year,month);    return arr.map(function(item)&#123;        var td=document.createElement(&quot;div&quot;);        td.className=&quot;td next-month&quot;;        if(currentYear===nextYear&amp;&amp;currentMonth===nextMonth&amp;&amp;currentDate===item)&#123;            td.classList.add(&quot;current&quot;)        &#125;        td.innerText=item;        return td;    &#125;)&#125;// 创建渲染函数，用来渲染 xxxx年xx月的日历表function render(year,month,selectDate)&#123;    //更新日历头部    var dateDom=document.querySelector(&quot;.calendar-menu .current-date&quot;);    dateDom.innerText=year+&quot;年&quot;+month+&quot;月&quot;;    //先拿到上月、当月、下月的日期    var prevMonth=getPrevMonth(year,month);    var currentMonth=getMonthDay(year,month);    var nextMonth=nextMonthDate(year,month);    //创建td结构    var td1=creatTd1(year,month);    if(selectDate)&#123;        var td2=creatTd2(year,month,selectDate);    &#125;else&#123;        var td2=creatTd2(year,month);    &#125;    var td3=creatTd3(year,month);&gt;    //将td拼接成一个数组    var tds=td1.concat(td2,td3);    //获取calendar-main    var calendarMain=document.querySelector(&quot;.calendar-main&quot;);    //渲染前将原有内容清空    calendarMain.innerHTML=&quot;&quot;;    //将table插入到calendar-main中    calendarMain.appendChild(creatTable(tds))&gt;    //将tds插入到table中    function creatTable(tds)&#123;        var table=document.createElement(&quot;div&quot;);        table.className=&quot;table&quot;;        var n=0;        //行        for(var i=0;i&lt;6;i++)&#123;            var tr=document.createElement(&quot;div&quot;);            tr.className=&quot;tr&quot;;            //列            for(var j=0;j&lt;7;j++)&#123;                tr.appendChild(tds[n]);                n++;            &#125;            table.appendChild(tr);        &#125;        return table;    &#125;&#125;function getNowDate()&#123;    var nowDate=new Date();    return &#123;        year:nowDate.getFullYear(),        month:nowDate.getMonth()+1,        date:nowDate.getDate(),    &#125;&#125;</code></pre><ol start="12"><li>完整版日历组件开发</li></ol><pre><code>&gt;&lt;script&gt;  var date = getNowDate();  var currentYear = date.year;  var currentMonth = date.month;  var currentDate = date.date;  render(currentYear, currentMonth);&gt;  var prevYearDom = document.querySelector(&quot;.prev-year&quot;);  var nextYearDom = document.querySelector(&quot;.next-year&quot;);  var prevMonthDom = document.querySelector(&quot;.prev-month&quot;);  var nextMonthDom = document.querySelector(&quot;.next-month&quot;);&gt;  //上一年  prevYearDom.onclick = function () &#123;    currentYear--;    render(currentYear, currentMonth);  &#125;;  //下一年  nextYearDom.onclick = function () &#123;    currentYear++;    render(currentYear, currentMonth);  &#125;;  //上一月  prevMonthDom.onclick = function () &#123;    currentMonth--;    if (currentMonth === 0) &#123;      currentMonth = 12;      currentYear--;    &#125;    render(currentYear, currentMonth);  &#125;;  //下一月  nextMonthDom.onclick = function () &#123;    currentMonth++;    if (currentMonth === 13) &#123;      currentMonth = 1;      currentYear++;    &#125;    render(currentYear, currentMonth);  &#125;;&gt;  //选中对应日期  var calendarMain = document.querySelector(&quot;.calendar-main&quot;);  var prevEl = null; //前一个被选中的元素  calendarMain.onclick = function (e) &#123;    var target = e.target;    var bool = target.classList.contains(&quot;td&quot;);    if (!bool) return;    //将前一个选中元素的样式清除    if (prevEl) prevEl.classList.remove(&quot;active&quot;);    //给被选中元素添加样式    target.classList.add(&quot;active&quot;);    prevEl = target;    //如果点击上/月日期，切换页面，则：    var prevBool = target.classList.contains(&quot;prev-month&quot;);    var nextBool = target.classList.contains(&quot;next-month&quot;);&gt;  if (prevBool) &#123;    currentMonth--;    if (currentMonth === 0) &#123;      currentMonth = 12;      currentYear--;    &#125;    var selectDate = target.innerText; //保存被点击的日期    render(currentYear, currentMonth, selectDate);  &#125;  if (nextBool) &#123;    currentMonth++;    if (currentMonth === 13) &#123;      currentMonth = 1;      currentYear++;    &#125;    var selectDate = target.innerText; //保存被点击的日期    render(currentYear, currentMonth, selectDate);  &#125;  //打印对应日期  console.log(    currentYear + &quot;年&quot; + currentMonth + &quot;月&quot; + target.innerText + &quot;日&quot;  );&#125;;&gt;&lt;/script&gt;</code></pre>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JS核心知识点（十五）</title>
      <link href="/2023/12/08/JS%E6%A0%B8%E5%BF%83%E7%9F%A5%E8%AF%86%E7%82%B9%EF%BC%88%E5%8D%81%E4%BA%94%EF%BC%89/"/>
      <url>/2023/12/08/JS%E6%A0%B8%E5%BF%83%E7%9F%A5%E8%AF%86%E7%82%B9%EF%BC%88%E5%8D%81%E4%BA%94%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<span id="more"></span><h2 id="JavaScript-继承的-6-种方式、应用场景，内置构造函数"><a href="#JavaScript-继承的-6-种方式、应用场景，内置构造函数" class="headerlink" title="JavaScript 继承的 6 种方式、应用场景，内置构造函数"></a>JavaScript 继承的 6 种方式、应用场景，内置构造函数</h2><h3 id="一、什么是继承呢-？"><a href="#一、什么是继承呢-？" class="headerlink" title="一、什么是继承呢 ？"></a>一、什么是继承呢 ？</h3><blockquote><ul><li>首先继承是一种关系，类（Class）与类之间的关系</li><li>JS 中<strong>没有类</strong>,但是可以通过构造函数<strong>模拟类</strong>，然后通过原型来实现继承。</li><li>继承是为了实现数据共享，同时对于实现<strong>代码的复用</strong>非常有用</li></ul></blockquote><blockquote><blockquote><p>我们先来看下面两个类<br><img src="继承-类.png"></p></blockquote></blockquote><blockquote><p><strong>解说</strong></p><ul><li><code>People</code>类拥有的属性和方法<code>Student</code>类都有，同时<code>Student</code>类还扩展了一些自已独有的属性和方法</li><li>我们可以按上图结构定义<code>People</code>类，然后再定义一个<code>Student</code>类，在<code>Student</code>类上只需要定义<code>People</code>类上没有的属性和方法。</li><li>然后用<code>Student</code>类继承<code>People</code>类，这样<code>Student</code>类就可以直接拥有<code>People</code>类的所有属性和方法了</li></ul></blockquote><blockquote><blockquote><p><code>Student</code> 类继承 <code>People</code> 类，在这个继承关系中</p></blockquote><ul><li><code>People</code> 类称为“父类”（或 “超类”、“基类”）</li><li><code>Student</code> 类称为“子类”（或“派生类”）</li><li><code>Student</code> 子类可以访问 <code>People</code> 父类的所有属性和方法</li><li><code>Student</code> “是一种” <code>People</code> ，两个继承类之间是<code>“is a kind of”</code>关系</li><li>继承描述了两个类之间的<code>“ is a kind of &quot;</code>关系，也就是两个类之间存在<code>&quot;is a kind of &quot;</code>关系，就可以实现继承。</li></ul></blockquote><ul><li>接下来，我们来学习下，如何实现类与类之间的继承关系。</li></ul><blockquote><p><strong>JavaScript 实现继承有以下 6 种方式</strong></p><ul><li>原型链实现继承</li><li>借用构造函数（经典继承）</li><li>组合继承</li><li>原型式继承</li><li>寄生式继承</li><li>寄生式组合继承<blockquote><p>实现继承的关键在于：子类必须拥有父类的全部公有（属性和方法），<strong>同时</strong>子类还应该能定义自己特有的属性和方法</p></blockquote></li></ul></blockquote><h3 id="二、通过原型链实现继承"><a href="#二、通过原型链实现继承" class="headerlink" title="二、通过原型链实现继承"></a>二、通过原型链实现继承</h3><blockquote><p>接下来，我们来学习下，如何<strong>利用原型链</strong>实现 <code>Student</code>类 继承 <code>People</code>类</p></blockquote><h4 id="原型链实现继承的本质"><a href="#原型链实现继承的本质" class="headerlink" title="原型链实现继承的本质"></a>原型链实现继承的本质</h4><blockquote><p>让子类构造函数的<code>prototype</code> ，指向父类的一个<strong>实例</strong></p></blockquote><pre class=" language-js"><code class="language-js"><span class="token comment" spellcheck="true">// 子类 Student 父类 People</span>Student<span class="token punctuation">.</span>prototype <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">People</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 以上原型链方式实现继承，Student 的实例就可以访问 Popele类原型上的所有方法和属性</span></code></pre><blockquote><ul><li>通过前面的学习我们知道，每个构造函数都有一个 <code>prototype</code> 属性，这个属性指向一个对象。</li><li>构造函数构造出来的实例对象，可以访问构造函数 <code>prototype</code> 属性上所有方法和属性。</li><li>如果<code>子类构造函数.prototype = 父类的实例</code> ，那<strong>子类的实例</strong>就可以通过原型链查找，访问到父类构造函数原型 <code>prototype</code> 上面的所有属性和方法。</li></ul></blockquote><ol><li>Student 类继承 People 类关系图<img src="通过原型链继承.png"></li></ol><blockquote><p>原型链实现继承本质上是<strong>扩展</strong>了原型的搜索机制。</p><ul><li>实例在访问某个属性时，会在自己身上找，找不到，就会去原型上找</li><li>原型上找不到，就会去继承的实例的原型上去找，一层层向上找，找到就不找</li><li>找不到就会一直找到原型链的终点（Object 原型的原型，为 null）</li></ul></blockquote><ul><li>Student 类 与 People 类 通过原型链实现继承，代码如下</li></ul><pre><code>// 父类  人类function People(name, age, sex) &#123;  this.name = name;  this.age = age;  this.sex = sex;&#125;People.prototype.sayHello = function () &#123;  console.log(    &quot;我是&quot; + this.name + &quot;今年&quot; + this.age + &quot;岁，我是&quot; + this.sex + &quot;生&quot;  );&#125;;People.prototype.sleep = function () &#123;  console.log(this.name + &quot;开始睡觉了zzzzz&quot;);&#125;;&gt;// 子类  学生类function Student(name, age, sex, scholl, sid) &#123;  this.name = name;  this.age = age;  this.sex = sex;  this.scholl = scholl;  this.sid = sid;&#125;&gt;// 实现继承   一定要先实现继承，再添加新的方法和属性Student.prototype = new People();&gt;Student.prototype.study = function () &#123;  console.log(this.name + &quot;正在学习！&quot;);&#125;;Student.prototype.exam = function () &#123;  console.log(this.name + &quot;正在考试，加油！！&quot;);&#125;;&gt;// 创建父类 实例var laoliu = new People(&quot;老刘&quot;, 38, &quot;男&quot;);laoliu.sayHello();//我是老刘今年38岁，我是男生&gt;// 创建子类实例var cuihua = new Student(&quot;翠花&quot;, 18, &quot;女&quot;, &quot;雅礼中学&quot;, 20800);cuihua.sayHello();//我是翠花今年18岁，我是女生cuihua.sleep();//翠花开始睡觉了zzzzzcuihua.study();//翠花正在学习！cuihua.exam();//翠花正在考试，加油！！</code></pre><blockquote><ul><li>一定要先实现继承，再添加新的方法和属性<ul><li><code>Student.prototype = new People();</code>改变了子类的<code>prototype</code></li><li>通过<code>Student.prototype</code>添加的方法，实际上是加在了<code>new People()</code>身上</li><li>如果先添加方法，再改变，就找不到该方法了</li></ul></li><li>父类和子类身上都有<code>name</code>、<code>sex</code>、<code>age</code>属性</li><li>写<code>Student.prototype = new People();</code>的时候，不用输入参数，输了也会被新创建的子类替代</li></ul></blockquote><ol start="2"><li>注意事项 1 - 重写父类方法<blockquote><ul><li>子类有时候需要覆盖父类的方法，或者增加父类没有的方法。这些方法必须<strong>在原型赋值之后再添加</strong>到原型上去。</li><li>子类覆盖父类上已有的方法，我们称为重写 （override）父类方法</li></ul></blockquote></li></ol><pre><code>// 以下代码必需写在 Student.prototype = new People(); 之后// 也可以重写（override）父类的 sayHello方法Student.prototype.sayHello = function () &#123;  console.log(&quot;大家好，我是&quot; + this.scholl + &quot;学校的学生,我叫&quot; + this.name);&#125;;</code></pre><ol start="3"><li>注意事项 2 - 子类的 <code>constructor</code> 指向问题<blockquote><p>复习知识点：</p><ul><li>任何函数都有一个<code>prototype</code>属性，<code>prototype</code>属性值是一个<strong>对象</strong>，这个对象有一个<code>constructor</code>属性，指向这个函数本身</li><li>构造函数的<code>prototype</code>属性是它的实例的原型,在构造函数的实例中有一个隐含的属性<code>__proto__</code>，指向该构造函数的原型<code>prototype</code></li><li>构造函数构造的<strong>实例</strong>可以直接访问<code>prototype</code>对象身上的属性和方法；因此<code>实例.constructor === 构造函数</code> 那就说明这个实例是这个构造函数的实例<blockquote><p>实例会沿着原型链<code>__proto__</code>一层层查找<code>constructor</code>，只有原型<code>prototype</code>才有<code>constructor</code>属性</p></blockquote></li></ul></blockquote></li></ol><img src="子类的constructor指向问题.png"><blockquote><ul><li>因为<code>Student.prototype=new People()</code>使<code>Student</code>类继承<code>People</code>类</li></ul></blockquote><pre><code>Student.prototype=new People();new People().constructor===People;Student.prototype.consructor===People;cuihua.__proto__===new People();cuihua.__proto__.constuctor===People;因为构造函数构造的实例可以直接访问其构造函数的`prototype`对象身上的属性和方法所以：cuihua.constructor===People</code></pre><blockquote><ul><li>因此<code>Student.prototype</code>中的<code>constructor</code>属性被重写为指向<code>People</code></li><li>即<code>Student</code>的所有实例访问到的<code>constructor</code>都指向<code>People</code></li><li>所以造成了子类原型中的<code>constructor</code>被丢失，当访问子类原型中的<code>constructor</code>时，其本质是通过原型链查找，最终查找到的是父类的构造函数</li></ul></blockquote><ol start="4"><li>注意事项 3 - instanceof<blockquote><ul><li><code>instanceof</code>操作符确认<strong>实例与构造函数的关系</strong></li><li>如果实例的原型链中出现过对应的构造函数的原型，则实例为对应构造函数的实例</li></ul></blockquote></li></ol><pre><code>cuihua instanceof Student; // truecuihua instanceof People; // truecuihua instanceof Object; // true</code></pre><ol start="5"><li>注意事项 4<blockquote><p>从继承的角度来看原型链</p><ul><li>任意函数的默认<code>prototype</code>原型都是一个<code>Object</code>的实例</li><li>这就意味着函数的默认原型中有一个<code>__proto__</code>属性指向<code>Object.prototype</code><blockquote><p>声明一个构造函数<code>People</code></p></blockquote></li></ul></blockquote></li></ol><pre><code>function People() &#123;&#125;People.prototype.__proto__ === Object.prototype; // truenew People().__proto__.__proto__ === Object.prototype; // true</code></pre><img src="继承的角度看原型链.png"><blockquote><ul><li>根据上图可知，任何函数其实都继承于<code>Object</code></li><li>这就是为什么自定义类型能继承（访问）<code>Object</code> 原型上的<code>toString()</code>、<code>valueOf()</code>等方法的原型</li></ul></blockquote><ol start="6"><li>原型链实现继承的不足之一<blockquote><ul><li>实例拥有其构造函数的所有属性和方法(可访问可修改)，并且能够调用其原型里的所有方法</li><li>如果<strong>原型中</strong>某个属性的值是<strong>引用类型值</strong>时,这个值会被所有实例共享。当实例修改这个属性值时，其它实例身上对应的这个属性值也被改变了</li><li>这也是为什么<strong>属性通常会在构造函数中定义</strong>，而不会定义在原型上的原因</li><li>原型链实现继承，子类的原型实际上变成父类的实例，则就意味<strong>父类实例身上的属性变成了子类原型属性</strong>；</li><li><strong>所有子类的实例都能访问这个属性或修改属性值</strong>,一旦子类的实例修改引用类型的属性值，那么其它实例身上对应的这个属性值也被改变了<blockquote><p>引用数据类型赋值时赋的是地址，基本数据类型赋的是值，不会被影响</p></blockquote></li></ul></blockquote></li></ol><pre><code>// 超类 （父类）function SuperType() &#123;  this.colors = [&quot;red&quot;, &quot;blue&quot;, &quot;yellow&quot;];  this.a = 2;&#125;// 子类function subType() &#123;&#125;&gt;subType.prototype = new SuperType();var sub1 = new subType();var sub2 = new subType();&gt;sub1.a = 4; // 修改值，相当于重写属性（遮蔽效应）console.log(sub1.a); // 4console.log(sub2.a); // 2&gt;sub1.colors.push(&quot;green&quot;); // 修改数组中值console.log(sub1.colors); //  [&#39;red&#39;, &#39;blue&#39;, &#39;yellow&#39;, &#39;green&#39;]console.log(sub2.colors); // [&#39;red&#39;, &#39;blue&#39;, &#39;yellow&#39;, &#39;green&#39;]</code></pre><img src="通过原型链继承的缺点1.png"><ol start="7"><li>原型链实现继承的不足之二<blockquote><p>子类在实例化时，不能给父类的构造函数传参。 也就意味着，子类不能应用父类已有的属性，而需要自己重写一份</p></blockquote></li></ol><pre><code>// 父类  人类function People(name, age, sex) &#123;  this.name = name;  this.age = age;  this.sex = sex;&#125;&gt;// 子类  学生类function Student(name, age, sex, scholl, sid) &#123;  this.name = name;  this.age = age;  this.sex = sex;&#125;&gt;// 实现继承   一定要先实现继承，再添加新的方法和属性Student.prototype = new People();&gt;// 创建子类实例var cuihua = new Student(&quot;翠花&quot;, 18, &quot;女&quot;, &quot;雅礼中学&quot;, 20800);//</code></pre><h3 id="借用构造函数（经典继承）"><a href="#借用构造函数（经典继承）" class="headerlink" title="借用构造函数（经典继承）"></a>借用构造函数（经典继承）</h3><blockquote><ul><li>为了解决<strong>子类原型中包含引用类型值</strong>所带来问题和<strong>在子类构造函数中不能给父类构造函数传参</strong>的问题</li><li>开发人员通常使用一种叫做 “<strong>借用构造函数”</strong> 的技术，也被称为 “伪造对象” 或 “经典继承”</li></ul></blockquote><ol><li>借用构造函数的基本思路<blockquote><ul><li>在子类构造函数内部调用父类的构造函数</li><li>但要注意使用<code>call</code>或<code>apply</code>方法将新创建的对象作为父类构造函数的上下文对象</li><li>子类可以继承父类构造函数中的所有属性并传参</li></ul></blockquote></li></ol><pre><code> function People(name, sex, age) &#123;   this.name = name;   this.sex = sex;   this.age = age;   this.arr = [1, 2, 3]; &#125;&gt; function Student(name, sex, age, school, sid) &#123;   // 借用构造函数   People.call(this, name, sex, age);   this.school = school;   this.sid = sid; &#125;&gt; var cuihua = new Student(&quot;翠花&quot;, &quot;女&quot;, 18, &quot;雅礼中学&quot;, 20230106); cuihua.arr.push(&quot;abc&quot;); //子类的实例拥有了父类身上所有方法 console.log(cuihua.name); //翠花 console.log(cuihua.arr); // [1, 2, 3, &#39;abc&#39;]</code></pre><ol start="2"><li>借用构造函数实现继承的不足之处<blockquote><ul><li>如果采用借用构造函数的方式实现继承，是<strong>没有办法把父类原型上的方法继承过来</strong>，只能继承父类构造函数中的属性</li><li>如果要把父类上的方法继承过来，那父类的方法就必需定义在构造函数内部，之显然是<strong>不合理</strong>的</li></ul></blockquote></li></ol><h3 id="四、组合继承"><a href="#四、组合继承" class="headerlink" title="四、组合继承"></a>四、组合继承</h3><blockquote><ul><li>将原型链实现继承和借用构造函数实现继承的技术组合到一起，这样就可以将两者的优点集中起来</li><li>这种继承方式，叫做 “组合继承” ，也叫作”伪经典继承”</li></ul></blockquote><ol><li>组合继承的基本思路<blockquote><ul><li>使用<strong>原型链</strong>继承来实现继承父类原型上的属性和方法<ul><li>弥补了借用构造函数不能继承父类原型上方法的缺陷</li></ul></li><li><strong>借用构造函数</strong>来实现继承父类实例的所有属性(可传参)<ul><li>弥补了原型链继承，父类原型上值为引用类型的属性，不能相互独立的缺陷</li><li>从父类继承的属性，是通过改变this指向给父类得到的；区别于原型链继承时，所有属性和方法都是放在子类的原型里的方式；因此，子类的这些属性相互独立，即使是引用数据类型也不是同一地址；<blockquote><p>这样就可以把父类的方法定义在子类的原型上，实现重用。同时又可以让每个实例都有自己的属性。</p></blockquote></li></ul></li></ul></blockquote></li></ol><pre><code> // 父类  人类 function People(name, age, sex) &#123;   this.name = name;   this.age = age;   this.sex = sex;   this.a = [1, 2, 3]; &#125; People.prototype.sayHello = function () &#123;   console.log(     &quot;我是&quot; + this.name + &quot;今年&quot; + this.age + &quot;岁，我是&quot; + this.sex + &quot;生&quot;   ); &#125;;&gt; // 子类  学生类 function Student(name, age, sex, scholl, sid) &#123;   // 借用构造函数 继承父类构造函数中的属性   People.call(this, name, age, sex);   this.scholl = scholl;   this.sid = sid; &#125;&gt; // 借用原型链 继承来实现继承父类原型上的属性和方法 Student.prototype = new People();&gt; Student.prototype.study = function () &#123;   console.log(this.name + &quot;正在学习！&quot;); &#125;;&gt; // 创建子类实例 var cuihua = new Student(&quot;翠花&quot;, 18, &quot;女&quot;, &quot;雅礼中学&quot;, 20800); //传参 var xiaoming = new Student(&quot;小明&quot;, 16, &quot;男&quot;, &quot;雅礼中学&quot;, 20990); //传参 cuihua.sayHello(); cuihua.study(); console.log(cuihua.a === xiaoming.a); //false console.log(cuihua.a); //[1, 2, 3] cuihua.a.push(12); console.log(cuihua.a); //[1, 2, 3,12] console.log(xiaoming.a); //[1, 2, 3]不会受到影响</code></pre><ol start="2"><li>组合继承的不足之处<blockquote><p>组合继承最大的问题就是无论什么情况下，都会调用<strong>两次父（超）类的构造函数</strong></p><ul><li>一次是在创建子类原型的时候，如</li></ul></blockquote></li></ol><pre><code>Student.prototype = new People(); // 调用父类构造函数</code></pre><blockquote><ul><li>另一次是在子类构造函数的内部，如</li></ul></blockquote><pre><code>People.call(this, name, age, sex); // 调用父类的构造函数</code></pre><blockquote><p>子类原型中的<code>constructor</code>被丢失，当访问子类原型中的 <code>constructor</code> 时，其本质是通过原型链查找，最终查找到的是父类的构造函数</p></blockquote><pre><code>Student.prototype.constructor === People; // true</code></pre><blockquote><blockquote><p>关于组合继承的不足之处如何解决，我们在后面会讲到</p></blockquote></blockquote><h3 id="五、原型式继承"><a href="#五、原型式继承" class="headerlink" title="五、原型式继承"></a>五、原型式继承</h3><blockquote><p><strong>重点强调</strong>：原型式继承是一种不涉及严格意义上构造函数的继承方法</p></blockquote><ol><li>原型式继承适用场景<blockquote><ul><li>如果你有一个对象，想在它的基础上再创建一个新对象</li><li>现有对象<code>obj1</code>，现在希望再创建一个<code>obj2</code>对象，<code>obj2</code>需要继承<code>obj1</code>实例身上的所有方法和属性</li></ul></blockquote></li></ol><pre><code>var obj1 = &#123;  a: 1,  b: [&quot;A&quot;, &quot;B&quot;, &quot;C&quot;],  sum: function () &#123;    console.log(this.a + this.b);  &#125;,&#125;;</code></pre><blockquote><ul><li><code>obj2</code>要能继承<code>obj1</code>身上的所有方法和属性，则<code>obj2.__proto__</code>属性需要指向<code>obj1</code></li><li>我们知道<code>obj2.__proto__</code>指向的是<code>obj2</code>的构造函数的<code>prototype</code>，则说明<code>obj2</code>肯定是要用构造函数构造出来。</li><li>因此<code>obj2</code>的构造函数的<code>prototype=obj1</code></li></ul></blockquote><pre><code>function Fn() &#123;&#125;Fn.prototype = obj1;var obj2 = new Fn();</code></pre><img src="原型式继承方法1.png"><blockquote><ul><li>我们可以把上面的代码封装成一个函数，这个函数接受一个参数（原型指向的对象）</li><li>当我们调用这个函数时，就会创建出一个新的对象，同时这个对象的原型指向函数的参数。</li></ul></blockquote><pre><code>function createObject(o) &#123;  function Fn() &#123;&#125;  Fn.prototype = o;  return new Fn();&#125;</code></pre><ul><li>另一个版本(了解即可)</li></ul><pre><code>var obj1 = &#123;  a: 1,  b: [&quot;A&quot;, &quot;B&quot;, &quot;C&quot;],  sum: function () &#123;    console.log(this.a + this.b);  &#125;,&#125;;&gt;var obj2=new Object();obj2.__proto__=obj1;</code></pre><img src="原型式继承方法2.png"><blockquote><p><strong>区别：</strong></p><ul><li>方法2：把原本的<code>obj2.__proto__=Object.prototype</code>这条线切断，这样就用不了<code>Object</code>原型里的方法；但是！又通过<code>obj1.__proto__=Object.prototype</code>接上了；因为<code>obj1</code>是一个对象，它肯定是由<code>Object</code>构造出来的</li><li>然而，方法1就没这么复杂，更加节省性能，直接可以通过原型链调用<code>Object</code>的方法；所以，更推荐使用方法1</li></ul></blockquote><ol start="2"><li>原型式继承：完整版代码</li></ol><pre><code>var obj1 = &#123;  a: 1,  b: [&quot;A&quot;, &quot;B&quot;, &quot;C&quot;],  sum: function () &#123;    console.log(this.a);    console.log(this.b);  &#125;,&#125;;&gt;function createObject(o) &#123;  function Fn() &#123;&#125;  Fn.prototype = o;  return new Fn();&#125;&gt;var obj2 = createObject(obj1); // 以obj1为原型，创建一个新对象var obj3 = createObject(obj1);obj2.c = 3; // 新对象添加自已的属性obj2.a = 4; // 重写原型上属性 aconsole.log(obj2); // &#123;c: 3, a: 4&#125;obj2.b.push(&quot;obj2新加&quot;);obj2.sum(); // 4  [&#39;A&#39;, &#39;B&#39;, &#39;C&#39;, &#39;obj2新加&#39;]obj1.sum(); // 1 [&#39;A&#39;, &#39;B&#39;, &#39;C&#39;, &#39;obj2新加&#39;]</code></pre><blockquote><p>注意事项</p><ul><li>以上方法创建出来的多个对象会<strong>共享原型上的引用类型属性</strong></li><li>其中一个对象修改了这个引用类型中的值，相当于所有创建出来的对象上的这个属性值都改变了</li></ul></blockquote><ol start="3"><li>Object.create 方法<blockquote><ul><li><code>ECMAScript5</code> 增加了<code>Object.create()</code>方法将原型式继承的概念规范化了</li><li><code>Object.create()</code>方法用于创建一个新对象，使用现有的对象来作为新创建对象的原型（prototype）<br>语法</li></ul></blockquote></li></ol><pre><code>Object.create(proto[,propertiesObject]);</code></pre><blockquote><ul><li><code>proto</code>为新创建对象的原型对象</li><li><code>propertiesObject</code>可选参数，给新对象定义额外属性的对象。 他与<code>Object.defineProperties()</code>的第二个参数一样，每个新增属性都通过各自的<strong>描述符</strong>来描述。以这种方式添加的属性会<strong>遮蔽</strong>原型对象上的同名属性<blockquote><p>只传入第一个参数时，该方法的底层逻辑就是前面的方法1</p></blockquote></li></ul></blockquote><pre><code>var obj1 = &#123;  a: 1,  b: [&quot;A&quot;, &quot;B&quot;, &quot;C&quot;],  sum: function () &#123;    console.log(this.a);    console.log(this.b);  &#125;,&#125;;&gt;var obj2 = Object.create(obj1);console.log(obj2.a); // 1var obj3 = Object.create(obj1, &#123;  b: &#123;    value: 4,  &#125;,&#125;);console.log(obj3); // &#123;b:4&#125;console.log(obj3.b); // 4</code></pre><ul><li>注意事项<blockquote><ul><li><code>Object.create(proto)</code>中的<code>proto</code>，只能是 <code>null</code>或对象类型，否则会抛出<code>TypeError</code>异常</li></ul></blockquote></li></ul><pre><code>Object.create(1); // 报错Object.create(new Object(1)); //不报错，但用不了继承的方法Object.create(undefined); // 报错Object.create(function () &#123;&#125;); // 不报错</code></pre><blockquote><ul><li><code>Object.defineProperties(newObj,propertiesObject)</code>中的第二个参数，不能是<code>null</code>和<code>undefined</code>，字符串，否则会报错。实际上只要这里传的不是一个对象，就没有意义</li></ul></blockquote><pre><code>var obj = &#123;&#125;;Object.defineProperties(obj, null); // 报错Object.defineProperties(obj, undefined); // 报错</code></pre><ol start="4"><li>手写 Object.create 方法（经典面试题）<blockquote><ul><li>面试中经常会要求我们手写<code>Object.create</code>方法</li><li>当<code>Object.create()</code>只有一个参数时，其作用与上面我们自已封装的<code>createObject()</code>方法1效果一样</li><li>所以我们只需要在方法1的基础上来<strong>完善第二个参数的相关功能</strong>，并限制第一个参数的传入类型<br><strong>完善的功能：</strong></li><li>判断传入的<code>proto</code>是否为对象或<code>null</code><ul><li>只能是<code>null</code>或对象类型，否则会抛出<code>TypeError</code>异常</li></ul></li><li>利用<code>Ojbect.defineProperties(newObj,propertiesObject)</code>来实现第二个参数功能</li><li>同时要判断<code>propertiesObject</code>是否是一个对象</li></ul></blockquote></li></ol><pre><code>Object._create = function (proto, propertiesObject) &#123;  // proto只能是null 或 对象  if (proto !== null &amp;&amp; !(proto instanceof Object))    throw new TypeError(&quot;proto只能是null或者对象,不能是其它类型&quot;);&gt;  // 实现原型式继承  function Fn() &#123;&#125;  Fn.prototype = proto;  var obj = new Fn();&gt;  // 给新对象添加属性，只要当前属性不是对象，就没有意义  propertiesObject instanceof Object &amp;&amp;    Object.defineProperties(obj, propertiesObject);&gt;  return obj;&#125;;</code></pre><ol start="5"><li>原型式继承注意事项<blockquote><ul><li><strong>适用场景</strong>：原型式继承非常适合不需要单独创建构造函数，但仍然需要在对象间共享信息的场合</li><li><strong>注意事项</strong>：如果原型对象的属性包含引用类型值时，所有以这个对象为原型创建的新对象的这个属性指向的是堆内中的同一个内容</li></ul></blockquote></li></ol><h3 id="六、寄生式继承"><a href="#六、寄生式继承" class="headerlink" title="六、寄生式继承"></a>六、寄生式继承</h3><blockquote><p><strong>寄生式继承的实现思路</strong>： 编写一个函数，它接收一个参数 O，返回以 O 为原型的新对象 p，同时给 p 添加了一些预置的新方法</p><ul><li>新对象相当于是寄生在原来的对象上，然后又添加了一些自己的新方法，所以称为 “寄生式继承”</li><li>在函数内，用<code>Object.create()</code>方法，创建出以 参数O 为原型的新对象p；并在函数p给内添加新方法，最后返回新对象p</li></ul></blockquote><pre><code>// 创建一个对象var ball = &#123;  color: &quot;red&quot;,  r: 20,  opacity: 1,&#125;;&gt;// 创建一个函数，实现增强某个对象，实现寄生式继承function enHanceObject(o) &#123;  // 以o为原型，创建出一个新对象  var obj = Object.create(o);  // 为新创建的对象添加一些预置的方法，用来增强对象  obj.changeColor = function () &#123;    this.color = &quot;blue&quot;;    console.log(&quot;我已经将颜色变成&quot; + this.color);  &#125;;  // ....可以为新对象添加更多的预置方法  return obj;&#125;&gt;var ball2 = enHanceObject(ball);console.log(ball2);console.log(ball2.r); //20ball2.changeColor(); //我已经将颜色变成blueconsole.log(ball.color); //red</code></pre><blockquote><blockquote><p>注：</p></blockquote><ul><li><strong>寄生式继承</strong>相当于一个小工厂，他接受一个参数，然后返回一个新的对象</li><li>寄生式继承<strong>适用场景</strong>：主要关注的是对象，而不在乎类型和构造函数的场景</li><li>注意事项： 寄生式继承给新对象添加的函数是没有办法实现重用的。每创建一个新对象身上都会独有一份预置的方法,相互独立</li></ul></blockquote><h3 id="七、寄生式组合继承"><a href="#七、寄生式组合继承" class="headerlink" title="七、寄生式组合继承"></a>七、寄生式组合继承</h3><blockquote><p>在前面学习的组合继承中也存在以下不足之处</p></blockquote><ol><li>组合继承不足之处<blockquote><ul><li>组合继承最大的问题就是无论什么情况下，都会<strong>调用两次父（超）类的构造函数</strong>。一次是在创建子类原型的时候 ，另一次是在子类构造函数的内部</li></ul></blockquote></li></ol><pre><code>Student.prototype = new People(); // 创建子类原型时，调用父类构造函数People.call(this, name, age, sex); // 在子类的构造函数内部，调用父类的构造函数</code></pre><blockquote><ul><li>子类原型中的constructor被丢失，当访问子类原型中的 constructor 时，其本质是通过原型链查找，最终查找到的是父类的构造函数</li></ul></blockquote><pre><code>Student.prototype.constructor === People; // true</code></pre><blockquote><p>在接下来学习的寄生式组合继承中，就能解决上面的两大问题</p></blockquote><ol start="2"><li>寄生式组合的基本思路<blockquote><ul><li><strong>借用构造函数实现继承父类属性</strong>： 在子类的构造函数中调用父类的构造函数来实现继承父类属性<ul><li><code>People.call(this, name, age);</code></li></ul></li><li><strong>原型链混合原型式继承，实现继承父类原型上方法</strong>：<code>Object.create()</code>以父类的原型对象为原型，来创建出一个新的对象。并让子类的原型指向新创建出来的对象。解决了不用再次调用父类构造函数，同时父类构造函数中的属性也不会成为原型的属性<ul><li><code>var prototype = Object.create(People.prototype);</code></li><li><code>Student.prototype = prototype;</code></li></ul></li><li><strong>修正子类构造函数的 constructor 属性的指向</strong>： 把新创建对象中的<code>constructor</code>指向子类的构造函数。解决了原型中<code>constructor</code>丢失问题，同是修正了子类构造函数中的<code>constructor</code>指向子类构造函数<ul><li><code>prototype.constructor = Student;</code></li></ul></li></ul></blockquote></li></ol><img src="寄生式组合继承.png"><blockquote><ul><li>寄生式组合继承是如何实现完美继承的<img src="寄生式组合继承的完美性.png"></li></ul></blockquote><pre><code>// 父类  人类function People(name, age) &#123;  this.name = name;  this.age = age;&#125;&gt;People.prototype.sayHello = function () &#123;  console.log(&quot;大家好，我是&quot; + this.name + &quot;今年&quot; + this.age + &quot;岁了&quot;);&#125;;&gt;// 子类  学生类function Student(name, age, scholl, sid) &#123;  People.call(this, name, age);  this.scholl = scholl;  this.sid = sid;&#125;&gt;// 寄生式组合继承// 以 People的原型为原型，创建一个新对象var prototype = Object.create(People.prototype);// 更改prototype中的constructor指向prototype.constructor = Student;// 将新创建的prototype对象，赋值给Student.prototypeStudent.prototype = prototype;&gt;// 子类原型上对象上添加新方法Student.prototype.exam = function () &#123;  console.log(this.name + &quot;正在考试&quot;);&#125;;&gt;var cuihua = new Student(&quot;翠花&quot;, 13, &quot;高新中学&quot;, &quot;A0001&quot;);var laoliu = new Student(&quot;老刘&quot;, 20, &quot;北京大学&quot;, &quot;SD0001&quot;);console.log(cuihua);cuihua.sayHello();cuihua.exam();console.log(laoliu);laoliu.sayHello();laoliu.exam();</code></pre><blockquote><blockquote><p>温馨提示：</p></blockquote><ul><li>继承的代码要写在给子类原型添加新方法的前面，否则子类在原型上新添加的方法会被覆盖</li></ul></blockquote><ol start="3"><li>封装函数 - 寄生式组合继承</li></ol><pre><code>&gt;/**&gt; * 寄生式组合继承&gt; * subType子类&gt; * superType 超类（父类）&gt; */function inheritPrototype(subType, superType) &#123;  // 以父类的原型为原型，创建一个新对象  var prototype = Object.create(superType.prototype);  // 新对象的constructor指向子类的构造函数  prototype.constructor = subType;  // 子类的原型指向新创建的对象  subType.prototype = prototype;&#125;</code></pre><ul><li>使用</li></ul><pre><code>// 父类  人类function People(name, age) &#123;  this.name = name;  this.age = age;&#125;&gt;People.prototype.sayHello = function () &#123;  console.log(&quot;大家好，我是&quot; + this.name + &quot;今年&quot; + this.age + &quot;岁了&quot;);&#125;;&gt;// 子类  学生类function Student(name, age, scholl, sid) &#123;  People.call(this, name, age);  this.scholl = scholl;  this.sid = sid;&#125;&gt;// 寄生式组合继承inheritPrototype(Student, People);&gt;// 子类原型上对象上添加新方法Student.prototype.exam = function () &#123;  console.log(this.name + &quot;正在考试&quot;);&#125;;&gt;var cuihua = new Student(&quot;翠花&quot;, 13, &quot;高新中学&quot;, &quot;A0001&quot;);var laoliu = new Student(&quot;老刘&quot;, 20, &quot;北京大学&quot;, &quot;SD0001&quot;);console.log(cuihua);cuihua.sayHello();cuihua.exam();console.log(laoliu);laoliu.sayHello();laoliu.exam();</code></pre><h3 id="八、JavaScript-6-种继承方式的实现原理、优缺点总结"><a href="#八、JavaScript-6-种继承方式的实现原理、优缺点总结" class="headerlink" title="八、JavaScript 6 种继承方式的实现原理、优缺点总结"></a>八、JavaScript 6 种继承方式的实现原理、优缺点总结</h3><table><thead><tr><th>继承方式</th><th>代码</th><th>实现原理</th><th>继承的对象</th><th>优缺点</th></tr></thead><tbody><tr><td>原型链实现继承</td><td><code>子类.prototype=new 父类()</code></td><td>子类的原型指向父类的实例</td><td>类与类</td><td>缺点：1.子类原型中的<code>constructor</code>被丢失；2.父类的属性中有引用类型，则所有子类的实例共享这个属性值；3.不能实现属性的复用，因为子类在实例化时，不能给父类的构造函数传参</td></tr><tr><td>借用构造函数</td><td><code>父类.call(this,参数)</code></td><td>子类构造函数内部调用父类构造函数，将<code>this</code>指向变为新创建的对象，并传参</td><td>类与类</td><td>优点：解决了原型链继承中<strong>引用类型共享</strong>和<strong>属性复用</strong>的问题；缺点：不能实现方法的继承</td></tr><tr><td>组合式继承</td><td><code>子类.prototype=new 父类()</code>+<code>父类.call(this,参数)</code></td><td>将原型链实现继承和借用构造函数实现继承组合一起使用</td><td>类与类</td><td>优点：既解决了原型链继承中<strong>引用类型共享</strong>和<strong>属性复用</strong>的问题，又能<strong>继承父类原型上的方法</strong>；缺点：1.两次调用父类的构造函数，也因此造成子类原型上多了一份无用的属性;2.子类原型中的<code>constructor</code>被丢失；</td></tr><tr><td>原型式继承</td><td><code>var newObj=Object.create(obj，propertiesObject)</code></td><td>实现以<code>obj</code>对象为原型，创建出一个新的对象<code>newObj</code>,同时可以给新创建的对象添加新的属性<code>propertiesObject</code></td><td>对象与对象</td><td>缺点：如果原型对象上有引用数据类型，则所有新创建的对象共享同一个属性值</td></tr><tr><td>寄生式继承</td><td><code>function enHanceObject(o) &#123; var obj = Object.create(o);//为新创建的对象添加一些预置的方法，用来增强对象obj.changeColor = function () &#123;&#125;; return obj;&#125;</code></td><td>以 obj 为原型，创建出一个新的对象，同时为新创建的对象添加一个预置的方法</td><td>对象与对象</td><td>缺点：给新对象添加的函数是没有办法实现重用的</td></tr><tr><td>寄生式组合继承</td><td><code>function inheritPrototype(subType, superType) &#123; var prototype = Object.create(superType.prototype); prototype.constructor = subType; subType.prototype = prototype;&#125;</code> 子类构造函数添加：<code>People.call(this, name, age);</code></td><td>将原型链继承、借用构造函数、原型式继承组合在一起来使用；以父类的原型为原型创建出一个新对象，同时将新对象的 <code>constructor</code>指向子类，再将新对象作为子类的原型。</td><td>类与类</td><td>完美解决类与类之间的继承</td></tr></tbody></table><img src="各类继承方式的优缺点.png"><h3 id="九、内置构造函数"><a href="#九、内置构造函数" class="headerlink" title="九、内置构造函数"></a>九、内置构造函数</h3><blockquote><p>在学习内置构造函数前，我们先来了解下 JS 中对象的分类，JS 对象分为以下 3 大类</p><table><thead><tr><th>类别</th><th>描述</th></tr></thead><tbody><tr><td>内部对象</td><td>JS 中的内部对象很多包括但不限于以下：<strong>常用构造函数（对象）</strong>：Object、Function、Array；<strong>包装类（对象）</strong>：String、Boolean、Number；<strong>Date 日期类、RegExp 正则表达式</strong>；<strong>错误处理类</strong>：Error、EvalError、RangeError、ReferenceError、SyntaxError、TypeError、URIError；<strong>内置对象</strong>：Global、Math</td></tr><tr><td>宿主对象</td><td>宿主对象就是执行 JS 脚本的环境提供的对象；对于嵌入到网页中的 JS 来说，其宿主对象就是浏览器提供的对象，所以又称为浏览器对象。不同的浏览器提供的宿主对象可能不同，即使提供的对象相同，其实现方式也大相径庭！这会带来浏览器兼容问题，增加开发难度；浏览器对象有很多，所有的 BOM 和 DOM 都是宿主对象，如Window、Document，Element，Form，Image等等</td></tr><tr><td>自定义对象</td><td>就是开发人员自己定义的对象</td></tr></tbody></table></blockquote><blockquote><p>我们接下来要学习的内置构造函数，指的就是<strong>内部对象中的相关对象</strong></p><blockquote><p>内置构造函数非常有用，所有该类型的方法都是定义在它的内置构造函数的 <code>prototype</code> 上的，我们可以给这个对象添加新的方法，从而拓展某类型的功能。</p></blockquote><p><strong>内置构造函数</strong></p><ul><li>常用构造函数：Object、Function、Array</li><li>包装类：String、Boolean、Number</li><li>Date 日期类、RegExp 正则表达式</li><li>错误处理类：Error、EvalError、RangeError、ReferenceError、SyntaxError、TypeError、URIError</li><li>……还有更多，在后面慢慢介绍<br><strong>内置对象</strong></li><li>Global 对象，全局对象</li><li>Math 对象<blockquote><p>这两个对象在脚本程序初始化时被创建，不必实例化这两个对象。即不用 <code>new</code> 来调用</p></blockquote></li></ul></blockquote><ol><li>常用构造函数<blockquote><ul><li>关于 Array、Function、Object 三个构造函数，我们在之前就有接触过，特别是 Array 构造函数。</li><li>这三个构造函数身上有那些：静态属性、静态方法、实例属性、实例方法大家可以参考 MDN 官方文档来复习。<blockquote><p>接下来，我们来复习下这三个构造函数的继承关系和原型链</p></blockquote></li><li>任意函数的默认<code>prototype</code>原型都是一个<code>Object</code>的实例,因此所有函数都继承于<code>Object</code> </li><li>所有的类(构造函数)本身都是函数，都是由Function构造出来的<blockquote><p>特别注意：<code>Function.__proto__ === Function.prototype</code></p></blockquote></li></ul></blockquote></li></ol><img src="三个构造函数的继承关系和原型链.png"><ol start="2"><li>Object 构造函数<blockquote><ul><li><code>Object</code>构造函数用来构造对象，所有对象都是 <code>Object</code>的实例</li></ul></blockquote></li></ol><pre><code>&#123;&#125;.__proto__===Object.prototype; // true</code></pre><blockquote><ul><li><code>Object</code> 的原型也是一个对象，按理来说<code>Object.prototype.___proto__===Object.prototype</code>，但显然是不合理的。实际 <code>Object</code>原型的原型指向原型链的终点，即 <code>null</code></li></ul></blockquote><pre><code>Object.prototype.__proto__ === Object.prototype; // falseObject.prototype.__proto__ === null; // true;</code></pre><blockquote><ul><li><code>Object</code> 构造函数也是函数，所以 <code>Object</code> 也是 <code>Function</code> 构造函数的实例</li></ul></blockquote><pre><code>Object.__proto__ === Function.prototype; // true</code></pre><blockquote><ul><li>所以 Object 可以打点调用 Function 原型上的方法</li></ul></blockquote><pre><code>&quot;call&quot; in Object; // true&quot;bind&quot; in Object; // true&gt;Object.call(&#123; a: 1, b: 2 &#125;); // &#123;&#125;</code></pre><ol start="3"><li>Array 构造函数<blockquote><ul><li><code>Array</code>构造函数，用来构造数组，所有数组都是 <code>Array</code>的实例</li></ul></blockquote></li></ol><pre><code>[].__proto__ === Array.prototype; // true</code></pre><blockquote><ul><li><code>Array.prototype</code>是一个对象，所以<code>Array.prototype</code>也是 <code>Object</code> 的实例</li></ul></blockquote><pre><code>Array.prototype.__proto__ === Object.prototype;</code></pre><blockquote><ul><li><code>Object</code>原型的原型为原型链的终点,即<code>null</code></li></ul></blockquote><pre><code>Array.prototype.__proto__.__proto__ === null; // true</code></pre><blockquote><ul><li><code>Array</code> 构造函数也是函数，所以<code>Array</code> 也是 <code>Function</code> 构造函数的实例</li></ul></blockquote><pre><code>Array.__proto__ === Function.prototype; // true</code></pre><ol start="4"><li>Function 构造函数<blockquote><ul><li><code>Function</code>构造函数用来构造函数，所有函数都是 <code>Function</code>的实例</li></ul></blockquote></li></ol><pre><code>var fn = function () &#123;&#125;;fn.__proto__ === Function.prototype; // true</code></pre><blockquote><ul><li><code>Function</code>构造函数也是一个函数，所以下面这种特殊情况也成立</li></ul></blockquote><pre><code>Function.__proto__ === Function.prototype; // true</code></pre><h2 id="JS三大包装类-Number、String、Boolean"><a href="#JS三大包装类-Number、String、Boolean" class="headerlink" title="JS三大包装类 Number、String、Boolean"></a>JS三大包装类 Number、String、Boolean</h2><blockquote><ul><li>为了方便操作<strong>原始值</strong>，<code>ECMAScript</code> 提供了<code>Number</code>、<code>String</code>、<code>Boolean</code>这三个特殊的构造函数</li><li>他们的主要作用就是把基本数据类型<strong>包装</strong>成一个 <strong>“对象”</strong>版本的基本类型值，所以这三个类又称为<strong>包装类</strong></li></ul></blockquote><table><thead><tr><th>包装类</th><th>说明</th></tr></thead><tbody><tr><td>Number</td><td>将数字包装成一个数字对象</td></tr><tr><td>String</td><td>将字符串包装成一个字符对象</td></tr><tr><td>Boolean</td><td>将布尔值包装成一个布尔对象</td></tr></tbody></table><pre><code>// Number 类var n = new Number(3);console.log(n); // Number &#123;3&#125;console.log(typeof n); // objectconsole.log(n + 4); // 7&gt;// String 类var str = new String(&quot;abcd&quot;);console.log(str); // String &#123;&#39;abcd&#39;&#125;console.log(typeof str); // objectconsole.log(str + &quot;123&quot;); // abcd123&gt;// Boolean 类var b = new Boolean(true);console.log(b); // Boolean &#123;true&#125;console.log(typeof b);//objectconsole.log(true + 1); // 2</code></pre><h3 id="一、包装类核心基础"><a href="#一、包装类核心基础" class="headerlink" title="一、包装类核心基础"></a>一、包装类核心基础</h3><blockquote><ul><li>包装类的<strong>主要目的</strong>：是让基本类型值可以从它们的构造函数的 <code>prototype</code> 上获得方法。</li><li>每当用到某个原始值的方法或属性时，<strong>后台都会创建一个相应的原始包装类型的对象</strong>，从而暴露出操作原始值的各种方法</li></ul></blockquote><p><strong>我们来分析下，下面代码的执行流程</strong></p><pre><code>var str1 = &quot;我就是我，不一样的小花朵&quot;;var str2 = str1.charAt(2); // 是</code></pre><blockquote><ul><li>上面代码中<code>str1</code>是一个原始值，原始值不是一个对象，因此逻辑上不能调用方法。但实际上按预期输出了结果。为什么呢 ？</li><li>实际上代码执行到<code>str1.charAt(2)</code>时，JS 后台进行了很多处理<br><strong>具体处理步骤如下：</strong></li></ul></blockquote><pre><code>var str1 = &quot;我就是我，不一样的小花朵&quot;;var str2 = str1.charAt(2);//当执行到这句代码时，会先执行右边，再赋值 //在执行str1.charAt(2)时，JS内部会进行：var str = new String(str1); // 1、将str1包装成一个新String对象str.charAt(2)// 2、让新对象调用方法str2 = str.charAt(2); //3、将返回的结果赋值给到 str2str = null; // 4、销毁创建的实例</code></pre><ol><li>包装类的生命周期<blockquote><ul><li><code>new</code>关键字创建的原始值包装对象，只有<strong>在当前作用域被销毁时</strong>才销毁</li><li>自动创建的原始值包装对象，只存在于访问它的<strong>那一行代码执行期间</strong>。执行完就自动销毁</li></ul></blockquote></li></ol><pre><code>var str1 = &quot;我就是我，不一样的小花朵&quot;;str1.name = &quot;张三&quot;;console.log(str1.name); // undefinedconsole.log(typeof str1); // string&gt;var str2 = new String(&quot;我就是我&quot;);str2.name = &quot;清心&quot;;console.log(str2.name); // 清心console.log(typeof str2); // object</code></pre><blockquote><p><strong>分析 str1 变量</strong></p><ul><li>当代码执行到<code>str1.name=&quot;张三&quot;</code>时，<code>str1</code> 确实被包装成了<strong>对象</strong>，然后在对象上添加了 <code>name</code> 属性，<strong>但执行完，被包装成的对象就销毁了</strong></li><li>当执行到<code>console.log(str1.name)</code>时，<code>str1</code><strong>又创建了一个新的 <code>String</code> 对象</strong>，但是这个对象已经不是前面的那个对象，他身上没有 <code>name</code> 属性，访问对象身上不存在的属性不会报错，返回值为<code>undefined</code><br><strong>分析 str2 变量</strong></li><li>执行<code>var str2 = new String(&quot;我就是我&quot;);</code>时，相当于创建了一个包装对象，然后把这个包装对象赋值级到 <code>str2</code></li><li>当执行到<code>str2.name = &quot;清心&quot;;</code>时，相当于给对象添加 <code>name</code> 属性</li><li>当执行到<code>str2.name</code>时，相当于读到对象身上的属性，返回结果为清心</li></ul></blockquote><ol start="2"><li>原始值包装对象 - 转为布尔值都是 true<blockquote><p>直接调用 <code>Boolean</code> 函数，可以将其它类型转换为对应的 <code>boolean</code> 值</p><ul><li>基本数据类型的包装对象，转布尔值得到的都是<code>true</code></li></ul></blockquote></li></ol><pre><code>// 数字console.log(Boolean(0)); // falsevar n1 = new Number(0);console.log(Boolean(n1)); // trueconsole.log(n1); // Number &#123;0&#125;&gt;// 布尔值var flag = new Boolean(false);console.log(Boolean(false)); // falseconsole.log(Boolean(flag)); // trueconsole.log(flag); // Boolean &#123;false&#125;&gt;// 字符串var str = new String(&quot;&quot;);console.log(Boolean(&quot;&quot;));console.log(Boolean(str));console.log(str);</code></pre><ol start="3"><li>区分直接调用包装类与 new 调用<blockquote><ul><li><strong>直接调用</strong>包装类函数，主要目的是实现数据类型的转换</li><li>使用**<code>new</code>调用**包装类，是为了把基本数据类型转换为对象类型</li></ul></blockquote></li></ol><pre><code>var value = &quot;20&quot;;var number = Number(value);//字符串转数字类型console.log(number); // 20console.log(typeof number); // number&gt;var obj = new Number(value);console.log(obj); // Number &#123;20&#125;console.log(typeof obj); // object</code></pre><h3 id="二、Number-包装类"><a href="#二、Number-包装类" class="headerlink" title="二、Number 包装类"></a>二、Number 包装类</h3><blockquote><p>Number 类有很多方法和属性，我们这里挑出最常用的给大家讲解</p></blockquote><ul><li><p>以下是常见的<code>Number</code>的<strong>静态属性</strong>，只需要了解即可</p><table><thead><tr><th>静态属性</th><th>描述</th></tr></thead><tbody><tr><td>Number.MAX_SAFE_INTEGER</td><td>表示在 JavaScript 中最大的安全整数<code>2^53 - 1</code></td></tr><tr><td>Number.MIN_SAFE_INTEGER</td><td>代表在 JavaScript 中最小的安全整数 <code>-(2^53 - 1)</code></td></tr><tr><td>Number.MAX_VALUE</td><td>JavaScript 里所能表示的最大数值</td></tr><tr><td>大于 <code>MAX_VALUE</code> 的值代表 <code>&quot;Infinity&quot;</code></td><td></td></tr><tr><td>Number.MIN_VALUE</td><td>表示在 JavaScript 中所能表示的最小的正值；小于<code>MIN_VALUE (&quot;underflow values&quot;)</code>的值将会转换为 0</td></tr></tbody></table></li><li><p>以下是常用的<code>Number</code><strong>原型上的方法</strong>，之些方法我们之前都学习过，列出来用于复习<br>|实例方法（原型方法）|描述|<br>|toFixed|返回结果后的小数部分<strong>保留指定小数位数</strong>，返回结果为一个字符串；保留小数位时，会采用四舍五入；如果小数位不足，则用 0 来补充；如果参数为空，则表示不保留小数位|<br>|toString|<code>toString()</code>用来将数值类型转换为字符串类型；<code>toString()</code>可以接受一个参数，用来将数字转换成对应进制的字符串|<br>|valueOf|<code>valueOf</code>方法返回被<code>Number</code>对象包装的原始值|</p></li></ul><ol><li>Number.MAX_SAFE_INTEGER 属性<blockquote><ul><li>是一个值为 <code>9007199254740991</code> （即<code>2^53-1</code>）的常量。</li><li>表示在 <code>JavaScript</code> 中最大的安全整数<code>(maxinum safe integer)``（2^53 - 1）</code></li><li>所谓的安全，是指<strong>能够准确的区分两个不相同的值</strong></li></ul></blockquote></li></ol><pre><code>var n = Math.pow(2, 53) - 1;console.log(n); // 9007199254740991console.log(Number.MAX_SAFE_INTEGER); // 9007199254740991&gt;// 安全系数  以下得到结果为true，显然是不合理的console.log(Number.MAX_SAFE_INTEGER + 1 === Number.MAX_SAFE_INTEGER + 2); // true</code></pre><blockquote><blockquote><p><code>Math.pow(base,exponent)</code>函数返回基数（base）的指数（exponent）次幂</p></blockquote></blockquote><ol start="2"><li>Number.MIN_SAFE_INTEGER 属性<blockquote><ul><li>是一个值为<code>-9007199254740991</code>的常量，即<code>-(2^53 -1)</code></li><li>表示在在 <code>JavaScript</code> 中最小的安全整数<code>-(2^53 - 1)</code></li><li>所谓的安全，是指能够准确的区分两个不相同的值</li></ul></blockquote></li></ol><pre><code>var n = -(Math.pow(2, 53) - 1);console.log(n); // -9007199254740991console.log(Number.MIN_SAFE_INTEGER); // -9007199254740991&gt;//安全系数  以下得到结果为true，显然是不合理的console.log(Number.MIN_SAFE_INTEGER - 1 === Number.MIN_SAFE_INTEGER - 2); // true</code></pre><p>3、<code>Number.MAX_VALUE</code>与<code>Number.MIN_VALUE</code>属性</p><blockquote><ul><li><code>Number.MAX_VALUE</code>表示<code>JavaScript</code>里所能表示的<strong>最大数值</strong></li><li><code>Number.MIN_VALUE</code>表示在<code>JavaScript</code>中所能表示的<strong>最小的数值</strong></li></ul></blockquote><pre><code>console.log(Number.MAX_VALUE); // 1.7976931348623157e+308console.log(Number.MIN_VALUE); // 5e-324</code></pre><ol start="4"><li>toFixed 方法<blockquote><ul><li>返回结果后的小数部分<strong>保留指定小数位数</strong>，返回结果为一个<strong>字符串</strong></li><li>如果参数为空，则表示不保留小数位</li><li>保留小数位时，会采用四舍五入</li><li>如果小数位不足，则用 0 来补充</li></ul></blockquote></li></ol><pre><code>var n = 1.447;console.log(n.toFixed()); // 1console.log(n.toFixed(1)); // 1.4console.log(n.toFixed(2)); // 1.45console.log(n.toFixed(5)); // 1.44700console.log(typeof n.toFixed()); // string</code></pre><ol start="5"><li>toString 方法<blockquote><ul><li><code>Number</code>类<strong>重写了</strong>原型上继承于<code>Object</code>对象的<code>toString</code>方法</li><li><code>toString()</code>用来将数值类型转换为字符串类型</li><li><code>toString()</code>可以接受一个参数，用来将数字转换成对应进制的字符串</li></ul></blockquote></li></ol><pre><code>var n = 16;console.log(n.toString()); // 16console.log(typeof n.toString()); // stringconsole.log(n.toString(2)); // 10000console.log(n.toString(8)); // 20console.log(n.toString(10)); // 16console.log(n.toString(16)); // 10</code></pre><ol start="6"><li>valueOf 方法<blockquote><ul><li><code>Number</code>类重写了原型上的<code>valueOf</code>方法</li><li><code>valueOf</code>方法返回被<code>Number</code>对象包装的原始值</li><li>该方法通常是由<code>JavaScript</code>引擎在内部隐式调用的，而不是由用户在代码中显式调用的</li></ul></blockquote></li></ol><pre><code>var n = 16;var obj = new Number(n);console.log(obj); // Number &#123;16&#125;console.log(obj.valueOf()); // 16console.log(obj + 3); // 19 内部自动调用了valueOf方法</code></pre><h3 id="三、Boolean-包装类"><a href="#三、Boolean-包装类" class="headerlink" title="三、Boolean 包装类"></a>三、Boolean 包装类</h3><blockquote><p>以下是<code>Boolean</code>包装类原型上的方法</p></blockquote><table><thead><tr><th>实例方法（原型方法）</th><th>描述</th></tr></thead><tbody><tr><td>toString</td><td>方法返回表示指定的布尔对象的字符串</td></tr><tr><td>valueOf</td><td>返回一个原始值true或false</td></tr></tbody></table><ol><li>toString 方法<blockquote><ul><li><code>Boolean</code>类<strong>重写了</strong>原型上继承于<code>Object</code>对象的<code>toString</code>方法</li><li>方法返回表示指定的布尔对象的字符串</li><li>当一个<code>Boolean</code>对象作为文本值或进行字符串连接时，<code>JavaScript</code>会自动调用其<code>toString</code>方法</li></ul></blockquote></li></ol><pre><code>console.log(true.toString()); // &#39;true&#39;console.log(typeof true.toString()); // stringconsole.log(false.toString()); // &#39;false&#39;console.log(true + &quot;abc&quot;); // trueabc 内部自动调用了toString()方法</code></pre><ol start="2"><li>valueOf<blockquote><blockquote><p>返回原始值<code>true</code>或<code>false</code></p></blockquote></blockquote></li></ol><pre><code>var flag = new Boolean(&quot;12&quot;);console.log(flag); // Boolean &#123;true&#125;console.log(flag.valueOf()); // true&gt;var flag2 = new Boolean(0);console.log(flag2); // Boolean &#123;false&#125;console.log(flag2.valueOf()); // false</code></pre><blockquote><blockquote><p>建议永远不要使用 <code>new Boolean()</code> 来包装一个布尔值，这里只当做了解</p></blockquote></blockquote><h3 id="四、String-包装类"><a href="#四、String-包装类" class="headerlink" title="四、String 包装类"></a>四、String 包装类</h3><table><thead><tr><th>实例（原型）方法</th><th>描述</th></tr></thead><tbody><tr><td>charAt()</td><td>返回字符串中指下标的字符</td></tr><tr><td>concat()</td><td>将一个或多个字符串与原字符串连接合并，形成一个新的字符串并返回</td></tr><tr><td>indexOf</td><td>返回给定的字符串在整个字符串中第一次出现的索现</td></tr><tr><td>slice</td><td>方法提取某个字符串的一部分，并返回一个新的字符串，且不会改动原字符串。</td></tr><tr><td>substring</td><td>返回字符串中指定开始索引到结束索引之间的字符串，包含起始索引，不包含结束索引</td></tr><tr><td>trim</td><td>清除字符串两端的空格，返回一个新的字符串</td></tr><tr><td>trimEnd</td><td>方法会删除字符串末尾的空白字符。trimRight() 是这个方法的别名</td></tr><tr><td>trimStart</td><td>方法会删除字符串开头的空白字符。trimLeft() 是此方法的别名</td></tr><tr><td>toUpperCase()</td><td>将字符串中字母转换为大写</td></tr><tr><td>toLowerCase()</td><td>将字符串中字母转换为小写</td></tr><tr><td>valueOf</td><td>返回 String 对象的原始值</td></tr></tbody></table><blockquote><blockquote><p>这些字符串方法（split 、match、search、replace）涉及到正则表达式的应用，则放在正则表达式那一章节来学</p></blockquote></blockquote><ol><li>charAt<blockquote><ul><li>返回字符串中指定下标的字符</li></ul></blockquote></li></ol><pre><code>str.charAt(index);</code></pre><blockquote><ul><li><code>index</code>值介于<code>0 ~ 字符串长度-1</code>之间的整数,如果值超出这个范围，返回空字符串</li><li>如果没有传入参数，则默认返回下标为 0 的字符</li></ul></blockquote><pre><code>var str = &quot;我就是我，不一样的小花朵&quot;;console.log(str.charAt()); // 我console.log(str.charAt(str.length - 1)); // 朵console.log(str.charAt(str.length)); // 超出范围 返回空字符串console.log(str.charAt(-1)); // 超出范围 返回空字符串</code></pre><ol start="2"><li>concat<blockquote><ul><li>将一个或多个字符串与原字符串连接合并，形成一个新的字符串并返回。</li><li>如果传入的参数为非字符串，<strong>会先转换成字符串</strong>，然后再拼接</li><li>concat 方法，并不影响原字符串<blockquote><p>MDN上明确强调：出于性能考虑，强烈建议使用<code>+</code>或<code>+=</code>来代替<code>concat()</code>方法拼接字符串</p></blockquote></li></ul></blockquote></li></ol><pre><code>str.concat(str2, [, ...strN]); // [] 里面表示可选，即concat的中的参数 &gt;= 1个</code></pre><pre><code>var str = &quot;abc&quot;;console.log(str.concat(&quot;c&quot;)); // abccconsole.log(str.concat(&quot;c&quot;, 4, 5)); // abcc45console.log(str.concat([&quot;d&quot;, &quot;e&quot;, &quot;f&quot;])); // abcd,e,fconsole.log(str.concat(true)); // abctrueconsole.log(str.concat(null)); // abcnullconsole.log(str.concat([])); // abcconsole.log(str.concat(&#123;&#125;)); // abc[object Object]console.log(str.concat(&#123; a: 1, b: 2 &#125;)); // abc[object Object]</code></pre><blockquote><blockquote><ul><li>其他类型转字符串</li></ul></blockquote><ul><li><code>String(&#123;&#125;)</code>&#x3D;&#x3D;&#x3D;<code>&#39;[object Object]&#39;</code></li><li><code>String(&#123;a: 1, b: 2&#125;)</code>&#x3D;&#x3D;&#x3D;<code>&#39;[object Object]&#39;</code></li><li><code>String([&quot;d&quot;, &quot;e&quot;, &quot;f&quot;])</code>&#x3D;&#x3D;&#x3D;<code>&#39;d,e,f&#39;</code></li></ul></blockquote><ol start="3"><li>indexOf<blockquote><ul><li>返回指定字符串在大于或等于<code>position</code>位置的第一次出现的索引，如果没有找到则返回<code>-1</code></li><li><code>searchString</code>要搜索的子字符串</li><li><code>position</code>从指定位置开始往后查询</li></ul></blockquote></li></ol><pre><code>indexOf(searchString);indexOf(searchString, position);</code></pre><blockquote><ul><li>如果没有传第二个参数，则默认从 0 的位置开始查找</li><li>给定了第二个参数，会从当前位置开始往后查找，包括当前位置</li></ul></blockquote><pre><code>var str = &quot;hello world&quot;;console.log(str.indexOf(&quot;o&quot;)); // 4console.log(str.indexOf(&quot;o&quot;, 7)); // 7console.log(str.indexOf(&quot;o&quot;, 8)); // -1</code></pre><blockquote><ul><li>如果 <code>position</code> 大于字符串长度(空格也算)，则搜索不到对应字符串，返回结果为 <code>-1</code></li><li>如果 <code>position</code> 小于 <code>0</code>，则当成 <code>0</code> 来处理，从第<code>0</code>的位置往后查询<blockquote><p>唯一区别：数组中的<code>indexOf</code>方法,如果第二个数是负数，则表示从后往前找</p></blockquote></li></ul></blockquote><pre><code>var str = &quot;hello world&quot;;console.log(str.indexOf(&quot;o&quot;, 11)); // -1console.log(str.indexOf(&quot;o&quot;, -4)); // 4indexOf 查询内容时，是严格区分大小写的，数组中的 indexOf 方法也是一样的var str = &quot;hello world&quot;;console.log(str.indexOf(&quot;W&quot;)); // -1console.log(str.indexOf(&quot;w&quot;)); // 6</code></pre><blockquote><blockquote><p>空字符串搜索时会产生以下奇怪的结果，所以在查询时如果查询内容有可能为空，则需要提前判断</p></blockquote><ul><li><code>position</code>未传，返回<code>0</code></li><li><code>position</code>传了：<ul><li><code>position &lt; 字符串长度</code>，返回结果为 <code>position</code> 值</li><li><code>position &gt;= 字符串长度</code>，返回结果为字符串的长度</li></ul></li></ul></blockquote><ul><li><code>案例应用</code>： 统计某个字母或单词在字符串中出现的次数</li></ul><pre><code>String.prototype.count = function (searchString, position) &#123;  var n = 0; // 统计字符串出现的次数  if (position === undefined) position = 0; // 如果没有赋值，默认为0  if (typeof position !== &quot;number&quot;) &#123;    // 如果不是数字类型，则抛出错误    throw new TypeError(&quot;position只能是数字类型&quot;);  &#125;  // 从当前位置往后查找，并将查询的位置结果返回  position = this.indexOf(searchString, position);  while (position !== -1) &#123;    n++;    position = this.indexOf(searchString, position + 1);  &#125;  return n;&#125;;&gt;var str = &quot;on test my love on top bottom test&quot;;console.log(str.count(&quot;on&quot;));console.log(str.count(&quot;o&quot;, 2));console.log(str.count(&quot;test&quot;, -2));</code></pre><ol start="4"><li>slice<blockquote><ul><li>方法提取某个字符串的一部分，并返回一个新的字符串，且不会改动原字符串</li><li>其用法和数组的 slice 方法一样</li></ul></blockquote></li></ol><pre><code>str.slice(beginIndex[, endIndex])</code></pre><blockquote><ul><li><code>beginIndex</code>为查询的起始索引，默认为 <code>0</code></li><li><code>endIndex</code>为结束索引，可选参数，默认不写，表示从结束位置提取到整个字符串的尾部。</li><li>如果<code>beginIndex</code>和<code>endIndex</code>为负数，表示从后往前数，找到对应位置，再从开始位置向右查询到结束位置。</li><li>从后往前数，下标从<code>-1</code>开始，同时查询字符串包含 <code>beginIndex</code>，但不包换<code>endIndex</code></li></ul></blockquote><pre><code>var str = &quot;abcdefc&quot;;console.log(str.slice(2, 5)); // cdeconsole.log(str.slice(2, -2)); // cdeconsole.log(str.slice(-5, -2)); // cdeconsole.log(str.slice(-3)); // efc</code></pre><ol start="5"><li>substring<blockquote><ul><li>返回字符串中指定开始索引到结束索引之间的字符串，包含起始索引，不包含结束索引</li></ul></blockquote></li></ol><pre><code>str.substring(startIndex[,endIndex])</code></pre><blockquote><ul><li><code>startIndex</code>开始索引，如果小于 0 或为 <code>NaN</code>，则当成 0 处理，大于字符串长度，则当成字符串长度处理</li><li><code>endIndex</code> 结束索引，如果小于 0 或为 NaN，则当成 0 处理，大于字符串长度，则当成字符串长度处理</li><li>特殊之处：如果 <code>startIndex &gt; endIndex</code> ，则执行效果像两个参数调换一样</li></ul></blockquote><pre><code>var str = &quot;abcdefc&quot;;console.log(str.substring(2)); // cdefcconsole.log(str.substring(-2)); // abcdefcconsole.log(str.substring(5, 2)); //cdeconsole.log(str.substring(2, -3)); // abconsole.log(str.substring(2, 5)); //cdeconsole.log(str.substring(-2, -3)); //&quot;&quot;</code></pre><ol start="6"><li>trim、trimEnd、trimStart<blockquote><ul><li><code>trim</code>：清除字符串两端的空格，返回一个新的字符串</li><li><code>trimEnd</code>： 方法会删除字符串末尾的空白字符，<code>trimRight()</code> 是这个方法的别名</li><li><code>trimStart</code>：方法会删除字符串开头的空白字符,<code>trimLeft()</code> 是此方法的别名<blockquote><p>这里的空格是指：所有的空白字符（空格、tab、不换行空格等）以及所有行终止符字符（如 LF、CR 等）</p></blockquote></li></ul></blockquote></li></ol><pre><code>var str = &quot;   abc   &quot;;var newstr = str.trim();console.log(str.trim()); // &quot;abc&quot;console.log(str.trim().length); // 3&gt;console.log(str.trimStart()); // &quot;abc   &quot;console.log(str.trimStart().length); // 6&gt;console.log(str.trimEnd()); // &quot;   abc&quot;console.log(str.trimEnd().length); // 6</code></pre><ol start="7"><li>toUpperCase 与 toLowerCase<blockquote><ul><li>toLowerCase：将字符串中字母全部转换为小写</li><li>toUpperCase ： 将字符串中字母全部转换为大写</li></ul></blockquote></li></ol><pre><code>var str = &quot;I love You 是我爱你&quot;;console.log(str.toUpperCase());console.log(str.toLowerCase());以下方法可实现将 true、false 这些非字符串值转换全大写String.prototype.toUpperCase.call(true);String.prototype.toUpperCase.call(false);以下代码会抛出类型错误String.prototype.toUpperCase.call(null);String.prototype.toUpperCase.call(undefined);image-20221208004420970</code></pre><ol start="8"><li>valueOf<blockquote><ul><li><code>valueOf()</code>返回<code>String</code>对象的原始值</li></ul></blockquote></li></ol><pre><code>var obj = new String(&quot;wang&quot;);console.log(obj); // String &#123;&#39;wang&#39;&#125;console.log(obj.valueOf()); // wang&gt;// 字符串拼接时，会自动调用valueOf方法，获取原始值来拼接console.log(obj + &quot;abc&quot;);</code></pre><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><h4 id="三个特殊的构造函数的使用"><a href="#三个特殊的构造函数的使用" class="headerlink" title="三个特殊的构造函数的使用"></a>三个特殊的构造函数的使用</h4><blockquote><p><code>ECMAScript</code>提供了<code>Number</code>、<code>String</code>、<code>Boolean</code>这三个特殊的构造函数</p></blockquote><ol><li>当用<code>new</code>调用(作为一个构造函数使用)时<blockquote><ul><li>将基本数据类型包装成一个<strong>对象</strong>(又称为包装类)；</li><li>这个对象可以使用构造函数身上的属性，从构造函数的<code>prototype</code>上获得方法。</li></ul></blockquote></li></ol><ul><li>new Number()<blockquote><ul><li>创建一个 Number 对象,该对象不是一个原始值</li></ul></blockquote></li></ul><pre><code> var obj = new Number(42); console.log(obj); //Number &#123;42&#125; console.log(typeof obj); //object console.log(obj == 42); //true console.log(obj === 42); //false</code></pre><ul><li>new Boolean(参数)<blockquote><ul><li>如果省略该参数或参数值为 <code>0</code>、<code>-0</code>、<code>null</code>、<code>false</code>、<code>NaN</code>、<code>undefined</code>，或空字符串<code>（&quot;&quot;）</code>，则该<strong>对象</strong>具有的初始值为 false。</li><li>所有其他值，包括任何对象，空数组（[]）或字符串 “false”，都会创建一个初始值为 true 的<strong>对象</strong>。</li></ul></blockquote></li></ul><pre><code> var flag1 = new Boolean(&quot;&quot;); console.log(flag1); //Boolean &#123;false&#125; console.log(typeof flag1); //object&gt; var flag2 = new Boolean(&quot;123&quot;); console.log(flag2); //Boolean &#123;true&#125; console.log(typeof flag2); //object</code></pre><ul><li>new String()<blockquote><ul><li>创建字符串对象</li></ul></blockquote></li></ul><pre><code> var str = new String(&quot;a,b&quot;); console.log(str); //String &#123;&#39;a,b&#39;&#125; console.log(typeof str); //object</code></pre><ol><li>当作为一个函数使用时<blockquote><ul><li>主要目的是实现<strong>数据类型的转换</strong></li></ul></blockquote></li></ol><blockquote><p><strong>Number()函数：</strong></p><ul><li>基本数据类型：’’空字符串 、字符串只有前后包含空格、纯数字类字符串、2 进制或 16 进制表示的数字、科学记数表示法能转换成数字，其它都转换成 NaN</li><li>引用数据类型：<code>Number([])</code>结果是<code>0</code>，<code>Number(&#123;&#125;)</code>结果是<code>NaN</code></li></ul></blockquote><blockquote><p><strong>Boolean() 函数：</strong></p><ul><li>代表空，否定的值会被转换为<code>false</code>。 如：<code>&#39;&#39;</code>、<code>0</code>、<code>NaN</code>、<code>null</code>、<code>undefined</code></li><li>除了上面列出的 <code>5</code> 个值，其它所有值都转换为<code>true</code><blockquote><p>所有对象转布尔值都为<code>true</code>，因此<strong>原始值包装对象</strong>转为布尔值都是<code>true</code></p></blockquote></li></ul></blockquote><blockquote><p><strong>String()函数：</strong></p><ul><li>其它类型转换字符串</li></ul></blockquote><h4 id="三大包装类常用的属性和方法"><a href="#三大包装类常用的属性和方法" class="headerlink" title="三大包装类常用的属性和方法"></a>三大包装类常用的属性和方法</h4><blockquote><ul><li>Number类<img src="Number类的常用属性和方法.png"></li></ul></blockquote><blockquote><ul><li>Boolean类<img src="Boolean类的常用属性和方法.png"></li></ul></blockquote><blockquote><ul><li>String类<img src="String类的常用属性和方法.png"></li></ul></blockquote>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JS核心知识点（十四）</title>
      <link href="/2023/12/07/JS%E6%A0%B8%E5%BF%83%E7%9F%A5%E8%AF%86%E7%82%B9%EF%BC%88%E5%8D%81%E5%9B%9B%EF%BC%89/"/>
      <url>/2023/12/07/JS%E6%A0%B8%E5%BF%83%E7%9F%A5%E8%AF%86%E7%82%B9%EF%BC%88%E5%8D%81%E5%9B%9B%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<span id="more"></span><h3 id="一、Object-defineProperty"><a href="#一、Object-defineProperty" class="headerlink" title="一、Object.defineProperty"></a>一、Object.defineProperty</h3><blockquote><p><code>Object.defineProperty()</code>方法会直接在一个对象上定义一个新属性，或者修改一个对象的现有属性，<strong>并返回此对象</strong>。</p><ul><li><code>// 语法 Object.defineProperty(obj, prop, descriptor);</code></li><li>obj ：要定义属性的对象</li><li>prop ：要定义或修改的属性的名称</li><li>descriptor : 要定义或修改的<strong>属性描述符</strong>，是一个对象<blockquote><p>目前存在的属性描述符有两种主要形式：数据描述符 和 存取描述符</p></blockquote></li></ul></blockquote><h4 id="数据描述符"><a href="#数据描述符" class="headerlink" title="数据描述符"></a>数据描述符</h4><blockquote><ul><li>数据描述符是一个具有值的属性，该值可以是可写的，也可以是不可写的。</li><li>数据描述符有以下 4 个特性描述它们的行为，具体如下表</li></ul></blockquote><table><thead><tr><th>属性特性</th><th>说明</th><th>默认值</th></tr></thead><tbody><tr><td>writable</td><td>表示属性值是否可以被修改，false 不能改，true 可以修改</td><td>false</td></tr><tr><td>value</td><td>属性的实际值</td><td>undefined</td></tr><tr><td>configurable</td><td>该特性表示对象的属性是否可以被删除，以及除 value 和 writable 特性外的其他特性是否可以被修改</td><td>false</td></tr><tr><td>enumerable</td><td>表示属性是否可通过 <code>for-in</code> 循环遍历</td><td>false</td></tr></tbody></table><blockquote><blockquote><p>注</p></blockquote><ul><li><code>Object.defineProperty</code>定义的属性，如果属性描述符为数据描述符，那这个属性被称为 “数据属性”</li></ul></blockquote><ol><li>具体演示<blockquote><ul><li>当<code>configurable: false</code>时，重新定义属性，<strong>会报错</strong>，所有特性都不能修改；只有在它为<code>true</code>才能修改所有属性</li><li></li><li></li></ul></blockquote></li></ol><pre><code>  // 定义对象  var obj = &#123;    name: &quot;张三&quot;,  &#125;;  //用Object.defineProperty定义新属性  Object.defineProperty(obj, &quot;age&quot;, &#123;    writable: false,    value: 22,    enumerable: false,    configurable: true,  &#125;);  console.log(obj); //&#123;name: &#39;张三&#39;, age: &#39;22&#39;&#125;  //修改age,因为writable是false所以不能直接修改,除非重新定义  obj.age = 33;  console.log(obj); //&#123;name: &#39;张三&#39;, age: &#39;22&#39;&#125;  //遍历该对象,因为enumerable是false,所以age不能被遍历出来  for (var key in obj) &#123;    console.log(obj[key]); //张三  &#125;  //删除属性,因为configurable是false,所以无法删除  delete obj.age;  console.log(obj); //&#123;name: &#39;张三&#39;, age: 22&#125;  //修改属性,因为configurable是true,所以都可修改  Object.defineProperty(obj, &quot;age&quot;, &#123;    writable: false,    value: 44,    configurable: false,    enumerable: false,  &#125;);  console.log(obj); //&#123;name: &#39;张三&#39;, age: 44&#125;  var a1 = Object.getOwnPropertyDescriptor(obj, &quot;age&quot;);  console.log(a1); //&#123;value: 44, writable: false, enumerable: false, configurable: false&#125;</code></pre><ol start="2"><li><p>Object.getOwnPropertyDescriptor</p><blockquote><ul><li><code>Object.getOwnPropertyDescriptor()</code>方法可以取得指定属性的属性描述符</li><li><code>Object.getOwnPropertyDescriptor(obj, prop);</code></li></ul></blockquote></li><li><p>注意事项</p><blockquote><ul><li>直接定义在对象身上的属性，以上属性特性的默认值分别为：<code>writable:true</code>、<code>value:undefined</code>、<code>configurable：true</code>、<code>enumerable:true</code></li><li>通过<code>Object.defineProperty</code>方式定义的属性，其属性特性的默认值分别为：<code>writable:false</code>、<code>value:undefined</code>、<code>configurable：false</code>、<code>enumerable:false</code></li></ul></blockquote></li></ol><h4 id="存取描述符"><a href="#存取描述符" class="headerlink" title="存取描述符"></a>存取描述符</h4><blockquote><p>存取描述符有以下 4 个特性描述它们的行为，具体如下表</p></blockquote><table><thead><tr><th>属性特性</th><th>说明</th><th>默认</th></tr></thead><tbody><tr><td>configurable</td><td>特性表示对象的属性是否可以被删除，以及除 value 和 writable 特性外的其他特性是否可以被修改</td><td>false</td></tr><tr><td>enumerable</td><td>表示属性是否可以通过<code>for...in</code> 循环遍历</td><td>false</td></tr><tr><td>get获取函数</td><td>获取函数，在读取属性时调用。这个函数的主要责任就是返回一个有效的值</td><td>undefined</td></tr><tr><td>set 设置函数</td><td>设置函数，在写入属性时调用。这个函数决定了对数据做什么样的修改，这个函数有一个参数</td><td>undefined</td></tr></tbody></table><blockquote><blockquote><p>注：<br><code>Object.defineProperty</code>定义的属性，如果属性描述符为存取描述符，那这个属性被称为 “<strong>访问器属性</strong>”</p></blockquote><ul><li><code>configurable</code>与 <code>enumerable</code>特性与 数据描述符的用法是一样的</li><li><code>get</code> 获取函数，在读取属性时调用，这个函数的返回值为这个属性的值</li><li><code>set</code> 设置函数，在写入属性时调用，这个函数决定了对数据做什么样的修改,重新设置属性值时，这个值就是set函数的<strong>实参</strong></li><li>一般用访问器属性获取&#x2F;修改的属性 与 对象被定义时设置的名称不一样，在定义时会被设置成”私有变量”，我们约定用<code>_</code>开头的方式命名(依旧可以打点访问)，因为在ES5中无法设置私有变量，只能这么做</li></ul></blockquote><pre><code>var obj = &#123;    name: &quot;张三&quot;,    age: 23,    _sex: &quot;女&quot;,    identity: &quot;女士&quot;,  &#125;;&gt;  Object.defineProperty(obj, &quot;sex&quot;, &#123;    //获取属性    get: function () &#123;      return this._sex;    &#125;,    //设置属性    set: function (value) &#123;      this._sex = value;      if (value === &quot;女&quot;) &#123;        this.identity = &quot;女士&quot;;      &#125; else &#123;        this.identity = &quot;先生&quot;;      &#125;    &#125;,  &#125;);  //获取属性  console.log(obj.sex); //女  //重新设置属性  obj.sex = &quot;男&quot;;  console.log(obj.sex); //男  console.log(obj.identity); //先生</code></pre><ul><li><p>访问器属性的典型<strong>应用场景</strong>：</p><blockquote><ul><li>当设置或获取一个属性的值时，我们还需要做相关的其它操作，就可以把这个属性设置成访问器属性。</li><li>get 和 set 方法的这种机制，我们可以理解为<strong>数据拦截</strong>或<strong>数据劫持</strong>。<blockquote><p>也就是在我操作数据时，会被 get 和 set 方法拦截，然后在里面做相应的操作,改变正常的访问和设置行为。</p></blockquote></li></ul></blockquote></li><li><p>注意事项</p><blockquote><ul><li>获取函数和设置函数<strong>不一定都要定义</strong></li><li><strong>只定义获取函数</strong>意味着属性是只读的，尝试修改属性会被忽略，严格模式会抛错</li><li><strong>只有一个设置函数</strong>的属性是不能读取的，非严格模式下返回值为<code>undefined</code>,严格模式下（有可能）会抛错。</li></ul></blockquote></li></ul><h4 id="Object-defineProperties"><a href="#Object-defineProperties" class="headerlink" title="Object.defineProperties"></a>Object.defineProperties</h4><blockquote><p><code>Object.defineProperties()</code>方法允许我们在一个对象上同时定义多个属性。</p><ul><li><code>Object.defineProperties(obj, props)</code>;</li><li><code>obj</code> 需要定义和修改属性的对象</li><li><code>props</code> 用来修改对应属性的描述符对象</li></ul></blockquote><pre><code> var obj = &#123;   _sex: &quot;女&quot;, &#125;; Object.defineProperties(obj, &#123;   name: &#123;     value: &quot;李四&quot;,     writable: true,   &#125;,   age: &#123;     value: 11,     configurable: false,   &#125;,   sex: &#123;     get: function () &#123;       return this._sex;     &#125;,     set: function (value) &#123;       this._sex = value;     &#125;,   &#125;, &#125;); console.log(obj.sex); //女 obj.sex = &quot;男&quot;; console.log(obj.sex); //男</code></pre><h4 id="经典面试题"><a href="#经典面试题" class="headerlink" title="经典面试题"></a>经典面试题</h4><blockquote><p><code>JavaScript</code>中有没有可能让<code>(a === 1 &amp;&amp; a === 2 &amp;&amp; a === 3)</code>返回<code>true</code> ？</p><ul><li>这是阿里的一个经典面试题，刚开始一看你觉得这是不可能的，因为一个变量怎么可能同时存在三个不同的值呢？ 但你静下心来分析，你就能找到面试官在考什么 ？</li><li>如果我们在<strong>读取</strong>一个变量的值时，能<strong>修改</strong>这个变量对应的值，那不就有解了吗 ?</li><li>我们可以把变量 a 当成 <code>window</code> 对象的属性，同时 a 还是一个访问器属性，那我们就可以在他的 <code>get</code> 方法中来修改他的值。</li></ul></blockquote><pre><code>  var _a = 0;  Object.defineProperty(window, &quot;a&quot;, &#123;    get: function () &#123;      return ++_a;    &#125;,  &#125;);  if (a === 1 &amp;&amp; a === 2 &amp;&amp; a == 3) &#123;    console.log(&quot;true&quot;);  &#125;</code></pre><blockquote><blockquote><p>通过上面这个面试题给了我们一个启发</p></blockquote><ul><li>如果在获取或设置一个变量的值时，<strong>还需要做相关的其它操作</strong>，我们就可以把这个变量设置成一个访问器属性，然后在他的 get 和 set 方法中做相应的操作。</li></ul></blockquote><h4 id="案例应用1：追溯属性的赋值记录"><a href="#案例应用1：追溯属性的赋值记录" class="headerlink" title="案例应用1：追溯属性的赋值记录"></a>案例应用1：追溯属性的赋值记录</h4><blockquote><p>当我们每次设置属性的值时，可以把设置的值保存在<strong>数组</strong>中，那这个数组就是用来保存属性赋值的记录</p><ul><li>除了可以保存赋值记录，还可以查询某次的记录、总值</li></ul></blockquote><pre><code> var obj = &#123;   _num: 0,   _historyValue: [], &#125;; Object.defineProperty(obj, &quot;num&quot;, &#123;   get: function () &#123;     return this._num;   &#125;,   set: function (value) &#123;     this._num = value;     this._historyValue.push(value);   &#125;, &#125;); //查找全部历史记录 obj.getHistory = function () &#123;   return this._historyValue; &#125;; //查找某次记录 obj.go = function (index) &#123;   if (index &gt;= this._historyValue.length)     throw new Error(&quot;访问下标超出范围&quot;);   return this._historyValue[index - 1]; &#125;; //查找总金额 obj.sum = function () &#123;   var _sum = 0;   for (var i = 0; i &lt; obj._historyValue.length; i++) &#123;     _sum += this._historyValue[i];   &#125;   return _sum; &#125;; obj.num = 45; obj.num = 32; obj.num = 23; console.log(obj.getHistory());//45,32,23 console.log(obj.go(1)); //45 console.log(obj.sum());//100</code></pre><h4 id="案例应用2：数据驱动页面更新（单向）"><a href="#案例应用2：数据驱动页面更新（单向）" class="headerlink" title="案例应用2：数据驱动页面更新（单向）"></a>案例应用2：数据驱动页面更新（单向）</h4><blockquote><p>Vue 中有两种数据绑定方式</p><ul><li>单向绑定（v-bind）：数据只能从 data 流向页面</li><li>双向绑定（v-modle）：数据不仅能从 data 流向页面，还能从页面流向 data<br>在 Vue2 中，其数据的绑定方式底层采用的是 <code>Object.defineProperty</code>，在 <code>Vue3</code> 中，底层采用的是 <code>Proxy</code> 代理。但本质的原理是一样的。</li></ul></blockquote><blockquote><ul><li>以下案例简单实现了数据的单向绑定，关于双向绑定后面的案例中会讲到</li><li>效果：当data中的数据发生更新数据，则页面数据就发生相应的变化</li></ul></blockquote><pre><code>&gt;&lt;div class=&quot;goods&quot;&gt;&gt;  &lt;h3 class=&quot;title&quot;&gt;&lt;/h3&gt;&gt;  &lt;img src=&quot;&quot; alt=&quot;&quot; class=&quot;main-img&quot; /&gt;&gt;  &lt;p&gt;价格：&lt;span class=&quot;price&quot;&gt;&lt;/span&gt;&lt;/p&gt;&gt;&lt;/div&gt;&gt;&lt;script&gt;  function update() &#123;    var obj = &#123;&#125;;    //这三个元素相当于私有变量，外面访问不到    var title = &quot;云原生容器化docker+K8S+CICD弹性扩容集群架构实战&quot;;    var mainImg =      &quot;https://sce7a2b9c9d95a-sb-qn.qiqiuyun.net/files/course/2020/04-23/1339186404a1276893.jpg&quot;;    var price = 3680.0;    //获取元素    var oTitle = document.querySelector(&quot;.title&quot;);    var oImg = document.querySelector(&quot;.main-img&quot;);    var oPrice = document.querySelector(&quot;.price&quot;);    //初始渲染：    oTitle.innerText = title;    oImg.src = mainImg;    oPrice.innerText = price;&gt;    var data = Object.defineProperties(obj, &#123;      title: &#123;        get: function () &#123;          return title;        &#125;,        set: function (value) &#123;          title = value;          oTitle.innerText = value;        &#125;,      &#125;,      mainImg: &#123;        get: function () &#123;          return mainImg;        &#125;,        set: function (value) &#123;          mainImg = value;          oImg.src = value;        &#125;,      &#125;,      price: &#123;        get: function () &#123;          return price;        &#125;,        set: function (value) &#123;          price = value;          oPrice.innerText = value &gt; 0 ? value : &quot;免费&quot;;        &#125;,      &#125;,    &#125;);    return data; //将obj对象返回  &#125;  var date = update(); //调用函数，得到obj对象  //更新数据，当date中的数据发生更新数据，则页面数据就发生相应的变化  date.title = &quot;Web前端高级工程师系统课-星辰班&quot;;  date.mainImg =    &quot;https://sce7a2b9c9d95a-sb-qn.qiqiuyun.net/files/course/2022/08-29/210311f40bcf290736.jpg&quot;;  date.price = 300;&gt;&lt;/script&gt;</code></pre><h3 id="二、区分公有、静态、私有属性"><a href="#二、区分公有、静态、私有属性" class="headerlink" title="二、区分公有、静态、私有属性"></a>二、区分公有、静态、私有属性</h3><h4 id="JS-公有属性和公有方法"><a href="#JS-公有属性和公有方法" class="headerlink" title="JS 公有属性和公有方法"></a>JS 公有属性和公有方法</h4><blockquote><ul><li>公有属性：所有构造函数的实例都可以访问的属性，在构造函数内部通过 <code>this.属性名</code> 定义的。</li><li>公有方法：所有构造函数的实例都可以访问的方法，在构造函数 <code>prototype</code> 原型上定义的方法。<blockquote><p>公有属性也称实例属性，公有方法也称实例方法</p></blockquote></li></ul></blockquote><blockquote><p>定义公有方法有两种方式:</p><ul><li>一种是在在构造函数内部通过<code>this.方法</code>定义；但不推荐这种方式，因为它在每个实例身上都会创建，并且相互独立，所以就会造成内存的浪费</li><li>另一种方式就是在构造函数的原型上定义，所有实例都是共用原型上的同一个方法，更推荐这种方式</li></ul></blockquote><pre><code>function Person(name, age) &#123;  // 公有属性 实例属性  this.name = name;  this.age = age;  // 公有方法（一般不会这样写）  this.toSleep = function () &#123;    console.log(&quot;我正在睡觉&quot;);  &#125;;&#125;// 公有方法 实例方法Person.prototype.sayHello = function () &#123;  console.log(&quot;大家好，我是&quot; + this.name);&#125;;&gt;var p1 = new Person(&quot;张三&quot;, 32);console.log(p1.name);console.log(p1.age);p1.sayHello();</code></pre><h4 id="JS-静态属性和静态方法"><a href="#JS-静态属性和静态方法" class="headerlink" title="JS 静态属性和静态方法"></a>JS 静态属性和静态方法</h4><blockquote><ul><li>静态属性：只有类（构造函数）本身能访问的属性，通过<code>类名.属性名</code>来定义</li><li>静态方法：只有类（构造函数）本身能访问的属性，通过<code>类名.方法名 = function() &#123;...&#125;</code> 来定义</li><li>访问的时候也是通过<code>类名.属性名/方法名</code>的方式</li></ul></blockquote><pre><code>function Person() &#123;&#125;// 静态属性Person.length = 0;Person.children = function () &#123;  console.log(&quot;静态方法&quot;);&#125;;&gt;var p = new Person();console.log(p.length); // 不能访问console.log(Person.length); // 能访问</code></pre><h4 id="JS-私有属性、私有方法和特权方法"><a href="#JS-私有属性、私有方法和特权方法" class="headerlink" title="JS 私有属性、私有方法和特权方法"></a>JS 私有属性、私有方法和特权方法</h4><blockquote><ul><li>私有属性：只能在构造函数<strong>内部</strong>才能访问的属性，如果外部要访问必须<strong>通过指定的方法</strong>来访问和修改</li><li>私有方法：是指对象不希望公开的方法，只能在构造函数<strong>内部</strong>才能调用的方法</li><li><strong>特权方法：是指有权访问内部私有属性和私有方法的公有方法</strong></li></ul></blockquote><blockquote><blockquote><p>注意：</p></blockquote><ul><li>在JS中并没有私有属性和私有方法的概念，所以需要利用<strong>闭包</strong>的思想<ul><li>在构造函数里<strong>直接声明</strong>属性和方法<blockquote><p>注意与公有的声明方式：<code>this.属性/方法</code>区分</p></blockquote></li></ul></li><li>行业约定规范，私有属性和方法在命名时以<code>_</code>下划线开头</li></ul></blockquote><pre><code>function Price() &#123;  // 私有属性  var _price = 0;&gt;  // 私有方法  用来对属性price做相关操作  function _computed() &#123;    return _price &gt; 0 ? &quot;￥&quot; + _price : &quot;免费&quot;;  &#125;&gt;  // 特权方法  获取属性计算后的值  this.getPrice = function () &#123;    return _computed();  &#125;;&gt;  // 特权方法  this.setPrice = function (value) &#123;    if (typeof value !== &quot;number&quot;) throw new TypeError(&quot;传入一个数字&quot;);    _price = value;  &#125;;&#125;&gt;var p = new Price();p.setPrice(200.05);console.log(p.getPrice()); // ￥200.05p.setPrice(-90); //console.log(p.getPrice()); // 免费</code></pre><h4 id="混合模式"><a href="#混合模式" class="headerlink" title="混合模式"></a>混合模式</h4><blockquote><ul><li>将所有实例都操作的<strong>特权方法</strong>定义在构造函数的<strong>原型链</strong>上</li><li>特权方法要访问到私有属性和方法可以利用<strong>闭包</strong>来实现</li></ul></blockquote><blockquote><blockquote><p>矛盾点：</p></blockquote><ul><li>定义在原型链上的是公有方法,它只能通过<code>this.</code>的方式访问构造函数里的<strong>公有属性&#x2F;方法</strong>，<strong>不能访问到私有的</strong></li><li>因此要用<strong>立即执行函数+闭包</strong>的方式才能实现混合模式</li></ul></blockquote><pre><code> var GetNum = (function () &#123;   var _num = 4;   function GetNum() &#123;&#125;   GetNum.prototype.get = function () &#123;     return _num;   &#125;;   GetNum.prototype.set = function (value) &#123;     _num = value;   &#125;;   return GetNum; &#125;)();&gt; var n1 = new GetNum(); console.log(n1); console.log(n1.get());//4 n1.set(555); console.log(n1.get());//555</code></pre><blockquote><p><strong>案例应用</strong></p><ul><li>利用 JS 来模拟现实生活中，父亲有挣钱、花钱、查看账户金额的能力，但是他的孩子只有花钱能力</li><li>我们可以定义两个类：Father类（模拟父亲） Children类（模拟孩子们）</li></ul></blockquote><p><strong>Father 类身上有的方法和属性</strong></p><table><thead><tr><th>属性与方法</th><th>功能</th></tr></thead><tbody><tr><td>私有属性</td><td>_money</td></tr><tr><td>静态方法</td><td>save</td></tr><tr><td>静态方法</td><td>take</td></tr><tr><td>静态方法</td><td>view</td></tr><tr><td>实例方法</td><td>take</td></tr></tbody></table><p><strong>Children 类身上有的方法和属性</strong></p><table><thead><tr><th>属性和方法</th><th>功能</th></tr></thead><tbody><tr><td>实例属性 姓名</td><td>保存孩子的姓名</td></tr></tbody></table><pre><code> var Father = (function () &#123;   //私有属性   var _money = 0;   function Father() &#123;&#125;   //静态方法：存钱   Father.save = function (value) &#123;     _money += value;     console.log(&quot;父亲存了&quot; + value + &quot;元&quot;);   &#125;;   // 静态方法 取钱   Father.take = function (value) &#123;     _money -= value;     console.log(&quot;父亲取走&quot; + value + &quot;元&quot;);   &#125;;   // 静态方法 查看   Father.view = function () &#123;     console.log(&quot;目前账户还有&quot; + _money + &quot;元&quot;);     return _money;   &#125;;   //公有方法(实例方法)   Father.prototype.take = function (value) &#123;     _money -= value;     console.log(this.name + &quot;取走&quot; + value + &quot;元&quot;);   &#125;;   return Father;  &#125;)(); //子类 function Child(name) &#123;  this.name = &quot;张三&quot;;  Father.call(this); // 经典继承（盗用构造函数） &#125; // 原型式继承 Child.prototype = Object.create(Father.prototype);&gt; var child1 = new Child(); Father.save(2000); //父亲存了2000元 Father.take(200); //父亲取走200元 Father.view(); //目前账户还有1800元 child1.take(100); //张三取走100元</code></pre><blockquote><blockquote><p>注意： 以上情况，所有实例本质上操作的是同一个变量<code>_money</code></p></blockquote></blockquote><h4 id="多彩运动的小球"><a href="#多彩运动的小球" class="headerlink" title="多彩运动的小球"></a>多彩运动的小球</h4><ol><li>多彩运动小球的实现原理<blockquote><ul><li>当鼠标滑动时，会产生一系列的彩色小球，然后这些小球开始向不同的方向运动，运动过程中会发生（大小，位置，透明度）的变化</li><li>所以我们需要构建一个球类，这个类身上有以下相关的属性和方法<table><thead><tr><th>属性和方法</th><th>说明</th></tr></thead><tbody><tr><td>实例属性x</td><td>小球水平方向坐标 ，默认值 0</td></tr><tr><td>实例属性y</td><td>小球垂直方向从标 ，默认值 0</td></tr><tr><td>实例属性r</td><td>小球的半径，默认值 20</td></tr><tr><td>实例属性color</td><td>数组，从数组中随机取出一个颜色作为小球的颜色</td></tr><tr><td>实例属性 opacity</td><td>小球的透明度（刚开始透明度为 1）</td></tr><tr><td>实例属性 speedX</td><td>小球水平方向运动速度（步长）随机 （取值范围[-10,10]）</td></tr><tr><td>实例属性 speedY</td><td>小球垂直方向运动速度（步长）随机（取值范围[-10,10]）</td></tr><tr><td>实例属性 dom</td><td>小球的 dom 结构</td></tr><tr><td>实例方法 init</td><td>初始化一个小球（根据小球属性，在页面创建一个真实的 DOM 球）</td></tr><tr><td>实例方法 update</td><td>更新小球的属性值(x,y,r,opacity)，同时当小球透明度为 0，将其从 DOM 中删除</td></tr></tbody></table></li></ul></blockquote></li></ol><ul><li>x,y属性由鼠标的位置决定，所以当<code>onmousemove</code>事件触发时，创建实例</li><li><code>speedx、speedy</code>：不能同时等于0，用<code>do...while</code>语句</li></ul><pre><code>&gt;/**&gt; * Ball 创建一个球类&gt; * @param x坐标  默认值 0&gt; * @param y坐标  默认值 0&gt; * @param r小球半径 默认 20&gt; */function Ball(x = 0, y = 0, r = 20) &#123;  this.x = x; // x坐标  this.y = y; // y坐标  this.r = r; // 小球半径  // 随机生成一个小球颜色  this.color = (function () &#123;    var color = [      &quot;red&quot;,      &quot;pink&quot;,      &quot;skyblue&quot;,      &quot;orange&quot;,      &quot;tomato&quot;,      &quot;khaki&quot;,      &quot;greenyellow&quot;,    ];    var index = (Math.random() * color.length) &gt;&gt; 0;    return color[index];  &#125;)();  this.opacity = 1; // 小球透明度  // 小球运动速度，speedX和speedY的取值范围 [-10,10]，但不能同时为0  do &#123;    this.speedX = Math.floor(Math.random() * 21) - 10;    this.speedY = Math.floor(Math.random() * 21) - 10;  &#125; while (this.speedX === 0 &amp;&amp; this.speedY === 0);&gt;  // 在new Ball(),内部会自动调用this.init()初始化小球，在页面显示，其 实现代码看下一步  this.init();&#125;&gt;// 鼠标在页面滑动时，会创建实例化的小球document.onmousemove = function (e) &#123;  var pageX = e.pageX;  var pageY = e.pageY;  new Ball(pageX, pageY);&#125;;</code></pre><ul><li><code>init</code>方法<blockquote><ul><li>要在定义实例属性的最后调用该方法；创建实例的时候就会自动调用,实现在页面插入一个真实的小球；</li><li>创建DOM后，要将DOM设置成<strong>绝对定位</strong></li><li>为了鼠标出现在小球中心，小球的宽等于<code>x-小球的半径</code>，高同理</li></ul></blockquote></li></ul><pre><code>Ball.prototype.init = function () &#123;  this.dom = document.createElement(&quot;div&quot;); // 创建dom结构  this.dom.style.position = &quot;absolute&quot;;  this.dom.style.left = this.x - this.r + &quot;px&quot;;  this.dom.style.top = this.y - this.r + &quot;px&quot;;  this.dom.style.width = 2 * this.r + &quot;px&quot;;  this.dom.style.height = 2 * this.r + &quot;px&quot;;  this.dom.style.borderRadius = &quot;50%&quot;;  this.dom.style.backgroundColor = this.color;  // 添加到页面  document.body.appendChild(this.dom);&#125;;</code></pre><ul><li><code>update</code>方法<blockquote><ul><li>放在定时器内，每间隔一段时间就调用</li><li>更新小球的属性值(x,y,r,opacity)，并将这些值再次更新到DOM中</li><li>监控小球的透明度，一旦透明度为0，就把他从DOM和数组中删除</li></ul></blockquote></li></ul><pre><code>Ball.prototype.update = function () &#123;  this.x += this.speedX; // 更新x坐标  this.y += this.speedY; // 更新y坐标  this.r += 0.3; // 更新半径  this.opacity -= 0.01;&gt;  // 更新的属性更新到真实DOM上  this.dom.style.display = &quot;none&quot;;  this.dom.style.width = this.r * 2 + &quot;px&quot;;  this.dom.style.height = this.r * 2 + &quot;px&quot;;  this.dom.style.left = this.x - this.r + &quot;px&quot;;  this.dom.style.top = this.y - this.r + &quot;px&quot;;  this.dom.style.opacity = this.opacity;  this.dom.style.display = &quot;block&quot;;&#125;;</code></pre><ul><li>那如何监控鼠标在滑动过程中被创建出来的一堆小球，然后让他们不停的<strong>运动</strong>呢 ？<blockquote><ul><li>我们需要在球类上创建一个<strong>私有属性</strong><code>_ballArr = []</code>，用来保存鼠标移动时创建出来的实例化小球。每实例化一个小球，就把这个实例化的小球对象添加到<code>_ballArr</code>数组中</li><li>还需要创建一个静态方法<code>ballArr</code>用来获取所有实例化的小球。这样我们就能拿到所有实例化的小球，对他们进行操作。<table><thead><tr><th>属性和方法</th><th>说明</th></tr></thead><tbody><tr><td>私有属性 <code>_ballArr</code></td><td>数组，用来保存创建好的实例化小球</td></tr><tr><td>静态方法 <code>getBalls</code></td><td>用来获取所有实例化的小球 （返回数组<code>ballArr</code>）</td></tr></tbody></table></li></ul></blockquote></li></ul><pre><code>var _ballArr=[]; // 类的私有属性// 静态方法Ball.getBalls = function () &#123;    return ballArr;&#125;;&gt;function Ball(x = 0, y = 0, r = 20)&#123;  // ......  // .....以下代码放在 this.init() 后面&gt;  // 每次创建的实例对象，添加到数组 _ballArrl中  _ballArr.push(this);&#125;</code></pre><blockquote><p>拿到实例化小球后，如何让小球运动起来 ？</p><ul><li>要让小球运动起来，需要开启一个<strong>定时器</strong>，让球不断的调用自身的<code>update</code>方法，实现小球运动及运动中各种属性的变化</li><li>同时还要判断如果小球的透明度为 <code>0</code>，则需要将小球从<code>_ballArr</code>数组和 <code>DOM</code> 中删除，确保垃圾能及时被回收，不至于小球多了造成页面卡顿,这段代码写在<code>update</code>方法的最后</li></ul></blockquote><pre><code>var timer = setInterval(function () &#123;  var balls = Ball.getBalls();  // 更新小球  for (var i = 0; i &lt; balls.length; i++) &#123;    balls[i].update();  &#125;&#125;, 20);&gt;// 以下代码添加到update方法的最后面// 如果小球的透明度小于等于0,则将其从数组和DOM中删除if (this.opacity &lt;= 0) &#123;  for (var i = 0; i &lt; _ballArr.length; i++) &#123;    if (_ballArr[i] === this) &#123;      _ballArr.splice(i, 1); // 从数组中删除      document.body.removeChild(this.dom); // 从DOM中删除      break;    &#125;  &#125;&#125;</code></pre><ol start="2"><li>完整源码<blockquote><ul><li>为了防止变量造成全局污染，则利用闭包，将所有代码封装在立即执行函数中，然后将 <code>Ball</code> 类作为返回值返回</li></ul></blockquote></li></ol><pre><code> //构造函数 var Ball = (function () &#123;  var _ballArr = [];  function Ball(x = 0, y = 0, r = 20) &#123;    //公有属性    this.x = x;    this.y = y;    this.r = r;    this.opacity = 1;    this.color = (function () &#123;      var colorArr = [&quot;red&quot;, &quot;skyblue&quot;, &quot;pink&quot;, &quot;tomato&quot;, &quot;yellow&quot;];      var index = (Math.random() * colorArr.length) &gt;&gt; 0;      return colorArr[index];    &#125;)();    do &#123;      this.speedx = (Math.random() * 21 - 10) &gt;&gt; 0;      this.speedy = (Math.random() * 21 - 10) &gt;&gt; 0;    &#125; while (this.speedx == 0 &amp;&amp; this.speedy == 0);    _ballArr.push(this); //将创建的实例放入数组中    //初始化小球    this.init();  &#125;  //静态方法  Ball.ballArr = function () &#123;    return _ballArr;  &#125;;  //公有方法：初始化  Ball.prototype.init = function () &#123;    this.dom = document.createElement(&quot;div&quot;);    //球在鼠标中心出现    this.dom.style.position = &quot;absolute&quot;;    this.dom.style.left = this.x - this.r / 2 + &quot;px&quot;;    this.dom.style.top = this.y - this.r / 2 + &quot;px&quot;;    this.dom.style.width = this.r * 2 + &quot;px&quot;;    this.dom.style.height = this.r * 2 + &quot;px&quot;;    this.dom.style.borderRadius = &quot;50%&quot;;    this.dom.style.opacity = this.opacity;    this.dom.style.backgroundColor = this.color;    //插入页面    document.body.appendChild(this.dom);  &#125;;  //公有方法：运动函数  Ball.prototype.update = function () &#123;    this.x += this.speedx;    this.y += this.speedy;    this.r += 0.3;    this.opacity -= 0.01;           //将更新后的属性 更新到真实的DOM上    this.dom.style.display = &quot;none&quot;;    this.dom.style.left = this.x + &quot;px&quot;;    this.dom.style.top = this.y - this.r / 2 + &quot;px&quot;;    this.dom.style.width = this.r * 2 + &quot;px&quot;;    this.dom.style.height = this.r * 2 + &quot;px&quot;;    this.dom.style.opacity = this.opacity;    this.dom.style.display = &quot;block&quot;;&gt;    //删除dom、数组中的实例    if (this.opacity &lt;= 0) &#123;      // 找到小球实例在数组中的位置，然后将他从数组中删除      var index = _ballArr.indexOf(this);      _ballArr.splice(index, 1);      // 从dom中删除      document.body.removeChild(this.dom);    &#125;  &#125;;  return Ball;&#125;)();&gt; //定时器 var timer = setInterval(function () &#123;   var balls = Ball.ballArr();   for (var i = 0; i &lt; balls.length; i++) &#123;     balls[i].update();   &#125; &#125;, 20); //鼠标事件 document.onmousemove = function (e) &#123;   var target = e.target;   var _x = e.pageX;   var _y = e.pageY;   new Ball(_x, _y); &#125;;</code></pre><h3 id="三、JS-实现栈与队列"><a href="#三、JS-实现栈与队列" class="headerlink" title="三、JS 实现栈与队列"></a>三、JS 实现栈与队列</h3><ol><li>什么是栈<blockquote><p>栈是一种先进后出的数据结构，是一种逻辑结构，一种抽像出来的理论模型</p><ul><li>入栈操作（push）：就将新元素放入到栈中，先放的在栈底</li><li>出栈操作（pop）：就是将元素从栈中弹出，只有栈顶元素才能出<img src="栈.jpg"></li></ul></blockquote></li></ol><blockquote><ul><li>之前课程中我们简单的用数组来模拟一个栈的出栈和入栈全过程</li><li>数组相当于一个栈结构，向数组中<code>push</code>添中元素为入栈，从数组尾部<code>pop</code>取出元素为出栈<blockquote><p>接下来，我们利用 JS 来模拟一个完整的栈对象</p></blockquote></li></ul></blockquote><ol start="2"><li>JS 实现栈结构<blockquote><ul><li>构建一个 <code>Stack</code> 类，只要 <code>new Stack()</code> 就能创建一个新的栈</li><li>一个基础的栈对象要求有以下方法和属性<table><thead><tr><th>方法</th><th>说明</th></tr></thead><tbody><tr><td>push</td><td>入栈，向栈中添加元素</td></tr><tr><td>pop</td><td>出栈，从栈顶部弹出元素</td></tr><tr><td>isFull</td><td>查看栈是否满</td></tr><tr><td>isEmpty</td><td>查看栈是否为空</td></tr><tr><td>getTop</td><td>取出栈顶部元素</td></tr><tr><td>clear</td><td>清空栈中元素</td></tr><tr><td>view</td><td>查看当前栈中元素</td></tr></tbody></table></li></ul></blockquote></li></ol><table><thead><tr><th>属性</th><th>说明</th></tr></thead><tbody><tr><td>实例属性：size</td><td>查看栈的长度（模拟大小）</td></tr><tr><td>私有属性：_stack</td><td>数组，模拟栈容器，栈中元素都存在<code>_stack</code>中；私有属性，不允许直接操作<code>_stack</code>，只能通过给定的接口来操作</td></tr></tbody></table><blockquote><blockquote><p>注：</p></blockquote><ul><li>以上栈（数组）的长度是在动态变化的，但最终入栈的个数不能大于栈的<code>size</code>大小</li><li>如果栈满，再入栈就会抛出栈满错误提示</li><li>如果栈空，再出栈就会抛出栈空错误提示</li></ul></blockquote><ul><li>基础版代码</li></ul><pre><code>&gt;/**&gt; * Stack 栈&gt; * size 栈的大小（长度）&gt; */function Stack(size = 100) &#123;  this._stack = []; // 私有属性，栈容器  this.size = size; // 返回栈的大小（长度）,可更改&#125;&gt;// 判断栈是否满,满返回true,否则falseStack.prototype.isFull = function () &#123;  return this._stack.length &gt;= this.size ? true : false;&#125;;&gt;// 判断栈是否为空,为空返回true,否则falseStack.prototype.isEmpty = function () &#123;  return this._stack.length &lt;= 0 ? true : false;&#125;;&gt;// 入栈Stack.prototype.push = function (value) &#123;  if (this.isFull()) &#123;    throw new Error(&quot;栈满，不能再填加元素&quot;);  &#125; else &#123;    this._stack.push(value);    return true; // 返回true，表示入栈成功  &#125;&#125;;&gt;// 出栈Stack.prototype.pop = function () &#123;  if (this.isEmpty()) &#123;    throw new Error(&quot;栈空，没有元素可以出栈&quot;);  &#125; else &#123;    return this._stack.pop(); // 返回出栈元素  &#125;&#125;;&gt;// 取出栈顶元素Stack.prototype.getTop = function () &#123;  return this._stack[this._stack.length - 1];&#125;;&gt;// 查看栈中元素Stack.prototype.view = function () &#123;  console.log(&quot;当前栈中的元素有&quot;);  this._stack.forEach(function (item) &#123;    console.log(item);  &#125;);&#125;;&gt;// 清空栈Stack.prototype.clear = function () &#123;  this._stack = [];  return true; // 清空栈成功&#125;;&gt;var stack = new Stack(4);// 入栈console.log(stack.push(1)); // trueconsole.log(stack.push(2)); // trueconsole.log(stack.push(3)); // trueconsole.log(stack.push(4)); // true// 查看栈是否满console.log(stack.isFull()); // true// 查看栈元素console.log(stack.view()); //  [1, 2, 3, 4]// 出栈console.log(stack.pop()); // 4console.log(stack.pop()); // 3// 查看栈元素console.log(stack.view()); // [1, 2]// 查看栈是否满console.log(stack.isFull()); // false// 清空栈console.log(stack.clear()); // true// 判断栈是否为空console.log(stack.isEmpty()); // true// 查看栈元素console.log(stack.view()); // []</code></pre><ol start="3"><li>JS 实现栈结构 - 优化版<blockquote><p>以上版本，最终用户本质上还是可以通过 <code>stack._stack</code>的方式操作数组</p><ul><li>我们可以把私有属性的名字，改成<code>Symbol</code>类型，这样用户就真正没有办法访问到该属性了</li></ul></blockquote></li></ol><pre><code>var Stack = (function () &#123;&gt;/**&gt; * Stack 栈&gt; * size 栈的大小（长度）&gt; */  var _stack = Symbol(&quot;_stack&quot;); // 生成唯一标识符  function Stack(size = 100) &#123;    this[_stack] = []; //  私有属性，栈容器    var _size = size; // 返回栈的大小（长度）,可更改&gt;    Object.defineProperty(this, &quot;size&quot;, &#123;      get: function () &#123;        return _size;      &#125;,      // 当对size进行操作时，需要对数组做相关操作      set: function (value) &#123;        if (value &lt; _size) &#123;          this[_stack] = this[_stack].slice(0, value);          _size = value;        &#125;      &#125;,    &#125;);  &#125;&gt;  // 判断栈是否满,满返回true,否则false  Stack.prototype.isFull = function () &#123;    return this[_stack].length === this._size ? true : false;  &#125;;&gt;  // 判断栈是否为空,为空返回true,否则false  Stack.prototype.isEmpty = function () &#123;    return this[_stack].length === 0 ? true : false;  &#125;;&gt;  // 入栈  Stack.prototype.push = function (value) &#123;    if (this.isFull()) &#123;      throw new Error(&quot;栈满，不能再填加元素&quot;);    &#125; else &#123;      this[_stack].push(value);      return true; // 返回true，表示入栈成功    &#125;  &#125;;&gt;  // 出栈  Stack.prototype.pop = function () &#123;    if (this.isEmpty()) &#123;      throw new Error(&quot;栈空，没有元素可以出栈&quot;);    &#125; else &#123;      return this[_stack].pop(); // 返回出栈元素    &#125;  &#125;;&gt;  // 取出栈顶元素  Stack.prototype.getTop = function () &#123;    return this[_stack][this[_stack].length - 1];  &#125;;&gt;  // 查看栈中元素  Stack.prototype.view = function () &#123;    console.log(&quot;当前栈中的元素有&quot;);    this[_stack].forEach(function (item) &#123;      console.log(item);    &#125;);  &#125;;&gt;  // 清空栈  Stack.prototype.clear = function () &#123;    this[_stack] = [];    return true; // 清空栈成功  &#125;;  return Stack;&#125;)();&gt;var stack = new Stack();// 入栈console.log(stack.push(1)); // trueconsole.log(stack.push(2)); // trueconsole.log(stack.push(3)); // trueconsole.log(stack.push(4)); // true// 查看栈是否满console.log(stack.isFull()); // true// 查看栈元素console.log(stack.view()); //  [1, 2, 3, 4]// 出栈console.log(stack.pop()); // 4console.log(stack.pop()); // 3// 查看栈元素console.log(stack.view()); // [1, 2]// 查看栈是否满console.log(stack.isFull()); // false// 清空栈console.log(stack.clear()); // true// 判断栈是否为空console.log(stack.isEmpty()); // true// 查看栈元素console.log(stack.view()); // []</code></pre><ol start="4"><li><p>什么是队列</p><blockquote><p>现在我们来学习一种新的数据结构队列</p><ul><li>队列是一种线性的数据结构，它的特点是先进先出（<code>First In First Out</code>，简称<code>FIFO</code>），后进后出</li><li>队列的出口端叫作队头（<code>front</code>），队列的入口端叫作队尾（<code>rear</code>）</li><li>入队（<code>enqueue</code>）就是把新元素放入队列中，只允许在队列的队尾放入元素</li><li>出队（<code>dequeue</code>）就是把元素移出队列，只允许在队列的队头移出元素<img src="队列.png"></li></ul></blockquote></li><li><p>JS 实现队列</p><blockquote><p>构建一个 Queue 类，只要new Queue() 就能创建一个新的队列</p><ul><li>一个基础的队列对象要求有以下方法和属性</li></ul></blockquote></li></ol><table><thead><tr><th>方法</th><th>说明</th></tr></thead><tbody><tr><td>enQueue</td><td>入队，向队尾添加元素</td></tr><tr><td>deQueue</td><td>出队，从队头删除元素</td></tr><tr><td>isFull</td><td>判断队列是否已满</td></tr><tr><td>isEmpty</td><td>判断队列是否为空</td></tr><tr><td>getFront</td><td>取出队头元素</td></tr><tr><td>clear</td><td>清空队列</td></tr><tr><td>view</td><td>查看队列中元素</td></tr></tbody></table><table><thead><tr><th>属性</th><th>说明</th></tr></thead><tbody><tr><td>私有属性：<code>_queue</code></td><td>数组，模拟队列容器，队中元素都存在<code>_queue</code>中；私有属性，不允许直接操作<code>_queue</code>，只能通过给定的接口来操作</td></tr><tr><td>实例属性：size</td><td>队列的大小（长度）</td></tr></tbody></table><pre><code>&gt;&lt;script&gt;  var Queue = (function () &#123;    var _queue = Symbol(&quot;queue&quot;); // 创建唯一标识符    function Queue(size) &#123;      this[_queue] = []; // 私有属性，队列容器      this.size = size; // 队列的长度（大小）    &#125;    // 判断队列是否已满,true表示已满，false表示未满    Queue.prototype.isFull = function () &#123;      return this[_queue].length === this.size ? true : false;    &#125;;    // 判断队列是否为空    Queue.prototype.isEmpty = function () &#123;      return this[_queue].length === 0 ? true : false;    &#125;;&gt;    // 入队    Queue.prototype.enQueue = function (value) &#123;      if (this.isFull()) &#123;        throw new Error(&quot;队列已满，不能现入队&quot;);      &#125; else &#123;        this[_queue].push(value);        return true; //表示入队成功      &#125;    &#125;;&gt;    // 出队    Queue.prototype.deQueue = function () &#123;      if (this.isEmpty()) &#123;        throw new Error(&quot;队列已为空，没有元素可出队&quot;);      &#125; else &#123;        return this[_queue].shift(); // 返回出队元素      &#125;    &#125;;&gt;    // 取出队头元素    Queue.prototype.getFront = function () &#123;      return this[_queue][0]; // 返回值为undefined表示当前队列已空    &#125;;&gt;    // 查看队列中元素    Queue.prototype.view = function () &#123;      this[_queue].forEach(function (item) &#123;        console.log(item);      &#125;);    &#125;;&gt;    // 清空队列    Queue.prototype.clear = function () &#123;      this[_queue] = [];      return true; // true清空队列成功    &#125;;    return Queue;  &#125;)();&gt;&lt;/script&gt;</code></pre><blockquote><blockquote><p>上述代码与模拟栈类似，只是出栈方式不同</p></blockquote></blockquote><blockquote><p><strong>上述版本缺点</strong></p><ul><li>以上版本，在入队时还好，直接尾部插入元素，但是在出队时<strong>从队头取出元素</strong>，本质上会造成整个数组往后的所有元素都向前移动，非常消耗性能</li><li>同时队列的容量大小一直是在不断变化的，而实际上一个队列的大小在刚开始分配时，大小应该是固定才更合理<br><strong>优化方向</strong></li><li>有没有什么办法能实现在出队时，能正常出，不需要动数组中的其它元素呢 ?</li><li>同时保证整个出队和入队过程程中，栈的容量大小是固定的</li></ul></blockquote><ol start="6"><li>优化版本 - JS 实现循环队列<blockquote><ul><li>我们可以利用<strong>双指针</strong>思想，同时采用循环队列的方式来实现</li><li>以下图中的队列容量（长度）为 <code>4</code>，需要用长度为 <code>5</code> 的数组来实现。<img src="模拟队列.png"></li></ul></blockquote></li></ol><blockquote><ul><li>定义两个指针 <code>front</code> 和 <code>rear</code>，<code>front</code>和<code>rear</code>分别表示当前队列队头和队尾的下标<ul><li><code>front</code> &#x3D; <code>rear</code> &#x3D; <code>0</code></li></ul></li><li>队列的长度为用户设定的<code>size+1</code> ，初始化后，不可更改<ul><li><code>this[_queue] = new Array(size + 1);</code></li></ul></li></ul></blockquote><blockquote><ul><li>查看队列元素：使用<code>filter</code>方法，过滤空元素，声明一个变量保存由<code>filter</code>方法筛选出来的元素所组成的数组</li><li>清空队列：初始化队列容器、队头、队尾</li></ul></blockquote><blockquote><ul><li>如果队未满，<ul><li>入队一个元素，<code>rear + 1</code>，向右移一位，<code>front</code>不变</li><li>当<code>rear + 1 === arr.length</code>时，则在下一次入队后， <code>rear = 0</code></li></ul></li></ul></blockquote><blockquote><p><strong>因此入队：</strong></p><ul><li>入队时要判断当前队是否满，如果满，啥也不做</li><li>先在队头处放置入队元素</li><li>然后移动<code>rear</code>的位置，要判断 <code>rear + 1 === arr.lenght</code>,如果成立，则入队后，<code>rear = 0</code></li><li>如果未满，则 <code>rear + 1</code></li><li>所以可得<code>rear</code> 的计算公式：<code>rear = (rear + 1) % arr.length</code></li></ul></blockquote><blockquote><ul><li>如果队未空，<ul><li>出队一个元素，<code>front + 1</code>，向右移一位，<code>rear</code>不变</li><li>当<code>front + 1 === arr.lenght</code> 时，则在下一次出队后，<code>front = 0</code></li></ul></li></ul></blockquote><blockquote><p><strong>因此出队：</strong></p><ul><li>出队时要判断当前队是否为空，如果为空，啥也不做。</li><li>如果队不为空，保存队尾的值，并返回</li><li>将当前队尾的值设为<code>null</code>,出队不是真的把这个元素从数组中删除,而是把指针移动到下一位,为了能看到效果,我们把出队的元素的位置值设置为null</li><li>接着改变<code>front</code>的位置，要判断 <code>front+1 === arr.length</code> 如果成立则出队后，<code>front = 0</code>，</li><li>如果不成立，则<code>front + 1</code></li><li>因此可得<code>front</code>的计算公式：<code>front = (front + 1) % arr.length</code></li></ul></blockquote><blockquote><ul><li>队满的条件：当<code>(rear + 1) % arr.lenght === front</code> 时，表示队满</li><li>队空的条件：当 <code>rear === front</code> 时，表示队空</li><li>重点强调：<strong>队列的容量 + 1 &#x3D; 数组的长度</strong><blockquote><ul><li>先进先出：从最左边开始入队，队列容量满了之后，出列时，也是从最左边开始出队(从队头删除元素)；</li><li><strong>但再次入队时</strong>，不是从最左边开始，而是入到<code>过渡项</code>：数组长度比队列容量多的那块；之后就是从最左边开始(此时的最左边相对于<code>front</code>来说是队尾)</li></ul></blockquote></li></ul></blockquote><blockquote><ul><li>用<code>Object.defineProperty()</code>方法，形成访问、设置<code>size</code>的接口<ul><li>get：返回私有变量<code>_size</code>的值</li><li>set：抛出错误，不允许更改</li></ul></li></ul></blockquote><pre><code>&gt;&lt;script&gt;  var Queue = (function () &#123;    var _queue = Symbol(&quot;queue&quot;);    var _front = Symbol(&quot;front&quot;);    var _rear = Symbol(&quot;rear&quot;);    function Queue(size = 100) &#123;      // 私有属性      this[_queue] = new Array(size + 1); // 队容器（固定长度）      this[_front] = 0; // 队头      this[_rear] = 0; // 队尾      // 实例属性      var _size = size;      Object.defineProperty(this, &quot;size&quot;, &#123;        get: function () &#123;          return _size;        &#125;,        set: function () &#123;          throw new Error(&quot;不允许设置size的值&quot;);        &#125;,      &#125;);    &#125;&gt;    // 队是否为空    Queue.prototype.isFull = function () &#123;      //   队满的条件      return (this[_rear] + 1) % this[_queue].length === this[_front];    &#125;;    // 队是否为空    Queue.prototype.isEmpty = function () &#123;      return this[_front] === this[_rear];    &#125;;    // 入队    Queue.prototype.enQueue = function (value) &#123;      //入队前要判断当前队列是否已满,如果已满,则啥也不做,抛出错误提示      if (this.isFull()) throw new Error(&quot;当前队列已满,不能再入队&quot;);&gt;      // 先在当前位置入队元素,然后指向右移动      this[_queue][this[_rear]] = value;      // 判断当前是不是在数组的最后面,最后一位就回到0      this[_rear] = (this[_rear] + 1) % this[_queue].length;      return true;    &#125;;    // 出队    Queue.prototype.deQueue = function () &#123;      // 出队前要判断当前队列是否为空      if (this.isEmpty()) throw new Error(&quot;当前队列已空,没有元素可出队&quot;);      // 只存要出队的元素      var deQueueValue = this[_queue][this[_front]];      // 出队不是真的把这个元素从数组中删除,而是把指针移动到下一位      // 为了能看到效果,我们把出队的元素的位置值设置为null      this[_queue][this[_front]] = null;      // 判断出对的指针是否指向了数组的最后面,如果是,则出队后指向0      this[_front] = (this[_front] + 1) % this[_queue].length;&gt;      return deQueueValue;    &#125;;&gt;    // 队头元素    Queue.prototype.getTop = function () &#123;      // 返回出队的元素,如果为null表示当前队列为空      return this[_queue][this[_front]];    &#125;;    // 查看队列元素    Queue.prototype.view = function () &#123;      var result = this[_queue].filter(function (item) &#123;        return item !== null;      &#125;);      return result;    &#125;;    // 清空队列    Queue.prototype.clear = function () &#123;      // 清空队列,就是重新初始化队列      this[_queue] = new Array(this.size + 1);      this[_front] = this[_rear] = 0;      return true;    &#125;;    return Queue;  &#125;)();&gt;&lt;/script&gt;</code></pre>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JS核心知识点（十三）</title>
      <link href="/2023/12/07/JS%E6%A0%B8%E5%BF%83%E7%9F%A5%E8%AF%86%E7%82%B9%EF%BC%88%E5%8D%81%E4%B8%89%EF%BC%89/"/>
      <url>/2023/12/07/JS%E6%A0%B8%E5%BF%83%E7%9F%A5%E8%AF%86%E7%82%B9%EF%BC%88%E5%8D%81%E4%B8%89%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<span id="more"></span><blockquote><p>什么是 BOM</p><ul><li>BOM（Browser Object Model）浏览器对象模型，是 JS 与浏览器窗口交互的接口</li><li>BOM 的核心是 window 对象，它表示浏览器的实例<blockquote><p>前面学过的定时器属于BOM相关内容</p></blockquote></li></ul></blockquote><h3 id="一、window-对象"><a href="#一、window-对象" class="headerlink" title="一、window 对象"></a>一、window 对象</h3><blockquote><ul><li><code>window</code>作为全局变量，代表了脚本正在运行的窗口，暴露给<code>Javascript</code>代码</li><li>在有标签页功能的浏览器中，每个标签都拥有自己的<code>window</code>对象</li><li>也就是说，同一个窗口的标签页之间<strong>不会共享</strong>一个<code>window</code>对象</li></ul></blockquote><blockquote><p>window对象有<strong>两重身份</strong></p><ul><li>在<code>ECMScript</code>中为<code>Global</code>对象，也就是后面常说的 <code>Node</code>中的全局对象。</li><li>在浏览器窗口中为<code>window</code>对象，所有全局作用域下的 <code>var</code>声明的全局变量和函数都是<code>window</code>对象的属性</li></ul></blockquote><ol><li>全局变量是 window 属性<blockquote><p>所有全局作用域下 var 声明的全局变量和函数都是<code>window</code>对象的属性</p></blockquote></li></ol><pre><code>var a = 2;// hasOwnProperty 检测当前对象是否拥有该属性console.log(window.hasOwnProperty(&quot;a&quot;)); // trueconsole.log(window.a); // 2console.log(window.a == a); // true</code></pre><blockquote><ul><li>多个 JS 文件之间是<strong>共享全局作用域</strong>的，即 JS 文件没有作用域隔离功能</li><li>创建<code>a.js</code>和<code>b.js</code>及<code>c.html</code>文件，在<code>c.html</code>页面引入<code>a.js</code>和<code>b.js</code></li></ul></blockquote><pre><code>// a.js文件代码如下var i=2;&gt;// b.js文件代码如下var i++;&lt;!-- c.html文件代码如下 --&gt;&gt;&lt;script src=&quot;js/a.js&quot;&gt;&lt;/script&gt;&gt;&lt;script src=&quot;js/b.js&quot;&gt;&lt;/script&gt;&gt;&lt;script&gt;  console.log(i); // 3&gt;&lt;/script&gt;</code></pre><ol start="2"><li><p>内置函数普遍是 window 对象的方法</p><blockquote><ul><li><code>setInterval()</code>、<code>alert()</code>、<code>Array</code>等普遍是 <code>window</code>的方法</li></ul></blockquote></li><li><p>浏览器窗口大小</p><blockquote><ul><li>window 对象身上的以下 4 个属性用来确定浏览器窗品大小</li></ul></blockquote></li></ol><table><thead><tr><th>属性名</th><th>说明</th></tr></thead><tbody><tr><td>innerWidth</td><td>返回浏览器窗口中页面可视区宽（不包含 浏览器边框和工具栏，包括滚动条）</td></tr><tr><td>innerHeight</td><td>返回浏览器窗口中页面可视区高（不包含 浏览器边框和工具栏，包括滚动条）</td></tr><tr><td>outerWidth</td><td>返回浏览器窗口自身的实际宽(浏览器边框、工具栏、滚动条)</td></tr><tr><td>outerHeight</td><td>返回浏览器窗口自身的实际高(浏览器边框、工具栏、滚动条)</td></tr></tbody></table><blockquote><ul><li>因为 innerWidth 和 innerHeight 包括了滚动条的宽和高，所以很多时候我们获取页面可视宽和高是通过：<code>document.body.clientWidth || document.documentElement.clientWidth</code>来实现，它不包括滚动条宽高、浏览器边框和工具栏</li></ul></blockquote><pre><code>// 浏览器窗口中页面视口大小 包括滚动条console.log(&quot;innerWidth:&quot; + window.innerWidth);console.log(&quot;innerHeight:&quot; + window.innerHeight);// 浏览器窗口大小console.log(&quot;outerWidth:&quot; + window.outerWidth);console.log(&quot;outerHeight:&quot; + window.outerHeight);&gt;// 页面可视区大小（不包括滚动条）console.log(&quot;clientWidth:&quot; + document.documentElement.clientWidth);console.log(&quot;clientHeight:&quot; + document.documentElement.clientHeight);</code></pre><ol start="4"><li>滚动距离<table><thead><tr><th>属性</th><th>说明</th></tr></thead><tbody><tr><td>window.scrollX</td><td>返回文档&#x2F;页面在水平方向滚动的像素值</td></tr><tr><td>window.scrollY</td><td>返回文档在垂直方向已滚动的像素值</td></tr><tr><td>window.pageXoffset</td><td>相当于 scrollX 的别名</td></tr><tr><td>window.pageYoffset</td><td>相当于 scrollY 的别名</td></tr></tbody></table></li></ol><blockquote><blockquote><p>通常获取页面的水平和垂直滚动距离还会通过如下代码获取</p></blockquote><ul><li>文档水平滚动距离：<code>document.documentElement.scrollLeft || document.body.scrollLeft</code></li><li>文档垂直滚动距离：<code>document.documentElement.scrollTop || document.body.scrollTop</code></li></ul></blockquote><pre><code>console.log(&quot;scrollX:&quot; + window.scrollX);console.log(&quot;scrollY:&quot; + window.scrollY);console.log(&quot;pageXoffset:&quot; + window.pageXOffset);console.log(&quot;pageYoffset:&quot; + window.pageYOffset);console.log(&quot;scrollTop:&quot; + document.documentElement.scrollTop);console.log(&quot;scrollLeft:&quot; + document.documentElement.scrollLeft);</code></pre><table><thead><tr><th>方法</th><th>说明</th></tr></thead><tbody><tr><td>scroll(x,y)</td><td>x，y表示相对视口距离的x和y坐标，<code>scroll(x,y)</code>表示文档滚动到<strong>指定坐标</strong>位置</td></tr><tr><td>scrollBy(x,y)</td><td>x表示水平方向上要滚动的<strong>偏移量</strong>，y表示垂直方向上要滚动的<strong>偏移量</strong></td></tr></tbody></table><blockquote><p>与按钮绑定：</p><ul><li><code>scroll(x,y)</code>只能点击一次，直接滚动条指定位置</li><li><code>scrollBy(x,y)</code>可多次点击，每次点击后移动指定距离</li></ul></blockquote><pre><code>&gt;&lt;style&gt;  html,  body &#123;    margin: 0;    padding: 0;    height: 3000px;    width: 3000px;  &#125;  button &#123;    width: 150px;    height: 50px;    position: fixed;    right: 50px;    top: 200px;  &#125;  .by &#123;    top: 280px;  &#125;&gt;&lt;/style&gt;&gt;&gt;&lt;button class=&quot;to&quot;&gt;滚动到指定位置&lt;/button&gt;&gt;&lt;button class=&quot;by&quot;&gt;滚动一定距离&lt;/button&gt;&gt;&gt;&lt;script&gt;  var button = document.getElementsByTagName(&quot;button&quot;);  button[0].onclick = function () &#123;    window.scroll(100, 200); // 点击后，跳转到与视口x=100,y=200的坐标位置  &#125;;&gt;  button[1].onclick = function () &#123;    // window.scrollBy(0, -100); // 每次点击，滚动条向上滚动 100px    window.scrollBy(0, 100); // 每次点击，滚动条向上滚动100px  &#125;;&gt;&lt;/script&gt;</code></pre><ol start="5"><li>window 其它属性<blockquote><p>重点提示</p><ul><li>因为 window 对象的属性在全局作用域中有效，所以很多浏览器<code>API</code>及相关构造函数等都以<code>window</code>对象属性的形式暴露出来</li><li>总结一句话：window 对象身上的属性<strong>并非全是</strong>与 BOM 操作相关的方法和属性<br>接下来我们学习<code>window</code>对象身上与<code>BOM</code>相关的属性</li></ul></blockquote></li></ol><table><thead><tr><th>属性</th><th>说明</th></tr></thead><tbody><tr><td>location</td><td>获取当前页面的 URL信息</td></tr><tr><td>history</td><td>对象提供了操作浏览器会话历史的接口</td></tr><tr><td>navigator</td><td>对象包含用户此次活动的浏览器的相关属性和标识</td></tr></tbody></table><h3 id="二、window-location-对象"><a href="#二、window-location-对象" class="headerlink" title="二、window.location 对象"></a>二、window.location 对象</h3><blockquote><ul><li><code>window.location</code>只读属性，返回一个 <code>Location</code>对象，其中包含有关文档<strong>当前位置</strong>的信息。</li><li><code>Location</code>接口表示其链接到的对象的位置（URL）<ul><li><code>location.__proto__ === Location.prototype; // true</code><blockquote><p>强调：location 对象虽然是只读属性，但它比较特殊，可以赋值，重新赋值URL，相当于跳转到URL</p></blockquote></li></ul></li></ul></blockquote><pre><code>// 跳转到  http://www.icodingedu.com 这个页面window.location = &quot;http://www.icodingedu.com&quot;;</code></pre><ol><li>URL 组成部分<blockquote><ul><li><code>URL（Uniform Resource Locator）</code>统一资源定位符</li><li>URL 无非就是一个给定的独特资源在 Web 上的地址</li><li>理论上说，每个有效的 URL 都指向一个唯一的资源</li><li>这个资源可以是一个 HTML 页面，一个 CSS 文档，一幅图像，等等</li></ul></blockquote></li></ol><pre><code>protocol://host[:port]/path/[?query]#fragment  /* [] 方括号表示可选 */http://www.arryblog.com/guide/html5/html5.html?targetId=12&amp;preview=0#top</code></pre><table><thead><tr><th>组成</th><th>说明</th></tr></thead><tbody><tr><td>protocol</td><td>URL 对应的协议名，常用的协议有：http、https、ftp、maito、file等</td></tr><tr><td>host</td><td>主机（域名），如 <code>www.arryblog.com</code></td></tr><tr><td>port</td><td>网络端口号，可选。如果省略，表示使用默认的端口。如 http 的默认端口是 80</td></tr><tr><td>path</td><td>路径，用来表示服务器上的一个目录或文件路径 如：<code>guide/html5/html5.html</code></td></tr><tr><td>query</td><td>查询字符串（参数），以键值对的形式表示，多个用&amp;符号分隔，如：<code>targetId=12&amp;preview=0</code></td></tr><tr><td>fragment</td><td>片段标识符，#后内容，用来标记已获取资源的文档内的某个位置。如：常见锚点 <code>#top</code></td></tr></tbody></table><ol start="2"><li>location 对象的属性<blockquote><ul><li>location对象上有很多属性，以下就是其中的一部分</li></ul></blockquote></li></ol><table><thead><tr><th>属性</th><th>说明</th></tr></thead><tbody><tr><td>location.href</td><td>获取完整的 URL，也可以重新设置 URL</td></tr><tr><td>location.host</td><td>获取主机名（域名）</td></tr><tr><td>location.port</td><td>获取端口号，如果端口号省略，返回空字符串””</td></tr><tr><td>location.pathname</td><td>返回 URL 中 path 路径部分</td></tr><tr><td>location.search</td><td>返回 URL 中的 query 查询字符串部分内容</td></tr><tr><td>location.hash</td><td>返回 URL 中的 fragment 部分内容。</td></tr></tbody></table><ol start="3"><li>处理 URL 中 query 部分数据<blockquote><ul><li>写一个<strong>函数</strong>，把 URL 中的 query 部分参数转换成对象中的属性和值，然后将这个对象返回，同时要考虑参数的类型。</li><li>MDN 官方参考地址：<code>https://developer.mozilla.org/zh-CN/docs/Web/API/Window/location</code></li></ul></blockquote></li></ol><pre><code>// location.search得到 URL中的query数据&quot;?targetId=99&amp;sort=hot&amp;bool=true&amp;name=张三&quot;&gt;// 最终转换成下面这样一个对象&#123; targetId: 99, sort: &#39;hot&#39;, bool: true, name: &#39;张三&#39;&#125;</code></pre><ul><li>思路：<blockquote><p><strong>写一个函数，将传入的查询字符串query，处理成对象形式</strong></p><ul><li>第一步：去掉问号<code>slice(start);</code>，如果只有问号，就返回空对象</li><li>第二步：分割<code>&amp;</code>前后的数据<code>split(&quot;&amp;&quot;)</code>，并返回一个数组</li><li>第三步：将数组中的每一项，以键值对的形式存入一个对象中<ul><li>遍历每一项，先用&#x3D;分隔，形成一个新数组</li><li>再将新数组的每一项分别存成<code>key</code>和<code>value</code></li></ul></li><li>第四步：给<code>value</code>转码，将已编码 URI 中所有能识别的转义序列转换成原字符<ul><li><code>decodeURIComponent()</code>：用于解码由 <code>encodeURIComponent</code>方法或者其他类似方法编码的部分统一资源标识符（URI）<blockquote><p>此时，返回的对象的值都是字符串的形式</p></blockquote></li></ul></li><li>第五步：处理数据类型</li></ul></blockquote></li></ul><blockquote><p><strong>因此，还要写个代码，转换数据类型</strong></p><ul><li>查询字符串query一定是<strong>基本数据类型</strong></li><li>考虑传过来的值是不是空的&#x2F;<code>&quot;  &quot;</code>&#x2F;<code>null</code>&#x2F;<code>undefined</code>，如果为空就返回<code>null</code></li><li><code>.trim()</code>：从字符串的两端移除空白字符，并返回一个新的字符串<ul><li><code>null==undefined</code></li></ul></li><li>其次考虑布尔类型<ul><li><code>.toLowerCase()</code>：将该字符串转换为小写形式</li></ul></li><li>再次考虑数值<ul><li><code>parseFloat()</code>：将给定值解析成浮点数</li><li><code>isFinite()</code>：用来判断被传入的参数值是否为一个有限数值,是的话返回<code>true</code></li></ul></li><li>最后考虑是否为日期<ul><li><code>Date.parse()</code>：解析一个表示某个日期的字符串，并返回一个毫秒数，如果该字符串无法识别，则返回值为 NaN。</li><li><code>Date() 构造函数</code>：可以创建一个Date实例或返回代表当前时间的字符串</li></ul></li><li>如果上面的都不是，就只能是字符串了</li></ul></blockquote><pre><code>&gt;&lt;script&gt;  var search = &quot;?targetId=99&amp;sort=hot&amp;bool=true&amp;name=张三&quot;;  var paramObj = getVars(search);  console.log(paramObj);  //将query转换成一个对象，并考虑数据类型&gt; /**&gt;  * getVars 将取得的查询参数以键值对形式存到对象中，同时考虑数据类型&gt;  * @param search查询的字符串内容&gt;  */  function getVars(search) &#123;    var obj = &#123;&#125;;    if (search.length === 1) return &#123;&#125;; //如果只有?就返回空对象    var arr = search.slice(1).split(&quot;&amp;&quot;);    arr.forEach(function (item) &#123;      var keyValue = item.split(&quot;=&quot;);      var key = keyValue[0];      var value = keyValue[1];      //解码      obj[key] = transferValue(decodeURIComponent(value));    &#125;);    return obj;  &#125;&gt;  //处理数据类型的函数  function transferValue(value) &#123;    //先考虑传入的值是否为空、null、undfined、&quot;  &quot;    if (value == undefined || value.trim() == &quot;&quot;) return null;    //考虑布尔值    if (value.toLowerCase() === &quot;true&quot;) return true;    if (value.toLowerCase() === &quot;false&quot;) return false;    //考虑数值    if (isFinite(value)) return parseFloat(value);    //考虑日期    if (isFinite(Date.parse(value))) return new Date(value);    return value;  &#125;&gt;&lt;/script&gt;</code></pre><ol start="4"><li>数据交互 - 根据参数显示页面内容<blockquote><ul><li><code>index.html</code>表示首页，用来显示产品列表</li><li><code>goods.html</code>表示产品详细页，根据 URL 中的参数来决定显示那个产品的详细信息</li><li>当点击<code>index.html</code>页面的产品名，就会跳转到<code>goods.html</code>页面，显示对应产品的详细信息</li></ul></blockquote></li></ol><ul><li><p>思路：</p><blockquote><ul><li>后端提供一个接口数据，里面放着<code>query</code>数据、产品信息(图片、标题、价格)</li><li><code>index.html</code>里面放的是a标签，它是由JS动态生成的，因为它的<code>href</code>放的是文件路径和<code>targetId</code></li><li><code>goods.html</code>里面放的是产品信息，也需要根据不同的<code>targetId</code>来创建</li><li>当本页面的<code>targetId</code>等于接口数据里<code>targetId</code>时，就提取该ID下的信息，并创建HTML节点，渲染出商品页面</li><li>要取得本页面的<code>targetId</code>，就需要用前面写的函数处理<code>location.search</code><blockquote><p>只有当我们从<code>index.html</code>页面跳转到<code>goods.html</code>时，<code>goods.html</code>才会获得相应的<code>targetId</code></p></blockquote></li></ul></blockquote></li><li><p><code>index.html</code> 页面源代码</p></li></ul><pre><code>&gt;&lt;ul class=&quot;container&quot;&gt;  &lt;!-- &lt;li&gt;    &lt;a href=&quot;./06-goods.html?targetID=93&quot;&gt;      Web前端高级工程师系统课-星辰班    &lt;/a&gt;  &lt;/li&gt;  &lt;li&gt;    &lt;a href=&quot;./06-goods.html?targetID=91&quot;&gt; 30个HTML+CSS实战小案例详解 &lt;/a&gt;  &lt;/li&gt;  &lt;li&gt;    &lt;a href=&quot;./06-goods.html?targetID=77&quot;      &gt;云原生Kubernetes与云上DevOps新版系统实战课    &lt;/a&gt;  &lt;/li&gt; --&gt;&gt;&lt;/ul&gt;&gt;&lt;script&gt;  var data = [    &#123;      targetId: 93,      title: &quot;Web前端高级工程师系统课-星辰班&quot;,      mainImage:        &quot;https://sce7a2b9c9d95a-sb-qn.qiqiuyun.net/files/course/2022/08-29/210311f40bcf290736.jpg&quot;,      price: 8680,    &#125;,    &#123;      targetId: 91,      title: &quot;30个HTML+CSS实战小案例详解&quot;,      mainImage:        &quot;https://sce7a2b9c9d95a-sb-qn.qiqiuyun.net/files/course/2022/03-19/174949d70767470556.jpg&quot;,      price: 0,    &#125;,    &#123;      targetId: 77,      title: &quot;云原生Kubernetes与云上DevOps新版系统实战课&quot;,      mainImage:        &quot;https://sce7a2b9c9d95a-sb-qn.qiqiuyun.net/files/course/2020/07-14/122139326c0d505110.png&quot;,      price: 2680,    &#125;,  ];  var oUL = document.querySelector(&quot;.container&quot;);  data.forEach(function (item) &#123;    var li = document.createElement(&quot;li&quot;);    var a = document.createElement(&quot;a&quot;);    a.href = &quot;./06-goods.html?targetId=&quot; + item.targetId;    a.innerText = item.title;    a.target = &quot;blank&quot;;    li.appendChild(a);    oUL.appendChild(li);  &#125;);&gt;&lt;/script&gt;</code></pre><ul><li><code>goods.html</code> 页面源代码</li></ul><pre><code>&gt;&lt;div class=&quot;show&quot;&gt;  &lt;!-- &lt;img    src=&quot;https://sce7a2b9c9d95a-sb-qn.qiqiuyun.net/files/course/2022/08-29/210311f40bcf290736.jpg&quot;    alt=&quot;&quot;  /&gt;  &lt;h3&gt;Web前端高级工程师系统课-星辰班&lt;/h3&gt;  &lt;p&gt;价格：8680&lt;/p&gt; --&gt;&gt;&lt;/div&gt;&gt;&lt;script src=&quot;./getVars.js&quot;&gt;&lt;/script&gt;&gt;&lt;script&gt;  var data = [    &#123;      targetId: 93,      title: &quot;Web前端高级工程师系统课-星辰班&quot;,      mainImage:        &quot;https://sce7a2b9c9d95a-sb-qn.qiqiuyun.net/files/course/2022/08-29/210311f40bcf290736.jpg&quot;,      price: 8680,    &#125;,    &#123;      targetId: 91,      title: &quot;30个HTML+CSS实战小案例详解&quot;,      mainImage:        &quot;https://sce7a2b9c9d95a-sb-qn.qiqiuyun.net/files/course/2022/03-19/174949d70767470556.jpg&quot;,      price: 0,    &#125;,    &#123;      targetId: 77,      title: &quot;云原生Kubernetes与云上DevOps新版系统实战课&quot;,      mainImage:        &quot;https://sce7a2b9c9d95a-sb-qn.qiqiuyun.net/files/course/2020/07-14/122139326c0d505110.png&quot;,      price: 2680,    &#125;,  ];  var show = document.querySelector(&quot;.show&quot;);  var search = location.search;  var Vars = getVars(search);  data.forEach(function (item) &#123;    if (item.targetId === Vars.targetId) &#123;      var frag = document.createDocumentFragment();      var img = document.createElement(&quot;img&quot;);      img.src = item.mainImage;      frag.appendChild(img);      var h3 = document.createElement(&quot;h3&quot;);      h3.innerText = item.title;      frag.appendChild(h3);      var p = document.createElement(&quot;p&quot;);      var price = item.price === 0 ? &quot;免费&quot; : item.price;      p.innerText = &quot;价格：&quot; + price;      frag.appendChild(p);      show.appendChild(frag);    &#125;  &#125;);&gt;&lt;/script&gt;</code></pre><ol start="5"><li>404 页面，定时跳转功能<blockquote><ul><li>写一个定时器，做倒计时效果</li><li>当倒计时结束，就改变页面的<code>url</code>，使其跳转到另一个页面</li></ul></blockquote></li></ol><pre><code>&gt;&lt;style&gt;    body &#123;      margin: 0;      display: flex;      justify-content: center;    &#125;    span &#123;      font-size: 50px;      color: red;    &#125;&gt;&lt;/style&gt;&gt;&lt;/head&gt;&gt;&lt;body&gt;&gt;  &lt;p&gt;&lt;span class=&quot;time&quot;&gt;5&lt;/span&gt;秒后，跳转到首页&lt;/p&gt;&gt;&lt;script&gt;  var span = document.querySelector(&quot;.time&quot;);  var sum = 5;  var timer = setInterval(function () &#123;    sum--;    span.innerText = sum;    if (sum &lt;= 0) &#123;      clearInterval(timer);      location.href = &quot;https://www.icodingedu.com/&quot;;    &#125;  &#125;, 1000);&gt;&lt;/script&gt;</code></pre><ol start="6"><li>location 对象的方法<blockquote><p>以下是<code>location</code>对象身上的一些常见的方法</p></blockquote></li></ol><table><thead><tr><th>方法名</th><th>说明</th></tr></thead><tbody><tr><td>assign</td><td><code>location.assign()</code>方法会触发窗口加载并显示指定的<code>URL</code>的内容，类似<code>location.href</code>；<strong>会有历史记录</strong>，可通过前进和后退按扭来追回历史页；如果传入一个无效的 URL，则会抛出一个<code>syntax_error</code>语法错误</td></tr><tr><td>replace</td><td>用给定的URL替换掉当前的资源，<strong>不会有历史记录</strong>，即不能用后退回到原页面</td></tr><tr><td>reload</td><td>重新加载当前页面，相当于刷新按扭或F5；如果参数 为<code>true</code>，表示强制刷新<code>ctrl + F5</code>，即：要<strong>从服务器上</strong>加载数据；如果参数为<code>false</code>，表示浏览器优先从缓存当中加载页面</td></tr></tbody></table><pre><code>&gt;&lt;script&gt;  document.onclick = function () &#123;    // assign 相当于href，跳转到一个新的页面    location.assign(&quot;https://www.baidu.com/&quot;);    // 用给定URL替换当前面 不会产生历史记录    location.replace(&quot;https://www.baidu.com/&quot;);    location.reload(true); // 强制制新，重新从服务器加载数据  &#125;;&gt;&lt;/script&gt;</code></pre><h3 id="三、window-history-对象"><a href="#三、window-history-对象" class="headerlink" title="三、window.history 对象"></a>三、window.history 对象</h3><blockquote><ul><li><code>Window.history</code>是一个只读属性，用来获取<code>History</code>对象的引用，<code>History</code>对象提供了操作浏览器<strong>会话历史</strong>的接口<br>window.history对象相关方法</li></ul></blockquote><table><thead><tr><th>方法</th><th>作用</th></tr></thead><tbody><tr><td>back</td><td>后退功能，返回上一页，相当于用户点击了浏览的 <code>←</code> 等价 <code>history.go(-1)</code></td></tr><tr><td>forward</td><td>前进功能，进入下一页，相当于用户点击了浏览的 <code>➔</code> 等价<code>history.go(1)</code></td></tr><tr><td>go</td><td>前进与后退，当参数为<code>1</code>，表示进入下一页；当参数为<code>-1</code>，表示退回上一页，如果参数为<code>0</code>，则重新载入当前页面</td></tr></tbody></table><pre><code>history.back(); // 后退history.forward(); // 前进history.go(1); // 前进 进入下一页</code></pre><h3 id="四、navigator-对象"><a href="#四、navigator-对象" class="headerlink" title="四、navigator 对象"></a>四、navigator 对象</h3><blockquote><ul><li><code>window.navigator</code>对象包含用户此次活动的浏览器的相关属性和标识</li><li>他有很多属性，但最常用的是 <code>userAgent</code> 这个属性</li><li><code>userAgent</code> 属性返回当前浏览器的用户代理字符串</li><li><code>navigator.userAgent; // 返回用户代理（浏览器）相关信息</code><blockquote><p>我们通常利用这个<code>userAgent</code>属性来判断当前的打开页面的浏览器和设备</p></blockquote></li></ul></blockquote><ol><li>检测浏览器并返回浏览器名称<blockquote><ul><li>以下代码来自MDN：<a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Window/navigator">https://developer.mozilla.org/zh-CN/docs/Web/API/Window/navigator</a></li></ul></blockquote></li></ol><pre><code>function BrowserName() &#123;  var sBrowser,    sUsrAg = navigator.userAgent;  if (sUsrAg.indexOf(&quot;Firefox&quot;) &gt; -1) &#123;    sBrowser = &quot;Mozilla Firefox&quot;; // 火狐  &#125; else if (sUsrAg.indexOf(&quot;Opera&quot;) &gt; -1 || sUsrAg.indexOf(&quot;OPR&quot;) &gt; -1) &#123;    sBrowser = &quot;Opera&quot;; // 欧朋  &#125; else if (sUsrAg.indexOf(&quot;Trident&quot;) &gt; -1) &#123;    sBrowser = &quot;Microsoft Internet Explorer&quot;;  &#125; else if (sUsrAg.indexOf(&quot;Edge&quot;) &gt; -1) &#123;    sBrowser = &quot;Microsoft Edge&quot;; //Edge浏览器  &#125; else if (sUsrAg.indexOf(&quot;Chrome&quot;) &gt; -1) &#123;    sBrowser = &quot;Google Chrome or Chromium&quot;; // Chrome  &#125; else if (sUsrAg.indexOf(&quot;Safari&quot;) &gt; -1) &#123;    sBrowser = &quot;Apple Safari&quot;; // Safari  &#125; else &#123;    sBrowser = &quot;unknown&quot;; // 不知道  &#125;  return sBrowser;&#125;</code></pre><ol start="2"><li>判断是否为微信环境<blockquote><ul><li><code>micromessenger</code>为微信内嵌的浏览器，有此标识的基本上可以判断是微信环境，但此标识也<strong>可以伪造</strong></li></ul></blockquote></li></ol><pre><code>// 判断是否为微信const isWx = function () &#123;  var ua = window.navigator.userAgent.toLowerCase();  if (ua.indexOf(&quot;micromessenger&quot;) !== -1) return true;  return false;&#125;;</code></pre><p>3、设备判断：android、ios、web</p><pre><code>function isDevice() &#123;  if (/(iPhone|iPad|iPod|iOS)/i.test(navigator.userAgent)) &#123;    return &quot;iOS&quot;;  &#125; else if (/(Android)/i.test(navigator.userAgent)) &#123;    return &quot;Android&quot;;  &#125;  return &quot;Web&quot;;&#125;</code></pre><blockquote><blockquote><p>注：</p></blockquote><ul><li>i：代表不区分大小写匹配</li><li><code>()</code>是为了提取匹配字符串的，表达式中有几个<code>()</code>，就有几个相应的匹配字符串</li></ul></blockquote><h3 id="五、window-相关事件"><a href="#五、window-相关事件" class="headerlink" title="五、window 相关事件"></a>五、window 相关事件</h3><blockquote><p>接下来我们学习几个非常重要的事件</p></blockquote><table><thead><tr><th>事件名</th><th>说明</th></tr></thead><tbody><tr><td>load</td><td>整个页面（包括所有外部资源，如：图片、JavaScript 文件和 CSS 文件）加载完成后触发，这里指的是<code>window</code>身上的load事件</td></tr><tr><td>DOMContentLoaded</td><td>在 DOM 树构建完成后立即触发，不用等待图片、JavaScript 文件、CSS 文件或其它资源加载完成。</td></tr><tr><td>resize</td><td>当调整浏览器的窗口大小时，会触发 resize 事件；resize 事件触发会很频繁，所以我们在处理时，可以设置<strong>节流</strong>操作</td></tr><tr><td>scroll</td><td>当浏览器滚动条发生滚动时触发<code>window.onsrcoll</code>事件</td></tr></tbody></table><blockquote><blockquote><p><code>DOMContentLoaded</code>事件的实际目标是<code>document</code>，但会冒泡到<code>window</code>；所以我们可以在<code>document</code>上监听这个事件</p></blockquote></blockquote><h4 id="load-和-DOMContentLoaded-事件"><a href="#load-和-DOMContentLoaded-事件" class="headerlink" title="load 和 DOMContentLoaded 事件"></a>load 和 DOMContentLoaded 事件</h4><blockquote><ul><li>load ：<strong>整个页面</strong>（包括所有外部资源，如：图片、JavaScript 文件和 CSS 文件）加载完成后触发</li><li>DOMContentLoaded ：<strong>在 <code>DOM</code> 树构建完成后</strong>立即触发，不用等待图片、JavaScript 文件、CSS 文件或其它资源加载完成。<blockquote><p><code>DOMContentLoaded</code>事件始终在<code>load</code>事件之前发生</p></blockquote></li></ul></blockquote><pre><code>console.log(&quot;我第一个出来&quot;);// DOM树构建完成时触发window.addEventListener(&quot;DOMContentLoaded&quot;, function () &#123;  alert(&quot;我第二个出来&quot;);&#125;);// 页面加载完成后触发window.onload = function () &#123;  alert(&quot;我第三个出来&quot;);&#125;;</code></pre><ul><li>除了页面加完会触发 load 事件外，其它元素也会触发与之对应的 load 的事件<table><thead><tr><th>元素</th><th>说明</th></tr></thead><tbody><tr><td><code>&lt;img&gt;</code>标签</td><td>图片会在<strong>图片加载完成后</strong>触发 load 事件；<strong>图片并不需要插入到页面</strong>。只要 img 对象添加 src 属性，就会发起 http 请求，下载成功就会触发 load 事件</td></tr><tr><td><code>&lt;script&gt;</code>标签</td><td>在 <strong>JS 加载完后</strong>会触发 load 事件；不过<code>&lt;script&gt;</code>标签要指定 src 属性，<strong>同时要插入到文档中</strong>，才会发起 http 请求，下载成功才会触发 load 事件</td></tr><tr><td><code>&lt;link&gt;</code>标签</td><td>需要指定<code>&lt;link&gt;</code>标签的<code>href</code>属性，<strong>同时要插入到文档中</strong>，才会发起 http 请求，在 <strong>CSS 文件</strong>全部加载完成后会触发 load 事件</td></tr></tbody></table></li></ul><ol><li>动态加载图片，插入页面<blockquote><p>load 加载成功，触发 load 事件</p><ul><li>图片加载完成后触发<code>load</code>事件，图片并不需要插入到页面。</li><li>只要 img 对象添加<code>src</code>属性，就会发起<code>http</code>请求，下载成功就会触发<code>load</code>事件</li><li><code>error</code>加载失败，触发<code>error</code>事件</li></ul></blockquote></li></ol><pre><code>&gt;/**&gt; * loadImg 动态加载图片&gt; * @param url 图片地址&gt; */function loadImg(url) &#123;  var img = new Image(); // 创建img对象  // 图片加载成功，插入到页面  img.onload = function () &#123;    // alert(&#39;加载成功&#39;)    document.body.appendChild(img);  &#125;;  // 图片加载失败，在页面显示图片加载失败  img.onerror = function () &#123;    document.body.innerText = &quot;图片加载失败&quot;;  &#125;;  img.src = url;&#125;&gt;var url =  &quot;https://sce7a2b9c9d95a-sb-qn.qiqiuyun.net/files/course/2022/08-29/210311f40bcf290736.jpg&quot;;loadImg(url);</code></pre><ol start="2"><li>动态加载 JS<blockquote><ul><li>在 JS 加载完后会触发 load 事件</li><li>不过<code>&lt;script&gt;</code>标签要指定 src 属性，同时<strong>要插入到文档中</strong>，才会发起 http 请求，下载成功才会触发 load 事件。</li></ul></blockquote></li></ol><pre><code>&gt;/**&gt; * loadScript 动态加载JS文件&gt; * @param src js文件地址&gt; * @param callback回调函数，js加载完成后，要处理的事情&gt; */function loadScript(src, callback) &#123;  var script = document.createElement(&quot;script&quot;);  script.onload = function () &#123;    typeof callback === &quot;function&quot; ? callback() : callback;  &#125;;  script.onerror = function () &#123;    alert(&quot;加载失败&quot;);  &#125;;  // 指定src属性值，并插入到页面中  script.src = src;  document.body.appendChild(script); // 不插入到页面，load事件永远不会触发&#125;&gt;loadScript(&quot;./a.js&quot;, function () &#123;  alert(&quot;加载成功&quot;);&#125;);</code></pre><ol start="3"><li>动态加载 CSS<blockquote><ul><li>在 CSS 文件全部加载完成后会触发 load 事件</li><li>和<code>&lt;script&gt;</code>标签一样，需要指定 <code>href</code> 属性值，并且要把<code>&lt;link&gt;</code>标签插入到文档发中才会开始下载 <code>CSS</code> 样式，下载完成后才会触发 <code>load</code> 事件</li><li>要设置<code>link.rel = &quot;stylesheet&quot;;</code></li><li><code>&lt;link&gt;</code>标签是插入到<code>head</code>标签里面，不是<code>document</code></li></ul></blockquote></li></ol><pre><code>&gt;/**&gt; * 动态插入外链css&gt; * href css外链地址&gt; */function loadCSS(href) &#123;  var link = document.createElement(&quot;link&quot;);  link.rel = &quot;stylesheet&quot;;  link.addEventListener(    &quot;load&quot;,    function () &#123;      alert(&quot;css加载成功&quot;);    &#125;,    false  );  link.href = href;  // 把link标签插入到head标签中  var head = document.getElementsByTagName(&quot;head&quot;)[0];  head.appendChild(link);&#125;loadCSS(&quot;./index.css&quot;);</code></pre><h4 id="resize-事件"><a href="#resize-事件" class="headerlink" title="resize 事件"></a>resize 事件</h4><blockquote><ul><li>当调整浏览器的窗口大小时，会触发<code>resize</code>事件</li><li><code>resize</code>事件触发会很频繁，所以我们在处理时，可以设置节流操作</li></ul></blockquote><pre><code>var a = 0;window.onresize = throttle(fn, 50);function fn() &#123;  console.log(a++);&#125;&gt;&gt;/**&gt; * 节流函数&gt; * fn 事件处理函数&gt; * delay 函数执行间隔时间&gt; */function throttle(fn, delay) &#123;  var timer = null;&gt;  return function () &#123;    var self = this;    var args = arguments;    if (timer) return;    timer = setTimeout(function () &#123;      // 函数体执行代码      fn.apply(self, args);      // 开锁      timer = null;    &#125;, delay);  &#125;;&#125;</code></pre><h4 id="srcoll-事件"><a href="#srcoll-事件" class="headerlink" title="srcoll 事件"></a>srcoll 事件</h4><blockquote><ul><li>当浏览器滚动条发生滚动时触发<code>window.onsrcoll</code>事件</li><li>如果<strong>某个元素</strong>内的内容溢出，显示了滚动条，滚动对应的滚动条，也会触发对应的<code>scroll</code>事件</li><li><code>scroll</code>事件的触发频率也非常的快，所以了要根据实际业务场景来添加节流操作</li></ul></blockquote><pre><code>&gt;&lt;style&gt;  .body &#123;    margin: 0;    height: 3000px;  &#125;  .box &#123;    width: 200px;    height: 300px;    margin: 100px;    border: 1px solid #000;    overflow-y: scroll;  &#125;  p &#123;    width: 100%;    height: 800px;    margin: 0;    background-color: khaki;  &#125;&gt;&lt;/style&gt;&gt;&lt;div class=&quot;box&quot;&gt;&gt;  &lt;p&gt;&gt;    我是一段内容我是一段内容我是一段内容我是一段内容我是一段内容我是一段内容我是一段内容&gt;  &lt;/p&gt;&gt;&lt;/div&gt;&gt;&lt;script&gt;  var box = document.querySelector(&quot;.box&quot;);  var a = 0;  //浏览器的scroll事件  window.onscroll = throttle(fn, 300);  function fn() &#123;    console.log(a++);  &#125;  //元素的scroll事件  box.onscroll = throttle(fn1, 300);  function fn1() &#123;    console.log(&quot;box&quot;);  &#125;&gt;&gt; /**&gt;  * 节流函数&gt;  * fn 事件处理函数&gt;  * delay 函数执行间隔时间&gt;  */  function throttle(fn, delay) &#123;    var timer = null;&gt;    return function () &#123;      var self = this;      var args = arguments;      if (timer) return;      timer = setTimeout(function () &#123;        // 函数体执行代码        fn.apply(self, args);        // 开锁        timer = null;      &#125;, delay);    &#125;;  &#125;&gt;&lt;/script&gt;</code></pre><h4 id="案例1：返回顶部"><a href="#案例1：返回顶部" class="headerlink" title="案例1：返回顶部"></a>案例1：返回顶部</h4><blockquote><ul><li>实现效果：点击返回顶部按扭，页面滚动到最顶部，即滚动条与浏览器顶部的滚动距离<strong>不断的减小</strong>(不是直接到顶部)，直到减少到 0</li></ul></blockquote><ol><li>限定步长的匀速运动<blockquote><p>实现方式有三种</p><ul><li>1、不断减小<code>window.scroll(x,y)</code>中 y 的值，直到y &lt;&#x3D; 0</li><li>2、通过<code>window.scrollBy(x,y)</code> 方法，每次向上移动一点距离，直到<code>window.scrollY &lt;= 0</code></li><li>3、通过不断减小<code>document.documentElement.scrollTop</code>的值，直到 <code>&lt;= 0</code></li></ul></blockquote></li></ol><ul><li>三种实现方式的通用布局</li></ul><pre><code>&gt;&lt;style&gt;  #back-top &#123;    width: 80px;    height: 80px;    background-color: #ddd;    text-align: center;    line-height: 80px;    cursor: pointer;    position: fixed;    right: 10px;    bottom: 100px;  &#125;  body &#123;    height: 3000px;  &#125;&gt;&lt;/style&gt;&gt;&gt;&lt;div id=&quot;back-top&quot;&gt;返回顶部&lt;/div&gt;</code></pre><ul><li>实现方式1<blockquote><p>使用 <code>window.scroll(x,y)</code> 和 <code>window.scrollY</code></p><ul><li>点击后，首先获取当前滚动条滚动的距离<code>scrollY = window.scrollY</code></li><li>然后开启一个定时器，隔一定时间让<code>window.scroll(0,y)</code>中 <code>y</code> 的值减小 100 ，直到<code>window.scrollY &lt;= 0</code>，说明滚动条滚动到页面的顶部，然后暂停定时器</li><li>添加 <code>lock</code> 变量，用来防止当次滚动没有结束前，再次执行新的动画</li></ul></blockquote></li></ul><pre><code>&gt;&lt;script&gt;  var backTop = document.getElementById(&quot;back-top&quot;);  // 第一套方案 window.scroll();  var timer = null;  var lock = false; // 可以点击  // 点击事件  backTop.onclick = function () &#123;    // 获取滚动条与浏览器顶部的距    if (lock) return;    lock = true;    var scrollY = window.scrollY; // 把他放在外面，不用频繁的读他    timer = setInterval(function () &#123;      scrollY -= 100;      if (scrollY &lt;= 0) &#123;        clearInterval(timer);        lock = false;      &#125;      window.scroll(0, scrollY);    &#125;, 20);  &#125;;&gt;&lt;/script&gt;</code></pre><ul><li>实现方式二<blockquote><p>使用 <code>window.scrollBy</code> 和 <code>window.scrollY</code></p><ul><li>通过<code>window.scrollBy(x,y)</code> 方法，每次向上移动一点距离，直到<code>window.scrollY &lt;= 0</code></li><li>添加 <code>lock</code> 变量，用来防止当次滚动没有结束前，再次执行新的动画</li></ul></blockquote></li></ul><pre><code>&gt;&lt;script&gt;  var backTop = document.getElementById(&quot;back-top&quot;);  // 第一套方案 window.scroll();  var timer = null;  var lock = false; // 可以点击&gt;  // 点击事件  backTop.onclick = function () &#123;    // 获取滚动条与浏览器顶部的距离    if (lock) return;    lock = true;&gt;    timer = setInterval(function () &#123;      var scrollY = window.scrollY;       if (scrollY &lt;= 0) &#123;        clearInterval(timer);        lock = false;      &#125;      window.scrollBy(0, -20);    &#125;, 20);  &#125;;&gt;&lt;/script&gt;</code></pre><ul><li>实现方式三<blockquote><p>使用 <code>document.documentElement.scrollTop</code> 来实现</p><ul><li>首先获取当前滚动条滚动过的距离<code>document.documentElement.scrollTop</code></li><li><code>Element.scrollTop</code>属性可以<strong>获取或设置</strong>一个元素的内容垂直滚动的像素数。</li><li>开启定时器，不断的减小<code>scrollTop</code> 的值，直到 <code>&lt;= 0</code></li><li>添加 <code>lock</code> 变量，用来防止当次滚动没有结束前，再次执行新的动画</li></ul></blockquote></li></ul><pre><code>&gt;&lt;script&gt;  var backTop = document.getElementById(&quot;back-top&quot;);  backTop.addEventListener(&quot;click&quot;, backToTop, false);  var lock = false;  function backToTop() &#123;    if (lock) return;    lock = true;    // 获取当前滚动条滚动的距离    var doc = document.documentElement || document.body;    var top = doc.scrollTop;    clearInterval(this.timer); // 多次点击无效，以最后一次为主    var that = this; // 保存this，在定时器内需要用到&gt;    this.timer = setInterval(function () &#123;      if (top &lt;= 0) &#123;        clearInterval(that.timer); // 如果top小于0清除定时器        lock = false;      &#125; else &#123;        top = top - 100; // 每次减 100        doc.scrollTop = top; // 动态更改滚动条件与浏览器的滚动的距离      &#125;    &#125;, 20);  &#125;&gt;&lt;/script&gt;</code></pre><ol start="2"><li>限时匀速运动——最佳实践<blockquote><ul><li>T：<code>time</code>已经运动的时间</li><li>B：<code>begin</code>开始位置</li><li>C： <code>change</code>需要移动的总距离 &#x3D; Target - Begin</li><li>D： <code>duration</code>动画运动的总时间 </li><li>每次运动后，滚动条要到的位置(距顶部的距离)：<code>CurrentDistance = T / D * C + B</code> 即：<code>当前位置 = T / D * C + B</code></li></ul></blockquote></li></ol><ul><li>使用<code>window.scroll(x,y)</code>和<code>window.scrollY</code>实现</li></ul><pre><code>&gt;&lt;script&gt;  var backTop = document.getElementById(&quot;back-top&quot;);  var timer = null; //定时器  var lock = false; //未上锁  backTop.onclick = function () &#123;    if (lock) return;    lock = true;    var T = 0; //记录已经运动的时间    var B = window.scrollY; // 开始位置    var C = 0 - B; //需要移动的总距离,target=0    var D = 500; //限定时间    timer = setInterval(function () &#123;      T += 20;      // 当次滚动条要到的位置      var currentDistance = (T / D) * C + B;      if (T &gt; D) &#123;        clearInterval(timer);        currentDistance = 0;        lock = false;      &#125;      window.scroll(0, currentDistance);    &#125;, 20);  &#125;;&gt;&lt;/script&gt;</code></pre><ul><li>使用 <code>document.documentElement.scrollTop</code> 实现</li></ul><pre><code>&gt;&lt;script&gt;  var backTop = document.getElementById(&quot;back-top&quot;);  var doc = document.documentElement || document.body;  var timer = null;  var lock = false;  //点击后要处理的事情  // 限定时间动画  backTop.onclick = function () &#123;    if (lock) return;    lock = true;    // 运动的时间    var T = 0;    var B = doc.scrollTop; // 开始位置    // target=0 目标位置    var C = 0 - B; // 总共需要改变的距离    var D = 500; // 总共运动的时间&gt;    timer = setInterval(function () &#123;      // 记录运的时间      T += 20;      // 当前运动到的位置      var currentDistance = (T / D) * C + B;      // currentDistance &lt; 0      if (T &gt;= D) &#123;        clearInterval(timer);        currentDistance = 0;        lock = false;      &#125;&gt;      doc.scrollTop = currentDistance;    &#125;, 20);  &#125;;&gt;&lt;/script&gt;</code></pre><h4 id="案例2：图片延时加载"><a href="#案例2：图片延时加载" class="headerlink" title="案例2：图片延时加载"></a>案例2：图片延时加载</h4><blockquote><p><strong>实现原理：</strong></p><ul><li>页面中所有需要做延时加载的图片上加上<code>class = &#39;lazy&#39;</code> 和 <code>data-src = &#39; 图片真实地址&#39;</code></li><li>获取页面中所有<code>class</code>中包含<code>lazy</code>的元素，同时要判断元素是否为<code>img</code>标签且<code>data-src</code>是否有值。确保操作的元素是 <code>img</code> 元素，同时<code>data-src</code>中有图片地址。</li><li>当滚动浏览器的滚动条时，要判断对应的图片<strong>是否进入可视区</strong>，如果进入，则给<code>img.src</code>动态赋值</li><li>如果图片一旦赋值，则后面就不需要再对此 <code>img</code> 标签做监听。则可以从数组对象中将其删除，同时把 <code>lazy</code> 样式删除</li><li>最后考虑浏览器窗口大小改变时(响应式布局)的情况，还有要考虑对 <code>scroll</code> 和 <code>resize</code> 事件做节流操作</li></ul></blockquote><blockquote><p><strong>步骤</strong></p><ul><li>CSS布局</li><li>用JS实现响应式布局</li><li>JS实现延时加载效果</li></ul></blockquote><ul><li>布局</li></ul><pre><code>&gt;&lt;style&gt;  html,  body,  ul,  li &#123;    margin: 0;    padding: 0;  &#125;  ul &#123;    /* width: 968px; */    margin: 0 auto;  &#125;  li &#123;    list-style: none;    width: 200px;    height: 200px;    padding: 10px;    margin: 10px;    border: 1px solid #ddd;    float: left;  &#125;  li img &#123;    width: 200px;    height: 200px;  &#125;&gt;&lt;/style&gt;&gt;&gt;&lt;ul id=&quot;J_container&quot;&gt;&gt;  &lt;li&gt;&gt;    &lt;img&gt;      src=&quot;./images/loading-svg/loading-bars.svg&quot;&gt;      data-src=&quot;./images/01.png&quot;&gt;      class=&quot;lazy&quot;&gt;    /&gt;&gt;  &lt;/li&gt;&gt;  &lt;li&gt;&gt;    &lt;img&gt;      src=&quot;./images/loading-svg/loading-bars.svg&quot;&gt;      data-src=&quot;./images/01.png&quot;&gt;      class=&quot;lazy&quot;&gt;    /&gt;&gt;  &lt;/li&gt;&gt; ……&gt;&lt;/ul&gt;</code></pre><ul><li>JS 实现页面响应式布局<blockquote><ul><li>效果：无论怎么调整浏览器窗口，ul都能居中对齐</li><li>第一次打开页面或当浏览器窗口大小发生改变时，获取浏览器窗口的可视区宽 <code>clientWidth</code></li></ul></blockquote></li></ul><pre><code>var clientWidth =  document.documentElement.clientWidth || document.body.clientWidth;</code></pre><blockquote><ul><li>然后用<code>clienwWidth / 每个li元素的占位宽</code>（包括 margin，border，padding），对结果向下取整，计算得出页面一行最多能放几个li</li></ul></blockquote><pre><code>var count = Math.floor(clientWidth / 242);</code></pre><blockquote><ul><li>利用 <code>count * li占位宽</code> 动态计算得到其父容器ul的宽</li></ul></blockquote><pre><code>container.style.width = count * 242 + &quot;px&quot;;</code></pre><blockquote><ul><li><code>ul</code>设置左右居中</li></ul></blockquote><ul><li>JS 实现懒加载（延时加载）效果<blockquote><ul><li>获取页面中所有<code>class = &#39;lazy&#39;</code> 的元素，同时过滤掉不是图片的元素</li></ul></blockquote></li></ul><pre><code>// 1、需要获取到所有需要延时加载的图片var imgs = document.querySelectorAll(&quot;.lazy&quot;);// 2、过滤掉不是图片的标签//方式一：var imgs = document.querySelectorAll(&quot;img.lazy&quot;);//方式二：imgs = Array.prototype.filter.call(imgs, function (item) &#123;  return item instanceof Image;&#125;);//方式三：imgs = Array.prototype.filter.call(imgs, function (item) &#123;  return item instanceof HTMLImageElement;&#125;);</code></pre><blockquote><blockquote><p>注意：方式一得到的是类数组，没有<code>indexOf</code>方法</p></blockquote></blockquote><blockquote><ul><li>获取页面可视区的高</li></ul></blockquote><pre><code>// 获取浏览器可视区的高var clientHeight =  document.documentElement.clientHeight || document.body.clientHeight;</code></pre><blockquote><ul><li>对获取的所有图片进行遍历，遍历时判断元素是否进入到可视区</li><li>元素进入可视区原理：元素底部与浏览器可视区的高 &gt; 0 同时元素顶部与浏览器可视区的高要小于浏览器可视区高。 即<code>bottom &gt; 0 &amp;&amp; _top &lt; clientHeight</code></li><li>如果元素进入可视区，将图片保存在<code>data-src</code>属性上的正确地址赋值给<code>src</code>属性</li><li>同时将此图片从<code>imgs</code>数组中删除，以后不需要再监听了</li><li>当<strong>滚动条滚动</strong>时，或<strong>浏览器窗口大小发生改变</strong>时，会有其它图片进入到当前浏览器可视区,则需要添加对应的<strong>事件来监听</strong>。</li><li>当所有图片都被加载出来了，<code>imgs</code>是空数组；此时就不用再遍历了</li><li>最后还要做相关节流操作<blockquote><p>注意：</p></blockquote></li><li>如果动态调整<code>ul</code>宽度的<code>resize</code>事件也做节流的话，那么，它的间隔时间必须短于懒加载函数中<code>resize</code>事件的间隔时间</li><li>不要用<code>top</code>命名变量，因为，<code>window</code>里面有一个<code>top</code>方法，它指向<code>window</code>本身</li></ul></blockquote><p><strong>主页面</strong></p><pre><code>&gt;&lt;script&gt;  //获取元素  var container = document.getElementById(&quot;J_container&quot;);  //第一次进来时，初始化ul的宽度  initUlWidth();  //每次调整浏览器可视区时，动态调整ul的宽度  window.addEventListener(&quot;resize&quot;, throttle(initUlWidth, 90));  //调整ul宽度函数  function initUlWidth() &#123;    //获取可视区宽度    var clientWidth =      document.documentElement.clientWidth || document.body.clientWidth;    var count = Math.floor(clientWidth / 242);    container.style.width = count * 242 + &quot;px&quot;;  &#125;  lazyload(); //实现延迟加载效果&gt; /**&gt;  * 节流函数&gt;  * fn 事件处理函数&gt;  * delay 函数执行间隔时间&gt;  */  function throttle(fn, delay) &#123;    var timer = null;    return function () &#123;      var self = this;      var args = arguments;      if (timer) return;      timer = setTimeout(function () &#123;        // 函数体执行代码        fn.apply(self, args);        // 开锁        timer = null;      &#125;, delay);    &#125;;  &#125;&gt;&lt;/script&gt;</code></pre><p><strong>完整JS文件</strong></p><blockquote><ul><li>只需要将图片上添加<code>data-src</code>属性，存放真实图片地址，同时添加<code>class=&#39;lazy&quot;</code>,最后调用<code>lazyLoad()</code>即可</li></ul></blockquote><pre><code>(function () &#123;  // 实现延时加载  function lazyLoad() &#123;    // 1、需要获取到所有需要延时加载的图片    var imgs = document.querySelectorAll(&quot;.lazy&quot;);    // 2、过滤掉不是图片的标签    imgs = Array.prototype.filter.call(imgs, function (item) &#123;      return item instanceof Image;    &#125;);    lazy(); // 调用    window.addEventListener(&quot;scroll&quot;, throttle(lazy, 100)); //  给window绑定滚动事件    window.addEventListener(&quot;resize&quot;, throttle(lazy, 100));    function lazy() &#123;      if (imgs.length === 0) return; // 当前数组中没有需要监听的图片了      // 获取浏览器可视区的高      var clientHeight =        document.documentElement.clientHeight || document.body.clientHeight;&gt;      // 遍历所有过滤后得图片，然后查看图片是否进入到可视区，      // 如果进入到可视区，就动态给图片添加真实的图片地址      for (var i = 0; i &lt; imgs.length; i++) &#123;        // 判断图片是否进入可视区  bottom&gt;0  &amp;&amp; top&lt;浏览器可视区高        var rect = imgs[i].getBoundingClientRect();&gt;        var bottom = rect.bottom;        var _top = rect.top;        // 以下条件成立，代表元素进入到可视区        if (bottom &gt; 0 &amp;&amp; _top &lt; clientHeight) &#123;          // 把自定义属性上的真实地址赋值给图片          imgs[i].src = imgs[i].dataset.src;          // 如果图片进入过一次可视区，动态赋过值，就不用再管他了          var index = imgs.indexOf(imgs[i]);          imgs.splice(index, 1);          i--; // 一定要注意，i--        &#125;      &#125;    &#125;  &#125;&gt;&gt;/**&gt; * 节流函数&gt; * fn 事件处理函数&gt; * delay 函数执行间隔时间&gt; */  function throttle(fn, delay) &#123;    var timer = null;    return function () &#123;      var self = this;      var args = arguments;      if (timer) return;      timer = setTimeout(function () &#123;        // 函数体执行代码        fn.apply(self, args);        // 开锁        timer = null;      &#125;, delay);    &#125;;  &#125;&gt;  window.lazyLoad = lazyLoad;&#125;)();</code></pre><h4 id="案例3：吸顶盒导航"><a href="#案例3：吸顶盒导航" class="headerlink" title="案例3：吸顶盒导航"></a>案例3：吸顶盒导航</h4><blockquote><p><strong>涉及知识点</strong></p><ul><li>过渡动画</li><li><code>window.onsrcoll</code>事件</li><li><code>offsetTop</code>、<code>offsetHeight</code>、<code>scrollTop</code></li></ul></blockquote><blockquote><p>思路：</p><ul><li>给吸顶盒元素做一个<strong>副本</strong>，定在可视区之外</li><li>滚动条往下走，当它滚动的距离 超过 元素自身高度+元素距顶部距离 时，副本<strong>缓慢</strong>定在最顶部<ul><li>副本出现的时候，给它加动画效果的样式</li></ul></li><li>滚动条往上走，当 它滚动的距离 小于 元素元素距浏览器顶部距离时，副本马上消失<ul><li>副本消失时，去掉样式<blockquote><p>注意<strong>副本消失时的条件</strong>，如果直接写在<code>else</code>里，就会发生抖动</p></blockquote></li></ul></li></ul></blockquote><pre><code>&gt;&lt;style&gt;  html,  body &#123;    margin: 0;    height: 100%;  &#125;  .top &#123;    height: 50px;    background-color: #000;  &#125;  .header &#123;    height: 120px;    background-color: skyblue;  &#125;  .nav &#123;    width: 100%;    height: 100px;    background-color: red;  &#125;  .nav2 &#123;    background-color: red;    position: fixed;    top: -100px;  &#125;  .transition &#123;    transition: top 1s ease;  &#125;  .main &#123;    height: 3000px;  &#125;&gt;&lt;/style&gt;&gt;&gt;&lt;!-- 模拟的头部内部 --&gt;&gt;&lt;div class=&quot;top&quot;&gt;&lt;/div&gt;&gt;&lt;div class=&quot;header&quot;&gt;&lt;/div&gt;&gt;&lt;!-- 吸顶盒 --&gt;&gt;&lt;!-- nav2相当于nav1的副本，不过nav2是固定定位在浏览器的外部 --&gt;&gt;&lt;div class=&quot;nav nav1&quot;&gt;&lt;/div&gt;&gt;&lt;div class=&quot;nav nav2&quot;&gt;&lt;/div&gt;&gt;&lt;div class=&quot;main&quot;&gt;&lt;/div&gt;&gt;&gt;&lt;script&gt;  // 获取nav1与nav2  var nav1 = document.querySelector(&quot;.nav1&quot;);  var nav2 = document.querySelector(&quot;.nav2&quot;);  var nav1Top = nav1.offsetTop; // nav1的顶部与浏览器顶部距离  var bottom = nav1Top + nav1.offsetHeight; // nav1的底部与浏览器顶部距离&gt;  //添加 scroll事件  window.addEventListener(&quot;scroll&quot;, fn);  function fn() &#123;    var scrollTop =      document.documentElement.scrollTop || document.body.scrollTop;    // 滚动条滚动距离 &gt;= 元素底部与浏览器顶部距离    if (scrollTop &gt;= bottom) &#123;      nav2.classList.add(&quot;transition&quot;);      //nav2 区块显示出      nav2.style.top = &quot;0px&quot;;    &#125;    // 滚动条滚动距离 &lt;= 元素顶部与浏览器项部距离    if (scrollTop &lt;= nav1Top) &#123;      nav2.classList.remove(&quot;transition&quot;);      nav2.style.top = &quot;-100px&quot;;    &#125;  &#125;&gt;&lt;/script&gt;</code></pre><h4 id="案例4：滚动加载更多"><a href="#案例4：滚动加载更多" class="headerlink" title="案例4：滚动加载更多"></a>案例4：滚动加载更多</h4><blockquote><ul><li>当滚动条滚动到最底部时，加载一批数据，填充到页面上</li><li>判断滚动条滚动到底部公式：<code>scrollHeight - scrollTop - clientHeight = 0</code></li></ul></blockquote><table><thead><tr><th>属性</th><th>说明</th></tr></thead><tbody><tr><td>scrollTop</td><td>元素滚动出去的高</td></tr><tr><td>clientHeight</td><td>元素的可视高（height + padding）</td></tr><tr><td>scrollHeight</td><td>元素实际内容的高</td></tr></tbody></table><pre><code>var doc = document.documentElement || document.body;if (doc.scrollHeight - doc.scrollTop - doc.clientHeight &lt; 100) &#123;  // 快滚动到底部时，就开始请求加载数据&#125;</code></pre><pre><code>&gt;&lt;style&gt;  .main &#123;    height: 3000px;  &#125;  .box1 &#123;    background-color: khaki;    height: 500px;    margin: 50px;  &#125;&gt;&lt;/style&gt;&gt;&gt;&lt;div class=&quot;main&quot;&gt;&lt;/div&gt;&gt;&gt;&lt;script&gt;  // window滚动事件  window.addEventListener(&quot;scroll&quot;, throttle(loadmore, 100));  // 加载更多函数  function loadmore() &#123;    var doc = document.documentElement || document.body;    var scrollHeight = doc.scrollHeight;    var scrollTop = doc.scrollTop;    var clientHeight = doc.clientHeight;    // 什么时开始加载下一批内容    // 当浏览器的srollHeight - scrollTop -clientHeight=0时，表示滚动到页面的底部    // 但我们更希望在快到达底部前，就开始加载下一批数据，所以可以设置100左右的差值    if (scrollHeight - scrollTop - clientHeight &lt; 100) &#123;      // 加载更多内容      //   console.log(&quot;加载更多内容&quot;);      // 每次滚动到底部，创建一批内容，加载到页面当中      var div = document.createElement(&quot;div&quot;);      div.className = &quot;box1&quot;;      document.body.appendChild(div);&gt;      // ajax请求      // 把数据渲染到页面当中来    &#125;  &#125;&gt;&gt; /**&gt;  * 节流函数&gt;  * fn 事件处理函数&gt;  * delay 函数执行间隔时间&gt;  */  function throttle(fn, delay) &#123;    var timer = null;    return function () &#123;      var self = this;      var args = arguments;      if (timer) return;      timer = setTimeout(function () &#123;        // 函数体执行代码        fn.apply(self, args);        // 开锁        timer = null;      &#125;, delay);    &#125;;  &#125;&gt;&lt;/script&gt;</code></pre><h4 id="案例5：楼梯式导航"><a href="#案例5：楼梯式导航" class="headerlink" title="案例5：楼梯式导航"></a>案例5：楼梯式导航</h4><blockquote><p>涉及知识</p><ul><li>元素添加自定义属性绑定<strong>下标序号</strong></li><li>事件委托</li><li>查找数组中第一个大于 n 的数的下标</li><li>限时匀速动画</li><li>window.onscroll事件</li><li>scrollTop、offsetTop</li><li>函数节流</li></ul></blockquote><blockquote><p>布局思路</p><ul><li><code>foor-nav</code>用来制作右侧楼梯导航，采用固定定位，定位到浏览右侧</li><li><code>header</code> 和 <code>footer</code> 用来占位，模拟真实网站头部和尾部占用的空间</li><li><code>main</code> 中的直接子元素<code>floor-item</code>区域为楼梯导航滚动相关内容区块</li></ul></blockquote><ul><li>HTML结构</li></ul><pre><code>&gt;&lt;style&gt;  html &#123;    /* 滚动条平滑滚动效果 */    scroll-behavior: smooth;  &#125;  html,  body,  ul,  li &#123;    padding: 0;    margin: 0;    list-style: none;  &#125;  body &#123;    background-color: #ddd;  &#125;  .floor-nav &#123;    position: fixed;    right: 50px;    top: 100px;    width: 50px;    background-color: #fff;    padding: 10px 10px;  &#125;  .floor-nav li &#123;    height: 35px;    line-height: 35px;    text-align: center;    color: #000;    font-size: 14px;    border-bottom: 1px dashed #ddd;    cursor: pointer;  &#125;  .floor-nav li:hover,  .floor-nav li.active:hover &#123;    background-color: red;    color: #fff;  &#125;  .floor-nav li.active &#123;    color: red;  &#125;  .main &#123;    width: 600px;    margin: 0px auto;  &#125;  .main .floor-item &#123;    width: 100%;    background-color: skyblue;    font-size: 50px;    text-align: center;    line-height: 200px;    margin-top: 50px;  &#125;&gt;&lt;/style&gt;&gt;&gt;&lt;!-- 楼梯导航按扭开始 --&gt;&gt;&lt;ul class=&quot;floor-nav&quot; id=&quot;J_floor&quot;&gt;&gt;  &lt;li&gt;国创&lt;/li&gt;&gt;  &lt;li&gt;综艺&lt;/li&gt;&gt;  &lt;li&gt;娱乐&lt;/li&gt;&gt;  &lt;li&gt;电影&lt;/li&gt;&gt;  &lt;li&gt;游戏&lt;/li&gt;&gt;  &lt;li&gt;纪录片&lt;/li&gt;&gt;  &lt;li&gt;电视剧&lt;/li&gt;&gt;&lt;/ul&gt;&gt;&lt;!-- 楼梯导航按扭开始 --&gt;&gt;&lt;div class=&quot;header&quot; style=&quot;height: 500px&quot;&gt;&lt;/div&gt;&gt;&lt;!--楼梯内容开始--&gt;&gt;&lt;div id=&quot;J_app&quot; class=&quot;main&quot;&gt;&gt;  &lt;div class=&quot;floor-item&quot; style=&quot;height: 500px&quot;&gt;国创&lt;/div&gt;&gt;  &lt;div class=&quot;floor-item&quot; style=&quot;height: 530px&quot;&gt;综艺&lt;/div&gt;&gt;  &lt;div class=&quot;floor-item&quot; style=&quot;height: 400px&quot;&gt;娱乐&lt;/div&gt;&gt;  &lt;div class=&quot;floor-item&quot; style=&quot;height: 600px&quot;&gt;电影&lt;/div&gt;&gt;  &lt;div class=&quot;floor-item&quot; style=&quot;height: 560px&quot;&gt;游戏&lt;/div&gt;&gt;  &lt;div class=&quot;floor-item&quot; style=&quot;height: 400px&quot;&gt;纪录片&lt;/div&gt;&gt;  &lt;div class=&quot;floor-item&quot; style=&quot;height: 620px&quot;&gt;电视剧&lt;/div&gt;&gt;&lt;/div&gt;&gt;&lt;!--楼梯内容结束--&gt;&gt;&lt;div class=&quot;footer&quot; style=&quot;height: 1500px&quot;&gt;&lt;/div&gt;</code></pre><ul><li>JS 实现思路<blockquote><p><strong>第一步：实现右侧楼梯导航按扭点击滚动效果</strong></p><ul><li>利用事件委托来实现，所有<code>li</code>的点击事件全委托给父元素<code>#J_floor</code>来实现</li><li>点击对应按扭实现：当前点击元素文字变红，其它文字为灰色，同时滚动条滚动到对应楼层</li><li>要实现当前文字变红，其它文字变灰，需要定义变量 <code>prevIndex</code>来保存前一项被点击元素的下标</li></ul></blockquote></li></ul><pre><code>// 获取id为 J_floor元素var floorNav = document.getElementById(&quot;J_floor&quot;);var navs = document.querySelectorAll(&quot;#J_floor li&quot;);var prevIndex = -1; // 前一个楼梯按扭序号// 事件委托，所有子元素li的点击事件委托给父元素来处理floorNav.onclick = function (e) &#123;  var target = e.target;  var tagName = target.tagName.toLowerCase();  // 如果不是点击对应的li啥也不做  if (tagName !== &quot;li&quot;) return;&gt;  // 点击后要处理的事情  // 1.前面变红的li复原  prevIndex !== -1 &amp;&amp; navs[prevIndex].classList.remove(&quot;active&quot;);  // 2.当前项变红色  target.classList.add(&quot;active&quot;);  // 3、把前一个序号更新为当前序号，供后面使用  prevIndex = Array.prototype.indexOf.call(navs, target);  // 4、滚动条滚动到当前楼层所在位置  // .........具体实现思路看下一步，&#125;;</code></pre><blockquote><p><strong>第二步：实现点击导航按扭后，滚动条滚动到对应楼层</strong></p><ul><li>创建一个空数组<code>floorItemsTopArr = []</code>，用来保存每一个楼层的元素与浏览器顶部的距离</li><li>点击按扭时，找到对应按扭元素的下标，再找到<code>floorItemsTopArr</code>数组中对应下标的元素，获得当前浏览器滚动条需要滚动到的距离。</li><li>实现滚动条在滚动时能平滑滚动:<ul><li>方法1：在html 标签的样式中添加<code>scroll-behavior: smooth;</code>样式;但目前在一些低版本浏览器中不支持</li><li>方法2：JS手动封装实现滚动条平滑滚动的函数，利用限时匀速运动</li></ul></li></ul></blockquote><pre><code>&gt;/**&gt; * scrollByTop 滚动条从当前位置滚动到目标位置（只针对垂直方向）&gt; * target 滚动到的目标位置&gt; * delay 滚动的总时间&gt; */function scrollByTop(target, delay = 200) &#123;  // 已经运动的时间  var T = 0;  // 开始运动的位置  var B = window.scrollY;  // 目标位置是 0  var targe=0;  // 总共需要改变的距离  var C = target - B;  // 总共需要运动的时间  var D = delay;&gt;  // 开始执行动画  timer = setInterval(function () &#123;    T += 20; // 记录运动的时间    // 当前滚动条运动的距离    var currentDistance = (T / D) * C + B;    if (T &gt;= D) &#123;      currentDistance = target;      clearInterval(timer);    &#125;    window.scroll(0, currentDistance);  &#125;, 20);&#125;</code></pre><blockquote><p><strong>第三步：实现滚动浏览器窗口，对应楼层按扭显示对应样式</strong></p><ul><li>如何知道当前滚动条滚动所在的对应楼层呢 ？可以通过当前滚动条滚动的距离与楼层顶部与浏览器的距离来判断</li><li>找到数组中<strong>从前往后</strong>满足： <code>滚动条滚动距离 &gt; 楼层顶部与浏览器顶部距离的最后一个元素</code> 。这个元素所在的下标，就是当前滚动条滚动到的楼层所对应的下标。把这个下标保存在变量<code>currentIndex</code>中，供后面使用。</li><li>找到对应楼层序号，就可以修改楼层的按扭样式。</li></ul></blockquote><blockquote><blockquote><p>性能优化</p></blockquote><ul><li>如果滚动条一直在当前楼层中滚动，则不需要频繁执行更改楼层按扭样式的代码</li><li>如果<code>prevIndex === currentIndex</code>说明当前滚动条一直在当前楼层滚动</li></ul></blockquote><pre><code>var currentIndex = -1; // 当前楼梯所在按扭序号// 当滚动浏览器窗口时，对应导航的样式要显示到对应楼层window.onscroll = function () &#123;  // 不断获取浏览器滚动的距离  var scrollY = window.scrollY;  // 找到当前滚动所在的楼层序号  for (var i = 0; i &lt; floorItemsTopArr.length; i++) &#123;    if (scrollY &gt;= floorItemsTopArr[i]) &#123;      currentIndex = i; // 最后一次找到的i就是当前滚动所在的楼层    &#125; else &#123;      break;    &#125;  &#125;&gt;  if (prevIndex === currentIndex) return;&gt;  // 找到对应楼层后，需要处理的事情  prevIndex !== -1 &amp;&amp; navs[prevIndex].classList.remove(&quot;active&quot;);  currentIndex !== -1 &amp;&amp; navs[currentIndex].classList.add(&quot;active&quot;);  prevIndex = currentIndex;&#125;;</code></pre><blockquote><p><strong>第四步：第一个按扭和最后一个按扭样式的特殊情况</strong></p><ul><li>当滚动条滚动在最上面，不在第一个楼层区，即 <code>滚动距离 &lt; 第一个楼层与浏览器顶部距离</code>，则楼层按扭文字不变红</li><li>当滚动条滚动到最后面，不在最后一个楼层区，即 <code>滚动距离 &gt; 最后一个楼层与浏览器顶部距离 + 最后一个楼层的高度</code> ，则最后一个楼层按扭文字也不变红</li><li>要使楼层按扭文字不变红，只需要把<code>currentIndex = -1</code>即可</li></ul></blockquote><pre><code>var len = floorItemTopArr.length;// 最后一个元素底部与浏览器顶部距离var bottom = floorItemsTopArr[len - 1] + floorItems[len - 1].offsetHeight;if (scrollY &lt; floorItemsTopArr[0] || scrollY &gt; bottom) &#123;  currentIndex = -1;&#125;</code></pre><ul><li>完整源代码</li></ul><pre><code>&gt;&lt;script&gt;  // 获取id为 J_floor元素  var floorNav = document.getElementById(&quot;J_floor&quot;);  var navs = document.querySelectorAll(&quot;#J_floor li&quot;);  var floorItems = document.querySelectorAll(&quot;#J_app .floor-item&quot;);  var len = floorItemTopArr.length;  var prevIndex = -1; // 前一个楼梯按扭序号  var currentIndex = -1; // 当前楼梯所在按扭序号  var floorItemsTopArr = []; // 用来保存每一层的顶部与浏览器顶部的高&gt;  // 把所有 floor-item与body顶部的距离添加到一个数组floorItemsTopArr  for (var i = 0; i &lt; floorItems.length; i++) &#123;    floorItemsTopArr.push(floorItems[i].offsetTop);  &#125;&gt;  // 事件委托，所有子元素li的点击事件委托给父元素来处理  floorNav.onclick = function (e) &#123;    var target = e.target;    var tagName = target.tagName.toLowerCase();    // 如果不是点击对应的li啥也不做    if (tagName !== &quot;li&quot;) return;&gt;    // 点击后要处理的事情    // 1.前面变红的li复原    prevIndex !== -1 &amp;&amp; navs[prevIndex].classList.remove(&quot;active&quot;);    // 2.当前项变红色    target.classList.add(&quot;active&quot;);    // 3、把前一个序号更新为当前序号，供后面使用    prevIndex = Array.prototype.indexOf.call(navs, target);    // 4、滚动条滚动到当前楼层所在位置    // 方法一：    window.scroll(0, floorItemsTopArr[prevIndex]);    // 方法二：    // var doc = document.documentElement || document.body;    // doc.scrollTop = floorItemsTopArr[prevIndex];    // 方法三    //   scrollByTop(floorItemsTopArr[prevIndex]);  &#125;;&gt;  // 当滚动浏览器窗口时，对应导航的样式要显示到对应楼层  window.onscroll = function () &#123;    // 不断获取浏览器滚动的距离    var scrollY = window.scrollY;    // 找到当前滚动所在的楼层序号    // 楼层数据中最后一个满足： 条件的的元素所在序号    for (var i = 0; i &lt; floorItemsTopArr.length; i++) &#123;      if (scrollY &gt;= floorItemsTopArr[i]) &#123;        currentIndex = i; // 最后一次找到的i就是当前滚动所在的楼层      &#125; else &#123;        break;      &#125;    &#125;    // 考虑第一个和最后一个的特殊情况    // 最后一个元素底部与浏览器顶部距离    var bottom = floorItemsTopArr[len - 1] + floorItems[len - 1].offsetHeight;    if (scrollY &lt; floorItemsTopArr[0] || scrollY &gt; bottom) &#123;      currentIndex = -1;    &#125;&gt;    // 优化处理，如果一直在当前楼层内滚动，不执行以下代码    if (prevIndex === currentIndex) return;    // 找到对应楼层后，需要处理的事情    prevIndex !== -1 &amp;&amp; navs[prevIndex].classList.remove(&quot;active&quot;);    currentIndex !== -1 &amp;&amp; navs[currentIndex].classList.add(&quot;active&quot;);    prevIndex = currentIndex;  &#125;;&gt;&lt;/script&gt;</code></pre>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JS核心知识点（十二）</title>
      <link href="/2023/12/07/JS%E6%A0%B8%E5%BF%83%E7%9F%A5%E8%AF%86%E7%82%B9%EF%BC%88%E5%8D%81%E4%BA%8C%EF%BC%89/"/>
      <url>/2023/12/07/JS%E6%A0%B8%E5%BF%83%E7%9F%A5%E8%AF%86%E7%82%B9%EF%BC%88%E5%8D%81%E4%BA%8C%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<span id="more"></span><h3 id="一、鼠标滚轮事件"><a href="#一、鼠标滚轮事件" class="headerlink" title="一、鼠标滚轮事件"></a>一、鼠标滚轮事件</h3><blockquote><p>鼠标滚轮事件存在兼容性问题，不同浏览器对应的事件名不一样。</p><table><thead><tr><th>事件名</th><th>事件对象属性（判断滚动方向）</th><th>支持浏览器</th></tr></thead><tbody><tr><td>mousewheel（非标准）</td><td><code>e.wheelDelta</code>：正值（120） ↑;负值（-120）↓</td><td>Webkit 和 Edge 等各大浏览器，但 Firefox 不支持</td></tr><tr><td>DOMMouseScroll（非标准）</td><td><code>e.detail</code>：</td><td></td></tr><tr><td>正值（3）↓;负值（-3）↑</td><td>低版本 firefox，同时该事件需要通过<code>addEventListener</code>方式绑定事件监听</td><td></td></tr><tr><td>wheel（标准）</td><td><code>e.deltaY</code>：正值 ↓;负值 ↑</td><td>各个厂商的高版本浏览器都支持</td></tr></tbody></table></blockquote><ol><li>mousewheel 事件<blockquote><ul><li>早期低版本的<code>webkit</code>和<code>Edge</code>支持</li><li>通过<code>e.wheelDelta</code>的值来判断鼠标滚动的方向，值为 120 向上，值为-120 向下</li></ul></blockquote></li></ol><pre><code>box.addEventListener(&quot;wheel&quot;, eventFn, false);function eventFn(e) &#123;  // 负值 向下滚  正值 向上滚  console.log(e.wheelDelta);&#125;</code></pre><ol start="2"><li>DOMMouseScroll 事件<blockquote><ul><li>低版本的<code>Firefox</code>支持</li><li>通过<code>e.detail</code>的值来判断鼠标滚动方向，值为 3，向下滚，值为 -3 向上滚</li></ul></blockquote></li></ol><pre><code>box.addEventListener(&quot;DOMMouseScroll&quot;, eventFn, false);function eventFn(e) &#123;  // 正值 3 向下滚  负值 -3  向上滚  console.log(e.detail);&#125;</code></pre><ol start="3"><li>wheel 事件<blockquote><ul><li>为了统一滚轮事件的标准，各大浏览器的高版本都支持这个事件</li><li>通过 <code>e.deltaY</code> 的值来判断鼠标滚动方向，正值向下，负值向上。</li></ul></blockquote></li></ol><pre><code>var box = document.querySelector(&quot;.box&quot;);box.addEventListener(&quot;wheel&quot;, eventFn, false);function eventFn(e) &#123;  // 正值 向下滚  负值 向上滚  console.log(e.deltaY);&#125;</code></pre><ol start="4"><li>兼容型处理<blockquote><ul><li>以下代码封装成<code>wheel.js</code>文件，供后期使用</li></ul></blockquote></li></ol><ul><li>获取浏览器当前支持的版本的鼠标滚轮事件名</li></ul><pre><code> var box = document.querySelector(&quot;.box&quot;); // 获取浏览器当前支持的版本的鼠标滚轮事件名 console.log(&quot;onwheel&quot; in box); //true var support =   &quot;onwheel&quot; in document.createElement(&quot;div&quot;)     ? &quot;wheel&quot; // 各个厂商的高版本浏览器都支持&quot;wheel&quot;     : document.onmousewheel !== undefined     ? &quot;mousewheel&quot; // Webkit 和 IE 一定支持&quot;mousewheel&quot;     : &quot;DOMMouseScroll&quot;; // 低版本 firefox</code></pre><blockquote><ul><li><code>&quot;onwheel&quot; in box</code>：用<code>in</code>检查<code>HTMLElement</code>原型上是否有<code>onwheel</code>这个方法，如果有就用<code>wheel</code>事件</li><li>但因为要封装，所以自己创建一个元素，并查看它的原型上是否有这个方法</li><li><code>document.onmousewheel !== undefined</code>用来检查是否支持<code>mousewheel</code>事件，如果不支持，就会使用<code>DOMMouseScroll</code></li></ul></blockquote><ul><li>处理事件对象的属性值</li></ul><pre><code>function callback(e) &#123;  var e = e || window.event;  e.preventDefault(); // 阻止默认行为  // 处理低版本火狐,如果有detail值，就给e添加deltaY属性,并统一正负  e.detail &amp;&amp; (e.deltaY = e.detail * 40);  // 处理低版本 ie 和  Edge等浏览器,如果有wheelDelta值，就给e添加deltaY属性,并统一正负  e.wheelDelta &amp;&amp; (e.deltaY = -e.wheelDelta);  //如果前两个版本都没有，就使用e.deltaY  if (e.deltaY &gt; 0) &#123;      //向下滚      //要处理的业务逻辑写在这里    &#125; else &#123;      //向上滚      //要处理的业务逻辑写在这里    &#125;&gt;&#125;</code></pre><ul><li><p>优化</p><blockquote><ul><li>将事件处理函数抽离，供用户自己设置</li><li>事件处理函数中的<code>this</code>和<code>arguments</code>丢失问题</li></ul></blockquote></li><li><p>封装</p></li></ul><pre><code>&gt;/**&gt; * addWheelListener 兼容不同版板的鼠标滚轮事件&gt; * element 绑定滚轮事件的元素&gt; * eventFn 事件处理函数&gt; * useCapture 在捕获还是冒泡阶段执行&gt; */window.addWheelListener = function (element, eventFn, useCapture = false) &#123;  // 获取浏览器当前支持的版本的鼠标滚轮事件名  var support =    &quot;onwheel&quot; in document.createElement(&quot;div&quot;)      ? &quot;wheel&quot; // 各个厂商的高版本浏览器都支持&quot;wheel&quot;      : document.onmousewheel !== undefined      ? &quot;mousewheel&quot; // Webkit 和 IE 一定支持&quot;mousewheel&quot;      : &quot;DOMMouseScroll&quot;; // 低版本 firefox&gt;  // 添加鼠标事件  element.addEventListener(support, callback, useCapture);&gt;  // 兼容写法的事件方法  function callback(e) &#123;    var e = e || window.event;    e.preventDefault(); // 阻止默认行为    // 处理低版本火狐    e.detail &amp;&amp; (e.deltaY = e.detail * 40);    // 处理低版本 ie 和  Edge等浏览器    e.wheelDelta &amp;&amp; (e.deltaY = -e.wheelDelta);&gt;    // 滚动事件要处理的事情，通过e.deltaY来判断滚动的方向，正向下，负向上    eventFn.apply(this, arguments);//传入this和arguments  &#125;&#125;;  //调用函数  function fn(e) &#123;    console.log(this);    console.log(e);    //真正的事件处理函数    if (e.deltaY &gt; 0) &#123;      //向下滚      //要处理的业务逻辑写在这里      console.log(&quot;向下&quot;);    &#125; else &#123;      //向上滚      //要处理的业务逻辑写在这里      console.log(&quot;向上&quot;);    &#125;  &#125;  addWheelListener(box, fn, false);</code></pre><ol start="5"><li>案例 1：滚动实现元素高度变化</li></ol><pre><code>&gt;&lt;style&gt;  html,  body &#123;    margin: 0;    padding: 0;  &#125;  .box &#123;    width: 100px;    height: 200px;    background-color: khaki;    margin: 50px;  &#125;&gt;&lt;/style&gt;&gt;&lt;script src=&quot;./wheel.js&quot;&gt;&lt;/script&gt;&gt;&lt;div class=&quot;box&quot;&gt;&lt;/div&gt;&gt;&lt;script&gt;  var box = document.querySelector(&quot;.box&quot;);&gt;  function fn(e) &#123;    var speed = 10;    if (e.deltaY &gt; 0) &#123;      //向下滚      box.style.height = this.offsetHeight + speed + &quot;px&quot;;    &#125; else &#123;      //向上滚      box.style.height = this.offsetHeight - speed + &quot;px&quot;;    &#125;  &#125;&gt;  addWheelListener(box, fn);&gt;&lt;/script&gt;</code></pre><ol start="6"><li>案例2：全屏垂直滚动轮播<blockquote><p>涉及知识点</p><ul><li>鼠标滚轮事件</li><li><code>transitionend</code>事件</li><li>节流操作</li><li>事件委托</li><li><code>window.resize</code>事件</li></ul></blockquote></li></ol><ul><li>CSS布局代码</li></ul><pre><code>&gt;&lt;style&gt; html, body &#123;   margin: 0;   padding: 0;   height: 100%; &#125; .wrap &#123;   width: 100%;   height: 500%;   transform: translate3d(0, 0, 0);   transition: transform 1s ease; &#125; .wrap .slide &#123;   display: flex; /*使文字居中*/   align-items: center;   justify-content: center;   color: #fff;   font-size: 60px;   height: 20%; &#125; .wrap .slide:nth-child(1) &#123;   background-color: khaki; &#125; .wrap .slide:nth-child(2) &#123;   background-color: skyblue; &#125; .wrap .slide:nth-child(3) &#123;   background-color: tomato; &#125; .wrap .slide:nth-child(4) &#123;   background-color: rgb(154, 236, 197); &#125; .wrap .slide:nth-child(5) &#123;   background-color: rgb(174, 139, 223); &#125; /* 分页器 */ .pagination &#123;   position: fixed; /*固定在一个位置*/   right: 20px;   top: 50%;   transform: translateY(-50%);   width: 11px;   height: 100px;   display: flex; /*使span居中*/   flex-direction: column; /*改变方向*/   justify-content: space-between; /*使span两端对齐*/ &#125; .pagination span &#123;   width: 100%;   height: 11px;   background-color: #fff;   border-radius: 50%;   cursor: pointer; &#125; .pagination span.active &#123;   background-color: orange;   box-shadow: 0 0 2px 3px orange; &#125;&gt;&lt;/style&gt;&gt;&gt;&lt;div class=&quot;wrap&quot;&gt;&gt;  &lt;div class=&quot;slide&quot;&gt;第一屏&lt;/div&gt;&gt;  &lt;div class=&quot;slide&quot;&gt;第二屏&lt;/div&gt;&gt;  &lt;div class=&quot;slide&quot;&gt;第三屏&lt;/div&gt;&gt;  &lt;div class=&quot;slide&quot;&gt;第四屏&lt;/div&gt;&gt;  &lt;div class=&quot;slide&quot;&gt;第五屏&lt;/div&gt;&gt;&lt;/div&gt;&gt;&lt;div class=&quot;pagination&quot;&gt;&gt;  &lt;span class=&quot;active&quot;&gt;&lt;/span&gt;&gt;  &lt;span&gt;&lt;/span&gt;&gt;  &lt;span&gt;&lt;/span&gt;&gt;  &lt;span&gt;&lt;/span&gt;&gt;  &lt;span&gt;&lt;/span&gt;&gt;&lt;/div&gt;</code></pre><ul><li>处理分页器切换效果</li></ul><pre><code>&gt;&lt;script&gt; var spans = document.querySelectorAll(&quot;.pagination span&quot;); var pagination = document.querySelector(&quot;.pagination&quot;); var viewHeight = document.documentElement.clientHeight; var wrap = document.querySelector(&quot;.wrap&quot;); var currentIndex = 0; var prevSpan = 0; //给span加下标 var len = spans.length; for (var i = 0; i &lt; len; i++) &#123;   spans[i].index = i; &#125; //利用事件委托，切换slide和span pagination.onclick = function (e) &#123;   var target = e.target;   var tagName = target.tagName.toLowerCase();   if (tagName !== &quot;span&quot;) return;   //给span加样式   spans[prevSpan].classList.remove(&quot;active&quot;);   currentIndex = target.index;   spans[currentIndex].classList.add(&quot;active&quot;);   prevSpan = currentIndex;   //改变slide   var translateY = -currentIndex * viewHeight;   wrap.style.transform = &quot;translate3d(0,&quot; + translateY + &quot;px, 0)&quot;; &#125;;&gt;&lt;/script&gt;</code></pre><ul><li>滚轮操作切换效果</li></ul><pre><code>&gt;&lt;script src=&quot;./wheel.js&quot;&gt;&lt;/script&gt;// 滚轮切换 function fn(e) &#123;   if (e.deltaY &gt; 0) &#123;     currentIndex++;     if (currentIndex === len) &#123;       currentIndex = len - 1;       return;     &#125;     //给span加样式     spans[prevSpan].classList.remove(&quot;active&quot;);     spans[currentIndex].classList.add(&quot;active&quot;);     prevSpan = currentIndex;     //改变slide     var translateY = -currentIndex * viewHeight;     wrap.style.transform = &quot;translate3d(0,&quot; + translateY + &quot;px, 0)&quot;;   &#125; else &#123;     currentIndex--;     if (currentIndex &lt; 0) &#123;       currentIndex = 0;       return;     &#125;     //给span加样式     spans[prevSpan].classList.remove(&quot;active&quot;);     spans[currentIndex].classList.add(&quot;active&quot;);     prevSpan = currentIndex;     //改变slide     var translateY = -currentIndex * viewHeight;     wrap.style.transform = &quot;translate3d(0,&quot; + translateY + &quot;px, 0)&quot;;  &#125; &#125; addWheelListener(wrap, fn);</code></pre><ul><li>节流操作<blockquote><ul><li>方法1：节流函数</li><li>引入节流函数，因为是低频，所以注意要把事件处理函数放定时器外面</li><li>缺点：滚动事件的节流和分页器的节流相互独立，虽然在限时时间内不能滚动，但如果同时点分页器，就会受到影响</li></ul></blockquote></li></ul><blockquote><ul><li>方法2：<code>addtransitionend</code>事件</li><li>设置一把锁，当<code>lock=true</code>时，不能触发<code>span</code>的点击事件和滚轮事件</li><li>当动画完结时，开锁</li><li>注意还有几个需要开锁的地方<ul><li>当滚动到最后一个&#x2F;第一个后，再次滚动，不会触发动画，因此就不会开锁</li><li>当连续点击同一个分页器时，也不会触发动画<blockquote><p>这个方法使滚轮事件和分页器相互影响，在其中一个事件的动画完成之前，另一个事件是触发不了的</p></blockquote></li></ul></li></ul></blockquote><ul><li>优化<blockquote><ul><li>把公用的代码抽离出来</li><li>当浏览器窗口大小改变时，<code>viewHeight</code>、<code>translateY</code>也要做相应改变<ul><li>使用<code>resize</code></li></ul></li></ul></blockquote></li></ul><pre><code>function to(index) &#123;  //给span加样式  currentIndex = index;  spans[prevSpan].classList.remove(&quot;active&quot;);  spans[currentIndex].classList.add(&quot;active&quot;);  prevSpan = currentIndex;  //改变slide  var translateY = -currentIndex * viewHeight;  wrap.style.transform = &quot;translate3d(0,&quot; + translateY + &quot;px, 0)&quot;;&#125;window.addEventListener(&quot;resize&quot;, function () &#123;  // 同时还要重新计算，wrap 的translateY的值  viewHeight = document.documentElement.clientHeight;  var translateY = -(currentindex * viewHeight);  wrap.style.transform = &quot;translate3d(0, &quot; + translateY + &quot;px, 0)&quot;;&#125;);</code></pre><h3 id="二、鼠标按键"><a href="#二、鼠标按键" class="headerlink" title="二、鼠标按键"></a>二、鼠标按键</h3><ol><li>禁止右键菜单<blockquote><ul><li><code>contextmenu</code>事件，会在鼠标点击右键或者按下键盘上的菜单键时被触发，用于显示上下文菜单</li><li>如果我们希望在按下右键时，不要显示上下文菜单，我们可以在<code>contextmenu</code>事件中，阻止默认行为。</li></ul></blockquote></li></ol><pre><code>// 在页面任意位置按下右键，都不会显示上下文菜单document.addEventListener(&quot;contextmenu&quot;, function (e) &#123;  e.preventDefault();&#125;);&gt;var box = document.querySelector(&quot;.box&quot;);// 只在当前元素上按下时，不显示上下文菜单box.addEventListener(&quot;contextmenu&quot;, function (e) &#123;  e.preventDefault();&#125;);</code></pre><ol start="2"><li>禁止选中元素<blockquote><ul><li><code>selectstart</code>事件，在用户开始一个新的选择时候触发<blockquote><p>如果不想用户选择内容，可以在事件中阻止默认行为</p></blockquote></li></ul></blockquote></li></ol><pre><code>我是一堆测试文字&gt;&lt;script&gt;  document.onselectstart = function (e) &#123;    e.preventDefault();  &#125;;&gt;&lt;/script&gt;</code></pre><ol start="3"><li>判断按下的鼠标键<blockquote><ul><li><code>MouseEvent.button</code>(e.button)是只读属性，它返回一个值，代表用户按下并触发了事件的鼠标按键。</li><li>常用于在<code>onmouseup</code>事件中，判断用户按下的是鼠标左键 、中键、右键中的那个键<table><thead><tr><th>属性值</th><th>说明</th></tr></thead><tbody><tr><td>0</td><td>主按键，通常指鼠标左键或默认值</td></tr><tr><td>1</td><td>辅助按键，通常指鼠标滚轮中键</td></tr><tr><td>2</td><td>次按键，通常指鼠标右键</td></tr></tbody></table></li></ul></blockquote></li></ol><pre><code>&gt;&lt;style&gt;  .box &#123;    width: 200px;    height: 200px;    background-color: khaki;  &#125;&gt;&lt;/style&gt;&gt;&gt;&lt;div class=&quot;box&quot;&gt;&lt;/div&gt;&gt;&lt;script&gt;  var box = document.querySelector(&quot;.box&quot;);  box.onmouseup = function (e) &#123;    console.log(e.button); // 0 左键  1中键  2右键  &#125;;&gt;&lt;/script&gt;</code></pre><ol start="4"><li>案例-自定义右键菜单<blockquote><ul><li>禁止出现原本的右键菜单</li><li>自定义新的菜单栏<ul><li>鼠标点哪菜单就出现在哪：将菜单栏的left、top与鼠标事件绑定</li><li>点击其他位置取消菜单栏：设置一个点击事件隐藏菜单栏</li></ul></li><li>处理菜单栏<ul><li>给每个li设置下标</li><li>用事件委托+<code>switch</code></li></ul></li></ul></blockquote></li></ol><pre><code>&gt;&lt;style&gt;  html,  body,  ul,  li &#123;    margin: 0;    padding: 0;  &#125;  li &#123;    list-style: none;  &#125;  .menu &#123;    position: absolute;    left: 100px;    top: 100px;    box-shadow: 2px 1px 2px 2px #d7d1d1;    display: none;  &#125;  .menu li &#123;    width: 120px;    border-bottom: 1px solid #ddd;    height: 30px;    line-height: 30px;    text-indent: 5px;    cursor: pointer;    background-color: #fff;  &#125;  .skin &#123;    position: absolute;    top: 50%;    left: 50%;    transform: translate(-50%, -50%);    width: 540px;    background-color: khaki;    display: none;  &#125;  .select-skin li img &#123;    width: 260px;    height: 163px;    float: left;    margin: 5px;    cursor: pointer;  &#125;  .clear::after &#123;    content: &quot;&quot;;    clear: both;    display: block;  &#125;  .skin .close &#123;    position: absolute;    top: -15px;    right: -15px;    width: 30px;    height: 30px;    color: #fff;    text-align: center;    line-height: 30px;    border-radius: 50%;    background-color: #000;    cursor: pointer;  &#125;&gt;&lt;/style&gt;&gt;&lt;ul class=&quot;menu&quot;&gt;&gt;  &lt;li&gt;更换浏览器背景&lt;/li&gt;&gt;  &lt;li&gt;刷新&lt;/li&gt;&gt;  &lt;li&gt;跳转到&lt;/li&gt;&gt;  &lt;li&gt;更换背景颜色&lt;/li&gt;&gt;&lt;/ul&gt;&gt;&lt;div class=&quot;skin&quot;&gt;&gt;  &lt;ul class=&quot;select-skin clearfix&quot;&gt;&gt;    &lt;li&gt;&gt;      &lt;img&gt;        src=&quot;../src/skin/min1.jpg&quot;&gt;        alt=&quot;&quot;&gt;        data-skin=&quot;../src/skin/big1.jpg&quot;&gt;      /&gt;&gt;    &lt;/li&gt;&gt;    &lt;li&gt;&gt;      &lt;img&gt;        src=&quot;../src/skin/min2.jpg&quot;&gt;        alt=&quot;&quot;&gt;        data-skin=&quot;../src/skin/big2.jpg&quot;&gt;      /&gt;&gt;    &lt;/li&gt;&gt;    &lt;li&gt;&gt;      &lt;img&gt;        src=&quot;../src/skin/min3.jpg&quot;&gt;        alt=&quot;&quot;&gt;        data-skin=&quot;../src/skin/big3.jpg&quot;&gt;      /&gt;&gt;    &lt;/li&gt;&gt;    &lt;li&gt;&gt;      &lt;img&gt;        src=&quot;../src/skin/min4.jpg&quot;&gt;        alt=&quot;&quot;&gt;        data-skin=&quot;../src/skin/big4.jpg&quot;&gt;      /&gt;&gt;    &lt;/li&gt;&gt;  &lt;/ul&gt;&gt;  &lt;div class=&quot;close&quot;&gt;X&lt;/div&gt;&gt;&lt;/div&gt;&gt;&lt;script&gt;  var menu = document.querySelector(&quot;.menu&quot;);  var list = document.querySelectorAll(&quot;.menu li&quot;);  var skin = document.querySelector(&quot;.skin&quot;);  var close = document.querySelector(&quot;.skin .close&quot;);  var imgList = document.querySelectorAll(&quot;.skin img&quot;);  //禁止原本的右键菜单  document.oncontextmenu = function (e) &#123;    e.preventDefault();  &#125;;  //鼠标右击菜单出现  document.addEventListener(&quot;mouseup&quot;, function (e) &#123;    if (e.button === 2) &#123;      menu.style.left = e.pageX + &quot;px&quot;;      menu.style.top = e.pageY + &quot;px&quot;;      menu.style.display = &quot;block&quot;;    &#125;  &#125;);  // 在页面任意位置点击，即关闭自定义菜单  document.onclick = function () &#123;    menu.style.display = &quot;none&quot;;  &#125;;  //为菜单选项，添加点击事件，点击后做相关操作,事件委托  //1.给li加下标  for (var i = 0; i &lt; list.length; i++) &#123;    list[i].index = i;  &#125;  // 事件委托，右键菜单的点击事件委托给父元素来处理  menu.onclick = function (e) &#123;    var target = e.target;    var _index = target.index;    switch (_index) &#123;      case 0:        skin.style.display = &quot;block&quot;;        break;      case 1:        alert(&quot;1&quot;);        break;      case 2:        alert(&quot;2&quot;);        break;      case 3:        document.body.style.backgroundColor = &quot;skyblue&quot;;        break;    &#125;  &#125;;  // 点击关闭按扭，关闭换肤  close.onclick = function () &#123;    skin.style.display = &quot;none&quot;;  &#125;;  //换肤效果  var prevImg = imgList[0];  prevImg.style.outline = &quot;1px solid red&quot;;  skin.onclick = function (e) &#123;    var target = e.target;    var tagName = target.tagName.toLowerCase();    if (tagName !== &quot;img&quot;) return;    prevImg.style.outline = &quot;&quot;;    target.style.outline = &quot;1px solid red&quot;;    prevImg = target;    var src = target.dataset.skin;    document.body.style.backgroundImage = &quot;url(&quot; + src + &quot;)&quot;;  &#125;;&gt;&lt;/script&gt;</code></pre><h3 id="三、HTML5-的拖拽事件"><a href="#三、HTML5-的拖拽事件" class="headerlink" title="三、HTML5 的拖拽事件"></a>三、HTML5 的拖拽事件</h3><blockquote><ul><li>默认情况下，网页中<strong>只有图片和文本</strong>可以拖动。其它元素默认情况下，均不允许被拖动</li><li>在图片上按下鼠标不放，然后移动鼠标就可以拖动图片。</li><li>当需要拖动文本时，只需要先选中文本，然后在选中文本上按下，最后移动鼠标，就可以实现拖动。</li></ul></blockquote><blockquote><p>如果想要其它元素也能被拖动呢 ？</p><ul><li>在<code>HTML5</code>中为每个元素提供了一个<code>draggable</code>属性，这个属性用于标识元素是否允许使用拖放操作拖动。</li><li>我们可以在元素身上添加<code>draggabel</code>属性，同时值为字符”true”，元素就可以被拖动了</li></ul></blockquote><h4 id="draggable-属性"><a href="#draggable-属性" class="headerlink" title="draggable 属性"></a>draggable 属性</h4><blockquote><p>draggable 属性有以下三个值，用来控制元素是否能被拖拽<br>|属性值|描述|<br>|true|表示元素可以被拖动|<br>|false|表示元素不可以被拖动|<br>|auto|默认值，表示使用浏览器定义的默认行为；默认情况下,只有已选中的文本、图片、链接可以拖动，其它元素是不可拖拽的。|</p></blockquote><blockquote><blockquote><p>注意</p></blockquote><ul><li>当元素被设置为可拖拽时，其元素中的文本和其子元素都不能以正常的方式被选中，而是会随着父容器一起被拖动</li><li>当元素被设置为不可拖拽时，其元素中的文本仍然会被拖动</li></ul></blockquote><pre><code>&gt;&lt;style&gt; .box &#123;   width: 200px;   height: 200px;   background-color: khaki; &#125;&gt;&lt;/style&gt;&gt;&lt;div class=&quot;box&quot; draggable=&quot;true&quot;&gt;我是一堆测试文字&lt;/div&gt;</code></pre><h4 id="拖拽基础概念"><a href="#拖拽基础概念" class="headerlink" title="拖拽基础概念"></a>拖拽基础概念</h4><blockquote><ul><li>在拖放（drag and drop）操作过程中，分为<strong>拖拽元素</strong>和<strong>目标元素（可放置元素）</strong></li><li>拖拽元素： 鼠标按下进行拖拽的元素为拖拽元素</li><li>目标元素： 把拖拽元素放入某个元素内部，或与某个元素发生碰撞等，这些元素为目标元素（可放置元素）。<br>如下图：假设把 A 元素拖拽放到 B 元素中，那A元素为拖拽元素，B元素为目标元素(可放置元素)<img src="拖拽基本概念.png"></li></ul></blockquote><h4 id="拖拽事件"><a href="#拖拽事件" class="headerlink" title="拖拽事件"></a>拖拽事件</h4><blockquote><p>元素在拖拽期间，会触发一些事件类型，其中分为</p><ul><li>拖拽元素事件：<code>dragstart</code> 、<code>drag</code>、<code>dragend</code></li><li>目标元素（放置元素）事件：<code>dragenter</code>、<code>dragover</code>、<code>dragleave</code>、<code>drop</code></li></ul></blockquote><ol><li>拖拽元素事件：drag、dragstart 、dragend<table><thead><tr><th>事件名</th><th>说明</th></tr></thead><tbody><tr><td>dragstart</td><td>当按住鼠标键<strong>不放并开始移动鼠标</strong>的那一刻，被拖动元素上会触发<code>dragstart</code>事件。只会在刚开始移动时触发一次。</td></tr><tr><td>drag</td><td>只要拖拽元素在拖拽中，就会持续的触发drag事件，有点类似于 <code>mousemove</code> 事件，只要鼠标在移动就会<strong>不断触发</strong></td></tr><tr><td>dragend</td><td>dragend 事件在拖放操作<strong>结束</strong>时触发（通过释放鼠标按钮或单击 <code>escape</code> 键），只会在结束时触发一次</td></tr></tbody></table></li></ol><blockquote><blockquote><p>使用这些事件之前，确认该元素可拖拽，已设置<code>draggable=&quot;true&quot;</code></p></blockquote><ul><li>通常会在dragstart中，设置被拖拽元素为半透明，标识元素正在被拖动。</li><li>在dragend中，恢复被拖拽元素为不透明。</li><li>所有<strong>子元素</strong>的拖拽事件，都会<strong>冒泡</strong>到他们的父元素身上，所以在处理拖拽事件时，<strong>可以利用事件委托</strong></li></ul></blockquote><pre><code>&gt;&lt;style&gt;  .box &#123;    width: 200px;    height: 200px;    background-color: khaki;  &#125;  .box2 &#123;    width: 100px;    height: 100px;    background-color: skyblue;  &#125;&gt;&lt;/style&gt;&gt;&gt;&lt;div class=&quot;box&quot;&gt;&gt;  &lt;div class=&quot;box2&quot; draggable=&quot;true&quot;&gt;&lt;/div&gt;&gt;&lt;/div&gt;&gt;&lt;script&gt;  var box = document.querySelector(&quot;.box&quot;);  var box2 = document.querySelector(&quot;.box2&quot;);&gt;  // 给box2添加对应拖拽事件  box2.ondragstart = function (e) &#123;    console.log(&quot;box2-start&quot;);  &#125;;  box2.ondrag = function (e) &#123;    console.log(&quot;box2-drag&quot;);  &#125;;  box2.ondragend = function (e) &#123;    console.log(&quot;box2-end&quot;);  &#125;;&gt;  // 以下元素默认不能拖，但事件能被成功触发  // 是因为box2元素上对应事件触发后，会冒泡到父元素上  box.ondragstart = function (e) &#123;    console.log(&quot;box-start&quot;);  &#125;;  box.ondrag = function (e) &#123;    console.log(&quot;box-drag&quot;);  &#125;;  box.ondragend = function (e) &#123;    console.log(&quot;box-end&quot;);  &#125;;&gt;  document.ondragstart = function (e) &#123;    console.log(&quot;document-start&quot;);  &#125;;  document.ondrag = function (e) &#123;    console.log(&quot;document-drag&quot;);  &#125;;  document.ondragend = function (e) &#123;    console.log(&quot;document-end&quot;);  &#125;;&gt;&lt;/script&gt;</code></pre><ol start="2"><li>dragenter、dragover、dragleave 放置元素事件<table><thead><tr><th>事件名</th><th>说明</th></tr></thead><tbody><tr><td>dragenter</td><td>当拖动的元素或被选择的文本<strong>进入有效的放置目标</strong>时， dragenter 事件被触发。</td></tr><tr><td>dragover</td><td>当元素或者选择的文本被拖拽到一个有效的放置目标上时，触发 dragover 事件（每几百毫秒触发一次）</td></tr><tr><td>dragleave</td><td>dragleave 事件在拖动的元素或选中的文本<strong>离开</strong>一个有效的放置目标时被触发</td></tr></tbody></table></li></ol><blockquote><blockquote><p>同样支持冒泡</p></blockquote></blockquote><pre><code>&gt;&lt;style&gt;  .drag &#123;    position: absolute;    left: 10px;    top: 10px;    width: 100px;    height: 100px;    background-color: khaki;  &#125;  .target-wrap &#123;    position: absolute;    top: 10px;    left: 300px;    width: 250px;    height: 250px;    background-color: tomato;  &#125;  .target &#123;    width: 150px;    height: 150px;    background-color: skyblue;  &#125;&gt;&lt;/style&gt;&gt;&lt;/head&gt;&gt;&lt;body&gt;&gt;  &lt;div class=&quot;drag&quot; draggable=&quot;true&quot;&gt;&lt;/div&gt;&gt;  &lt;div class=&quot;target-wrap&quot;&gt;&gt;    &lt;div class=&quot;target&quot;&gt;&lt;/div&gt;&gt;  &lt;/div&gt;&gt;&lt;script&gt;  // 拖拽元素  var drag = document.querySelector(&quot;.drag&quot;);  // 目标元素  var target = document.querySelector(&quot;.target&quot;);  //拖拽父元素  var targetWrap = document.querySelector(&quot;.target-wrap&quot;);  // 当拖拽元素进入目标元素时触发  target.ondragenter = function () &#123;    console.log(&quot;dragenter&quot;);  &#125;;  //当拖拽元素在有效的目标位置上时会触发;  target.ondragover = function () &#123;    console.log(&quot;dragover&quot;);  &#125;;  //当拖拽元素离开有效的目标位置上时会触发  target.ondragleave = function () &#123;    console.log(&quot;dragleave&quot;);  &#125;;  //此时box-wrap就是一个放置目标  targetWrap.ondragover = function () &#123;    console.log(&quot;targetWrap-dragover&quot;);  &#125;;  //当box被拖拽到target上时，会同时打印dragover和targetWrap-dragover&gt;&lt;/script&gt;</code></pre><ol start="3"><li><p>drop 事件</p><table><thead><tr><th>事件名</th><th>说明</th></tr></thead><tbody><tr><td>drop</td><td>drop事件在被拖拽元素或选中的文本被放置在有效的放置目标上时被触发</td></tr></tbody></table></li><li><p>默认情况，元素不允许放置</p><blockquote><ul><li>在网页中，默认情况下，<strong>唯一有效</strong>的放置目标元素是文本框。但默认<strong>只能放置文本、链接、图片</strong></li><li>页面其它元素默认情况下，是不允许放置。如果把元素拖动到不允许放置的目标上，然后放下，不会触发 <code>drop</code> 事件。</li></ul></blockquote></li></ol><pre><code>&gt;&lt;style&gt;  .drag &#123;    width: 100px;    height: 100px;    background-color: khaki;  &#125;  .target &#123;    width: 200px;    height: 100px;    border: 2px dashed #ddd;    position: absolute;    top: 10px;    left: 300px;  &#125;  textarea &#123;    width: 200px;    height: 100px;    position: absolute;    left: 300px;    top: 150px;  &#125;&gt;&lt;/style&gt;&gt;&gt;&lt;img src=&quot;https://www.arryblog.com/logo.png&quot; width=&quot;100&quot; /&gt;&gt;我是一段文字&gt;&lt;a href=&quot;www.baidu.com&quot;&gt;百度&lt;/a&gt;&gt;&lt;div class=&quot;drag&quot; draggable=&quot;true&quot;&gt;&lt;/div&gt;&gt;&lt;textarea name=&quot;&quot; id=&quot;text&quot; cols=&quot;30&quot; rows=&quot;10&quot;&gt;&lt;/textarea&gt;&gt;&lt;!--普通元素框  --&gt;&gt;&lt;div class=&quot;target&quot;&gt;&lt;/div&gt;&gt;&lt;script&gt;  var drag = document.querySelector(&quot;.drag&quot;);  var text = document.getElementById(&quot;text&quot;);  var target = document.querySelector(&quot;.target&quot;);&gt;  text.ondrop = function () &#123;    console.log(&quot;text - drop&quot;);  &#125;;  target.ondrop = function () &#123;    console.log(&quot;target - drop &quot;);  &#125;;&gt;&lt;/script&gt;</code></pre><ol start="5"><li>如何使放置元素触发 <code>drop</code> 事件<blockquote><ul><li>如果被拖拽元素在进入放置（目标）元素时，其<strong>鼠标状态</strong>显示禁止，则表示禁止该行为，在鼠标松开时，不会触发<code>drop</code>事件。</li><li>因为默认情况，元素是不允许放置的，要使目标元素能够接收到<code>drop</code>事件，需要使目标元素在<code>dragenter</code>和<code>dragover</code>事件中<strong>阻止默认行为</strong>。<blockquote><p>一般只需要在<code>dragover</code>事件中<strong>阻止默认行为</strong>就可以了</p></blockquote></li></ul></blockquote></li></ol><pre><code>  //要使放置元素的drop事件能触发，需要在dragover中禁止其默认行为 target.ondragover = function (e) &#123;   e.preventDefault(); &#125;; target.ondragenter = function (e) &#123;   e.preventDefault(); &#125;; target.ondrop = function () &#123;   console.log(&quot;target - drop &quot;); &#125;;</code></pre><ol start="6"><li>drop 事件兼容问题<blockquote><p>在 Firefox 浏览器中，drop 放置事件的默认行为如下：</p><ul><li>如果拖动元素是<strong>链接</strong>，则在放置（目标）元素上松开鼠标时，会导航到对应页面</li><li>如果拖动元素是<strong>图片</strong>，则在放置（目标）元素上松开鼠标时，会导航到图片文件</li><li>如果拖动元素是文本，会导致无效的 <code>URL</code> 错误（或默认开启百度搜索）<blockquote><p>所以如果拖动元素为以上三者，我们需要在 <code>drop</code> 放置事件中，<strong>阻止其默认行为和事件冒泡</strong></p></blockquote></li></ul></blockquote></li></ol><pre><code>e.preventDefault(); // 阻止默认行为e.stopPropagation(); // 阻止事件冒泡</code></pre><pre><code>&gt;&lt;style&gt;  .drag &#123;    width: 100px;    height: 100px;    background-color: khaki;  &#125;  .target &#123;    width: 200px;    height: 200px;    border: 2px dashed #ddd;    position: absolute;    top: 10px;    left: 220px;  &#125;&gt;&lt;/style&gt;&gt;&gt;&lt;a href=&quot;http://www.baidu.com&quot;&gt;我是大美人&lt;/a&gt;&lt;br /&gt;&gt;&lt;img src=&quot;https://www.arryblog.com/logo.png&quot; alt=&quot;&quot; width=&quot;100&quot; /&gt;&lt;br /&gt;&gt;我只是个文字&gt;&lt;div class=&quot;drag&quot; draggable=&quot;true&quot;&gt;&lt;/div&gt;&gt;&lt;div class=&quot;target&quot;&gt;&lt;/div&gt;&gt;&lt;script&gt;  var drag = document.querySelector(&quot;.drag&quot;);  var target = document.querySelector(&quot;.target&quot;);  // 要使放置元素的drop事件能触发，需要在dragover中禁止其默认行为  target.ondragover = function (e) &#123;    e.preventDefault();  &#125;;  // 放置元素绑定drop事件&gt;  target.ondrop = function (e) &#123;    console.log(&quot;drop&quot;);    e.preventDefault(); // 阻止默认行为    e.stopPropagation(); // 阻止事件冒泡  &#125;;&gt;&lt;/script&gt;</code></pre><h4 id="DataTransfer-对象"><a href="#DataTransfer-对象" class="headerlink" title="DataTransfer 对象"></a>DataTransfer 对象</h4><blockquote><ul><li>在事件对象<code>e</code>上有一个<code>dataTransfer</code>属性，这个属性是一个<code>DataTransfer</code>对象</li><li><code>e.dataTransfer</code> 对象用于保存拖放<code>（drag and drop）</code>过程中的拖拽数据，可以保存一项或多项数据，这些数据项可以是一种或者多种数据类型。</li><li><code>e.dataTransfer</code> 对象提供了相关的属性和方法实现拖放功能<blockquote><p>具体如下：</p><table><thead><tr><th>属性</th><th>说明</th></tr></thead><tbody><tr><td>dropEffect</td><td>可以告诉浏览器目标元素<strong>允许哪种放置行为</strong>， 同时会影响<strong>鼠标的样式</strong></td></tr><tr><td>effectAllowed</td><td>表示对被拖动元素<strong>是否允许</strong><code>dropEffect</code> 中设置的行为，同时会影响<strong>鼠标的样式</strong></td></tr></tbody></table></blockquote></li></ul></blockquote><table><thead><tr><th>方法</th><th>说明</th></tr></thead><tbody><tr><td>setDragImage</td><td>可以自定义一处图片元素来设置拖放图片</td></tr><tr><td>setData</td><td>方法用来设置拖放操作的<code>drag data</code>到指定的数据和类型</td></tr><tr><td>getData</td><td>方法接受指定类型的拖放(以<code>DOMString</code>的形式)数据。如果拖放行为没有操作任何数据，会返回一个空字符串</td></tr><tr><td>clearData()</td><td>删除与给定类型关联的数据,如果类型为空或未指定，则删除与所有类型关联的数据</td></tr></tbody></table><ol><li>dropEffect 属性<blockquote><ul><li><code>dropEffect</code>属性：可以告诉浏览器目标元素允许哪种放置行为，比如：复制、移动、导航等，这些只是<strong>表面形态</strong>；但具体行为的动作还需要开发者自己代码实现。</li><li>当拖动元素在目标元素上放置时，只有<code>dropEffect</code><strong>允许的行为</strong>，才会触发 drop 事件(none不会触发drop事件)</li><li>dropEffect 属性值，还会影响拖拽过程中光标的手势，这个手势；可能会预示了将要发生什么样的操作，但仅是视觉上的反馈。<blockquote><p>这个属性有以下 4 种可能值</p></blockquote></li></ul></blockquote></li></ol><table><thead><tr><th>属性值</th><th>说明</th></tr></thead><tbody><tr><td>none</td><td>被拖动元素<strong>不允许</strong>被放置在目标元素，鼠标样式是禁止状态</td></tr><tr><td>move</td><td>被拖动元素应该移动到放置的目标元素中，但必需满足 <code>dropEffect</code> 的行为是<code>effectAllowed</code>允许的行为</td></tr><tr><td>copy</td><td>被拖动元素应该复制到放置目标元素中，但必需满足 <code>dropEffect</code>的行为是<code>effectAllowed</code>允许的行为</td></tr><tr><td>link</td><td>放置目标会导航到被拖动元素（仅限它是<code>URL</code>情况）</td></tr></tbody></table><blockquote><blockquote><p>注意事项</p></blockquote><ul><li>对于<code>dragenter</code>和<code>dragover</code>事件，<code>dropEffect</code> 会根据用户的请求的行为进行<strong>初始化</strong>。具体如何初始化和浏览器平台有关。（即<strong>没有</strong>设置 <code>dropEffect</code> 属性值时，浏览器会自动为其赋值）</li><li>我们期望得到一个指定的行为而不是用户的请求行为时，可以通过 <code>dragenter</code> 和 <code>dragover</code> 事件处理中修改 <code>dropEffect</code>的值。</li></ul></blockquote><pre><code>&gt;&lt;style&gt;  .drag &#123;    width: 100px;    height: 100px;    background-color: khaki;  &#125;  .target &#123;    width: 200px;    height: 200px;    border: 2px dashed #ddd;    position: absolute;    top: 10px;    left: 220px;  &#125;&gt;&lt;/style&gt;&gt;&gt;&lt;div class=&quot;drag&quot; draggable=&quot;true&quot;&gt;&lt;/div&gt;&gt;&lt;div class=&quot;target&quot;&gt;&lt;/div&gt;&gt;&gt;&lt;script&gt;  var drag = document.querySelector(&quot;.drag&quot;); // 被拖动元素  var target = document.querySelector(&quot;.target&quot;); // 目标放置元素&gt;  // 拖动元素进入目标元素那一刻  target.ondragenter = function (e) &#123;    // 阻止默认行为，元素才能被放置，才有可能触发drop事件    e.preventDefault();    // move 允许被拖动元素移动到目标元素上 , 同时光标也会变化    e.dataTransfer.dropEffect = &quot;move&quot;;  &#125;;&gt;  target.ondragover = function (e) &#123;    // 阻止默认行为，元素才能被放置，才有可能触发drop事件    e.preventDefault();    // move 允许被拖动元素移动到目标元素上 , 同时光标也会变化    e.dataTransfer.dropEffect = &quot;move&quot;;    // 被动元素不允许放在这里，不会触发drop事件，光标为禁止样式    // e.dataTransfer.dropEffect = &quot;none&quot;;  &#125;;&gt;  target.ondrop = function () &#123;    console.log(&quot;drop&quot;);  &#125;;&gt;&lt;/script&gt;</code></pre><ol start="2"><li>effectAllowed 属性<blockquote><p><code>effectAllowed</code>属性：表示<strong>被拖动元素</strong>是否允许 <code>dropEffect</code>中设置的行为</p></blockquote></li></ol><table><thead><tr><th>属性值</th><th>说明</th></tr></thead><tbody><tr><td>none</td><td>不允许<code>dropEffect</code>的任何行为</td></tr><tr><td>copy</td><td>只允许”copy”这种<code>dropEffect</code>行为</td></tr><tr><td>link</td><td>只允许”link”这种<code>dropEffect</code>行为</td></tr><tr><td>move</td><td>只允许”move”这种<code>dropEffect</code>行为</td></tr><tr><td>copyLink</td><td>允许”copy” 和 “link”两种<code>dropEffect</code>行为,显示的是copy样式</td></tr><tr><td>copyMove</td><td>允许”copy” 和 “move”两种<code>dropEffect</code>行为,显示的是move样式</td></tr><tr><td>linkMove</td><td>允许”link” 和 “move”两种<code>dropEffect</code>行为,显示的是move样式</td></tr><tr><td>all</td><td>允许所有<code>dropEffect</code>行为,显示的是copy样式</td></tr><tr><td>uninitialized</td><td>效果没有设置时的默认值，则等同于all,显示的是copy样式</td></tr></tbody></table><blockquote><blockquote><p>注意事项</p></blockquote><ul><li>应该在<code>dragstart</code>事件处理函数中设置<code>effectAllowed</code>的属性值，以便为拖动元素设置所需的拖动效果（鼠标样式）</li><li>要看到不同属性值对应的鼠标样式，还需要在<code>document.ondragover</code>事件中，取消默认行为。</li><li>因为默认情况下，元素是不允许被放置的，所以在拖动元素时，事件会冒泡到<code>document</code>的<code>ondragover</code>事件中，鼠标样式为禁用。（整个拖动过程中<code>document</code>默认都是被放置元素）</li><li>如果<code>effectAllowed</code>的值，不是在<code>dropEffect</code>允许的范围，则不会触发<code>drop</code>事件；同时拖动元素进入目标元素时，鼠标样式为<strong>禁止样式</strong></li><li>在进入目标元素前，鼠标为<code>effectAllowed</code>设置的样式，进入后，鼠标为<code>dropEffect</code>设置的样式&#x2F;禁止样式</li></ul></blockquote><pre><code>&gt;&lt;style&gt;  .drag &#123;    width: 100px;    height: 100px;    background-color: khaki;  &#125;  .target &#123;    width: 200px;    height: 200px;    border: 2px dashed #ddd;    position: absolute;    left: 200px;    top: 10px;  &#125;&gt;&lt;/style&gt;&gt;&gt;&lt;div class=&quot;drag&quot; draggable=&quot;true&quot;&gt;&lt;/div&gt;&gt;&lt;div class=&quot;target&quot;&gt;&lt;/div&gt;&gt;&lt;script&gt;  var drag = document.querySelector(&quot;.drag&quot;);  var target = document.querySelector(&quot;.target&quot;);  drag.ondragstart = function (e) &#123;    // 设置被拖动元素允许的 dropEffect行为    e.dataTransfer.effectAllowed = &quot;linkMove&quot;;  &#125;;  document.ondragover = function (e) &#123;    // 禁止默认行为,才能看到拖动元素的光标样式与effectAllowed的值对应    e.preventDefault();  &#125;;  target.ondragover = function (e) &#123;    //阻止默认行为，target元素才能允许被放置    e.preventDefault();    // 如果EffectAllowed的值不是在 dropEffect允许内，不会触发drop事件，同时光标为禁止    e.dataTransfer.dropEffect = &quot;link&quot;;  &#125;;  target.ondrop = function (e) &#123;    console.log(&quot;drop&quot;);  &#125;;&gt;&lt;/script&gt;</code></pre><ol start="4"><li>setData 、getData 方法<table><thead><tr><th>方法</th><th>说明</th></tr></thead><tbody><tr><td>setData</td><td>方法用来设置拖放操作的<code>drag data</code>到指定的数据和类型</td></tr><tr><td>getData</td><td>方法读取指定类型的拖放(以<code>DOMString</code>的形式)数据。如果拖放行为没有操作任何数据，会返回一个空字符串</td></tr></tbody></table></li></ol><blockquote><p>语法</p></blockquote><pre><code>e.dataTransfer.setData(format, data); // 保存数据e.dataTransfer.getData(format); // 取出数据</code></pre><blockquote><ul><li><code>data</code>表示要存入的数据</li><li><code>format</code>表示存入的数据类型，常见的支持类型如下：<blockquote><p>推荐的拖动数据类型参考官网链接地址：<code>https://developer.mozilla.org/zh-CN/docs/Web/API/HTML_Drag_and_Drop_API/Recommended_drag_types</code></p></blockquote></li></ul></blockquote><table><thead><tr><th>数据类型</th><th>说明</th></tr></thead><tbody><tr><td>text&#x2F;plain 支持简写：text</td><td>文本类型（string）</td></tr><tr><td>text&#x2F;html</td><td>HTML文字</td></tr><tr><td>text&#x2F;xml</td><td>XML文字</td></tr><tr><td>text&#x2F;uri-list支持简写： url</td><td>链接</td></tr><tr><td>application&#x2F;x-moz-file</td><td>文件</td></tr></tbody></table><blockquote><blockquote><p>注意事项</p></blockquote><ul><li>一般都会在<code>dragstart</code>事件中，利用<code>e.dataTransfer.setData()</code>保存数据,可以存储一项或多项</li><li>存储在<code>dataTransfer</code>对象中的数据只能在<code>drop</code>放置事件中读取。</li><li>如果没有在<code>drop</code>事件处理函数中取得这些数据，随后 <code>dataTransfer</code>对象被销毁，数据也就丢失了。</li></ul></blockquote><pre><code>&gt;&lt;style&gt;  .drag &#123;    width: 100px;    height: 100px;    background-color: khaki;  &#125;  .target &#123;    width: 200px;    height: 200px;    border: 2px dashed #ddd;    position: absolute;    left: 200px;    top: 10px;  &#125;&gt;&lt;/style&gt;&gt;&lt;div class=&quot;drag&quot; draggable=&quot;true&quot; id=&quot;J_drag&quot;&gt;&lt;/div&gt;&gt;&lt;div class=&quot;target&quot;&gt;&lt;/div&gt;&gt;&gt;&lt;script&gt;  var drag = document.querySelector(&quot;.drag&quot;);  var target = document.querySelector(&quot;.target&quot;);  drag.ondragstart = function (e) &#123;    e.dataTransfer.setData(&quot;text&quot;, e.target.id);    // 下面这种情况保存id，在获取时得到的数据为空，因为他会把后面数据当链接处理    // e.dataTransfer.setData(&quot;url&quot;, e.target.id);    this.style.opacity = &quot;0.3&quot;;  &#125;;&gt;  target.ondragover = function (e) &#123;    //允许放置行为    e.preventDefault();  &#125;;&gt;  target.ondrop = function (e) &#123;    var id = e.dataTransfer.getData(&quot;text&quot;);    // var id = e.dataTransfer.getData(&quot;url&quot;);    // console.log(id);    var dragElement = document.getElementById(id);    target.appendChild(dragElement);    drag.style.opacity = &quot;1&quot;;  &#125;;&gt;&lt;/script&gt;</code></pre><ol start="5"><li>clearData<blockquote><ul><li><code>clearData()</code>方法删除给定类型的拖动操作的<code>drag data</code>，如果给定类型的数据不存在，则此方法不执行任何操作</li><li>如果不带参数，默认清空所有setData方式添加的数据</li></ul></blockquote></li></ol><pre><code>// 清空对应类型数据  如果不带参数，默认清空所有setData方式添加的数据e.dataTransfer.clearData([format]);</code></pre><ol start="6"><li>setDragImage<blockquote><ul><li><code>setDragImage</code>可以自定义一个<code>img</code>类型，用来设置拖放过程中的鼠标下面的图标</li><li>在<code>dragstart</code>里创建图片元素</li></ul></blockquote></li></ol><pre><code>setDragImage(element, x, y);</code></pre><blockquote><ul><li><code>element</code>拖拽时鼠标下面的图片，必需是一个元素节点</li><li>x表示：图标距离鼠标指针的 x 轴方向的偏移量</li><li>y表示：图标距离鼠标指针 y 轴方向的偏移量</li></ul></blockquote><pre><code>&gt;&lt;div class=&quot;drag&quot; draggable=&quot;true&quot; id=&quot;J_drag&quot;&gt;&lt;/div&gt;&gt;&lt;div class=&quot;target&quot;&gt;&lt;/div&gt;&gt;&lt;script&gt;  var drag = document.querySelector(&quot;.drag&quot;);  var target = document.querySelector(&quot;.target&quot;);&gt;  drag.ondragstart = function (e) &#123;    //创建图片元素    var img = document.createElement(&quot;img&quot;);    img.src = &quot;../src/skin/min1.jpg&quot;;    e.dataTransfer.setDragImage(img, 100, 100); // 设置自定义图拖拽图像  &#125;;&gt;&lt;/script&gt;</code></pre><h3 id="四、HTML5-拖拽综合应用案例"><a href="#四、HTML5-拖拽综合应用案例" class="headerlink" title="四、HTML5 拖拽综合应用案例"></a>四、HTML5 拖拽综合应用案例</h3><blockquote><p>结合本章节所学内容进行综合实践应用。</p></blockquote><ol><li>双向拖拽添加内容<blockquote><p>涉及知识点</p><ul><li>事件委托</li><li>拖拽事件（dragstart、dragend、dragover、drop）</li></ul></blockquote></li></ol><ul><li>CSS布局</li></ul><pre><code>&gt;&lt;style&gt;  html,  body,  ul,  li &#123;    margin: 0;    padding: 0;  &#125;  li &#123;    list-style: none;  &#125;  .container &#123;    display: flex;    justify-content: space-around;    width: 600px;    margin: 50px;  &#125;  .container h3 &#123;    text-align: center;  &#125;  .drag-wrap,  .target-wrap &#123;    width: 200px;    height: 280px;  &#125;  .drag-wrap &#123;    border: 1px solid #ddd;  &#125;  .target-wrap &#123;    border: 2px dashed #ddd;  &#125;  .drag-wrap li,  .target-wrap li &#123;    height: 40px;    margin: 5px;    color: #fff;    text-align: center;    font-size: 20px;    line-height: 40px;    cursor: pointer;  &#125;  .drag-wrap li:hover,  .target-wrap li:hover &#123;    background-color: khaki;  &#125;  .drag-wrap li &#123;    background-color: #ddd;  &#125;  .target-wrap li &#123;    background-color: lightcoral;  &#125;&gt;&lt;/style&gt;&gt;&lt;div class=&quot;container&quot;&gt;&gt;  &lt;div class=&quot;select-fruit&quot;&gt;&gt;    &lt;h3&gt;选择你喜欢的水果&lt;/h3&gt;&gt;    &lt;ul class=&quot;drag-wrap&quot;&gt;&gt;      &lt;li class=&quot;drag-item&quot; draggable=&quot;true&quot;&gt;苹果&lt;/li&gt;&gt;      &lt;li class=&quot;drag-item&quot; draggable=&quot;true&quot;&gt;梨子&lt;/li&gt;&gt;      &lt;li class=&quot;drag-item&quot; draggable=&quot;true&quot;&gt;水蜜桃&lt;/li&gt;&gt;      &lt;li class=&quot;drag-item&quot; draggable=&quot;true&quot;&gt;荔枝&lt;/li&gt;&gt;      &lt;li class=&quot;drag-item&quot; draggable=&quot;true&quot;&gt;葡萄&lt;/li&gt;&gt;      &lt;li class=&quot;drag-item&quot; draggable=&quot;true&quot;&gt;香蕉&lt;/li&gt;&gt;    &lt;/ul&gt;&gt;  &lt;/div&gt;&gt;  &lt;div class=&quot;like-fruit&quot;&gt;&gt;    &lt;h3&gt;你最喜欢的水果是&lt;/h3&gt;&gt;    &lt;ul class=&quot;target-wrap&quot;&gt;&lt;/ul&gt;&gt;  &lt;/div&gt;&gt;&lt;/div&gt;</code></pre><ul><li>JS实现<blockquote><ul><li>在这个案例中，拖动元素的容器本身也是放置目标元素。</li><li>放置目标元素中的子元素，本身也是被拖动的元素。</li><li>所有拖动元素要处理的事情，全部委托给他到们的父容器来处理。</li><li>声明一个元素来记录当前被拖动的元素，放置到目标区域时，将该元素插入页面中</li></ul></blockquote></li></ul><pre><code>&gt;&lt;script&gt;  var dragWrap = document.querySelector(&quot;.drag-wrap&quot;);  var targetWrap = document.querySelector(&quot;.target-wrap&quot;);  var dragElement = null; //记录当前被拖动的元素  //从左往右：  //拖拽元素  dragWrap.ondragstart = dragStartHandle;  dragWrap.ondragend = dragEndHandle;  //放置元素  targetWrap.ondragover = dragOver;  targetWrap.ondrop = dropHandle;  //从右往左：  //拖拽元素  targetWrap.ondragstart = dragStartHandle;  targetWrap.ondragend = dragEndHandle;  //放置元素  dragWrap.ondragover = dragOver;  dragWrap.ondrop = dropHandle;&gt;  //处理拖拽元素  function dragStartHandle(e) &#123;    var target = e.target;    target.style.opacity = &quot;0.5&quot;;    dragElement = target;    e.dataTransfer.effctAllowed = &quot;move&quot;;  &#125;  function dragEndHandle(e) &#123;    var target = e.target;    target.style.opacity = &quot;1&quot;; //恢复透明度  &#125;  //处理放置元素  function dragOver(e) &#123;    e.preventDefault(); //禁止默认行为    e.dataTransfer.dropEffect = &quot;move&quot;;  &#125;  function dropHandle(e) &#123;    this.appendChild(dragElement);    dragElement.style.opacity = &quot;1&quot;; //恢复透明度  &#125;  document.ondragover = function (e) &#123;    e.preventDefault();  &#125;;&gt;&lt;/script&gt;</code></pre><ol start="2"><li>页面中随意拖拽<blockquote><ul><li>获取拖动前，元素的<code>offsetLeft</code>、<code>offsetTop</code></li><li>获取被拖动那一刻<code>dragstart</code>，鼠标的位置<code>_clientX</code>、<code>_clientY</code></li><li>获取被拖动时，鼠标的位置<code>clientX</code>、<code>clientY</code></li><li>元素的<code>left</code>&#x3D;<code>clientX-_clientX+offsetLeft</code></li><li>元素的<code>top</code>&#x3D;<code>clientY-_clientY+offsetTop</code><blockquote><p>注意：</p></blockquote></li><li>当放置元素没有触发drop事件时，元素被拖拽后会迅速回到原位置</li><li>松开元素后，鼠标的位置<code>clientX</code>、<code>clientY</code>变成0；由于公式控制了元素的<code>left</code>、<code>top</code>，所以回不到原来的位置</li><li>因此，必须在放置元素的<code>dragover</code>事件中阻止默认行为。</li></ul></blockquote></li></ol><pre><code>&gt;&lt;style&gt;  html,  body &#123;    margin: 0;    padding: 0;  &#125;  .box &#123;    position: absolute;    left: 100px;    top: 100px;    width: 200px;    height: 200px;    background-color: khaki;  &#125;&gt;&lt;/style&gt;&gt;&gt;&lt;div class=&quot;box&quot; draggable=&quot;true&quot;&gt;&lt;/div&gt;&gt;&lt;script&gt;  var box = document.querySelector(&quot;.box&quot;);  document.ondragover = function (e) &#123;    e.preventDefault();  &#125;;  var offsetLeft;  var offsetTop;  var _clientX;  var _clientY;&gt;  box.ondragstart = function (e) &#123;    _clientX = e.clientX;    _clientY = e.clientY;    offsetLeft = this.offsetLeft;    offsetTop = this.offsetTop;  &#125;; //213 171 100 100  box.ondrag = function (e) &#123;    var clientX = e.clientX;    var clientY = e.clientY;    var left = clientX - _clientX + offsetLeft;    var top = clientY - _clientY + offsetTop;    this.style.left = left + &quot;px&quot;;    this.style.top = top + &quot;px&quot;;  &#125;;&gt;&lt;/script&gt;</code></pre><ol start="3"><li>拖拽排序<blockquote><p>核心知识</p><ul><li>拖拽相关事件</li><li>占位思想</li><li>找出相邻兄弟中离自己最近的元素</li><li>insertAdjacentElement 方法</li><li>prepend 方法</li></ul></blockquote></li></ol><ul><li>CSS布局</li></ul><pre><code>&gt;&lt;style&gt;  html,  body,  ul,  li &#123;    margin: 0;    padding: 0;  &#125;  li &#123;    list-style: none;  &#125;  .drag-wrap &#123;    position: relative;    width: 200px;    height: 280px;    padding: 10px;    margin: 50px;    border: 1px solid #ddd;  &#125;  .drag-wrap .drag-item &#123;    width: 200px;    height: 50px;    background-color: #ddd;    margin: 5px auto;    text-align: center;    line-height: 50px;    cursor: pointer;  &#125;  .drag-wrap .draging &#123;    background-color: khaki;  &#125;  .stand &#123;    width: 200px;    height: 50px;    margin: 5px auto;  &#125;&gt;&lt;/style&gt;&gt;&lt;ul class=&quot;drag-wrap&quot;&gt;&gt;  &lt;li class=&quot;drag-item&quot; draggable=&quot;true&quot;&gt;苹果&lt;/li&gt;&gt;  &lt;li class=&quot;drag-item&quot; draggable=&quot;true&quot;&gt;香蕉&lt;/li&gt;&gt;  &lt;li class=&quot;drag-item&quot; draggable=&quot;true&quot;&gt;梨子&lt;/li&gt;&gt;  &lt;li class=&quot;drag-item&quot; draggable=&quot;true&quot;&gt;葡萄&lt;/li&gt;&gt;  &lt;li class=&quot;drag-item&quot; draggable=&quot;true&quot;&gt;火龙果&lt;/li&gt;&gt;&lt;/ul&gt;</code></pre><ul><li>JS 实现原理<br><strong>第一步：实现鼠标按下开始拖动时要处理的事情</strong><blockquote><ul><li>1、为了后面 drag 事件中能获取到当前拖动的元素，还需要<strong>把拖动元素保存到全局变量</strong>中</li><li>2、把拖动元素的<strong>背景色</strong>设置为黄色</li><li>3、同时把拖动元素设置为<strong>绝对定位</strong>元素，设置好初始 left 和 top 值，同时把 margin 值为 0</li><li>4、<strong>创建一个 div 元素</strong>，作为占位元素，其宽、高、margin 和被拖动元素一样，然后把创建好的空元素插入当前元素前面。</li><li>5、为了后面拖动元素，还需要在此记录鼠标按下时<strong>与浏览器左边和上边的距离</strong>。<blockquote><p>以上拖动元素需要处理的事情，全委托给他们的父元素来处理。</p></blockquote></li></ul></blockquote></li></ul><pre><code>  var dragWrap = document.querySelector(&quot;.drag-wrap&quot;);  var standElement = null;  var dragElement = null;  var dragLeft;  var dragTop;  var pageX;  var pageY;&gt;  //刚开始拖动时，需要处理的事件  dragWrap.ondragstart = function (e) &#123;    var target = e.target;    //1.元素背景变色    target.classList.add(&quot;draging&quot;);    //2.把拖拽元素设置成为绝对定位元素，设置left、top、margin    dragLeft = target.offsetLeft;    dragTop = target.offsetTop;    dragElement = target;    target.style.display = &quot;none&quot;;    target.style.position = &quot;absolute&quot;;    target.style.left = dragLeft + &quot;px&quot;;    target.style.top = dragTop + &quot;px&quot;;    target.style.margin = &quot;0 auto&quot;;    target.style.display = &quot;block&quot;;    //3.创建站位元素    standElement = document.createElement(&quot;div&quot;);    standElement.classList.add(&quot;stand&quot;);    this.insertBefore(standElement, target);&gt;    pageX = e.pageX;    pageY = e.pageY;  &#125;;</code></pre><p><strong>第二步：拖动过程中要处理的事情</strong></p><blockquote><ul><li>元素能正常随着鼠标<strong>拖动</strong>，动态改变<code>left</code>、和<code>top</code></li><li>找到与当前拖动元素同时满足以下条件的<strong>兄弟元素</strong>（兄弟元素不包含占位元素）<ul><li>拖动元素底部与浏览器的距离 &gt;&#x3D; 兄弟元素垂直中心点与浏览器顶部的距离</li></ul></li><li>封装一个函数来实现，如果有对应的兄弟元素就将元素返回，没有就返回 <code>null</code></li><li>如果有满足条件的兄弟元素，就将兄弟元素的<strong>背景色变为红色</strong>，同时将占位符<strong>插入</strong>当前兄弟元素的后面。</li><li>如果没有满足条件的兄弟元素，说明当前拖动元素在第一个子元素的前面，此时可以将占位元素插入到父元素的第一个子元素的前面。目的是在与最前面一个元素交换时，能将它挤到第二个<ul><li>将新节点插入到参考节点后面：<code>referenceNode.insertAdjacentElement(&quot;afterend&quot;, neNode);</code></li><li>将节点插入到父节点的最前面：<code>父节点.prepend(child)</code></li></ul></li></ul></blockquote><pre><code>//元素被拖动过程中，应处理的事dragWrap.ondrag = function (e) &#123;  var _pageX = e.pageX;  var _pageY = e.pageY;  //改变元素的位置，动态赋值  var left = _pageX - pageX + dragLeft;  var top = _pageY - pageY + dragTop;  dragElement.style.left = left + &quot;px&quot;;  dragElement.style.top = top + &quot;px&quot;;  //找到符合要求的兄弟元素，  //改变它的背景色，并将占位元素插入当前兄弟元素的后面。  var nearSibling = findSibling(dragElement);  //如果nearSibling=null,说明当前拖动元素在第一个子元素的最前面  if (!nearSibling) &#123;    // 将占位元素插入到父元素的第一个子元素的前面    dragWrap.prepend(standElement);  &#125;  //如果存在最近的兄弟元素  if (nearSibling) &#123;    //将前一个颜色恢复    prevNearSibling &amp;&amp; (prevNearSibling.style.backgroundColor = &quot;&quot;);    //改变它的背景色    nearSibling.style.backgroundColor = &quot;red&quot;;    prevNearSibling = nearSibling;    //将占位元素插入到兄弟元素的后面    nearSibling.insertAdjacentElement(&quot;afterend&quot;, standElement);  &#125;&#125;;&gt;//函数：找到符合要求的兄弟元素function findSibling(dragEle) &#123;  //条件:1.不包含占位元素  //2.拖动元素底部与浏览器的距离&gt;= 兄弟元素垂直中心点与浏览器顶部的距离  //获取拖拽元素到浏览器顶部的距离  var rect = dragEle.getBoundingClientRect();  var rectBottom = rect.bottom;  // 获取拖动元素的所有兄弟元素  var siBlings = dragEle.parentNode.children;  //将类数组转成数组  siBlings = Array.prototype.slice.call(siBlings, 0);  //首先过滤掉占位元素  siBlings = siBlings.filter(function (item) &#123;    return item !== standElement;  &#125;);  var result = null; //用来保存找到了满足条件兄弟元素  for (var i = 0; i &lt; siBlings.length; i++) &#123;    //排除自身    if (siBlings[i] === dragEle) continue; //跳过当次    var rect1 = siBlings[i].getBoundingClientRect();    // 获取每个元素中心与浏览器顶部的距离    var center = rect1.y + siBlings[i].offsetHeight / 2;    // 找到离自己最近的满足 rectBottom&gt;center的兄弟元素    if (rectBottom &gt; center) &#123;      result = siBlings[i];    &#125; else &#123;      return result;    &#125;  &#125;  return result;&#125;</code></pre><blockquote><blockquote><p>注意：</p></blockquote><ul><li>整个<code>drag</code>操作过程的样式要生效，必需要设置父容器为允许放置行为，即在<code>dragover</code>中取消默认行为</li></ul></blockquote><pre><code>dragWrap.ondragover = function (e) &#123;  e.preventDefault();&#125;;</code></pre><p><strong>第三步：拖动结束要处理的事情</strong></p><blockquote><ul><li>拖动元素的背景色还原</li><li>拖动元素要取消定位，同时恢复 margin 值</li><li>将拖动元素放入占位元素所在位置（前或后）</li><li>将占位元素从页面中移除</li><li>如果存在前一个背景变红的兄弟元素，将红色背景去掉，使页面最后无红色背景元素</li></ul></blockquote><pre><code> //拖拽结束时，应该处理的事 dragWrap.ondragend = function (e) &#123;   var target = e.target;   //1.拖拽元素恢复颜色   target.classList.remove(&quot;draging&quot;);   //2.把拖动的元素还原，去掉绝对定位和margin   target.style.position = &quot;&quot;;   target.style.margin = &quot;5px auto&quot;;   //3.将拖动元素放入占位元素所在位置（前或后）   this.insertBefore(dragElement, standElement);   //4.删除站位节点   this.removeChild(standElement);   //如果存在前一个背景变红的兄弟元素，将红色背景去掉   prevNearSibling &amp;&amp; (prevNearSibling.style.backgroundColor = &quot;&quot;); &#125;;</code></pre><p><strong>完整源码</strong></p><pre class=" language-js"><code class="language-js"><span class="token operator">></span><span class="token operator">&lt;</span>script<span class="token operator">></span>  <span class="token keyword">var</span> dragWrap <span class="token operator">=</span> document<span class="token punctuation">.</span><span class="token function">querySelector</span><span class="token punctuation">(</span><span class="token string">".drag-wrap"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token keyword">var</span> dragLeft<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 记录被拖动元素的初始left值</span>  <span class="token keyword">var</span> dragTop<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 记录被拖动元素的初始top值</span>  <span class="token keyword">var</span> pageX<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 记录拖动元素开始拖动时，鼠标与浏览器的水平距离</span>  <span class="token keyword">var</span> pageY<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 记录拖动元素开始拖动时，鼠标与浏览器的垂直距离</span>  <span class="token keyword">var</span> standElement <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 用来保存占位元素</span>  <span class="token keyword">var</span> dragElement <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 记录被拖动的元素</span>  <span class="token keyword">var</span> prevNearSibling <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//保存前一个最近的兄弟元素</span><span class="token operator">></span>  <span class="token comment" spellcheck="true">//刚开始拖动时，需要处理的事件</span>  dragWrap<span class="token punctuation">.</span>ondragstart <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span>e<span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>    <span class="token keyword">var</span> target <span class="token operator">=</span> e<span class="token punctuation">.</span>target<span class="token punctuation">;</span>    dragElement <span class="token operator">=</span> target<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//记录被拖动的元素</span>    <span class="token comment" spellcheck="true">//1.元素背景变色</span>    target<span class="token punctuation">.</span>classList<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token string">"draging"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//2.把拖拽元素设置成为绝对定位元素，设置left、top、margin</span>    dragLeft <span class="token operator">=</span> target<span class="token punctuation">.</span>offsetLeft<span class="token punctuation">;</span>    dragTop <span class="token operator">=</span> target<span class="token punctuation">.</span>offsetTop<span class="token punctuation">;</span>    target<span class="token punctuation">.</span>style<span class="token punctuation">.</span>display <span class="token operator">=</span> <span class="token string">"none"</span><span class="token punctuation">;</span>    target<span class="token punctuation">.</span>style<span class="token punctuation">.</span>position <span class="token operator">=</span> <span class="token string">"absolute"</span><span class="token punctuation">;</span>    target<span class="token punctuation">.</span>style<span class="token punctuation">.</span>left <span class="token operator">=</span> dragLeft <span class="token operator">+</span> <span class="token string">"px"</span><span class="token punctuation">;</span>    target<span class="token punctuation">.</span>style<span class="token punctuation">.</span>top <span class="token operator">=</span> dragTop <span class="token operator">+</span> <span class="token string">"px"</span><span class="token punctuation">;</span>    target<span class="token punctuation">.</span>style<span class="token punctuation">.</span>margin <span class="token operator">=</span> <span class="token string">"0 auto"</span><span class="token punctuation">;</span>    target<span class="token punctuation">.</span>style<span class="token punctuation">.</span>display <span class="token operator">=</span> <span class="token string">"block"</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//3.创建站位元素,将其插入当前拖动元素的后面</span>    standElement <span class="token operator">=</span> document<span class="token punctuation">.</span><span class="token function">createElement</span><span class="token punctuation">(</span><span class="token string">"div"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    standElement<span class="token punctuation">.</span>classList<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token string">"stand"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    dragElement<span class="token punctuation">.</span><span class="token function">insertAdjacentElement</span><span class="token punctuation">(</span><span class="token string">"afterend"</span><span class="token punctuation">,</span> standElement<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//4.记录鼠标按下开始拖动时，鼠标与浏览器左边和顶部的距离</span>    pageX <span class="token operator">=</span> e<span class="token punctuation">.</span>pageX<span class="token punctuation">;</span>    pageY <span class="token operator">=</span> e<span class="token punctuation">.</span>pageY<span class="token punctuation">;</span>  <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span><span class="token punctuation">;</span><span class="token operator">></span>  <span class="token comment" spellcheck="true">//元素被拖动过程中，应处理的事</span>  dragWrap<span class="token punctuation">.</span>ondrag <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span>e<span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 获取鼠标与浏览器左边和上边距离</span>    <span class="token keyword">var</span> _pageX <span class="token operator">=</span> e<span class="token punctuation">.</span>pageX<span class="token punctuation">;</span>    <span class="token keyword">var</span> _pageY <span class="token operator">=</span> e<span class="token punctuation">.</span>pageY<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//改变元素的位置，动态赋值</span>    <span class="token keyword">var</span> left <span class="token operator">=</span> _pageX <span class="token operator">-</span> pageX <span class="token operator">+</span> dragLeft<span class="token punctuation">;</span>    <span class="token keyword">var</span> top <span class="token operator">=</span> _pageY <span class="token operator">-</span> pageY <span class="token operator">+</span> dragTop<span class="token punctuation">;</span>    dragElement<span class="token punctuation">.</span>style<span class="token punctuation">.</span>left <span class="token operator">=</span> left <span class="token operator">+</span> <span class="token string">"px"</span><span class="token punctuation">;</span>    dragElement<span class="token punctuation">.</span>style<span class="token punctuation">.</span>top <span class="token operator">=</span> top <span class="token operator">+</span> <span class="token string">"px"</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//找到符合要求的兄弟元素，</span>    <span class="token comment" spellcheck="true">//改变它的背景色，并将占位元素插入当前兄弟元素的后面。</span>    <span class="token keyword">var</span> nearSibling <span class="token operator">=</span> <span class="token function">findSibling</span><span class="token punctuation">(</span>dragElement<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//如果nearSibling=null,说明当前拖动元素在第一个子元素的最前面</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>nearSibling<span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>      <span class="token comment" spellcheck="true">// 将占位元素插入到父元素的第一个子元素的前面</span>      dragWrap<span class="token punctuation">.</span><span class="token function">prepend</span><span class="token punctuation">(</span>standElement<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//如果存在最近的兄弟元素</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>nearSibling<span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>      <span class="token comment" spellcheck="true">//将前一个颜色恢复</span>      prevNearSibling <span class="token operator">&amp;&amp;</span> <span class="token punctuation">(</span>prevNearSibling<span class="token punctuation">.</span>style<span class="token punctuation">.</span>backgroundColor <span class="token operator">=</span> <span class="token string">""</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token comment" spellcheck="true">//改变它的背景色</span>      nearSibling<span class="token punctuation">.</span>style<span class="token punctuation">.</span>backgroundColor <span class="token operator">=</span> <span class="token string">"red"</span><span class="token punctuation">;</span>      prevNearSibling <span class="token operator">=</span> nearSibling<span class="token punctuation">;</span>      <span class="token comment" spellcheck="true">//将占位元素插入到兄弟元素的后面</span>      nearSibling<span class="token punctuation">.</span><span class="token function">insertAdjacentElement</span><span class="token punctuation">(</span><span class="token string">"afterend"</span><span class="token punctuation">,</span> standElement<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>  <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span><span class="token punctuation">;</span><span class="token operator">></span>  <span class="token comment" spellcheck="true">//拖拽结束时，应该处理的事</span>  dragWrap<span class="token punctuation">.</span>ondragend <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span>e<span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>    <span class="token keyword">var</span> target <span class="token operator">=</span> e<span class="token punctuation">.</span>target<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//1.拖拽元素恢复颜色</span>    target<span class="token punctuation">.</span>classList<span class="token punctuation">.</span><span class="token function">remove</span><span class="token punctuation">(</span><span class="token string">"draging"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//2.把拖动的元素还原，去掉绝对定位和margin</span>    target<span class="token punctuation">.</span>style<span class="token punctuation">.</span>position <span class="token operator">=</span> <span class="token string">""</span><span class="token punctuation">;</span>    target<span class="token punctuation">.</span>style<span class="token punctuation">.</span>margin <span class="token operator">=</span> <span class="token string">"5px auto"</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//3.将拖动元素放入占位元素所在位置（前或后）</span>    <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">insertBefore</span><span class="token punctuation">(</span>dragElement<span class="token punctuation">,</span> standElement<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//4.删除站位节点</span>    <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">removeChild</span><span class="token punctuation">(</span>standElement<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//如果存在前一个背景变红的兄弟元素，将红色背景去掉</span>    prevNearSibling <span class="token operator">&amp;&amp;</span> <span class="token punctuation">(</span>prevNearSibling<span class="token punctuation">.</span>style<span class="token punctuation">.</span>backgroundColor <span class="token operator">=</span> <span class="token string">""</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span><span class="token punctuation">;</span><span class="token operator">></span>  dragWrap<span class="token punctuation">.</span>ondragover <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span>e<span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>    e<span class="token punctuation">.</span><span class="token function">preventDefault</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//允许放置</span>    e<span class="token punctuation">.</span>dataTransfer<span class="token punctuation">.</span>dropEffect <span class="token operator">=</span> <span class="token string">"move"</span><span class="token punctuation">;</span>  <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span><span class="token punctuation">;</span><span class="token operator">></span>  <span class="token comment" spellcheck="true">//找到符合要求的兄弟元素</span>  <span class="token keyword">function</span> <span class="token function">findSibling</span><span class="token punctuation">(</span>dragEle<span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//条件:1.不包含占位元素</span>    <span class="token comment" spellcheck="true">//2.拖动元素底部与浏览器的距离>= 兄弟元素垂直中心点与浏览器顶部的距离</span>    <span class="token comment" spellcheck="true">//获取拖拽元素到浏览器顶部的距离</span>    <span class="token keyword">var</span> rect <span class="token operator">=</span> dragEle<span class="token punctuation">.</span><span class="token function">getBoundingClientRect</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">var</span> rectBottom <span class="token operator">=</span> rect<span class="token punctuation">.</span>bottom<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 获取拖动元素的所有兄弟元素</span>    <span class="token keyword">var</span> siBlings <span class="token operator">=</span> dragEle<span class="token punctuation">.</span>parentNode<span class="token punctuation">.</span>children<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//将类数组转成数组</span>    siBlings <span class="token operator">=</span> Array<span class="token punctuation">.</span>prototype<span class="token punctuation">.</span>slice<span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span>siBlings<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//首先过滤掉占位元素</span>    siBlings <span class="token operator">=</span> siBlings<span class="token punctuation">.</span><span class="token function">filter</span><span class="token punctuation">(</span><span class="token keyword">function</span> <span class="token punctuation">(</span>item<span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>      <span class="token keyword">return</span> item <span class="token operator">!==</span> standElement<span class="token punctuation">;</span>    <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">var</span> result <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//用来保存找到了满足条件兄弟元素</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">var</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> siBlings<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>      <span class="token comment" spellcheck="true">//排除自身</span>      <span class="token keyword">if</span> <span class="token punctuation">(</span>siBlings<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">===</span> dragEle<span class="token punctuation">)</span> <span class="token keyword">continue</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//跳过当次</span>      <span class="token keyword">var</span> rect1 <span class="token operator">=</span> siBlings<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">getBoundingClientRect</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token comment" spellcheck="true">// 获取每个元素中心与浏览器顶部的距离</span>      <span class="token keyword">var</span> center <span class="token operator">=</span> rect1<span class="token punctuation">.</span>y <span class="token operator">+</span> siBlings<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>offsetHeight <span class="token operator">/</span> <span class="token number">2</span><span class="token punctuation">;</span>      <span class="token comment" spellcheck="true">// 找到离自己最近的满足 rectBottom>center的兄弟元素</span>      <span class="token keyword">if</span> <span class="token punctuation">(</span>rectBottom <span class="token operator">></span> center<span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>        result <span class="token operator">=</span> siBlings<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>      <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span> <span class="token keyword">else</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> result<span class="token punctuation">;</span>      <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>    <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> result<span class="token punctuation">;</span>  <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span><span class="token operator">></span><span class="token operator">&lt;</span><span class="token operator">/</span>script<span class="token operator">></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JS核心知识点（十一）</title>
      <link href="/2023/12/07/JS%E6%A0%B8%E5%BF%83%E7%9F%A5%E8%AF%86%E7%82%B9%EF%BC%88%E5%8D%81%E4%B8%80%EF%BC%89/"/>
      <url>/2023/12/07/JS%E6%A0%B8%E5%BF%83%E7%9F%A5%E8%AF%86%E7%82%B9%EF%BC%88%E5%8D%81%E4%B8%80%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<span id="more"></span><h3 id="一、定时器与延时器"><a href="#一、定时器与延时器" class="headerlink" title="一、定时器与延时器"></a>一、定时器与延时器</h3><h4 id="setInterval-与-clearInterval"><a href="#setInterval-与-clearInterval" class="headerlink" title="setInterval() 与 clearInterval()"></a>setInterval() 与 clearInterval()</h4><blockquote><ul><li><code>setInterval()</code>方法设置一个定时器，每间隔相同的一段时间，重复调用一个函数或执行一个代码片段</li><li>清除定时器：<code>clearInterval()</code> 函数可以清除一个定时器</li></ul></blockquote><pre><code>// 基本语法var timer = setInterval(funtion, delay, arg1, arg2, arg3);</code></pre><blockquote><ul><li>function：这个参数是一个<strong>函数</strong>，每经过指定 <code>delay</code> 毫秒后执行一次。第一次调用发生在 <code>delay</code> 毫秒之后。</li><li>delay：表示定时器延迟的时间，<strong>以毫秒为单位</strong>，1 秒等于 1000 毫秒</li><li>arg1…arg3：每次定时器到指定时间，要执行 function 函数前，这些参数会被当成 function 的参数传递给 function</li><li>timer：表示延时器的<strong>返回值</strong>，返回值是一个<strong>正整数</strong>，表示定时器的编号，这个值可以传递给<code>clearInterval()</code>来取消该定时器</li></ul></blockquote><pre><code>&gt;&lt;button&gt;点击结束&lt;/button&gt;&gt;&lt;script&gt;  //不传参数  var timer1 = setInterval(function () &#123;    console.log(1);  &#125;, 1000);  //传参  var timer2 = setInterval(    function (a, b) &#123;        console.log(a, b);    &#125;,    1000,    5,    10  );&gt;  //具名函数也可以传入setInterval  var a = 0;  function fun() &#123;    console.log(++a);  &#125;  // 具名函数当做第一个参数，注意：fun这里没有圆括号  setInterval(fun, 1000);&gt;  //直接使用一段代码代替函数，类似eval,慎用  var timer3 = setInterval(&quot;console.log(1)&quot;, 1000);&gt;  //取消定时器  var button = document.querySelector(&quot;button&quot;);  button.onclick = function () &#123;    clearInterval(timer3);  &#125;;&gt;  //注意  var a = 0;  var timer1 = setInterval(function () &#123;    a++;    console.log(a);    if (a === 3) &#123;      clearInterval(timer1);    &#125;    console.log(&quot;ss&quot;);    console.log(&quot;aa&quot;);  &#125;, 1000);  //1 ss aa  //2 ss aa  //3 ss aa&gt;&lt;/script&gt;</code></pre><blockquote><blockquote><p>注意：</p></blockquote><ul><li>取消定时器<strong>不意味</strong>着马上停止所有行为(即打印出3就退出去)</li><li>它会把这一轮进行完(后面的”ss”、”aa”会被打印出来)</li><li>具名函数当做第一个参数时，注意：没有圆括号</li></ul></blockquote><ul><li>案例：计时器功能<blockquote><ul><li>开始按钮，暂停按钮</li><li>注意在每次点击开始后，先清除计算器，以避免定时器叠加（当我们不停点击开始按钮时，就能看到），但这不代表清零</li></ul></blockquote></li></ul><pre><code>&gt;&lt;button id=&quot;start&quot;&gt;开始&lt;/button&gt;&gt;&lt;div class=&quot;time&quot;&gt;&lt;/div&gt;&gt;&lt;button id=&quot;pause&quot;&gt;暂停&lt;/button&gt;&gt;&lt;script&gt;  var start = document.getElementById(&quot;start&quot;);  var pause = document.getElementById(&quot;pause&quot;);  var time = document.querySelector(&quot;.time&quot;);  var timer = null; //初始化计时器  var sum = 0;  start.onclick = function () &#123;    //为了防止定时器叠加，应在开始前清除计时器    clearInterval(timer);     timer = setInterval(function () &#123;      time.innerText = ++sum + &quot;秒&quot;;    &#125;, 1000);  &#125;;  pause.onclick = function () &#123;    clearInterval(timer);  &#125;;&gt;&lt;/script&gt;</code></pre><h4 id="setTimeout-与-clearTimeout"><a href="#setTimeout-与-clearTimeout" class="headerlink" title="setTimeout() 与 clearTimeout()"></a>setTimeout() 与 clearTimeout()</h4><blockquote><ul><li><code>setTimeout()</code>方法设置一个延时器，该延时器在定时器到期后执行一个函数或指定的一段代码。</li><li><code>clearTimeout()</code>用来取消一个延时器<blockquote><p>注意：当指定时间到了之后，会执行函数<strong>一次</strong>，不再重复执行</p></blockquote></li><li>语法</li></ul></blockquote><pre><code>// 设置一个定时器var timer = setTimeout(funtion, delay, arg1, arg2, arg3);// 清除一个定时器cleartTimeout(timer);</code></pre><blockquote><ul><li><code>delay</code> ：表示定时器延迟的时间，以毫秒为位，1 秒等于 <code>1000</code> 毫秒</li><li><code>function</code> 这个参数是一个函数，当延时器延迟时间<code>delay</code>到期后，就会执行这个函数</li><li><code>arg1...arg3</code>等：附加参数，一旦定时器到期，它们会作为参数传递给 <code>function</code> ，<code>ie</code>不支持</li><li><code>timer</code>：表示延时器的返回值，返回值是一个正整数，表示定时器的编号，这个值可以传递给<code>clearTimeout()</code>来取消该延时器。</li></ul></blockquote><h4 id="定时器中-this-问题"><a href="#定时器中-this-问题" class="headerlink" title="定时器中 this 问题"></a>定时器中 this 问题</h4><blockquote><ul><li><code>setTimout</code>和<code>setInterval</code>函数中的第一个参数是一个函数，当定时器到时间执行这个函数</li><li>这个函数中的<code>this</code>默认指向<code>window</code>或<code>global</code>，不管在严格模式还是非严格模式下，<code>this</code>都指向<code>window</code></li></ul></blockquote><pre><code>var obj = &#123;   name: &quot;张三&quot;,   sayHello: function () &#123;     console.log(this); // window     console.log(&quot;大家好，我叫&quot; + this.name);   &#125;, &#125;;&gt; var timer;&gt; timer = setInterval(function () &#123;   console.log(this); //window &#125;, 1000);&gt; timer = setInterval(obj.sayHello, 1000); //this指window //相当于： timer = setInterval(function () &#123;  console.log(this); // window  console.log(&quot;大家好，我叫&quot; + this.name);&#125;, 1000); //this指window</code></pre><ol><li>修改 this 指向<blockquote><ul><li>注意：这里的方法实质上并不是真的改变了定时器的this指向，只是改变了结果</li></ul></blockquote></li></ol><blockquote><p>知识点：</p><ul><li>在之前的学习中我们知道，<code>this</code>代表的是函数的上下文对象，指向把函数当成方法调用的那个对象</li></ul></blockquote><ul><li>方法1：包装函数来实现this</li></ul><pre><code>var obj = &#123;  name: &quot;张三&quot;,  sayHello: function () &#123;    console.log(this); // obj    console.log(&quot;大家好，我叫&quot; + this.name);  &#125;,&#125;;var timer = setInterval(function () &#123;  //定时器的this仍然指向window  obj.sayHello();//在函数内obj调用sayHello方法&#125;, 2000);//输出结果：每个两秒打印出 大家好，我叫张三</code></pre><ul><li>方法2：利用 bind 来实现<blockquote><ul><li>bind方法：<code>var fn2 = fn.bind(thisArg, arg1, arg2, arg3);</code></li><li>改变<code>this</code>指向并返回一个新函数</li><li><code>setInterval(obj.sayHello, 1000);</code>this指的是window</li><li>然而<code>.bind(obj)</code>把<code>obj.sayHello</code>方法的this改成了obj</li></ul></blockquote></li></ul><pre><code>var obj = &#123;  name: &quot;张三&quot;,  sayHello: function () &#123;    console.log(this);    console.log(&quot;大家好，我叫&quot; + this.name);  &#125;,&#125;;&gt;setInterval(obj.sayHello.bind(obj), 1000);</code></pre><ul><li>方法三：在外层作用域，保存 this<blockquote><ul><li>事件函数中的this指向绑定事件的那个对象</li><li>实现效果：点击开始按钮，1秒后，开始按钮变颜色</li><li>因为不一定知道按钮元素名，所以一般会写成<code>this.style...</code>；但定时器函数的<code>this</code>指的是window，所以就会报错</li><li>因此，声明一个变量<code>that</code>接收事件处理函数的<code>this</code>，在定时器内调用</li></ul></blockquote></li></ul><pre><code>&gt;&lt;button id=&quot;start&quot;&gt;开始&lt;/button&gt;&gt;&lt;script&gt;  var start = document.getElementById(&quot;start&quot;);  start.onclick = function () &#123;    //事件处理函数的this指的是start    var that = this;    setInterval(function () &#123;      console.log(that); // that指向start      that.style.backgroundColor = &quot;red&quot;;//改变start的背景颜色    &#125;, 1000);  &#125;;&gt;&lt;/script&gt;</code></pre><h4 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h4><blockquote><p>在讲接下来的同步与异步相关内容时，会涉及到队列相关知识，所以我们先来学习下队列相关内容</p><ul><li>队是一种线性的数据结构，它的特点是先进先出（<code>First In First Out</code>,简称<code>FIFO</code>），后进后出。</li><li>队列的出口端叫作队头（<code>front</code>），队列的入口端叫作队尾(<code>rear</code>)</li><li>入队（<code>enqueue</code>）就是把新元素放入队列中，只允许在队列的<strong>队尾</strong>放入元素</li><li>出队（<code>dequeue</code>）就是把元素移出队列，只允许在队列的<strong>队头</strong>移出元素。<img src="队列.png"></li></ul></blockquote><h4 id="单线程、同步与异步"><a href="#单线程、同步与异步" class="headerlink" title="单线程、同步与异步"></a>单线程、同步与异步</h4><blockquote><p>生活的角度来举一个例子，帮助大家理解。</p><ul><li>比如你现在工作是查阅合同，并归档，并且这个工作只有你一个人在做，那就属与<strong>单线程执行</strong>。<blockquote><p>所谓单线程，站在现实角度，简单理解就是一个人干了所有活。</p></blockquote></li></ul></blockquote><blockquote><ul><li>至于 JS 为什么设置成单线程的，我们后面在性能优化那节课来专门讲解。</li></ul></blockquote><blockquote><p>比如，你现在的工作流程如下：</p><ul><li>第一：查阅合同是否有错误，我们简称 A 事情</li><li>第二：如果有错误就要提交到老板处，让老板改正 我们简称 B 事情</li><li>第三：老板改正好之后，我们要拿回合同，然后一起归档，简称 C 事情</li><li>第四：可能中间还有其它同事需要我帮助等啥的，我们简称 D 事情<blockquote><p>如果说你现在手上有 10 个文档，当你查阅到第 3 个文档时，发现文档有错误，那你现在该怎么办 ？</p></blockquote></li></ul></blockquote><ol><li>第一种情况：同步执行任务<blockquote><ul><li>把错误合同提交到老板处，让老板改正后，等老板改好，再拿回来，继续查况后面的合同。老板修改合同上的错误，肯定需要花很多时间，还要找律师啥，显然在老师改合同这个时间里，我们一直等着，后面的合同也不审，那太浪费时间了。<blockquote><p>这种情况，就是单线的同步执行任务</p></blockquote></li><li><strong>一次只能做一件事</strong>，而且每次要等前面的事做完了，再做后面的，否则就<strong>一直等着</strong>。而自己一直空闲着，但后面还有好多事又做不了。</li></ul></blockquote></li></ol><p><strong>JS 单线程同步执行任务</strong></p><blockquote><ul><li><code>JS</code> 是属于单线程的，也就是一次只能做一件事。做了 A 就不能做 B。如果前面的 A 任务会花费大量的时间，就会导致后面的 B 任务停止执行，直到 A 执行完才会执行 B。</li><li>如果排队是因为计算量大，CPU 忙不过来，倒也算了，但是很多时候 CPU 是闲着的，因为 IO 设备（输入输出设备）很慢（比如 Ajax 操作从网络读取数据，进行大量计算），不得不等着结果出来，再往下执行。<blockquote><p>显示如果单线执行任务，只能同步执行的话，那是非常麻烦的。</p></blockquote></li></ul></blockquote><ol start="2"><li>第二种情况：同步与异步结合执行任务<blockquote><ul><li>每次把错误的合同提交到老板那里，让老板去改正，自己继续审下面的合同。等老板改好合同后，来通知我去拿合同时，我才会考虑去取回合同。</li><li>老板通知我拿合同时，如果手上的事没有忙完，则等我忙完了，再去老板那里拿回合同，一起归档，如果忙完了，那就直接去老板哪里取回合同。</li><li>如果我忙完了，老板还没有通知我，那我闲着没事也没关系。<blockquote><p>这种情况，就是<strong>同步与异步混合</strong>的方式来执行任务</p></blockquote></li></ul></blockquote></li></ol><blockquote><ul><li>从上面这件事来看，第二种情况肯定工作效率会更高，那在我们 JS 执行代码时，他也采用的是<strong>第二种机制</strong>，同步与异步结合的方式执行代码。</li></ul></blockquote><blockquote><p>为了防止主线程的不阻塞，异步方案产生</p><ul><li>所有任务可以分成两种，一种是同步任务（synchronous），另一种是异步任务（asynchronous）。<blockquote><p>就好比上面的 A、B、D 是同步任务，C 是异步任务</p></blockquote></li><li>同步任务指的是： 在主线程上排队执行的任务，只有前一个任务执行完毕，才能执行后一个任务；</li><li>异步任务指的是： 不进入主线程、而进入**”任务队列”<strong>（task queue）的任务，</strong>只有”任务队列”通知主线程**，某个异步任务可以执行了，该任务才会进入主线程执行</li><li>JS 中代码分为同步代码和异步代码。大部分代码是同步的，只有少许代码是异步的</li></ul></blockquote><ol start="3"><li><p>JS 执行中遇到异步任务如何处理</p><blockquote><ul><li>JS 代码在执行代码时，也是一样的，首先会将所有同步代码执行完了，再去执行异步的代码。</li><li>如果在执行过程中碰到了异步的代码，那 JS 就会先把他暂时放到一个<strong>任务队列</strong>中等着，<strong>等同步的代码全部执行完了</strong>再执行任务队列中的异步代码。</li><li>执行顺序按<strong>先插入队列的先拿出来执行</strong>。<img src="JS代码执行流程（简化版）.png"></li></ul></blockquote></li><li><p>setInterval 和 setTimeout 是两个异步语句</p><blockquote><ul><li>我们来分析下，下面这段代码的执行结果</li></ul></blockquote></li></ol><pre><code>console.log(1);console.log(2);setTimeout(function () &#123;    console.log(&quot;定时器1000&quot;);&#125;, 1000);console.log(3);&gt;setTimeout(function () &#123;    console.log(&quot;定时器0&quot;);&#125;, 0);console.log(4);......&gt;// 最后执行结果  1，2，3，4 定时器0  定时器1000</code></pre><blockquote><ul><li>代码从上往下执行时，碰到<code>setInterval()</code>和<code>setTimeout()</code>异步任务时，浏览器会把这个任务放在<code>Event Table</code>，</li><li>等到<strong>定时器计时一到</strong>，会把对应回调函数加入到<code>Event Queue</code><strong>事件队列</strong>中，<strong>等</strong>其它的同步代码执行完了，再去执行他们。<blockquote><p>定时器的计时不是由 JS 主线程来负责的。</p></blockquote></li><li>这里就会造成定时器并不能完全按预期的延迟时间来执行代码。因为有可能定时器的等待时间是<code>100ms</code>，而<strong>同步代码</strong>执行的时间要 <code>200ms</code>，这样就会造成定时器要在 <code>200ms</code> 后才会第一次被执行。</li></ul></blockquote><blockquote><blockquote><p>总结</p></blockquote><ul><li>单线程： 一个人干了所有活，而且每次只能做一件事，JS 就是单线程的。<br><strong>同步</strong></li><li>同步就是一件一件事情来，只有等前面的事情做完了，才会做后面的事情，如果前面的事情耗时很长，也要一直等着完成才做后面。</li><li>同步会阻塞后续代码的执行<br><strong>异步</strong></li><li>异步是相同同步而言的，如果在做的过程中遇到异步的任务，就把他先放在一边，等同步的事情做完了，再去做异步的任务</li><li>异步不会阻塞后续代码的执行</li><li>异步任务一般都是非常耗时的，而且会受到外部影响。</li></ul></blockquote><ol start="5"><li>异步的应用场景<blockquote><ul><li>异步任务都是基于 <code>callback</code> 回调函数的形式来处理的，即需要异步处理的代码放在 <code>callbacak</code> 回调函数中</li><li>遇到异步任务，就会把对应的 <code>callback</code> 函数，添加到<strong>任务队列</strong>中，等同步执行完，定时器时间一到，再到任务队列中取出对应的回调函数放入事件队列中，开始执行。</li></ul></blockquote></li></ol><blockquote><p>常见的异步任务有</p><ul><li>网络请求，如：ajax，图片加载</li><li>定时任务，如：setInterval() 和 setTimeout()</li></ul></blockquote><blockquote><p>图片加载案例</p><ul><li>load 事件，表示图片加载成功后要触发的事件</li><li>error 事件，表示图片加载失败后要触发的事件</li></ul></blockquote><pre><code>console.log(&quot;同步代码1&quot;);var img = document.createElement(&quot;img&quot;); // 同步代码img.src = &quot;https://www.arryblog.com/logo.png&quot;; // 同步代码img.onload = function () &#123;  console.log(&quot;图片加载成功&quot;);  document.body.appendChild(img);&#125;; // 异步回调img.onerror = function () &#123;  console.log(&quot;图片加载失败&quot;);&#125;; // 异步回调console.log(&quot;同步代码2&quot;);//同步代码1 同步代码2 图片加载成功</code></pre><h4 id="定时器实现动画"><a href="#定时器实现动画" class="headerlink" title="定时器实现动画"></a>定时器实现动画</h4><blockquote><ul><li>动画的本质，就是在更改 CSS 样式</li><li>比如，制作一个变色的小球，就是在一定的时间内改变 div 的背景颜色</li><li>比如，实现一个长方形，从左边移动到右边，本质就是在不停的更改 div 的 left 值（前提 div 是一个定位元素）<blockquote><p>我们利用定时器，在一定的时间内，更改元素身上的 CSS 属性，就能实现简单的动画效果</p></blockquote></li></ul></blockquote><ol><li>案例 1：实现变色小球<blockquote><ul><li>开一个定时器，间隔一定的时间，就更改下元素的背景颜色</li></ul></blockquote></li></ol><pre><code>var ball = document.querySelector(&quot;.ball&quot;);var arrColor = [  &quot;lightblue&quot;,  &quot;lightcoral&quot;,  &quot;lightgray&quot;,  &quot;lightseagreen&quot;,  &quot;lightpink&quot;,  &quot;skyblue&quot;,];var len = arrColor.length;setInterval(function () &#123;  var index = (Math.random() * len) &gt;&gt; 0;  ball.style.backgroundColor = arrColor[index];&#125;, 500);</code></pre><ol start="2"><li>案例 2：匀速运动 - 向右<blockquote><p>当点击开始按扭时，希望小球从左边运动到右边的某个位置，然后停下来，在整个过程中小球运动要到达目的地，可以是</p><ul><li>匀速运动</li><li>减速运动</li><li>限定时间（规定多长时间运动到目的）</li></ul></blockquote></li></ol><ul><li>我们来先看第一种：匀速运动 - 向右运动<blockquote><ul><li>匀速运动，即小球每次移动的距离是一样的，我们把每一次移动距离称为<strong>步长</strong>（step）</li><li>我们可以开启一个定时器，让小球每次从当前位置向右移动规定的步长</li><li>当小球到达目的时，<strong>暂停</strong>动画（即关闭定时器）</li><li>因为在小球每次到达目地的时，如果一直按开始按扭，会开启很多个定时器，小球的运动速度会<strong>越来越快</strong></li><li>所以每次在开启一个新的定时器前，要<strong>关闭之前的定时器</strong></li></ul></blockquote></li></ul><pre><code>&gt;&lt;style&gt;.ball &#123;    position: absolute;    left: 0;    top: 100px;    width: 100px;    height: 100px;    background-color: skyblue;    border-radius: 50%;  &#125;&gt;&lt;/style&gt;&gt;&gt;&lt;button class=&quot;start&quot;&gt;开始&lt;/button&gt;&gt;&lt;div class=&quot;ball&quot;&gt;&lt;/div&gt;&gt;&lt;script&gt;  var start = document.querySelector(&quot;.start&quot;);  var ball = document.querySelector(&quot;.ball&quot;);  var timer = null; //记录定时器  // 点击按扭，球开始运动  start.onclick = function () &#123;    move(ball, 10, 500, 100);  &#125;;  /*  move:封装运动动画  el:运动的元素  step:小球每次运动的步长  target:目的地距离  delay:表示定时器的执行时间，默认值是20ms  */  function move(el, step, target, delay = 20) &#123;    // 每次开启新定时器前，把之前的定时器关闭    clearInterval(el.timer);    // 定时器隔一定时间，让小球向右移动一定距离    el.timer = setInterval(function () &#123;      //将定时器绑定到元素身上      // 如果移动距离超过了目标位置，则让他运动到目标位置      var location = el.offsetLeft + step;      if (location &gt;= target) &#123;        location = target;        clearInterval(el.timer);//清除下一次的定时器      &#125;      el.style.left = location + &quot;px&quot;;    &#125;, delay);  &#125;&gt;&lt;/script&gt;</code></pre><blockquote><blockquote><p>以上方法，小球只能向右运动。如果想让小球在水平向左或向右运动，我们需要修改代码</p></blockquote></blockquote><ol start="3"><li>案例 3：匀速水平——向左&#x2F;向右<blockquote><p>小球沿水平（向左或向右）运动的条件：判断小球的位置与目标点的距离</p><ul><li>如果小球位置 &lt; 目标点位置，则 step 为正数</li><li>如果小球位置 &gt; 目标点位置，则 step 为负数<br>所以小球运动到目标点<strong>停止的条件</strong>就变成了：</li><li>当前位置 &gt;&#x3D; 目标位置 &amp;&amp; step 为正数时，停止</li><li>或 当前位置 &lt;&#x3D; 目标位置 &amp;&amp; step 为负数时，停止</li></ul></blockquote></li></ol><ul><li>封装函数</li></ul><pre><code>&gt;/**&gt; * move 运动函数 指定元素以规定的步长匀速运动到目的&gt; * @param el 需要运动的元素&gt; * @param step 每次运动的步长（移动的距离）&gt; * @param target 运动到的目的点&gt; * @param delay 定时器每次间隔时长，如果没有传就启用默认值20&gt; */function move(el, step, target, delay = 20) &#123;  // 判断目标位置与当前元素位置  if (el.offsetLeft &gt; target) step = -step;  clearInterval(el.timer);  // 定时器隔一定时间，让小球向右移动一定距离  el.timer = setInterval(function () &#123;    // 如果移动距离超过了目标位置，则让他运动到目标位置    var currentLocation = el.offsetLeft + step;    // 小球停止运动的条件    if (      (currentLocation &gt;= target &amp;&amp; step &gt; 0) ||      (currentLocation &lt;= target &amp;&amp; step &lt; 0)    ) &#123;      currentLocation = target;      clearInterval(el.timer);//清除下一次的定时器    &#125;    el.style.left = currentLocation + &quot;px&quot;;  &#125;, delay);&#125;</code></pre><ol start="4"><li>案例 4：匀速水平——往返运动<blockquote><ul><li>使用回调函数</li></ul></blockquote></li></ol><pre><code>&gt;&lt;button class=&quot;btn&quot;&gt;先向左后向右&lt;/button&gt;&gt;   &lt;div class=&quot;ball&quot;&gt;&lt;/div&gt;&gt;   &lt;script&gt; var btn = document.querySelector(&quot;.btn&quot;); var ball = document.querySelector(&quot;.ball&quot;); var timer = null; //记录定时器 // 点击按扭，球开始运动 btn.onclick = function () &#123;  //用实参传入回调函数   move(ball, 10, 500, 50, function () &#123;     move(ball, 10, 0, 50);   &#125;); &#125;;//先左后右 btn.onclick = function () &#123;   move(ball, 10, 500, 50, function () &#123;     move(ball, 10, 0, 50, function () &#123;       move(ball, 10, 500, 50);     &#125;);   &#125;); &#125;;//先左后右再左&gt; function move(el, step, target, delay = 20, callback) &#123;   // 判断目标位置与当前元素位置   if (el.offsetLeft &gt; target) step = -step;   clearInterval(el.timer);   // 定时器隔一定时间，让小球向右移动一定距离   el.timer = setInterval(function () &#123;     // 如果移动距离超过了目标位置，则让他运动到目标位置     var currentLocation = el.offsetLeft + step;     // 小球停止运动的条件     if (       (currentLocation &gt;= target &amp;&amp; step &gt; 0) ||       (currentLocation &lt;= target &amp;&amp; step &lt; 0)     ) &#123;       currentLocation = target;       clearInterval(el.timer);//清除下一次的定时器       //这里清理定时器，表示到头了       //判断传入类型，如果是函数，则调用，不是则什么也不做       typeof callback === &quot;function&quot; ? callback() : callback;       //callback instanceof Function()?callback():callback;//所有的函数都是Function的实例     &#125;     el.style.left = currentLocation + &quot;px&quot;;   &#125;, delay); &#125;&gt;&lt;/script&gt;</code></pre><ol start="5"><li>案例 5：减速运动 - 向右<blockquote><ul><li>所谓减速运动，我们可以理解为，让一个元素从左边运动到右边，其运动的速度越来越小，到最后停止运动。</li><li>比如小球从左边运动到右边，其步长变化类似于： step &#x3D; 10，step &#x3D; 9、step &#x3D; 7 … step &#x3D; 1 最后到达终点，然后停止运动。<blockquote><p>这里的难点在于，整个过程中速度的变化如何消减，从而还要实现在速度消减到最小的时候小球运动到了目地的。这里有一个简单计算每一次小球运动步长的<strong>公式</strong></p></blockquote></li></ul></blockquote></li></ol><pre><code>// n 是一个大于1的数，如果等于1，直接到达目地的，所以n尽可能设置大些step = (目地的 - 当前位置) / n;</code></pre><blockquote><ul><li>注意：向右减速运动时，步长是递减的，一定要<strong>向上取整</strong><code>Math.ceil</code>才能刚好停在目的地；</li><li>因为最后的几个步长一定是小数，只有向上取整，使它等于1，每次的步长为1，才会逐步到达目的地</li></ul></blockquote><ul><li>小球从最左边做减速运动运动到 500px 的位置</li></ul><pre><code>&gt;&lt;button id=&quot;start&quot;&gt;开始&lt;/button&gt;&gt;&lt;div class=&quot;ball&quot;&gt;&lt;/div&gt;&gt;&lt;script&gt;  var start = document.getElementById(&quot;start&quot;);  var ball = document.querySelector(&quot;.ball&quot;);  var timer = null; //初始化定时器&gt;  start.onclick = function () &#123;    move(ball, 500, 50);  &#125;;  //向右减速运动  function move(el, target, delay = 20) &#123;    // 每次开启一个新定时器前，先清除原来的    clearInterval(el.timer);    el.timer = setInterval(function () &#123;      // 计算每次运动的步长  小数向上取正      var step = Math.ceil((target - el.offsetLeft) / 10);      // 到达目标位置，停下（即清除定时器）      if (el.offset === target) &#123;        clearInterval(el.timer);      &#125;      // 让小球运动起来      el.style.left = el.offsetLeft + step + &quot;px&quot;;    &#125;, delay);  &#125;&gt;&lt;/script&gt;</code></pre><ol start="6"><li>案例 6：减速运动 - 水平(向左&#x2F;向右&#x2F;往返)<blockquote><p>要让小球沿水平（向左或向右）运动，那就要判断小球的位置与目标点的距离</p><ul><li>如果小球位置 &lt; 目标点位置，则 step 为正数，向上取整，才能准确到达目的地</li><li>如果小球位置 &gt; 目标点位置，则 step 为负数，向下取整，才能准确到达目的地</li></ul></blockquote></li></ol><blockquote><ul><li>向左&#x2F;向右时，就把函数绑在相应的<code>onclick</code>上,改变left的初始值</li><li>往返时，就使用回调函数</li></ul></blockquote><pre><code>&gt;&lt;style&gt; .ball &#123;   position: absolute;   /* left: 0; */   left: 500px;   top: 50px;   width: 100px;   height: 100px;   background-color: skyblue;   border-radius: 50%; &#125;&gt;&lt;/style&gt;&gt;&gt;&lt;button id=&quot;left&quot;&gt;向左&lt;/button&gt;&gt;&lt;button id=&quot;right&quot;&gt;向右&lt;/button&gt;&gt;&lt;button id=&quot;side&quot;&gt;往返&lt;/button&gt;&gt;&lt;div class=&quot;ball&quot;&gt;&lt;/div&gt;&gt;&lt;script&gt;  var left = document.getElementById(&quot;left&quot;);  var right = document.getElementById(&quot;right&quot;);  var side = document.getElementById(&quot;side&quot;);  var ball = document.querySelector(&quot;.ball&quot;);  var timer = null; //初始化定时器&gt;  //向左减速运动  left.onclick = function () &#123;    move(ball, 500, 50);  &#125;;  //向右减速运动  right.onclick = function () &#123;    move(ball, 0, 50);  &#125;;  //往返运动  side.onclick = function () &#123;    move2(ball, 500, 50, function () &#123;      move2(ball, 0, 50, function () &#123;        move2(ball, 500, 50);      &#125;);    &#125;);  &#125;;&gt;//向左或向右运动  function move(el, target, delay = 20) &#123;    // 每次开启一个新定时器前，先清除原来的    clearInterval(el.timer);    el.timer = setInterval(function () &#123;      // 计算每次运动的步长  小数向上取正      var step = (target - el.offsetLeft) / 10;      // 如果step大于0，则向上取正  如果step小于0，则向下取正      step = step &gt; 0 ? Math.ceil(step) : Math.floor(step);      // 到达目标位置，停下（即清除定时器）      if (el.offsetLeft === target) &#123;        clearInterval(el.timer);      &#125;      // 让小球运动起来      el.style.left = el.offsetLeft + step + &quot;px&quot;;    &#125;, delay);  &#125;&gt;//往返运动  function move2(el, target, delay = 20, callback) &#123;    // 每次开启一个新定时器前，先清除原来的    clearInterval(el.timer);    el.timer = setInterval(function () &#123;      // 计算每次运动的步长  小数向上取正      var step = (target - el.offsetLeft) / 10;      // 如果step大于0，则向上取正  如果step小于0，则向下取正      step = step &gt; 0 ? Math.ceil(step) : Math.floor(step);      // 到达目标位置，停下（即清除定时器）      if (el.offsetLeft === target) &#123;        clearInterval(el.timer);      &#125;      // 让小球运动起来      el.style.left = el.offsetLeft + step + &quot;px&quot;;      //等赋完上一轮的值之后再来调回调函数      if (el.offsetLeft === target) &#123;            callback instanceof Function ? callback() : callback;          &#125; &#125;, delay);  &#125;&gt;&lt;/script&gt;</code></pre><ol start="7"><li>案例 7：多属性减速运动<blockquote><p>我们希望小球按我们指定的属性来发生变化，如果同时指定多个属性呢 ？</p></blockquote></li></ol><ul><li>难点一：多个属性如何指定，传值问题。<blockquote><ul><li>我们把 <code>target</code> 目标参数改成一个<strong>对象</strong>，用对象的形式来指定变化的属性值，如下：</li></ul></blockquote></li></ul><pre><code>target = &#123; left: 200, top: 300, width: 300, height: 400 &#125;;</code></pre><ul><li>难点二：如何控制每个属性的变化<blockquote><ul><li>可以利用<code>for..in</code>循环遍历出<code>target</code>中的每个<strong>属性名</strong>和对应的<strong>属性值</strong>(目标值)</li><li>然后利用<code>getComputedStyle()</code>方法，获取元素<strong>当前对应属性值</strong>，与目标值对比，来控制属性变化</li></ul></blockquote></li></ul><pre><code>// for ...in 遍历target，获取对应属性名和属性值for(var key in target)&#123; ....&#125;&gt;// 获取元素对应属性值var attrValue = getStyle(el, key);function getStyle(el, attr) &#123;    return getComputedStyle(el, null)[attr] || 0;//0是默认值&#125;//相当于 var attrValue = getComputedStyle(el)[key];</code></pre><ul><li>难点三：何时暂停定时器<blockquote><ul><li>多个属性发生变化，只有当<strong>所有属性</strong>变化值都达到目标时，才会能暂停定时器。</li><li>判断方法：我们设置一个<code>flag</code>属性用来记录是否所有属性都达到了目标值，只要有一个没有达到<code>flag = false</code>,只有所有值都达到目标值时，<code>flag = true</code></li></ul></blockquote></li></ul><pre><code>if (flag) &#123;  clearInterval(el.timer);&#125;</code></pre><ul><li>把 opacity 透明度属性融入进去<blockquote><ul><li>我们把<code>透明度的属性值 * 100</code>再处理，然后保存结果时，再<code>除以 100</code></li><li>如果用户传过来的对应属性<code>left，top，width，height，opacity</code>值，带有小数，我们在比较时<strong>用整数来比较</strong>。<blockquote><p>注：传入的 opacity 只能是 1 到 100 之间的整数</p></blockquote></li></ul></blockquote></li></ul><pre><code>&gt;/**&gt; * move 多属性运动动画&gt; * el 运动的元素&gt; * target 多个属性的目标值 target=&#123;width:&#39;300px&#39;,height:&#39;400px&#39;&#125;&gt; * callback 回调函数  动画结束后执行&gt; * delay 定时器的执行间隔时间&gt; */function move(el, target = &#123;&#125;, callback, delay = 20) &#123;  // 开定时器之前，要清定时器  clearInterval(el.timer);  el.timer = setInterval(function () &#123;    var flag = true; //假设所有的属性都到达目标值    // 多属性动画    // 通过for...in遍历 target对象，取得每个key和(value)    // 通过key得到当前改变的属性，及属性的当前值    // 通过value得到当前改变的属性的目标值    for (var key in target) &#123;     // 要对传过来的key做一个判断，判断是不是一个opacity     var attrValue = getComputedStyle(el)[key]; // 当前值   1     if (key.toLowerCase() === &quot;opacity&quot;) &#123;       // 将值 1 或 0.4等 转换成 100或 40       attrValue = attrValue * 100;     &#125; else &#123;       attrValue = parseInt(attrValue); // 当前值   1     &#125;&gt;     var targetValue = parseInt(target[key]); // 目标值   30&gt;     // 计算运动的步长step(速度 speed)     var step = (targetValue - attrValue) / 10;     step = step &gt; 0 ? Math.ceil(step) : Math.floor(step);&gt;     // 只要有一个属性没有到达目标值，那就把flag设置为false     var currentDistance = attrValue + step;     if (currentDistance !== targetValue) &#123;       flag = false;     &#125;     // 赋值     if (key.toLowerCase() === &quot;opacity&quot;) &#123;       el.style[key] = currentDistance / 100;     &#125; else &#123;       el.style[key] = currentDistance + &quot;px&quot;;     &#125;   &#125;&gt;   // 清定时器,只有flage=true时   if (flag) &#123;     clearInterval(el.timer);     // 执行回调     callback instanceof Function ? callback() : callback;   &#125; &#125;, delay);&#125;</code></pre><ol start="8"><li>案例 8：单个属性限定时间动画<blockquote><ul><li>限定步长的动画，是没有办法精准的把控好时间的，其运动的距离也长，耗时越长</li><li>如果我们要限定时间，在规定的时间内完成动画，那需要如何实现呢 ？<img src="限定时间动画.png"></li></ul></blockquote></li></ol><blockquote><ul><li>计算<strong>当前位置</strong>以控制<code>left</code>的距离</li><li><code>duration</code>&#x3D;走完全程所需要的时间（s）</li><li><code>begin</code>&#x3D;开始位置&#x3D;<code>el.offsetLeft</code></li><li><code>change</code>&#x3D;总距离&#x3D;target(目标位置)-begin(开始位置)</li><li>速度&#x3D;总距离&#x2F;总时间&#x3D;<code>change/duration</code></li><li><code>time</code>(已经走了多久)：定时器次数*延迟时间</li><li><code>currentDistance</code>(当前位置)&#x3D;left&#x3D;<code>起始位置+所用时间*速度</code>&#x3D;begin+T*C&#x2F;D</li><li>改善：将毫秒调整为秒<code>duration = parseFloat(duration) * 1000</code>,<code>parseFloat</code>过滤字符串</li><li>加入回调函数</li></ul></blockquote><ul><li>限定时间动画函数</li></ul><pre><code>&gt;&lt;div class=&quot;ball&quot;&gt;&lt;/div&gt;&gt;&lt;script&gt;  var ball = document.querySelector(&quot;.ball&quot;);&gt;      function move(el, target, duration, callback) &#123;    var begin = el.offsetLeft;    var change = target - begin;    //将毫秒调整为秒    duration = parseFloat(duration) * 1000;    var time = 0;    //开启定时器时，首先清理上一个定时器    clearInterval(el.timer);    el.timer = setInterval(function () &#123;      time += 20;      var currentDistance = begin + (time * change) / duration;      //超过规定时间，就把位置拉到目标距离，清理定时器      if (time &gt;= duration) &#123;        currentDistance = target;        clearInterval(el.timer);      &#125;      el.style.left = currentDistance + &quot;px&quot;;      //到头之后使用回调函数      if (time &gt;= duration) &#123;        callback instanceof Function ? callback() : callback;      &#125;    &#125;, 20);  &#125;  document.documentElement.onclick = function () &#123;    move(ball, 500, &quot;1s&quot;, function () &#123;      move(ball, 10, &quot;0.5s&quot;);    &#125;);  &#125;;&gt;&lt;/script&gt;</code></pre><ol><li>案例9：多个属性，同一限定时间动画<blockquote><ul><li>在上一个案例的基础上，再融合多个属性</li></ul></blockquote></li></ol><pre><code>&gt;&lt;div class=&quot;ball&quot;&gt;&lt;/div&gt;&gt;&lt;script&gt;  var ball = document.querySelector(&quot;.ball&quot;);&gt;  document.documentElement.onclick = function () &#123;    move(ball, (target = &#123; top: &quot;50px&quot;, left: &quot;500px&quot; &#125;), &quot;1s&quot;);  &#125;;&gt;  //回调函数  document.documentElement.onclick = function () &#123;    move(      ball,      (target = &#123; top: &quot;50px&quot;, left: &quot;500px&quot; &#125;),      &quot;1s&quot;,      function () &#123;        move(ball, (target = &#123; top: &quot;10px&quot;, left: &quot;10px&quot; &#125;), &quot;1s&quot;);      &#125;    );  &#125;;&gt;  //限定时间动画  function move(el, target = &#123;&#125;, duration, callback) &#123;    var time = 0;    //将毫秒调整为秒    duration = parseFloat(duration) * 1000;    //开启定时器时，首先清理上一个定时器    clearInterval(el.timer);&gt;    el.timer = setInterval(function () &#123;      time += 20;      for (var key in target) &#123;        var begin = parseFloat(getComputedStyle(el)[key]);        var targerValue = parseFloat(target[key]);        var change = targerValue - begin;        var currentDistance = begin + (time * change) / duration;       //超过规定时间，就把位置拉到目标距离，清理定时器        if (time &gt;= duration) &#123;          currentDistance = targerValue;          clearInterval(el.timer);        &#125;        el.style[key] = currentDistance + &quot;px&quot;;       //到头之后使用回调函数        if (time &gt;= duration) &#123;          callback instanceof Function ? callback() : callback;        &#125;      &#125;&gt;   &#125;, 20); &#125;&gt;&lt;/script&gt;</code></pre><ol><li>案例10：多个属性，不同限定时间动画</li></ol><p><strong>几大核心问题：</strong></p><ul><li>多属性运动，target 保存数据的结构定义成如下，用户按这个格式来传数据</li></ul><pre><code>var target = [  &#123;    width: &quot;200px&quot;,    duration: &quot;2s&quot;,  &#125;,  &#123;    left: &quot;600px&quot;,    duration: &quot;5s&quot;,  &#125;,  &#123;    top: &quot;200px&quot;,    duration: &quot;1s&quot;,  &#125;,];</code></pre><ul><li>对上面结构的数据做转换，转成适合编程的如下结构数据</li></ul><pre><code>&gt;/**&gt; * attr 运动的属性&gt; * target 运动的目标值&gt; * D ：duration 动画（某个属性）运动的总时间&gt; * B ：Begin 动画（当前属性）的开始位置&gt; * C : Change 需要改变的总距离  target -B&gt; */var target = [  &#123; attr: &quot;width&quot;, D: 2000, target: 200, B: 100, C: 100 &#125;,  &#123; attr: &quot;left&quot;, D: 5000, target: 600, B: 10, C: 590 &#125;,  &#123; attr: &quot;top&quot;, D: 1000, target: 200, B: 10, C: 190 &#125;,];</code></pre><blockquote><p><strong>难点</strong></p><ul><li>怎样先得到每个对象的第一个键值对，再得到每个对象的第二个键值对</li><li><code>for in</code>不能保证按书写顺序遍历数组&#x2F;对象，怎么处理</li></ul></blockquote><blockquote><ul><li>方式一：未考虑<code>for in</code> 的遍历顺序</li><li><code>n=0</code>使得到的是每个对象的第一个键值</li><li><code>n=1</code>使得到的是每个对象的第二个键值</li></ul></blockquote><pre><code>function convertDataStruct(el, target) &#123;  var result = [];  for (var i = 0; i &lt; target.length; i++) &#123;    var n = 0; //记录进入对象的次数    var obj = &#123;&#125;;    for (var key in target[i]) &#123;      if (n === 0) &#123;        obj.attr = key;        obj.target = parseInt(target[i][key]);        obj.B = parseInt(getComputedStyle(el)[key]);        obj.C = obj.target - obj.B;      &#125; else &#123;        //把秒转成毫秒        obj.D = parseFloat(target[i][key]) * 1000;      &#125;      n++;    &#125;    result.push(obj);  &#125;  return result;&#125;</code></pre><blockquote><ul><li>优化版</li><li>用<code>indexOf</code>在attrArr数组中查找元素</li><li>找到了的就是每个对象的第一个键值</li><li>没找到的就是每个对象的第二个键值</li></ul></blockquote><pre><code>var attrArr = [&quot;width&quot;, &quot;left&quot;, &quot;top&quot;, &quot;height&quot;];function convertDataStruct(el, target) &#123;  var result = [];  for (var i = 0; i &lt; target.length; i++) &#123;    var obj = &#123;&#125;;    for (var key in target[i]) &#123;      var index = attrArr.indexOf(key);      if (index !== -1) &#123;        obj.attr = key;        obj.target = parseInt(target[i][key]);        obj.B = parseInt(getComputedStyle(el)[key]);        obj.C = obj.target - obj.B;      &#125; else &#123;        obj.D = Math.abs(parseFloat(target[i][key]) * 1000);      &#125;    &#125;    result.push(obj);  &#125;  return result;&#125;</code></pre><ul><li>何时清除定时器<blockquote><ul><li>累计时间 &gt; 多个属性中<strong>最大运动时间</strong>时，清定时器</li></ul></blockquote></li><li>那如何获取多个属性中，运动时间最长的那个时间？<blockquote><ul><li>如果没有输入运动时间？设默认值</li><li>如果输入的运动时间为负？用<code>Math.abs()</code></li><li>可以用for循环，也可以用<code>forEach</code></li></ul></blockquote></li></ul><pre><code>function getTime(target) &#123;  var MaxTime = parseFloat(target[0].duration) * 1000;  //如果没有设置duration，则时间为0，有就等于它的绝对值  MaxTime = MaxTime ? Math.abs(MaxTime) : 0;&gt;   //方法1：for 循环  // for (var i = 0; i &lt; target.length; i++) &#123;  //   var time = parseFloat(target[i].duration) * 1000;  //   //如果某项没设置duration，就为0  //   time = time ? Math.abs(time) : 0;  //   if (MaxTime &lt; time) MaxTime = time;  // &#125;&gt;  //方法2：forEach  target.forEach(function (value) &#123;    var time = parseFloat(value.duration) * 1000;    //如果某项没设置duration，就为0    time = time ? Math.abs(time) : 0;    if (MaxTime &lt; time) MaxTime = time;  &#125;);  return MaxTime;&#125;</code></pre><ul><li><p>当累计时间大于属性运动时间</p><blockquote><ul><li>如果累计时间 &gt; 属性运动时间，则属性值 &#x3D; 目标值，将当前运动距离强制设为目标值，但<strong>不清</strong>定时器</li></ul></blockquote></li><li><p>什么时候执行回调函数</p><blockquote><ul><li>清定时器，表示动画结束，可以执行回调</li></ul></blockquote></li><li><p>加入<code>opacity</code>属性</p><blockquote><ul><li>数据转换时，把透明度的属性值 * 100</li><li>定时器中改变属性值的公式，不用再加”px”,直接<code>除100</code></li></ul></blockquote></li><li><p>完整代码：</p></li></ul><pre><code>&gt;&lt;div class=&quot;ball&quot;&gt;&lt;/div&gt;&gt;&lt;script&gt;  var ball = document.querySelector(&quot;.ball&quot;);  var target = [    &#123;      width: &quot;150px&quot;,      duration: &quot;2s&quot;,    &#125;,    &#123;      height: &quot;150px&quot;,      duration: &quot;2s&quot;,    &#125;,    &#123;      left: &quot;400px&quot;,      duration: &quot;3s&quot;,    &#125;,    &#123;      top: &quot;100px&quot;,      duration: &quot;1s&quot;,    &#125;,    &#123;      opacity: &quot;0.3&quot;,      duration: &quot;1s&quot;,    &#125;,  ];  document.documentElement.onclick = function () &#123;    move(ball, target);  &#125;;  function move(el, target, callback) &#123;    clearInterval(el.timer); //清理定时器    var time = 0;    //获得属性中运动时间最长的时间，默认值200    var MaxTime = getTime(target) || 200;&gt;  //转换数据  var target = convertDataStruct(ball, target);  //启动定时器  el.timer = setInterval(function () &#123;    time += 20;    //遍历目标数组    for (var i = 0; i &lt; target.length; i++) &#123;      var duration = target[i].D || 200;      var targetDistance = target[i].target;      var begin = target[i].B;      var change = target[i].C;&gt;      var currentDistance = begin + (time * change) / duration;      //超过目标距离时      if (time &gt;= duration) &#123;        currentDistance = targetDistance;      &#125;      if (target[i].attr === &quot;opacity&quot;) &#123;        el.style[target[i].attr] = currentDistance / 100;      &#125; else &#123;        el.style[target[i].attr] = currentDistance + &quot;px&quot;;      &#125;    &#125;    //如果最长时间结束，清理定时器，执行回调函数    if (time &gt; MaxTime) &#123;      clearInterval(el.timer);      callback instanceof Function ? callback() : callback;    &#125;  &#125;, 20);&#125;&gt;  //得到最长完成时间  function getTime(target) &#123;    var MaxTime = parseFloat(target[0].duration) * 1000;    //如果没有设置duration，则时间为0，有就等于它的绝对值    MaxTime = MaxTime ? Math.abs(MaxTime) : 0;    //for 循环    // for (var i = 0; i &lt; target.length; i++) &#123;    //   var time = parseFloat(target[i].duration) * 1000;    //   //如果某项没设置duration，就为0    //   time = time ? Math.abs(time) : 0;    //   if (MaxTime &lt; time) MaxTime = time;    // &#125;&gt;    //forEach    target.forEach(function (value) &#123;      var time = parseFloat(value.duration) * 1000;      //如果某项没设置duration，就为0      time = time ? Math.abs(time) : 0;      if (MaxTime &lt; time) MaxTime = time;    &#125;);    return MaxTime;  &#125;  //getTime(target)&gt;  //数据结构转换函数：  //   var target = [  //     &#123; attr: &quot;width&quot;, D: 2000, target: 200, B: 100, C: 100 &#125;,  //     &#123; attr: &quot;left&quot;, D: 5000, target: 600, B: 10, C: 590 &#125;,  //     &#123; attr: &quot;top&quot;, D: 1000, target: 200, B: 10, C: 190 &#125;,  //   ];&gt;  //基础版  function convertDataStruct(el, target) &#123;    var result = [];    for (var i = 0; i &lt; target.length; i++) &#123;      var n = 0; //记录进入对象的次数      var obj = &#123;&#125;;      for (var key in target[i]) &#123;        if (n === 0) &#123;          if (key === &quot;opacity&quot;) &#123;            obj.attr = key;            obj.target = target[i][key] * 100;            obj.B = getComputedStyle(el)[key] * 100;            obj.C = obj.target - obj.B;          &#125; else &#123;            obj.attr = key;            obj.target = parseInt(target[i][key]);            obj.B = parseInt(getComputedStyle(el)[key]);            obj.C = obj.target - obj.B;          &#125;        &#125; else &#123;          //把秒转成毫秒          obj.D = parseFloat(target[i][key]) * 1000;        &#125;        n++;      &#125;      result.push(obj);    &#125;    return result;  &#125;&gt;  //优化版  var attrArr = [&quot;width&quot;, &quot;left&quot;, &quot;top&quot;, &quot;height&quot;];  function convertDataStruct(el, target) &#123;    var result = [];    for (var i = 0; i &lt; target.length; i++) &#123;      var obj = &#123;&#125;;      for (var key in target[i]) &#123;        var index = attrArr.indexOf(key);        if (index !== -1) &#123;          if (key === &quot;opacity&quot;) &#123;            obj.attr = key;            obj.target = target[i][key] * 100;            obj.B = getComputedStyle(el)[key] * 100;            obj.C = obj.target - obj.B;          &#125; else &#123;            obj.attr = key;            obj.target = parseInt(target[i][key]);            obj.B = parseInt(getComputedStyle(el)[key]);            obj.C = obj.target - obj.B;          &#125;        &#125; else &#123;          obj.D = Math.abs(parseFloat(target[i][key]) * 1000);        &#125;      &#125;      result.push(obj);    &#125;    return result;  &#125;&gt;&lt;/script&gt;</code></pre><ul><li>封装成一个函数，放在js文件里<blockquote><ul><li>怎样暴露在全局里：<code>window.move=move</code></li><li>为了使变量不污染全局，做成一个立即执行函数，形成闭包<code>(function()&#123;&#125;)()</code></li></ul></blockquote></li></ul><ol start="11"><li>常见的动画运动公式：<blockquote><ul><li>把以下代码放入一个JS文件中调用</li></ul></blockquote></li></ol><ul><li>使用方法<blockquote><ul><li>拿上个案例来说，将公式<code>currentDistance = begin + (time * change) / duration;</code>换成<code>currentDistance = Tween.Cubic.easeIn(time, begin, change, duration);</code></li><li>打点调用方法，以<code>Tween</code>开头</li><li>只需要提供<code>time, begin, change, duration</code>这四个变量</li></ul></blockquote></li></ul><pre><code>// 运动方式var Tween = &#123;  // 匀速运动公式  Linear: function (t, b, c, d) &#123;    return (t / d) * c + b;  &#125;,  // 指数衰减的反弹缓动  Bounce: &#123;    easeIn: function (t, b, c, d) &#123;      return c - Tween.Bounce.easeOut(d - t, 0, c, d) + b;    &#125;,    easeOut: function (t, b, c, d) &#123;      if ((t /= d) &lt; 1 / 2.75) &#123;        return c * (7.5625 * t * t) + b;      &#125; else if (t &lt; 2 / 2.75) &#123;        return c * (7.5625 * (t -= 1.5 / 2.75) * t + 0.75) + b;      &#125; else if (t &lt; 2.5 / 2.75) &#123;        return c * (7.5625 * (t -= 2.25 / 2.75) * t + 0.9375) + b;      &#125; else &#123;        return c * (7.5625 * (t -= 2.625 / 2.75) * t + 0.984375) + b;      &#125;    &#125;,    easeInOut: function (t, b, c, d) &#123;      if (t &lt; d / 2) &#123;        return Tween.Bounce.easeIn(t * 2, 0, c, d) * 0.5 + b;      &#125;      return Tween.Bounce.easeOut(t * 2 - d, 0, c, d) * 0.5 + c * 0.5 + b;    &#125;,  &#125;,  // 二次方的缓动  Quad: &#123;    easeIn: function (t, b, c, d) &#123;      return c * (t /= d) * t + b;    &#125;,    easeOut: function (t, b, c, d) &#123;      return -c * (t /= d) * (t - 2) + b;    &#125;,    easeInOut: function (t, b, c, d) &#123;      if ((t /= d / 2) &lt; 1) &#123;        return (c / 2) * t * t + b;      &#125;      return (-c / 2) * (--t * (t - 2) - 1) + b;    &#125;,  &#125;,  // 三次方的缓动  Cubic: &#123;    easeIn: function (t, b, c, d) &#123;      return c * (t /= d) * t * t + b;    &#125;,    easeOut: function (t, b, c, d) &#123;      return c * ((t = t / d - 1) * t * t + 1) + b;    &#125;,    easeInOut: function (t, b, c, d) &#123;      if ((t /= d / 2) &lt; 1) &#123;        return (c / 2) * t * t * t + b;      &#125;      return (c / 2) * ((t -= 2) * t * t + 2) + b;    &#125;,  &#125;,  // 四次方的缓动  Quart: &#123;    easeIn: function (t, b, c, d) &#123;      return c * (t /= d) * t * t * t + b;    &#125;,    easeOut: function (t, b, c, d) &#123;      return -c * ((t = t / d - 1) * t * t * t - 1) + b;    &#125;,    easeInOut: function (t, b, c, d) &#123;      if ((t /= d / 2) &lt; 1) &#123;        return (c / 2) * t * t * t * t + b;      &#125;      return (-c / 2) * ((t -= 2) * t * t * t - 2) + b;    &#125;,  &#125;,  // 五次方的缓动  Quint: &#123;    easeIn: function (t, b, c, d) &#123;      return c * (t /= d) * t * t * t * t + b;    &#125;,    easeOut: function (t, b, c, d) &#123;      return c * ((t = t / d - 1) * t * t * t * t + 1) + b;    &#125;,    easeInOut: function (t, b, c, d) &#123;      if ((t /= d / 2) &lt; 1) &#123;        return (c / 2) * t * t * t * t * t + b;      &#125;      return (c / 2) * ((t -= 2) * t * t * t * t + 2) + b;    &#125;,  &#125;,  // 正弦曲线的缓动  Sine: &#123;    easeIn: function (t, b, c, d) &#123;      return -c * Math.cos((t / d) * (Math.PI / 2)) + c + b;    &#125;,    easeOut: function (t, b, c, d) &#123;      return c * Math.sin((t / d) * (Math.PI / 2)) + b;    &#125;,    easeInOut: function (t, b, c, d) &#123;      return (-c / 2) * (Math.cos((Math.PI * t) / d) - 1) + b;    &#125;,  &#125;,  // 指数曲线的缓动  Expo: &#123;    easeIn: function (t, b, c, d) &#123;      return t == 0 ? b : c * Math.pow(2, 10 * (t / d - 1)) + b;    &#125;,    easeOut: function (t, b, c, d) &#123;      return t == d ? b + c : c * (-Math.pow(2, (-10 * t) / d) + 1) + b;    &#125;,    easeInOut: function (t, b, c, d) &#123;      if (t == 0) return b;      if (t == d) return b + c;      if ((t /= d / 2) &lt; 1) return (c / 2) * Math.pow(2, 10 * (t - 1)) + b;      return (c / 2) * (-Math.pow(2, -10 * --t) + 2) + b;    &#125;,  &#125;,  // 圆形曲线的缓动  Circ: &#123;    easeIn: function (t, b, c, d) &#123;      return -c * (Math.sqrt(1 - (t /= d) * t) - 1) + b;    &#125;,    easeOut: function (t, b, c, d) &#123;      return c * Math.sqrt(1 - (t = t / d - 1) * t) + b;    &#125;,    easeInOut: function (t, b, c, d) &#123;      if ((t /= d / 2) &lt; 1) &#123;        return (-c / 2) * (Math.sqrt(1 - t * t) - 1) + b;      &#125;      return (c / 2) * (Math.sqrt(1 - (t -= 2) * t) + 1) + b;    &#125;,  &#125;,&#125;;</code></pre><h4 id="带左右按扭的自动切换轮播效果"><a href="#带左右按扭的自动切换轮播效果" class="headerlink" title="带左右按扭的自动切换轮播效果"></a>带左右按扭的自动切换轮播效果</h4><ul><li>思路</li></ul><ol><li>首先布局</li><li>实现自动轮播<blockquote><ul><li>自动移动：定时器</li><li>匀速移动：引用上面的<code>move</code>动画</li><li>播完最后一个无缝衔接到第一个<ul><li>把第一个克隆到最后</li><li>给<code>move</code>函数设置一个回调函数</li></ul></li></ul></blockquote></li></ol><pre><code>  //克隆第一个li到最后  var liLast = liList[0].cloneNode(true);  wrap.appendChild(liLast);&gt;  move(wrap, [&#123; left: targetDistance + &quot;px&quot; &#125;], function () &#123;    if (currentIndex &gt;= len) &#123;      wrap.style.left = &quot;0px&quot;;      currentIndex = 0;    &#125;  &#125;);</code></pre><blockquote><ul><li>当播到最后一个时，分页器显示第一个按钮<ul><li>在定时器内分情况</li></ul></li></ul></blockquote><pre><code>if (currentIndex &gt;= len) &#123;  //分页器变化  currentSpan.classList.remove(&quot;active&quot;);  spans[0].classList.add(&quot;active&quot;);  currentSpan = spans[0];&#125; else &#123;  //分页器变化  currentSpan.classList.remove(&quot;active&quot;);  spans[currentIndex].classList.add(&quot;active&quot;);  currentSpan = spans[currentIndex];&#125;</code></pre><ol start="3"><li>分页器的处理<blockquote><ul><li>鼠标移到分页器上，停止自动播放，鼠标移开，继续自动播放<ul><li>用for循环，给每个span添加<code>onmouseover</code>和<code>onmouseout</code>事件</li><li>给每个span添加下标</li></ul></li><li>鼠标点击到哪个span，该span变色，并播放对应的图片<ul><li>给<code>button</code>添加事件，用事件委托的方式</li><li>点击哪个span，就给它加上<code>active</code>样式</li><li>根据<code>span</code>的下标，得到相应图片的下标，移动<code>left</code></li></ul></li></ul></blockquote></li></ol><pre><code>for (var i = 0; i &lt; len; i++) &#123;  spans[i].index = i; //给span加下标  // 给span添加事件，鼠标放在分页器上就停止自动播放  spans[i].onmouseover = function () &#123;    clearInterval(timer);  &#125;;  //给span添加事件，鼠标移开就继续播放  spans[i].onmouseout = function () &#123;    autoplay();  &#125;;&#125;&gt;//点击哪个span就播放相应的图片button.onclick = function (e) &#123;  var target = e.target;  var targetTag = target.tagName.toLowerCase();  if (targetTag !== &quot;span&quot;) return;  //如果点的是span,对应的span变色·  currentIndex = target.index;  currentSpan.classList.remove(&quot;active&quot;);  spans[currentIndex].classList.add(&quot;active&quot;);  currentSpan = spans[currentIndex];  //改变left,跳转到对应的图片  var currentDistance = -currentIndex * liWidth;  move(wrap, [&#123; left: currentDistance + &quot;px&quot; &#125;]);&#125;;</code></pre><ol start="4"><li>处理左右按钮<blockquote><ul><li>鼠标移动到按钮上时，停止自动轮播；移开时，继续播放<ul><li>和分页器是一样的处理方式</li></ul></li><li>点击按钮，切换到上一张和下一张<blockquote><p>向上切换和向下切换有区别</p></blockquote></li><li>向下切换：<ul><li><code>currentIndex++</code></li><li>再改变分页器和图片容器的<code>left</code>(写成一个向下切换的函数)</li></ul></li><li>向上切换：<ul><li><code>currentindex--</code></li><li>当下标为0时，拉回到克隆的最后一张，<code>currentIdex=len</code></li><li>改变图片容器的<code>left</code></li></ul></li></ul></blockquote></li></ol><pre><code>//处理向下按钮 next.onmouseover = function () &#123;   clearInterval(timer); &#125;; next.onmouseout = function () &#123;   autoplay(); &#125;; next.onclick = function () &#123;   currentIndex++;   toNext(); &#125;; //处理向上按钮 prev.onmouseover = function () &#123;   clearInterval(timer); &#125;; prev.onmouseout = function () &#123;   autoplay(); &#125;; prev.onclick = function () &#123;   currentIndex--;   if (currentIndex &lt; 0) &#123;     //播到第一张时，拉回最后一张     wrap.style.left = -liWidth * len + &quot;px&quot;;     currentIndex = len - 1;   &#125;   currentSpan.classList.remove(&quot;active&quot;);   spans[currentIndex].classList.add(&quot;active&quot;);   currentSpan = spans[currentIndex];   var currentDistance = -currentIndex * liWidth;   move(wrap, [&#123; left: currentDistance + &quot;px&quot; &#125;]); &#125;;</code></pre><ul><li><code>toNext()</code>函数<blockquote><ul><li>和自动轮播效果的代码是一样的，所以把它摘出来</li></ul></blockquote></li></ul><pre><code>//向下播放函数 function toNext() &#123;   if (currentIndex &gt;= len) &#123;     //分页器变化     currentSpan.classList.remove(&quot;active&quot;);     spans[0].classList.add(&quot;active&quot;);     currentSpan = spans[0];   &#125; else &#123;     //分页器变化     currentSpan.classList.remove(&quot;active&quot;);     spans[currentIndex].classList.add(&quot;active&quot;);     currentSpan = spans[currentIndex];   &#125;&gt;  var targetDistance = -currentIndex * 990; //获取移动距离   // wrap.style.left = targetDistance + &quot;px&quot;;  move(wrap, [&#123; left: targetDistance + &quot;px&quot; &#125;], function () &#123;    if (currentIndex &gt;= len) &#123;      wrap.style.left = &quot;0px&quot;;      currentIndex = 0;    &#125;  &#125;);&#125;</code></pre><ol start="5"><li>优化<blockquote><ul><li>当上一个动画没结束时，点击无效<ul><li>声明一个<code>flag</code>，<code>flag=false</code>时表示动画结束了</li><li>什么时候动画结束？执行回调函数时</li></ul></li><li>给点击事件加<code> if (flag) return; flag = true;</code>，</li><li>加上回调函数</li></ul></blockquote></li></ol><pre><code>function () &#123;  flag = false;&#125;</code></pre><ul><li>布局代码</li></ul><pre><code>&gt;&lt;style&gt;  body,  ul,  li &#123;    margin: 0;    padding: 0;  &#125;  li &#123;    list-style: none;  &#125;  .container &#123;    position: relative;    width: 990px;    height: 460px;    overflow: hidden;    margin: 50px;  &#125;  .container .wrap &#123;    position: absolute;    left: 0;    top: 0;    width: 10000px;    height: 460px;  &#125;  .container .wrap li &#123;    float: left;    width: 990px;    height: 460px;  &#125;&gt;   /* 分页器 */  .buttons &#123;    position: absolute;    bottom: 20px;    left: 0;    width: 100%;    height: 20px;    text-align: center;    font-size: 0;  &#125;  .buttons span &#123;    display: inline-block;    width: 15px;    height: 15px;    border-radius: 50%;    background-color: #fff;    margin: 0 3px;      cursor: pointer;    &#125;    .buttons span.active &#123;      background-color: orange;    &#125;&gt;  /* 左右按钮 */  .container .prev,  .container .next &#123;    position: absolute;    top: 50%;    transform: translateY(-50%);    width: 41px;    height: 70px;    cursor: pointer;    background-image: url(../src/images/icon-slides.png);  &#125;  .container .prev &#123;    left: 0;    background-position: -83px 0;  &#125;  .prev:hover &#123;    background-position: 0;  &#125;  .container .next &#123;    right: 0;    background-position: -123px 0;  &#125;  .next:hover &#123;    background-position: -41px 0;  &#125;&gt;&lt;/style&gt;</code></pre><ul><li>JS代码<blockquote><ul><li>引用了<code>move.js</code>（前面封装的多属性限时动画）</li></ul></blockquote></li></ul><pre><code>&gt;&lt;div class=&quot;container&quot;&gt;&gt;  &lt;!-- 轮播图 --&gt;&gt;  &lt;ul class=&quot;wrap&quot;&gt;&gt;    &lt;li&gt;&lt;img src=&quot;../src/images/1.jpg&quot; alt=&quot;&quot; /&gt;&lt;/li&gt;&gt;    &lt;li&gt;&lt;img src=&quot;../src/images/2.jpg&quot; alt=&quot;&quot; /&gt;&lt;/li&gt;&gt;    &lt;li&gt;&lt;img src=&quot;../src/images/3.jpg&quot; alt=&quot;&quot; /&gt;&lt;/li&gt;&gt;    &lt;li&gt;&lt;img src=&quot;../src/images/4.jpg&quot; alt=&quot;&quot; /&gt;&lt;/li&gt;&gt;  &lt;/ul&gt;&gt;  &lt;!-- 分页器 --&gt;&gt;  &lt;div class=&quot;buttons&quot;&gt;&gt;    &lt;span class=&quot;active&quot;&gt;&lt;/span&gt;&gt;    &lt;span&gt;&lt;/span&gt;&gt;    &lt;span&gt;&lt;/span&gt;&gt;    &lt;span&gt;&lt;/span&gt;&gt;  &lt;/div&gt;&gt;  &lt;!-- 左右按钮 --&gt;&gt;  &lt;div class=&quot;prev&quot;&gt;&lt;/div&gt;&gt;  &lt;div class=&quot;next&quot;&gt;&lt;/div&gt;&gt;&lt;/div&gt;&gt;&lt;script src=&quot;./move.js&quot;&gt;&lt;/script&gt;&gt;&lt;script&gt;  //获取元素  var wrap = document.querySelector(&quot;.wrap&quot;);  var liList = document.querySelectorAll(&quot;.wrap li&quot;);  var button = document.querySelector(&quot;.buttons&quot;);  var spans = document.querySelectorAll(&quot;.buttons span&quot;);  var prev = document.querySelector(&quot;.prev&quot;);  var next = document.querySelector(&quot;.next&quot;);  var flag = false; // 表示当前没有元素在切换  //克隆第一个li到最后  var liLast = liList[0].cloneNode(true);  wrap.appendChild(liLast);  var liWidth = liList[0].offsetWidth;  var len = liList.length;  var currentIndex = 0; //记录轮播图下标  var currentSpan = spans[0]; //记录当前分页器下标  var timer = null; //定义定时器  autoplay();  //自动播放效果  function autoplay() &#123;    clearInterval(timer);    timer = setInterval(function () &#123;      currentIndex++;      toNext();    &#125;, 2000);  &#125;&gt;  for (var i = 0; i &lt; len; i++) &#123;    spans[i].index = i; //给span加下标    // 给span添加事件，鼠标放在分页器上就停止自动播放    spans[i].onmouseover = function () &#123;      clearInterval(timer);    &#125;;    //给span添加事件，鼠标移开就继续播放    spans[i].onmouseout = function () &#123;      autoplay();    &#125;;  &#125;  //点击哪个span就播放相应的图片  button.onclick = function (e) &#123;    var target = e.target;    var targetTag = target.tagName.toLowerCase();    if (flag) return;     flag = true;     if (targetTag !== &quot;span&quot;) return;     //如果点的是span,对应的span变色·     currentIndex = target.index;     currentSpan.classList.remove(&quot;active&quot;);     spans[currentIndex].classList.add(&quot;active&quot;);     currentSpan = spans[currentIndex];     //改变left,跳转到对应的图片     var currentDistance = -currentIndex * liWidth;     move(wrap, [&#123; left: currentDistance + &quot;px&quot; &#125;], function () &#123;       flag = false;     &#125;);   &#125;;&gt;  //处理向下按钮  next.onmouseover = function () &#123;    clearInterval(timer);  &#125;;  next.onmouseout = function () &#123;    autoplay();  &#125;;  next.onclick = function () &#123;    if (flag) return;    flag = true;    currentIndex++;    toNext();  &#125;;  //处理向上按钮  prev.onmouseover = function () &#123;    clearInterval(timer);  &#125;;  prev.onmouseout = function () &#123;    autoplay();  &#125;;  prev.onclick = function () &#123;    if (flag) return;    flag = true;    currentIndex--;    if (currentIndex &lt; 0) &#123;      //播到第一张时，拉回最后一张      wrap.style.left = -liWidth * len + &quot;px&quot;;      currentIndex = len - 1;    &#125;    currentSpan.classList.remove(&quot;active&quot;);    spans[currentIndex].classList.add(&quot;active&quot;);    currentSpan = spans[currentIndex];    var currentDistance = -currentIndex * liWidth;    move(wrap, [&#123; left: currentDistance + &quot;px&quot; &#125;], function () &#123;      flag = false;    &#125;);  &#125;;&gt;  //向下播放函数  function toNext() &#123;    if (currentIndex &gt;= len) &#123;      //分页器变化      currentSpan.classList.remove(&quot;active&quot;);      spans[0].classList.add(&quot;active&quot;);      currentSpan = spans[0];    &#125; else &#123;      //分页器变化      currentSpan.classList.remove(&quot;active&quot;);      spans[currentIndex].classList.add(&quot;active&quot;);      currentSpan = spans[currentIndex];    &#125;     var targetDistance = -currentIndex * 990; //获取移动距离     // wrap.style.left = targetDistance + &quot;px&quot;;    move(wrap, [&#123; left: targetDistance + &quot;px&quot; &#125;], function () &#123;      flag = false;      if (currentIndex &gt;= len) &#123;        wrap.style.left = &quot;0px&quot;;        currentIndex = 0;      &#125;    &#125;);  &#125;&gt;&lt;/script&gt;</code></pre><h3 id="二、定时器延迟执行与丢帧问题"><a href="#二、定时器延迟执行与丢帧问题" class="headerlink" title="二、定时器延迟执行与丢帧问题"></a>二、定时器延迟执行与丢帧问题</h3><blockquote><ul><li>要了解定时器为什么会延迟执行和存在丢帧问题，就需要先了解下面几个问题</li></ul></blockquote><ol><li>屏幕刷新频率<blockquote><ul><li>屏幕刷新频率即图像在屏幕上更新的速度，也即屏幕上的图像<strong>每秒钟</strong>出现的次数，它的单位是赫兹（Hz）。</li><li>对于一般笔记本电脑，这个频率大概是 60Hz，可以在桌面上 <code>右键 —显示设置 — 高级显示设置 — 刷新频率</code>中查看和设置<blockquote><p>这个值的设定受屏幕分辨率、屏幕尺寸和显卡的影响，原则上设置成让眼睛看着舒适的值都行。</p></blockquote></li></ul></blockquote></li></ol><ul><li>常见的显示器有两种<blockquote><p>即 CRT 和 LCD， CRT 就是传统显示器，LCD 就是我们常说的液晶显示器。</p><ul><li>CRT 是一种使用<code>阴极射线管</code>的显示器，屏幕上的图形图像是由一个个因<code>电子束</code>击打而发光的<code>荧光点</code>组成，由于显像管内荧光粉受到电子束击打后发光的时间很短，所以电子束必须不断击打荧光粉使其持续发光，电子束每秒击打荧光粉的次数就是屏幕刷新频率。</li></ul></blockquote></li></ul><blockquote><ul><li>而对于 LCD 来说，则不存在刷新频率的问题，它根本就<strong>不需要刷新</strong>，因为 LCD 中每个像素都在持续不断地发光，直到不发光的电压改变并被送到控制器中，所以 LCD 不会有电子束击打荧光粉而引起的闪烁现象。</li></ul></blockquote><blockquote><ul><li>因此，当你对着电脑屏幕什么也不做的情况下，显示器也会以每秒 60 次的频率正在不断的更新屏幕上的图像。为什么你感觉不到这个变化？</li><li>那是因为人的眼睛有<code>视觉停留效应</code>，即前一副画面留在大脑的印象还没消失，紧接着后一副画面就跟上来了，这中间只间隔了 <code>16.7ms(1000/60 ≈ 16.7)</code>。</li><li>所以会让你误以为屏幕上的图像是静止不动的，而屏幕给你的这种感觉是对的，试想一下，如果刷新频率变成 1 次&#x2F;秒，屏幕上的图像就会出现严重的闪烁，这样就很容易引起眼睛疲劳、酸痛和头晕目眩等症状。</li></ul></blockquote><ol start="2"><li><p>动画实现原理</p><blockquote><p>根据上面的原理我们知道，你眼前所看到图像正在以每秒60次的频率刷新，由于刷新频率很高，因此你感觉不到它在刷新，而动画本质就是要让人眼看到图像被刷新而引起变化的视觉效果，这个变化要以连贯的、平滑的方式进行过渡。<br>那怎么样才能做到这种效果呢 ?</p><ul><li>刷新频率为<code>60Hz</code>的屏幕每<code>16.7ms</code>刷新一次，我们在屏幕每次刷新前，将图像的位置向左移动一个像素，即1px，这样一来，屏幕每次刷出来的图像位置都比前一个要差 1px，因此你会看到图像在移动，由于我们人眼的视觉停留效应，当前位置的图像停留在大脑的印象还没消失，紧接着图像又被移到了下一个位置。</li><li>因此你才会看到图像在流畅的移动，这就是视觉效果上形成的动画。</li></ul></blockquote></li><li><p>setInterval 实现动画原理</p><blockquote><ul><li>setInterval 其实就是通过设置一个间隔时间来不断的改变图像的位置等属性，从而达到动画效果的。</li></ul></blockquote></li></ol><pre><code>setInterval(f, 20); // 每隔10ms 执行下回调函数 f</code></pre><ul><li>setInterval 执行会出现延迟问题<blockquote><ul><li>setInterval的执行时间并不是确定的。在 Javascript 中， setInterval 任务被放进了<strong>异步队列</strong>中，只有当<strong>主线程</strong>上的任务执行完以后，才会去检查该队列里的任务是否需要开始执行，因此， setInterval 的实际执行时间一般要比其设定的时间<strong>晚</strong>一些。</li><li>setInterval的<strong>第二个参数的延时</strong>只能保证何时会把回调函数添加到任务队列，<strong>不能保证</strong>添加到任务队就会立即执行。能不能执行要看主线程是否空闲，同时前面是否还有任务在等待</li></ul></blockquote></li></ul><ol start="4"><li>setTimeout 实现动画原理<blockquote><ul><li>setTimeout 是通过间隔一定时间执行动画<strong>回调函数</strong>，在回调函数执行完成后，再重新开一个 setTimeout 定时器执行下一次回调，重复上面过程。</li></ul></blockquote></li></ol><pre><code>function f() &#123;  /* 要执行的动画代码 */  // ....  setTimeout(f, 20);&#125;setTimeout(f, 20);</code></pre><blockquote><blockquote><p>注：</p></blockquote><ul><li><code>setTimeout</code>每次是在上一个动画执行完成后，再间隔相同时间，把定时器加入到<strong>任务队列</strong>等待执行。和 setInterval 一样都会存在延时问题。</li><li><strong>浏览器的计时</strong>也会存在不精准的问题，具体内容可参考官方教程</li></ul></blockquote><ol start="5"><li>动画动画卡顿、抖动现象<blockquote><ul><li><code>setInterval</code> 和 <code>setTimeout</code> 会出现<strong>执行时间延时</strong>问题</li><li>再加上<code>刷新频率</code>受屏幕分辨率和屏幕尺寸的影响，因此不同设备的屏幕刷频率可能会不同</li><li>而 <code>setInterval</code>只能设置一个固定的时间间隔，这个时间不一定和屏幕的刷新时间相同。<br>以上两种情况都会导致<code>动画的执行步调</code>和<code>屏幕的刷新步调</code>不一致，从而引起<strong>丢帧现象</strong>，造成动画卡顿、抖动。</li></ul></blockquote></li></ol><ul><li><p>那为什么步调不一致就会引起丢帧呢？</p><blockquote><ul><li>首先要明白，<code>setInterval</code> 和 <code>setTimeout</code> 的执行只是在<strong>内存中对图像属性进行改变</strong>，这个变化必须要等到屏幕下次<strong>刷新时</strong>才会被更新到屏幕上。</li><li>如果两者的步调不一致，就可能会导致中间某一帧的操作被跨越过去，而直接更新下一帧的图像</li></ul></blockquote></li><li><p>案例分析</p><blockquote><p>假设屏幕每隔 <code>16.7ms</code> 刷新一次，而 setInterval 每隔 <code>10ms</code> 设置图像向左移动 <code>1px</code>， 就会出现如下<br><strong>绘制过程</strong></p><ul><li>1、第<code>0ms</code>屏幕未刷新，等待中，<code>setInterval</code>也未执行，等待中；</li><li>2、第<code>10ms</code>屏幕未刷新，等待中，<code>setInterval</code>开始执行并设置图像属性<code>left = 1px</code>;</li><li>3、第<code>16.7ms</code>屏幕开始刷新，屏幕上的图像向左移动了 <code>1px</code>，<code>setInterval</code> 未执行，继续等待中；</li><li>4、第<code>20ms</code>屏幕未刷新，等待中，<code>setInterval</code>开始执行并设置图像属性 <code>left = 2px;</code></li><li>5、 第<code>30ms</code>屏幕未刷新，等待中，<code>setInterval</code>开始执行并设置图像属性<code>left = 3px;</code></li><li>6、第<code>33.4ms</code>屏幕开始刷新，屏幕上的图像向左移动了 <code>3px</code>，<code>setInterval</code>未执行，继续等待中；</li></ul></blockquote></li></ul><blockquote><blockquote><p>注：</p><ul><li>从上面的绘制过程中可以看出，屏幕<strong>没有更新</strong><code>left = 2px</code>的那一帧画面</li><li>图像直接从1px的位置跳到了3px的的位置</li><li>这就是丢帧现象，这种现象就会引起动画卡顿</li></ul></blockquote></blockquote><ol start="6"><li>总结：定时器执行动画卡顿、抖动原理<blockquote><ul><li><code>定时器的执行时间</code>并不是一定会按预期时间执行，所以会造成<strong>动画延迟执行</strong>。</li><li>定时器的<code>执行频率</code>和屏幕的<code>刷新频率</code>不一样，会造成<strong>丢帧现象，引起动画卡顿</strong>。</li><li>当然还有<strong>各个浏览器的计时器精度</strong>也程很大差异，不能精确到 1 毫秒内<br>比如：</li><li>Chrome 的计时器精度为 4 毫秒</li><li>Firefox 和 Safari 计时器精度约为 10 毫秒<blockquote><p>为了解决上面定时器存在的问题，出现了一个新的方法 <code>requestAnimationFrame</code></p></blockquote></li></ul></blockquote></li></ol><h3 id="三、requestAnimationFrame"><a href="#三、requestAnimationFrame" class="headerlink" title="三、requestAnimationFrame"></a>三、requestAnimationFrame</h3><blockquote><p>我们都知道：浏览器是知道<code>CSS3</code>的<code>transition</code> 和 &#96;animation动画什么时候开始，并据此计算出正确的时间间隔，到时间就去刷新用户界面。</p><ul><li>但是对于 JS 动画，浏览器并不知道动画什么时候开始，如果我们能<strong>让浏览器知道动画什么时候开始，然后开始刷新屏幕</strong>。</li><li>这样不就出现丢帧问题了吗？</li></ul></blockquote><blockquote><p><code>requestAnimationFrame</code>方法就可以解决这个问题</p><ul><li><code>requestAnimationFrame</code>最大的优势是由系统(浏览器)来决定回调函数的<strong>执行时机</strong></li><li>具体一点讲，如果屏幕刷新率是60Hz，那么回调函数就每<code>16.7ms</code>被执行一次</li><li>如果刷新率是<code>75Hz</code>，那么这个时间间隔就变成了<code>1000/75 = 13.3ms</code></li><li>换句话说就是，<code>requestAnimationFrame</code>的步伐跟着系统的刷新步伐走</li><li>它能保证回调函数在屏幕<strong>每一次的刷新间隔中</strong>只被执行一次，这样就不会引起丢帧现象，也不会导致动画出现卡顿的问题。</li></ul></blockquote><ol><li>requestAnimationFrame 用法<blockquote><ul><li><code>window.requestAnimationFrame()</code>告诉浏览器——你希望执行一个动画，并且要求浏览器在<strong>下次重绘之前</strong>调用指定的回调函数更新动画。</li><li>该方法需要传入一个回调函数作为参数，该回调函数会在浏览器下一次重绘之前执行</li><li><code>window.requestAnimationFrame()</code>的返回值是它的ID</li></ul></blockquote></li></ol><pre><code>var timer = window.requestAnimationFrame(callback);// callback 下一次重绘之前更新动画帧所调用的函数// timer 一个整数，表示请求ID 是回调列表中唯一的标识</code></pre><blockquote><blockquote><p>requestAnimationFrame 方法只会执行一次</p></blockquote></blockquote><ol start="2"><li>requestAnimationFrame 实现动画原理</li></ol><pre><code>window.requestAnimationFrame(f);function f() &#123;  /* 动画执行代码 */  if (条件为真) &#123;    window.requestAnimationFrame(f);  &#125;&#125;</code></pre><ol start="3"><li>cancelAnimationFrame<blockquote><p><code>cancelAnimationFrame</code>方法用来<strong>取消</strong><code>requestAnimationFrame</code>方法添加的的任务。</p></blockquote></li></ol><pre><code>var requestId = requestAnimationFrame(fn); // 第一次执行cancelAnimationFrame(requestId);function fn() &#123;  console.log(&quot;我不会出来&quot;);&#125;</code></pre><ol start="4"><li><p>requestAnimationFrame 注意事项</p><blockquote><ul><li>为了提高性能和电池寿命，因此在大多数浏览器里，当<code>requestAnimationFrame()</code>运行在<strong>后台标签页</strong>或者隐藏的<code>&lt;iframe&gt;</code>里时，<code>requestAnimationFrame()</code>会被<strong>暂停调用</strong>以提升性能和电池寿命。</li></ul></blockquote></li><li><p>requestAnimationFrame 方法实现动画</p></li></ol><pre><code>&gt;&lt;style&gt;  .box &#123;    width: 100px;    height: 100px;    background-color: red;    position: absolute;    left: 0;  &#125;&gt;&lt;/style&gt;&gt;&gt;&lt;div class=&quot;box&quot;&gt;&lt;/div&gt;&gt;&lt;script&gt;  var box = document.querySelector(&quot;.box&quot;);  requestAnimationFrame(fn); // 第一次执行  function fn() &#123;    var left = box.offsetLeft + 3;    if (left &gt; 600) left = 600;    box.style.left = left + &quot;px&quot;;    if (left &lt; 600) &#123;      requestAnimationFrame(fn); // 没有有达到目标，再次执行    &#125;  &#125;&gt;&lt;/script&gt;</code></pre><ol start="6"><li>优雅降级 - 处理兼容问题<blockquote><ul><li>目前所有浏览器都支持<code>requestAnimationFrame</code>这个不带前缀的方法，但考虑有些浏览器的旧版本，还需要添加前缀，所以需要处理下兼容问题。</li></ul></blockquote></li></ol><pre><code>window.requestAnimFrame = (function () &#123;  return (    window.requestAnimationFrame ||    window.webkitRequestAnimationFrame ||    window.mozRequestAnimationFrame ||    window.oRequestAnimationFrame ||    window.msRequestAnimationFrame ||    function (callback) &#123;      window.setTimeout(callback, 1000 / 60);    &#125;  );&#125;)();</code></pre><h3 id="四、函数节流-经典面试题"><a href="#四、函数节流-经典面试题" class="headerlink" title="四、函数节流(经典面试题)"></a>四、函数节流(经典面试题)</h3><blockquote><p><strong>什么是函数节流：</strong></p><ul><li>不管事件触发有多频繁，都会保证在规定时间内执行一次真正的事件处理函数<br><strong>函数节流原理：</strong></li><li>通过判断是否到达一定时间，如果<code>时间 &gt;= 规定时间周期</code>，才会触发函数<br><strong>函数节流优点：</strong></li><li>降低函数执行的频率，从而达到节省计算资源，减少性能消耗</li></ul></blockquote><h4 id="优化JS结合CSS3的transition实现动画"><a href="#优化JS结合CSS3的transition实现动画" class="headerlink" title="优化JS结合CSS3的transition实现动画"></a>优化JS结合CSS3的transition实现动画</h4><blockquote><ul><li>如果用户<strong>频繁的点击</strong>开始动画按扭，那方块就会在未达到终点状态之间来回切换</li><li>如果我们希望在动画没有到达终点状态之前，不管用户点击多少次，都不会执行再执行新的动画。</li><li>只有动画到达终点状态后，用户再次点击，才会再执行新的动画</li></ul></blockquote><ol><li>基础版</li></ol><ul><li>设置一个锁，上锁后：在动画完成之前，用户点击无效<blockquote><ul><li>定义一个变量<code>lock</code>与定时器配合，变量 <code>lock</code> 相当于一把锁，定时器用来记录时间。</li><li>刚开始变量<code>lock = false</code>，表示锁是打开的，可以执行事件处理函数中代码，在执行时立即设置<code>lock = true</code></li><li><code>lock = true</code>，相当于当前锁是关上的，不管事件触发多少次，都不会做任何操作</li><li>等到定时器时间一到，在定时器中设置<code>lock = false</code>，相当把锁打开，下一次事件触发，则又恢复正常。</li><li>重复上面过程，就可以达到<strong>节流</strong>效果，相当于事件处理函数在1000ms内只会执行一次</li></ul></blockquote></li></ul><pre><code> var button = document.querySelector(&quot;.button&quot;); var box = document.querySelector(&quot;.box&quot;); var flag = false; //true表示样式还没加上去，还在原地 var lock = false; //表示未锁上 button.onclick = function () &#123;   if (lock) return; //锁上时，不能进   lock=true;//动画开始后就上锁&gt; //如果flag=true,则移除样式 if (flag) &#123;   box.classList.remove(&quot;active&quot;);   flag = false; &#125; else &#123;   //如果flag=false,则添加样式   box.classList.add(&quot;active&quot;);   flag = true; &#125;&gt;  timer = setTimeout(function () &#123;    lock=false; //动画结束后，开锁  &#125;, 1000);&#125;;</code></pre><ol start="2"><li>第一次优化<blockquote><ul><li>我们把上面的<code>lock</code>变量消除掉，直接用 <code>timer</code>变量来代替。</li><li>代码中，两处<code>lock = false</code>的地方，用<code>timer = null;</code>替换, 表示当前锁是开的, 可以执行事件处理函数</li><li>把<code>if(lock)</code>换成 <code>if(timer)</code> ，如果timer有值，表示当前锁是关着的，不能再次执行事件处理函数</li><li>去掉用来保存定时器返回值 <code>timer</code>变量前面的<code>var</code>，因为<code>timer</code>在上面改成全局中声明</li></ul></blockquote></li></ol><pre><code> var button = document.querySelector(&quot;.button&quot;); var box = document.querySelector(&quot;.box&quot;); var flag = false; //true表示样式还没加上去，还在原地 var timer = null; //定时器不存在时，表示未锁上 button.onclick = function () &#123;   if (timer) return; //锁上时，不能进&gt; //如果flag=true,则移除样式 if (flag) &#123;   box.classList.remove(&quot;active&quot;);   flag = false; &#125; else &#123;   //如果flag=false,则添加样式   box.classList.add(&quot;active&quot;);   flag = true; &#125;&gt;  //动画开始后，定时器启动，即上锁  timer = setTimeout(function () &#123;    timer = null; //动画结束后，开锁  &#125;, 1000);&#125;;</code></pre><ol start="3"><li>第二次优化：封装节流函数<blockquote><ul><li><code>move</code>为真正的事件处理函数</li><li><code>throttle</code>是用来处理节流的函数</li><li><code>timer</code>这个变量不能放在全局作用域下,要<strong>改写</strong>到<code>throttle</code>函数内部才算是完美的。</li><li><strong>定时器的时间</strong>不能固定，可以改写成参数，让用户自己来决定</li><li><strong>事件处理函数</strong>也不能固定死，可以改写成参数，让用户自己来决定</li></ul></blockquote></li></ol><pre><code> var button = document.querySelector(&quot;.button&quot;); var box = document.querySelector(&quot;.box&quot;); var flag = false; //true表示样式还没加上去，还在原地 button.onclick = throttle(move, 1000); //相当于： button.onclick =function () &#123;  if (timer) return; //锁上时，不能进  fn(); //调用函数，使其运动  //动画开始后，定时器启动，即上锁  timer = setTimeout(function () &#123;    timer = null; //动画结束后，开锁  &#125;, delay);&#125;;&gt;&gt;/**&gt; * throttle 节流函数&gt; * fn 事件处理函数&gt; * delay 延迟时间&gt; */ function throttle(fn, delay = 50) &#123;   var timer = null; //定时器不存在时，表示未锁上   return function () &#123;     if (timer) return; //锁上时，不能进     fn(); //调用函数，使其运动     //动画开始后，定时器启动，即上锁     timer = setTimeout(function () &#123;       timer = null; //动画结束后，开锁     &#125;, delay);   &#125;; &#125; //点击事件，需要处理的代码 function move() &#123;   //如果flag=true,则移除样式   if (flag) &#123;     box.classList.remove(&quot;active&quot;);     flag = false;   &#125; else &#123;     //如果flag=false,则添加样式     box.classList.add(&quot;active&quot;);     flag = true;   &#125; &#125;</code></pre><ol start="4"><li>第三次优化<blockquote><ul><li>以上事件处理函数<code>move</code>中的<code>this</code>和事件对象<code>e</code>是有问题的</li><li><code>onclick</code>原本调用的应该是<code>move</code>函数，但封装后，<code>fn()</code>直接调用，内部 <code>this</code> 肯定指向的是 <code>window</code>，同时事件对象 <code>e</code> 被丢失了</li></ul><blockquote><p>还有一个问题，就是<code>fn()</code>事件处理函数的<strong>位置问题</strong>，他是写在定时器前面，还是后面，还是定时器里面呢？</p></blockquote><ul><li>如果 fn() 写在定时器后面，相对来说没有什么问题，只是定时器会先计时，再执行fn()</li><li>如果fn()写在定时器前面，那会先执行事件处理函数，再定时器计时，那<strong>最终每次间隔时间比预期的长些</strong>，如果fn()执行时间较长，会达不到节流效果。</li><li>如果fn()写在定时器里面，那要等到计时器到达时间后才开始执行fn()，这样就会造成<strong>第一次fn()函数要在计时器到达到才执行</strong>。（针对<strong>高频事件</strong>，<code>delay</code> 的时间特别小，这个影响可以忽略不计，但如果 <code>delay</code> 的时间特别长，那这个影响就很明显了，后面用案例演示）</li><li>而我们所说的节流操作主要针对的就是<strong>高频时间</strong>，即 <code>delay</code>的时间特别小，所以面试中，各大网站上流行的面试题答案都是基于这个版本的。<blockquote><p>因此，<code>fn.apply(self, args);</code>写在定时器里面，只适合高频时间；如果是低频，就把<code>fn.apply(self, args);</code>写在定时器后面</p></blockquote></li></ul></blockquote></li></ol><pre><code>function throttle(fn, delay = 50) &#123;  var timer = null; //定时器不存在时，表示未锁上  return function () &#123;    if (timer) return; //锁上时，不能进    //动画开始后，定时器启动，即上锁    var self = this;//将调用事件处理函数的this传过去    var args = arguments;//将事件对象e传过去    timer = setTimeout(function () &#123;      fn.apply(self, args); //只适合高频函数，调用函数，使其运动      timer = null; //动画结束后，开锁    &#125;, delay);  &#125;;&#125; //点击事件，需要处理的代码 function move() &#123;   //如果flag=true,则移除样式   if (flag) &#123;     box.classList.remove(&quot;active&quot;);     flag = false;   &#125; else &#123;     //如果flag=false,则添加样式     box.classList.add(&quot;active&quot;);     flag = true;   &#125; &#125;</code></pre><blockquote><ul><li>根据前面的优化，我们可以得到封装好的节流函数</li></ul></blockquote><h4 id="ES5-版本-节流函数"><a href="#ES5-版本-节流函数" class="headerlink" title="ES5 版本 - 节流函数"></a>ES5 版本 - 节流函数</h4><blockquote><ul><li><code>ES5</code>版本的定时器中的回调函数，它的this指向的是<code>window</code>，<code>arguments</code>也指的是回调函数的</li><li>所以要用变量把它们存起来再传过去</li></ul></blockquote><pre><code>&gt;/**&gt; * throttle 节流函数&gt; * fn 事件处理函数&gt; * delay 执行事件处理函数的间隔时间&gt; */function throttle(fn, delay = 20) &#123;  var timer = null; // null表示当前锁是打开的，没有锁，可以执行事件处理函数中的代码&gt;  return function () &#123;    if (timer) return;    var self = this; // 保存this 绑定事件的对象    var args = arguments; // 保存arguments 主要用来获取事件对象 e    // 定时器计时，用来开锁    timer = setTimeout(function () &#123;      fn.apply(self, args); // 事件处理函数      timer = null; // 开锁    &#125;, delay);    //fn.apply(self, args); // 事件处理函数  &#125;;&#125;</code></pre><h4 id="ES6-版本-节流函数"><a href="#ES6-版本-节流函数" class="headerlink" title="ES6 版本 - 节流函数"></a>ES6 版本 - 节流函数</h4><blockquote><ul><li><code>ES6</code>版本的节流函数用的是箭头函数的<code>setTimeout</code>，这个版本的定时器没有相应的<code>this</code>和<code>arguments</code></li><li>因此不需要用变量把它们存起来再传过去</li></ul></blockquote><pre><code>&gt;/**&gt; * throttle 节流函数&gt; * fn 事件处理函数&gt; * delay 执行事件处理函数的间隔时间&gt; */function throttle(fn, delay = 20) &#123;  var timer = null; // null表示当前锁是打开的，没有锁，可以执行事件处理函数中的代码&gt;  return function () &#123;    if (timer) return;    // 定时器计时，用来开锁    timer = setTimeout(() =&gt; &#123;      fn.apply(this, arguments); // 箭头函数没有自己的this和arguments      timer = null; // 开锁    &#125;, delay);  &#125;;&#125;</code></pre><h4 id="节流函数的应用场景："><a href="#节流函数的应用场景：" class="headerlink" title="节流函数的应用场景："></a>节流函数的应用场景：</h4><blockquote><ul><li>当一个事件触发的时间特别短时，就会频繁的触发事件处理函数，我们需要通过节流函数来限止执行的频率。</li><li>比如：<code>mousemove</code>、<code>mousedown</code>、<code>keydown</code>、<code>scroll</code>等事件，他们的触发时间特别短。我们可以通过节流函数来限止，在一定时间内只能执行一次</li></ul></blockquote><ol><li>案例1：对<code>mousemove</code>事件处理函数执行节流操作——高频<blockquote><ul><li>接下来我们对<code>mousemove</code>事件处理函数执行节流操作，限止其在1000ms内只能执行一次</li><li>即<code>mousemove</code>事件频繁触发，那事件处理函数也只会每间隔1000ms才会执行一次</li></ul></blockquote></li></ol><blockquote><p><strong>节流实现原理</strong></p><ul><li>用定时器作为锁，如果定时器在运行，表示当前锁是关着的，不能再次执行事件处理函数</li></ul></blockquote><ul><li>用前面封装好的节流函数，来对<code>mousemove</code>事件处理函数执行节流操作</li></ul><pre><code>&gt;&lt;script src=&quot;./throttle.js&quot;&gt;&lt;/script&gt;&gt;&lt;script&gt;  // document.onmousemove = fn;//未节流  document.onmousemove = throttle(fn, 1000);  var i = 0;  function fn() &#123;    console.log(i++);  &#125;&gt;&lt;/script&gt;</code></pre><ol start="2"><li>案例2：规定时间内只能操作一次——低频<blockquote><ul><li>这个案例主要是用来演示上面提到事件处理函数放在<strong>定时器里面与外面</strong>的区别</li><li>我们希望点击发送按扭，就执行一次回调函数，然后间隔<code>1s </code>后，再次点击发送按扭才会再次执行回调函数。如果下一次点击时间离上一次点击时间<code>&lt; 1s</code>，就啥也不做。</li></ul></blockquote></li></ol><pre><code>&gt;&lt;button class=&quot;send&quot;&gt;发送&lt;/button&gt;&gt;&lt;script&gt;  var send = document.querySelector(&quot;.send&quot;);  send.onclick = throttle(fn, 1000);&gt;  function fn() &#123;    console.log(&quot;111&quot;);  &#125;&gt;  function throttle(fn, delay = 50) &#123;    var timer = null; //null表示锁是打开的    return function () &#123;      if (timer) return; //如果定时器还存在，就不能进      var self = this;      var args = arguments;      timer = setTimeout(function () &#123;        timer = null;      &#125;, delay);      fn(this, args);    &#125;;  &#125;&gt;&lt;/script&gt;</code></pre><h3 id="五、CSS3动画效果开发"><a href="#五、CSS3动画效果开发" class="headerlink" title="五、CSS3动画效果开发"></a>五、CSS3动画效果开发</h3><blockquote><ul><li>在前面我们已经学习了如何利用<strong>纯JS</strong>来实现动画效果，如果实现相对较简单的动画JS肯定是没什么问题，但如果遇到相对复杂的动画，用 JS 实现起来还是很麻烦的。</li><li>我们知道，<code>CSS3</code>的<code>transition</code>可以实现过渡动画，<code>animation</code>可以实现相对复杂的动画。而且<code>CSS3</code>动画是<strong>浏览器原生支持</strong>的，相对而言性能比 JS 实现会更好。</li></ul></blockquote><h4 id="过渡事件"><a href="#过渡事件" class="headerlink" title="过渡事件"></a>过渡事件</h4><table><thead><tr><th>事件</th><th>描述</th></tr></thead><tbody><tr><td><code>transitionstart</code></td><td>该事件在 CSS 过渡<strong>实际开始时</strong>触发</td></tr><tr><td><code>transitionend</code></td><td>该事件在 CSS <strong>完成过渡后</strong>触发。</td></tr><tr><td><code>transitioncancel</code></td><td>该事件在 CSS 过渡动画<strong>取消时</strong>触发</td></tr><tr><td><code>transitionrun</code></td><td>该事件会在<strong>创建过渡动画前</strong>触发，即在 <code>transitionstart</code>前触发</td></tr></tbody></table><pre><code>&gt;&lt;style&gt;  .box &#123;    width: 100px;    height: 100px;    background-color: red;    transition: width 1s ease;  &#125;  .box:hover &#123;    width: 300px;  &#125;&gt;&lt;/style&gt;&gt;&gt;&lt;div class=&quot;box&quot;&gt;&lt;/div&gt;&gt;&lt;script&gt;  var box = document.querySelector(&quot;.box&quot;);  box.addEventListener(&quot;transitionend&quot;, fn, false);  function fn() &#123;    // alert(&quot;动画结束&quot;);    this.style.width = &quot;300px&quot;; // 动画结束后，停在目标点  &#125;&gt;&lt;/script&gt;</code></pre><h4 id="动画事件"><a href="#动画事件" class="headerlink" title="动画事件"></a>动画事件</h4><blockquote><p>以下是常见的 CSS3 动画事件</p><table><thead><tr><th>事件</th><th>描述</th></tr></thead><tbody><tr><td>animationend</td><td>该事件在 CSS 动画结束播放时触发</td></tr><tr><td>animationiteration</td><td>该事件在 CSS 动画重复播放时触发</td></tr><tr><td>animationstart</td><td>该事件在 CSS 动画开始播放时触发</td></tr><tr><td>animationcancel</td><td>该事件在 CSS 动画意外中止时触发</td></tr></tbody></table></blockquote><blockquote><ul><li><code>animationiteration</code>的触发次数是<code>重复数-1</code>，因为第一次播放动画不算</li></ul></blockquote><pre><code>&gt;&lt;style&gt;  .box &#123;    width: 100px;    height: 100px;    background-color: skyblue;    /* 动画名  动画时间  速度  延时  执行次数 */    animation: move 2s ease 2s 3;  &#125;  @keyframes move &#123;    0% &#123;      width: 100px;      height: 100px;    &#125;    50% &#123;      width: 300px;      height: 100px;    &#125;    100% &#123;      width: 300px;      height: 300px;    &#125;  &#125;&gt;&lt;/style&gt;&gt;&gt;&lt;div class=&quot;box&quot;&gt;&lt;/div&gt;&gt;&lt;script&gt;  var box = document.querySelector(&quot;.box&quot;);  box.addEventListener(&quot;animationstart&quot;, fn1, false);  box.addEventListener(&quot;animationend&quot;, fn2, false);  box.addEventListener(&quot;animationiteration&quot;, fn3, false);  function fn1() &#123;    console.log(&quot;动画开始前执行&quot;);  &#125;  function fn2() &#123;    console.log(&quot;动画开始结束时执行&quot;);  &#125;  function fn3() &#123;    console.log(&quot;动画重复执行时执行&quot;);  &#125;&gt;&lt;/script&gt;</code></pre><h4 id="案例1：JS-结合-CSS3-的-transition-实现动画"><a href="#案例1：JS-结合-CSS3-的-transition-实现动画" class="headerlink" title="案例1：JS 结合 CSS3 的 transition 实现动画"></a>案例1：JS 结合 CSS3 的 transition 实现动画</h4><blockquote><p>我们希望利用 JS 与 CSS3 来实现以下动画效果，我们来看下<br><strong>实现的思路</strong></p><ul><li>整个运动过程中，方块的位置、宽、高、透明度都发生了变化</li><li>我们可以给方块添加 <code>transition</code> 过渡属性，让其支持过渡动画</li><li>然后在点击开始动画按扭时，动态添加相应的样式，那方块就会按下面效果动起来。</li></ul></blockquote><ol><li>基础版</li></ol><pre><code>&gt;&lt;style&gt;  .box &#123;    position: absolute;    left: 50px;    top: 50px;    width: 100px;    height: 100px;    background-color: skyblue;    opacity: 1;    transition: all 1s ease;  &#125;  .active &#123;    left: 300px;    top: 300px;    width: 200px;    height: 200px;    opacity: 0.3;  &#125;&gt;&lt;/style&gt;&gt;&lt;button class=&quot;button&quot;&gt;开始动画&lt;/button&gt;&gt;&lt;div class=&quot;box&quot;&gt;&lt;/div&gt;&gt;&lt;script&gt;  var button = document.querySelector(&quot;.button&quot;);  var box = document.querySelector(&quot;.box&quot;);  var flag = false; //true表示样式还没加上去，还在原地  button.onclick = function () &#123;    //如果flag=true,则移除样式    if (flag) &#123;      box.classList.remove(&quot;active&quot;);      flag = false;    &#125; else &#123;      //如果flag=false,则添加样式      box.classList.add(&quot;active&quot;);      flag = true;    &#125;  &#125;;&gt;&lt;/script&gt;</code></pre><ol start="2"><li>动画的优化<blockquote><ul><li>如果用户<strong>频繁的点击</strong>开始动画按扭，那方块就会在未达到终点状态之间来回切换</li><li>如果我们希望在动画没有到达终点状态之前，不管用户点击多少次，都不会执行再执行新的动画。</li><li>只有动画到达终点状态后，用户再次点击，才会再执行新的动画</li></ul></blockquote></li></ol><ul><li>解决方案一：节流函数<blockquote><ul><li>利用前面封装好的节流函数</li></ul></blockquote></li></ul><pre><code>function throttle(fn, delay = 50) &#123;  var timer = null; //定时器不存在时，表示未锁上  return function () &#123;    if (timer) return; //锁上时，不能进    //动画开始后，定时器启动，即上锁    var self = this;//将调用事件处理函数的this传过去    var args = arguments;//将事件对象e传过去    timer = setTimeout(function () &#123;      fn.apply(self, args); //只适合高频函数，调用函数，使其运动      timer = null; //动画结束后，开锁    &#125;, delay);  &#125;;&#125; //点击事件，需要处理的代码 function move() &#123;   //如果flag=true,则移除样式   if (flag) &#123;     box.classList.remove(&quot;active&quot;);     flag = false;   &#125; else &#123;     //如果flag=false,则添加样式     box.classList.add(&quot;active&quot;);     flag = true;   &#125; &#125;</code></pre><ul><li>解决方案二：过渡事件<blockquote><ul><li>给<code>box</code>加<code>transitionend</code>事件，在过渡动画完成后，才能打开锁</li></ul></blockquote></li></ul><pre><code>&gt;&lt;script&gt;  var button = document.querySelector(&quot;.button&quot;);  var box = document.querySelector(&quot;.box&quot;);  var flag = false; //true表示样式还没加上去，还在原地  var lock = false; //false表示未上锁  button.onclick = function () &#123;    //如果上锁了就不能进    if (lock) return;    //进来之后上锁    lock = true;    //如果flag=true,则移除样式    if (flag) &#123;      box.classList.remove(&quot;active&quot;);      flag = false;    &#125; else &#123;      //如果flag=false,则添加样式      box.classList.add(&quot;active&quot;);      flag = true;    &#125;  &#125;;  box.addEventListener(    &quot;transitionend&quot;,    function () &#123;      lock = false;    &#125;,    false  );&gt;&lt;/script&gt;</code></pre><h4 id="案例2：二级伸缩菜单——低频"><a href="#案例2：二级伸缩菜单——低频" class="headerlink" title="案例2：二级伸缩菜单——低频"></a>案例2：二级伸缩菜单——低频</h4><ol><li><p>思路</p><blockquote><ul><li>使用事件委托</li><li>点击标题，拿到它后面的<code>ul</code><ul><li><code>var nextSibling = target.nextElementSibling;</code></li></ul></li><li>展开、收缩菜单<ul><li>定义一个变量<code>flag</code>来更新状态</li><li>改变<code>ul</code>的高度</li></ul></li><li>动态获取每个ul的高度<ul><li>先拿到<code>ul</code>的子元素，得到子元素的<code>length</code></li><li>再拿到第一个子元素的高度</li><li>总高度&#x3D;个数*单个高度；</li></ul></li></ul></blockquote></li><li><p>为了防止用户重复点击，造成抖动，所以要进行优化</p></li></ol><ul><li>CSS代码</li></ul><pre><code>&gt;&lt;style&gt;  body,  html,  ul,  li &#123;    margin: 0;    padding: 0;  &#125;  li &#123;    list-style: none;  &#125;  a &#123;    color: #000;    text-decoration: none;  &#125;  .menu &#123;    width: 200px;    margin: 50px;  &#125;  .menu .title &#123;    width: 100%;    height: 30px;    font-size: 20px;    background-color: skyblue;    color: #fff;    cursor: pointer;    text-indent: 1em;    user-select: none;  &#125;  .menu ul &#123;    height: 0;    overflow: hidden;  &#125;  .menu ul li a &#123;    text-indent: 2em;    display: inline-block;    width: 100%;    height: 25px;    border-bottom: 1px solid #ddd;  &#125;&gt;&lt;/style&gt;&gt;&gt;&lt;div class=&quot;menu&quot;&gt;&gt;  &lt;div class=&quot;title&quot;&gt;菜单一&lt;/div&gt;&gt;  &lt;ul&gt;&gt;    &lt;li&gt;&lt;a href=&quot;&quot;&gt;首页&lt;/a&gt;&lt;/li&gt;&gt;    &lt;li&gt;&lt;a href=&quot;&quot;&gt;免费公开课&lt;/a&gt;&lt;/li&gt;&gt;    &lt;li&gt;&lt;a href=&quot;&quot;&gt;web前端&lt;/a&gt;&lt;/li&gt;&gt;    &lt;li&gt;&lt;a href=&quot;&quot;&gt;JAVA&lt;/a&gt;&lt;/li&gt;&gt;    &lt;li&gt;&lt;a href=&quot;&quot;&gt;大数据&lt;/a&gt;&lt;/li&gt;&gt;  &lt;/ul&gt;&gt;  &lt;div class=&quot;title&quot;&gt;菜单二&lt;/div&gt;&gt;  &lt;ul&gt;&gt;    &lt;li&gt;&lt;a href=&quot;&quot;&gt;免费公开课&lt;/a&gt;&lt;/li&gt;&gt;    &lt;li&gt;&lt;a href=&quot;&quot;&gt;JAVA&lt;/a&gt;&lt;/li&gt;&gt;    &lt;li&gt;&lt;a href=&quot;&quot;&gt;大数据&lt;/a&gt;&lt;/li&gt;&gt;  &lt;/ul&gt;&gt;  &lt;div class=&quot;title&quot;&gt;菜单三&lt;/div&gt;&gt;  &lt;ul&gt;&gt;    &lt;li&gt;&lt;a href=&quot;&quot;&gt;免费公开课&lt;/a&gt;&lt;/li&gt;&gt;    &lt;li&gt;&lt;a href=&quot;&quot;&gt;web前端&lt;/a&gt;&lt;/li&gt;&gt;    &lt;li&gt;&lt;a href=&quot;&quot;&gt;大数据&lt;/a&gt;&lt;/li&gt;&gt;  &lt;/ul&gt;&gt;&lt;/div&gt;</code></pre><ul><li>JS代码——优化方案1：节流函数</li></ul><pre><code>&gt;&lt;script src=&quot;./throttle2.js&quot;&gt;&lt;/script&gt;&gt;&lt;script&gt;  //获取元素  var menu = document.querySelector(&quot;.menu&quot;);  //节流操作(把fn写在定时器后面)  menu.onclick = throttle(fn, 300);  //事件委托  function fn(e) &#123;    var target = e.target;    var targetName = target.className;    if (targetName !== &quot;title&quot;) return;    //获取菜单的后一个HTML元素    var nextSibling = target.nextElementSibling;    //获取菜单的后一个HTML元素的子元素    var children = nextSibling.children;    //获取高度    var height = children.length * children[0].offsetHeight;    //动态改变ul的值    if (target.flag) &#123;      //如果flag=true,则收缩      nextSibling.style.height = &quot;0px&quot;;      target.flag = false; //更新状态    &#125; else &#123;      //如果flag=false,则展开      nextSibling.style.height = height + &quot;px&quot;;      target.flag = true; //更新状态    &#125;  &#125;&gt;&lt;/script&gt;</code></pre><ul><li>JS代码——优化方案2：过渡事件<blockquote><ul><li>给<code>ul</code>的CSS代码加上<code>transition</code>动画</li><li>声明一个变量，作为过渡动画的锁，只有动画完成了才能再一次进入</li><li>利用for循环，给每个ul加上<code>transitionend</code>事件，当动画结束时，开锁</li></ul></blockquote></li></ul><pre><code>.menu ul &#123;  height: 0;  overflow: hidden;  transition: height 1s ease;&#125;&gt;&lt;script&gt; //获取元素 var menu = document.querySelector(&quot;.menu&quot;); var oUL = document.querySelectorAll(&quot;.menu ul&quot;);&gt; var lock = false; //false表示未上锁&gt; menu.onclick = fn; //事件委托 function fn(e) &#123;   if (lock) return; //上锁了就不能进   lock = true;   var target = e.target;   var targetName = target.className;   if (targetName !== &quot;title&quot;) return;   //获取菜单的后一个HTML元素   var nextSibling = target.nextElementSibling;   //获取菜单的后一个HTML元素的子元素   var children = nextSibling.children;   //获取高度   var height = children.length * children[0].offsetHeight;   //动态改变ul的值   if (target.flag) &#123;     //如果flag=true,则收缩     nextSibling.style.height = &quot;0px&quot;;     target.flag = false; //更新状态   &#125; else &#123;     //如果flag=false,则展开     nextSibling.style.height = height + &quot;px&quot;;     target.flag = true; //更新状态   &#125; &#125; // 每个ul身上添加transitionend事件，当动画结束触发了transitionend事件时，开锁 for (var i = 0; i &lt; oUL.length; i++) &#123;   oUL[i].addEventListener(     &quot;transitionend&quot;,     function () &#123;       lock = false; //开锁     &#125;,     false   ); &#125;&gt;&lt;/script&gt;</code></pre><h4 id="案例3：JS-结合-CSS3-实现转盘抽奖"><a href="#案例3：JS-结合-CSS3-实现转盘抽奖" class="headerlink" title="案例3：JS 结合 CSS3 实现转盘抽奖"></a>案例3：JS 结合 CSS3 实现转盘抽奖</h4><blockquote><p>涉及知识点</p><ul><li>抽奖盘布局</li><li>抽奖概率计算原理</li><li>transitionend 事件</li><li>css3 实现缓动动画</li><li>节流锁应用</li><li>其它：权重数组、数组 sort 方法排序、switch 用法、数组的 splice 方法</li></ul></blockquote><ol><li>CSS布局</li></ol><pre><code>&gt;&lt;style&gt;  /* 初始化 */  body,  html &#123;    margin: 0;    padding: 0;    height: 100%;  &#125;  /* 使转盘在中间 */  body &#123;    display: flex;    align-items: center;    justify-content: center;  &#125;  .luck-draw &#123;    display: flex;    align-items: center;    justify-content: center;    width: 300px;    height: 300px;    background-color: tomato;    border-radius: 50%;  &#125;  /* 最终是使luck-panel转动 */  .luck-draw .luck-panel &#123;    width: 280px;    height: 280px;    border-radius: 50%;    overflow: hidden;    transform: rotate(-67.5deg);    transition: transform 1s cubic-bezier(0.15, 0.79, 0.64, 0.97);  &#125;  /* 左边转盘 */  .panel-left &#123;    position: relative;    float: left;    width: 50%;    height: 100%;  &#125;  .panel-left .prize-item &#123;    position: absolute;    top: 0;    left: 0;    transform-origin: right center;  &#125;  .panel-left .prize-item:nth-child(1) &#123;    width: 100%;    height: 100%;    background-color: pink;  &#125;  .panel-left .prize-item:nth-child(2) &#123;    width: 100%;    height: 100%;    background-color: rgb(155, 185, 215);    transform: rotate(-45deg);  &#125;  .panel-left .prize-item:nth-child(3) &#123;    width: 100%;    height: 100%;    background-color: rgb(181, 228, 179);    transform: rotate(-90deg);  &#125;  .panel-left .prize-item:nth-child(4) &#123;    width: 100%;    height: 100%;    background-color: rgb(197, 169, 228);    transform: rotate(-135deg);  &#125;  /* 调整文字 */  .panel-left .prize-item span &#123;    position: absolute;    top: 20px;    right: 10px;    transform: rotate(-24deg);    user-select: none;  &#125;  /* 右边转盘 */  .panel-right &#123;    position: relative;    float: left;    width: 50%;    height: 100%;    overflow: hidden;  &#125;  .panel-right .prize-item &#123;    position: absolute;    top: 0;    right: 0;    transform-origin: left center;  &#125;  .panel-right .prize-item:nth-child(1) &#123;    width: 100%;    height: 100%;    background-color: rgb(241, 233, 166);  &#125;  .panel-right .prize-item:nth-child(2) &#123;    width: 100%;    height: 100%;    background-color: rgb(234, 148, 211);    transform: rotate(-45deg);  &#125;  .panel-right .prize-item:nth-child(3) &#123;    width: 100%;    height: 100%;    background-color: rgb(232, 119, 88);    transform: rotate(-90deg);  &#125;  .panel-right .prize-item:nth-child(4) &#123;    width: 100%;    height: 100%;    background-color: #fff;    transform: rotate(-135deg);  &#125;  .panel-right .prize-item span &#123;    position: absolute;    bottom: 20px;    left: 8px;    transform: rotate(155deg);    user-select: none;  &#125;  /* 抽奖按钮 */  .luck-draw .luck-button &#123;    position: absolute;    top: 50%;    left: 50%;    transform: translate(-50%, -50%);    width: 50px;    height: 50px;    color: #fff;    line-height: 50px;    border-radius: 50%;    text-align: center;    background-color: tomato;    user-select: none;    cursor: pointer;  &#125;  .luck-button:after &#123;    content: &quot;&quot;;    position: absolute;    top: -18px;    left: 50%;    transform: translateX(-50%);    display: block;    border: 8px solid transparent;    border-bottom: 15px solid tomato;  &#125;&gt;&lt;/style&gt;&gt;&lt;/head&gt;&gt;&lt;body&gt;&gt; &lt;div class=&quot;luck-draw&quot;&gt;&gt;   &lt;div class=&quot;luck-panel&quot;&gt;&gt;     &lt;div class=&quot;panel-left&quot;&gt;&gt;       &lt;div class=&quot;prize-item&quot;&gt;&lt;span&gt;&lt;/span&gt;&lt;/div&gt;&gt;       &lt;div class=&quot;prize-item&quot;&gt;&lt;span&gt;&lt;/span&gt;&lt;/div&gt;&gt;       &lt;div class=&quot;prize-item&quot;&gt;&lt;span&gt;&lt;/span&gt;&lt;/div&gt;&gt;       &lt;div class=&quot;prize-item&quot;&gt;&lt;span&gt;&lt;/span&gt;&lt;/div&gt;&gt;     &lt;/div&gt;&gt;     &lt;div class=&quot;panel-right&quot;&gt;&gt;       &lt;div class=&quot;prize-item&quot;&gt;&lt;span&gt;&lt;/span&gt;&lt;/div&gt;&gt;       &lt;div class=&quot;prize-item&quot;&gt;&lt;span&gt;&lt;/span&gt;&lt;/div&gt;&gt;       &lt;div class=&quot;prize-item&quot;&gt;&lt;span&gt;&lt;/span&gt;&lt;/div&gt;&gt;       &lt;div class=&quot;prize-item&quot;&gt;&lt;span&gt;&lt;/span&gt;&lt;/div&gt;&gt;     &lt;/div&gt;&gt;   &lt;/div&gt;&gt;   &lt;div class=&quot;luck-button&quot;&gt;抽奖&lt;/div&gt;&gt; &lt;/div&gt;</code></pre><ol start="2"><li>JavaScript 实现思路</li></ol><ul><li>第一步<blockquote><ul><li>动态添加抽奖礼品数据到页面，抽奖礼品保存在以下数组中</li></ul></blockquote></li></ul><pre><code>var prizes = [  &quot;手机一部&quot;,  &quot;电饭煲一台&quot;,  &quot;保温杯一个&quot;,  &quot;免单50元&quot;,  &quot;免单100元&quot;,  &quot;10元红包&quot;,  &quot;10个积分&quot;,  &quot;未中奖喽!&quot;,];</code></pre><ul><li>第二步<blockquote><ul><li>随机抽奖，需要通过随机函数，生成 <code>0-1</code> 之间的随机数，<code>* 数组长度</code>，通过这个随机数来确定对应的中奖奖品的下标</li></ul></blockquote></li></ul><pre><code>var prizesLength = prizes.length;var _index = (Math.random() * prizesLength) &gt;&gt; 0;</code></pre><ul><li><p>第三步</p><blockquote><ul><li>根据抽中的奖项，来确定转盘旋转的角度，计算公式如下</li><li><code>var deg = _index * 45 + 22.5;</code></li><li>抽奖按钮的指针要正对奖项中间，就必须转<code>22.5deg</code></li><li>每个奖项占45°</li></ul></blockquote></li><li><p>第四步</p><blockquote><ul><li>我们希望每次抽奖，转盘能在现有角度上<strong>再旋转 5 圈</strong>，然后到达指定角度</li></ul></blockquote></li></ul><pre><code>var sum = 0; // 相当于累加器sum += 1800;deg = sum + deg;luckpanel.style.transform = &quot;rotate(&quot; + deg + &quot;deg)&quot;;</code></pre><ul><li>第五步<blockquote><p>控制抽奖概率</p><ul><li>设置权重数组，然后随机生成 0-99 之间的整数，把生成的数插入到权重数组中</li><li>然后将该数组按照升序排序：<code>.sort(function(a,b)&#123;return a-b&#125;)</code></li><li>查询随机数在权重数组中的下标<code>indexOf()</code>，根据对应的下标来决定中的是哪个奖项</li><li>最后把随机从权重数组中删除<code>.splice(_index,1)</code>，不能破坏了权重数组</li><li>删除前面设置的随机函数</li></ul></blockquote></li></ul><pre><code>// 权重数组var weight = [1, 3, 7, 12, 19, 30, 40, 100];// 随机生成 0-99 之间的整数。var random = (Math.random() * 100) &gt;&gt; 0;// 把生成的随机数添加到数组中weight.push(random);// 对数组进行升序排序weight.sort(function (a, b) &#123;  return a - b;&#125;);// 找到随机生成的数，在数组中的下标var _index = weight.indexOf(random);// 删除随机生成的数，不能影到我的权重数组weight.splice(_index, 1);</code></pre><ul><li>第六步<blockquote><ul><li>防止用户频繁点击按扭。在上一次抽奖没有结束前，不能再次抽奖</li><li>声明一个变量<code>lock</code>作为锁</li><li>在动画结束后，利用过渡事件开锁</li></ul></blockquote></li></ul><pre><code>var lock = false; // 开锁 目前没有抽奖// 点击抽奖drawButton.onclick = function () &#123;  if (lock) return;  lock = true; // 关锁 正在抽奖  // ....&#125;;&gt;// 动画结束后 开锁luckpanel.addEventListener(  &quot;transitionend&quot;,  function () &#123;    lock = false;    //   alert(&quot;恭喜你中了&quot; + drawText);  &#125;,  false);</code></pre><ul><li>JS完整代码</li></ul><pre><code>&gt;&lt;script&gt; var prizes = [   &quot;手机一部&quot;,   &quot;电饭煲一台&quot;,   &quot;保温杯一个&quot;,   &quot;免单50元&quot;,   &quot;免单100元&quot;,   &quot;10元红包&quot;,   &quot;10个积分&quot;,   &quot;未中奖哦!&quot;, ]; var prizesLength = prizes.length; //动态添加抽奖礼品数据到页面 var spans = document.querySelectorAll(&quot;.luck-panel .prize-item span&quot;); var spansLength = spans.length; for (var i = 0; i &lt; spansLength; i++) &#123;   spans[i].innerText = prizes[i]; &#125; //点击按钮，随机转动转盘 var luckPanel = document.querySelector(&quot;.luck-panel&quot;); var luckButton = document.querySelector(&quot;.luck-button&quot;); var sum = 0; var lock = false; //false表示未上锁 luckButton.onclick = function () &#123;   if (lock) return; //如果lock=true,就不能进   lock = true;   // 权重数组   var weight = [1, 3, 7, 12, 19, 30, 40, 100];   //生成随机数   // var _index = (Math.random() * prizesLength) &gt;&gt; 0;   var random = (Math.random() * 100) &gt;&gt; 0;   //将随机数插入权重数组   weight.push(random);   //将权重数组按升序排列   weight.sort(function (a, b) &#123;     return a - b;   &#125;);   //获取该随机数的下标   var _index = weight.indexOf(random);   // 删除随机生成的数，不能影到我的权重数组   weight.splice(_index, 1);   sum += 1800;   //获取对应的文字   var prizesText = prizes[_index];   //转动转盘   var deg = sum + _index * 45 + 22.5;   luckPanel.style.transform = &quot;rotate(&quot; + deg + &quot;deg)&quot;;   //开锁   luckPanel.addEventListener(     &quot;transitionend&quot;,     function () &#123;       lock = false;       // alert(prizesText);     &#125;,     false   ); &#125;;&gt;&lt;/script&gt;</code></pre><h4 id="案例：红包雨效果"><a href="#案例：红包雨效果" class="headerlink" title="案例：红包雨效果"></a>案例：红包雨效果</h4><ol><li>CSS布局</li></ol><ul><li><p>实现思路</p><blockquote><ul><li>页面背景设置黑色，同时设置超出部分显示隐藏(为了不出现滚动条)</li><li>创建一个小红包（因为每个红包旋转角度不一样，则红包旋转的角度用 JS 来设置）</li><li>布局红包中奖后的显示效果，包括关闭按扭，红包金额</li><li>黑色半透明遮罩层 (刚开始是隐藏的)</li></ul></blockquote></li><li><p>代码实现</p></li></ul><pre><code>&gt;&lt;style&gt; html, body &#123;   margin: 0;   padding: 0;   width: 100%;   height: 100%; &#125; body &#123;   background-color: #000;   overflow: hidden; &#125; .red-packet &#123;   position: absolute;   /* top: -168px; 用JS控制，用户可指定*/   width: 120px;   height: 168px;   background-image: url(../src/红包雨图片素材/redPacket.png);   background-size: cover;   cursor: pointer; &#125; /* 匀速下落动画 */ .animation-drop &#123;   /* 不同的红包效果不一样，为了方便用JS操作，分开写 */   animation-name: drop; /* 动画名字 */   /*animation-duration: 5s;  动画运动时间 用JS操作，每个红包不一样 */   animation-timing-function: ease; /* 运动的速度 */   animation-fill-mode: forwards; /* 运动结束后的状态 */ &#125; @keyframes drop &#123;   0% &#123;     opacity: 0;   &#125;   50% &#123;     opacity: 1;   &#125;   100% &#123;     opacity: 1;     top: 1000px;   &#125; &#125; .show-prize &#123;   position: fixed;   top: 50%;   left: 50%;   width: 400px;   height: 579px;   background-image: url(../src/红包雨图片素材/redPacket2.png);   background-size: cover;   transform: translate(-50%, -50%);   z-index: 3;   display: none; &#125; /* 中奖金额 */ .show-prize .money &#123;   position: absolute;   bottom: 130px;   left: 50%;   transform: translate(-50%, -50%);   color: #fff;   font-size: 35px;   user-select: none; &#125; /* 关闭按钮 */ .show-prize .close &#123;   position: absolute;   top: 15px;   right: -15px;   width: 30px;   height: 30px;   line-height: 30px;   text-align: center;   background-color: #fff;   border-radius: 50%;   cursor: pointer; &#125;  /* 黑色遮罩层 */  .mask &#123;    position: absolute;    width: 100%;    height: 100%;    background-color: rgba(0, 0, 0, 0.6);    display: none;  &#125;&gt;&lt;/style&gt;&gt;&lt;div id=&quot;J_redPacket&quot;&gt;&gt;   &lt;div class=&quot;red-packet animation-drop&quot;&gt;&lt;/div&gt;&gt;   &lt;div class=&quot;show-prize&quot;&gt;&gt;     &lt;div class=&quot;money&quot;&gt;2.88元&lt;/div&gt;&gt;     &lt;div class=&quot;close&quot;&gt;X&lt;/div&gt;&gt;   &lt;/div&gt;&gt;   &lt;div class=&quot;mask&quot;&gt;&lt;/div&gt;&gt; &lt;/div&gt;</code></pre><ol start="2"><li>JS代码实现思路</li></ol><ul><li>创建一个红包类这个红包类有以下属性和方法<table><thead><tr><th>属性</th><th>说明</th></tr></thead><tbody><tr><td>width</td><td>红包宽 ，如果不传，用默认值 120</td></tr><tr><td>height</td><td>红包高，如果不传，用默认值 168</td></tr><tr><td>x</td><td>水平方向坐标 （随机生成） （最大值不能大于浏览器宽 - 元素宽）</td></tr><tr><td>y</td><td>垂直方向坐标 (随机生成) （最开始元素在浏览器外面，即 top&#x3D;- 元素自身高）</td></tr><tr><td>money</td><td>红包金额大小（钱）</td></tr><tr><td>rotate</td><td>旋转的角度 （-45deg 到 45deg ）之间</td></tr><tr><td>duration</td><td>运动时间 3-7s 秒之间</td></tr><tr><td>dom</td><td>红包的 dom 结构</td></tr></tbody></table></li></ul><table><thead><tr><th>实例方法</th><th>说明</th></tr></thead><tbody><tr><td>init</td><td>用于在页面初始化一个红包</td></tr><tr><td>drop</td><td>让红包运动起来,从上往下掉落</td></tr></tbody></table><table><thead><tr><th>静态方法</th><th>说明</th></tr></thead><tbody><tr><td>showRedPacket</td><td>显示红包中奖状态</td></tr><tr><td>hideRedPacket</td><td>隐藏红包中奖状态</td></tr><tr><td>sendRedPacket</td><td>用来发放红包</td></tr></tbody></table><ul><li><p>红包类</p><blockquote><ul><li>红包的宽高、坐标、旋转角度、金额都可以由用户传入</li><li>金额、宽、高都不能小于0</li><li>如果没传：<ul><li>X坐标：左右都要空出一段距离，不能让红包落在屏幕以外：<code>[30, 浏览器的宽度 - 红包的宽度];</code></li><li>Y坐标：默认值为 <code>-元素高度</code></li><li>旋转角度：随机生成 <code>[-45 ,45] </code>之间整数</li><li>运动时间，随机生成 <code>[3，7]</code>之间随机整数</li></ul></li><li>随机生成<code>[a,b]</code>之间的整数<ul><li><code>Math.random() * (b + 1 - a) + a;</code></li></ul></li></ul></blockquote></li><li><p>给红包类添加<code>init</code>方法</p><blockquote><ul><li>将创建好的红包对象，添加到body里，在页面中呈现出来</li><li>先给构造函数添加<code>init</code>方法，要加到它的<code>prototype</code>里，只要调用这个方法，就能将新创建的对象添加到页面</li><li>创建<code>div</code>元素，这个元素就是<code>new</code>出来的新对象的<code>dom</code></li><li>将新对象的宽、高、金额、坐标赋给<code>div</code></li><li>给<code>div</code>添加样式：把之前定义好的CSS样式加上去<code>.className=&quot;&quot;</code></li><li>将<code>div</code>上树，添加到页面中<blockquote><p><code>this</code>是构造函数创建的对象，<code>this.dom</code>是根据对象的属性创建出来的节点元素</p></blockquote></li></ul></blockquote></li><li><p>给红包类添加<code>drop</code>方法</p><blockquote><ul><li>调用<code>drop</code>方法，红包就可以运动</li><li>先给构造函数添加<code>init</code>方法，要加到它的<code>prototype</code>里，只要调用这个方法，就能让新创建的dom元素运动起来</li><li>给<code>dom</code>加上”animation-drop”动画</li><li>添加运动时间</li><li>同时运动结束后，会将自己的 dom 元素从页面删除<ul><li>运动结束，也就是动画结束，给dom添加<strong>动画事件</strong></li><li>然后用<code>父节点.removedChild(子节点)</code>删除元素</li></ul></li></ul></blockquote></li><li><p>在页面中创建 100 个 0-5 之间的随机数，作为红包的金额</p><blockquote><ul><li>把所生成的100个随机数塞到数组里</li><li><code>var random = Number((Math.random() * 5).toFixed(2));</code></li><li><code>.toFixed(2)</code>表示保留后两位小数</li></ul></blockquote></li><li><p>给红包类定义一个静态方法，用来实现发红包效果</p><blockquote><ul><li>传入一个包含红包金额的数组</li><li>设置一个定时器，每过<code>100ms</code>就<code>new</code>一个对象，并调用<code>drop</code>运动；这个过程也就是发出红包</li><li>用<code>.pop()</code>把红包金额传入，既能传入金额，也可以马上删除该金额</li><li>当数组的长度为0时，红包就发完了，此时消除定时器</li></ul></blockquote></li><li><p>给红包类定义两个静态方法，用来显示和隐藏打开红包的效果</p><blockquote><ul><li>打开红包效果要把<strong>new出来的实例</strong>传进去，因为只有实例身上才有<code>.money</code>这个属性</li><li>显示和隐藏就是将改变遮罩层和红包的<code>display</code></li></ul></blockquote></li><li><p>添加事件委托，把红包的点击事件委托给他的父元素来操作</p><blockquote><ul><li>当红包被点击后，就调用显示红包的静态方法</li><li>要注意！显示红包的静态方法需要传入<strong>所点击的实例</strong>，所以，在初始化时，把<code>this</code>保存在<code>dom</code>身上</li><li>给父元素添加委托事件后，可以拿到被点击的子元素，也就是<code>dom</code>，是不能直接拿到实例对象的</li></ul></blockquote></li><li><p>给关闭按钮添加点击事件</p><blockquote><ul><li>当关闭按钮被点击后，调用隐藏红包的静态效果</li></ul></blockquote></li><li><p>注意：如果不想让事件委托放在全局里</p><blockquote><ul><li>可以放在红包类里面</li><li><strong>但是</strong>，放在红包类里面，之后每次new一个实例，都会执行一次</li><li>然而我们只需要给父元素和关闭按钮添加一次委托时间</li><li>因此，我们给红包类添加静态方法</li></ul></blockquote></li><li><p>为了使代码不发生冲突，把所有代码放入一个立即执行函数中</p></li></ul><pre><code>&gt;&lt;script&gt;(function () &#123; var redPacketParent = document.getElementById(&quot;J_redPacket&quot;); var domShowPrize = redPacketParent.querySelector(&quot;.show-prize&quot;); var domMoney = redPacketParent.querySelector(&quot;.money&quot;); var domClose = redPacketParent.querySelector(&quot;.close&quot;);&gt; /**&gt;  * RedPacket 红包类&gt;  * width 红包宽&gt;  * height 红包高&gt;  * @param x 红包x坐标&gt;  * @param y 红包 y 坐标&gt;  * @param money 红包金额&gt;  */ function RedPacket(money = 0, x, y, rotate, width = 120, height = 168) &#123;   // 构造函数的this指的是调用函数new创建出来的新对象   //金额、宽、高都不能小于0   this.money = money &lt;= 0 ? 0 : money;   this.width = width &lt;= 0 ? 0 : width;   this.height = height &lt;= 0 ? 0 : height;&gt;   //立即执行函数的this指向的是window，所以需要把外面的this传进去   this.x = (function (that) &#123;     if (x === 0) return 0; //如果传进来的x为0，则返回0     if (x) return x; //只有传进来的x不等于false(undefined等)，就返回x     //x默认值[30, 浏览器的宽度 - 红包的宽度];     var MaxLeft = document.documentElement.clientWidth - that.width;     return (Math.random() * (MaxLeft - 30 + 1) + 30) &gt;&gt; 0;   &#125;)(this);&gt;   //处理y：默认值为 -height   this.y = (function (that) &#123;     if (y === 0) return 0; //如果传进来的x为0，则返回0     if (y) return y; //只有传进来的x不等于false(undefined等)，就返回x     return -that.height;   &#125;)(this);   //处理旋转角度：随机生成 `[-45 ,45] `之间整数   this.rotate = (function (that) &#123;     if (rotate === 0) return 0;     if (rotate) return rotate;     return (Math.random() * (90 + 1) - 45) &gt;&gt; 0;   &#125;)(this);&gt;   //处理运动时间：随机生成 `[3，7]`之间随机整数   this.duration = (Math.random() * (4 + 1) + 3) &gt;&gt; 0;   this.init(); //初始化   if (!RedPacket.flag) &#123;     //没有加上委托事件才能进来     RedPacket.flag = true;     //事件委托     redPacketParent.onclick = function (e) &#123;       var target = e.target;       var bool = target.classList.contains(&quot;red-packet&quot;);       //如果点的不是红包，就返回       if (!bool) return;       RedPacket.showRedPacket(target.that);     &#125;;     domClose.onclick = function () &#123;       RedPacket.closeRedPacket();     &#125;;   &#125; &#125; RedPacket.flag = false; //false表示没有添加委托事件&gt; //初始化红包，创建元素节点 RedPacket.prototype.init = function () &#123;   //这里的this是指调用init方法的新对象   this.dom = document.createElement(&quot;div&quot;);   this.dom.className = &quot;red-packet&quot;;   this.dom.style.width = this.width + &quot;px&quot;;   this.dom.style.height = this.height + &quot;px&quot;;   this.dom.style.left = this.x + &quot;px&quot;;   this.dom.style.top = this.y + &quot;px&quot;;   this.dom.style.transform = &quot;rotate(&quot; + this.rotate + &quot;deg)&quot;;   //把this保存他对应dom的that属性上，供后面使用   this.dom.that = this;   this.dom.parent = redPacketParent; // 可保存，可不保存，看后续需求   //上树   this.dom.parent.appendChild(this.dom); &#125;;&gt; //让红包动起来 RedPacket.prototype.drop = function () &#123;   this.dom.classList.add(&quot;animation-drop&quot;);   this.dom.style.animationDuration = this.duration + &quot;s&quot;;   this.dom.addEventListener(     &quot;animationend&quot;,     function () &#123;       //这里的this指的是外面的this.dom       this.parentNode.removeChild(this);     &#125;,     false   ); &#125;;&gt; //定义一个静态方法，实现发红包效果 RedPacket.sendRedPacket = function (date) &#123;   //如果传入的不是数组   if (!Array.isArray(date))     throw new Error(&quot;date不是一个数组,请输入一个数组&quot;);   var timer = setInterval(function () &#123;     var redPacket = new RedPacket(moneyArr.pop());     redPacket.drop();     if (moneyArr.length === 0) &#123;       clearInterval(timer);     &#125;   &#125;, 100); &#125;;&gt; //定义两个静态方法，显示和隐藏打开红包的效果 RedPacket.showRedPacket = function (that) &#123;   domShowPrize.style.display = &quot;block&quot;;   domClose.style.display = &quot;block&quot;;   domMoney.innerText = that.money; &#125;; RedPacket.closeRedPacket = function () &#123;   domShowPrize.style.display = &quot;none&quot;;   domClose.style.display = &quot;none&quot;; &#125;;&gt;  // 页面中创建100个 0-5之间的随机数，作为红包的金额  var moneyArr = [];  for (var i = 0; i &lt; 100; i++) &#123;    var random = Number((Math.random() * 5).toFixed(2));    moneyArr.push(random);  &#125;  RedPacket.sendRedPacket(moneyArr); //发放红包&#125;)();&gt;&lt;/script&gt;</code></pre><h3 id="六、JS-实现拖拽动画"><a href="#六、JS-实现拖拽动画" class="headerlink" title="六、JS 实现拖拽动画"></a>六、JS 实现拖拽动画</h3><h4 id="案例-1：拖拽动画"><a href="#案例-1：拖拽动画" class="headerlink" title="案例 1：拖拽动画"></a>案例 1：拖拽动画</h4><blockquote><ul><li>要求拖拽的小方块只能在父元素的区域内移动</li></ul></blockquote><ol><li><p>涉及知识点：</p><blockquote><ul><li>事件对象（鼠标位置、阻止默认行为）</li><li>鼠标事件：<code>onmousedown</code>、<code>onmousemove</code>、<code>onmouseup</code></li><li>鼠标位置：<ul><li><code>clientX</code>：鼠标指针相对于浏览器的水平坐标</li><li><code>clientY</code>：鼠标指针相对于浏览器的垂直坐标</li></ul></li><li><code>e.preventDefault()</code>方法用来阻止事件产生的 “默认动作”</li><li>获取元素尺寸：<ul><li><code>offsetLeft</code>：它返回当前元素(左边框)相对于其 <code>offsetParent</code>元素的左边框<strong>内壁</strong>的距离</li><li><code>offsetTop</code>：它返回当前元素(左边框)相对于其 <code>offsetParent</code>元素的左边框<strong>内壁</strong>的距离</li><li><code>offsetWidth</code>：返回一个元素的布局宽度；标准盒模型下，包括：<code>width</code>、<code>border</code>、<code>padding</code>、滚动条宽</li><li><code>offsetHeight</code>：返回一个元素的布局宽度；标准盒模型下，包括：<code>height</code>、<code>border</code>、<code>padding</code>、滚动条宽</li><li><code>offsetParent</code>：返回离当前元素最近的<strong>定位祖先元素</strong>或最近的 table,td,th,tody 元素</li></ul></li></ul></blockquote></li><li><p>拖拽动画实现原理</p><img src="拖拽动画.png"></li></ol><blockquote><ul><li>在<strong>鼠标按下</strong>时,即<code>onmousedown</code>事件<ul><li>记录鼠标按下时<strong>与浏览器可视区</strong>左边和上边距离，即<code>e.clientX</code>和<code>e.clientY</code></li><li>同时记录<strong>被拖拽元素与定义父元素</strong>左边和上边的距离，即<code>drag.offsetLeft</code>和<code>drag.offsetTop</code></li></ul></li><li>在鼠标<strong>移动</strong>时，即<code>onmousemove</code>事件<ul><li>记录鼠标此时<strong>与浏览器可视区</strong>左边和上边距离，即<code>e.clientX</code>和<code>e.clientY</code></li><li>用<strong>当前的</strong><code>e.clientX</code> - <strong>鼠标按下时</strong><code>e.clientX</code>，得到鼠标在<strong>水平移动的距离</strong>，然后用这个距离<strong>加上</strong>移动前元素的<code>offsetLeft</code>，就得到了此时被拖拽元素的 <code>left</code>值。同得理得 <code>top</code> 值</li></ul></li><li>还要添加<code>onmouseup</code>事件，在鼠标抬起时，要<strong>解绑</strong> <code>onmousemove</code>和<code>onmouseup</code>事件<blockquote><p>以上步骤实现了元素可以自由的被拖拽，但是并不能控制元素只能在定位父元素容器中移动</p></blockquote></li></ul></blockquote><ol><li>优化</li></ol><ul><li><p>控制被拖拽元素移动时<strong>不能超出父容器</strong>，</p><blockquote><ul><li>我们只需要控制被拖拽元素的 <code>left</code> 和 <code>top</code> 值的大小</li><li>如果 <code>left &lt; 0</code>，表示超出了父容器左边界，此时设置 <code>left=0</code>，强行拉回</li><li>如果 <code>left &gt; 父容器宽 - 元素宽</code> ，表示超出了父容器右边界，此时设置 <code>left = 父容器宽 - 元素</code>宽 ,强行拉回</li><li>如果 <code>top &lt; 0</code>，表示超出了父容器上边界，此时设置 <code>top = 0</code>，强行拉回</li><li>如果 <code>top &gt; 父容器高 - 元素高</code> ，表示超出了父容器下边界，此时设置 <code>top = 父容器宽 - 元素宽</code> ,强行拉回<blockquote><p>以上步骤，实现了控制元素只能在父容器中移动</p></blockquote></li></ul></blockquote></li><li><p>兼容性处理：如果被拖拽的元素是一个图片，或元素中有文字，被拖拽时就会出现卡顿</p><blockquote><ul><li>处理办法，就是禁止掉鼠标按下时,图片和被选中的文字默认的拖拽行为。</li></ul></blockquote></li></ul><blockquote><blockquote><p>注意：</p></blockquote><ul><li>被拖拽的元素一定是定位元素</li><li>如果定位父元素是<code>body</code>，那么要给<code>body</code>设置高度</li><li><code>onmousedown</code>事件处理函数绑定的是拖拽的元素；但里面的<code>onmousemove</code>和<code>onmouseup</code>绑定的是<code>document</code></li></ul></blockquote><ul><li>完整代码</li></ul><pre><code>&gt;&lt;style&gt;  html,  body &#123;    margin: 0;    padding: 0;  &#125;  .container &#123;    position: relative;    width: 500px;    height: 500px;    background-color: #ddd;    border: 10px solid #000;    margin: 50px;  &#125;  .drag &#123;    position: absolute;    left: 100px;    top: 100px;    width: 50px;    height: 50px;    background-color: tomato;    cursor: move;    user-select: none;  &#125;&gt;&lt;/style&gt;&gt;&lt;div class=&quot;container&quot;&gt;&gt;  &lt;div class=&quot;drag&quot;&gt;我是一段文字&lt;/div&gt;&gt;&lt;/div&gt;&gt;&lt;script&gt; var container = document.querySelector(&quot;.container&quot;); var drag = document.querySelector(&quot;.drag&quot;);&gt; drag.onmousedown = function (e) &#123;   e.preventDefault(); //取消事件的默认行为   //获取鼠标按下时，与浏览器左边的距离   var beforeClientX = e.clientX;   var beforeClientY = e.clientY;   //获取初始位置的offsetleft和offsetTop   var beforeLeft = drag.offsetLeft;   var beforeTop = drag.offsetTop;&gt; //获取元素的宽高 var dragWidth = this.offsetWidth; var dragHeight = this.offsetHeight;&gt; //获取定位父容器的宽高 var parentWidth = this.offsetParent.clientWidth; var parentHeight = this.offsetParent.clientHeight;&gt; //计算元素能移动的最大范围 var maxLeft = parentWidth - dragWidth; var maxTop = parentHeight - dragHeight;&gt; //当鼠标按下后移动时 document.onmousemove = function (e) &#123;  //获取鼠标移动后 与浏览器的距离  var afterClientX = e.clientX;  var afterClientY = e.clientY;&gt;  //获取移动的距离  var distanceX = afterClientX - beforeClientX;  var distanceY = afterClientY - beforeClientY;&gt;  //获取移动后的left、top值  var _left = distanceX + beforeLeft;  var _top = distanceY + beforeTop;&gt;  //限制元素移动的范围  _left = _left &lt; 0 ? 0 : _left;  _left = _left &gt; maxLeft ? maxLeft : _left;  _top = _top &lt; 0 ? 0 : _top;  _top = _top &gt; maxTop ? maxTop : _top;&gt;  //改变drag的位置  drag.style.left = _left + &quot;px&quot;;  drag.style.top = _top + &quot;px&quot;; &#125;;  //鼠标松开时，移除事件监听 document.onmouseup = function () &#123;   document.onmousemove = null;   document.onmouseup = null;  &#125;;&#125;;&gt;&lt;/script&gt;</code></pre><ol start="4"><li>封装——方法1<blockquote><ul><li>功能：需要拖拽那个元素，那个元素就调用 drag 方法<ul><li>打点调用，就是在原型上添加方法</li><li>所有元素都是<code>HTMLElement</code>这个类构造出来的，所以把方法写在它的原型上</li></ul></li><li><code>drag</code>方法中有两个参数 <code>dragmove</code> 和 <code>dragend</code>，分别为两个<strong>回调函数</strong></li><li><code>dragmove</code>：<strong>拖拽过程中</strong>需要处理的事情写在 <code>dragmove</code> 函数</li><li><code>dragend</code>：<strong>拖拽结束后</strong>，需要处理的事情写在 <code>dragend</code> 函数中</li></ul></blockquote></li></ol><blockquote><blockquote><p><strong>注意：</strong></p></blockquote><ul><li>元素调用这个方法时，<code>this</code>指的就是该元素</li><li>但是，在该方法里的<code>mousemove</code>事件处理函数，绑定的是document，因此它的<code>this</code>是<code>document</code></li><li><code>mousemove</code>事件处理函数，要调整元素的位置,所以要把它的<code>this</code>替换为拖拽的元素</li><li>因此在事件处理函数外面用 <code>var that = this</code> 保存被拖拽元素，然后传进去。</li><li>要在方法代码后面调用</li></ul></blockquote><pre><code>&gt;/**&gt; *drag 拖拽方法&gt; * @param dragmove：拖拽过程中需要处理的事情写在dragmove函数&gt; * @param dragend：拖拽结束后，需要处理的事情写在dragend函数中&gt; */HTMLElement.prototype.drag = function (dragmove, dragend) &#123;  // 当鼠标在元素身上按下去时  this.onmousedown = function (e) &#123;    var e = e || window.event;    // 取消事件的默认行为    e.preventDefault();    // 鼠标按下时，与浏览器左边的距离和上面的距离    var _clientX = e.clientX;    var _clientY = e.clientY;&gt;    // 获鼠标按下时，元素与定位父元素左边和上边的距离    var _offsetTop = this.offsetTop;    var _offsetLeft = this.offsetLeft;&gt;    // 获取父容器的宽,用来计算元素最大left    var dragWidth = this.offsetWidth;    var dragHeight = this.offsetHeight;&gt;    // 获取元素的定位父容器的宽    var parentWidth = this.offsetParent.clientWidth;    var parentHeight = this.offsetParent.clientHeight;&gt;    // 计算元素能移动的最大left值和最大top值    var maxLeft = parentWidth - dragWidth;    var maxTop = parentHeight - dragHeight;    var that = this;    // 当鼠标移动时    document.onmousemove = throttle(fn);//节流函数    function fn(e) &#123;      // 鼠标移动时，与浏览器可视区左边的距离      var _moveClientX = e.clientX;      var _moveClientY = e.clientY;&gt;      // 计算鼠标移动的距离      var _x = _moveClientX - _clientX;      var _y = _moveClientY - _clientY;&gt;      // 元素的left和top值      var left = _x + _offsetLeft;      var top = _y + _offsetTop;&gt;      // 限定left只能在 0-maxLeft之间      left = left &lt; 0 ? 0 : left;      left = left &gt; maxLeft ? maxLeft : left;&gt;      top = top &lt; 0 ? 0 : top;      top = top &gt; maxTop ? maxTop : top;&gt;      // 计算元素当前的位置      that.style.left = left + &quot;px&quot;;      that.style.top = top + &quot;px&quot;;&gt;      // 移动过程中要处理的事情，调用以下回调函数      dragmove instanceof Function ? dragmove() : dragmove;    &#125;;&gt;    // 当鼠标弹起来时，要对事件解绑    document.onmouseup = function () &#123;      document.onmousemove = null;      // 拖拽动画结束后，调用以下回调函数      dragend instanceof Function ? dragend() : dragend;      document.onmouseup = null;    &#125;;  &#125;;&#125;;</code></pre><ul><li>使用：</li></ul><pre><code>&gt;&lt;style&gt;  body,  html &#123;    margin: 0;    padding: 0;    height: 100%;  &#125;  .box &#123;    position: absolute;    width: 100px;    height: 100px;    background-color: khaki;    cursor: move;  &#125;&gt;&lt;/style&gt;&gt;&gt;&lt;div class=&quot;box&quot;&gt;1111&lt;/div&gt;&gt;&lt;script&gt;  var box = document.querySelector(&quot;.box&quot;);  box.drag(    function () &#123;      console.log(&quot;我在动&quot;);    &#125;,    function () &#123;      console.log(&quot;我运动完了&quot;);    &#125;  );&gt;&lt;/script&gt;&gt;&lt;script src=&quot;./throttle2.js&quot;&gt;&lt;/script&gt;</code></pre><ol start="5"><li>封装 drag 方法2<blockquote><ul><li>功能：被按下的元素和被拖拽的元素<strong>不是同一个元素</strong>，当在 A 元素上按下时，可拖拖拽 B 元素</li><li>给<code>HTMLElement.prototype</code>添加方法，打点调用</li><li><code>drag</code> 方法中有 3 个参数 <code>dragElement</code>,<code>dragmove</code> 和 <code>dragend</code></li><li><code>dragElement</code>：表示要拖拽的元素</li><li><code>dragmove</code>：拖拽过程中需要处理的事情写在 dragmove 函数</li><li><code>dragend</code>：拖拽结束后，需要处理的事情写在 dragend 函数中</li><li>注意：AB元素都要为定位元素</li></ul></blockquote></li></ol><pre><code>&gt;/**&gt; * 调用drag方法的元素，为鼠标按下的元素&gt; * @param dragElement 为被拖拽的元素&gt; * @param dragmove：拖拽过程中需要处理的事情写在dragmove函数&gt; * @param dragend：拖拽结束后，需要处理的事情写在dragend函数&gt; */ HTMLElement.prototype.drag = function (dragElement, dragmove, dragend) &#123;   // 当鼠标在元素身上按下去时   this.onmousedown = function (e) &#123;     e.preventDefault(); //取消事件的默认行为     //获取鼠标按下时，与浏览器左边的距离     var beforeClientX = e.clientX;     var beforeClientY = e.clientY;     //获取初始位置的offsetleft和offsetTop     var beforeLeft = dragElement.offsetLeft;     var beforeTop = dragElement.offsetTop;&gt;     //获取元素的宽高     var dragWidth = dragElement.offsetWidth;     var dragHeight = dragElement.offsetHeight;&gt;     //获取定位父容器的宽高     var parentWidth = dragElement.offsetParent.clientWidth;     var parentHeight = dragElement.offsetParent.clientHeight;&gt;     //计算元素能移动的最大范围     var maxLeft = parentWidth - dragWidth;     var maxTop = parentHeight - dragHeight;&gt;     //当鼠标按下后移动时     //给onmousemove做节流     document.onmousemove = throttle(fn);     function fn(e) &#123;       //获取鼠标移动后 与浏览器的距离       var afterClientX = e.clientX;       var afterClientY = e.clientY;&gt;     //获取移动的距离     var distanceX = afterClientX - beforeClientX;     var distanceY = afterClientY - beforeClientY;&gt;     //获取移动后的left、top值     var _left = distanceX + beforeLeft;     var _top = distanceY + beforeTop;&gt;     //限制元素移动的范围     _left = _left &lt; 0 ? 0 : _left;     _left = _left &gt; maxLeft ? maxLeft : _left;&gt;     _top = _top &lt; 0 ? 0 : _top;     _top = _top &gt; maxTop ? maxTop : _top;&gt;     //改变drag的位置     dragElement.style.left = _left + &quot;px&quot;;     dragElement.style.top = _top + &quot;px&quot;;&gt;     dragmove instanceof Function ? dragmove() : dragmove;     &#125;     document.onmouseup = function () &#123;            document.onmousemove = null;&gt;     dragend instanceof Function ? dragend() : dragend;     document.onmouseup = null;   &#125;;  &#125;;&#125;;</code></pre><ul><li>使用</li></ul><pre><code>&gt;&lt;style&gt;  html,  body &#123;    margin: 0;    padding: 0;  &#125;  .container &#123;    position: relative;    width: 500px;    height: 500px;    background-color: #ddd;    border: 10px solid #000;    margin: 50px;  &#125;  .drag &#123;    position: absolute;    left: 100px;    top: 100px;    width: 100px;    height: 100px;    background-color: tomato;    cursor: move;    user-select: none;  &#125;  .drag .title &#123;    width: 100%;    height: 30px;    background-color: khaki;  &#125;&gt;&lt;/style&gt;&gt;&gt;&lt;div class=&quot;container&quot;&gt;&gt;  &lt;div class=&quot;drag&quot;&gt;&gt;    &lt;div class=&quot;title&quot;&gt;登录&lt;/div&gt;&gt;    我是一段文字&gt;  &lt;/div&gt;&gt;&lt;/div&gt;&gt;&lt;script&gt;  var container = document.querySelector(&quot;.container&quot;);  var drag = document.querySelector(&quot;.drag&quot;);  var title = document.querySelector(&quot;.title&quot;);  title.drag(    drag,    function () &#123;      console.log(&quot;我在动哦&quot;);    &#125;,    function () &#123;      console.log(&quot;我停下来了&quot;);    &#125;  );&gt;&lt;/script&gt;&gt;&lt;script src=&quot;./throttle2.js&quot;&gt;&lt;/script&gt;</code></pre><blockquote><blockquote><p>优化：</p></blockquote><ul><li>还可以给<code>onmousemove</code>做节流，这两个封装方法都可以</li><li>可以把事件监听的方式<code>on</code>换成<code>addEventListener</code></li></ul></blockquote><h4 id="案例-2：拖拽交换两元素位置"><a href="#案例-2：拖拽交换两元素位置" class="headerlink" title="案例 2：拖拽交换两元素位置"></a>案例 2：拖拽交换两元素位置</h4><blockquote><p>涉及知识点</p><ul><li>利用 JS 实现布局转换</li><li><code>onmousedown</code>、<code>onmousemove</code>、<code>onmouseup</code>事件</li><li>事件对象</li><li>自定义属性的使用</li><li>布局转换：浮动布局转定位</li><li>拖拽动画实现原理、如何检测两个元素<strong>碰撞</strong>，如果找到多个碰撞元素中离自己<strong>最近</strong>的一个</li><li>如何<strong>交换</strong>两个元素的位置</li></ul></blockquote><ol><li>先利用纯CSS来实现两行4列的布局</li></ol><pre><code>&gt;&lt;style&gt; html, body &#123;   margin: 0;   padding: 0;   width: 100%;   height: 100%;   overflow: hidden; &#125; ul, li &#123;   margin: 0;   padding: 0;   list-style: none; &#125; .container &#123;   position: relative; /*li是相对于ul定位的*/   width: 880px;   height: 240px;   margin: 20px; &#125; .container li &#123;   float: left;   width: 200px;   height: 100px;   line-height: 100px;   font-size: 30px;   text-align: center;   margin: 10px;   background-color: skyblue;   user-select: none; &#125;&gt;&lt;/style&gt;&gt;&gt;&lt;ul class=&quot;container&quot;&gt;&gt;  &lt;li&gt;1&lt;/li&gt;&gt;  &lt;li&gt;2&lt;/li&gt;&gt;  &lt;li&gt;3&lt;/li&gt;&gt;  &lt;li&gt;4&lt;/li&gt;&gt;  &lt;li&gt;5&lt;/li&gt;&gt;  &lt;li&gt;6&lt;/li&gt;&gt;  &lt;li&gt;7&lt;/li&gt;&gt;  &lt;li&gt;8&lt;/li&gt;&gt;&lt;/ul&gt;</code></pre><blockquote><blockquote><p>注意</p></blockquote><ul><li><code>body</code>的宽高一定要设置为100%</li><li>父容器<code>container</code>要设置相对定位，因为li的是相对于ul进行绝对定位的;</li></ul></blockquote><ol start="2"><li>布局转换<blockquote><p>元素需要拖动，那肯定要设置为绝对定位元素，我们可以利用 JS 来实现布局转换。同时将每个版块的颜色设置为不同</p></blockquote></li></ol><blockquote><ul><li>通过 JS 获取页面中 li 元素，利用for循环把每个元素相对其定位的父元素left值和top值保存到一个对象中，然后添加进数组</li><li><code>offsetLeft</code>和<code>offsetTop</code>的值是相对于离他最近的定位祖先元素的</li><li>遍历所有 li 元素，把每个元素的都转换为<strong>定位元素</strong>，同时把之前保存到数组中的对应的 left 值和 top 值添加到对应元素身上</li><li>再准备一个 bgColor 数组，用来保存每个 li 元素的背景颜色，同时把每个元素的背景颜色更改为对应颜色</li></ul></blockquote><blockquote><blockquote><p>注意</p></blockquote><ul><li>第一次for循环保存的left值和top值是包含li的<code>margin</code>值的</li><li>因此，我们要在第二次for循环时，把li的<code>margin</code>值设置为<code>0</code></li></ul></blockquote><pre><code>&gt;&lt;script&gt; var oUL = document.querySelector(&quot;.container&quot;); var liList = document.querySelectorAll(&quot;.container li&quot;); var len = liList.length; var coordinate = []; //用来保存li的定位值 //用for循环得到li的left、top值 for (var i = 0; i &lt; len; i++) &#123;   var obj = &#123;&#125;;   obj.left = liList[i].offsetLeft;   obj.top = liList[i].offsetTop;   coordinate.push(obj); &#125; //颜色数组 var bgColor = [   &quot;pink&quot;,   &quot;skyblue&quot;,   &quot;turquoise&quot;,   &quot;khaki&quot;,   &quot;salmon&quot;,   &quot;thistle&quot;,   &quot;orange&quot;,   &quot;red&quot;, ]; //布局转换、更改颜色及其他样式 for (var j = 0; j &lt; len; j++) &#123;   liList[j].style.position = &quot;absolute&quot;;   liList[j].style.left = coordinate[j].left + &quot;px&quot;;   liList[j].style.top = coordinate[j].top + &quot;px&quot;;   liList[j].style.margin = &quot;0px&quot;;   liList[j].style.backgroundColor = bgColor[j];   //把li的left和top值保存在它身上，不用重复获取   liList[j].left = coordinate[j].left;   liList[j].top = coordinate[j].top;   liList[j].style.zIndex = 4; //给所有li设置统一的z-index值 &#125; &gt;&lt;/script&gt;</code></pre><ol start="3"><li>JS 实现：拖拽效果<blockquote><p>利用<strong>事件委托</strong>来处理，所以 li 子元素的 <code>mousedown</code>事件需要处理的事情，全交由父元素来处理</p><ul><li>在<code>li</code>上按下，可以拖拽<code>li</code></li><li>同时在元素没有发生碰撞时，松开鼠标，元素回到原位置<ul><li>在第二个for循环里，把<code>li</code>的<code>left</code>、<code>top</code>值保存在它身上</li></ul></li><li>被按下拖拽的元素，会在所有元素的最上面，所以他的 <code>z-index</code>要最大<ul><li>在第二个for循环里，给<code>li</code>设置统一的<code>z-index</code>值</li></ul></li></ul></blockquote></li></ol><pre><code>oUL.onmousedown = function (e) &#123;  var target = e.target;  var tagName = target.tagName.toLowerCase();  if (tagName !== &quot;li&quot;) return;&gt;  //获取鼠标与浏览器的距离  var _clientX = e.clientX;  var _clientY = e.clientY;  //获取li的offsetLeft  var _left = target.left;  var _top = target.top;&gt;  //当元素运动时  document.onmousemove = function (e) &#123;    var clientX = e.clientX;    var clientY = e.clientY;&gt;  //获取移动距离  var distanceX = clientX - _clientX + _left;  var distanceY = clientY - _clientY + _top;  //修改li的位置  target.style.left = distanceX + &quot;px&quot;;  target.style.top = distanceY + &quot;px&quot;;  target.style.zIndex = 20; //提高层级&#125;;&gt;  //当鼠标松开时，li回到原位,时间解绑  document.onmouseup = function () &#123;    //如果没有和其他元素碰撞，就回到原位    target.style.left = target.left + &quot;px&quot;;    target.style.top = target.top + &quot;px&quot;;    target.style.zIndex = 4;//鼠标松开后，层级恢复    document.onmousemove = null;    document.onmouseup = null;  &#125;;&#125;;</code></pre><ol start="4"><li>JS 实现：碰撞检测，同时找出碰撞元素中离自己最近的元素<blockquote><ul><li>判断当前拖拽的元素与其它兄弟碰上是否碰上<ul><li>写一个for循环&#x2F;forEach将每个元素与当前拖拽的元素比较 </li><li>使用之前写过的函数<code>isBump(obj1, obj2)</code>，撞上了就返回true</li></ul></li><li>如果碰上，就把碰上的元素添加到数组中去</li><li>比较数组中，哪个元素离自己最近<ul><li>使用之前写过的函数<code>findNearest(obj)</code>，返回的是离自己最近的元素</li></ul></li><li>给离自己最近的元素加上外轮廓，并提高他的层级</li></ul></blockquote></li></ol><pre><code>var prevBumpElement = null; // 记录前一个与自己碰撞的元素var nearElement = null; // 当前碰上的元素&gt;document.onmousemove = function (e) &#123;  // 前面代码略  //  .....  // 如何判断两个元素是否碰上  var bumpElement = []; //保存离自己最近的元素  //将其他每个元素与当前元素比较距离  for (var i = 0; i &lt; len; i++) &#123;    if (liList[i] !== target) &#123;      if (isBump(target, liList[i])) &#123;        bumpElement.push(liList[i]);      &#125;    &#125;  &#125;&gt;  //找出数组中离自己最近的元素  nearElement = findNearest(target, bumpElement);  // 如果前一个碰上的元素存在，就把样式消掉  if (prevnearElement) &#123;    prevnearElement.style.outline = &quot;none&quot;;    prevnearElement.style.zIndex = 4; //提高最近元素的层级  &#125;  // 如果有碰上的元素，就把碰上的最近的那个元素添加如下样式  if (nearElement) &#123;    nearElement.style.outline = &quot;10px solid pink&quot;;    nearElement.style.zIndex = 10; //提高最近元素的层级    prevnearElement = nearElement;  &#125;&#125;;</code></pre><ol start="5"><li>JS 实现：在碰上时，松开鼠标，交换两元素位置<blockquote><p>如何判断当前鼠标是在碰撞元素上松开的呢 ？<br>如果<strong>鼠标松开</strong>时，<strong>存在</strong>离自己最近的碰上元素，那就是就是碰上时松开鼠标的</p><ul><li>碰上时，交换两元素位置，同时交换位置时，实现动画效果</li><li>交换位置时，要把碰上元素的<code>outline</code>去掉，同时<code>nearElement = null</code></li></ul></blockquote></li></ol><pre><code> //当鼠标松开时，li回到原位,事件解绑，层级降低 document.onmouseup = function () &#123;   if (nearElement) &#123;     //碰上了就要交换两个元素的位置     //交换left、top值     var left = target.left;     var top = target.top;     target.left = nearElement.left;     target.top = nearElement.top;     nearElement.left = left;     nearElement.top = top;     //交换位置     target.style.left = target.left + &quot;px&quot;;     target.style.top = target.top + &quot;px&quot;;     nearElement.style.left = nearElement.left + &quot;px&quot;;     nearElement.style.top = nearElement.top + &quot;px&quot;;     nearElement.style.outline = &quot;none&quot;;   &#125; else &#123;     //如果没有和其他元素碰撞，就回到原位     target.style.left = target.left + &quot;px&quot;;     target.style.top = target.top + &quot;px&quot;;     target.style.zIndex = 4; //松开后层级恢复   &#125;   document.onmousemove = null;   document.onmouseup = null; &#125;;</code></pre><ol start="6"><li>给交换的两个元素添加动画<blockquote><ul><li>交换位置的时候加上动画</li><li>交换后，清除掉<code>nearElement</code>的值</li><li>动画结束后，去掉动画样式<ul><li>给每个li添加<code>transitionend</code></li></ul></li></ul></blockquote></li></ol><pre><code> .move &#123;    transition: all 0.5s ease;  &#125; &gt;&#123;  //交换位置  target.classList.add(&quot;move&quot;);  nearElement.classList.add(&quot;move&quot;);&gt;  target.style.left = target.left + &quot;px&quot;;  target.style.top = target.top + &quot;px&quot;;  nearElement.style.left = nearElement.left + &quot;px&quot;;  nearElement.style.top = nearElement.top + &quot;px&quot;;  nearElement.style.outline = &quot;none&quot;;  nearElement = null; //清除&#125;&gt;  //给所有li添加transitionend  for (var k = 0; k &lt; len; k++) &#123;    liList[k].addEventListener(      &quot;transitionend&quot;,      function () &#123;        this.classList.remove(&quot;move&quot;);        target.style.zIndex = 4; //交换后后层级恢复      &#125;,      false    );  &#125;</code></pre><h3 id="七、综合应用实践案例"><a href="#七、综合应用实践案例" class="headerlink" title="七、综合应用实践案例"></a>七、综合应用实践案例</h3><h4 id="案例-3：键盘控制元素运动"><a href="#案例-3：键盘控制元素运动" class="headerlink" title="案例 3：键盘控制元素运动"></a>案例 3：键盘控制元素运动</h4><blockquote><p>涉及知识点</p><ul><li>定时器 <code>setInterval()</code></li><li><code>onkeydown</code>、<code>onkeyup</code> 事件</li><li>事件对象：<ul><li><code>e.altkey</code>：表示事件触发时<code>alt</code>键是否按下，返回的是布尔值</li><li><code>key</code>：返回用户按下的物理按键的值。</li></ul></li></ul></blockquote><ul><li>动画执行原理<blockquote><ul><li>页面中有一个元素，当我按键盘上的不同方向键时，他可以<strong>向不同的方向移动</strong></li><li>如果同时按下<code>Alt</code>键和方向键，则会<strong>加速</strong>向某个方向移动</li><li>因为 <code>keydown</code> 有卡顿现象：<strong>第一次</strong>事件处理函数的调用时间与<strong>第二次</strong>的事件处理函数调用的时间间隔相对来说比较长</li><li>所以<code>keydown</code>事件主要用来判断元素的<strong>运动方向</strong>，元素的<strong>运动行为</strong>通过&#x3D;&#x3D;定时器&#x3D;&#x3D;来实现。</li></ul></blockquote></li></ul><blockquote><blockquote><p>注意</p></blockquote><ul><li>按下键盘后，调用定时器使元素运动；按住键盘时会不断调用定时器，因此要上锁，每按下一次，只能调用一次定时器；并在松开键盘后清除定时器、开锁</li><li>加速运动时，我们要使用两个键盘值，一个控制速度，一个控制方向；但定时器只能调用一次</li><li>所以把<code>keyName</code>声明在全局对象里，onkeydown<code>事件调用</code>keyMove&#96;事件时，不传入key值，让定时器去全局对象里找</li></ul></blockquote><ul><li>代码实现</li></ul><pre><code>&gt;&lt;style&gt;  html,  body &#123;    margin: 0;    padding: 0;  &#125;  .box &#123;    position: absolute;    top: 50px;    left: 100px;    width: 100px;    height: 100px;    background-color: pink;  &#125;&gt;&lt;/style&gt;&gt;&gt;&lt;div class=&quot;box&quot;&gt;&lt;/div&gt;&gt;&lt;script&gt;  var box = document.querySelector(&quot;.box&quot;);  var keyName; //因为switch要访问到，必须是全局变量  var speed;  var timer = null;  var lock = false; //锁  // 当键盘按下时，需要做的事情  document.onkeydown = function (e) &#123;    keyName = e.key;    var altKey = e.altKey;    speed = altKey ? 50 : 5;    //每按下一个键，就会不断触发定时器，所以给他上锁    if (!lock) &#123;      //进来后就上锁      lock = true;      keyMove(); //不能传入key值，因为只能调用一次，第二个值传不进去    &#125;  &#125;;// 根据方向，来移动元素function keyMove() &#123;  timer = setInterval(function () &#123;    switch (keyName) &#123;      case &quot;ArrowLeft&quot;:        box.style.left = box.offsetLeft - speed + &quot;px&quot;;        break;      case &quot;ArrowRight&quot;:        box.style.left = box.offsetLeft + speed + &quot;px&quot;;        break;      case &quot;ArrowUp&quot;:        box.style.top = box.offsetTop - speed + &quot;px&quot;;        break;      case &quot;ArrowDown&quot;:        box.style.top = box.offsetTop + speed + &quot;px&quot;;        break;    &#125;  &#125;, 50);&#125;  //键盘抬起后，就开锁,并清理定时器  document.onkeyup = function () &#123;    lock = false;    clearInterval(timer);  &#125;;&gt;&lt;/script&gt;</code></pre><h4 id="案例-4：表单全选和取消"><a href="#案例-4：表单全选和取消" class="headerlink" title="案例 4：表单全选和取消"></a>案例 4：表单全选和取消</h4><blockquote><p>涉及知识点</p><ul><li><code>display:table</code>布局</li><li>自定义属性灵活使用</li><li>事件委拖</li><li>判断元素身上是否包含某个 class 类</li></ul></blockquote><ol><li><code>display:table</code>布局<blockquote><p><code>display: table;</code>系列几乎是和<code>table</code>系的元素相对应的，请看下表：</p></blockquote></li></ol><table><thead><tr><th>属性</th><th>说明</th></tr></thead><tbody><tr><td>table</td><td>（类似 <table>）此元素会作为块级表格来显示，表格前后带有换行符。</td></tr><tr><td>table-row</td><td>（类似 <tr>）此元素会作为一个表格行显示。</td></tr><tr><td>table-cell</td><td>（类似 <td> 和 <th>）此元素会作为一个表格单元格显示。</td></tr><tr><td>inline-table</td><td>（类似 <table>）此元素会作为内联表格来显示，表格前后没有换行符。</td></tr><tr><td>table-row-group</td><td>（类似 <tbody>）此元素会作为一个或多个行的分组来显示。</td></tr><tr><td>table-header-group</td><td>（类似 <thead>）此元素会作为一个或多个行的分组来显示。</td></tr><tr><td>table-footer-group</td><td>（类似 <tfoot>）此元素会作为一个或多个行的分组来显示。</td></tr><tr><td>table-column-group</td><td>（类似 <colgroup>）此元素会作为一个或多个列的分组来显示。</td></tr><tr><td>table-column</td><td>（类似 <col>）此元素会作为一个单元格列显示。</td></tr><tr><td>table-caption</td><td>（类似 <caption>）此元素会作为一个表格标题显示。</td></tr></tbody></table><ol start="2"><li>CSS布局实现</li></ol><pre><code>&gt;&lt;style&gt; .table &#123;   display: table;   width: 500px;   border: 1px solid #666;   border-collapse: collapse; /* 合并单元格边框线 */ &#125; .tr &#123;   display: table-row; &#125; .tr .th, .tr .td &#123;   display: table-cell;   height: 35px;   border: 1px solid #666;   text-align: center;   vertical-align: middle; &#125; .tr .th &#123;   background-color: #ddd;   font-weight: bolder; &#125; .check &#123;   width: 22px;   height: 22px;   outline: 1px solid #333;   margin: 0 auto; &#125; /* 被选中状态 */ .selected &#123;   width: 22px;   height: 22px;   background: url(../src/表单全选和登录验证提示素材/seleted.png) no-repeat;   background-size: cover;   outline: none; &#125;&gt;&lt;/style&gt;&gt;&gt;&lt;div class=&quot;table&quot; id=&quot;J_table&quot;&gt;&gt;  &lt;div class=&quot;tr&quot;&gt;&gt;    &lt;div class=&quot;th&quot;&gt;&lt;div class=&quot;check&quot; id=&quot;J_selected&quot;&gt;&lt;/div&gt;&lt;/div&gt;&gt;    &lt;div class=&quot;th&quot;&gt;序号&lt;/div&gt;&gt;    &lt;div class=&quot;th&quot;&gt;编号&lt;/div&gt;&gt;    &lt;div class=&quot;th&quot;&gt;班级名称&lt;/div&gt;&gt;    &lt;div class=&quot;th&quot;&gt;班主任&lt;/div&gt;&gt;    &lt;div class=&quot;th&quot;&gt;操作&lt;/div&gt;&gt;  &lt;/div&gt;&gt;  &lt;div class=&quot;tr&quot;&gt;&gt;    &lt;div class=&quot;td&quot;&gt;&lt;div class=&quot;check check-item&quot;&gt;&lt;/div&gt;&lt;/div&gt;&gt;    &lt;div class=&quot;td&quot;&gt;001&lt;/div&gt;&gt;    &lt;div class=&quot;td&quot;&gt;202201001&lt;/div&gt;&gt;    &lt;div class=&quot;td&quot;&gt;初一（103班）&lt;/div&gt;&gt;    &lt;div class=&quot;td&quot;&gt;王老师&lt;/div&gt;&gt;    &lt;div class=&quot;td&quot;&gt;&lt;button class=&quot;del&quot;&gt;删除&lt;/button&gt;&lt;/div&gt;&gt;  &lt;/div&gt;&gt;  &lt;div class=&quot;tr&quot;&gt;&gt;    &lt;div class=&quot;td&quot;&gt;&lt;div class=&quot;check check-item&quot;&gt;&lt;/div&gt;&lt;/div&gt;&gt;    &lt;div class=&quot;td&quot;&gt;002&lt;/div&gt;&gt;    &lt;div class=&quot;td&quot;&gt;202201002&lt;/div&gt;&gt;    &lt;div class=&quot;td&quot;&gt;初一（104班）&lt;/div&gt;&gt;    &lt;div class=&quot;td&quot;&gt;贺老师&lt;/div&gt;&gt;    &lt;div class=&quot;td&quot;&gt;&lt;button class=&quot;del&quot;&gt;删除&lt;/button&gt;&lt;/div&gt;&gt;  &lt;/div&gt;&gt;  &lt;div class=&quot;tr&quot;&gt;&gt;    &lt;div class=&quot;td&quot;&gt;&lt;div class=&quot;check check-item&quot;&gt;&lt;/div&gt;&lt;/div&gt;&gt;    &lt;div class=&quot;td&quot;&gt;003&lt;/div&gt;&gt;    &lt;div class=&quot;td&quot;&gt;202201001&lt;/div&gt;&gt;    &lt;div class=&quot;td&quot;&gt;初二（105班）&lt;/div&gt;&gt;    &lt;div class=&quot;td&quot;&gt;雷老师&lt;/div&gt;&gt;    &lt;div class=&quot;td&quot;&gt;&lt;button class=&quot;del&quot;&gt;删除&lt;/button&gt;&lt;/div&gt;&gt;  &lt;/div&gt;&gt;  &lt;div class=&quot;tr&quot;&gt;&gt;    &lt;div class=&quot;td&quot;&gt;&lt;div class=&quot;check check-item&quot;&gt;&lt;/div&gt;&lt;/div&gt;&gt;    &lt;div class=&quot;td&quot;&gt;004&lt;/div&gt;&gt;    &lt;div class=&quot;td&quot;&gt;202201001&lt;/div&gt;&gt;    &lt;div class=&quot;td&quot;&gt;初二（106班）&lt;/div&gt;&gt;    &lt;div class=&quot;td&quot;&gt;张老师&lt;/div&gt;&gt;    &lt;div class=&quot;td&quot;&gt;&lt;button class=&quot;del&quot;&gt;删除&lt;/button&gt;&lt;/div&gt;&gt;  &lt;/div&gt;&gt;&lt;/div&gt;</code></pre><ol start="3"><li>JS实现思路</li></ol><blockquote><p><strong>第一步：处理全选按扭点击后要实现的功能</strong></p><ul><li>点击全选按钮，为所有复选框做相应的全选或取消操作</li><li>通过<code>classList.toggle</code>方法，来实现元素点击时，在选中和未选中状态之间来回切换</li><li>如果<code>classList.toggle</code>方法的返回值为<code>true</code>，表示当前是全选状态，为<code>false</code>表示未全选状态。</li><li>利用for循环给复选框增加或删除样式</li></ul></blockquote><pre><code> var selectAllButton = document.getElementById(&quot;J_selected&quot;); var selectButtons = document.querySelectorAll(&quot;.table .tr .check-item&quot;); var len = selectButtons.length; selectAllButton.onclick = function () &#123;   var bool1 = this.classList.toggle(&quot;selected&quot;);   //如果bool1=true，则所有复选框都要被选中   if (bool1) &#123;     for (var i = 0; i &lt; len; i++) &#123;       selectButtons[i].classList.add(&quot;selected&quot;);     &#125;   &#125; else &#123;     for (var i = 0; i &lt; len; i++) &#123;       selectButtons[i].classList.remove(&quot;selected&quot;);     &#125;   &#125; &#125;;</code></pre><blockquote><p>第二步：利用事件委托，处理每个子元素点击要实现的功能</p><ul><li>同样通过<code>classList.toggle</code>来实现子元素在选中和未选中状态之间切换。</li><li>然后根据<code>toggle</code>方法的返回值，来决定当前全选按扭的状态。</li><li>用for循环来判断是否所有复选框都被选中</li></ul></blockquote><pre><code>var table = document.getElementById(&quot;J_table&quot;);var flag = true; //假设是全选状态//利用事件委托，处理子元素table.onclick = function (e) &#123;  var target = e.target;  var bool2 = target.classList.contains(&quot;check-item&quot;);  if (!bool2) return;  //如果点击的是复选框，就处理以下事情  var bool3 = target.classList.toggle(&quot;selected&quot;);  //如果是true，判断是否所有复选框都被选中  if (bool3) &#123;    for (var j = 0; j &lt; len; j++) &#123;      //判断所有复选框是不是都选中了      flag = selectButtons[j].classList.contains(&quot;selected&quot;);      if (!flag) &#123;        //只要有一个未选中，则全选框无样式，退出循环        selectAllButton.classList.remove(&quot;selected&quot;);        break;      &#125;    &#125;    if (flag) &#123;      //flag=true,表示全选      selectAllButton.classList.add(&quot;selected&quot;);    &#125;  &#125; else &#123;    //只要有一个为false,全选框就不会有样式    selectAllButton.classList.remove(&quot;selected&quot;);  &#125;&#125;;</code></pre><ul><li>完整代码</li></ul><pre><code></code></pre><ul><li>优化<blockquote><ul><li>记录被选中复选框的个数，如果个数与复选框数量相等，则全选框要被选中(用这个方法，替代for循环)</li></ul></blockquote></li></ul><pre><code>&gt;&lt;script&gt;  var table = document.getElementById(&quot;J_table&quot;);  var selectAllButton = document.getElementById(&quot;J_selected&quot;);  var selectButtons = document.querySelectorAll(&quot;.table .tr .check-item&quot;);  var len = selectButtons.length;  selectAllButton.selectedNum = 0; //记录被选中的复选框个数  //处理全选按钮  selectAllButton.onclick = function () &#123;    var bool1 = this.classList.toggle(&quot;selected&quot;);    //如果bool1=true，则所有复选框都要被选中    if (bool1) &#123;      for (var i = 0; i &lt; len; i++) &#123;        selectButtons[i].classList.add(&quot;selected&quot;);        this.selectedNum = len; // 保存当前选中的子元素个数      &#125;    &#125; else &#123;      for (var i = 0; i &lt; len; i++) &#123;        selectButtons[i].classList.remove(&quot;selected&quot;);        this.selectedNum = 0; // 保存当前选中的子元素个数      &#125;    &#125;  &#125;;&gt;  //利用事件委托，处理子元素  table.onclick = function (e) &#123;    var target = e.target;    var bool2 = target.classList.contains(&quot;check-item&quot;);    if (!bool2) return;    //如果点击的是复选框，就处理以下事情    var bool3 = target.classList.toggle(&quot;selected&quot;);    if (bool3) &#123;      //如果复选框被选中，个数+1      selectAllButton.selectedNum++;      //如果全部选中，全选框加样式      if (selectAllButton.selectedNum === len) &#123;        selectAllButton.classList.add(&quot;selected&quot;);      &#125;    &#125; else &#123;      //只要有一个复选框没被选中，全选框就无样式      selectAllButton.selectedNum--;      selectAllButton.classList.remove(&quot;selected&quot;);    &#125;  &#125;;&gt;&lt;/script&gt;</code></pre><h4 id="案例-5：表单验证提示效果"><a href="#案例-5：表单验证提示效果" class="headerlink" title="案例 5：表单验证提示效果"></a>案例 5：表单验证提示效果</h4><ol><li>CSS布局</li></ol><pre><code>&gt;&lt;style&gt; html, body &#123;   padding: 0;   margin: 0;   height: 100%; &#125; body &#123;   display: flex;   align-items: center;   justify-content: center;   background-color: #000; &#125; .login &#123;   width: 300px;   padding: 40px;   background-color: #fff;   border-radius: 10px; &#125; .login .login-row &#123;   position: relative;   margin: 20px 0; &#125; /* 去掉input的外轮廓效果 */ input &#123;   outline: none; &#125; .login-row input, .login-row button &#123;   box-sizing: border-box;   width: 100%;   height: 50px;   background-color: #f9f9f9;   border: none;   padding-left: 20px; &#125; button.submit &#123;   font-size: 20px;   background-color: tomato;   color: #fff; &#125; /* JS 操作获取焦点后的样式 */ .login-row input.focus1 &#123;   background-color: #fcf2f3; &#125; .login-row input.focus2 &#123;   border: 1px solid tomato; &#125;       /* 输入框文字 */ .login-row .lable-tip &#123;   position: absolute;   top: 0;   left: 20px;   line-height: 50px;   color: rgba(0, 0, 0, 0.4); &#125; /* 动态添加的缩放效果 */ .login-row .lable-min &#123;   line-height: 30px;   font-size: 13px; &#125; /* 输入提示 */ .login-row .input-tip &#123;   color: tomato;   font-size: 14px; &#125; /* 聚焦后提示变化 */ .hide &#123;   display: none; &#125; /* 密码隐藏与显示 */ .icon-eye &#123;   position: absolute;   top: 15px;   right: 20px;   width: 30px;   height: 20px;   background: url(../src/表单全选和登录验证提示素材/eye-close.png)     no-repeat center;   cursor: pointer; &#125; .login-row .icon-show &#123;   background-image: url(../src/表单全选和登录验证提示素材/eye.png); &#125;&gt;&lt;/style&gt;&gt;&gt;&lt;div class=&quot;login&quot; id=&quot;J_login&quot;&gt;&gt;  &lt;div class=&quot;login-row&quot;&gt;&gt;    &lt;input type=&quot;text&quot; class=&quot;user-name&quot; id=&quot;user-name&quot; /&gt;&gt;    &lt;label for=&quot;user-name&quot; class=&quot;lable-tip&quot;&gt;邮箱/手机号码&lt;/label&gt;&gt;    &lt;div class=&quot;input-tip&quot;&gt;请输入账户名&lt;/div&gt;&gt;  &lt;/div&gt;&gt;  &lt;div class=&quot;login-row&quot;&gt;&gt;    &lt;input type=&quot;password&quot; class=&quot;user-pwd&quot; id=&quot;user-pwd&quot; /&gt;&gt;    &lt;label for=&quot;user-pwd&quot; class=&quot;lable-tip&quot;&gt;密码&lt;/label&gt;&gt;    &lt;div class=&quot;input-tip&quot;&gt;请输入登录密码&lt;/div&gt;&gt;    &lt;div class=&quot;icon-eye&quot;&gt;&lt;/div&gt;&gt;  &lt;/div&gt;&gt;  &lt;div class=&quot;login-row&quot;&gt;&gt;    &lt;button type=&quot;submit&quot; class=&quot;submit&quot;&gt;登录&lt;/button&gt;&gt;  &lt;/div&gt;&gt;&lt;/div&gt;</code></pre><ol start="2"><li>JS 实现思路<blockquote><p>第一步：处理文本框获取到焦点&#x2F;失去焦点时要实现的功能<br><strong>获取焦点时</strong></p><ul><li>不管输入框中有无内容，文字是缩小的，有红色边框线</li><li>如果有内容，无错误提示(需隐藏),无粉色背景(需去掉)</li><li>如果没有内容，有输入提示(需加上)，有粉色背景(需加上)</li></ul></blockquote></li></ol><blockquote><p><strong>失去焦点时</strong></p><ul><li>不管输入框中有无内容，无红色边框线(需去掉)</li><li>如果有内容，缩小文字(获取焦点时已加)，无输入提示(获取焦点时已设置)，无粉色背景(获取焦点时已去掉)</li><li>如果没有内容，文字正常大小(需恢复)，有粉色背景(获取焦点时已加)，有提示文字(获取焦点时已加)</li></ul></blockquote><blockquote><blockquote><p>在输入时，有可能输入内容后又删除了，但<code>onfocus</code>只会在获取焦点时触发一次</p></blockquote><ul><li>所以要开一个计时器来<strong>定期检查输入内容是否为空</strong>，这里采用 <code>requestAnimationFrame</code> 来处理。</li><li>当失去焦点时，就不再调用 <code>requestAnimationFrame</code>，所以我们可以定义一把锁，当获取焦点时开锁，可以一直重复调用 <code>requestAnimationFrame</code>，失去焦点时关锁，不再调用<blockquote><p>注意回调函数<code>requestAnimationFrame(fn)</code>，是在下次刷新前执行；获取焦点的时候，不断调用，失去焦点后，在下一次刷新前，还会调用一次</p></blockquote></li></ul></blockquote><blockquote><ul><li>获取输入框中的值：<code>.value</code></li><li>处理输入框中的空格：<code>.trim()</code></li></ul></blockquote><blockquote><p>第二步：处理点击密码框中的小眼睛，闭上与打开要实现的功能</p><ul><li>如果小眼睛关闭状态，点击后打开，然后设置密码输入框<code>type = &#39;text&#39;</code></li><li>如果小眼睛打开状态，点击后关闭，然后设置密码输入框<code>type = &#39;password&#39;</code></li></ul></blockquote><pre><code>&gt;&lt;script&gt; var inputs = document.querySelectorAll(&quot;#J_login .login-row input&quot;); var eye = document.querySelector(&quot;.icon-eye&quot;); var pwd = document.querySelector(&quot;.user-pwd&quot;); var lock = false; // false表示锁是开的 //由于onfocus和blur都不支持事件冒泡，所以不能用事件委托 for (var i = 0; i &lt; inputs.length; i++) &#123;   inputs[i].addEventListener(&quot;focus&quot;, focusFn, false);   inputs[i].addEventListener(&quot;blur&quot;, blurFn, false); &#125;&gt; //获取焦点时 function focusFn() &#123;   window.requestAnimationFrame(fn);   lock = false; //一旦获取焦点就开锁，启动定时器   //开启定时器   var that = this; //this是调用focus的输入框   var nextEle = this.nextElementSibling;   //无论是否有内容：   //1. 文字缩小   nextEle.classList.add(&quot;lable-min&quot;);   //2. 加边框   this.classList.add(&quot;focus2&quot;);   function fn() &#123;     var value = that.value.trim();     if (value) &#123;       //如果有内容       //同时隐藏输入提示       nextEle.nextElementSibling.classList.add(&quot;hide&quot;);       that.classList.remove(&quot;focus1&quot;);     &#125; else &#123;       //如果没有内容：显示输入提示       nextEle.nextElementSibling.classList.remove(&quot;hide&quot;);       that.classList.add(&quot;focus1&quot;);     &#125;     if (!lock) &#123;       //如果锁是开着的，就不断调用定时器       window.requestAnimationFrame(fn);     &#125;   &#125; &#125;&gt; //失去焦点时 function blurFn() &#123;   lock = true; //失去焦点就关锁，清除定时器   var nextEle = this.nextElementSibling;   //无论是否有内容，去掉红色边框线   this.classList.remove(&quot;focus2&quot;);   var value = this.value.trim();   if (!value) &#123;     //如果没有内容     //1.文字正常     nextEle.classList.remove(&quot;lable-min&quot;);     //2.粉色背景     // this.classList.add(&quot;focus1&quot;);   &#125; &#125;&gt; //密码眼睛 eye.onclick = function () &#123;   var bool = eye.classList.toggle(&quot;icon-show&quot;);   if (bool) &#123;     pwd.type = &quot;text&quot;;   &#125; else &#123;     pwd.type = &quot;password&quot;;   &#125; &#125;;&gt;&lt;/script&gt;</code></pre><h4 id="案例-6：放大镜效果"><a href="#案例-6：放大镜效果" class="headerlink" title="案例 6：放大镜效果"></a>案例 6：放大镜效果</h4><blockquote><p>涉及知识点</p><ul><li>选项卡效果、事件代理</li><li>onmouseover、onmousemove 事件</li><li>事件对象：e.pageX、e.pageY</li><li>元素偏移尺寸：offsetLeft、offsetTop</li><li>操作图片的 src 属性，完成图片替换</li><li>元素的显示与隐藏、事件冒泡机制</li></ul></blockquote><ol><li>CSS布局</li></ol><pre><code>&gt;&lt;style&gt; /* 初始化 */ body, html, ul, li &#123;   margin: 0;   padding: 0; &#125; li &#123;   list-style: none; &#125; .magnify &#123;   position: relative;   width: 350px;   padding: 20px;   border: 1px solid #ddd;   margin: 50px; &#125;&gt; /* 大图 */ .magnify .main &#123;   position: relative;   width: 100%;   height: 350px; &#125; .magnify .main img &#123;   width: 350px;   height: 350px; &#125; .magnify .mask &#123;   position: absolute;   top: 0;   left: 0;   width: 150px;   height: 150px;   background-color: rgba(232, 216, 94, 0.5);   cursor: move; &#125;&gt; /* 小图 */ .magnify .small-img &#123;   width: 100%;   height: 85px;   display: flex;   align-items: flex-end;   justify-content: space-between; &#125; .magnify .small-img li &#123;   width: 75px;   height: 75px; &#125; .magnify .small-img li img &#123;   width: 100%;   height: 100%;   cursor: pointer; &#125; .active &#123;   outline: 3px solid red;  &#125;&gt; /* 大图预览 */ .magnify .big-img &#123;   position: absolute;   top: 0;   left: 400px;   width: 450px;   height: 475px;   overflow: hidden;   /* display: none; */ &#125; .magnify .big-img img &#123;   position: absolute;   top: 0;   left: 0; &#125;&gt;&lt;/style&gt;&gt;&lt;div class=&quot;magnify&quot;&gt;&gt;  &lt;!-- 主图 --&gt;&gt;  &lt;div class=&quot;main&quot; id=&quot;J_main-img-wrap&quot;&gt;&gt;    &lt;img src=&quot;../src/放大镜图片素材/big1.jpg&quot; alt=&quot;&quot; /&gt;&gt;    &lt;div class=&quot;mask&quot;&gt;&lt;/div&gt;&gt;  &lt;/div&gt;&gt;  &lt;!-- 小图 --&gt;&gt;  &lt;ul class=&quot;small-img&quot; id=&quot;J_small-img-wrap&quot;&gt;&gt;    &lt;li&gt;&gt;      &lt;img&gt;        src=&quot;../src/放大镜图片素材/small1.jpg&quot;&gt;        data-src=&quot;../src/放大镜图片素材/big1.jpg&quot;&gt;      /&gt;&gt;    &lt;/li&gt;&gt;    &lt;li&gt;&gt;      &lt;img&gt;        src=&quot;../src/放大镜图片素材/small2.jpg&quot;&gt;        data-src=&quot;../src/放大镜图片素材/big2.jpg&quot;&gt;      /&gt;&gt;    &lt;/li&gt;&gt;    &lt;li&gt;&gt;      &lt;img&gt;        src=&quot;../src/放大镜图片素材/small3.jpg&quot;&gt;        data-src=&quot;../src/放大镜图片素材/big3.jpg&quot;&gt;      /&gt;&gt;    &lt;/li&gt;&gt;    &lt;li&gt;&gt;      &lt;img&gt;        src=&quot;../src/放大镜图片素材/small4.jpg&quot;&gt;        data-src=&quot;../src/放大镜图片素材/big4.jpg&quot;&gt;      /&gt;&gt;    &lt;/li&gt;&gt;  &lt;/ul&gt;&gt;  &lt;!-- 大图预览 --&gt;&gt;  &lt;div class=&quot;big-img&quot; id=&quot;J_big-img-wrap&quot;&gt;&gt;    &lt;img src=&quot;../src/放大镜图片素材/big1.jpg&quot; alt=&quot;&quot; id=&quot;J_big-img&quot; /&gt;&gt;  &lt;/div&gt;&gt;&lt;/div&gt;</code></pre><ol start="2"><li>JS 实现思路</li></ol><ul><li>第一步：处理点击小图要实现的效果<blockquote><ul><li>利用事件委托，点击小图后要处理的事情委托给他的们的祖先元素 ul 来处理。</li><li>给小图加边框</li><li>更换主图和预览大图<ul><li>小图设置自定义属性，绑定相应大图的地址</li></ul></li></ul></blockquote></li></ul><pre><code> //事件委托：点击小图，切换大图 smallImgWrap.onclick = function (e) &#123;   var target = e.target;   var tagName = target.tagName.toLowerCase();&gt;   if (tagName !== &quot;img&quot;) return;   //清除前一个选择元素样式   prevSmallImg.classList.remove(&quot;active&quot;);   //给当前点击的图片添加边框;   target.classList.add(&quot;active&quot;);   //把当前点击的图片更换为前一个激活的图片   prevSmallImg = target;   //更换主图   mainImg.src = target.dataset.src;   //更换大图   bigImg.src = target.dataset.src; &#125;;</code></pre><ul><li>第二步：当鼠标滑动到主图容器和离开主图容器要实现的效果<blockquote><ul><li>鼠标滑动到主图容器，要显示透明滑块，同时显示大图容器</li><li>鼠标离开主图容器，要隐藏透明滑块，同时隐藏大图容器</li></ul></blockquote></li></ul><pre><code> //当鼠标滑动到主图容器 mainImgWrap.onmouseover = function () &#123;   mask.style.display = &quot;block&quot;;   bigImgWrap.style.display = &quot;block&quot;; &#125;; //当鼠标离开主图容器 mainImgWrap.onmouseout = function () &#123;   mask.style.display = &quot;none&quot;;   bigImgWrap.style.display = &quot;none&quot;; &#125;;</code></pre><ul><li><p>第三步：实现滑块跟随之鼠标移动，并且块的中心位置为鼠标当前所在位置</p><blockquote><ul><li>设置滑块相对主图容器的 left 和 top 值</li><li><code>left 值 = 鼠标与浏览器左边距离 - 主图与浏览器左边距离 - 滑块宽度的一半</code></li><li><code>top 值 = 鼠标与浏览器上边距离 - 主图与浏览器上边距离 - 滑块高度的一半</code><ul><li>与浏览器的距离考虑滚动条的存在，使用<code>.pageX</code></li><li>主图与浏览器的距离：由于<code>main-wrap</code>与·浏览器还隔着父容器<code>magnify</code>,所以不能直接用<code>offsetLeft</code>；需要调用之前写过的函数</li><li>滑块宽高用<code>.offsetWidth</code>来获取<blockquote><p>减去宽&#x2F;高的一半，就可以使滑块的中心位置为鼠标当前所在位置</p></blockquote></li></ul></li></ul></blockquote></li><li><p>第四步：限止滑块的滑块区域</p><blockquote><ul><li>滑块能滑动的最小水平距离 &#x3D; 0 ，最大水平距离 &#x3D; 主图容器宽 - 滑块宽</li><li>滑块能滑动的最小垂直距离 &#x3D; 0 ，最大垂距离 &#x3D; 主图容器高 - 滑块高</li></ul></blockquote></li></ul><pre><code> //实现滑块跟随着鼠标移动 mainImgWrap.onmousemove = function (e) &#123;   //1. 获取鼠标与页面的距离   var pageX = e.pageX;   var pageY = e.pageY;   //2.获取主图容器与浏览器的距离   var mainLeft = getPosition(this).left;   var mainTop = getPosition(this).top;   //3.获取滑块宽高   var maskWidth = mask.offsetWidth;   var maskHeight = mask.offsetHeight;&gt;   //4. 计算滑块的left 和 top值 (鼠标在滑块中心)   var left = pageX - mainLeft - maskWidth / 2;   var top = pageY - mainTop - maskHeight / 2;&gt;   //5. 限制滑块距离   var maxLeft = this.clientWidth - maskWidth;   var maxTop = this.clientHeight - maskHeight;&gt;   left = left &lt; 0 ? 0 : left; //当left&lt;0   left = left &gt; maxLeft ? maxLeft : left;   top = top &lt; 0 ? 0 : top; //当top&lt;0   top = top &gt; maxTop ? maxTop : top;&gt;   // 设置滑块的left和top值。   mask.style.left = left + &quot;px&quot;;   mask.style.top = top + &quot;px&quot;; &#125;;&gt; // 获取当前元素与浏览器的left和top值 function getPosition(el) &#123;   // 获取当前元素左偏移量   var left = el.offsetLeft;   var top = el.offsetTop;   // 获了当前元素的offsetParent   var parent = el.offsetParent;   // 如果 offsetParent 存在，则一直获取,计算他的offsetLeft值，如果不存在，则终止   while (parent) &#123;     left += parent.offsetLeft; // 与每一轮元素的父元素与其定位父元素左边距离累加     top += parent.offsetTop;     // 计算父元素左边框大小     style = getComputedStyle(parent, null);     borderLeft = parseInt(style.borderLeftWidth); // 过滤单位部分，只取数字部分     borderTop = parseInt(style.borderTopWidth);     // 把左边框累加进去     left += borderLeft;     top += borderTop;     parent = parent.offsetParent;   &#125;   // 最终返回获取的left值   return &#123; left: left, top: top &#125;; &#125;</code></pre><ul><li>第五步：处理大图预览的对应移动的位置<blockquote><ul><li>通过以下公式，来求大图对应移动的 left 和 top 值</li><li>滑块滑动的距离 &#x2F; 滑块能滑动的最大距 &#x3D; 大图移动的距离 &#x2F; 大图能移动的最大距离</li><li>大图移动的距离&#x3D;（滑块滑动的距离 &#x2F; 滑块能移动的最大距离） * 大图能移动的最大距离</li></ul></blockquote></li></ul><pre><code> //处理大图预览的对应移动的位置 // 1.大图最大滑动水平距离 即 left最大值 var bigMaxLeft = bigImg.clientWidth - bigImgWrap.clientWidth; // 大图最大滑动垂直距离，即top最大值 var bigMaxTop = bigImg.clientHeight - bigImgWrap.clientHeight; //2. 计算大图的位置 var bigLeft = (left / maxLeft) * bigMaxLeft; var bigTop = (top / maxTop) * bigMaxTop;&gt; // 设置大图的left和top值(负数) bigImg.style.left = -bigLeft + &quot;px&quot;; bigImg.style.top = -bigTop + &quot;px&quot;;</code></pre><ol start="3"><li><p>性能优化</p><blockquote><ul><li><code>onmousemove</code>做节流操作；引用节流函数</li><li>将<code>onmousemove</code>里面能一次性获取的放在外面，提前获取到；减少重排重绘，节省性能</li></ul></blockquote></li><li><p>完整代码</p></li></ol><pre><code>&gt;&lt;script&gt; var mainImgWrap = document.getElementById(&quot;J_main-img-wrap&quot;); var smallImgWrap = document.getElementById(&quot;J_small-img-wrap&quot;); var bigImgWrap = document.getElementById(&quot;J_big-img-wrap&quot;);&gt; var smallImgs = document.querySelectorAll(&quot;#J_small-img-wrap img&quot;); var mainImg = document.querySelector(&quot;#J_main-img-wrap img&quot;); var bigImg = document.querySelector(&quot;#J_big-img-wrap img&quot;);&gt; var mask = document.querySelector(&quot;#J_main-img-wrap .mask&quot;); var prevSmallImg = smallImgs[0];&gt; //事件委托：点击小图，切换大图 smallImgWrap.onclick = function (e) &#123;   var target = e.target;   var tagName = target.tagName.toLowerCase();&gt;   if (tagName !== &quot;img&quot;) return;   //清除前一个选择元素样式   prevSmallImg.classList.remove(&quot;active&quot;);   //给当前点击的图片添加边框;   target.classList.add(&quot;active&quot;);   //把当前点击的图片更换为前一个激活的图片   prevSmallImg = target;   //更换主图   mainImg.src = target.dataset.src;   //更换大图   bigImg.src = target.dataset.src; &#125;; var maskWidth; var maskHeight; var bigMaxLeft; var bigMaxTop;&gt; //当鼠标滑动到主图容器 mainImgWrap.onmouseover = function () &#123;   mask.style.display = &quot;block&quot;;   bigImgWrap.style.display = &quot;block&quot;;&gt;   //3.获取滑块宽高   maskWidth = mask.offsetWidth;   maskHeight = mask.offsetHeight;&gt;   // 1.大图最大滑动水平距离 即 left最大值   bigMaxLeft = bigImg.clientWidth - bigImgWrap.clientWidth;   // 大图最大滑动垂直距离，即top最大值   bigMaxTop = bigImg.clientHeight - bigImgWrap.clientHeight;&#125;;  //当鼠标离开主图容器 mainImgWrap.onmouseout = function () &#123;   mask.style.display = &quot;none&quot;;   bigImgWrap.style.display = &quot;none&quot;; &#125;;&gt; //2.获取主图容器与浏览器的距离 var mainLeft = getPosition(mainImgWrap).left; var mainTop = getPosition(mainImgWrap).top;&gt; //获取主图容器的宽高 var mainImgWrapWidth = mainImgWrap.clientWidth; var mainImgWrapHeight = mainImgWrap.clientHeight;&gt; //实现滑块跟随着鼠标移动 mainImgWrap.onmousemove = throttle(fn, 100); function fn(e) &#123;   //1. 获取鼠标与页面的距离   var pageX = e.pageX;   var pageY = e.pageY;&gt;   //4. 计算滑块的left 和 top值 (鼠标在滑块中心)   var left = pageX - mainLeft - maskWidth / 2;   var top = pageY - mainTop - maskHeight / 2;&gt;   //5. 限制滑块距离   var maxLeft = mainImgWrapWidth - maskWidth;   var maxTop = mainImgWrapHeight - maskHeight;&gt;   left = left &lt; 0 ? 0 : left; //当left&lt;0   left = left &gt; maxLeft ? maxLeft : left;   top = top &lt; 0 ? 0 : top; //当top&lt;0   top = top &gt; maxTop ? maxTop : top;&gt;   // 设置滑块的left和top值。   mask.style.left = left + &quot;px&quot;;   mask.style.top = top + &quot;px&quot;;&gt;   //处理大图预览的对应移动的位置   //2. 计算大图的位置   var bigLeft = (left / maxLeft) * bigMaxLeft;   var bigTop = (top / maxTop) * bigMaxTop;&gt;   // 设置大图的left和top值(负数)   bigImg.style.left = -bigLeft + &quot;px&quot;;   bigImg.style.top = -bigTop + &quot;px&quot;; &#125;&gt; // 获取当前元素与浏览器的left和top值 function getPosition(el) &#123;   // 获取当前元素左偏移量   var left = el.offsetLeft;   var top = el.offsetTop;   // 获了当前元素的offsetParent   var parent = el.offsetParent;   // 如果 offsetParent 存在，则一直获取,计算他的offsetLeft值，如果不存在，则终止   while (parent) &#123;     left += parent.offsetLeft; // 与每一轮元素的父元素与其定位父元素左边距离累加     top += parent.offsetTop;     // 计算父元素左边框大小     style = getComputedStyle(parent, null);     borderLeft = parseInt(style.borderLeftWidth); // 过滤单位部分，只取数字部分     borderTop = parseInt(style.borderTopWidth);     // 把左边框累加进去     left += borderLeft;     top += borderTop;     parent = parent.offsetParent;   &#125;  // 最终返回获取的left值  return &#123; left: left, top: top &#125;;&#125;&gt; // 节流操作 function throttle(fn, delay = 20) &#123;   var timer = null; // null表示当前锁是打开的，没有锁，可以执行事件处理函数中的代码   return function () &#123;     if (timer) return;     var self = this; // 保存this 绑定事件的对象     var args = arguments; // 保存arguments 主要用来获取事件对象 e     // 定时器计时，用来开锁     timer = setTimeout(function () &#123;       fn.apply(self, args); // 事件处理函数       timer = null; // 开锁     &#125;, delay);   &#125;; &#125;&gt;&lt;/script&gt;</code></pre><h3 id="八、手写防抖函数（经典面试题）"><a href="#八、手写防抖函数（经典面试题）" class="headerlink" title="八、手写防抖函数（经典面试题）"></a>八、手写防抖函数（经典面试题）</h3><ol><li>什么是防抖 ？<blockquote><ul><li>是指只有在间隔时间达到规定时间后才会执行一次真正的事件处理函数</li><li>如果在规定时间内再次触发事件，则会重新计时。<br>接下来我们通过一个经典的<strong>防抖案例：搜索查询</strong>来作为切入点展开讲解。</li></ul></blockquote></li></ol><blockquote><p>搜索查询 - <strong>功能需求</strong></p><ul><li>当我们在表单中输入内容时，希望在抬起键盘间隔<code>500ms</code>毫秒之后，获取输入框中输入的内容，然后再在事件处理函数中向后台发送请求，请求查询。</li></ul></blockquote><ol start="2"><li>搜索查询 - 未实现防抖前效果<blockquote><ul><li>我们想要在键盘抬起后，获取输入框中的内容，然后再发送请求，请求查询</li><li>我们可以通过 <code>keyup</code> 事件来处理，但是当我们抬起键盘的那一刻就会触发 <code>keup</code> 事件</li><li>也就意味着我<strong>每次</strong>输一个字，就会触发一次 <code>keyup</code> 事件</li></ul></blockquote></li></ol><pre><code>&gt;&lt;body&gt;&gt; 搜索查询：&lt;input type=&quot;text&quot; /&gt;&gt; &lt;script&gt;   var search = document.querySelector(&quot;input&quot;);   search.onkeyup = function () &#123;     console.log(this.value);     // 获取输入框内容，向后台发请求查询     // ....发送请求代码省略   &#125;;&gt; &lt;/script&gt;&gt;&lt;/body&gt;</code></pre><blockquote><p>以上写法存在问题</p><ul><li>以上效果肯定不是我们想要的，因为事件处理函数的<strong>执行频率太高了</strong>。<br><strong>期望效果</strong></li><li>我们希望的是在我们抬起键盘<code>500ms</code>后，才真正的执行一次事件处理函数中的代码。</li><li>如果在<code>500ms</code>以内，再次输入内容，则会<strong>重新计时</strong>，不会执行事件处理函数中的代码。</li></ul></blockquote><ol start="3"><li>搜索查询 - 实现防抖后效果<br><strong>实现逻辑</strong><blockquote><ul><li>我们可以通过一个<strong>定时器</strong>来计时， 然后在定时器到达指定时间后，就执行事件处理函数中代码，向后台发送请求，请求查询</li><li>如果在定时器没有达到指定时间内，再次触发keyup事件，就把<strong>上一次的定时器清除掉</strong>，重新再开一个定时器<strong>重新计时</strong></li></ul></blockquote></li></ol><ul><li>版本1：</li></ul><pre><code>&gt;搜索查询：&lt;input type=&quot;text&quot; /&gt;&gt;&lt;script&gt;  var search = document.querySelector(&quot;input&quot;);  var timer = null;  search.onkeyup = function () &#123;    clearTimeout(timer);    self = this; //this=search传给定时器    timer = setTimeout(function () &#123;      //定时器里的this是window      console.log(self.value);      // 获取输入框内容，向后台发请求查询      // ....发送请求代码省略    &#125;, 2000);  &#125;;&gt;&lt;/script&gt;</code></pre><ul><li>版本二</li></ul><pre><code>&gt;搜索查询：&lt;input type=&quot;text&quot; /&gt;&gt;&lt;script&gt;  var search = document.querySelector(&quot;input&quot;);  var timer = null;  search.onkeyup = function () &#123;    if (timer) clearTimeout(timer);    self = this; //this=search传给定时器    timer = setTimeout(function () &#123;      //定时器里的this是window      console.log(self.value);      // 获取输入框内容，向后台发请求查询      // ....发送请求代码省略      timer = null; // 这里很多人有争议，要不要置空    &#125;, 2000);  &#125;;&gt;&lt;/script&gt;</code></pre><ol start="4"><li>抽离防抖相关代码，封装成防抖函数<blockquote><ul><li>将事件触发真正要执行的代码抽离出来放在函数<code>eventFn</code>中</li><li>封装防抖函数<code>debounce</code></li><li>事件处理函数<code>eventFn</code>不能写死，要让用户自己定义，所以通过参数传进去</li><li>定时器的延迟时间也不能写死，通过参数传入</li></ul></blockquote></li></ol><pre><code>&gt;&lt;script&gt;  var search = document.querySelector(&quot;input&quot;);  search.onkeyup = debounce(eventFn, 1000)    function debounce(fn, delay = 500) &#123;    var timer = null;    return function () &#123;      if (timer) clearTimeout(timer);      var self = this;       timer = setTimeout(function () &#123;        fn();        // 获取输入框内容，向后台发请求查询        // ....发送请求代码省略        timer = null; // 这里很多人有争议，要不要置空      &#125;, delay);    &#125;;  &#125;  function eventFn() &#123;    console.log(self.value);  &#125;&gt;&lt;/script&gt;</code></pre><ul><li>进一步优化<blockquote><ul><li><code>denounce</code> 函数内调用的 <code>fn</code> 事件处理函数中的 <code>this</code> 和 事件对象 <code>e</code> 是有问题的</li><li><code>fn()</code>直接调用，内部 <code>this</code> 肯定指向的是 window，同时事件对象 e 被丢失了</li><li>所以我们要修改<code>fn()</code>时，内部的 <code>this </code>指向，同时把事件对象 <code>e</code> 传递进去。</li></ul></blockquote></li></ul><ol start="5"><li>ES5 版本 - 防抖函数</li></ol><pre><code> &gt;搜索查询：&lt;input type=&quot;text&quot; /&gt; &gt;&lt;script&gt;   var search = document.querySelector(&quot;input&quot;);   search.onkeyup = debounce(eventFn, 1000);&gt; function debounce(fn, delay = 500) &#123;   var timer = null;   return function () &#123;     if (timer) clearTimeout(timer);     var self = this;     var args = arguments;     timer = setTimeout(function () &#123;       fn.apply(self, args); //fn()直接调用，内部 this 肯定指向的是 window       // 获取输入框内容，向后台发请求查询       // ....发送请求代码省略       timer = null; // 这里很多人有争议，要不要置空     &#125;, delay);   &#125;; &#125; function eventFn() &#123;   console.log(this.value); &#125;&gt;&lt;/script&gt;</code></pre><ol start="6"><li>ES6 版本 - 防抖函数</li></ol><pre><code>&gt;/**&gt; * debounce 防抖函数&gt; * @param fn 事件处理函数&gt; * @param delay 延迟时间&gt; */function debounce(fn, delay = 200) &#123;  var timer = null;  // 以下是每次需要执行的代码  return function () &#123;    if (timer) clearTimeout(timer);    // 开启定时器    timer = setTimeout(() =&gt; &#123;      fn.apply(this, arguments);      timer = null; // 这里很多人有争议，要不要置空    &#125;, delay);  &#125;;&#125;</code></pre><ol start="7"><li>区分防抖与节流<blockquote><p><strong>不同点</strong></p><ul><li>节流：不管事件触发有多频繁，都会保证在规定时间内执行一次真正的事件处理函数</li><li>防抖：只有在间隔时间达到规定时间后才会执行一次真正的事件处理函数，如果在规定时间内再次触发事件，则会重新计时。<br><strong>相同点</strong></li><li>都可以通过使用 <code>setTimeout</code> 来实现</li><li>都是降低真正的事件处理函数的执行频率，达到节省计算资 源，减少性能的消耗<br><strong>节流应用场景</strong></li><li>搜索框输入查询、手机号、邮箱验证输入检测。</li><li><code>resize</code>事件，只需在窗口调整完后，计算窗口大小，防止重复渲染<br><strong>防抖应用场景</strong></li><li><code>scroll</code>滚动事件，判断是否滚动到页面底部，自动加载更多内容</li><li><code>mousemove</code>事件，当拖拽页面元素，或鼠标跟随效果</li><li>防止高频点击提交，防止表单重复提交</li></ul></blockquote></li></ol>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JS核心知识点（十）</title>
      <link href="/2023/12/05/JS%E6%A0%B8%E5%BF%83%E7%9F%A5%E8%AF%86%E7%82%B9%EF%BC%88%E5%8D%81%EF%BC%89/"/>
      <url>/2023/12/05/JS%E6%A0%B8%E5%BF%83%E7%9F%A5%E8%AF%86%E7%82%B9%EF%BC%88%E5%8D%81%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<span id="more"></span><h3 id="一、DOM-事件的基本介绍"><a href="#一、DOM-事件的基本介绍" class="headerlink" title="一、DOM 事件的基本介绍"></a>一、DOM 事件的基本介绍</h3><ol><li><p>什么是 DOM 事件 ？</p><blockquote><p>事件可以理解为：用户与网页发生的<strong>交互动作</strong>，比如：</p><ul><li>当鼠标移动到元素上面，会触发<code>mouseover</code>事件</li><li>当鼠标标点击中某个页面元素 ，会触发<code>click</code>事件</li><li>当用户进入或离开页面时，会触发 load 和 unload 事件</li><li>…. DOM 中的事件非常多，我们后面慢慢来学习<blockquote><p>当我们触发了上面这些事件时，计算机是如何知道用户与浏览器（网页）发生了这些交互呢 ？这就涉及到事件监听。</p></blockquote></li></ul></blockquote></li><li><p>什么是事件监听 ？</p><blockquote><ul><li>事件监听：就是计算机对事件进行监听，知道什么时候发生了这个事件，从而执行一些程序员预先编写好的程序。</li></ul></blockquote></li><li><p>设置事件监听的方法</p><blockquote><p>设置事件监听的方法有 2 种</p><ul><li>以 on 方式注册事件（绑定事件）</li><li>以 addEventListener() 方式监听注册事件</li></ul></blockquote></li></ol><ul><li>on 方式注册事件<blockquote><p>基本用法：</p><ul><li>语法<br><code>eventTarget.on事件类型 = fn;</code></li><li><code>eventTarget</code> 触发事件的<strong>目标对象</strong>，称为<strong>事件源</strong></li><li>on后面是<strong>事件类型</strong>，事件类型有很多如 click、mouseover、keydown、focus 等</li><li>fn是一个函数，事件触发时调用的函数，被称为<strong>事件处理函数</strong></li><li>一个完整的 DOM 事件，需要具备以上三部分：事件源、事件类型、事件处理函数</li></ul></blockquote></li></ul><pre><code>&gt;&lt;button id=&quot;btn&quot;&gt;点我&lt;/button&gt;&gt;&lt;script&gt;  // 获取dom元素  var btn = document.getElementById(&quot;btn&quot;);&gt;  // btn 为事件源 click 为事件类型名，这里的函数为事件处理函数  btn.onclick = function () &#123;    alert(&quot;我被点击了1&quot;);  &#125;;  btn.onclick = function () &#123;    alert(&quot;我被点击了2&quot;);  &#125;;&gt;&lt;/script&gt;</code></pre><blockquote><blockquote><p>on 方式注册事件，同一元素的同一事件，<strong>只能有一个</strong>事件处理函数，同时以写在<strong>后面的为主</strong></p></blockquote></blockquote><ul><li>以 addEventListener 方式监听注册事件<blockquote><p>基本用法</p><ul><li>语法<br><code>eventTarget.addEventListener(type, fn, useCapture);</code></li><li><code>eventTarget</code>为事件源, 触发事件的目标对象</li><li><code>type</code>监听事件的类型，type要加引号</li><li><code>fn</code>事件处理函数</li><li><code>useCapture</code>设置事件触发是捕获阶段还是冒泡阶段，其值只能是 false 和 true<ul><li>true 表示在捕获阶段触发</li><li>false 默认值，表示在冒泡阶段触发</li></ul></li><li>addEventListener方式，可以给元素的同一个事件添加<strong>多个</strong>事件监听（即绑定多个事件处理函数）</li></ul></blockquote></li></ul><blockquote><p>应用场景</p><ul><li>同一个页面要实现<strong>吸顶盒效果、楼梯式导航、滚动到底部加载更多</strong>等效果，这些效果都会用到<code>window.srcoll事件</code></li><li>所以我们需要为 window 的 scroll 事件，添加三个事件处理函数来分别处理以上三种效果。</li></ul></blockquote><pre><code>&gt;&lt;button id=&quot;btn&quot;&gt;点我&lt;/button&gt;&gt;&lt;script&gt;  // 获取dom元素  var btn = document.getElementById(&quot;btn&quot;);  // btn 为事件源 click 为事件类型名，fn为事件处理函数  false表示在冒泡阶段触发  btn.addEventListener(&quot;click&quot;, fn1, false);  btn.addEventListener(&quot;click&quot;, fn2, false);  function fn1() &#123;    alert(&quot;我被点击了fn1&quot;);  &#125;  function fn2() &#123;    alert(&quot;我被点击了fn2&quot;);  &#125;&gt;&lt;/script&gt;</code></pre><ol start="4"><li>移除事件监听</li></ol><ul><li>移除<code>on</code>方式绑定（注册）的事件<blockquote><p><code>eventTarget.on事件类型 = null; // 移除事件处理程序</code></p></blockquote></li></ul><pre><code>&gt;&lt;button id=&quot;btn&quot;&gt;点我&lt;/button&gt;&gt;&gt;&lt;script&gt;  // 获取dom元素  var btn = document.getElementById(&quot;btn&quot;);  btn.onclick = function () &#123;    console.log(&quot;点击后要执行的内容&quot;);  &#125;;  btn.onclick = null; // 移除 click事件&gt;&lt;/script&gt;</code></pre><ul><li>移除<code>addEventListener</code>方式的事件监听，需要通过 <code>removeEventListener</code>方法来实现</li></ul><pre><code>removeEventListener(事件名，事件处理函数，布尔值); // 用来移除具体的某一个事件监听// 移除时的，事件名，事件处理函数，布尔值 要与addEventListener添加时的参数完全相同</code></pre><blockquote><ul><li>因为<code>addEventListener</code>可以为同一元素的的同一事件绑定多个事件处理函数</li><li>所以，用<code>removeEventListener</code>方法来移除对应事件监听时，要<strong>保证移除的事件名，事件处理函数，布尔值</strong>要与 <code>addEventListener</code><strong>添加时的参数完全相同</strong>。才能移除具体的某个事件监听</li></ul></blockquote><pre><code>&gt;&lt;button id=&quot;btn&quot;&gt;点我&lt;/button&gt;&gt;&lt;script&gt;  // 获取dom元素  var btn = document.getElementById(&quot;btn&quot;);  btn.addEventListener(&quot;click&quot;, fn1, false);  // 不能移除，因为没有相对应的事件监听  // btn.removeEventListener(&quot;click&quot;, fn1, true);  // 移除第一次添加的事件监听  btn.removeEventListener(&quot;click&quot;, fn1, false);  function fn1() &#123;    console.log(&quot;执行了fn1&quot;);  &#125;&gt;&lt;/script&gt;</code></pre><blockquote><blockquote><p>注意：</p></blockquote><ul><li>如果注册事件时，fn写的是整个函数，而不是函数名，则无法移除</li><li>以下写法，不能移除事件</li></ul></blockquote><pre><code>//注册事件 btn.addEventListener(   &quot;click&quot;,   function fn1() &#123;     alert(&quot;你被点击了&quot;);   &#125;,   false ); //   移除事件 btn.removeEventListener(   &quot;click&quot;,   function fn1() &#123;     alert(&quot;你被点击了&quot;);   &#125;,   false );</code></pre><h3 id="二、常见鼠标事件"><a href="#二、常见鼠标事件" class="headerlink" title="二、常见鼠标事件"></a>二、常见鼠标事件</h3><blockquote><ul><li>用<code>addEventListener</code>时，去掉<code>on</code><table><thead><tr><th>事件名</th><th>描述</th></tr></thead><tbody><tr><td>onclick</td><td>当鼠标单击某个对象</td></tr><tr><td>ondbclick</td><td>当鼠标双击某个对象</td></tr><tr><td>onmouseover</td><td>当鼠标进入某个对象</td></tr><tr><td>onmouseout</td><td>当鼠标离开某个对象</td></tr><tr><td>onmouseenter</td><td>当鼠标进入某个对象（相似事件 onmouseover）不能向上冒泡</td></tr><tr><td>onmouseleave</td><td>当鼠标离开某个对象（相似事件 onmouseout）不能向上冒泡</td></tr><tr><td>onmousedown</td><td>当某个鼠标按键在某个对象上被按下</td></tr><tr><td>onmouseup</td><td>当某个鼠标按键在某个对象上被松开</td></tr><tr><td>onmousemove</td><td>当某个鼠标按键在某个对象上被移动</td></tr></tbody></table></li></ul></blockquote><h4 id="onclick-与-ondblclick-事件"><a href="#onclick-与-ondblclick-事件" class="headerlink" title="onclick 与 ondblclick 事件"></a>onclick 与 ondblclick 事件</h4><table><thead><tr><th>事件名</th><th>描述</th></tr></thead><tbody><tr><td>onclick</td><td>鼠标单击事件，当鼠标单击某个对象时触发</td></tr><tr><td>ondblclick</td><td>鼠标双击事件，当鼠标双击某个对象时触发</td></tr></tbody></table><pre><code>&gt;&lt;style&gt;&gt;  .box &#123;&gt;    width: 200px;&gt;    height: 200px;&gt;    background-color: skyblue;&gt;  &#125;&gt;&lt;/style&gt;&gt;&lt;div class=&quot;box&quot;&gt;&lt;/div&gt;&gt;&lt;script&gt;  var box = document.querySelector(&quot;.box&quot;);  // 单击事件  box.onclick = function () &#123;    console.log(&quot;我是 onclick&quot;);  &#125;;  // 双击事件  box.ondblclick = function () &#123;    alert(&quot;我是 ondblclick&quot;);  &#125;;&gt;&lt;/script&gt;</code></pre><h4 id="事件处理函数中的-this-指向"><a href="#事件处理函数中的-this-指向" class="headerlink" title="事件处理函数中的 this 指向"></a>事件处理函数中的 this 指向</h4><blockquote><ul><li>事件处理函数中的 this 指向<strong>绑定事件的那个对象</strong></li></ul></blockquote><pre><code>&gt;&lt;div class=&quot;box&quot;&gt;点我&lt;/div&gt;&gt;&lt;script&gt;  var box = document.querySelector(&quot;.box&quot;);  // on开头绑定事件  box.onclick = function () &#123;    console.log(this); // &lt;div class=&quot;box&quot;&gt;点我&lt;/div&gt;  &#125;;&gt;  // addEventListener 绑定事件  box.addEventListener(&quot;click&quot;, fn, false);  function fn() &#123;    console.log(this); // &lt;div class=&quot;box&quot;&gt;点我&lt;/div&gt;  &#125;&gt;&lt;/script&gt;</code></pre><h4 id="案例"><a href="#案例" class="headerlink" title="案例"></a>案例</h4><ol><li>案例1：当用户点击页面上的 div 后，更改 div 的背景色</li></ol><pre><code>&gt;&lt;style&gt;&gt;  .box &#123;&gt;    width: 200px;&gt;    height: 200px;&gt;    background-color: skyblue;&gt;  &#125;&gt;&lt;/style&gt;&gt;&gt;&lt;div class=&quot;box&quot;&gt;&lt;/div&gt;&gt;&lt;script&gt;  // 获取class名为box的div  var box = document.querySelector(&quot;.box&quot;);  // on开头的方式给box元素添加click点击事件  // 当box元素被点击后，就会触发click事件，从而执行后面函数中的代码  box.onclick = function () &#123;    this.style.backgroundColor = &quot;khaki&quot;; // 更改div的背景颜色  &#125;;&gt;  // 以addEventListener（）方法给 box元素添加click事件  // 当box元素被点击后，就会触发click事件，从而执行bgColor函数  box.addEventListener(&quot;click&quot;, bgColor, false);  function bgColor() &#123;    this.style.backgroundColor = &quot;blue&quot;;  &#125;&gt;&lt;/script&gt;</code></pre><ol start="2"><li>案例2：点击显示和隐藏<blockquote><ul><li>默认状态为隐藏，点击按钮切换状态</li></ul></blockquote></li></ol><ul><li>方法1：<blockquote><ul><li>操作样式（控制元素显示与隐藏），改变<code>display</code></li><li>开关锁：定义一个变量来标记当前状态<blockquote><p>注意：这里不能用<code>this</code>，因为事件源是<code>button</code>，而做出改变的是<code>box</code></p></blockquote></li></ul></blockquote></li></ul><pre><code>&gt;&lt;style&gt;  .box &#123;    width: 200px;    height: 200px;    background-color: green;    display: none;  &#125;&gt;&lt;/style&gt;&gt;&gt;&lt;button&gt;点击&lt;/button&gt;&gt;&lt;div class=&quot;box&quot;&gt;&lt;/div&gt;&gt;&lt;script&gt;  btn = document.querySelector(&quot;button&quot;);  box = document.querySelector(&quot;.box&quot;);  var flag = false; //默认情况下不显示  btn.onclick = function () &#123;    // 如果flag是true，则点击后隐藏  if (flag) &#123;    box.style.display = &quot;none&quot;;    flag = false;  &#125; else &#123;    // 如果flag是false，则点击后显示出来    box.style.display = &quot;block&quot;;    flag = true;  &#125;&#125;;&gt;&lt;/script&gt;</code></pre><ul><li>方法2<blockquote><ul><li>利用<code>classList.toggle()</code>方法，实现两种样式之间相互转换</li><li><code>toggle()</code>：如果有这个类名,则删除这个类名，返回 <code>false</code>，如果没有，则添加该类名，返回 <code>true</code></li></ul></blockquote></li></ul><pre><code>&gt;&lt;style&gt;  .box &#123;    width: 200px;    height: 200px;    background-color: green;    display: none;  &#125;.hide &#123;  display: none;&#125;&gt;&lt;/style&gt;&gt;&gt;&lt;button&gt;点击&lt;/button&gt;&gt;&lt;div class=&quot;box hide&quot;&gt;&lt;/div&gt;&gt;&lt;script&gt;  btn = document.querySelector(&quot;button&quot;);  box = document.querySelector(&quot;.box&quot;);  // 方法2：  btn.onclick = function () &#123;    box.classList.toggle(&quot;hide&quot;);  &#125;;&gt;&lt;/script&gt;</code></pre><ol start="3"><li>案例 3：变色小球<blockquote><ul><li>让小球在红（red)，绿(green)，黄(yellow)，蓝(blue) 4 个颜色之间切换</li><li>小球初始颜色为红色（red），第一次点击后，变为绿色（green），第二次点击，变为黄色（yellow），第三次点击变为蓝色（blue），第四点击后变为红色（red）</li><li>后面点击依次按上面步骤来切换不同颜色</li></ul></blockquote></li></ol><ul><li>解题思路：<blockquote><ul><li>我们可以定义一个变量<code>bgColor</code>，用来保存元素的当前的颜色状态</li><li>刚开始小球颜色为红色，即<code>bgColor = &#39;red&#39;;</code></li><li>然后每次点击后，判断下当前的颜色，</li><li>如果为<code>red</code>，则把小球背景色变为<code>green</code>，同时<code>bgColor = &#39;green&#39;</code>,更改为当前球的背景色</li><li>如果为<code>green</code>，则把小球背景色变为<code>yellow</code>，同时<code>bgColor = &#39;yellow&#39;</code>,更改为当前球的背景色</li><li>如果为<code>yellow</code>，则把小球背景色变为<code>blue</code>，同时<code>bgColor = &#39;blue&#39;</code>,更改为当前球的背景色</li><li>如果为<code>blue</code>，则把小球背景色变为<code>red</code>，同时<code>bgColor = &#39;red&#39;</code>,更改为当前球的背景色</li></ul></blockquote></li></ul><pre><code>&gt;&lt;style&gt;  .ball &#123;    width: 100px;    height: 100px;    border-radius: 50%;    background-color: red;  &#125;&gt;&lt;/style&gt;&gt;&gt;&lt;div class=&quot;ball&quot;&gt;&lt;/div&gt;&gt;&lt;script&gt;  var ball = document.querySelector(&quot;.ball&quot;);  var bgColor = &quot;red&quot;;  ball.onclick = function () &#123;    if (bgColor === &quot;red&quot;) &#123;      this.style.backgroundColor = &quot;green&quot;;      bgColor = &quot;green&quot;;    &#125; else if (bgColor === &quot;green&quot;) &#123;      this.style.backgroundColor = &quot;yellow&quot;;      bgColor = &quot;yellow&quot;;    &#125; else if (bgColor === &quot;yellow&quot;) &#123;      this.style.backgroundColor = &quot;blue&quot;;      bgColor = &quot;blue&quot;;    &#125; else if (bgColor === &quot;blue&quot;) &#123;      this.style.backgroundColor = &quot;red&quot;;      bgColor = &quot;red&quot;;    &#125;  &#125;;&gt;&lt;/script&gt;</code></pre><ul><li><strong>优化版</strong><blockquote><ul><li>元素在多个状态之间切换，可以把 <code>if</code> 这种方式，改成用 <code>switch 语句</code>来实现，条理更清淅</li><li>把 <code>bgColor</code> 这个变量，更改为<strong>对象自身的一个属性</strong>，更好，这样就可以<strong>消除全局变量</strong>，同时如果页面有多个相似的对象，那这些对象之间互不干扰</li><li>把这个改变元素背景颜色的<strong>函数封装</strong>成一个大家共用的方法</li></ul></blockquote></li></ul><pre><code>&gt;&lt;style&gt;  .ball1 &#123;    width: 100px;    height: 100px;    border-radius: 50%;    background-color: red;  &#125;  .ball2 &#123;    width: 100px;    height: 100px;    border-radius: 50%;    background-color: green;  &#125;&gt;&lt;/style&gt;&gt;&gt;&lt;div class=&quot;ball1&quot;&gt;&lt;/div&gt;&gt;&lt;div class=&quot;ball2&quot;&gt;&lt;/div&gt;&gt;&lt;script&gt;  var ball1 = document.querySelector(&quot;.ball1&quot;);  var ball2 = document.querySelector(&quot;.ball2&quot;);  ball1.bgColor = &quot;red&quot;; // bgColor为对象的一个属性  ball1.onclick = changeBgColor;  ball2.bgColor = &quot;green&quot;; // bgColor为对象的一个属性  ball2.onclick = changeBgColor;&gt;  // 把切换背景的功能，抽离成一个公共方法  function changeBgColor() &#123;    switch (this.bgColor) &#123;      case &quot;red&quot;:        this.style.backgroundColor = &quot;green&quot;;        this.bgColor = &quot;green&quot;;        break;      case &quot;green&quot;:        this.style.backgroundColor = &quot;yellow&quot;;        this.bgColor = &quot;yellow&quot;;        break;      case &quot;yellow&quot;:        this.style.backgroundColor = &quot;blue&quot;;        this.bgColor = &quot;blue&quot;;        break;      case &quot;blue&quot;:        this.style.backgroundColor = &quot;red&quot;;        this.bgColor = &quot;red&quot;;        break;    &#125;  &#125;&gt;&lt;/script&gt;</code></pre><blockquote><blockquote><p>总结：</p><ul><li>如果一个元素在<strong>多个状态</strong>之间相互切换，我们可以在元素身上<strong>定义一个属性</strong>，这个属性用来保存当前元素的当前状态。</li><li>然后在每次切换状态前，判断下当前的状态，再根据不同的状态来实现不同效果。</li></ul></blockquote></blockquote><ol start="4"><li>案例 4：点击弹出对应 li 的序号<blockquote><p>涉及知识点</p><ul><li>对象自定义属性的应用</li><li>闭包的应用<blockquote><p>如下：当点击第一个 1，弹出 0，第二个弹出 1，第三个弹出 2，第 4 个弹出 3</p></blockquote></li></ul></blockquote></li></ol><pre><code>&gt;&lt;body&gt;&gt; &lt;ul class=&quot;list&quot;&gt;    &lt;li&gt;1&lt;/li&gt;    &lt;li&gt;2&lt;/li&gt;    &lt;li&gt;3&lt;/li&gt;    &lt;li&gt;4&lt;/li&gt;&gt;&lt;/ul&gt;&gt;&lt;script&gt;    var liList = document.querySelectorAll(&quot;.list li&quot;);    // 常见错误写法    for (var i = 0; i &lt; liList.length; i++) &#123;      liList[i].onclick = function () &#123;        alert(i);      &#125;;    &#125;&gt;    // 正确写法一：自定义属性    for (var i = 0; i &lt; liList.length; i++) &#123;      liList[i].index = i; // 给每个对象添加自定义属性，来保存对应下标      liList[i].onclick = function () &#123;        alert(this.index);      &#125;;    &#125;&gt;    // 正确写法二：利用闭包    for (var i = 0; i &lt; liList.length; i++) &#123;      (function (i) &#123;        liList[i].onclick = function () &#123;          alert(i);        &#125;;      &#125;)(i);    &#125;&gt;  &lt;/script&gt;&gt;&lt;/body&gt;</code></pre><blockquote><p><strong>错误写法解读</strong></p><ul><li><code>liList[0].onclick = function () &#123; alert(i); &#125;</code></li><li><code>alert(i);</code>在函数里，所以他并不会马上执行，只有当函数被调用，也就是被点击的时候才会执行</li><li>而执行时，i是全局变量，在for循环结束后，i已经变成了4，所以每个li被点击时，都会得到4；</li></ul></blockquote><blockquote><p><strong>解决办法1解读</strong></p><ul><li>通过for循环，给每个li添加自定义属性，里面保存i的值作为li的下标，点击事件发生时，就调用该属性</li><li>每次循环都会保存不同的值，而且互不影响</li></ul></blockquote><blockquote><p><strong>解决办法2解读</strong></p><ul><li>使用立即执行函数，每次for循环开始，就马上执行该函数</li><li>由于点击事件里面的函数，在点击时才会执行，所以立即执行函数会产生一个闭包，里面保存当前for循环的i值</li></ul></blockquote><ol start="5"><li>案例 5：点击随机生成 6 位符号验证码<blockquote><p>涉及知识</p><ul><li>创建 DOM 元素，同时添加样式，事件等</li><li>随机函数：随机数字及颜色，随机背景图片<br><strong>思路：</strong></li><li>效果：用元素调用函数，就直接能在该函数里生成随机验证码</li><li>因此，该效果里的html元素都要在函数内用JS生成，不能写死</li><li>验证码里的数字、字母、背景干扰图片也是自动生成的，可以各写成两个独立函数，在主函数内调用</li><li>设置点击事件，每点击一次，更新验证码背景图片<blockquote><p>注意：更新数字和字母前，一定要把之前的内容清空</p></blockquote></li></ul></blockquote></li></ol><pre><code>&gt;&lt;style&gt;  /* .yzm &#123;    position: relative;    width: 150px;    height: 50px;  &#125; */  /* .yzm .yzm-code &#123;    background-color: #ddd;    height: 100%;    font-size: 0;    text-align: center;    line-height: 50px;  &#125; */  /* .yzm .yzm-code span &#123;    font-weight: bold;    font-size: 30px;    margin: 2px;    user-select: none;  &#125; */  /* .yzm-bg &#123;    position: absolute;    top: 0;    left: 0;    width: 100%;    height: 100%;    background: url(../src/yzm/line1.png) no-repeat center;    background-size: cover;    cursor: pointer;  &#125; */&gt;&lt;/style&gt;&gt;&lt;div class=&quot;box&quot;&gt;  &lt;!-- &lt;div class=&quot;yzm&quot;&gt;    &lt;div class=&quot;yzm-code&quot;&gt;      &lt;span&gt;1&lt;/span&gt;      &lt;span&gt;d&lt;/span&gt;      &lt;span&gt;b&lt;/span&gt;      &lt;span&gt;a&lt;/span&gt;      &lt;span&gt;9&lt;/span&gt;      &lt;span&gt;5&lt;/span&gt;    &lt;/div&gt;  &lt;/div&gt;  &lt;div class=&quot;yzm-bg&quot;&gt;&lt;/div&gt; --&gt;&gt;&lt;/div&gt;&gt;&lt;script&gt;  // 用js写出html元素  function getYzm(el) &#123;    // 首先创建yzm的html结构    var yzm = document.createElement(&quot;div&quot;);    // 给yzm添加样式    yzm.style.cssText = &quot;position: relative;width: 150px;height: 50px;&quot;;    // 创建数字结构    var yzmCode = document.createElement(&quot;div&quot;);    // 给yzmCode添加样式    yzmCode.style.cssText =      &quot;background-color: #ddd;height: 100%;font-size: 0;text-align: center;line-height: 50px;&quot;;    // 创建背景结构    var yzmBg = document.createElement(&quot;div&quot;);    // 给背景添加样式    yzmBg.style.cssText =      &quot;position: absolute;top: 0;left: 0;width: 100%;height: 100%;background: url(../src/yzm/line1.png) no-repeat center;background-size: cover;cursor: pointer;&quot;;    // 把yzmCode添加到yam上    yzm.appendChild(yzmCode);    // 将背景添加到yzm上    yzm.appendChild(yzmBg);    // 将yzm添加到容器元素上    el.appendChild(yzm);    // 调用随机数字函数    updateCode(yzmCode);      // 添加点击事件      yzm.addEventListener(&quot;click&quot;, updateYzm, false);      function updateYzm() &#123;        updateCode(yzmCode);        // 调用随机背景函数        updateBg(yzmBg);      &#125;    &#125;&gt;  // 生成随机数字、颜色  function updateCode(el) &#123;    // 在赋值前，先把之前内容全部清空    el.innerHTML = &quot;&quot;;    // 声明数字组成的数组    var codeArr = [1, 2, 3, 4, 5, 6, 7, 8, 9, &quot;a&quot;, &quot;f&quot;, &quot;r&quot;, &quot;l&quot;, &quot;i&quot;, &quot;o&quot;];    var colorArr = [&quot;#000&quot;, &quot;blue&quot;, &quot;green&quot;, &quot;tomato&quot;, &quot;red&quot;, &quot;purple&quot;];    for (var i = 0; i &lt; 6; i++) &#123;      var span = document.createElement(&quot;span&quot;);      //   添加样式      span.style.cssText =        &quot;font-weight: bold;font-size: 30px;margin: 2px; user-select: none;&quot;;      // 生成随机数字      var codeIndex = (Math.random() * codeArr.length) &gt;&gt; 0;      span.innerText = codeArr[codeIndex];      // 生成随机颜色      var colorIndex = (Math.random() * colorArr.length) &gt;&gt; 0;      span.style.color = colorArr[colorIndex];      // 添加到yzmCode中      el.appendChild(span);    &#125;  &#125;&gt;  // 生成随机背景  function updateBg(el) &#123;    var bgArr = [      &quot;../src/yzm/line1.png&quot;,      &quot;../src/yzm/line2.png&quot;,      &quot;../src/yzm/line3.png&quot;,      &quot;../src/yzm/line4.png&quot;,    ];    var bgIndex = (Math.random() * bgArr.length) &gt;&gt; 0;    // 把背景添加到el样式中    el.style.backgroundImage = &quot;url(&quot; + bgArr[bgIndex] + &quot;)&quot;;  &#125;  var box = document.querySelector(&quot;.box&quot;);  getYzm(box);&gt;&lt;/script&gt;&gt;&lt;/body&gt;</code></pre><blockquote><ul><li><code>user-select: none;</code>不能选中文字</li></ul></blockquote><ol start="6"><li>案例 6：点击换肤效果<img src="换肤效果.gif"></li></ol><p><strong>涉及知识点</strong></p><blockquote><ul><li>背景图片撑满整个屏幕(body不设置宽高时)<ul><li><code>html,body&#123;width:100%;height:100%&#125;</code></li><li><code>body&#123;background-size:cover&#125;</code></li></ul></li><li>选择皮肤时的边框<ul><li>为了不影响图片的位置和效果，不能设置成<code>border</code>，而是要设置成<code>outline</code></li><li><code>outline</code>不占据空间，绘制于元素内容周围的轮廓 ，不参于盒子模型的占位计算，不会因为添加这个属性，而造成盒子占位空间变化。</li><li>边框只能出现在一个皮肤上，两个解决办法：<strong>排他思想</strong>、<strong>标记前一个并删除边框</strong>，后一个性能更高</li></ul></li><li>点击小图更换皮肤<ul><li>设置<strong>自定义属性</strong>，使大图与小图相对应</li><li>设置方式：直接在标签上书写，命名规则：以<code>data-</code>开头</li><li>获取方式：直接通过<code>对象.dataset.属性名</code>（属性名书写格式：属性去掉 data-之后的单词，以驼峰命名）</li></ul></li><li>点击叉叉关闭遮罩层和皮肤选择框<blockquote><p>重难点：利用自定义属性保存每个元素标签不同的数据；</p></blockquote></li></ul></blockquote><pre><code>&gt;&lt;style&gt;  ul,  li &#123;    list-style: none;    margin: 0;    padding: 0;  &#125;  /* 清除浮动 */  .clearfix::after &#123;    display: block;    clear: both;    content: &quot;&quot;;  &#125;  /* 皮肤撑满屏幕 */  html,  body &#123;    width: 100%;    height: 100%;  &#125;  body &#123;    margin: 0;    background: url(../src/skin/big1.jpg) no-repeat;    background-size: cover;  &#125;  /* 换肤按钮 */  .update-skin &#123;    color: #fff;    position: absolute;    top: 20px;    right: 20px;    cursor: pointer;    user-select: none;  &#125;  /* 皮肤容器 */  .container-skin &#123;    display: none;    position: fixed;    top: 50%;    left: 50%;    z-index: 3;    transform: translate(-50%, -50%);    width: 540px;    background-color: #fff;    border-radius: 10px;    padding: 5px;  &#125;  /* 皮肤框 */  .select-skin li img &#123;    width: 260px;    height: 163px;    float: left;    margin: 5px;    cursor: pointer;  &#125;  /* 关闭框 */  .container-skin .close &#123;    position: absolute;    top: -15px;    right: -15px;    width: 30px;    height: 30px;    color: #fff;    font-size: 20px;    background-color: #000;    text-align: center;    line-height: 30px;    border-radius: 50%;    cursor: pointer;  &#125;  .mask &#123;    /* display: none; */    width: 100%;    height: 100%;    background-color: #000;    opacity: 0.5;  &#125;  .hide &#123;    display: none;  &#125;&gt;&lt;/style&gt;&gt;&gt;&lt;body&gt;&gt; &lt;div class=&quot;update-skin&quot;&gt;更换皮肤&lt;/div&gt;&gt; &lt;div class=&quot;container-skin&quot;&gt;&gt;   &lt;!-- 皮肤 --&gt;&gt;   &lt;ul class=&quot;select-skin clearfix&quot;&gt;&gt;     &lt;li&gt;&gt;       &lt;img&gt;         src=&quot;../src/skin/min1.jpg&quot;&gt;         alt=&quot;&quot;&gt;         data-skin=&quot;../src/skin/big1.jpg&quot;&gt;       /&gt;&gt;     &lt;/li&gt;&gt;     &lt;li&gt;&gt;       &lt;img&gt;         src=&quot;../src/skin/min2.jpg&quot;&gt;         alt=&quot;&quot;&gt;         data-skin=&quot;../src/skin/big2.jpg&quot;&gt;       /&gt;&gt;     &lt;/li&gt;&gt;     &lt;li&gt;&gt;       &lt;img&gt;         src=&quot;../src/skin/min3.jpg&quot;&gt;         alt=&quot;&quot;&gt;         data-skin=&quot;../src/skin/big3.jpg&quot;&gt;       /&gt;&gt;     &lt;/li&gt;&gt;     &lt;li&gt;&gt;       &lt;img&gt;         src=&quot;../src/skin/min4.jpg&quot;&gt;         alt=&quot;&quot;&gt;         data-skin=&quot;../src/skin/big4.jpg&quot;&gt;       /&gt;&gt;     &lt;/li&gt;&gt;   &lt;/ul&gt;&gt;   &lt;!-- 关闭按钮 --&gt;&gt;   &lt;div class=&quot;close&quot;&gt;X&lt;/div&gt;&gt; &lt;/div&gt;&gt; &lt;!-- 遮罩层 --&gt;&gt; &lt;div class=&quot;mask hide&quot;&gt;&lt;/div&gt;&gt;&lt;script&gt; // 点击换肤按钮，跳出选择框、遮罩层  var btnSkin = document.querySelector(&quot;.update-skin&quot;);  var container = document.querySelector(&quot;.container-skin&quot;);  var mask = document.querySelector(&quot;.mask&quot;);  btnSkin.onclick = function () &#123;    container.style.display = &quot;block&quot;;    mask.classList.toggle(&quot;hide&quot;);    // mask.style.display = &quot;block&quot;;  &#125;;  // 点击关闭按钮，关闭皮肤框  var btnClose = document.querySelector(&quot;.container-skin .close&quot;);  btnClose.onclick = function () &#123;    container.style.display = &quot;none&quot;;    mask.classList.toggle(&quot;hide&quot;);    // mask.style.display = &quot;none&quot;;  &#125;;  //自定义属性，点击换肤；设置边框  var imgList = document.querySelectorAll(&quot;.select-skin li img&quot;);  var len = imgList.length;  var selectImg = imgList[0]; //用来标记前一个被选中的图片  selectImg.style.outline = &quot;1px solid red&quot;; //默认选中第一个  for (var i = 0; i &lt; len; i++) &#123;    //给每个imgList添加点击事件    imgList[i].onclick = function () &#123;      //   排他法：每次点击后，先清楚所有图片的外轮廓      //   for (var j = 0; j &lt; len; j++) &#123;      //     imgList[j].style.outline = &quot;&quot;;      //   &#125;      //   this.style.outline = &quot;1px solid red&quot;;      //清除前一个法      selectImg.style.outline = &quot;&quot;; //清除前一个被选中图片样式      this.style.outline = &quot;1px solid #000&quot;; //给当前选中元素加样式      selectImg = this; //标记当前选中      // 换肤      var url = this.dataset.skin;      document.body.style.backgroundImage = &quot;url(&quot; + url + &quot;)&quot;;    &#125;;  &#125;&gt;&lt;/script&gt;&gt;&lt;/body&gt;</code></pre><h4 id="onmouseover-和-onmouseout-事件"><a href="#onmouseover-和-onmouseout-事件" class="headerlink" title="onmouseover 和 onmouseout 事件"></a>onmouseover 和 onmouseout 事件</h4><table><thead><tr><th>事件名</th><th>描述</th></tr></thead><tbody><tr><td>onmouseover</td><td>当鼠标进入某个对象</td></tr><tr><td>onmouseout</td><td>当鼠标离开某个对象</td></tr></tbody></table><blockquote><ul><li>如果是能用<code>:hover</code>就能实现的功能，尽量用<code>:hover</code>，更加方便简捷</li></ul></blockquote><ol><li>案例1：鼠标滑动，表格隔行变色</li></ol><pre><code>&gt;&lt;style&gt;  ul,  li &#123;    padding: 0;    margin: 0;    list-style: none;  &#125;  ul li &#123;    width: 400px;    height: 50px;  &#125;  li:nth-child(even) &#123;    background-color: #ddd;  &#125;  li:nth-child(odd) &#123;    background-color: #8b7f7f;  &#125;  li.color &#123;    background-color: plum;  &#125;  /* li:hover &#123;    background-color: palegreen;  &#125; */&gt;&lt;/style&gt;&gt;&lt;body&gt;&gt; &lt;ul&gt;&gt;   &lt;li&gt;&lt;/li&gt;&gt;   &lt;li&gt;&lt;/li&gt;&gt;   &lt;li&gt;&lt;/li&gt;&gt;   &lt;li&gt;&lt;/li&gt;&gt;   &lt;li&gt;&lt;/li&gt;&gt;   &lt;li&gt;&lt;/li&gt;&gt; &lt;/ul&gt;&gt; &lt;script&gt;  var liList = document.querySelectorAll(&quot;ul li&quot;);  var len = liList.length;  // 方法1  //   for (var i = 0; i &lt; len; i++) &#123;  //     liList[i].onmouseover = function () &#123;  //       this.style.backgroundColor = &quot;purple&quot;;  //     &#125;;  //     liList[i].onmouseout = function () &#123;  //       this.style.backgroundColor = &quot;&quot;;  //     &#125;;  //   &#125;  // 方法2  for (var i = 0; i &lt; len; i++) &#123;    liList[i].onmouseover = function () &#123;      this.classList.add(&quot;color&quot;);    &#125;;    liList[i].onmouseout = function () &#123;      this.classList.remove(&quot;color&quot;);    &#125;;  &#125;  //方法3`:hover`&gt; &lt;/script&gt;&gt;&lt;/body&gt;</code></pre><ol start="2"><li>案例 2：扫图游戏<blockquote><ul><li>当图形中的花全部被扫出来，整个游戏就结束了<img src="扫图游戏.gif"></li></ul></blockquote></li></ol><p><strong>思路</strong></p><blockquote><ul><li>用一层小方块盖住图片，每个小方块都有对应的下标</li><li>当花对应小方块全部被扫掉，游戏结束</li></ul></blockquote><blockquote><p><strong>花朵部分</strong></p><ul><li>方法1：<ul><li>我们用一个数组保存花朵对应的小方块的下标</li><li>每扫掉一块，先查询该下标是否在数组中，如果是，再从数组中删除对应的下标</li><li>当数组长度为0时，游戏结束</li></ul></li></ul></blockquote><pre><code>li.onmouseover = function () &#123;  //鼠标划到小方块时，变透明  this.style.opacity = 0;  if (data.length === 0) &#123;    // 游戏结束    mask.style.display = &quot;block&quot;;  &#125;  // 查询其下标，删除  var k = data.indexOf(this.index);  // 如果它存在于结果数组中，则返回所查元素的下标  if (k !== -1) &#123;    //根据所返回的下标，删掉该元素    data.splice(k, 1);  &#125;  // 被扫过的元素，把身上的onmouseover事件取消  this.onmouseover = null;&#125;;</code></pre><blockquote><ul><li>方法2：<ul><li>我们用一个数组保存花朵对应的小方块的下标</li><li>再声明一个变量，作为累加器</li><li>每扫掉一块，先查询该下标是否在数组中，如果是，则累加器+1，当累加器等于结果数组长度时，游戏结束</li></ul></li></ul></blockquote><pre><code>var item = 0; //记录结果数组中已经变透明的方块数li.onmouseover = function () &#123;  //鼠标划到小方块时，变透明  this.style.opacity = 0;  if (item === data.length) &#123;    // 游戏结束    mask.style.display = &quot;block&quot;;  &#125;  // 查询其下标，删除  var k = data.indexOf(this.index);  // 如果它存在于结果数组中，则item+1  if (k !== -1) &#123;    item++;  &#125;  // 被扫过的元素，把身上的onmouseover事件取消  this.onmouseover = null;&#125;;</code></pre><blockquote><blockquote><p>两种方法各有优劣，视具体情况而定</p></blockquote></blockquote><blockquote><p><strong>构建方块</strong></p><ul><li>方法1：<ul><li>设置一个for循环，每循环一次，创建一个li元素</li><li>自定义一个属性保存当前li元素的下标，属性值等于for循环的变量值</li><li>给li元素设置浮动</li><li>扫掉方块时，<strong>只能</strong>将该块设置为透明；否则将会影响其他方块的位置</li></ul></li></ul></blockquote><pre><code>for (var i = 0; i &lt; 12 * 16; i++) &#123;  var li = document.createElement(&quot;li&quot;);  li.index = i;  li.innerText = i;  ul.appendChild(li);&#125;</code></pre><blockquote><ul><li>方法2：<ul><li>设置两层for循环，第一层是行，第二层是列，只需要在第二层创建li元素</li><li>必须在外面定义一个累加器，每次循环<code>+1</code>；<blockquote><p>但这与九九乘法表(li&gt;span)不一样！！</p></blockquote></li><li>给每个li设置<strong>绝对定位</strong>(重点)</li><li>扫掉方块时，可以删除该方块，也可以将它设置为透明</li></ul></li></ul></blockquote><pre><code>var sum = 0;for (var i = 0; i &lt; 12; i++) &#123;  // 行  for (var j = 0; j &lt; 16; j++) &#123;    // 列    var li = document.createElement(&quot;li&quot;);    li.index = sum;    //   li.innerText = sum;    sum++;    ul.appendChild(li);  &#125;&#125;</code></pre><p><strong>扫方块后，变透明</strong></p><blockquote><ul><li>给每个li添加<code>onmouseover</code>事件，扫过之后，该方块的透明度为0；同时根据上面的思路，会对该下标进行一系列操作</li><li>注意：移出鼠标后要马上删掉该li身上的<code>onmouseover</code>事件</li><li>因为我们只是把它变透明，下次滑到，仍然会进行该事件，会影响对下标的操作</li></ul></blockquote><pre><code>li.onmouseover = function () &#123;  //鼠标划到小方块时，变透明  this.style.opacity = 0;  //游戏结束条件  // 下标操作  // 被扫过的元素，把身上的onmouseover事件取消  this.onmouseover = null;&#125;;</code></pre><ul><li>最终代码</li></ul><pre><code>&gt;&lt;style&gt; body &#123;   margin: 0; &#125; .container &#123;   width: 800px;   margin: 50px auto;   border: 1px solid #000; &#125; .container h1 &#123;   text-align: center; &#125; .container .game &#123;   width: 800px;   height: 600px;   background: url(../src/games/flower.png) no-repeat; &#125; ul, li &#123;   padding: 0;   margin: 0;   list-style: none; &#125; ul li &#123;   float: left;   width: 50px;   height: 50px;   background-color: #ddd; &#125; /* 游戏结束 */ .mask &#123;   display: none;   position: fixed;   top: 0;   left: 0;   width: 100%;   height: 100%;   background-color: rgba(0, 0, 0, 0.5); &#125; .mask p &#123;   position: absolute;   top: 50%;   left: 50%;   transform: translate(-50%, -50%);   color: red;   font-size: 50px;   margin: 0; &#125;&gt;&lt;/style&gt;&gt;&lt;div class=&quot;container&quot;&gt;&gt;  &lt;h1&gt;扫图游戏&lt;/h1&gt;&gt;  &lt;div class=&quot;game&quot;&gt;&lt;/div&gt;&gt;&lt;/div&gt;&gt;&lt;div class=&quot;mask&quot;&gt;&lt;p&gt;游戏结束！&lt;/p&gt;&lt;/div&gt;&gt;&lt;script&gt;  var game = document.querySelector(&quot;.game&quot;);  var ul = document.createElement(&quot;ul&quot;);  var mask = document.querySelector(&quot;.mask&quot;);  var data = [    23, 24, 25, 38, 39, 40, 41, 42, 43, 53, 54, 55, 56, 57, 58, 59, 67, 68,    69, 70, 71, 72, 73, 74, 75, 76, 77, 83, 84, 85, 86, 87, 88, 89, 91, 92,    93, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 115, 116, 117, 118,    119, 120, 121, 122, 123, 124, 130, 131, 132, 133, 134, 135, 136, 137,    138, 139, 147, 148, 149, 150, 151, 152, 153, 166, 167, 168, 169,  ]; //结果数组&gt;  // 构建小方块，方法1：一层for循环+浮动  // 在图上构建li，并标记数字  //   for (var i = 0; i &lt; 12 * 16; i++) &#123;  //     var li = document.createElement(&quot;li&quot;);  //     li.index = i;  //     li.innerText = i;  //     ul.appendChild(li);  //     onmouseover事件  //   &#125;&gt;  // 构建小方块，方法2：两层for循环+绝对定位  var item = 0; //记录结果数组中已经变透明的方块数  var sum = 0;  //记录下标  for (var i = 0; i &lt; 12; i++) &#123;    // 行    for (var j = 0; j &lt; 16; j++) &#123;      // 列      var li = document.createElement(&quot;li&quot;);      li.index = sum;      //   li.innerText = sum;      sum++;      ul.appendChild(li);//将每个li添加到ul上&gt;      //查询删除结果数组的下标,方法1：      // 给每一个li添加一个onmouseover事件      //   li.onmouseover = function () &#123;      //     //鼠标划到小方块时，变透明      //     this.style.opacity = 0;      //     if (data.length === 0) &#123;      //       // 游戏结束      //       mask.style.display = &quot;block&quot;;      //     &#125;      //     // 查询其下标，删除      //     var k = data.indexOf(this.index);      //     // 如果它存在于结果数组中，则返回所查元素的下标      //     if (k !== -1) &#123;      //       //根据所返回的下标，删掉该元素      //       data.splice(k, 1);      //     &#125;      //     // 被扫过的元素，把身上的onmouseover事件取消      //     this.onmouseover = null;      //   &#125;;&gt;    //方法2：用item记录变透明的结果数组的个数      li.onmouseover = function () &#123;        //鼠标划到小方块时，变透明        this.style.opacity = 0;        if (item === data.length) &#123;          // 游戏结束          mask.style.display = &quot;block&quot;;        &#125;        // 查询其下标，删除        var k = data.indexOf(this.index);        // 如果它存在于结果数组中，则item+1        if (k !== -1) &#123;          item++;        &#125;        // 被扫过的元素，把身上的onmouseover事件取消        this.onmouseover = null;      &#125;;    &#125;  &#125;//将ul添加到game上  game.appendChild(ul);&gt;&lt;/script&gt;</code></pre><blockquote><blockquote><p>还有一个综合案例：放大镜效果，放在后面的综合案例应用中讲解</p></blockquote></blockquote><h4 id="onmousedown、onmouseup-和-onmousemove"><a href="#onmousedown、onmouseup-和-onmousemove" class="headerlink" title="onmousedown、onmouseup 和 onmousemove"></a>onmousedown、onmouseup 和 onmousemove</h4><table><thead><tr><th>事件名</th><th>描述</th></tr></thead><tbody><tr><td>onmousedown</td><td>当某个鼠标按键在某个对象上被按下时触发</td></tr><tr><td>onmouseup</td><td>当某个鼠标按键在某个对象上被松开时触发</td></tr><tr><td>onmousemove</td><td>当某个鼠标按键在某个对象上被移动时触发</td></tr></tbody></table><pre><code>&gt;&lt;style&gt;      .box &#123;        width: 300px;        height: 300px;        background-color: lightblue;      &#125;&gt;&lt;/style&gt;&gt;&lt;/head&gt;&gt;&gt; &lt;div class=&quot;box&quot;&gt;&lt;/div&gt;&gt; &lt;script&gt;  var box = document.querySelector(&quot;.box&quot;);  box.onmousedown = function () &#123;    box.style.width = &quot;500px&quot;;  &#125;;  box.onmouseup = function () &#123;    box.style.width = &quot;300px&quot;;  &#125;;  box.onmousemove = function () &#123;    box.style.backgroundColor = &quot;pink&quot;;    console.log(&quot;鼠标在我上面移动&quot;);//触发频率特别高  &#125;;&gt; &lt;/script&gt;</code></pre><p><strong>代码解读</strong></p><blockquote><ul><li><code>onmousedown</code>只会在鼠标按键被按下时触发一次</li><li><code>onmouseup</code>只会在鼠标标按键松开时触发一次</li><li><code>onmousemove</code>的触发频率特别高，只要稍会移动下，就会触发好多次<br>相关案例：参考本章综合案例应用中以下两个案例</li><li>案例 1：拖拽动画</li><li>案例 2：拖拽交换两元素位置</li></ul></blockquote><h3 id="三、常见键盘事件（keypress、keydown-和-keyup-事件）"><a href="#三、常见键盘事件（keypress、keydown-和-keyup-事件）" class="headerlink" title="三、常见键盘事件（keypress、keydown 和 keyup 事件）"></a>三、常见键盘事件（keypress、keydown 和 keyup 事件）</h3><blockquote><p>以下是常见的键盘事件</p><table><thead><tr><th>事件名</th><th>描述</th></tr></thead><tbody><tr><td>onkeypress</td><td><strong>被弃用</strong>（他会后于 onkeydown 触发）</td></tr><tr><td>onkeydown</td><td>当某个键盘的键被按下（系统按钮可以识别）</td></tr><tr><td>onkeyup</td><td>当某个键盘的键被松开</td></tr></tbody></table><blockquote><p>注：</p></blockquote><ul><li>一般使用键盘事件都是 <code>document</code> 和 <code>input</code></li><li>如果需要在一个 <code>div</code> 中使用时，需要在<code>div</code>标签中增加<code>contenteditable=&quot;true&quot;</code>，div就会变成一个输入框</li><li>在<code>input</code>输入框<strong>长按</strong>键盘时，第一个字输入后<strong>间隔一段时间</strong>，才会<strong>不停歇地</strong>输入后面的内容</li><li>可以通过 <code>keyup</code> 事件，来获取每次键盘抬起时，文本输入框中的内容</li></ul></blockquote><pre><code>&gt;&lt;style&gt;  .box &#123;    width: 100px;    height: 50px;    background-color: aqua;    margin: 10px;  &#125;&gt;&lt;/style&gt;&gt;&lt;input type=&quot;text&quot; /&gt;&gt;&lt;div class=&quot;box&quot; contenteditable=&quot;true&quot; ;&gt;&lt;/div&gt;&gt;&lt;script&gt;  var user = document.querySelector(&quot;input&quot;);  var box = document.querySelector(&quot;.box&quot;);  document.onkeydown = function () &#123;    // console.log(&quot;按下键盘了&quot;);  &#125;;  user.onkeydown = function () &#123;    // console.log(&quot;在输入内容了哦&quot;);  &#125;;  //div使用键盘事件  box.onkeydown = function () &#123;    console.log(&quot;div也能用&quot;);  &#125;;  user.onkeyup = function () &#123;    // console.log(&quot;键盘松开了&quot;);  &#125;;  //通过 keyup 事件，来获取每次键盘抬起时，文本输入框中的内容  user.onkeyup = function () &#123;    console.log(this.value);  &#125;;&gt;&lt;/script&gt;</code></pre><h3 id="四、常见表单事件"><a href="#四、常见表单事件" class="headerlink" title="四、常见表单事件"></a>四、常见表单事件</h3><blockquote><p>常见的表单事件如下</p><table><thead><tr><th>事件名</th><th>描述</th></tr></thead><tbody><tr><td>focus</td><td>当某元素获得焦点（比如 tab 键或鼠标点击）</td></tr><tr><td>blur</td><td>当某元素失去焦点</td></tr><tr><td>change</td><td>当用户改变域的内容</td></tr></tbody></table></blockquote><p>1、focus 和 blur 事件</p><pre><code>&gt;&lt;input type=&quot;text&quot; /&gt;&gt;&lt;script&gt;  var text = document.querySelector(&quot;input&quot;);  text.onfocus = function () &#123;    //输入框获取焦点时，改变外轮廓    this.style.outline = &quot;2px solid red&quot;; //不能是border  &#125;;  //失去焦点时，取消外轮廓  text.addEventListener(&quot;blur&quot;, fn, false);  function fn() &#123;    this.style.outline = &quot;&quot;;  &#125;&gt;&lt;/script&gt;</code></pre><ol start="2"><li>change 事件<blockquote><ul><li>change 事件，只会在内容发生改变时才触发，如果重复选择，内容不变，不会触发</li></ul></blockquote></li></ol><ul><li>案例：当选中下拉列表中的某个元素，把对应选中的内容显示在控制台</li></ul><pre><code>你最喜欢的水果&gt;&lt;select id=&quot;friut&quot;&gt;&gt;  &lt;option value=&quot;apple&quot;&gt;苹果&lt;/option&gt;&gt;  &lt;option value=&quot;banana&quot;&gt;香蕉&lt;/option&gt;&gt;  &lt;option value=&quot;pear&quot;&gt;梨子&lt;/option&gt;&gt;  &lt;option value=&quot;watermelon&quot;&gt;西瓜&lt;/option&gt;&gt;&lt;/select&gt;&gt;&gt;&lt;script&gt;  var friut = document.getElementById(&quot;friut&quot;);  friut.addEventListener(&quot;change&quot;, fn, false);  function fn() &#123;    var _index = this.selectedIndex; // 被选中元素的下标    var value = this.options[_index].value; // 被选中元素的value值,如 pear    var text = this.options[_index].text; // 被选中元素的文本 如 梨子    console.log(value, text);  &#125;&gt;&lt;/script&gt;</code></pre><blockquote><ul><li><code>_index =this.selectedIndex;</code>：被选中元素的下标</li><li><code>this.options[_index].value;</code>：被选中元素的value值</li><li><code>this.options[_index].text;</code>：被选中元素的文本<blockquote><ul><li><code>.selectedIndex</code>是<code>select</code>自带的属性</li><li>先获取下标，再根据下表获取值和文本</li></ul></blockquote></li></ul></blockquote><ol start="3"><li>二级联动下拉</li></ol><ul><li><p>思路</p><blockquote><ul><li>将省份信息、城市信息添加进下拉菜单</li><li>选择后展示不同省份所对应的城市</li></ul></blockquote></li><li><p>结构搭建</p><blockquote><ul><li>在body里设置省份、城市这两个下拉框<code>select</code>，不写任何值</li><li>用数组保存省份和城市的数据，以对象的形式一一对应</li></ul></blockquote></li></ul><pre><code>&gt;&lt;select name=&quot;&quot; id=&quot;province&quot;&gt;&lt;/select&gt;&lt;!-- &lt;option data-city=&quot;长沙市,株洲市,湘潭市,常德市&quot;&gt;&lt;/option&gt; --&gt;&gt;&lt;select name=&quot;&quot; id=&quot;city&quot;&gt;&lt;/select&gt;//scriptvar data = [  &#123;    province: &quot;湖南&quot;,    city: [&quot;长沙市&quot;, &quot;株洲市&quot;, &quot;湘潭市&quot;, &quot;常德市&quot;],  &#125;,  &#123;    province: &quot;陕西&quot;,    city: [&quot;西安市&quot;, &quot;铜川市&quot;, &quot;咸阳市&quot;, &quot;安康市&quot;, &quot;宝鸡市&quot;],  &#125;,  &#123;    province: &quot;四川&quot;,    city: [&quot;成都市&quot;, &quot;广元市&quot;, &quot;德阳市&quot;, &quot;眉山市&quot;],  &#125;,];</code></pre><ul><li>初始化：填充省份数据和默认的城市数据<blockquote><ul><li>由于每个部分都是用的是函数，所以定义一个初始化函数，统一调用其他函数</li></ul></blockquote></li></ul><pre><code>function init(data) &#123;  //添加省份数据  addProvince(province, data);  //添加默认城市数据  addCityDate(city, data[0].city); // addCitydate(city元素，城市数据)&#125;init(data);</code></pre><blockquote><blockquote><p>注意：要设置一个默认显示的城市信息，在’change’事件发生之前显示</p></blockquote></blockquote><ul><li>添加省份信息<blockquote><ul><li>构建函数</li><li>用for循环遍历数组，有多少省份，就有多少个对象</li><li>每循环到一个对象，就创建一个<code>option</code>元素</li><li>每循环到一个对象，就打点调用它的省份属性，将属性值赋给所创建的<code>option</code>元素，作为它的<code>text</code>值</li><li>每循环一次将<code>option</code>元素传入储存省份信息的下拉菜单中</li><li>为了提升性能，可以创建一个虚拟仓库<code>.createDocumentFragment()</code>来储存每一次创建的<code>option</code></li><li>在循环结束后，用仓库一次性将所有option添加进对应的<code>select</code></li></ul></blockquote></li></ul><pre><code>//添加省份信息 function addProvince(el, data) &#123;   // 用for循环，将省份添加进去   var frag = document.createDocumentFragment();   for (var i = 0; i &lt; data.length; i++) &#123;     var option = document.createElement(&quot;option&quot;);     option.text = data[i].province;     //先存储到仓库里，再添加到province，提升性能     // 将城市信息以自定义属性的方式绑定到省份上     //option.dataset.city = data[i].city;     frag.appendChild(option);   &#125;   el.appendChild(frag); &#125;</code></pre><ul><li>添加城市信息<blockquote><ul><li>构建函数</li><li>用for循环遍历包含了<strong>对应城市信息的数组</strong>，这个数组需要另外的函数来得到</li><li>每循环到一个城市，就创建一个<code>option</code>元素</li><li>每循环到一个城市，就将城市名赋给所创建的<code>option</code>元素，作为它的<code>text</code>值</li><li>每循环一次将<code>option</code>元素传入储存城市信息的下拉菜单中</li><li>为了提升性能，可以创建一个虚拟仓库<code>.createDocumentFragment()</code>来储存每一次创建的<code>option</code></li><li>在循环结束后，用仓库一次性将所有option添加进对应的<code>select</code></li></ul></blockquote></li></ul><pre><code>//要先获得城市数据，el是city元素 function addCityDate(el, citydate) &#123;   el.innerHTML = &quot;&quot;;   var frag = document.createDocumentFragment();   for (var i = 0; i &lt; citydate.length; i++) &#123;     var option = document.createElement(&quot;option&quot;);     option.text = citydate[i];     frag.appendChild(option);   &#125;   el.appendChild(frag); &#125;</code></pre><ul><li>怎么拿到对应城市信息的<strong>数组</strong><blockquote><ul><li>定义一个函数，通过省份名字，返回对应省份的市信息</li><li>使用<code>change</code>事件</li></ul></blockquote></li></ul><blockquote><p><strong>方法1：</strong></p><ul><li>拿到当前选中的省份名<ul><li>用<code>.selectedIndex</code>拿到当前选项的下标</li><li>用<code>.options[_index].text</code>拿到省份名</li></ul></li><li>再获取对应的城市信息，用这个数据来调用添加城市的函数<ul><li>设置一个<code>filter</code>函数来获得当前选中省份的城市信息</li><li>设置一个for循环，循环原始数组</li><li>打点调用出省份属性，当它的值等于上一步得到的<code>text</code>时</li><li>就打点调用出该省份对应的城市数据</li></ul></li><li>拿到城市数据后，调用添加城市信息的函数<blockquote><p>原始数组中城市信息都保存在一个数组中，所以以带点调用来拿到城市数据的方式可以直接获得包含城市信息的数组</p></blockquote></li></ul></blockquote><pre><code>//通过省份名，返回对应的城市信息 province.addEventListener(&quot;change&quot;, connect, false); function connect() &#123;   // 获取当前显示的省份下标   var _index = this.selectedIndex;   //获取它的文本   var text = this.options[_index].text;   //筛选省份，获得对应的城市数据   var citydate = filter(text, data);   //将城市数据添加进city元素   addCityDate(city, citydate); &#125; //筛选省份，获得对应的城市数据 function filter(text, data) &#123;   for (var i = 0; i &lt; data.length; i++) &#123;     if (data[i].province === text) &#123;       return data[i].city;     &#125;   &#125; &#125;</code></pre><blockquote><ul><li><strong>方法2：</strong></li><li>在填充省份信息时，将对应的市数据绑定到每个省份<code>option</code>元素的自定义属性上<br><code>option.dataset.city = data[i].city;</code></li><li>先拿到当前选中的省份名<ul><li>用<code>.selectedIndex</code>拿到当前选项的下标</li><li>调用该省份元素的自定义属性，获取城市信息</li></ul></li><li>根据下标调用自定义属性<blockquote><p>注意：</p></blockquote></li><li>自定义属性的值是用双引号包裹的字符串，不是数组<br><code>&lt;option data-city=&quot;长沙市,株洲市,湘潭市,常德市&quot;&gt;&lt;/option&gt;</code></li><li>赋值时，系统自动把数组转换成了字符串</li><li>所以此时获得的是字符串</li><li>用<code>split</code>方法转换成数组，以<code>,</code>分隔</li><li>拿到数组形式的城市数据后，调用添加城市信息的函数<blockquote><p>方法2只适合数据量较少的情况</p></blockquote></li></ul></blockquote><pre><code>//通过省份名，返回对应的城市信息 province.addEventListener(&quot;change&quot;, connect, false); function connect() &#123;   // 获取当前显示的省份下标   var _index = this.selectedIndex;   //获取它的文本   var text = this.options[_index].text;   //调用自定义属性获得对应的城市数据   var citydate = this.options[_index].dataset.city;   //此时得到的citydate是字符串形式：&quot;西安市,铜川市,咸阳市,安康市,宝鸡市&quot;   //用split转成数组，以，分隔   citydate = citydate.split(&quot;,&quot;);   //将城市数据添加进city元素   addCityDate(city, citydate); &#125;</code></pre><blockquote><blockquote><p>代码实现见html文件</p></blockquote></blockquote><ol start="4"><li>省市区三级联动<br><strong>思路</strong>：</li></ol><ul><li>定义一个html元素，作为容器</li></ul><pre><code>&gt;&lt;div id=&quot;area&quot;&gt;&lt;/div&gt;</code></pre><ul><li><p>填充数据</p><blockquote><ul><li>每个省市区都有对应的id名和<code>fullname</code></li><li>在构建<code>option</code>时，要将id作为<code>option</code>的<code>value</code></li><li>将<code>fullname</code>作为<code>option</code>的<code>text</code>值</li></ul></blockquote></li><li><p>省市县三个下拉菜单都通过js创建</p></li><li><p>初始化：填充省份数据、第一个省的市区数据——一个可递归的填充函数</p><blockquote><ul><li>利用递归执行三次函数，分别创建三个下拉菜单</li><li>利用for循环构建<code>option</code>，并将省份数据和第一个省的市、区数据分别填充进去</li><li>将<code>option</code>添加进<code>select</code></li><li>将<code>select</code>添加进容器<blockquote><p>此时不需要用虚拟仓库</p></blockquote></li></ul></blockquote></li></ul><pre><code>//初始化：填充省份数据和默认的市区数据 init(area, data); function init(el, data) &#123;   // 创建下拉菜单   var select = document.createElement(&quot;select&quot;);   selectArr.push(select);//添加到数组   for (var i = 0; i &lt; data.length; i++) &#123;     var option = document.createElement(&quot;option&quot;);     option.value = data[i].pid || data[i].cid || data[i].aid;     option.text = data[i].fullname;     select.appendChild(option);   &#125;   el.appendChild(select);   //初始化默认数据，市、区   if (data[0].children) &#123;     //如果有第一个children就执行     init(el, data[0].children);     //省的第一个children是市，     //市的第一个children是区，区没有children就停止   &#125; &#125;</code></pre><ul><li>利用<code>change</code>事件，拿到当前省、市id,并调用查找函数和填充函数<blockquote><ul><li>选择省份时，才能拿到省id并填充市数据</li><li>同样的选择市区时，才能拿到市id并填充区数据</li><li>因此，在为了在选择省份后能显示出默认的区数据</li><li>所以在填充市数据后，要把第一个市的<strong>区数据</strong>填充进去，作为默认值</li></ul></blockquote></li></ul><pre><code>//利用change事件，拿到当前点击的省份id selectArr[0].onchange = function () &#123;   var _index = this.selectedIndex;   var id = this.options[_index].value; //省份编码   //找市数据   var children = find(id, data);   //拿到市数据后，将其填充到下拉菜单   addDate(selectArr[1], children);   // 驱动 默认的 区数据的变化   addDate(selectArr[2], children[0].children); &#125;;&gt; //利用change事件，拿到当前点击的市id selectArr[1].onchange = function () &#123;   var _index = this.selectedIndex;   var id = this.options[_index].value; //省份编码    //找区数据   var children = find(id, data);   //拿到区数据后，将其填充到下拉菜单   addDate(selectArr[2], children); &#125;;</code></pre><ul><li>将查到的<code>children</code>数据填充进下拉菜单</li></ul><pre><code>// 填充市区数据,el:selectArr[];date:市/区数据 function addDate(el, date) &#123;   el.innerHTML = &quot;&quot;;   var frag = document.createDocumentFragment();   for (var i = 0; i &lt; date.length; i++) &#123;     var option = document.createElement(&quot;option&quot;);     option.value = date[i].pid || date[i].cid || date[i].aid;     option.text = date[i].fullname;     frag.appendChild(option);   &#125;   el.appendChild(frag); &#125;</code></pre><blockquote><blockquote><p>注意</p></blockquote><ul><li>下拉菜单是在函数内构建的，并不是全局变量，所以在全局变量内定义一个数组，构建<code>&lt;select&gt;</code>后，将它<code>push</code>到数组里，以便其他函数对其元素的调用</li><li>递归的函数，要适用于多种情况，在涉及到<code>pid</code>、<code>cid</code>、<code>aid</code>时，用<code>||</code></li></ul></blockquote><ul><li>取得id后，查找该id的<code>children</code>数据——一个可递归的函数<br><strong>方法1：先深度再广度，全盘搜索</strong><blockquote><p><strong>基础版</strong></p></blockquote></li></ul><pre><code> //用id,找市、区数据 var result = &quot;&quot;; function find(id, data) &#123;   //先深度再广度，每一个for循环查一个省，在这个for循环里，先查省，再查它的children市区   //如果拿到的是市id，那每个省市区都找一遍   for (var i = 0; i &lt; data.length; i++) &#123;     if (data[i].pid === id || data[i].cid === id || data[i].aid === id) &#123;       result = data[i].children;       return result;     //第一轮查的是省pid,查不到，如果它有children就下一轮     //第二轮到市，第三轮到区，区没有children就停止 &#125; else &#123;       if (data[i].children) &#123;         find(id, data[i].children);       &#125;     &#125;   &#125;   return result; &#125;</code></pre><blockquote><p><strong>优化版</strong></p></blockquote><pre><code>&gt;/**&gt; * find 根据pid 或 cid 或aid来查找对应省或市或区的下一级&gt; * id为对应pid或 cid或aid&gt; * data为省市区数据&gt; * n表示递归的深度&gt; */function find(id, data, n) &#123;  var result;  var flag = false; // 用来标记，退出整个for循环  n = n || 100;//设n的默认值为100  return search(id, data, n);  function search(id, data, n) &#123;    // 递归深度达到 或 数据不存在，则退出    if (n === -1 || !data) return;&gt;  // 数据遍历    for (var i = 0; i &lt; data.length; i++) &#123;      if (flag) break; // 退出整个for循环      if (data[i].pid === id || data[i].cid === id || data[i].aid === id) &#123;        result = data[i].children;        flag = true; // 找到了标记为true,用来退出后面所有for循环        break; // 或 return result;      &#125; else &#123;        n--; // 调用递归就开始减        search(id, data[i].children, n); // 值        n++;//下一次for循环的递归层数不能变      &#125;    &#125;    return result;  &#125;&#125;</code></pre><p><strong>方法2：逐级查询</strong></p><blockquote><ul><li>据对应省 pid 查询对应省下面市信息</li><li>根据对应省 pid 和市 cid 查询对应省-市下面的区信息</li><li>根据省 pid 和市 cid 及 aid，查询对应省-市-区下面街道信息。因数据中没有提供区的下一级，即返回 <code>null</code></li><li>我们定义一个对象<code>ids</code>，用来保存要查询的 id，然后当前参数传到 find 函数中</li></ul></blockquote><blockquote><ul><li>查省对应市 var ids &#x3D; {pid: “130000”};</li><li>查省-市对应区var ids &#x3D; {pid: “130000”,cid: “130100”};</li><li>查省-市-区对应街道 var ids &#x3D; {pid: “130000”,cid: “130100”,aid: “130102”};</li></ul></blockquote><pre><code>&gt;/**&gt; * find 根据传递id集合，找到对应市、区、街道信息&gt; * ids查询id集合   &#123; pid: &quot;130000&quot;, cid: &quot;130100&quot; &#125;&gt; * data 查询的数据&gt; */&gt;//   var a = 0;  查看查询的次数function find(ids, data) &#123;  // 遍历对象  for (var key in ids) &#123;    for (var i = 0; i &lt; data.length; i++) &#123;      // a++;      if (        (data[i].pid &amp;&amp; data[i].pid === ids[key]) ||        (data[i].cid &amp;&amp; data[i].cid === ids[key]) ||        (data[i].aid &amp;&amp; data[i].aid === ids[key])      ) &#123;        data = data[i].children; // 每一轮查找下一轮要查询的数据        break; // 找到了就退出，不找了，只退出第一层for循环      &#125;    &#125;  &#125;  // console.log(a);  return data || null;&#125;</code></pre><ul><li>如何记录每个下拉列表当前被选中项的 pid或cid或aid的值呢 ？<blockquote><ul><li>在当前对象上添加一个属性，用来记录</li></ul></blockquote></li></ul><blockquote><ul><li><code>init()</code>函数初始化时，给对象添加对应属性保存对应值</li></ul></blockquote><pre><code>data[0].pid &amp;&amp; (select.pid = data[0].pid);data[0].cid &amp;&amp; (select.cid = data[0].cid);data[0].aid &amp;&amp; (select.aid = data[0].aid);</code></pre><blockquote><ul><li>对应的 change 事件中</li></ul></blockquote><pre><code>this.pid = this.options[_index].value;// 或this.cid = this.options[_index].value;// 或this.aid = this.options[_index].value;</code></pre><blockquote><ul><li>addDate 函数中</li></ul></blockquote><pre><code>el.pid &amp;&amp; (el.pid = data[0].pid);el.cid &amp;&amp; (el.cid = data[0].cid);el.aid &amp;&amp; (el.aid = data[0].aid);</code></pre><blockquote><ul><li>完整实现</li></ul></blockquote><pre><code>&gt;&lt;div id=&quot;area&quot;&gt;&lt;/div&gt;&gt;&lt;script&gt;  // 我们需要利用JS来动态创建三个下拉列表，同时把对应的数据填充好，然后再一次性插入到页面中来  var area = document.getElementById(&quot;area&quot;);  var selectArr = []; // 用来保存初始的三个下拉列表  init(area, data);  // 初始化函数  function init(el, data) &#123;    // 创建下拉列表    var select = document.createElement(&quot;select&quot;); // 创建一个下拉列表    selectArr.push(select);    // select.addEventListener(&#39;change&#39;,fn,false);    for (var i = 0; i &lt; data.length; i++) &#123;      // 创建option      var option = document.createElement(&quot;option&quot;);      // 这里是重点，这个对应的id等下要用来找数据      option.value = data[i].pid || data[i].cid || data[i].aid;      option.text = data[i].fullname;      select.appendChild(option);    &#125;    el.appendChild(select);&gt;    // 保存对应pid或cid 或 aid到对象身上    data[0].pid &amp;&amp; (select.pid = data[0].pid);    data[0].cid &amp;&amp; (select.cid = data[0].cid);    data[0].aid &amp;&amp; (select.aid = data[0].aid);&gt;    // 递归调用 初始化市 区数据    if (data[0].children) &#123;      init(el, data[0].children);    &#125;  &#125;&gt;  // 开始级省份下拉列表添加change事件  selectArr[0].onchange = function () &#123;    // 查找省份对应的id，然后用他来查找省份对应的市数据    var _index = this.selectedIndex;    var pid = this.options[_index].value;    this.pid = pid; // 保存pid    // 找到对应省份的市数据 ，首先找到对应省份，然后找到对应的市数据，然后再填充    // 直接拿着对应的省份，去所有数据中找，然后把对应市数据拿到    var children = find(&#123; pid: pid &#125;, data);    // 拿省份对应的市数据，那就开始填充数据    addDate(selectArr[1], children);    // 驱动区数据的变化    addDate(selectArr[2], children[0].children);  &#125;;&gt;  // 开始市级下拉列表添加change事件  selectArr[1].onchange = function () &#123;    var _index = this.selectedIndex;    var cid = this.options[_index].value;    this.cid = cid; // 保存id    // 拿市 id要去找对应的区数据&gt;    var children = find(&#123; pid: selectArr[0].pid, cid: cid &#125;, data);    // 填充数据    addDate(selectArr[2], children);  &#125;;&gt;  selectArr[2].onchange = function () &#123;    var _index = this.selectedIndex;    var id = this.options[_index].value;    this.aid = id; // 保存aid  &#125;;&gt;  // 填充数据，el谁里面填数据 data用来填充的数据  function addDate(el, data) &#123;    el.innerHTML = &quot;&quot;; // 往el中填数据前，要清空之前数据    el.pid &amp;&amp; (el.pid = data[0].pid);    el.cid &amp;&amp; (el.cid = data[0].cid);    el.aid &amp;&amp; (el.aid = data[0].aid);    var frag = document.createDocumentFragment();    for (var i = 0; i &lt; data.length; i++) &#123;      var option = document.createElement(&quot;option&quot;);      option.value = data[i].pid || data[i].cid || data[i].aid;      option.text = data[i].fullname;      frag.appendChild(option);    &#125;    el.appendChild(frag);  &#125;&gt;  function find(ids, data) &#123;    // 遍历对象    for (var key in ids) &#123;      for (var i = 0; i &lt; data.length; i++) &#123;        // a++;        if (          (data[i].pid &amp;&amp; data[i].pid === ids[key]) ||          (data[i].cid &amp;&amp; data[i].cid === ids[key]) ||          (data[i].aid &amp;&amp; data[i].aid === ids[key])        ) &#123;          data = data[i].children; // 每一轮查找下一轮要查询的数据          break; // 找到了就退出，不找了，只退出第一层for循环        &#125;      &#125;    &#125;    // console.log(a);    return data || null;  &#125;&gt;  // 无关函数，用来询对象身上的pid或cid 或 aid属性  function show() &#123;    for (var i = 0; i &lt; selectArr.length; i++) &#123;      console.log(selectArr[i].pid || selectArr[i].cid || selectArr[i].aid);    &#125;  &#125;&gt;&lt;/script&gt;</code></pre><h3 id="五、DOM-事件流"><a href="#五、DOM-事件流" class="headerlink" title="五、DOM 事件流"></a>五、DOM 事件流</h3><ol><li>事件流<blockquote><p>在了解什么是事件流之前，我们先来回答下面这个问题。</p><ul><li>以下图中的四个圆<code>A、B、C、D</code>共用一个圆心，这个圆心称为同心圆。如果用手指点击中心，那我们按住了哪个圆？</li><li>实际上我们<strong>按住了所有的圆</strong><img src="同心圆.png"></li></ul></blockquote></li></ol><blockquote><blockquote><p>网页事件监听也是类似的,如果多个元素发生嵌套，当我们点击最里面的元素，本质上相当于点击了所有元素。</p></blockquote></blockquote><p><strong>假设</strong></p><blockquote><p>以上图中的<code>A、B、C、D</code>为嵌套的 4 个 div 元素，当我在中心点点击后，则相当于四个 div 元素都触发了click点击事件。那事件触发的顺序是以下那种情况？</p><ul><li>第一种情况： A —&gt; B —&gt; C —&gt; D</li><li>第二种情况： D —&gt; C —&gt; B —&gt; A<br>以上两种情况<strong>都有可能</strong>，但在具体的应用中，到底是情况一，还是情况二呢？<br>这就需要我们了解事件流</li><li>事件流描述了页面接收事件的顺序</li><li>事件流分为 3 个阶段：<strong>事件捕获</strong>、<strong>到达目标</strong>、<strong>事件冒泡</strong><blockquote><p>事件的传播本质是：先从外到内，到达实际的目标元素，然后再从内到外</p></blockquote></li><li><strong>从外到内</strong>的阶段称为：事件捕获阶段</li><li><strong>从内到外</strong>的阶段称为：事件冒泡阶段<img src="事件流.png"></li></ul></blockquote><blockquote><blockquote><p>注：</p><ul><li>事件冒泡： 最先由<code>IE公司</code>提出，事件定义为从最具体的元素开始触发，然后向上传播至文档</li><li>事件捕获： 最先由<code>网景公司</code>提出，事件定义为从最外层（最不具体的节点）开骀先收到（触发）事件，然后再传到具体的节点。</li><li>最后规范中规定事件流分为 3 个阶段：事件捕获、到达目标、事件冒泡</li></ul></blockquote></blockquote><ol start="2"><li>如何监听事件捕获与冒泡<blockquote><p><strong>监听事件有两种方式：</strong></p><ul><li>on 开头方式</li><li>addEventListener 方式<blockquote><p>那这两种方式在事件监听上有何不同 ？</p></blockquote></li></ul></blockquote></li></ol><ul><li>on开头方式，只能监听到事件冒泡阶段，不支持监听事件捕获阶段<blockquote><ul><li>书写顺序不影响冒泡顺序，只会从内往外触发</li></ul></blockquote></li></ul><pre><code>&gt;&lt;div class=&quot;box1&quot;&gt;&gt;  &lt;div class=&quot;box2&quot;&gt;&gt;    &lt;div class=&quot;box3&quot;&gt;&lt;/div&gt;&gt;  &lt;/div&gt;&gt;&lt;/div&gt;&gt;&lt;script&gt;  var box1 = document.querySelector(&quot;.box1&quot;);  var box2 = document.querySelector(&quot;.box2&quot;);  var box3 = document.querySelector(&quot;.box3&quot;);   box2.onclick = function () &#123;    console.log(&quot;冒泡2&quot;);  &#125;;   box1.onclick = function () &#123;    console.log(&quot;冒泡1&quot;);  &#125;;   box3.onclick = function () &#123;    console.log(&quot;冒泡3&quot;);  &#125;;  //冒泡3-&gt;冒泡2-&gt;冒泡1&gt;&lt;/script&gt;</code></pre><ul><li>addEventListener 方式监听事件<blockquote><p>由它的第三个参数决定，是监听捕获还是冒泡阶段</p><ul><li>如果第三个参数是true ， 表示监听捕获阶段</li><li>如果第三个参数是false ，表示监听冒泡阶段</li><li>同一个事件的不同阶段，先执行捕获阶段，再执行冒泡阶段</li><li>不同事件的同一阶段，如果是”true”则由外向内执行，如果是”false”则由内向外执行，书写顺序不影响执行顺序</li></ul></blockquote></li></ul><pre><code>// 监听捕获阶段element.addEventListener(&quot;click&quot;, function () &#123;&#125;, true);&gt;// 监听冒泡阶段element.addEventListener(&quot;click&quot;, function () &#123;&#125;, false);</code></pre><pre><code>&gt;&lt;div class=&quot;box1&quot;&gt;&gt;  &lt;div class=&quot;box2&quot;&gt;&gt;    &lt;div class=&quot;box3&quot;&gt;&lt;/div&gt;&gt;  &lt;/div&gt;&gt;&lt;/div&gt;&gt;&lt;script&gt;  var box1 = document.querySelector(&quot;.box1&quot;);  var box2 = document.querySelector(&quot;.box2&quot;);  var box3 = document.querySelector(&quot;.box3&quot;);  box1.addEventListener(    &quot;click&quot;,    function () &#123;      console.log(&quot;冒泡1&quot;);    &#125;,    false  );  box2.addEventListener(    &quot;click&quot;,    function () &#123;      console.log(&quot;捕获2&quot;);    &#125;,    true  );  box2.addEventListener(    &quot;click&quot;,    function () &#123;      console.log(&quot;冒泡2&quot;);    &#125;,    false  );  box3.addEventListener(    &quot;click&quot;,    function () &#123;      console.log(&quot;冒泡3&quot;);    &#125;,    false  );  //捕获2-&gt;冒泡3-&gt;冒泡2-&gt;冒泡1&gt;&lt;/script&gt;</code></pre><ol start="3"><li>mouseenter 和 mouseleave 事件不支持冒泡<table><thead><tr><th>事件名</th><th>描述</th></tr></thead><tbody><tr><td>mouseenter</td><td>当鼠标进入某个对象（相似事件 onmouseover）不能向上冒泡</td></tr><tr><td>mouseleave</td><td>当鼠标离开某个对象（相似事件 onmouseout）不能向上冒泡</td></tr></tbody></table></li></ol><pre><code>&gt;&lt;div class=&quot;box1&quot;&gt;&gt;  &lt;div class=&quot;box2&quot;&gt;&lt;/div&gt;&gt;&lt;/div&gt;&gt;&lt;script&gt;  var box1 = document.querySelector(&quot;.box1&quot;);  var box2 = document.querySelector(&quot;.box2&quot;);  //   mouseenter不会冒泡  box1.addEventListener(    &quot;mouseenter&quot;,    function () &#123;      console.log(&quot;冒泡移入1&quot;);    &#125;,    false  );  box2.addEventListener(    &quot;mouseenter&quot;,    function () &#123;      console.log(&quot;冒泡移入2&quot;);    &#125;,    false  );  //mouseover会冒泡  box1.addEventListener(    &quot;mouseover&quot;,    function () &#123;      console.log(&quot;冒泡移入1&quot;);    &#125;,    false  );  box2.addEventListener(    &quot;mouseover&quot;,    function () &#123;      console.log(&quot;冒泡移入2&quot;);    &#125;,    false  );&gt;&lt;/script&gt;</code></pre><blockquote><blockquote><p>当鼠标从外往内移入时</p><ul><li>mouseenter：冒泡移入1-&gt;冒泡移入2</li><li>mouseover：冒泡移入1-&gt;冒泡移入2-&gt;冒泡移入1，也就是当鼠标放在里面的div时，会同时触发两个冒泡事件</li></ul></blockquote></blockquote><ol start="4"><li><p>on 与 addEventListener 两者监听事件的区别</p><table><thead><tr><th>区别</th><th>on 方式监听</th><th>addEventListener 方式监听</th></tr></thead><tbody><tr><td>事件捕获与冒泡</td><td>只能监听到冒泡阶段</td><td>第三个参数是 true，监听捕获阶段</td></tr><tr><td>事件处理函数</td><td>同一事件，只能有一个</td><td>同一事件，任意个都行</td></tr><tr><td>事件处理函数执行顺序</td><td>写在后面的覆盖前面的，以最后的一个为主</td><td>先执行捕获阶段，再执行冒泡阶段，在这两个阶段，以代码书写时的顺序为主，从上往下执行每个事件处理函数</td></tr></tbody></table></li><li><p>经典面试题</p><blockquote><p>面试真题</p><ul><li>给一个 DOM 同时绑定两个点击事件，一个用捕获，一个用冒泡，说下会执行几次事件，然后会先执行冒泡还是捕获（知乎）</li></ul></blockquote></li></ol><blockquote><ul><li>会执行两次事件，先执行捕获事件，再执行冒泡事件，不管两个事件绑定的先后顺序如何，结果都不会变。</li></ul></blockquote><h3 id="六、event-事件对象"><a href="#六、event-事件对象" class="headerlink" title="六、event 事件对象"></a>六、event 事件对象</h3><blockquote><ul><li>事件处理函数提供了一个形参，它是一个对象，封装了本次<strong>事件的所有细节</strong></li><li>这个参数通常用单词<code>event</code>或<code>e</code>、<code>ev</code>表示</li></ul></blockquote><pre><code>box.onmousemove = function (e) &#123;  // 对象e就是这次事件的 “事件对象”&#125;;</code></pre><ol><li>鼠标位置<blockquote><p>事件对象 event 上提供了鼠标位置相关的属性，具体如下表</p><table><thead><tr><th>属性</th><th>描述</th></tr></thead><tbody><tr><td>clientX</td><td>鼠标指针相对于<strong>浏览器</strong>的水平坐标</td></tr><tr><td>clientY</td><td>鼠标指针相对于<strong>浏览器</strong>的垂直坐标</td></tr><tr><td>pageX</td><td>鼠标指针相对于<strong>整张网页</strong>的水平坐标</td></tr><tr><td>pageY</td><td>鼠标指针相对于<strong>整张网页</strong>的垂直坐标</td></tr><tr><td>offsetX</td><td>鼠标指针相对于<strong>事件源元素</strong>的水平坐标</td></tr><tr><td>offsetY</td><td>鼠标指针相对于<strong>事件源元素</strong>的垂直坐标</td></tr></tbody></table></blockquote></li></ol><pre><code>&gt;&lt;style&gt;  body &#123;    margin: 0;    height: 3000px;  &#125;  .box &#123;    width: 200px;    height: 200px;    border: 50px solid skyblue;    background-color: khaki;    margin: 100px;  &#125;&gt;&lt;/style&gt;&gt;&gt;&lt;div class=&quot;box&quot;&gt;&lt;/div&gt;&gt;&lt;script&gt;  var box = document.querySelector(&quot;.box&quot;);  box.onclick = function (e) &#123;    console.log(&quot;clientX:&quot; + e.clientX);    console.log(&quot;clientY:&quot; + e.clientY);    console.log(&quot;pageX:&quot; + e.pageX);    console.log(&quot;pageY:&quot; + e.pageY);    console.log(&quot;offsetX:&quot; + e.offsetX);    console.log(&quot;offsetY:&quot; + e.offsetY);  &#125;;&gt;&lt;/script&gt;</code></pre><ul><li><p>滚动条到顶时</p><blockquote><ul><li>此时<code>client</code>与<code>page</code>得到的数值一样</li><li><code>offset</code>：相对于<strong>事件源元素</strong>的坐标，如果点击的位置在边框里，则会得到负值；事件源元素不包括边框<img src="鼠标位置-滚动条到顶.png"></li></ul></blockquote></li><li><p>拉动滚动条时</p><blockquote><ul><li>移动滚动条时，<code>pageY</code>会受到影响，与<code>clientY</code>数值不一样<img src="鼠标位置—移动滚动条.png"></li></ul></blockquote></li></ul><ol start="2"><li>e.key 和 e.code<blockquote><p>事件对象上提供了获取<strong>键盘键码</strong>相关的属性，主要与<code>onkeydown</code>、<code>onkeyup</code>事件结合使用。</p><table><thead><tr><th>属性名</th><th>用处</th></tr></thead><tbody><tr><td>key</td><td>返回用户按下的物理按键的值。按下的键如果是可打印内容，返回的就是对应按扭的值；如果是一个控制键或特殊字符，返回一个事先定义好的值，参考以下表</td></tr><tr><td>code</td><td>表示键盘上的物理键</td></tr><tr><td>charCode</td><td>被弃用</td></tr><tr><td>keyCode</td><td>被弃用</td></tr></tbody></table></blockquote></li></ol><blockquote><ul><li>控制键或特殊字符<table><thead><tr><th>按键</th><th>键值</th></tr></thead><tbody><tr><td>四个方键← ↑ → ↓</td><td><code>ArrowLeft</code>、<code>ArrowUp</code>、<code>ArrowRight</code>、<code>ArrowDown</code></td></tr><tr><td>回车键</td><td>Enter</td></tr><tr><td>空格键</td><td>“”</td></tr><tr><td>删除键</td><td>Backspace</td></tr></tbody></table></li></ul></blockquote><pre><code>document.onkeydown = function (e) &#123;  console.log(&quot;key:&quot; + e.key);  console.log(&quot;code:&quot; + e.code);&#125;;</code></pre><ol start="3"><li>e.altKey、e.ctrlKey、e.shiftKey<table><thead><tr><th>属性名</th><th>说明</th></tr></thead><tbody><tr><td>ctrlKey</td><td>表示事件触发时<code>ctrl键</code>是否按下；如果按下，则<code>e.ctrlKey</code>返回值为<code>true</code>，否则为<code>false</code></td></tr><tr><td>altKey</td><td>表示事件触发时<code>alt键</code>是否按下；如果按下，则<code>e.altKey</code>返回值为<code>true</code>，否则为<code>false</code></td></tr><tr><td>shiftKey</td><td>表示事件触发时<code>shift键</code>是否按下；如果按下，则 <code>e.shiftKey</code>返回值为<code>true</code>，否则为<code>false</code></td></tr></tbody></table></li></ol><pre><code>document.onkeydown = function (e) &#123;  console.log(&quot;altkey:&quot; + e.altKey);  console.log(&quot;ctrlkey:&quot; + e.ctrlKey);  console.log(&quot;shift:&quot; + e.shiftKey);&#125;;</code></pre><ol start="4"><li>e.preventDefault() 方法<blockquote><ul><li><code>e.preventDefault()</code>方法用来阻止事件产生的**”默认动作”**</li><li>常见图片默认的拖拽行为、超链接的默认点击跳转行为</li></ul></blockquote></li></ol><pre><code>&gt;&lt;img src=&quot;../src/games/flower.png&quot; alt=&quot;&quot; width=&quot;300px&quot; /&gt;&gt;&lt;a href=&quot;www.baidu.com&quot;&gt;百度&lt;/a&gt;&gt; &lt;script&gt;  var img = document.querySelector(&quot;img&quot;);  var a = document.querySelector(&quot;a&quot;);  img.onmousedown = function (e) &#123;    e.preventDefault();  &#125;;  a.onclick = function (e) &#123;    e.preventDefault();  &#125;;&gt;&lt;/script&gt;</code></pre><ol start="5"><li>e.stopPropagation() 方法<blockquote><ul><li><code>e.stopPropagation()</code>方法<strong>用来阻止事件冒泡</strong></li><li>在一些场合，非常有必要切断事件继续传播，否则会造成页面特效显示出bug</li></ul></blockquote></li></ol><pre><code>&gt;&lt;div class=&quot;box1&quot;&gt;&gt;  &lt;div class=&quot;box2&quot;&gt;&lt;/div&gt;&gt;&lt;/div&gt;&gt;&lt;script&gt;  var box1 = document.querySelector(&quot;.box1&quot;);  var box2 = document.querySelector(&quot;.box2&quot;);  box1.onclick = function (e) &#123;    console.log(&quot;冒泡box1&quot;);  &#125;;  box2.onclick = function (e) &#123;    console.log(&quot;冒泡box2&quot;);    e.stopPropagation();//加了之后，阻止冒泡  &#125;;&gt;&lt;/script&gt;</code></pre><ol start="6"><li>案例<blockquote><ul><li><code>ctrl+a</code>改变网页背景颜色</li></ul></blockquote></li></ol><pre><code>&gt;&lt;script&gt;  document.onkeydown = function (e) &#123;    console.log(e.key);    console.log(e.ctrlKey);    if (e.key === &quot;a&quot; &amp;&amp; e.ctrlKey) &#123;      document.body.style.backgroundColor = &quot;red&quot;;    &#125;  &#125;;&gt;&lt;/script&gt;</code></pre><h3 id="七、事件委托"><a href="#七、事件委托" class="headerlink" title="七、事件委托"></a>七、事件委托</h3><h4 id="什么是事件委托"><a href="#什么是事件委托" class="headerlink" title="什么是事件委托"></a>什么是事件委托</h4><blockquote><ul><li>事件委托可以理解为，本来是 A 要处理的事情，现在委托给了 B 来处理，事件委托也称为<strong>事件代理</strong>。</li><li>事件委托是通过<strong>事件冒泡机制</strong>来实现，本来由各个子节点处理的事情，现在全部委托给其<strong>父节点</strong>来处理。<blockquote><p>接下来我们通过下面这个案例来演示，对比常规方法和事件委托处理之间的优缺点。</p></blockquote></li></ul></blockquote><ol><li>案例1：批量给子元素添加事件<blockquote><ul><li>页面上有一个无序列表<ul>，它内部共有10个<li>元素，请批量给它们添加点击事件监听</li><li>实现效果：点击哪个<li>元素，哪个<li>元素的文字颜色就变红</li></ul></blockquote></li></ol><pre><code>&gt;&lt;ul&gt;&gt;  &lt;li&gt;我是第1个li&lt;/li&gt;&gt;  &lt;li&gt;我是第2个li&lt;/li&gt;&gt;  &lt;li&gt;我是第3个li&lt;/li&gt;&gt;  &lt;li&gt;我是第4个li&lt;/li&gt;&gt;  &lt;li&gt;我是第5个li&lt;/li&gt;&gt;  &lt;li&gt;我是第6个li&lt;/li&gt;&gt;  &lt;li&gt;我是第7个li&lt;/li&gt;&gt;  &lt;li&gt;我是第8个li&lt;/li&gt;&gt;  &lt;li&gt;我是第9个li&lt;/li&gt;&gt;  &lt;li&gt;我是第10个li&lt;/li&gt;&gt;&lt;/ul&gt;&gt;&lt;script&gt;  //点击哪个&lt;li&gt;元素，哪个&lt;li&gt;元素的文字颜色就变红  var ul = document.getElementsByTagName(&quot;ul&quot;)[0];  var liList = document.getElementsByTagName(&quot;li&quot;);&gt;  // 常规思路：for循环给每个li添加点击事件  for (var i = 0; i &lt; liList.length; i++) &#123;    liList[i].onclick = function () &#123;      this.style.color = &quot;red&quot;;    &#125;;  &#125;&gt;  //事件委托 基础版：  ul.onclick = function (e) &#123;    console.log(e.target); // &lt;li&gt;....&lt;/li&gt;;    console.log(e.currentTarget); // &lt;ul&gt;...&lt;/ul&gt;;    e.target.style.color = &quot;red&quot;; //这时，如果点击ul的区域，那所有li都会变色  &#125;;&gt;    //事件委托 优化版：  ul.onclick = function (e) &#123;    var tag = e.target.tagName; //获取元素的标签名，大写形式    if (tag.toLowerCase() === &quot;li&quot;) &#123;      e.target.style.color = &quot;red&quot;;    &#125;  &#125;;&gt;&lt;/script&gt;</code></pre><blockquote><blockquote><ul><li><code>.toLowerCase()</code>大写转小写</li></ul></blockquote></blockquote><ul><li><p>常规思路：for循环批量给li添加点击事件</p><blockquote><p>批量添加事件监听的<strong>性能问题</strong></p><ul><li>每一个事件监听注册都会消耗一定的系统内存，而批量添加事件会导致监听数量太多，内存消耗会非常大</li><li>再加上，每个 li 的事件处理函数都是不同的函数，这些函数本身也会占用内存</li></ul></blockquote></li><li><p>事件委托方式处理</p><blockquote><ul><li>我们把所有子节点 li 的 click 事件全部委托给到他们对共同的父节点 ul 来处理</li><li>给 ul 添加 click 事件，当点击每个 li 时，其 li 上的 click 事件会通过冒泡的机制，来触发父节点上的 click 事件<blockquote><p>事件委托通常需要结合事件对象身上的<code>target</code>和 <code>currentTarget</code>属性来处理</p></blockquote></li></ul></blockquote></li></ul><table><thead><tr><th>属性</th><th>描述</th></tr></thead><tbody><tr><td>target</td><td>触发此事件的最早元素，即 “事件源元素”</td></tr><tr><td>currentTarget</td><td>绑定事件的那个元素</td></tr></tbody></table><blockquote><p>事件委托的<strong>优点</strong></p><ul><li>减少了事件监听的个数，同时绑定的函数个数也大大减少了。这些减少，本质就是减少内存的消耗，从而提高性能。</li></ul></blockquote><ol start="2"><li>案例 2：给新增元素动态绑定事件<blockquote><ul><li>页面上有一个无序列表<code>&lt;ul&gt;</code>，它内部没有<code>&lt;li&gt;</code> 元素，请制作一个按钮，点击这个按钮就能<strong>增加</strong>一个 li 元素</li><li>并且要求每个 li 上有一个<strong>删除</strong>按扭，点击后删除当前这个 li 元素</li></ul></blockquote></li></ol><ul><li>常规方法<blockquote><ul><li><code>span</code>的删除操作在新增按钮的点击事件里，因为在外面获取不到<code>span</code></li></ul></blockquote></li></ul><pre><code>&lt;button id=&quot;J_add&quot;&gt;新增&lt;/button&gt;&gt;&lt;ul id=&quot;J_list&quot;&gt;&gt;  &lt;!-- &lt;li&gt;第1个li元素&lt;span&gt;删除&lt;/span&gt;&lt;/li&gt;&gt;  &lt;li&gt;第2个li元素&lt;span&gt;删除&lt;/span&gt;&lt;/li&gt;&gt;  &lt;li&gt;第3个li元素&lt;span&gt;删除&lt;/span&gt;&lt;/li&gt;&gt;  &lt;li&gt;第4个li元素&lt;span&gt;删除&lt;/span&gt;&lt;/li&gt; --&gt;&gt;&lt;/ul&gt;&gt;&lt;script&gt;  var addButton = document.getElementById(&quot;J_add&quot;);  var ul = document.getElementById(&quot;J_list&quot;);  var span = document.querySelector(&quot;span&quot;);  var sum = 0;&gt;  addButton.onclick = function () &#123;    //新增li元素    var li = document.createElement(&quot;li&quot;);    sum++;    li.innerText = &quot;第&quot; + sum + &quot;个li元素&quot;;    ul.appendChild(li);    //新增span元素    var span = document.createElement(&quot;span&quot;);    span.innerText = &quot;删除&quot;;    li.appendChild(span);    ul.appendChild(li);&gt;    //删除操作——常规版 parent.removeChild(child)    span.onclick = function () &#123;      var li = this.parentNode;      li.parentNode.removeChild(li);    &#125;;  &#125;;&gt;&lt;/script&gt;</code></pre><ul><li>事件委托版</li></ul><pre><code>&lt;button id=&quot;J_add&quot;&gt;新增&lt;/button&gt;&gt;&lt;ul id=&quot;J_list&quot;&gt;&gt;  &lt;!-- &lt;li&gt;第1个li元素&lt;span&gt;删除&lt;/span&gt;&lt;/li&gt;&gt;  &lt;li&gt;第2个li元素&lt;span&gt;删除&lt;/span&gt;&lt;/li&gt;&gt;  &lt;li&gt;第3个li元素&lt;span&gt;删除&lt;/span&gt;&lt;/li&gt;&gt;  &lt;li&gt;第4个li元素&lt;span&gt;删除&lt;/span&gt;&lt;/li&gt; --&gt;&gt;&lt;/ul&gt;&gt;&lt;script&gt;  var addButton = document.getElementById(&quot;J_add&quot;);  var ul = document.getElementById(&quot;J_list&quot;);  var span = document.querySelector(&quot;span&quot;);  var sum = 0;&gt;  addButton.onclick = function () &#123;    //新增li元素    var li = document.createElement(&quot;li&quot;);    sum++;    li.innerText = &quot;第&quot; + sum + &quot;个li元素&quot;;    ul.appendChild(li);    //新增span元素    var span = document.createElement(&quot;span&quot;);    span.innerText = &quot;删除&quot;;    li.appendChild(span);    ul.appendChild(li);&#125;;&gt;  //事件委托版  oul.onclick = function (e) &#123;    var tag = e.target;    if (tag.tagName.toLowerCase() !== &quot;span&quot;) return;    this.removeChild(tag.parentNode); //this是ul  &#125;;&gt;&lt;/script&gt;</code></pre><blockquote><blockquote><p>注意：</p><ul><li>如果写成这样是报错的，因为此时的<code>tag</code>只是保存着字符串<code>&quot;span&quot;</code>的变量，找不到它的父元素</li></ul></blockquote></blockquote><pre><code>tag = e.target.tagName.toLowerCase()if (tag !== &quot;span&quot;) return;    this.removeChild(tag.parentNode); </code></pre><ol start="3"><li>案例 3：选项卡效果<blockquote><p>涉及知识点</p><ul><li>事件委托</li><li>自定属性操作 dataset</li><li>节点操作 firstElementChild</li></ul></blockquote></li></ol><ul><li>方式一：用相同的下标</li></ul><pre><code>&gt;&lt;style&gt;  ul,  li &#123;    margin: 0;    padding: 0;    list-style: none;  &#125;  .box &#123;    width: 400px;    height: 250px;    margin: 50px;    border: 1px solid #000;  &#125;  .box-tab &#123;    width: 100%;    height: 50px;    line-height: 50px;    text-align: center;  &#125;  .box-tab li &#123;    float: left;    width: 80px;    cursor: pointer;  &#125;  .box-tab li.current &#123;    color: red;  &#125;  .box-show .item &#123;    width: 100%;    height: 200px;    background-color: #ddd;    display: none;    font-size: 30px;    text-align: center;  &#125;&gt;&lt;/style&gt;&gt;&lt;div class=&quot;box&quot;&gt;&gt;  &lt;ul class=&quot;box-tab&quot; id=&quot;J_tab&quot;&gt;&gt;    &lt;li class=&quot;current&quot;&gt;最新&lt;/li&gt;&gt;    &lt;li&gt;内地&lt;/li&gt;&gt;    &lt;li&gt;港台&lt;/li&gt;&gt;    &lt;li&gt;欧美&lt;/li&gt;&gt;    &lt;li&gt;韩国&lt;/li&gt;&gt;  &lt;/ul&gt;&gt;  &lt;div class=&quot;box-show&quot;&gt;&gt;    &lt;div class=&quot;item&quot; style=&quot;display: block&quot;&gt;最新&lt;/div&gt;&gt;    &lt;div class=&quot;item&quot;&gt;内地&lt;/div&gt;&gt;    &lt;div class=&quot;item&quot;&gt;港台&lt;/div&gt;&gt;    &lt;div class=&quot;item&quot;&gt;欧美&lt;/div&gt;&gt;    &lt;div class=&quot;item&quot;&gt;韩国&lt;/div&gt;&gt;  &lt;/div&gt;&gt;&lt;/div&gt;&gt;&gt;&lt;script&gt;  var oUL = document.getElementById(&quot;J_tab&quot;);  var liList = document.querySelectorAll(&quot;.box-tab li&quot;);  var items = document.querySelectorAll(&quot;.box-show .item&quot;);&gt;  var currentLi = oUL.firstElementChild; //默认第一个  var currentItem = items[0]; //默认第一个   //给每一个li添加下标  for (var i = 0; i &lt; liList.length; i++) &#123;    liList[i].index = i;  &#125;  oUL.onclick = function (e) &#123;    var tag = e.target; //获取事件源元素    var tagName = tag.tagName.toLowerCase();    //如果事件源是li    if (tagName !== &quot;li&quot;) return;    //移除上一个点击元素的类名    currentLi.classList.remove(&quot;current&quot;);    //给每个被点击的li添加current    tag.classList.add(&quot;current&quot;);    currentLi = tag;     //切换下方菜单    var num = tag.index; //获得当前点击元素的下标    currentItem.style = &quot;display:none&quot;; //将上一个点击的元素隐藏    items[num].style = &quot;display:block&quot;;    currentItem = items[num];  &#125;;&gt;&lt;/script&gt;</code></pre><ul><li>方式二：用相同的属性<blockquote><ul><li>使用属性选择器获得与<code>li</code>的id相同的展示页</li><li>属性选择器<code>标签名/类名[属性=&quot;&quot;]</code></li></ul></blockquote></li></ul><pre><code>&gt;&lt;div class=&quot;box&quot;&gt;&gt;  &lt;ul class=&quot;box-tab&quot; id=&quot;J_tab&quot;&gt;&gt;    &lt;li class=&quot;current&quot; data-id=&quot;a&quot;&gt;最新&lt;/li&gt;&gt;    &lt;li data-id=&quot;b&quot;&gt;内地&lt;/li&gt;&gt;    &lt;li data-id=&quot;c&quot;&gt;港台&lt;/li&gt;&gt;    &lt;li data-id=&quot;d&quot;&gt;欧美&lt;/li&gt;&gt;    &lt;li data-id=&quot;e&quot;&gt;韩国&lt;/li&gt;&gt;  &lt;/ul&gt;&gt;  &lt;div class=&quot;box-show&quot;&gt;&gt;    &lt;div class=&quot;item&quot; data-id=&quot;a&quot; style=&quot;display: block&quot;&gt;最新&lt;/div&gt;&gt;    &lt;div class=&quot;item&quot; data-id=&quot;b&quot;&gt;内地&lt;/div&gt;&gt;    &lt;div class=&quot;item&quot; data-id=&quot;c&quot;&gt;港台&lt;/div&gt;&gt;    &lt;div class=&quot;item&quot; data-id=&quot;d&quot;&gt;欧美&lt;/div&gt;&gt;    &lt;div class=&quot;item&quot; data-id=&quot;e&quot;&gt;韩国&lt;/div&gt;&gt;  &lt;/div&gt;&gt;&lt;/div&gt;&gt;&lt;script&gt;  var oUL = document.getElementById(&quot;J_tab&quot;);  var items = document.querySelectorAll(&quot;.box-show .item&quot;);   var currentLi = oUL.firstElementChild; //默认第一个  var currentItem = items[0]; //默认第一个   oUL.onclick = function (e) &#123;    var tag = e.target; //获取事件源元素    var tagName = tag.tagName.toLowerCase();    //如果事件源是li    if (tagName !== &quot;li&quot;) return;    //移除上一个点击元素的类名    currentLi.classList.remove(&quot;current&quot;);    //给每个被点击的li添加current    tag.classList.add(&quot;current&quot;);    currentLi = tag;&gt;  //切换下方菜单  var id = tag.dataset.id; //获得当前点击元素的id  //选择属性与id相同的item，使用属性选择器img[alt=&quot;&quot;]  var item = document.querySelector(    &quot;.box-show .item[data-id=&quot; + id + &quot;]&quot;  );  currentItem.style.display = &quot;none&quot;; //将上一个点击的元素隐藏  item.style.display = &quot;block&quot;;  currentItem = item;&#125;;&gt;&lt;/script&gt;</code></pre><ol start="4"><li>事件委托的使用场景和注意事项和优点</li></ol><ul><li><p>注意事项：<strong>不能</strong>委托不冒泡的事件给祖先元素</p><blockquote><ul><li>通过上面的学习，我知道事件委托本质就是利用了事件的冒泡机制来实现</li><li>所以对于不支持事件冒泡的事件是没有办法使用事件委托<blockquote><p>如：onmouseenter 、 onmouseleave 、onload、onblur、onfocus，是不支持事件冒泡的</p></blockquote></li></ul></blockquote></li><li><p>使用场景：</p><blockquote><ul><li>当有大量类似元素需要批量添加相同的事件，处理相同的事情时，可以使用事件委托，把事件委托给这些元素的父级或祖先元素来处理。</li><li>当我们需要动态添加某节点时，我们可以把这些动态节点需要处理的事件委托给到父元素或祖先元素来处理。</li></ul></blockquote></li><li><p>优点：</p><blockquote><ul><li>可以减少事件的监听，减少内存的消耗，提升性能。</li></ul></blockquote></li></ul>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JS核心知识点（九）</title>
      <link href="/2023/12/05/JS%E6%A0%B8%E5%BF%83%E7%9F%A5%E8%AF%86%E7%82%B9%EF%BC%88%E4%B9%9D%EF%BC%89/"/>
      <url>/2023/12/05/JS%E6%A0%B8%E5%BF%83%E7%9F%A5%E8%AF%86%E7%82%B9%EF%BC%88%E4%B9%9D%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<span id="more"></span><blockquote><p>首先我们来回顾下，JS 这门课程需要学习的内容。<br><img src="JS课程内容.png"></p></blockquote><blockquote><ul><li>前面我们学习了 ECMAScript 标准中规定的基本语法中的一部分，还有 JS 高级部分+ES6+Ajax+本地存储等内容，等学完 DOM 和 BOM 后再学。</li><li>从今天开始，我们开始学习 DOM 和 BOM 相关的内容。</li></ul></blockquote><h3 id="一、API-与-Web-API"><a href="#一、API-与-Web-API" class="headerlink" title="一、API 与 Web API"></a>一、API 与 Web API</h3><ol><li>API 应用程序接口<blockquote><p>API即：<code>Application Programming Interface</code> ，<strong>应用程序接口</strong>。在编程中可以理解为一些<strong>预先定义好的函数</strong>，目的是提供应用程序与开发人员基于某软件或硬件得一访问一组<strong>例程</strong>的能力，而无须考虑其底层的源代码为何、或理解其内部工作机制的细节。</p><ul><li>例程： 是某个系统对外提供的功能接口或服务的集合</li><li>接口： 站在现实角度，可以理解为两个物体的口子相连接，而无需关心内部实现</li></ul></blockquote></li></ol><blockquote><blockquote><p>简单理解：</p><ul><li>API 是一个被封装好具有一定功能的函数，程序需要使用某种功能时，只需要调用这个函数，就能轻松实现想要完成的功能。</li></ul></blockquote></blockquote><ol start="2"><li>Web API Web 应用程序接口<blockquote><p>Web API：<code>Web Application Programming Interface</code> 在前端可以理解为是浏览器提供的一套操作<strong>浏览器功能和页面元素</strong>的API，其中包括 DOM 和 BOM。</p><ul><li><code>DOM：Document Object Model</code>文档对象模型， 是 JavaScript <strong>操作网页</strong>的接口。它定义了访问<strong>HTML文档对象</strong>的一套属性、方法和事件。</li><li><code>BOM：Browser Object</code>浏览器对象模型， 是 JavaScript <strong>操作浏览器</strong>的接口，提供一系列与浏览器相关的信息<ul><li>DOM 与 BOM 是 W3C 国际组织定义的一套 Web 标准接口。</li><li>W3C（万维网联盟）创建于 1994 年，是 Web 技术领域最具权威和影响力的国际中立性技术标准机构。<blockquote><p>因为 Web API 很多，所以我们称其为 Web APIs。</p></blockquote></li></ul></li></ul></blockquote></li></ol><h3 id="二、DOM-概况与获取元素"><a href="#二、DOM-概况与获取元素" class="headerlink" title="二、DOM 概况与获取元素"></a>二、DOM 概况与获取元素</h3><h4 id="什么是-DOM"><a href="#什么是-DOM" class="headerlink" title="什么是 DOM"></a>什么是 DOM</h4><blockquote><p>DOM全称<code>Document Object Model</code>文档对象模型。</p><ul><li><code>Document</code>文档，表示的就是整个 <code>HTML</code> 网页文档</li><li><code>Object</code>对象 ，表示将网页中的<strong>每一个部分</strong>都转换为一个<strong>对象</strong></li><li><code>Model</code>模型，表示对象之间的关系，这样方便我们获取对象。</li></ul></blockquote><blockquote><ul><li><strong>DOM 是 JavaScript 操作网页的接口，那 JS 具体是如何操作 DOM 的呢 ？</strong></li><li>DOM 最大的特点，就是将整个HTML文档抽象成一个<strong>DOM 树</strong>，JS 可以通过操作DOM树来实现<strong>对HTML文档的添加、删除 、修改等操作</strong></li></ul></blockquote><ul><li>我们来下面这段简单的 HTML 代码</li></ul><pre><code>&gt;&lt;!DOCTYPE html&gt;&gt;&lt;html lang=&quot;en&quot;&gt;&gt;  &lt;head&gt;&gt;    &lt;meta charset=&quot;UTF-8&quot; /&gt;&gt;    &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot; /&gt;&gt;    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot; /&gt;&gt;    &lt;title&gt;DOM文档结构树&lt;/title&gt;&gt;  &lt;/head&gt;&gt;  &lt;body&gt;&gt;    &lt;div&gt;&gt;      &lt;div&gt;我是文本节点&lt;/div&gt;&gt;      &lt;img src=&quot;&quot; alt=&quot;&quot; /&gt;&gt;      &lt;h3&gt;&lt;/h3&gt;&gt;    &lt;/div&gt;&gt;    &lt;p&gt;&lt;/p&gt;&gt;  &lt;/body&gt;&gt;&lt;/html&gt;</code></pre><img src="DOM树.png"><blockquote><blockquote><p>注</p></blockquote><ul><li>DOM 的<strong>最小组成单位</strong>叫做节点（node）</li><li>根据 W3C 的<code>HTML DOM 标准</code>，HTML 文档中的<strong>所有内容</strong>都是节点。</li><li>DOM 树就是由各种不同类型的节点组成。</li></ul></blockquote><h4 id="节点（node）"><a href="#节点（node）" class="headerlink" title="节点（node）"></a>节点（node）</h4><blockquote><ul><li>DOM 中的节点的类型有如下七种：</li></ul></blockquote><table><thead><tr><th>节点分类</th><th>描述</th></tr></thead><tbody><tr><td>Document 文档节点</td><td>整个 DOM 树的顶层节点</td></tr><tr><td>DocumentType 文档类型节点</td><td>如 doctype 标签(<code>&lt;!DOCTYPE html&gt;</code>)</td></tr><tr><td>Element 元素节点</td><td>网页的各种 HTML 标，如：<code>&lt;p&gt;</code>、<code>&lt;div&gt;</code></td></tr><tr><td>Attr 属性节点</td><td>元素的各种属性，如：title&#x3D;’标题’、class&#x3D;’box’</td></tr><tr><td>Text 文本节点</td><td>标签之间或标签包含的文本</td></tr><tr><td>Comment 注释节点</td><td>网页中的注释</td></tr><tr><td>DocumentFragment 文档片段</td><td>文档片段，不存于 DOM 树上，是一种游离态，通常作为仓库来使用</td></tr></tbody></table><h4 id="document-文档对象"><a href="#document-文档对象" class="headerlink" title="document 文档对象"></a>document 文档对象</h4><blockquote><ul><li>document 文档对象是<code>HTMLDocument</code>的<strong>实例</strong>，表示整个 HTML 页面（HTMLDocument 继承 Document）</li><li>document 是 window 对象的属性，因此是一个<strong>全局对象</strong></li><li>控制台 console 可以输入下面两行代码，就可以获得当前网页的文档对象</li></ul></blockquote><pre><code>window.document; // 获取 文档节点对象document; // 获取 文档节点对象// 注意区分大小写， document 与 Document是两个不同的东西// HTMLDocument 继承 Document</code></pre><blockquote><blockquote><ul><li>document 对象是 DOM 中最重要的东西，几乎所有DOM 的功能都封装在了 document 对象中</li><li>我们可以通过 document 对象，来访问元素节点。</li></ul></blockquote></blockquote><h4 id="访问元素节点的常用方法"><a href="#访问元素节点的常用方法" class="headerlink" title="访问元素节点的常用方法"></a>访问元素节点的常用方法</h4><blockquote><ul><li>所谓 “访问” 元素节点，就是指 “得到”、”获取” 页面上的元素节点</li><li>对节点进行操作，第一步就是要得到它<table><thead><tr><th>方法</th><th>功能</th></tr></thead><tbody><tr><td>getElementById()</td><td>通过元素 id 名获取到元素</td></tr><tr><td>getElementsByTagName()</td><td>通过标签名获取元素，返回的是一个数组</td></tr><tr><td>getElementsByClassName()</td><td>通过 class 名获取元素，返回的是一个数组</td></tr><tr><td>querySelector()</td><td>通过选择器得到元素,只能得到第一个被找到的元素</td></tr><tr><td>querySelectorAll()</td><td>通过选择器得到元素，返回的是一个数组</td></tr></tbody></table></li></ul></blockquote><ol><li>getElementById()<blockquote><ul><li><code>document.getElementById()</code>的功能是，通过元素的<strong>id名</strong>来得到元素节点</li><li>不管元素藏的位置有多深，都能通过 id 把它找到<blockquote><p>如果页面上有相同 id 的元素，则只能得到<strong>第一个</strong> ，id 是唯一的。</p></blockquote></li></ul></blockquote></li></ol><pre><code>&gt;&lt;div id=&quot;box&quot;&gt;我是一个盒子&lt;/div&gt;&gt;&lt;div id=&quot;box&quot;&gt;我是2&lt;/div&gt;&gt;&lt;p id=&quot;title&quot;&gt;我是一个段落&lt;/p&gt;&gt;&gt;&lt;script&gt;  var box = document.getElementById(&quot;box&quot;);  var title = document.getElementById(&quot;title&quot;);  console.log(box); // &lt;div id=&quot;box&quot;&gt;我是一个盒子&lt;/div&gt;  console.log(title); // &lt;p id=&quot;title&quot;&gt;我是一个段落&lt;/p&gt;  console.log(typeof box); // object&gt;&lt;/script&gt;</code></pre><ol start="2"><li>getElementsByTagName()<blockquote><ul><li><code>getElementsByTagName()</code>方法的功能是通过<strong>标签名</strong>得到节点元素组成的<strong>数组</strong>,而且得到的是一个类数组，没有数组身上的方法</li><li>所以我们可以通过遍历数组，批量操控每一元素节点</li></ul></blockquote></li></ol><pre><code>&gt;&lt;div id=&quot;box1&quot;&gt;&gt;  &lt;p&gt;我是p段落标签&lt;/p&gt;&gt;&lt;/div&gt;&gt;&lt;div id=&quot;box2&quot;&gt;&gt;  &lt;p&gt;我是p段落标签&lt;/p&gt;&gt;  &lt;p&gt;我是p段落标签&lt;/p&gt;&gt;  &lt;h3&gt;我是h3标签&lt;/h3&gt;&gt;&lt;/div&gt;&gt;&lt;script&gt;&gt;  var pList = document.getElementsByTagName(&quot;p&quot;);&gt;  console.log(pList); // HTMLCollection(3) [p, p, p]&gt;&lt;/script&gt;</code></pre><blockquote><blockquote><p>HTMLCollection 对象，是一个类数组对象，他没有数组身上的方法。</p></blockquote></blockquote><blockquote><ul><li>即使页面上<strong>只有一个</strong>指定标签名的节点，也将得到长度为 1 的数组</li><li>如果<strong>没有</strong>找到指定标签名的节点，则返回一个空数组</li><li>任何一个节点元素也可以调用 <code>getElementsByTagName()</code>方法，从而得到其内部的某种类的元素节点</li></ul></blockquote><ol start="3"><li>getElementsByClassName()<blockquote><ul><li><code>getElementsByClassName()</code>方法的功能是通过<strong>class 类名</strong>得到节点数组</li><li>如果只能获取一个元素，返回长度为 1 的数组，如果没有找到，则返回空数组</li><li>document和节点元素都可以调用 <code>getElementsByClassName()</code>方法，从而得到其内部的某类名的元素节点</li></ul></blockquote></li></ol><pre><code>&gt;&lt;div class=&quot;box box1&quot;&gt;box1&lt;/div&gt;&gt;&lt;div class=&quot;box box2&quot;&gt;box2&lt;/div&gt;&gt;&lt;div id=&quot;content&quot;&gt;&gt;  &lt;div class=&quot;box box3&quot;&gt;box3&lt;/div&gt;&gt;&lt;/div&gt;&gt;&gt;&lt;script&gt;  // 获取所有class名中包含 box的元素  var box = document.getElementsByClassName(&quot;box&quot;);  console.log(box);  // 获取id content的元素  var content = document.getElementById(&quot;content&quot;);  // 获取content中class名为box的元素  var conBox = content.getElementsByClassName(&quot;box&quot;);  console.log(conBox);&gt;&lt;/script&gt;</code></pre><ol start="4"><li>querySelector()<blockquote><ul><li>通过<strong>CSS 选择器</strong>得到页面当中的元素，不过只能得到<strong>第一个</strong>被找到的元素</li></ul></blockquote></li></ol><pre><code>&gt;&lt;div class=&quot;box&quot;&gt;  &lt;p&gt;我是p1&lt;/p&gt;  &lt;p&gt;我是p2&lt;/p&gt;&gt;&lt;/div&gt;&gt;&lt;script&gt;  var p = document.querySelector(&quot;.box p&quot;);  console.log(p); // &lt;p&gt;我是p1&lt;/p&gt;&gt;&lt;/script&gt;</code></pre><ol start="5"><li>querySelectorAll()<blockquote><ul><li>通过<strong>CSS选择器</strong>得到页面当中的元素，返回被找到元素组成的<strong>数组</strong></li><li>如果只有一个符合要求的，也将得到长度为 1 的数组</li><li>如果没有符合要求的，则返回一个空数组</li></ul></blockquote></li></ol><pre><code>&gt;&lt;div class=&quot;box&quot;&gt;&gt;  &lt;div class=&quot;title&quot;&gt;&gt;    &lt;p&gt;我是p&lt;/p&gt;&gt;    &lt;p&gt;我是p&lt;/p&gt;&gt;  &lt;/div&gt;&gt;&lt;/div&gt;&gt;&gt;&lt;div class=&quot;title&quot;&gt;&gt;  &lt;p&gt;我是p&lt;/p&gt;&gt;  &lt;p&gt;我是p&lt;/p&gt;&gt;&lt;/div&gt;&gt;&lt;script&gt;&gt;  var pList = document.querySelectorAll(&quot;.title p&quot;);&gt;  console.log(pList); // NodeList(4) [p, p, p, p]&gt;&lt;/script&gt;</code></pre><ol start="6"><li><p>querySelectorAll 、getElementsByClassName()、getElementsByTagName() 的区别</p><blockquote><ul><li><code>getElementsByClassName()</code>和 <code>getElementsByTagName()</code>方法是可以<strong>动态获取元素</strong>，也就是当页面上增加或删除元素时，获取的元素个数可以改变</li><li>而<code>querySelectorAll()</code>是做不到的</li></ul></blockquote></li><li><p>获取 body 与 HTML 元素</p><table><thead><tr><th>属性</th><th>说明</th></tr></thead><tbody><tr><td>document.body</td><td>获取 body 元素</td></tr><tr><td>document.documentElement</td><td>获取 html 元素</td></tr></tbody></table></li><li><p>获取页面中所有元素</p><blockquote><ul><li><code>document.all</code> 获取页面当中所有元素</li><li><code>document.getElementsByTagName(“*”) </code>获取页面当中所有元素<blockquote><p>以上方式几乎不用，只是当做了解即可</p></blockquote></li></ul></blockquote></li><li><p>onload 方法</p><blockquote><ul><li>浏览器在加载一个页面时，是按照<strong>自上而下</strong>的顺序加载的。</li><li>如果 JS 写在了 body 前面，那 JS 在获取页面元素时，页面上的元素标签还没有被加载出来，就会造成读取不到内容。<blockquote><p>通常 JS 代码一定要写到<code>&lt;/body&gt;</code>节点的前面，否则 JS 无法找到相应 HTML 节点</p></blockquote></li></ul></blockquote></li></ol><pre><code>&gt;&lt;script&gt;&gt;  var box1 = document.getElementById(&quot;box1&quot;);&gt;  console.log(box1); // null  没有获取到元素&gt;&lt;/script&gt;&gt;&lt;div id=&quot;box1&quot;&gt;box&lt;/div&gt;</code></pre><blockquote><ul><li>如果 JS 代码写在 body 前面，也能正常执行，可以使用<code>window.onload = function()&#123;&#125;</code>事件，使页面加载完毕后，再执行指定的代码</li></ul></blockquote><pre><code>&gt;&lt;script&gt;  // 给window对象添加onload事件监听，onload表示页面都加载完毕了  window.onload = function () &#123;    var box1 = document.getElementById(&quot;box1&quot;);    console.log(box1);  &#125;;&gt;&lt;/script&gt;&gt;&lt;body&gt;&gt;  &lt;div id=&quot;box1&quot;&gt;box&lt;/div&gt;&gt;&lt;/body&gt;</code></pre><h3 id="三、操作元素属性"><a href="#三、操作元素属性" class="headerlink" title="三、操作元素属性"></a>三、操作元素属性</h3><h4 id="符合标准的-w3c-属性"><a href="#符合标准的-w3c-属性" class="headerlink" title="符合标准的 w3c 属性"></a>符合标准的 w3c 属性</h4><blockquote><p>常见的符合标准的 w3c 属性有</p><ul><li>id、alt、title</li><li>class、style 更改元素样式属性 比较特殊，我们放在后面单独来讲</li><li>src 、 href 修改图片地址和 a 标签链接地址</li><li>type、value、checked、selected、disabled 表单元素属性<blockquote><p>符合标准的 w3c 属性，我们可以直接用<code>对象.属性名</code>的方式来访问</p></blockquote></li></ul></blockquote><ol><li>id、alt 、title<blockquote><ul><li>id 这个属性在实际中，我们肯定不会去更改他的值</li><li>alt 图片描述属性</li><li>title 提示属性，主要用在 a 标签上</li><li>获取元素后，打点调用来修改或者新增属性</li></ul></blockquote></li></ol><pre><code>&gt;&lt;img src=&quot;../src/3.avif&quot; id=&quot;img&quot; /&gt;&gt;&lt;a href=&quot;http://www.baidu.com&quot; id=&quot;link&quot;&gt;百度&lt;/a&gt;&gt;&lt;script&gt;&gt;  var img2 = document.getElementById(&quot;img&quot;);&gt;  var a2 = document.getElementById(&quot;link&quot;);&gt;  img2.id = &quot;img1&quot;;&gt;  img2.alt = &quot;美女图片&quot;;&gt;  a2.title = &quot;去百度走一趟&quot;;&gt;&lt;/script&gt;</code></pre><ol start="2"><li>src 和 href<blockquote><ul><li>src 属性，用来修改图片的地址</li><li>href 属性，用来修改超链接的地址</li><li>获取元素后，打点调用来修改或者新增属性<blockquote><p>a标签对里的文字用<code>.innerText</code>调用</p></blockquote></li></ul></blockquote></li></ol><pre><code>&gt;&lt;img src=&quot;images/img1.png&quot; alt=&quot;&quot; id=&quot;img&quot; /&gt;&gt;&lt;a href=&quot;http://www.baidu.com&quot; title=&quot;百度&quot; id=&quot;link&quot;&gt;百度&lt;/a&gt;&gt;&gt;&lt;script&gt;  var img = document.getElementById(&quot;img&quot;);  var a = document.getElementById(&quot;link&quot;);&gt;  img.src = &quot;images/logo.png&quot;;  a.href = &quot;http://www.icodingedu.com&quot;;  a.innerText = &quot;艾编程&quot;;  a.title = &quot;艾编程&quot;;&gt;&lt;/script&gt;</code></pre><ol start="3"><li>表单属性</li></ol><ul><li>value 表单值<blockquote><ul><li>获取元素后，调用value值可以获取<code>value的初始值</code>或<code>输入框中的内容</code></li></ul></blockquote></li></ul><pre><code>用户名：&lt;input type=&quot;text&quot; name=&quot;&quot; id=&quot;userName&quot; value=&quot;123&quot; /&gt;&lt;br /&gt;&gt;&lt;script&gt;  // 获取用户名  var userName = document.getElementById(&quot;userName&quot;);  console.log(userName.value);//123  //在输入框输入aabb后  console.log(userName.value);//aabb&gt;&lt;/script&gt;</code></pre><ul><li>type 表单类型<blockquote><ul><li>把<code>text</code>改成<code>password</code>隐藏密码，也可反向操作</li></ul></blockquote></li></ul><pre><code>密码：&lt;input type=&quot;text&quot; name=&quot;&quot; id=&quot;iphone&quot; value=&quot;&quot; /&gt;&gt;&lt;script&gt;// 获取电话号码输入框var iphone = document.getElementById(&quot;iphone&quot;);// 写入密码，将电话号码隐藏iphone.value = &quot;1223333&quot;;iphone.type = &quot;password&quot;;&gt;&lt;/script&gt;</code></pre><ul><li>checked 单选和复选框选中状态<blockquote><ul><li>单选框是互斥的</li><li>默认选中：<ul><li>在对应标签中写上<code>checked</code>或<code>checked=&quot;true&quot;</code></li><li>打点调用该元素的<code>checked</code>值修改为<code>true</code>或<code>checked</code></li></ul></li><li>单选</li></ul></blockquote></li></ul><pre><code>&gt;&lt;h3&gt;姓别&lt;/h3&gt;&gt;&lt;input type=&quot;radio&quot; name=&quot;sex&quot; id=&quot;&quot; value=&quot;男&quot; /&gt;男&gt;&lt;input type=&quot;radio&quot; name=&quot;sex&quot; checked=&quot;true&quot; id=&quot;&quot; value=&quot;女&quot; /&gt;女&gt;&lt;script&gt; // 获取单选框  var sex = document.getElementsByName(&quot;sex&quot;);  // 选中第一个男  //sex[0].checked = true;  //sex[1].checked = &quot;checked&quot;;&gt;&lt;/script&gt;</code></pre><blockquote><ul><li>复选</li></ul></blockquote><pre><code>&gt;&lt;h3&gt;喜欢的水果&lt;/h3&gt;&gt;&lt;input type=&quot;checkbox&quot; name=&quot;fruit&quot; id=&quot;&quot; /&gt; 苹果&gt;&lt;input type=&quot;checkbox&quot; name=&quot;fruit&quot; id=&quot;&quot; /&gt;梨子&gt;&lt;input type=&quot;checkbox&quot; name=&quot;fruit&quot; id=&quot;&quot; /&gt;葡萄&gt;&lt;script&gt;  // 获取复选框  var fruit = document.getElementsByName(&quot;fruit&quot;);  //选中第一个  fruit[0].checked=true;//或者&quot;checked&quot;  //取消选中  fruit[0].checked=false;&gt;&lt;/script&gt;</code></pre><blockquote><blockquote><p><code>getElementsByName</code>：通过表单的<code>name</code>属性获取元素，得到的是一个类数组元素</p></blockquote></blockquote><ul><li>selected 下拉列表元素选中状态<blockquote><ul><li>修改默认选中元素：<ul><li>方式1：<code>.selected = true</code></li><li>方式2：下拉菜单有一个属性：<code>.selectedIndex</code>可以获取&#x2F;修改选中元素</li></ul></li></ul></blockquote></li></ul><pre><code>&gt;&lt;h3&gt;选择所在城市&lt;/h3&gt;&gt;&lt;select name=&quot;&quot; id=&quot;city&quot;&gt;&gt;  &lt;option value=&quot;湖南&quot;&gt;湖南&lt;/option&gt;&gt;  &lt;option value=&quot;深圳&quot;&gt;深圳&lt;/option&gt;&gt;  &lt;option value=&quot;上海&quot;&gt;上海&lt;/option&gt;&gt;&lt;/select&gt;&gt;&lt;script&gt;&gt;  // 获取下拉列表&gt;  var city = document.getElementById(&quot;city&quot;);&gt;  var ops = city.getElementsByTagName(&quot;option&quot;);&gt;  //修改被选中元素——方式1&gt;  ops[2].selected = true;&gt;  console.log(city.selectedIndex); //2&gt;  //修改被选中元素——方式2&gt;  city.selectedIndex = 0;&gt;  console.log(city.selectedIndex); //0</code></pre><ul><li>disabled 元素是否被禁用<blockquote><ul><li><code>.disabled = true</code></li><li><code>.disabled = &quot;disabled&quot;</code></li></ul></blockquote></li></ul><pre><code>&gt;&lt;input type=&quot;submit&quot; id=&quot;submit&quot; value=&quot;提交&quot; /&gt;&gt;&lt;script&gt;// 提交按扭var submit = document.getElementById(&quot;submit&quot;);submit.disabled = true; // 禁用// submit.disabled = &quot;disabled&quot;;&gt;&lt;/script&gt;</code></pre><h4 id="自定义属性"><a href="#自定义属性" class="headerlink" title="自定义属性"></a>自定义属性</h4><blockquote><ul><li>自定义属性：由我们自己定义在元素身上的属性</li><li>自定义属性的目的：用来保存元素标签后期要用到的一些<strong>数据内容</strong>，一些简单数据存在自定义属性中，后期操作方便。</li><li>修改自定义属性，可以通过下面方法来操作(旧方法)<table><thead><tr><th>方法</th><th>说明</th></tr></thead><tbody><tr><td>getAttribute(key)</td><td>获取属性，key 表示要获取的属性名</td></tr><tr><td>setAttribute(key,value)</td><td>添加或修改属性值，key 表示属性名，value 表示属性值</td></tr></tbody></table></li></ul></blockquote><pre><code>&gt;&lt;div id=&quot;box&quot; abs=&quot;值&quot; title=&quot;我是提示&quot;&gt;&lt;/div&gt;&gt;&lt;script&gt;  var box = document.getElementById(&quot;box&quot;);  console.log(box.abs); // undefined  console.log(box.getAttribute(&quot;abs&quot;)); // 值  console.log(box.getAttribute(&quot;title&quot;)); // 我是提示  box.setAttribute(&quot;mycustom&quot;, &quot;自定义属性值&quot;);//添加属性  box.setAttribute(&quot;id&quot;, &quot;box2&quot;); //id=&quot;box2&quot;  console.log(box.getAttribute(&quot;id&quot;));//box2&gt;&lt;/script&gt;</code></pre><blockquote><blockquote><p><code>setAttribute(key,value)</code>与<code>getAttribute(key)</code>也是可以操作标准属性</p></blockquote></blockquote><h4 id="Html5-中自定义属性规范"><a href="#Html5-中自定义属性规范" class="headerlink" title="Html5 中自定义属性规范"></a>Html5 中自定义属性规范</h4><blockquote><ul><li>Html5 中规定自定义属性名以<code>data-</code>开头</li><li>使用<code>data-</code>前缀自定义属性，可以解决属性混乱无管理的现状，区分自定义属性与标准属性</li></ul></blockquote><ol><li>设置自定义属性的 2 种方式</li></ol><ul><li>方式一： 可以直接在 HTML 标签上面书写</li></ul><pre><code>&gt;&lt;h2 data-weather=&quot;sunny&quot;&gt;今天是晴天&lt;/h2&gt;&lt;!--    data-weather 自定义属性名    sunny 自定义属性值--&gt;&lt;!-- 多个单词组合 --&gt;&gt;&lt;h2 data-birth-date=&quot;20230501&quot;&gt;今天是我的生日&lt;/h2&gt;</code></pre><blockquote><blockquote><p>如果设置的自定义属性是多个单词组合的形式，需要用中横线-连接</p></blockquote></blockquote><ul><li>方式二： 通过 JS 的<code>dataset</code>属性来设置<blockquote><ul><li><code>.dataset.属性名=&quot;属性值&quot;</code></li><li>属性名中的大写，会自动用<code>-</code>分隔(驼峰命名法)</li></ul></blockquote></li></ul><pre><code>&gt;&lt;h2&gt;今天是我的生日&lt;/h2&gt;&gt;&lt;script&gt;&gt;  var h2 = document.querySelector(&quot;h2&quot;);&gt;  h2.dataset.birthDate = &quot;20230501&quot;;   //data-birth-date=&quot;20230501&quot;&gt;&lt;/script&gt;</code></pre><ol start="2"><li>获取自定义属性<blockquote><ul><li>直接通过<code>对象.dataset.属性名</code>（属性名书写格式：属性去掉 <code>data-</code>之后的单词，<strong>以驼峰命名</strong>）</li><li>如 属性名为<code>data-ab-cd-fg</code>则访问方式：<code>对象.dataset.abCdFg</code></li></ul></blockquote></li></ol><pre><code>&gt;&lt;img src=&quot;images/dog.png&quot; data-animal-type=&quot;animal&quot; /&gt;&gt;&lt;script&gt;  var img = document.getElementsByTagName(&quot;img&quot;);  //获取自定义属性  var animalType = img[0].dataset.animalType;  console.log(animalType);&gt;&lt;/script&gt;</code></pre><h3 id="四、操作元素样式"><a href="#四、操作元素样式" class="headerlink" title="四、操作元素样式"></a>四、操作元素样式</h3><blockquote><ul><li>操作元素样式的属性有style 、cssText、 className</li><li>同时 HTML5 提供了classList对象，classList对象身上的方法，用来操作元素的 class 属性，简直完美。</li></ul></blockquote><ol><li>style 属性<blockquote><ul><li>style 属性用来操作元素的<strong>行内样式</strong>，他只对行内样式有效</li><li><strong>获取</strong>行内样式的写法：<br><code>对象.style.属性名; // 属性名要采用驼峰形式书写</code></li><li><strong>修改或添加</strong>行内样式的写法<br><code>对象.style.属性名 = 属性值; // 属性名要采用驼峰形式书写</code></li></ul></blockquote></li></ol><pre><code>&gt;&lt;style&gt;    .box &#123;        width: 100px;        height: 200px;        background-color: hotpink;        color: red;    &#125;&gt;&lt;/style&gt;&gt;&gt;&lt;div class=&quot;box&quot;&gt;&lt;/div&gt;&gt;&lt;script&gt;  var box = document.getElementsByClassName(&quot;box&quot;);  box[0].style.width = &quot;200px&quot;;  box[0].style.backgroundColor = &quot;red&quot;;  box[0].style.borderTop = &quot;15px solid blue&quot;;&gt;  // 获取样式  console.log(box[0].style.color); // 获取不到,color写在class内  console.log(box[0].style.borderTop); //15px solid blue&gt;&lt;/script&gt;</code></pre><p><strong>注意事项：</strong></p><blockquote><ul><li>操作元素的 style 上的样式，这里的样式<strong>权重最高</strong>，可以覆盖外部和内嵌样式</li><li>如果样式写在了class类中，没写在 style 属性中，则通过<code>对象.style.属性名</code>的方式，是<strong>获取不到的</strong></li><li>如果元素要改变的<strong>样式量特别多</strong>，这种方式就比较麻烦。</li></ul></blockquote><ol start="2"><li>cssText 属性<blockquote><ul><li><code>cssText</code>的本质就是设置 HTML 元素的 <code>style</code> 属性值</li><li>所以每设置一次 cssText 值，就会把之前的 style 属性中的样式<strong>全部覆盖</strong>掉</li></ul></blockquote></li></ol><pre><code>&gt;&lt;div  class=&quot;box&quot;  style=&quot;width: 100px; height: 200px; background-color: red&quot;&gt;&lt;/div&gt;&gt;&lt;script&gt;  var box = document.getElementsByClassName(&quot;box&quot;)[0];  box.style.cssText = &quot;color:blue&quot;; // 覆盖了之前的style样式中的值&gt;&lt;/script&gt;</code></pre><blockquote><blockquote><p>cssText 主要用来合并多次对 CSS 样式的修改，改为一次性处理</p></blockquote></blockquote><ol start="3"><li>className 属性<blockquote><ul><li>我们在操作元素的<code>class</code>样式属性时，<strong>不能</strong>用<code>对象.属性</code> 的方法操作，因为 class 是关键字</li><li>我们可以通过<code>对象.className</code>的方式来操作</li><li>注意事项：<code>className</code>修改样式，如果是多个样式，样式之间要用<strong>空隔</strong>隔开</li></ul></blockquote></li></ol><pre><code>&gt;&lt;style&gt;  .box &#123;    width: 100px;    height: 100px;    background-color: skyblue;  &#125;  .box1 &#123;    border: 5px dashed tomato;  &#125;&gt;&lt;/style&gt;&gt;&lt;body&gt;  &lt;div class=&quot;box&quot;&gt;&lt;/div&gt;  &lt;script&gt;    var box = document.getElementsByClassName(&quot;box&quot;);    box[0].className = &quot;box box1&quot;; // box与box1之间要有空格  &lt;/script&gt;&gt;&lt;/body&gt;</code></pre><blockquote><ul><li>className 操作 CSS 样式有一个很大的<strong>缺点</strong>，就是我每次更新 class 类名时，都要把<strong>所有的类名带上</strong>。</li><li>如果我只想在元素原有的基础上继续添加新的类名、或删除某个类名，能不能不动原有的类名，就能实现。答案肯定是可以的</li></ul></blockquote><ol start="4"><li>操作 CSS 样式的优先方案<blockquote><p>style、cssText、className 三种方式操作 CSS 样式时，性能消耗由低到高的排序分别如下：</p><ul><li>className &gt; cssText &gt; style</li></ul></blockquote></li></ol><p><strong>原因</strong></p><blockquote><ul><li>通过 <code>style</code> 属性来操作 CSS 样式，会<strong>频繁的触发页面的重排和重绘（DOM 重新渲染）</strong></li><li>通过 style 身上的 <code>cssText</code> 属性来操作 CSS 样式，是把多次对 DOM 的操作合并为<strong>一次性处理</strong>，减少了触发重排和重绘（DOM 的重新渲染）次数</li><li>通过 <code>className</code> 属性，本质也是一样的，减少了对 DOM 的操作，<strong>多次操作合并为一次性处理</strong>，同时 className 中的样式，<strong>一开始就准备好了</strong>。</li></ul></blockquote><ol start="5"><li>classList 对象<blockquote><ul><li><code>html5</code>为每一个元素新增了一个**<code>classList</code>对象<strong>，<code>classList</code>对象保存着</strong>控制当前元素类名**的各个方法和属性。<br><strong>classList 对象身上相关的属性和方法如下表：</strong><table><thead><tr><th>属性或方法</th><th>说明</th></tr></thead><tbody><tr><td>length</td><td>返回类名的<strong>个数</strong></td></tr><tr><td>add()</td><td>在原有的类名基础上<strong>添加</strong>一个类名，如果这些类已经存在于元素的属性中，那么它们将被忽略。</td></tr><tr><td>remove()</td><td>在原有的类名基础上,<strong>移出</strong>某一个类名，即使删除不存在的类值也不会导致抛出异常</td></tr><tr><td>toggle()</td><td>如果<strong>有</strong>这个类名，则删除这个类名，返回 <code>false</code>，如果<strong>没有</strong>则添加上去，返回<code>true</code></td></tr><tr><td>item()</td><td>根据索引 获取类名</td></tr><tr><td>contains()</td><td>判断元素是否包含某一个类名</td></tr><tr><td>replace(oldClass, newClass)</td><td>用一个<strong>新类值替换</strong>已有的类值，替换成功返回 true,替换失败，返回 false</td></tr></tbody></table></li></ul></blockquote></li></ol><pre><code> var box = document.getElementsByClassName(&quot;box&quot;)[0]; console.log(box.classList.length); // 3 类名个数 box.classList.add(&quot;box3&quot;); // 追加一个类名box3 box.classList.remove(&quot;box2&quot;); // 移除一个类名box2 bool1 = box.classList.toggle(&quot;box1&quot;); // 有就移除box1 console.log(bool1); //删除则返回false bool2 = box.classList.toggle(&quot;box1&quot;); // 没有就添加box1 console.log(bool2); //添加则返回true console.log(box.classList.item(1)); // 索引为0的类名 box console.log(box.classList.contains(&quot;box&quot;)); // true console.log(box.classList.replace(&quot;box&quot;, &quot;mybox&quot;)); // 用mybox 替换box</code></pre><blockquote><blockquote><p>注</p></blockquote><ul><li>假设现在浏览器版本过低，<strong>不支持</strong> <code>classList</code> 对象，那就需要我们<strong>手写</strong>相关方法来实现对 class 属性的操作。</li><li>这里我们尝试手写：<code>add</code>、<code>remove</code>、<code>toggle</code>三个方法。</li><li>我们期望 html 元素可以直接调用这些方法，实现对 class 类名的操作。</li><li>那就需要确认，我们手写的这些方法要加在<strong>哪个构造函数（类）的原型上</strong>。因此我们了解 DOM 中各个类的关系。</li></ul></blockquote><ol start="6"><li>DOM 中各类的继承关系图<img src="DOM继承关系图.png"></li></ol><ul><li>方法：<blockquote><ul><li>查看实例的构造函数(类)：<code>实例.__proto__</code></li><li>查看继承关系：<ul><li>方法1：在控制台，一层层查看对应的<code>[[prototype]]</code></li><li>方法2：输入以下代码：</li></ul></li></ul></blockquote></li></ul><pre><code>//元素节点只有构造函数不同，后续都一样var box = document.getElementsByClassName(&quot;box&quot;)[0];//得到它的构造函数：HTMLDivElementconsole.log(box.__proto__);//通过一层层翻找`[[prototype]]`可知继承关系//HTMLDivElement-&gt;HTMLElement-&gt;Element-&gt;Node-&gt;EventTarget-&gt;Object;&gt;var attr = document.createAttribute(&quot;id&quot;);//属性节点：attr.__proto__;//实例-&gt;Attr(继承)-&gt;Node-&gt;EventTarget-&gt;Objectvar text = document.createTextNode(&quot;文本&quot;);//文本节点：text.__proto__;//实例-&gt;Text(继承)-&gt;CharacterData-&gt;Node-&gt;EventTarget-&gt;Objectvar frag = document.createDocumentFragment();//文档片段：frag.__proto__;//实例-&gt;DocumentFragment(继承)-&gt;Node-&gt;EventTarget-&gt;Objectvar comment = document.createComment(&quot;我是一段注释&quot;);//注释节点：comment.__proto__;//实例-&gt;Comment(继承)-&gt;CharacterData-&gt;Node-&gt;EventTarget-&gt;Object</code></pre><blockquote><blockquote><p>结论：</p></blockquote><ul><li>我们希望 HTML 元素可以直接打点调用 <code>addClass</code> 等方法，实现对 class 属性的操作</li><li>所以这些方法要写在 <code>HTMLElement</code> 的原型上。</li></ul></blockquote><ol start="7"><li>手写 addClass 方法<blockquote><p>该方法实现对元素添加对应的 class 类名，如果元素上没有对应 class 类名添加，有的话就不加</p><ul><li>className 属性：<ul><li><code>.className</code>，获取元素的class类名，得到的是字符串</li><li><code>.className=&quot;&quot;</code>修改类名，样式之间要用空隔隔开</li></ul></li><li><code>split()</code>方法可以使字符串以某种分隔符进行分隔，分隔后的字符串组成一个<strong>数组返回</strong></li><li><code>includes()</code>方法用来判断一个数组<strong>是否包含</strong>一个指定的值</li><li><code>join()</code>方法将一个数组的所有元素以<strong>特定的某种字符</strong>连接成一个字符串，并返回这个<strong>字符串</strong></li></ul></blockquote></li></ol><pre><code>&gt;&lt;div class=&quot;box box1 box2 box2&quot;&gt;&lt;/div&gt;&gt;&gt;&lt;script&gt;  /**   * addClass 方法实现对元素添加对应的class类名，如果元素上没有对应class类名就添加，有就不加   * @param name  class类名字符串   */  HTMLElement.prototype.addClass = function (name) &#123;    if (typeof name !== &quot;string&quot;) return;    // 获取当前对象上的class类名    var className = this.className;    // 以空格分隔成一个数组    var classArr = className.split(&quot; &quot;);    // 判断传过来的类名在不在当前数组中，如果不存在，就添加    if (!classArr.includes(name)) &#123;      classArr.push(name); // 将类名添加到数组中    &#125;    var newClassName = classArr.join(&quot; &quot;); // 将数组元素以空格拼接成字符串    this.className = newClassName;//修改类名  &#125;;  var box = document.querySelector(&quot;.box&quot;);  box.addClass(&quot;box4&quot;);//谁调用this就是谁&gt;&lt;/script&gt;</code></pre><ol start="8"><li>手写 removeClass 方法<blockquote><ul><li>该方法实现移除元素上对应的 Class 类名，如果有就移除，如果没有不做处理</li></ul></blockquote></li></ol><pre><code>&gt;&lt;div class=&quot;box box1 box2 box2&quot;&gt;&lt;/div&gt;&gt;&gt;&lt;script&gt;  /**   * addClass 方法实现对元素添加对应的class类名，如果元素上没有对应class类名就添加，有就不加   * @param name  class类名字符串   */  HTMLElement.prototype.removeClass = function (name) &#123;    if (typeof name !== &quot;string&quot;) return;    // 获取当前对象上的class类名    var className = this.className;    // 以空格分隔成一个数组    var classArr = className.split(&quot; &quot;);    // 获取所查找类名的下标    var index = classArr.indexOf(name);    //如果找不到，则退出    if (index === -1) return;    //while循环删除所有 给定类名    while (index !== -1) &#123;      classArr.splice(index, 1);      // 要考虑傻逼模式，就是他本来就出现了两个相同的类名      index = classArr.indexOf(name, index); //从刚删除的下标开始查找该元素    &#125;    var newClassName = classArr.join(&quot; &quot;); // 将数组元素以空格拼接成字符串    this.className = newClassName;//修改类名  &#125;;  var box = document.querySelector(&quot;.box&quot;);  box.removeClass(&quot;box4&quot;);//谁调用this就是谁&gt;&lt;/script&gt;</code></pre><ol start="9"><li>手写 toggleClass 方法<blockquote><ul><li>该方法实现自动判断是给元素添加还是删除对应的 Class 类名，如果元素存在对应 Class 类名就删除，否则就添加</li></ul></blockquote></li></ol><pre><code>&gt;&lt;div class=&quot;box box1 box2 box2&quot;&gt;&lt;/div&gt;&gt;&lt;script&gt;  /**   * toggleClass 该该方法实现自动判断是给元素添加还是删除对应的Class类名，如果元素存在对应Class类名就删除，否则就添加   * @param name  class类名字符串   */  HTMLElement.prototype.toggleClass = function (name) &#123;    // 获取当前对象上的class类名    var className = this.className;    // 以空格分隔成一个数组    var classArr = className.split(&quot; &quot;);    // 判断传过来的类名在不在当前数组中，如果不在，就添加，存在，找到对应下标然后删掉    var index = classArr.indexOf(name);    if (index === -1) &#123;      // 没有就添加      classArr.push(name);    &#125; else &#123;      // 存在，就删除      // 要考虑傻逼模式，就是他本来就出现了两个相同的类名      var _index = index;      while (_index !== -1) &#123;        classArr.splice(_index, 1);        _index = classArr.indexOf(name, _index);      &#125;    &#125;    var newClassName = classArr.join(&quot; &quot;); // 将数组元素以空格拼接成字符串    this.className = newClassName;&gt;    // 处理返回值    if (index === -1) return true;    return false;  &#125;;&gt;  var box = document.querySelector(&quot;.box&quot;);  box.toggleClass(&quot;box2&quot;);  box.toggleClass(&quot;box1&quot;);  box.toggleClass(&quot;box3&quot;);&gt;&lt;/script&gt;</code></pre><blockquote><blockquote><p>注：</p><ul><li>以上所有方法，都没有办法获取 <strong>class 类名</strong>或 <strong>id 中定义的 css 样式</strong>。</li></ul></blockquote></blockquote><ol start="10"><li>getComputedStyle 方法<blockquote><ul><li><code>getComputedStyle()</code>方法，<strong>获取</strong>元素的计算样式，<strong>但不能</strong>修改样式。</li><li>语法：<br><code>var style = window.getComputedStyle(element, [pseudoElt]);</code></li><li><code>element</code>用于获取计算样式的元素</li><li><code>pseudoElt</code>指定一个要匹配的<strong>伪元素的字符串</strong>。对普通元素省略（或null）</li><li>返回的style是一个<strong>实时</strong>的<code>CSSStyleDeclaration</code> （css 样式声明）对象（它是一个 CSS 声明块，CSS 属性键值对的集合），当元素的样式更改时，它会自动更新本身。</li></ul></blockquote></li></ol><pre><code>&gt;&lt;style&gt;  .box &#123;    width: 200px;    height: 200px;    background-color: red;  &#125;  .box1 &#123;    font-size: 20px;    color: yellow;    line-height: 100px;  &#125;&gt;&lt;/style&gt;&gt;&lt;/head&gt;&gt;&gt;&lt;div class=&quot;box box1&quot; id=&quot;mybox&quot;&gt;我是css盒子&lt;/div&gt;&gt;&lt;script&gt;&gt;  var mybox = document.getElementById(&quot;mybox&quot;);&gt;  var style = getComputedStyle(mybox, null); //得到CSS访问声明&gt;  console.log(style);&gt;  for (var i = 0; i &lt; style.length; i++) &#123;&gt;    key = style[i];&gt;    //CSS样式及值&gt;    console.log(key + &quot;=&quot; + style.getPropertyValue(key));&gt;  &#125;&gt;&lt;/script&gt;</code></pre><ol start="11"><li>访问 CSS 属性值 3 种方式</li></ol><pre><code>// 访问方式一// propName 属性名，正常书写window.getComputedStyle(element, [pseudoElt]).getgetPropertyValue(propName);&gt;// 访问方式二// propName 属性名 要采用驼峰命名方式window.getComputedStyle(element, [pseudoElt]).propName;&gt;// 访问方式三// propName 属性名，正常书写window.getComputedStyle(element, [pseudoElt])[propName];</code></pre><pre><code>&gt;&lt;style&gt;  .box &#123;    width: 200px;    height: 200px;    background-color: red;  &#125;  .box1 &#123;    font-size: 20px;    color: yellow;    line-height: 100px;  &#125;&gt;&lt;/style&gt;&gt;&lt;div class=&quot;box box1&quot; id=&quot;mybox&quot;&gt;我是css盒子&lt;/div&gt;&gt;&gt;&lt;script&gt;  var mybox = document.getElementById(&quot;mybox&quot;);  var style = getComputedStyle(mybox, null);  console.log(style.height);  console.log(style.backgroundColor);  console.log(style.lineHeight);&gt;  console.log(style.getPropertyValue(&quot;height&quot;));  console.log(style[&quot;background-color&quot;]);  console.log(style.getPropertyValue(&quot;line-height&quot;));&gt;&lt;/script&gt;</code></pre><ol start="12"><li>获取伪元素样式<blockquote><ul><li>语法：<br><code>var style = window.getComputedStyle(element, 伪元素字符串);</code></li></ul></blockquote></li></ol><pre><code>&gt;&lt;style&gt;  #mybox &#123;    width: 200px;    height: 200px;    background-color: red;  &#125;  #mybox::after &#123;    content: &quot;我是伪元素内容&quot;;    color: yellow;  &#125;&gt;&lt;/style&gt;&gt;&gt;&lt;div id=&quot;mybox&quot;&gt;&lt;/div&gt;&gt;&lt;script&gt;  var mybox = document.getElementById(&quot;mybox&quot;);  var style = getComputedStyle(mybox, &quot;::after&quot;);  console.log(style.color);  console.log(style.content);&gt;&lt;/script&gt;</code></pre><h3 id="五、获取元素尺寸"><a href="#五、获取元素尺寸" class="headerlink" title="五、获取元素尺寸"></a>五、获取元素尺寸</h3><h4 id="偏移尺寸"><a href="#偏移尺寸" class="headerlink" title="偏移尺寸"></a>偏移尺寸</h4><blockquote><ul><li>以下 5 个属性，都与元素的偏移尺寸有关 ,并且都是<strong>只读</strong>的</li><li>offsetWidth</li><li>offsetHeight</li><li>offsetParent</li><li>offsetLeft</li><li>offsetTop</li></ul></blockquote><ol><li>offsetWidth 与 offsetHeight<blockquote><ul><li>以下属性为<strong>只读</strong>的，<strong>每次访问都会重新计算</strong><table><thead><tr><th>属性</th><th>说明</th></tr></thead><tbody><tr><td>offsetWidth</td><td>返回一个元素的布局宽度；标准盒模型下，包括：width、border、padding、滚动条宽；怪异盒模型下为：width</td></tr><tr><td>offsetHeight</td><td>返回一个元素的布局高度；标准盒模型下，包括：height、border、padding、滚动条宽；怪异盒模型下为：height</td></tr></tbody></table></li></ul></blockquote></li></ol><pre><code>&gt;&lt;style&gt;  * &#123;    margin: 0;    padding: 0;  &#125;  .box &#123;    width: 200px;    height: 200px;    padding: 30px;    border: 10px solid red;    margin: 20px;  &#125;  .box1 &#123;    width: 100px;    height: 100px;    padding: 30px;    border: 10px solid blue;    margin: 20px;    /* box-sizing: border-box; */  &#125;&gt;&lt;/style&gt;&gt;&gt;&lt;div class=&quot;box&quot;&gt;&gt;  &lt;div class=&quot;box1&quot;&gt;&lt;/div&gt;&gt;&lt;/div&gt;&gt;&gt;&lt;script&gt;  var box1 = document.querySelector(&quot;.box1&quot;);  var _width = box1.offsetWidth;  var _height = box1.offsetHeight;  console.log(_width); // width+padding+border=100+60+20=180  console.log(_height); //  height+padding+border=100+60+20=180&gt;  // 如果box1更改为border-box，则最后输出结果为100 100&gt;&lt;/script&gt;</code></pre><ol start="2"><li>offsetParent<blockquote><ul><li>此属性为<strong>只读</strong>属性，每次访问都会<strong>重新计算</strong></li><li><strong>返回</strong>离当前元素<strong>最近的定位祖先元素</strong>或最近的 <code>table,td,th,tbody</code> 元素</li><li>在 Webkit 中，<ul><li>如果当前元素为隐藏的（该元素或其祖先元素的<code>style.display</code>为”none”），该属性返回 null。</li><li>或者该元素的<code>style.position</code>被设为”fixed”，则该属性返回 null。</li></ul></li></ul></blockquote></li></ol><pre class=" language-js"><code class="language-js"><span class="token operator">></span><span class="token operator">&lt;</span>style<span class="token operator">></span>  <span class="token punctuation">.</span>box <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>    position<span class="token punctuation">:</span> absolute<span class="token punctuation">;</span>  <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>  <span class="token punctuation">.</span>box1 <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">/* display: none; */</span>    position<span class="token punctuation">:</span> relative<span class="token punctuation">;</span>  <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>  <span class="token punctuation">.</span>box3 <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">/* position: fixed; */</span>    display<span class="token punctuation">:</span> none<span class="token punctuation">;</span>  <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span><span class="token operator">></span><span class="token operator">&lt;</span><span class="token operator">/</span>style<span class="token operator">></span><span class="token operator">></span>  <span class="token operator">&lt;</span><span class="token operator">!</span><span class="token operator">--</span>绝对定位<span class="token operator">--</span><span class="token operator">></span><span class="token operator">></span><span class="token operator">&lt;</span>div <span class="token keyword">class</span><span class="token operator">=</span><span class="token string">"box"</span><span class="token operator">></span>    <span class="token operator">&lt;</span><span class="token operator">!</span><span class="token operator">--</span>相对定位<span class="token operator">--</span><span class="token operator">></span>  <span class="token operator">&lt;</span>div <span class="token keyword">class</span><span class="token operator">=</span><span class="token string">"box1"</span><span class="token operator">></span>      <span class="token operator">&lt;</span><span class="token operator">!</span><span class="token operator">--</span>未定位<span class="token operator">--</span><span class="token operator">></span>    <span class="token operator">&lt;</span>div <span class="token keyword">class</span><span class="token operator">=</span><span class="token string">"box2"</span><span class="token operator">></span>      <span class="token operator">&lt;</span>div <span class="token keyword">class</span><span class="token operator">=</span><span class="token string">"box3"</span><span class="token operator">></span><span class="token operator">&lt;</span><span class="token operator">/</span>div<span class="token operator">></span>    <span class="token operator">&lt;</span><span class="token operator">/</span>div<span class="token operator">></span>  <span class="token operator">&lt;</span><span class="token operator">/</span>div<span class="token operator">></span><span class="token operator">></span><span class="token operator">&lt;</span><span class="token operator">/</span>div<span class="token operator">></span><span class="token operator">></span><span class="token operator">&lt;</span>script<span class="token operator">></span>  <span class="token comment" spellcheck="true">// 获取box3元素</span>  <span class="token keyword">var</span> box3 <span class="token operator">=</span> document<span class="token punctuation">.</span><span class="token function">querySelector</span><span class="token punctuation">(</span><span class="token string">".box3"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// 获取离box3最近的定位祖先元素</span>  <span class="token keyword">var</span> parent <span class="token operator">=</span> box3<span class="token punctuation">.</span>offsetParent<span class="token punctuation">;</span>  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>parent<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// null</span><span class="token operator">></span><span class="token operator">&lt;</span><span class="token operator">/</span>script<span class="token operator">></span></code></pre><ol start="3"><li>offsetLeft 和 offsetTop<blockquote><ul><li>以下两属性为<strong>只读</strong>属性，每次访问都会<strong>重新计算</strong></li><li>本质上可以简单理解为定位元素的top&#x2F;left值，但也会受到margin的影响<table><thead><tr><th>属性</th><th>说明</th></tr></thead><tbody><tr><td>offsetLeft</td><td>它返回当前元素(左边框)相对于其offsetParent元素的<strong>左边框内壁</strong>的距离</td></tr><tr><td>offsetTop</td><td>它返回当前元素(上边框)相对于其offsetParent元素的<strong>上边框内壁</strong>的距离</td></tr></tbody></table></li></ul></blockquote></li></ol><pre><code>&gt;&lt;style&gt;  * &#123;    margin: 0;    padding: 0;  &#125;  body &#123;    padding: 100px;  &#125;  .box1 &#123;    margin: 50px;    padding: 20px;    border: 5px solid blue;    width: 200px;    height: 200px;    position: relative;  &#125;  .box2 &#123;    border: 2px solid red;    height: 150px;  &#125;  .box3 &#123;    width: 100px;    height: 100px;    position: absolute;    border: 10px solid skyblue;    margin-top: 50px;    margin-left: 30px;    left: 20px;    top: 50px;  &#125;&gt;&lt;/style&gt;&gt;&gt;&lt;div class=&quot;box1&quot;&gt;  &lt;div class=&quot;box2&quot;&gt;    &lt;div class=&quot;box3&quot;&gt;&lt;/div&gt;  &lt;/div&gt;&gt;&lt;/div&gt;&gt;&gt;&lt;script&gt;  // 获取box3元素  var box3 = document.querySelector(&quot;.box3&quot;);  // 与离他最近的定位祖先元素左内边距的距离  var _left = box3.offsetLeft; // left + margin-left = 20 + 30 = 50  // 与离他最近的定位祖先元素上内边距的距离  var _top = box3.offsetTop; //  top + margin-top = 50 + 50 = 100  console.log(_left, _top);&gt;&lt;/script&gt;</code></pre><ol start="4"><li>计算元素与页面偏移量<blockquote><ul><li>如果要计算一个元素与页面的左偏移量,则需要把</li><li>当前元素与他<code>offsetParent</code>的<code>offsetLeft</code></li><li><code>offsetParent</code>的左边框宽度</li><li><code>offsetParent</code>的<code>offsetParent</code>元素的<code>offsetLeft</code></li><li><code>offsetParent</code>的<code>offsetParent</code>元素的做边框宽度</li><li>一层层相加，直到根元素(body)，body的<code>offsetParent</code>是<code>null</code><blockquote><p>一个元素与页面的上偏移量同理可得</p></blockquote></li></ul></blockquote></li></ol><ul><li>while 循环版</li></ul><pre><code>function getElementLeft(el) &#123;  // 获取当前元素左偏移量  var left = el.offsetLeft;  // 获了当前元素的offsetParent  var parent = el.offsetParent;  // 如果 offsetParent 存在，则一直获取,计算他的offsetLeft值，如果不存在，则终止  while (parent) &#123;    left += parent.offsetLeft; // 与每一轮元素的父元素与其定位父元素左边距离累加    // 计算父元素左边框大小    style = getComputedStyle(parent, null);    border = parseInt(style.borderLeftWidth); // 过滤单位部分，只取数字部分    // 把左边框累加进去    left += border;    parent = parent.offsetParent;  &#125;  // 最终返回获取的left值  return left;&#125;var box1 = document.querySelector(&quot;.box1&quot;);console.log(getLeft(box1));</code></pre><ul><li>递归版</li></ul><pre><code>function getElementLeft(el) &#123;  // 获取当前元素左边距  var left = el.offsetLeft;  // 获了当前元素的offsetParent  var parent = el.offsetParent;  // 如果 offsetParent 存在，则一直获取,计算他的offsetLeft值，如果不存在，则终止  if (parent) &#123;    // 计算父元素左边框大小    style = getComputedStyle(parent, null);    border = parseInt(style.borderLeftWidth); // 过滤单位部分，只取数字部分    // 把左边框累加进去    left += border;    left += getElementLeft(parent);  &#125;  return left;&#125;var box1 = document.querySelector(&quot;.box1&quot;);console.log(getLeft(box1));</code></pre><ol start="5"><li>总结<blockquote><ul><li>以下 5 个属性都与元素的<strong>偏移尺寸</strong>相关<img src="元素的偏移尺寸.png"></li></ul></blockquote></li></ol><blockquote><blockquote><p>重点强调</p><ul><li>以上偏移尺寸属性都是只读的，每次访问都会重新计算。因此，应该尽量减少查询它们的次数。</li><li>我们可以把查询的值保存在变量中，供后面使用，这样就可以避免影响性能。</li></ul></blockquote></blockquote><h4 id="案例"><a href="#案例" class="headerlink" title="案例"></a>案例</h4><ol><li>案例 1：求两元素中心点之间的距离<blockquote><ul><li>两个元素相对于同一个父元素定位，现在我们要求这两个元素中心点之间的距离。<img src="两元素中心点间的距离.png"></li></ul></blockquote></li></ol><pre><code>// 求两点之间的距离// obj1与obj2分别表示上图中 box1与box2function getDistance(obj1, obj2) &#123;  var a =    obj1.offsetLeft +    obj1.offsetWidth / 2 -    (obj2.offsetLeft + obj2.offsetWidth / 2);  var b =    obj1.offsetTop +    obj1.offsetHeight / 2 -    (obj2.offsetTop + obj2.offsetHeight / 2);  return Math.sqrt(a * a + b * b);&#125;</code></pre><blockquote><blockquote><ul><li>开平方：<code>Math.sqrt()</code></li></ul></blockquote></blockquote><ol start="2"><li>案例 2：找出与当前元素最近的一个元素<blockquote><ul><li>我们需要找到所有元素与当前元素的距离，然后再从中找出<strong>距离最小</strong>的那个元素(案例1)</li><li>我们可以新建一个数组，用来保存每个元素及每个元素与当前元素中心点的距离</li></ul></blockquote></li></ol><ul><li>数组结构如下</li></ul><pre><code>var elementArr = [  &#123;    element: li1, // html元素    distance: 30, // 与当前元素的最近距离  &#125;,  &#123;    element: li2,    distance: 50,  &#125;,];</code></pre><ul><li>最后找出数组中 distance 值最小的那一个对象中的 element 元素</li></ul><pre><code>// for循环遍历elementArr数组，找出数组中距离最小的那个元素，然后返回 var minElement = elementArr[0]; for (var j = 0; j &lt; elementArr.length; j++) &#123;   if (elementArr[j].distance &lt; minElement.distance) &#123;     minElement = elementArr[j];   &#125; &#125; return minElement.element; // 返回最小的距离的那个对象</code></pre><ul><li>代码实现：</li></ul><pre><code>&gt;&lt;body&gt;&gt;  &lt;div class=&quot;container&quot;&gt;&gt;    &lt;div class=&quot;box box1&quot;&gt;box1&lt;/div&gt;&gt;    &lt;div class=&quot;box box2&quot;&gt;box2&lt;/div&gt;&gt;    &lt;div class=&quot;box box3&quot;&gt;box3&lt;/div&gt;&gt;    &lt;div class=&quot;box box4&quot;&gt;box4&lt;/div&gt;&gt;  &lt;/div&gt;&gt;&gt; &lt;script&gt;  //通过数组下标查询  var conatiner = document.querySelector(&quot;.container&quot;);  var box = document.querySelectorAll(&quot;.container .box&quot;);&gt;  // 找出与obj元素距离最近的元素  function findNearest(obj) &#123;    var elementArr = [];    var len = box.length;    // 遍历每个元素，计算每个元素于obj的中心位置，然后保存到数组中    for (var i = 0; i &lt; len; i++) &#123;      // 当前被用来比较的obj，不用存到数组中，要排除      if (box[i] !== obj) &#123;        // 计算两中心点距离        var centerDistance = getDistance(box[i], obj);        // 把这个元素和对应中心点距离保存到数组中        var el = &#123;&#125;;        el.element = box[i];        el.distance = centerDistance;        elementArr.push(el);      &#125;    &#125;&gt;  // for循环遍历elementArr数组，找出数组中距离最小的那个元素，然后返回  var minElement = elementArr[0];  for (var j = 0; j &lt; elementArr.length; j++) &#123;    if (elementArr[j].distance &lt; minElement.distance) &#123;      minElement = elementArr[j];    &#125;  &#125;  return minElement.element; // 返回最小的距离的那个对象&#125;&gt;  console.log(findNearest(box[2]));&gt;  // 计算两个元素中心点位置  function getDistance(obj1, obj2) &#123;    var x =      obj1.offsetLeft +      obj1.offsetWidth / 2 -      (obj2.offsetLeft + obj2.offsetWidth / 2);&gt;  var y =    obj1.offsetTop +    obj1.offsetHeight / 2 -    (obj2.offsetTop + obj2.offsetHeight / 2);&gt;  return Math.sqrt(x * x + y * y);&#125;&gt; &lt;/script&gt;&gt;&lt;/body&gt;</code></pre><blockquote><ul><li>方法2：通过类名查询——见HTML文档</li></ul></blockquote><pre><code>// 获取与目标元素同级的兄弟元素var children = obj.parentNode.children;</code></pre><h4 id="客户端尺寸"><a href="#客户端尺寸" class="headerlink" title="客户端尺寸"></a>客户端尺寸</h4><blockquote><ul><li>以下两个属性为元素的客户端尺寸，属性为<strong>只读的</strong>，每次访问都会<strong>重新计算</strong><table><thead><tr><th>属性</th><th>说明</th></tr></thead><tbody><tr><td>clientWidth</td><td>表示元素的<strong>内容区宽</strong>，在标准盒模型下，包括 <code>width + padding</code>，不包括 <code>border + margin + 滚动条</code></td></tr><tr><td>clientHeight</td><td>表示元素的<strong>内容区高</strong>，在标准盒模型下，包括 <code>height + padding</code>，不包括 <code>border + margin + 滚动条</code></td></tr></tbody></table></li></ul></blockquote><pre><code>&gt;&lt;style&gt;  * &#123;    margin: 0;    padding: 0;  &#125;  .box &#123;    width: 200px;    height: 200px;    padding: 30px;    border: 10px solid red;    margin: 20px;  &#125;&gt;&lt;/style&gt;&gt;&gt;&lt;div class=&quot;box&quot;&gt;&gt;  &lt;div class=&quot;box1&quot;&gt;&lt;/div&gt;&gt;&lt;/div&gt;&gt;&gt;&lt;script&gt;  var box = document.querySelector(&quot;.box&quot;);  var w = box.clientWidth; // width + padding = 200 + 60 = 260  var h = box.clientHeight; // height + padding = 200 + 60 = 260  console.log(w, h);&gt;&lt;/script&gt;</code></pre><h4 id="滚动尺寸"><a href="#滚动尺寸" class="headerlink" title="滚动尺寸"></a>滚动尺寸</h4><blockquote><p>滚动尺寸，提供了元素内容滚动相关的信息。有以下四个属性</p><ul><li>scrollWidth</li><li>scrollHeight</li><li>scrollLeft</li><li>scrollTop</li></ul></blockquote><ol><li>scrollWidth 与 scrollHeight<blockquote><ul><li>若子元素宽度大于父盒子，那<code>scrollWidth</code>就是：子元素宽度+父盒子padding</li><li>若子元素宽度小于父盒子，那<code>scrollWidth</code>就是父元素<code>clientWidth</code>(width+padding-滚动条宽度)</li></ul></blockquote></li></ol><table><thead><tr><th>属性</th><th>说明</th></tr></thead><tbody><tr><td>scrollWidth</td><td>元素内容宽度的一种度量，包括由于<code>overflow</code>溢出而在屏幕上不可见的内容；如果没有水平滚动条，其它大小与 <code>clientWidth</code>相同</td></tr><tr><td>scrollHeight</td><td>元素内容高度的度量，包括由于<code>overflow</code>溢出导致的视图中不可见内容；如果没有垂直滚动条，其它大小与 <code>clientHeight</code>相同</td></tr></tbody></table><pre><code>&gt;&lt;style&gt;  .box &#123;    width: 200px;    height: 100px;    border: 2px solid red;    padding: 50px;    overflow: scroll;  &#125;  .box1 &#123;    width: 800px;    height: 800px;    &lt;!-- width: 100px;  --&gt;    &lt;!-- height: 500px;  --&gt;  background-color: skyblue;  &#125;&gt;&lt;/style&gt;&gt;&gt;&lt;div class=&quot;box&quot;&gt;&gt;  &lt;div class=&quot;box1&quot;&gt;    滚动的内容滚动的内容滚动的内容滚动的内容滚动的内容滚动的内容滚动的内容滚动的内容&gt;  &lt;/div&gt;&gt;&lt;/div&gt;&gt;&lt;script&gt;  var box = document.querySelector(&quot;.box&quot;);  var _w = box.scrollWidth;  var _h = box.scrollHeight;  console.log(_w, _h); // 900 900  &lt;!-- console.log(_w, _h); // 279 600 --&gt;&gt;&lt;/script&gt;</code></pre><ol start="2"><li>scrollLeft 和 scrollTop<blockquote><ul><li><code>scrollLeft</code>和<code>scrollTop</code>为 <strong>可读可写</strong> 属性<table><thead><tr><th>属性</th><th>说明</th></tr></thead><tbody><tr><td>scrollLeft</td><td>获取或设置一个元素的内容水平滚动的距离；如果元素没有产生水平方向滚动条，那 scrollLeft &#x3D; 0；设置scrollLeft的值小于 0，scrollLeft 被设为0；如果设置了超出这个容器可滚动的值，scrollLeft 会被设为最大值</td></tr><tr><td>scrollTop</td><td>获取或设置一个元素的内容垂直滚动的距离；如果元素没有产生垂直方向滚动条，那 scrollTop &#x3D; 0；如果scrollTop的值小于 0，scrollTop 会被设为0；如果设置了超出这个容器可滚动的值，scrollTop 会被设为最大值</td></tr></tbody></table></li></ul></blockquote></li></ol><img src="scrollTop和scrollLeft.png"><pre><code>&gt;&lt;style&gt;  .box &#123;    width: 200px;    height: 100px;    border: 2px solid red;    padding: 50px;    overflow: scroll;    border: 50px solid khaki;  &#125;  .box1 &#123;    width: 800px;    height: 800px;    background-color: skyblue;  &#125;&gt;&lt;/style&gt;&gt;&gt;&lt;div class=&quot;box&quot;&gt;&gt;  &lt;div class=&quot;box1&quot;&gt;    滚动的内容滚动的内容滚动的内容滚动的内容滚动的内容滚动的内容滚动的内容滚动的内容&gt;  &lt;/div&gt;&gt;&lt;/div&gt;&gt;&gt;&lt;script&gt;  var box = document.querySelector(&quot;.box&quot;);  box.onscroll = function () &#123;    console.log(box.scrollTop); // 打印滚动条滚动的高度    console.log(box.scrollLeft); // 打印滚动条滚动的宽度  &#125;;&gt;//修改滚动距离(根据scrollWidth/height得到滚动条宽高)  // 滚动条，滚动到底部  box.scrollTop = 721; // 800-100+21=721 要注意，不要多减了滚动条的高度  // 滚动条，滚动到最右边  box.scrollLeft = 621; // 800-200+21=621 要注意，不要多减了滚动条的宽度&gt;&lt;/script&gt;</code></pre><h4 id="确定元素尺寸"><a href="#确定元素尺寸" class="headerlink" title="确定元素尺寸"></a>确定元素尺寸</h4><blockquote><ul><li>浏览器在每个元素上都暴露了<code>getBoundingClientRect()</code>方法，返回一个 <code>DOMRect 对象</code></li><li>该对象提供了元素的大小及其相对于<strong>视口（可视区）</strong>的位置<blockquote><p>相关属性如下：</p></blockquote></li></ul></blockquote><table><thead><tr><th>属性</th><th>说明</th></tr></thead><tbody><tr><td>left、x</td><td>元素左边框相对于可视区左边的距离</td></tr><tr><td>top、y</td><td>元素上边框框相对于可视区顶部的距离</td></tr><tr><td>right</td><td>元素右边框相对于可视区左边的距离</td></tr><tr><td>bottom</td><td>元素底边框相对于可视区顶部的距离</td></tr><tr><td>height</td><td>元素的高，包括 height + padding + border</td></tr><tr><td>width</td><td>元素的宽，包括 width + padding + border</td></tr></tbody></table><img src="确定元素尺寸.png"><pre><code>&gt;&lt;style&gt;   body &#123;    margin:0;    height: 3000px;  &#125;  .box &#123;    width: 100px;    height: 100px;    border: 2px solid red;    padding: 20px;    border: 20px solid khaki;  &#125;&gt;&lt;/style&gt;&gt;&gt;&lt;div class=&quot;box&quot;&gt;&lt;/div&gt;&gt;&gt;&lt;script&gt;  var box = document.querySelector(&quot;.box&quot;);  var domRect = box.getBoundingClientRect();  console.log(domRect); // 打印 DOMRect对象  // 遍历对象  for (key in domRect) &#123;    if (typeof domRect[key] !== &quot;function&quot;) &#123;      // 过滤掉方法，只留下属性      console.log(key + &quot;:&quot; + domRect[key]);    &#125;  &#125;&gt;  // 滚动浏览器窗口  window.onscroll = function () &#123;    var domRect = box.getBoundingClientRect();    console.log(domRect);  &#125;;&gt;&lt;/script&gt;</code></pre><h4 id="案例-1"><a href="#案例-1" class="headerlink" title="案例"></a>案例</h4><ol><li>如何判断两个元素发生了碰撞（经典面试题）<img src="碰撞检测.png"></li></ol><blockquote><ul><li>相对于浏览器的位置或相对于同一父元素</li></ul></blockquote><ul><li>用<code>getBoundingClientRect()</code>方法</li></ul><pre><code>&gt;&lt;div class=&quot;box1&quot;&gt;&lt;/div&gt;&gt;    &lt;div class=&quot;box2&quot;&gt;&lt;/div&gt;&gt;&gt;&lt;script&gt;  function isBump(obj1, obj2) &#123;    var domRect1 = box1.getBoundingClientRect();    var T1 = domRect1.top;    var B1 = domRect1.bottom;    var L1 = domRect1.left;    var R1 = domRect1.right;    var domRect2 = box2.getBoundingClientRect();    var T2 = domRect2.top;    var B2 = domRect2.bottom;    var L2 = domRect2.left;    var R2 = domRect2.right;    if (L2 &gt; R1 || T1 &gt; B2 || L1 &gt; R2 || T2 &gt; B1) return false;    return true;  &#125;  var box1 = document.querySelector(&quot;.box1&quot;);  var box2 = document.querySelector(&quot;.box2&quot;);  isBump(box1, box2);&gt;&lt;/script&gt;</code></pre><ul><li>用偏移尺寸</li></ul><pre><code>function isBump(obj1, obj2) &#123;  var L1 = obj1.offsetLeft;  var R1 = L1 + obj1.offsetWidth;  var T1 = obj1.offsetTop;  var B1 = T1 + obj1.offsetHeight;  var L2 = obj2.offsetLeft;  var R2 = L2 + obj2.offsetWidth;  var T2 = obj2.offsetTop;  var B2 = T2 + obj2.offsetHeight;  if (L2 &gt; R1 || L1 &gt; R2 || T2 &gt; B1 || T1 &gt; B2) &#123;    return false; // 未碰撞，返回false  &#125; else &#123;    return true; // 碰撞，返回true  &#125;&#125;</code></pre><ol start="2"><li>判断元素是否在可视区（经典面试题）<blockquote><ul><li>判断一个元素是不是在可视区，只有元素<strong>全在可视区</strong>，才算是在可视区内<img src="元素是否在可视区内.png"></li></ul></blockquote></li></ol><ul><li>在浏览器可视区内</li></ul><pre><code>// 判断元素是否是在可视区内，只有当元素全部在可视区内才算是在可视区内function isElementInViewport(el) &#123;  var rect = el.getBoundingClientRect();  var T1 = rect.top;  var B1 = rect.bottom;  var L1 = rect.left;  var R1 = rect.right;  return (    T1 &gt;= 0 &amp;&amp;    B1 &lt;= document.documentElement.clientHeight &amp;&amp;    L1 &gt;= 0 &amp;&amp;    R1 &lt;= document.documentElement.clientWidth  );&#125;&gt;&gt; // 测试，自行在页面加一个.box的div&gt; var box = document.querySelector(&quot;.box&quot;);&gt; window.onscroll = function () &#123;&gt;   console.log(isElementInViewport(box));&gt; &#125;;</code></pre><ul><li>在父级盒子可视区内</li></ul><pre><code>function isInViewport(el) &#123;  var T1 = el.offsetTop;  var B1 = T1 + el.offsetHeight;  var L1 = el.offsetLeft;  var R1 = L1 + el.offsetWidth;  var PH = el.offsetParent.clientHeight;  var PW = el.offsetParent.clientWidth;  return T1 &gt;= 0 &amp;&amp; L1 &gt;= 0 &amp;&amp; B1 &lt;= PH &amp;&amp; R1 &lt;= PW;&#125;var box1 = document.querySelector(&quot;.box1&quot;);console.log(isInViewport(box1));</code></pre><h3 id="六、节点操作"><a href="#六、节点操作" class="headerlink" title="六、节点操作"></a>六、节点操作</h3><blockquote><p>接下来我们来学习与节点相关的操作，在开始学习 DOM 的时候，我们提到过 DOM 的节点类型有以下 7 种</p></blockquote><h4 id="节点类型"><a href="#节点类型" class="headerlink" title="节点类型"></a>节点类型</h4><table><thead><tr><th>节点分类</th><th>描述</th></tr></thead><tbody><tr><td>Document 文档节点</td><td>整个 DOM 树的顶层节点</td></tr><tr><td>DocumentType 文档类型节点</td><td>如 doctype 标签(<code>&lt;!DOCTYPE html&gt;)</code></td></tr><tr><td>Element 元素节点</td><td>网页的各种 HTML 标，如：<code>&lt;p&gt;</code>、<code>&lt;div&gt;</code></td></tr><tr><td>Attr 属性节点</td><td>元素的各种属性，如：<code>title=&#39;标题&#39;</code>、<code>class=&#39;box&#39;</code></td></tr><tr><td>Text 文本节点</td><td>标签之间或标签包含的文本</td></tr><tr><td>Comment 注释节点</td><td>网页中的注释</td></tr><tr><td>DocumentFragment 文档片段</td><td>文档片段，不存于 DOM 树上，是一种游离态，通常作为仓库来使用</td></tr></tbody></table><blockquote><p>如何检测节点的类型呢 ？其实每一个节点对象都有以下三个属性：</p><ul><li>nodeName 节点名</li><li>nodeType 节点类型</li><li>nodeValue 节点值<table><thead><tr><th>节点类型</th><th>nodeName</th><th>nodeType</th><th>nodeValue</th></tr></thead><tbody><tr><td>文档节点</td><td>#document</td><td>9</td><td>null</td></tr><tr><td>元素节点</td><td>标签名</td><td>1</td><td>null</td></tr><tr><td>属性节点</td><td>属性名</td><td>2</td><td>属性值</td></tr><tr><td>文本节点</td><td>#text</td><td>3</td><td>文本内容</td></tr></tbody></table></li></ul></blockquote><h4 id="节点关系"><a href="#节点关系" class="headerlink" title="节点关系"></a>节点关系</h4><ol><li>考虑所有节点<blockquote><ul><li>文本节点<code>#text</code>（即实是空白的文本）也属于节点。标签与标签之间有文本节点<br>页面节点之间存在以下关系<table><thead><tr><th>关系</th><th>考虑所有节点</th></tr></thead><tbody><tr><td>子节点</td><td>childNodes</td></tr><tr><td>父节点</td><td>parentNode</td></tr><tr><td>第一个子节点</td><td>firstChild</td></tr><tr><td>最后一个子节点</td><td>lastChild</td></tr><tr><td>前一个兄弟节点</td><td>previousSibling</td></tr><tr><td>后一个兄弟节点</td><td>nextSibling</td></tr></tbody></table></li></ul></blockquote></li></ol><pre><code>&gt;&lt;div class=&quot;box&quot;&gt;&gt;  &lt;h3 class=&quot;title&quot;&gt;我是h3标签&lt;/h3&gt;&gt;  &lt;p class=&quot;p1&quot;&gt;我是p标签&lt;/p&gt;&gt;  &lt;div class=&quot;item&quot;&gt;我是item&lt;/div&gt;&gt;&lt;/div&gt;&gt;&lt;script&gt;&gt;  var box = document.querySelector(&quot;.box&quot;);&gt;  console.log(box.childNodes);&gt;  console.log(box.parentNode); //body&gt;  console.log(box.firstChild); //#text&gt;  console.log(box.lastChild); //#text&gt;  var p1 = document.querySelector(&quot;.p1&quot;);&gt;  console.log(p1.previousSibling); //#text&gt;  console.log(p1.nextSibling); //#text&gt;&lt;/script&gt;</code></pre><blockquote><blockquote><p>注意点：文本节点也属于节点</p></blockquote><ul><li>而我们实际开发中，我们常常希望获取的是元素类型的节点，所以文本类型的节点给我们带来了很大的干扰。</li></ul></blockquote><ol start="2"><li>只考虑元素节点<blockquote><ul><li>实际上在 DOM 中还提供了一些<strong>只考虑元素节点</strong>的属性，如下表</li><li>我们把考虑所有节点的属性与只考虑元素节点的属性作如下<strong>对比</strong><table><thead><tr><th>关系</th><th>考虑所有节点</th><th>只考虑元素节点</th></tr></thead><tbody><tr><td>子节点</td><td>childNodes</td><td>children</td></tr><tr><td>父节点</td><td>parentNode</td><td>parentNode</td></tr><tr><td>第一个子节点</td><td>firstChild</td><td>fristElementChild</td></tr><tr><td>最后一个子节点</td><td>lastChild</td><td>lastElementChild</td></tr><tr><td>前一个兄弟节点</td><td>previousSibling</td><td>previousElementSibling</td></tr><tr><td>后一个兄弟节点</td><td>nextSibling</td><td>nextElementSibling</td></tr></tbody></table></li></ul></blockquote></li></ol><pre><code>&gt;&lt;div class=&quot;box&quot;&gt;&gt;  &lt;h3 class=&quot;title&quot;&gt;我是h3标签&lt;/h3&gt;&gt;  &lt;p class=&quot;p1&quot;&gt;我是p标签&lt;/p&gt;&gt;  &lt;div class=&quot;item&quot;&gt;我是item&lt;/div&gt;&gt;&lt;/div&gt;&gt;&lt;script&gt;&gt;  var box = document.querySelector(&quot;.box&quot;);&gt;  var p1 = document.querySelector(&quot;.p1&quot;);//只考虑元素节点  console.log(box.children);  console.log(box.firstElementChild); //h3  console.log(box.lastElementChild); //item  console.log(p1.previousElementSibling); //h3  console.log(p1.nextElementSibling); //item&gt;&lt;/script&gt;</code></pre><ol start="3"><li>手写 children 方法<blockquote><p>实现思路</p><ul><li>用<code>当前节点.childNodes</code>获取所有子节点，然后遍历所有子节点，判断节点的类型<code>nodeType 是否为 1</code></li><li>如果为 1，则把这个节点添加到<strong>数组</strong>中</li><li>最后遍历完，把数组作为返回值返回。</li></ul></blockquote></li></ol><pre><code>HTMLElement.prototype._children = function () &#123;  // this 指向，谁调用_children 那this就是谁  var nodes = this.childNodes;  var elementArr = [];  // 过滤节点类型，只留下元素类型节点  for (var i = 0; i &lt; nodes.length; i++) &#123;    if (nodes[i].nodeType === 1) &#123;      // 是元素类型节点，保存      elementArr.push(nodes[i]);    &#125;  &#125;  return elementArr;&#125;;var box = document.querySelector(&quot;.box&quot;);console.log(box._children());</code></pre><ol start="4"><li>手写 prevElementSibling 方法<blockquote><p>实现思路</p><ul><li><code>当前节点.previousSibling</code></li><li>如果返回值为<code>null</code>，说明<strong>没有</strong>上一个元素兄弟节点，直接将返回值<code>null</code>返回</li><li>如果返回值不为 <code>null</code>，要<strong>判断</strong>节点类型是否为元素节点，即判断<code>返回节点.nodeType === 1</code>是否成立</li><li>如果不成立，则继续用<code>返回的节点.previousSibling</code>，一直重复上面过程，直到<code>返回节点.nodeType === 1</code>成立或返回值为 <code>null</code>，就不再继续查找了。</li></ul></blockquote></li></ol><pre><code>HTMLElement.prototype._prevElementSibling = function () &#123;  // this，谁打点调用这个方法，this是谁  var prevElement = this.previousSibling; // 找上一个兄弟节点  // if(!prevElement) return null;  // 如果返回的兄弟节点不为null 且节点类型不等于1，说明当前兄弟节点不是元素类型节点，需要继续向上查找。  //顺序不能调换，因为如果prevElement是null，调用nodeType会报错  while (prevElement &amp;&amp; prevElement.nodeType !== 1) &#123;    prevElement = prevElement.previousSibling;    // if (!prevElement) return null;  &#125;  return prevElement; // 如果上面为null，直接返回null,如果不是，返回对应元素节点&#125;;</code></pre><h4 id="修改节点内容"><a href="#修改节点内容" class="headerlink" title="修改节点内容"></a>修改节点内容</h4><blockquote><ul><li>改变元素节点中的内容可以使用两个相关属性：</li><li>innerHTML：更改元素的内容，更改的内容能以<strong>HTML语法</strong>的形式显示</li><li>innerText：更改的内容，更改的内容只能以<strong>纯文本</strong>的形式显示</li></ul></blockquote><pre><code>&gt;&lt;div class=&quot;box&quot;&gt;&lt;/div&gt;&gt;&lt;div class=&quot;box&quot;&gt;&lt;/div&gt;&gt;&gt;&lt;script&gt;  var box = document.getElementsByClassName(&quot;box&quot;);  box[0].innerHTML = &quot;&lt;h3&gt;我是h3标签&lt;/h3&gt;&quot;;  box[1].innerText = &quot;&lt;h3&gt;我是h3标签&lt;/h3&gt;&quot;;&gt;&lt;/script&gt;</code></pre><h4 id="节点创建与移动"><a href="#节点创建与移动" class="headerlink" title="节点创建与移动"></a>节点创建与移动</h4><blockquote><ul><li>DOM 中提供了以下方法，用来创建节点，并将创建好的节点插入到页面当中</li></ul></blockquote><table><thead><tr><th>操作节点方法</th><th>作用</th></tr></thead><tbody><tr><td>document.createElement(‘标签名’)</td><td>用来创建一个指定的<strong>元素节点</strong>对象，并将创建好的对象作为返回值</td></tr><tr><td>document.createTextNode(‘文本内容’)</td><td>用来创建一个<strong>文本节点</strong>对象，并将创建好的对象作为返回值。</td></tr><tr><td>父节点.appendChild(‘子节点对象’)</td><td>用来向父节点的<strong>最后面</strong>添加一个新的子节点。</td></tr><tr><td>父节点.insertBefore(‘新节点’,’旧节点’)</td><td>将新创建的”孤儿节点”插入到页面原有的节点的<strong>前面</strong></td></tr></tbody></table><ol><li><p>document.createElement()</p><blockquote><ul><li><code>document.createElement()</code>方法用于创建一个指定 <code>tagName</code>的HTML元素</li><li>在创建元素之前，会将传入的tagName转化为<strong>小写</strong>，即生成的标签名是小写名</li><li>创建出来的节点是一个<strong>“孤儿节点”</strong>，他并不在 DOM 树上，而是<strong>独立存在</strong>的。</li><li>所以我们必须使用<code>appendChild()</code>或<code>insertBefore()</code>方法将孤儿节点<strong>插入到 DOM 树上</strong></li><li><code>var myDiv = document.createElement(&quot;div&quot;); //  创建一个标签名为div的元素节点</code></li></ul></blockquote></li><li><p>document.createTextNode()</p><blockquote><ul><li>用来创建一个文本节点对象，并将创建好的对象作为返回值</li><li><code>var text = document.createTextNode(data);</code><ul><li>text 是一个文本节点。</li><li>data 是一个字符串，包含了要放入文本节点的内容</li></ul></li></ul></blockquote></li><li><p>appendChild()</p><blockquote><ul><li>该方法将一个节点附加到指定父节点的子节点列表的末尾处</li><li>如果某个节点已经拥有父节点，在被传递给此方法后，它首先会被<strong>移除</strong>，再被插入到新的位置</li><li>这意味着，一个节点<strong>不可能</strong>同时出现在文档的不同位置<blockquote><p>返回值：<code>appendChild()</code>返回的是被附加的子元素</p></blockquote></li></ul></blockquote></li></ol><pre><code>element.appendChild(child);&gt;// element  将节点追节到的那个父节点// child 要追加给父节点的节点（通通是一个元素节点）</code></pre><blockquote><ul><li>代码演示：</li></ul></blockquote><pre><code>//获取页面元素var ul = document.querySelector(&quot;ul&quot;);//将div插入到ul的最后面var div = document.createElement(&quot;div&quot;);ul.appendChild(div);&gt;//将文本节点插入到ul的最后面var pt = document.createTextNode(&quot;我是一个文本节点&quot;);ul.appendChild(pt);&gt;//将文本节点插入到li中var li = document.createElement(&quot;li&quot;);ul.appendChild(li);li.appendChild(pt);</code></pre><ol start="4"><li>insertBefore()<blockquote><ul><li>方法在参考节点之前插入一个拥有指定父节点的子节点</li><li>如果被插入节点已经有父节点，则会从当前位置移动到新插入位置<blockquote><p>返回值：返回被插入的子节点</p></blockquote></li><li><code>parentNode.insertBefore(newNode, referenceNode);</code><ul><li><code>parentNode</code>是<strong>参考节点</strong>的父节点<blockquote><p>如果<code>referenceNode</code> 为 <code>null</code> 则 <code>newNode</code> 将被插入到子节点的末尾</p></blockquote></li></ul></li></ul></blockquote></li></ol><blockquote><ul><li>功能一：创建新元素，插入到指定元素前</li></ul></blockquote><pre><code>&gt;&lt;ul&gt;&gt;  &lt;li&gt;1&lt;/li&gt;&gt;  &lt;li&gt;2&lt;/li&gt;&gt;  &lt;li&gt;3&lt;/li&gt;&gt;&lt;/ul&gt;&gt;&lt;script&gt;  //获取ul  var oul = document.querySelector(&quot;ul&quot;);  //创建li元素  var li1 = document.createElement(&quot;li&quot;);  // 创建文本元素  var liText = document.createTextNode(&quot;我是新创建的li文本&quot;);  //   将文本元素插入到li1中  li1.appendChild(liText);  //   将li1插入到第二个li前面  oul.insertBefore(li1, oul.children[1]);&gt;&lt;/script&gt;</code></pre><blockquote><ul><li>功能二：移动元素</li></ul></blockquote><pre><code>&gt;&lt;ul&gt;&gt;  &lt;li&gt;1&lt;/li&gt;&gt;  &lt;li&gt;2&lt;/li&gt;&gt;  &lt;li&gt;3&lt;/li&gt;&gt;&lt;/ul&gt;&gt;&lt;script&gt;  //获取ul  var oul = document.querySelector(&quot;ul&quot;);  //获取li元素  var li = document.getElementsByTagName(&quot;li&quot;);  //将最后一个li移动到最前面  oul.insertBefore(li[3], li[0]);  //如果第二个参数为null，新节点将移动到父节点的最后面  oul.insertBefore(li[1], null);&gt;&lt;/script&gt;</code></pre><ol start="5"><li>综合代码</li></ol><pre><code>&gt;&lt;ul&gt;&gt;  &lt;li&gt;1&lt;/li&gt;&gt;  &lt;li&gt;2&lt;/li&gt;&gt;  &lt;li&gt;3&lt;/li&gt;&gt;&lt;/ul&gt;&gt;&lt;script&gt;  // 获取元素  var ul = document.querySelector(&quot;ul&quot;);  var li = document.getElementsByTagName(&quot;li&quot;);  //创建节点  var div = document.createElement(&quot;div&quot;);  // 修改/新建节点内容  div.innerHTML = &quot;&lt;h3&gt;我是idv中的h3标签&lt;/h3&gt;&quot;;  // 插入到页面中,appendChild是移到父元素最后面  ul.appendChild(div);  //  移动节点：将新建元素插到li[1]前面  ul.insertBefore(div, li[1]);&gt;&lt;/script&gt;</code></pre><h4 id="案例-2"><a href="#案例-2" class="headerlink" title="案例"></a>案例</h4><ol><li>请动态创建出一个 15 行 10 列的表格<blockquote><ul><li>方式1：创建table,tr,td标签</li></ul></blockquote></li></ol><pre><code>&gt;&lt;div class=&quot;table1&quot;&gt;&lt;/div&gt;&gt;&lt;script&gt;// 获取元素function creatTable1(rows, columns, el) &#123;  var table = document.createElement(&quot;table&quot;);  for (var i = 1; i &lt;= rows; i++) &#123;    // 创建行    var tr = document.createElement(&quot;tr&quot;);    for (var j = 1; j &lt;= columns; j++) &#123;      // 创建列      var td = document.createElement(&quot;td&quot;);      // 将列插入行中      tr.appendChild(td);    &#125;    // 将行插入表格中    table.appendChild(tr);  &#125;  // 将表格插入到页面中  el.appendChild(table);&#125;var table1 = document.querySelector(&quot;.table1&quot;);creatTable1(15, 10, table1);&gt;&lt;/script&gt;</code></pre><blockquote><ul><li>方式2：创建ul,li,span标签</li></ul></blockquote><pre><code>&gt;&lt;div class=&quot;table2&quot;&gt;&lt;/div&gt;&gt;&lt;script&gt;// 获取元素 function creatTable2(rows, columns, el) &#123;   var ul = document.createElement(&quot;ul&quot;);   for (var i = 1; i &lt;= rows; i++) &#123;     // 创建行     var li = document.createElement(&quot;li&quot;);     for (var j = 1; j &lt;= columns; j++) &#123;       // 创建列       var span = document.createElement(&quot;span&quot;);       // 将列插入行中       li.appendChild(span);     &#125;     // 将行插入ul中     ul.appendChild(li);   &#125;   // 将表格插入到页面中   el.appendChild(ul); &#125; var table2 = document.querySelector(&quot;.table2&quot;); creatTable2(5, 5, table2);&gt;&lt;/script&gt;</code></pre><blockquote><blockquote><p><code>span</code>要转换为行内元素</p></blockquote></blockquote><ol start="2"><li>案例 2：请制作九九乘法表<blockquote><ul><li>列数与行数一致</li><li>表格内插入文字：<code>innerText</code></li></ul></blockquote></li></ol><pre><code>&gt;&lt;div class=&quot;mytable&quot;&gt;&lt;/div&gt;&gt;&lt;script&gt;  // 创建表格  var table = document.createElement(&quot;table&quot;);  for (var i = 1; i &lt;= 9; i++) &#123;    // 创建行    var tr = document.createElement(&quot;tr&quot;);    for (var j = 1; j &lt;= i; j++) &#123;      // 创建列，输入文字      var td = document.createElement(&quot;td&quot;);      td.innerText = i + &quot;*&quot; + j + &quot;=&quot; + i * j;      //   将td插入行中      tr.appendChild(td);    &#125;    // 将行插入表格    table.appendChild(tr);  &#125;  var mytable = document.querySelector(&quot;.mytable&quot;);  // 将表格插入页面  mytable.appendChild(table);&gt;&lt;/script&gt;</code></pre><ol start="3"><li>案例 3：创建电影座位号<blockquote><ul><li>根据需求，创建几行几列的电影座位号<br>关键点：</li><li>座位号：用累加器</li><li>顺序是从下往上，所以用<code>insertBefore</code></li></ul></blockquote></li></ol><pre><code>&gt;&lt;div class=&quot;table&quot;&gt;&lt;/div&gt;&gt;&lt;script&gt;  function getSeats(rows, columns, el) &#123;    var ul = document.createElement(&quot;ul&quot;);    var sum = 0;    for (var i = 1; i &lt;= rows; i++) &#123;      // 创建行      var li = document.createElement(&quot;li&quot;);      for (var j = 1; j &lt;= columns; j++) &#123;        // 创建列        var div = document.createElement(&quot;div&quot;);        sum++;        div.innerText = sum;        li.appendChild(div);      &#125;      ul.insertBefore(li, ul.children[0]);    &#125;    el.appendChild(ul);  &#125;  var table = document.querySelector(&quot;.table&quot;);  getSeats(5, 5, table);&gt;&lt;/script&gt;</code></pre><h4 id="innerHTML-与-createElement-的效率问题"><a href="#innerHTML-与-createElement-的效率问题" class="headerlink" title="innerHTML 与 createElement 的效率问题"></a>innerHTML 与 createElement 的效率问题</h4><blockquote><ul><li><code>innerHTML</code>更改元素的内容，更改的内容能以 HTML 语法的形式显示</li><li><code>createElement</code>用于动态创建 HTML 元素，然后结合 <code>appendChild</code>将元素插入到页面中<blockquote><p>这两种方式都可以动态创建 HTML 元素，那一种效率更高呢 ？我们通过一个案例来分析</p></blockquote></li></ul></blockquote><ol><li>在页面动态创建 1000 个 li，插入到页面中</li></ol><pre><code>&gt;&lt;ul class=&quot;list&quot;&gt;&lt;/ul&gt;&gt;&lt;script&gt;  var oUl = document.querySelector(&quot;.list&quot;);&gt;  //innerHTML实现  console.time(&quot;innerHTML&quot;);  for (var i = 1; i &lt;= 1000; i++) &#123;    oUl.innerHTML += &quot;&lt;li&gt;这是第&quot; + i + &quot;条新闻&lt;/li&gt;&quot;;  &#125;  console.timeEnd(&quot;innerHTML&quot;); // 238.225830078125 ms&gt;  // createElement实现  console.time(&quot;createElement&quot;);  for (var j = 1; j &lt;= 1000; j++) &#123;    var oLi = document.createElement(&quot;li&quot;);    oLi.innerText = &quot;这是第&quot; + j + &quot;条新闻&quot;;    oUl.appendChild(oLi);  &#125;  console.timeEnd(&quot;createElement&quot;); //3.586669921875 ms&gt;  //innerHTML优化版  var oUl = document.querySelector(&quot;.list&quot;);  console.time(&quot;innerHTML&quot;);  var str = &quot;&quot;;  for (var i = 1; i &lt;= 1000; i++) &#123;    str += &quot;&lt;li&gt;这是第&quot; + i + &quot;条新闻&lt;/li&gt;&quot;;  &#125;  oUl.innerHTML += str;  console.timeEnd(&quot;innerHTML&quot;); // 0.52294921875 ms&gt;&lt;/script&gt;</code></pre><blockquote><blockquote><p>分析：以上代码中</p></blockquote><ul><li><code>innerHTML</code>的执行效率明显比<code>createElement</code>的方式要<strong>低很多</strong>，原因在于<ul><li>每次迭代都要设置一次 <code>innerHTML</code>，在设置 <code>innerHTML</code> 前还要先读取 <code>innerHTML</code>。而且每次读取和插入都是把之前的所有节点读取出来。</li><li>而 <code>createElement</code> 每次迭代，只是把新创建的元素插入到之前元素的后面。</li></ul></li><li>所以我们最后的优化版是通过一个字符串来拼接所有内容，然后再一次性的插入到页面中。</li></ul></blockquote><ol start="2"><li><p>innerHTML、createElement 总结</p><table><thead><tr><th></th><th>说明</th></tr></thead><tbody><tr><td>innerHTML</td><td>在操作时相对结构复杂，可读性不强，如果内容较<strong>少</strong>，可以使用，不过要注意把内容拼接成<strong>字符串</strong>，一次性插入到页面；同时，如果内容为用户输入时，要考虑<strong>安全问题</strong></td></tr><tr><td>createElement</td><td>创建元素相对复杂些，但可读性强，如果内容较<strong>多</strong>，建议使用这种方式</td></tr></tbody></table></li><li><p>innerHTML 安全问题</p><blockquote><ul><li>如果页面中需要提供<strong>用户输入的信息</strong>，那建议不要使用 <code>innerHTML</code>。因为有可能会造成<code>XSS攻击</code>。</li><li>所谓XSS攻击全称是<code>&#39;Cross Site Scripting&#39;</code>跨站脚本。</li><li>是指黑客往 HTML 文件中或者 DOM 中注入恶意脚本，从而在用户浏览页面时利用注入的恶意脚本对用户实施攻击的一种手段。<blockquote><p>2015 年喜马拉雅就被爆出了对应的<code>XSS 漏洞</code>，是因为用户在设置专辑名称时，服务器对关键字过滤不严格，可以将专辑名设置为一段 <code>Javascript</code>。</p></blockquote></li></ul></blockquote></li></ol><h4 id="删除节点"><a href="#删除节点" class="headerlink" title="删除节点"></a>删除节点</h4><blockquote><p>DOM 中删除一个子节点，<strong>返回</strong>删除的节点。</p><ul><li><code>var oldChild = node.removeChild(child);</code><ul><li><code>child</code> 是要移除的那个子节点。</li><li><code>node</code> 是<code>child</code>的父节点。</li><li><code>oldChild</code>保存对删除的子节点的引用。<code>oldChild === child</code><blockquote><p>注意：节点不能主动删除自己，必须由父节点删除它</p></blockquote></li></ul></li></ul></blockquote><pre><code>&gt;&lt;div class=&quot;box&quot;&gt;&gt;  &lt;h3 class=&quot;title&quot;&gt;我是标题&lt;/h3&gt;&gt;&lt;/div&gt;&gt;&lt;script&gt;  var box = document.querySelector(&quot;.box&quot;);  var h3 = document.querySelector(&quot;.title&quot;);&gt;  // 删除h3标签，方法一:先找到父节点，然后删除其子节点  // var _h3 = box.removeChild(h3);  // console.log(_h3);&gt;  // 删除h3标签，方法二：通过自身调用parentNode，将自身删除  h3.parentNode.removeChild(h3);&gt;&lt;/script&gt;</code></pre><blockquote><blockquote><p>更推荐使用<code>.parentNode</code>的方式找到父节点</p></blockquote></blockquote><blockquote><ul><li>删除一个元素的所有子节点</li></ul></blockquote><pre><code>&gt;&lt;ul class=&quot;list&quot;&gt;&gt;  &lt;li&gt;1&lt;/li&gt;&gt;  &lt;li&gt;2&lt;/li&gt;&gt;  &lt;li&gt;3&lt;/li&gt;&gt;  &lt;li&gt;4&lt;/li&gt;&gt;  &lt;li&gt;5&lt;/li&gt;&gt;  &lt;li&gt;6&lt;/li&gt;&gt;  &lt;li&gt;7&lt;/li&gt;&gt;&lt;/ul&gt;&gt;&gt;&lt;script&gt;//方法1：var oUl = document.querySelector(&quot;.list&quot;);// 如果有第一个子元素，就将他给删除// while (oUl.firstChild) &#123;//   oUl.removeChild(oUl.firstChild);// &#125;&gt;// 最简单的方法oUl.innerHTML = &quot;&quot;;&gt;&lt;/script&gt;</code></pre><h4 id="节点的替换（修改）"><a href="#节点的替换（修改）" class="headerlink" title="节点的替换（修改）"></a>节点的替换（修改）</h4><blockquote><ul><li><code>replaceChild</code>方法用指定的节点替换当前节点的一个子节点，并返回被替换掉的节点</li><li><code>parentNode.replaceChild(newChild, oldChild);</code></li><li><code>newChild</code>：用来替换<code>oldChild</code>的新节点。如果该节点已经存在于 DOM 树中，则它首先会<strong>被从原始位置删除</strong>。</li><li><code>oldChild</code>： 被替换掉的原始节点。</li><li><code>parentNode</code>是<code>oldChild</code>的父节点</li></ul></blockquote><pre><code>&gt;&lt;ul&gt;&gt;  &lt;li&gt;第一个li&lt;/li&gt;&gt;  &lt;li&gt;第二个li&lt;/li&gt;&gt;  &lt;li&gt;第三个li&lt;/li&gt;&gt;  &lt;li&gt;第四个li&lt;/li&gt;&gt;&lt;/ul&gt;&gt;&gt;&lt;script&gt;  // 获取页面元素  var oul = document.getElementsByTagName(&quot;ul&quot;)[0];  //用最后一个元素替换新的元素  var firstli = oul.children[0];  var lastli = oul.children[3];  oul.replaceChild(lastli, firstli);&gt;  // 创建新的元素来替换  var oli = document.createElement(&quot;li&quot;);  oli.innerHTML = &quot;&lt;p&gt;我是新创建的&lt;/p&gt;&quot;;  oli.title = &quot;我是新创建的&quot;;  oul.replaceChild(oli, oul.children[1]);&gt;&lt;/script&gt;</code></pre><ol start="2"><li>案例：交换两个元素在节点中的位置（阿里面试题）</li></ol><ul><li>实现思路<blockquote><ul><li>假设要交换第 1 个 li和第 4 个 li</li><li>我们可以先创建一个新的节点 <code>newNode</code>，插入到第 1 个 li 前面，用来<strong>占位</strong>（记录第 1 个 li 的位置）</li><li>然后用第一个 li来<strong>替换</strong>第 4 个 li，在替换前，要先把第 4 个 li <strong>保存</strong>起来，供后面使用</li><li>最后用第 4 个 li来<strong>替换</strong>之前新创建的节点<code>newNode</code></li><li>如果传过来的节点中，有一个<strong>不存在</strong>，则返回<code>false</code> ，如果替换成功，则返回<code>true</code><blockquote><p>注意：<code>insertBefore</code> 和<code>replaceChild</code>的父级元素是被替换的元素</p></blockquote></li></ul></blockquote></li></ul><pre><code>&gt;&lt;div class=&quot;box&quot;&gt;box&lt;/div&gt;&gt;&lt;ul class=&quot;list&quot;&gt;&gt;  &lt;li&gt;第一个li&lt;/li&gt;&gt;  &lt;li&gt;第二个li&lt;/li&gt;&gt;  &lt;li&gt;第三个li&lt;/li&gt;&gt;  &lt;li&gt;第四个li&lt;/li&gt;&gt;&lt;/ul&gt;&gt;&gt;&lt;script&gt;  function changeOfPosition(obj1, obj2) &#123;    // 如果传过来的节点，有一个不存在，就不做任何操作    if (!obj1 || !obj2) return false;    // 首先创建一个新节点    var newNode = document.createElement(&quot;div&quot;);    // 把新创建的节点插入到 obj1的前面    obj1.parentNode.insertBefore(newNode, obj1);    // 用obj1替换obj2,返回obj2    obj2.parentNode.replaceChild(obj1, obj2);    // 用obj2替换newNode,为什么不用obj1的父级，而要用newNode    // 在上面用obj1替换obj2了，所以obj1的父级此时变成了obj2的父级    newNode.parentNode.replaceChild(obj2, newNode);    return true;  &#125;&gt;  var liList = document.querySelectorAll(&quot;.list li&quot;);  var box = document.querySelector(&quot;.box&quot;);  // 交换第1个和第3个元素位置  changeOfPosition(box, liList[3]);&gt;&lt;/script&gt;</code></pre><h4 id="克隆节点"><a href="#克隆节点" class="headerlink" title="克隆节点"></a>克隆节点</h4><blockquote><ul><li><code>cloneNode</code>方法返回调用该方法的节点的一个<strong>副本</strong>。</li><li>也就是克隆节点，克隆出来的节点是 <strong>“孤儿节点”</strong>,只是存在内存中，没有插入页面</li><li><code>var dupNode = node.cloneNode(deep);</code></li><li><code>node</code>将要被克隆的节点</li><li><code>dupNode</code>克隆生成的副本节点</li><li><code>deep</code>是否采用深度克隆，可选参数<ul><li>如果为 true，则该节点里的所有后代节点也都会被克隆</li><li>如果为 false，则只克隆该节点本身(壳子)<blockquote><p>在早期规范中，<code>deep</code> 的默认值是 <code>true</code>，现在的新规范里，把默认值变成了 <code>false</code><br>所以考虑兼容问题，最好在克隆时把这个参数带上。</p></blockquote></li></ul></li></ul></blockquote><pre><code>&gt;&lt;div class=&quot;box&quot;&gt;&gt;  &lt;ul&gt;    &lt;li&gt;第一个li&lt;/li&gt;    &lt;li&gt;第二个li&lt;/li&gt;    &lt;li&gt;第三个li&lt;/li&gt;    &lt;li&gt;第四个li&lt;/li&gt;&gt;  &lt;/ul&gt;&gt;&lt;/div&gt;&gt;&gt;&lt;script&gt;  // 获取页面元素  var box = document.getElementsByClassName(&quot;box&quot;);  // var box2 = box[0].cloneNode(); // 浅克隆  var box2 = box[0].cloneNode(false); // 浅克隆  console.log(box2);  var box3 = box[0].cloneNode(true); // 深克隆  console.log(box3);  document.body.appendChild(box2);  document.body.appendChild(box3);&gt;&lt;/script&gt;</code></pre><blockquote><blockquote><p>温馨提示：</p><ul><li>如果克隆的节点，设置了<code>id名</code>，则克隆后要修改 id 的名字，确保 id 的<strong>唯一性</strong></li><li>克隆一个元素节点会拷贝它<strong>所有的属性以及属性值</strong>，当然也就包括了属性上绑定的事件（比如onclick&#x3D;”alert(1)”），但<strong>不会拷贝</strong>那些使用<code>addEventListener()</code>方法或者<code>node.onclick = fn</code>这种用<code>JavaScript</code>动态绑定的事件。</li></ul></blockquote></blockquote><h4 id="DocumentFragment"><a href="#DocumentFragment" class="headerlink" title="DocumentFragment"></a>DocumentFragment</h4><blockquote><ul><li><code>DocumentFragment</code>文档片段接口，表示一个<strong>没有父对象</strong>的最小文档对象。</li><li>它被作为一个<strong>轻量版</strong>的 <code>Document</code> 使用，就像标准的 <code>document</code> 一样，存储由<strong>节点（nodes）组成</strong>的文档结构。与 <code>document</code> 相比，<strong>最大的区别</strong>是它不是真实 DOM 树的一部分，它的变化<strong>不会触发</strong> DOM 树的重新渲染，且不会对<strong>性能</strong>产生影响。</li></ul></blockquote><blockquote><ul><li>他具有真实 DOM 的一切方法和属性，所以我们可以像操作真实 DOM 一样来操作他</li><li>你可以把他理解成<strong>虚拟节点对象</strong>，他的作用是充当其它要被添加到真实文档节点的<strong>仓库</strong>。而他自己永远不会被添加到真实的文档对中</li></ul></blockquote><pre><code>&gt;&lt;ul id=&quot;list&quot;&gt;&lt;/ul&gt;&gt;&lt;script&gt;  var oUl = document.getElementById(&quot;list&quot;);  // 创建一个文档片段，此时还没有插入到真实DOM树中，其存在内存中  var fragment = document.createDocumentFragment();&gt;  // for循环创建5个li，然后插入到ul中  for (var i = 0; i &lt; 4; i++) &#123;    var oLi = document.createElement(&quot;li&quot;);    oLi.innerText = &quot;第&quot; + i + &quot;个li&quot;;    // 将创建的DOM先放在文档片段中，这样就不会造成频繁的操作真实DOM    fragment.appendChild(oLi);  &#125;  // 一次性将创建的5个oLi插入到真实的DOM树中  oUl.appendChild(fragment);&gt;&lt;/script&gt;</code></pre><blockquote><blockquote><p>DocumentFragment 文档片段的主要功能：</p><ul><li>可以将频繁的 DOM 操作理改为<strong>一次性 DOM 操作</strong>，从而减少了页面的重排和重绘（减少 DOM 渲染的次数）</li></ul></blockquote></blockquote>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JS核心知识点（八）</title>
      <link href="/2023/12/05/JS%E6%A0%B8%E5%BF%83%E7%9F%A5%E8%AF%86%E7%82%B9%EF%BC%88%E5%85%AB%EF%BC%89/"/>
      <url>/2023/12/05/JS%E6%A0%B8%E5%BF%83%E7%9F%A5%E8%AF%86%E7%82%B9%EF%BC%88%E5%85%AB%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<span id="more"></span><h3 id="一、对象的基本概念"><a href="#一、对象的基本概念" class="headerlink" title="一、对象的基本概念"></a>一、对象的基本概念</h3><ol><li><p>现实生活角度-理解对象</p><blockquote><ul><li>在现实生活中，万物皆对象，对象是一个具体的，看得见摸得着的实实在在存在的实物。</li><li>如：一个苹果，一本书，一个杯子，一个人等，这些实实在在存在颜的实物，就是一个对象。</li><li>一个对象有两个重要的组成部分：<strong>属性、功能</strong><table><thead><tr><th>属性</th><th>功能</th></tr></thead><tbody><tr><td>可以简单理解为一个对象的特征和外观等，如：形状、颜色、气味、大小、重量、味道</td><td>可以简单的理解为一个对象功能和行为等，他能用来做什么</td></tr></tbody></table></li></ul></blockquote></li><li><p>JavaScript 语言角度-理解对象</p><blockquote><ul><li>在 JavaScript 中,对象是由一组<strong>无序的</strong>相关属性和方法的集合。</li><li>JS 中的对象，本质就是用代码来模拟现实生活中的对象，他由<strong>属性和方法</strong>两个部分组成。<ul><li>对象属性与现实生活中对象的属性是对应</li><li>对象方法与现实生活中对象的功能是对应</li></ul></li></ul></blockquote></li></ol><blockquote><p>比如，我们要在 JS 中定义一个手机对象，我们可以写成如下：</p></blockquote><pre><code>// 定义了一个手机对象var phone = &#123;  brand: &quot;苹果&quot;, // 品牌名  size: &quot;5.8英寸&quot;, // 手机尺寸  color: &quot;黑色&quot;, // 颜色  weight: &quot;100g&quot;, // 重量  quality: &quot;铝合金&quot;, // 材质  ringUp: function () &#123;    console.log(&quot;打电话&quot;); // 方法：打电话  &#125;,  playMovie: function () &#123;    console.log(&quot;播放电影&quot;); // 方法： 播放电影  &#125;,  // 更多方法省略......&#125;;</code></pre><ol start="3"><li>为什么需要对象<blockquote><ul><li>前面我们学过变量和数组，如果要保存一个基本数据类型的值，我们可以用变量来保存; 如果要保存一且具有相关性的值和数据，我们可以用数组;</li><li>但如果要保存一个完整的对象（比如人）的信息？变量和数组呢都不能做到</li><li>而对象的形式保存数据，非常直观和清淅，很明确的知道每一项保存的是什么信息。</li></ul></blockquote></li></ol><pre><code>var person = &#123;  name: &quot;小明&quot;,  sex: &quot;女&quot;,  age: 45,  weight: 45,  height: 128,&#125;;</code></pre><h3 id="二、对象的创建"><a href="#二、对象的创建" class="headerlink" title="二、对象的创建"></a>二、对象的创建</h3><blockquote><p>在 JS 中创建一个对象有以下三种方式：</p><ul><li>利用<strong>字面量</strong>方式，创建一个对象</li><li>利用 <code>new Object()</code> 方式，创建对象</li><li>利用<strong>构造函数</strong>方式，创建一个对象</li></ul></blockquote><ol><li>字面量方式创建对象</li></ol><pre><code>// 对象的抽象写法var obj = &#123;    key:value,    key:value,     ....&#125;&gt;// 创建一个对象var obj = &#123;    name:&#39;小明&#39;, // 属性    age:23,  // 属性    sing:function()&#123;  // 方法        console.log(&#39;我在唱歌&#39;)    &#125;&#125;&gt;// 创建一个空对象 对象中没有任何属性和方法var obj = &#123;&#125;;</code></pre><p><strong>语法解读</strong></p><blockquote><ul><li>{}表示的就是一个对象，我们把这个对象赋值给到一个变量，我们通过变量来访问这个对象。</li><li>{}括号里面表达了对象的属性和方法，对象的属性和方法，是以<strong>键值对</strong>的形式来书写的<ul><li><code>key: value;</code>键值对形式， key表示属性名，value表示属性值，即： name: ‘小明’</li><li>name、age 就是对象的<strong>属性</strong></li><li>sing 是对象的方法，其实他<strong>也是对象属性</strong>，不过一个属性的值如果是一个<strong>函数</strong>，我们把这个属性称为对象的<strong>方法</strong></li></ul></li><li>属性的值，可以是<strong>任意的</strong>数据类型</li><li>每个属性之间用<code>,</code>逗号隔开</li><li>最后一个属性,逗号不写</li></ul></blockquote><ol start="2"><li>对象中属性名规范<blockquote><ul><li>如果对象的属性名<strong>符合</strong>JS 标识符命名规范，则属性名<strong>不需要</strong>加双引号</li><li>否则就需要用 <code>“”</code> 双引号 或<code>&#39;&#39;</code>单引号包裹起来</li><li>标识符命名规范：只能以<strong>字母，数字，_下划线，$<strong>组成，但</strong>不能以数字开头</strong></li><li>对象中的属性名，如果是一个<strong>变量</strong>，则必需用<code>[]</code>的方式来书写</li></ul></blockquote></li></ol><pre><code>var name = &quot;abc&quot;;var person = &#123;  [name]: &quot;清心&quot;, //abc=&quot;清心“  [&quot;age&quot;]: 18, // 注意这里，age是一个字符串，不是一个变量  hobby: [&quot;游泳&quot;, &quot;健身&quot;, &quot;阅读&quot;],  &quot;to-sleep&quot;: function () &#123;    // to-sleep命名不符合标识符命名规范，则用&#39;&#39;包裹    console.log(&quot;我要睡觉了&quot;);  &#125;,&#125;;</code></pre><h3 id="三、对象属性的操作"><a href="#三、对象属性的操作" class="headerlink" title="三、对象属性的操作"></a>三、对象属性的操作</h3><ol><li>访问对象中的属性<blockquote><ul><li>我们可用对象打点的方式来访问对象中的属性，即：对象.属性名</li><li>如果属性名<strong>不符合</strong> JS 标识符命名规范，则必须用<strong>方括号</strong>的写法来访问，即： 对象[“属性名”]</li><li>[]方括中的属性名，必需用’’单引号或””双引号包裹</li><li>如果属性名以变量的形式存储，则可以使用方括号的形式访问，即 ：对象[变量名]</li><li>如果访问对象中，不存在的属性，不会报错，其值为 undefined</li></ul></blockquote></li></ol><pre><code>// 创建了一个对象var user = &#123;  name: &quot;清心&quot;,  age: 18,  sex: &quot;女&quot;,  &quot;my-hobbies&quot;: [&quot;篮球&quot;, &quot;画画&quot;, &quot;阅读&quot;, &quot;编程&quot;],&#125;;&gt;// 对象打点访问对象中的属性值console.log(user.name); // 清心console.log(user.age); // 18console.log(user.sex); // 女//如果属性名不符合 JS 标识符命名规范console.log(user[&quot;my-hobbies&quot;]); // [&quot;篮球&quot;, &quot;画画&quot;, &quot;阅读&quot;, &quot;编程&quot;]//如果属性名以变量的形式存储var key = &quot;name&quot;;console.log(user[key]); // 清心//如果访问对象中，不存在的属性console.log(user.weight); // undefined</code></pre><blockquote><blockquote><p>注意</p><ul><li>对象中的属性名，如果是一个变量 和 属性名以变量的形式存储是不一样的</li></ul></blockquote></blockquote><pre><code> var name = &quot;abc&quot;; //属性名以变量的形式存储 var key = &quot;height&quot;;&gt;  var person = &#123;//对象中的属性名，如果是一个变量,则必需用[]的方式来书写   [name]: &quot;hermia&quot;,   height: 188, &#125;; console.log(person); //&#123;abc:&quot;hermia&quot;, height:188&#125;&gt; //如果属性名以变量的形式存储,则以使用方括号的形式访问 console.log(person[key]); //188</code></pre><ol start="2"><li>添加或修改对象属性值<blockquote><ul><li>我们通过 <code>对象.属性名 = 属性值</code> 或 <code>对象[属性名] = 属性值</code>的方式来添加或修改对象的属性值</li><li>如果属性名<strong>不存在</strong>，则为对象<strong>添加属性</strong></li><li>如果属性名<strong>存在</strong>，则相当于<strong>修改</strong>属性的值。</li></ul></blockquote></li></ol><pre><code>// 定义一个对象 dogvar dog = &#123;  name: &quot;小黑&quot;,  &quot;skin-color&quot;: &quot;黑色&quot;,&#125;;&gt;dog.name = &quot;小红&quot;; // 修改属性值dog[&quot;skin-color&quot;] = &quot;红色&quot;; // 修改属性值</code></pre><ol start="3"><li>删除对象属性<blockquote><ul><li>如果要删除某个属性，则使用<code>delete obj.属性</code></li></ul></blockquote></li></ol><pre><code>// 创建一个对象var dog = &#123;  name: &quot;小黑&quot;,  &quot;skin-color&quot;: &quot;黑色&quot;,  age: 18,&#125;;delete dog.name; // 删除属性delete dog[&quot;skin-color&quot;]; // 删除属性console.log(dog); // &#123;age: 18&#125;</code></pre><h3 id="四、对象方法的操作"><a href="#四、对象方法的操作" class="headerlink" title="四、对象方法的操作"></a>四、对象方法的操作</h3><blockquote><ul><li>如果对象的某个属性值是一个函数，则我们把他称为对象的方法</li><li>我们采用 <code>对象.属性名()</code> 或 <code>对象[属性名]()</code> 的方式来调用对象的方法</li></ul></blockquote><pre><code>  var user = &#123;  name: &quot;清心  age: 18,  sayHello: function () &#123;    console.log(&quot;大家好，我是清心，永远18岁 ！&quot;);  &#125;,  &quot;to-sleep&quot;: function () &#123;    console.log(&quot;我正在睡觉&quot;);  &#125;,&#125;;user.sayHello(); // 大家好，我是清心，永远18岁 ！user[&quot;to-sleep&quot;](); // 我正在睡觉console.log(user.sayHello);//f()&#123;  console.log(&quot;大家好，我是清心，永远18岁 ！&quot;);  &#125;</code></pre><blockquote><ul><li>属性名后加<code>()</code>是调用方法，不加括号是打印该方法</li><li>对象方法的修改，新增、删除和属性的操作方法是一样，不过我们一般不会对一个对象的方法去做这些操作。</li></ul></blockquote><ol start="2"><li>方法和函数的关系<blockquote><ul><li>方法也是函数，只不过方法是对象的 “属性” ，它需要用对象打点调用等方式调用</li><li>我们之前讲的 Math.random()随机函数，本质上 random 就是 Math 对象上的一个方法</li></ul></blockquote></li></ol><h3 id="五、对象的遍历"><a href="#五、对象的遍历" class="headerlink" title="五、对象的遍历"></a>五、对象的遍历</h3><blockquote><ul><li>我们使用<code>for....in ....</code>循环来遍历<strong>对象</strong></li><li>使用<code>for...in...</code>循环可以遍历对象的每个键</li><li><code>for...in...</code>只能遍历对象的<strong>非符号键属性</strong></li></ul></blockquote><ul><li>for…in…循环语句语法</li></ul><pre><code>// obj 要遍历的对象// key 循环变量，它会依次成为对象的每一个键// key 可以换成任何标识符，只是在长期的习惯中，大家习惯用key来表示对象的键，用来遍历for (var key in obj) &#123;  console.log(&quot;对象obj的属性&quot; + key + &quot;的值是：&quot; + obj[key]);&#125;</code></pre><blockquote><ul><li>key是变量，它会依次成为对象的每一个键；</li><li>对象的属性名以变量的形式存储，则可以使用方括号的形式访问</li></ul></blockquote><ul><li>for…in…只能遍历对象的非符号键属性</li></ul><pre><code>var s = Symbol(&quot;符号属性&quot;);var obj = &#123;  a: 1,  b: 2,  c: 3,  [s]: &quot;我用for-in无法遍历&quot;, // 符号属性&#125;;for (var key in obj) &#123;  console.log(key + &quot;:&quot; + obj[key]);&#125;</code></pre><ul><li>数组也是一个对象，他的<strong>属性名就是对应的索引下标</strong> 0,1,2…. 他也可以用 for…in 遍历</li></ul><pre><code>var arr = [&quot;A&quot;, &quot;B&quot;, &quot;C&quot;, &quot;D&quot;];for (var key in arr) &#123;  console.log(key); // 0 1 2 3  console.log(arr[key]); // A B C D&#125;//相当于：arr=&#123;    0:A    1:B    2:C    3:D&#125;</code></pre><h3 id="六、对象的深克隆与浅克隆"><a href="#六、对象的深克隆与浅克隆" class="headerlink" title="六、对象的深克隆与浅克隆"></a>六、对象的深克隆与浅克隆</h3><ol><li>复习<table><thead><tr><th>数据类型</th><th>举例</th><th>变量中存储内容</th><th>赋值</th><th><code>==</code>和<code>===</code>比较时</th></tr></thead><tbody><tr><td>基本数据类型</td><td>数字型、字符串型、布尔型、null 空类型、undefined类型</td><td>变量中存的是值</td><td>把值复制一份，来赋值</td><td><code>==</code> 比较值是否相等;<code>===</code> 比较值和类型</td></tr><tr><td>引用数据类型</td><td>对象、数组、函数</td><td>变量中存的是地址</td><td>把地址复制一份，来赋值</td><td>&#x3D;&#x3D; 和 &#x3D;&#x3D;&#x3D; 比较的都是<strong>地址</strong></td></tr></tbody></table></li></ol><blockquote><p>如果要判断一个值是否为<code>null</code>或<code>undefined</code></p><ul><li>由于<code>null==undefined</code>，所以：</li></ul></blockquote><pre><code>if(num==null || num==undefined) return;if(num==null) return;第一句可以写成第二句，意思相同</code></pre><blockquote><blockquote><p>但是不能写成全等</p></blockquote></blockquote><ul><li>基本数据类型，赋值 和 &#x3D;&#x3D; 、&#x3D;&#x3D;&#x3D; 比较<blockquote><ul><li>基本数据类型在使用<code>==</code>来比较时，会自动进行隐式转换</li></ul></blockquote></li></ul><pre><code>// 基本数据类型var a = 10;var b = a;a = 20;console.log(a, b); // 20 ,10&gt;// == 和 ===比较console.log(&quot;5&quot; == 5);console.log(&quot;5&quot; === 5);</code></pre><ul><li>引用数据类型，赋值 和 &#x3D;&#x3D; 、&#x3D;&#x3D;&#x3D; 比较<blockquote><ul><li>引用数据类型是进行地址的比较</li></ul></blockquote></li></ul><pre><code>var arr1 = [1, 2, 3];var arr2 = arr1;//arr1和arr2指向的是同一个地址arr1[0] = &quot;A&quot;;console.log(arr1); // [&#39;A&#39;, 2, 3]console.log(arr2); // [&#39;A&#39;, 2, 3]&gt;// == 和 === 比较console.log(arr1 == arr2); // trueconsole.log(arr1 === arr2); // trueconsole.log([1, 2] == [1, 2]); // falseconsole.log([1, 2] === [1, 2]); // false</code></pre><ol start="2"><li>对象是引用类型<blockquote><p>对象是引用类型值，这意味着：</p><ul><li>不能使用<code>var obj2 = obj1</code>这样的语法克隆一个对象</li><li>使用<code>==</code> 或 <code>===</code> 进行对象的比较时，比较的也是两个对象是否指向堆内存中的<strong>同一个地址</strong></li></ul></blockquote></li></ol><ul><li>对象 &#x3D;&#x3D; 或 &#x3D;&#x3D;&#x3D;比较时</li></ul><pre><code>// 案例一var obj1 = &#123;  a: 1,  b: 2,  c: 3,&#125;;var obj2 = &#123;  a: 1,  b: 2,  c: 3,&#125;;&gt;console.log(obj1 == obj2); // falseconsole.log(obj1 === obj2); // false&gt;console.log(&#123;&#125; == &#123;&#125;); // falseconsole.log(&#123;&#125; === &#123;&#125;); // false</code></pre><ul><li>对象赋值<blockquote><ul><li>对象赋值，本质也是把对象存在栈内存中的地址赋值给另一个变量</li></ul></blockquote></li></ul><pre><code>var obj1 = &#123;  a: 1,  b: 2,&#125;;var obj2 = obj1;obj2.a = &quot;A&quot;;console.log(obj1); // &#123;a: &#39;A&#39;, b: 2&#125;console.log(obj2); // &#123;a: &#39;A&#39;, b: 2&#125;</code></pre><ol start="3"><li>对象的浅克隆<blockquote><ul><li>对象的浅克隆，本质也就是只能克隆对象的<strong>第一层</strong></li><li>我们创建一个新的空对象 <code>obj1</code>，然后<strong>遍历</strong>现在的对象 obj，把对象的属性全部遍历出来，添加 <code>obj</code> 中</li><li>基本数据类型，复制的是值，不会受原数组影响</li><li>数组和对象，复制的是地址，与原数组会相互影响</li></ul></blockquote></li></ol><pre><code>// 用来克隆的对象var obj = &#123;  a: 1,  b: 2,  c: [&quot;你&quot;, &quot;我&quot;, &quot;他&quot;],&#125;;&gt;// 被克隆后的对象var obj1 = &#123;&#125;;// 浅克隆对象for (var key in obj) &#123;  obj1[key] = obj[key]; // 赋值&#125;&gt;obj1.a = &quot;A&quot;;console.log(obj);//&#123;a: 1, b: 2 , c: [&quot;你&quot;, &quot;我&quot;, &quot;他&quot;]&#125;console.log(obj1);//&#123;a: &quot;A&quot;, b: 2 , c: [&quot;你&quot;, &quot;我&quot;, &quot;他&quot;]&#125;&gt;console.log(obj1.c == obj.c); // trueobj1[&quot;c&quot;].push(&quot;哈哈&quot;);//改变了它的数据类型&gt;console.log(obj);//&#123;a: 1, b: 2 , c: [&quot;你&quot;, &quot;我&quot;, &quot;他&quot;]&#125;console.log(obj1);//&#123;a: &quot;A&quot;, b: 2 , c: [&quot;你&quot;, &quot;我&quot;, &quot;他&quot;,&quot;哈哈&quot;]&#125;</code></pre><ol start="4"><li>对象的深克隆<blockquote><ul><li>深克隆：就是克隆对象的所有，不论对象的属性值是否是引用类型，都能将它们实现克隆</li><li>深克隆后原对象与克隆后的对象，克隆出来后长的一样，但本质两者都互相独立，互不干扰。<blockquote><p>以下对象克隆，只考对象{} 、数组[]、函数、基本数据类型，其它 es6 相关的类型暂时不考虑</p></blockquote></li></ul></blockquote></li></ol><p><strong>递归实现深克隆</strong></p><blockquote><ul><li>判断传过来的数据类是数组，还是对象，还是其它数据类型</li></ul></blockquote><pre><code> function depClone(obj) &#123;  var result;  //判断第一层  if (Array.isArray(obj)) &#123;    //传过来的是数组    result = [];    for (var i = 0; i &lt; obj.length; i++) &#123;      result.push(depClone(obj[i]));    &#125;  &#125; else if (Object.prototype.toString.call(obj) == &quot;[object Object]&quot;) &#123;    //传过来的是对象    result = &#123;&#125;;    for (var key in obj) &#123;      result[key] = depClone(obj[key]);    &#125;  &#125; else &#123;    //传过来的是基本数据类型    return obj;  &#125;  return result;&#125;</code></pre><h3 id="七、this-关键字"><a href="#七、this-关键字" class="headerlink" title="七、this 关键字"></a>七、this 关键字</h3><blockquote><blockquote><p>最好不要在全局作用域下声明一个叫<code>name</code>的变量，因为它在window里已经存在，是预留变量</p></blockquote></blockquote><ol><li>this 是什么 <blockquote><p>在函数中，其内部<code>this</code>指向把函数当成方法调用的<strong>上下文对象</strong></p></blockquote></li></ol><ul><li>什么是上下文 ？<blockquote><ul><li>垃圾分类，这是非常好的习惯，值得表扬。</li><li>随手关灯，这是非常好的习惯，值得表扬。</li></ul></blockquote></li></ul><blockquote><ul><li>这里的 “这” 字，就是这个语句的上下文。</li><li>就是说 “这” 这个代词的意思是需要通过这条中文语句的前言后语来判断</li><li><code>this</code>指向把<strong>函数当成方法</strong>调用的上下文对象，即<strong>谁来调用这个函数或方法，当前函数或方法体内的<code>this</code>就指向谁</strong>。</li><li>所以 this 的指向在定义时是不确定的，只有在调用的时候才能被确定</li><li>接下来，我们来看下面几个不同场景下，函数内部的 this 指向<ul><li>函数作为普通函数直接调用</li><li>函数作为对象的方法被调用</li><li>函数.call() 与 函数.apply()方式调用</li><li>函数作为构造器被调用</li></ul></li></ul></blockquote><ol start="2"><li>函数作为普通函数直接调用<blockquote><ul><li><code>函数名()</code> 的方式调用函数，其本质是<code>window.函数名()</code> 的方式在调用函数</li><li>所以这种方式调用函数，函数内部的 <code>this</code> 指向<code>window</code> 。 谁调用函数，this 就是谁<blockquote><p>所有<strong>全局作用域下</strong>声明的变量和函数，都是 window 对象的属性</p></blockquote></li></ul></blockquote></li></ol><pre><code>var a = 10;var b = 20;function sum() &#123;  return this.a + this.b;&#125;console.log(sum());</code></pre><ul><li>IIFE 立即执行函数<blockquote><ul><li>立即执行函数，本质也是 window 对象调用的，所以其内部 this 指向 window</li></ul></blockquote></li></ul><pre><code>(function()&#123;&#125;)()//表示立即执行该函数，执行完即刻销毁</code></pre><ol start="3"><li>函数作为对象的方法被调用<blockquote><ul><li>函数作为对象的方法被调用，this 指向这个对象，谁调用函数，this 就是谁</li></ul></blockquote></li></ol><pre><code>// 定义一个对象var dog = &#123;  name: &quot;小黑&quot;,  &quot;skin-color&quot;: &quot;黑色&quot;,  say: function () &#123;    console.log(&quot;我叫&quot; + this.name + &quot;，因为我的毛是&quot; + this[&quot;skin-color&quot;]);    console.log(this);  &#125;,&#125;;dog.say(); //  this 是 dog对象var say2 = dog.say;say2(); // this 是 window对象</code></pre><blockquote><ul><li>当代码执行到 <code>var say2 = dog.say</code> 时，本质是把函数当做<strong>值赋</strong>给了变量 <code>say2</code>，即</li></ul></blockquote><pre><code>var say2 = function () &#123;  console.log(&quot;我叫&quot; + this.name + &quot;，因为我的毛是&quot; + this[&quot;skin-color&quot;]);  console.log(this);&#125;;</code></pre><blockquote><ul><li>所以往后执行 say2() 时，本质是 window 对象调用了这个函数。</li></ul></blockquote><ol start="4"><li>数组<a href="">下标</a><blockquote><ul><li>数组（类数组对象）枚举出函数进行调用，this 指向的是这个<strong>数组（类数组对象）</strong></li><li>谁调用函数，this 就是谁</li></ul></blockquote></li></ol><pre><code>var arr = [  &quot;A&quot;,  2,  3,  function () &#123;    console.log(this[0]);  &#125;,];arr[3](); // A 这里 函数是数组身上的一个属性console.log(arr); //打印出数组arrvar fn = arr[3];fn(); // undefined  这里的this是window</code></pre><ol start="5"><li>测试题</li></ol><ul><li>题1：</li></ul><pre><code>var obj1 = &#123;  a: 1,  b: 2,  sum: function () &#123;    return this.a + this.b;  &#125;,&#125;;var obj2 = &#123;  a: 3,  b: 4,  sum: obj1.sum, // 这里只是完成简单的赋值操作&#125;;console.log(obj2.sum()); // 7&gt;// 相当于：var obj2 = &#123;  a: 3,  b: 4,  sum: function () &#123;    return this.a + this.b;  &#125;,&#125;console.log(obj2.sum());//obj2调用了函数，this是obj2</code></pre><ul><li>题2：</li></ul><pre><code>function add() &#123;  var a = 1,    b = 2;  return &#123;    // 将对作为返回值，返回    a: 10,    b: 20,    sum: function () &#123;      return this.a + this.b;    &#125;,  &#125;;&#125;console.log(add().sum()); // 30&gt;//先执行add(),得到返回值：&#123; a: 10, b: 20, sum: function () &#123;   return this.a + this.b; &#125;&#125;&gt;//返回的函数调用sum(),this指的就是该函数</code></pre><ul><li>题3：</li></ul><pre><code>var a = 1;var b = 2;function add() &#123;  return this.a + this.b;&#125;var obj = &#123;  a: 10,  b: add(), // 该函数执行后才赋值给b，this是window  得出结果是 3  sum: add,&#125;;var result = obj.sum();console.log(result); //13&gt;//也就是：var obj = &#123;  a: 10,  b: 3,  sum: function add() &#123;  return this.a + this.b;//obj调用的sum函数&#125;,&#125;;console.log(obj.sum());</code></pre><ul><li>题四：</li></ul><pre><code>var a = 1;var obj = &#123;  a: 2,  add: (function () &#123;    var a = this.a; // 立即执行函数的this是window，则this.a得到1    return function () &#123;      console.log(a + this.a);    &#125;;  &#125;)(),&#125;;obj.add(); // 3&gt;//obj.add()首先得到返回函数return function () &#123;      console.log(a + this.a);//第一个a根据作用域可知，等于上面的1；//是obj调用的add函数,所以this指obj,a=2    &#125;;</code></pre><ol start="6"><li>call 与 apply 更改 this 指向<blockquote><ul><li>函数调用<code>call()</code>和 <code>apply()</code>方法，可以<strong>更改</strong> <code>this</code> 的指向，同时<strong>立即执行</strong></li><li><code>call()</code> 和 <code>apply()</code>方法中的<strong>第一个参数</strong>是一个<strong>对象</strong>，这个对象指向函数内部的 this</li><li>apply中的参数必须用方括号包裹</li></ul></blockquote></li></ol><pre><code>// obj 是一个对象，此时，函数内部的this指向了obj// 这种方式，类似于把函数当成了obj的方法来使用函数.call(obj, arg1, arg2, arg3);函数.apply(obj, [arg1, arg2, arg3]);</code></pre><blockquote><ul><li>我们来看一个案例，定义一个方法，用来统计数组中所有数字之和</li></ul></blockquote><pre><code>var arr1 = [1, 2, 3, 4, 5];var arr2 = [5, 6, 7, 4, 3];&gt;// 函数 sum用来统计数组中所有元素之后function sum() &#123;  var result = 0;  for (var i = 0; i &lt; this.length; i++) &#123;    result += this[i];  &#125;  return result;&#125;&gt;console.log(sum.call(arr1));console.log(sum.call(arr2));console.log(sum.apply(arr1));console.log(sum.apply(arr2));</code></pre><ul><li>重点<blockquote><ul><li>某个函数或方法调用 call 时，等同于把方法或函数作为 call 的<strong>第一个参数的方法</strong>在调用。即：</li><li>函数.call(obj) 和 函数.apply(obj) 的方式，类似于把函数转换成了对象obj身上的方法来使用</li><li><code>fn.call(obj,arg1,arg2)   等同于 obj.fn(arg1,arg2)</code></li><li>但obj身上不会真的添加fn方法，只是类似于把fn当成obj的方法一样使用</li></ul></blockquote></li></ul><pre><code>var obj = &#123;  a: 1,  b: 2,&#125;;function fn() &#123;  console.log(this.a + this.b); &#125;fn.call(obj);//fn.call(obj)相当于：var obj = &#123;  a: 1,  b: 2,  fn:function fn() &#123;  console.log(this.a + this.b); &#125;，&#125;;</code></pre><ul><li>call 和 apply 的注意事项<blockquote><ul><li>如果 call 和 apply 的第一个参数<code>obj</code></li><li>当obj 是一个 <code>null</code> 或 <code>undefined</code> 时，其函数会自动将 this 替换为指向<strong>全局对象</strong></li><li>如果 obj 是一个<strong>原始值</strong>(基本数据类型)会被包装成一个对象</li></ul></blockquote></li></ul><pre><code>function fn() &#123;  console.log(this);&#125;fn.call(null); //window &#123;&#125;fn.apply(undefined);//window &#123;&#125;fn.call(1);// Number &#123;1&#125;fn.call(&quot;abc&quot;);// String &#123;&quot;abc&quot;&#125;fn.call(true);// Boolean &#123;true&#125;</code></pre><ol start="7"><li>bind 函数<blockquote><ul><li>bind方法创建一个新的函数（简单理解为<strong>原函数的拷贝</strong>）</li><li>bind在使用时是返回一个新函数，需要接收后再调用</li><li>在bind被调时，这个<strong>新函数</strong>的this被指定为bind()的<strong>第一个参数</strong>。</li><li>其余参数将作为<strong>新函数的参数</strong>，供调用时使用。</li><li><code>var fn2 = fn.bind(thisArg, arg1, arg2, arg3);</code></li></ul></blockquote></li></ol><ul><li>bind 用法一： 改变 this 指向</li></ul><pre><code>var obj = &#123;  a: 1,  b: 2,  c: 3,&#125;;function sum(a, b, c) &#123;  console.log(this.a, this.b, c);&#125;// 这里的fn接收sum的拷贝函数，此时fn函数内部的this变成了objvar fn = sum.bind(obj, &quot;A&quot;, &quot;B&quot;, &quot;C&quot;);//调用新函数fn();</code></pre><blockquote><ul><li>不改变this时,thisArg可以填null或undefined</li></ul></blockquote><ul><li>bind 用法二：创建一个拥有预设参数列表<blockquote><blockquote><p>也就是我们在第一次调用 bind 方法时，除了第一个参数外，后面还可以传递 <code>&gt;= 0</code> 个参数</p></blockquote></blockquote></li></ul><pre><code>var obj = &#123;  a: 1,  b: 2,  c: 3,&#125;;var c = 5;function sum(a, b, c) &#123;  console.log(a, this.b, c);&#125;// 创建一个函数，它拥有预设的第一个参数var fn = sum.bind(obj, &quot;A&quot;);fn(&quot;B&quot;, &quot;C&quot;);//补充参数，相当于(obj, &quot;A&quot;,&quot;B&quot;,&quot;C&quot;)</code></pre><ul><li>bind 返回的新函数，作为构造函数使用<blockquote><ul><li>如果 bind 返回的新函数作为<strong>构造函数</strong>，则会<strong>忽略</strong> thisArg 这个参数</li><li>也就是<strong>不更改</strong>原函数中 this，其作为构造函数使用，内部的 this 是 new 出来的实例对象</li></ul></blockquote></li></ul><pre><code>// 构造函数function Point(x, y) &#123;  this.x = x;  this.y = y;&#125;Point.prototype.getPosition = function () &#123;  console.log(&quot;指向位置&quot; + this.x, this.y);&#125;;&gt;var Fn = Point.bind([], 1);&gt;// bind返回的新函数和调用的函数是两个函数，只是长得一样console.log(Fn);console.log(Fn === Point); // falseconsole.log(Fn.prototype === Point.prototype); // false&gt;// point1是Point的实例, 并不是Fn的实例,也不是[]的实例var point1 = new Fn(2);console.log(point1); // Point &#123;x: 1, y: 2&#125;console.log(point1 instanceof Point); // trueconsole.log(point1.__proto__ === Point.prototype); // true&gt;// point1是Point实例，所以point1能访问Point.prototype上的属性point1.getPosition();</code></pre><blockquote><blockquote><p>特别注意</p></blockquote><ul><li>我们返回的新函数，每一个函数，都有自己的 prototype</li><li>如何让新函数的 prototype 指向原函数的 prototype，两者相互独立呢？</li></ul></blockquote><ul><li>bind 注意事项<blockquote><p>如果 bind 的第一个参数 <code>thisArg</code> </p><ul><li>是一个 <code>null</code> 或 <code>undefined</code> 时，其函数会自动将this替换为指向<strong>全局对象</strong></li><li>是一个<strong>原始值</strong>会被包装成一个对象</li></ul></blockquote></li></ul><pre><code>var obj = &#123;  a: 1,  b: 2,  c: 3,&#125;;function sum(a, b, c) &#123;  console.log(this);&#125;var fn1 = sum.bind();var fn2 = sum.bind(null);var fn3 = sum.bind(1);fn1(3, 4);//windowfn2(3, 4);//windowfn3(3, 4);//Number&#123;1&#125;</code></pre><ul><li>bind总结<blockquote><ul><li><code>var fn2 = fn.bind(thisArg, arg1, arg2);</code></li><li>fn 调用 bind 方法，相当于 fn 被当成了 thisArg 对象身上的方法，即 thisArg.fn();</li><li>但是，函数调用 bind 方法，并不会立即执行 fn 函数，而是返回一个新的函数 fn2</li><li>当调用 fn2 时，相当于内部执行了 <code>thisArg.fn()</code>;</li></ul></blockquote></li></ul><ol start="8"><li>call、apply、bind 的区别和使用场景<blockquote><ul><li>call,apply和bind方法就是Function原型中的方法，所以所有的函数都可以使用这三个方法</li></ul></blockquote></li></ol><table><thead><tr><th></th><th>作用相同</th><th>传参方式不同</th><th>返回值不同</th></tr></thead><tbody><tr><td>call</td><td>用来改变 this 指向</td><td>第一参数是 thisArg，后续参数是一个参数列表</td><td>立即执行函数，返回值为原函数返回值</td></tr><tr><td>apply</td><td>用来改变 this 指向</td><td>第一参数是 thisArg,后续参数是包含一个或多个参数的数组</td><td>立即执行函数，返回值为原函数返回值</td></tr><tr><td>bind</td><td>用来改变 this 指向</td><td>第一参数是 thisArg，后续参数是一个参数列表</td><td>返回一个新函数，相当于原函数拷贝</td></tr></tbody></table><blockquote><blockquote><p>改变 this 指向，本质就是把某个函数当成对象的方法来使用。</p></blockquote></blockquote><ol start="9"><li>this 指向总结<table><thead><tr><th>函数的调用方式</th><th>this 指向</th></tr></thead><tbody><tr><td>对象.函数()</td><td>对象</td></tr><tr><td>函数名()</td><td>window</td></tr><tr><td>IIFE 立即执行函数</td><td>window</td></tr><tr><td>数组<a href="">下标</a></td><td>数组</td></tr><tr><td>call(对象,arg1,arg2)</td><td>对象</td></tr><tr><td>apply(对象,arry)</td><td>对象</td></tr><tr><td>bind(对象,arg1,arg2)</td><td>对象</td></tr><tr><td>定时器中的回调函数</td><td>window</td></tr><tr><td>DOM 事件处理函数</td><td>添加事件监听的元素</td></tr><tr><td>new 函数()</td><td>对象的实例</td></tr></tbody></table></li></ol><blockquote><blockquote><p><code>数组[下标]()</code>这种方式，数组就是一个对象，下标就是他的属性，所以<code>数组[下标]()</code>就是调用数组身上的方法</p></blockquote></blockquote><h3 id="八、构造函数与类"><a href="#八、构造函数与类" class="headerlink" title="八、构造函数与类"></a>八、构造函数与类</h3><blockquote><p>在学习构造函数之前，我们来思考一个问题，我们如何批量创建一批相似的对象（结构相似）？</p><ul><li>比如说，我们现在要批量创建下面这样一批对象，这些对象有相同的属性和方法，我们会如何创建<table><thead><tr><th>相似对象（人）</th><th>属性</th><th>方法</th></tr></thead><tbody><tr><td>小明</td><td>姓名：小明，年龄：22 岁，性别：男</td><td>自我介绍：大家好，我是小明，性别男，今年 22</td></tr><tr><td>小红</td><td>姓名：小红，年龄：32 岁，性别：女</td><td>自我介绍：大家好，我是小红，性别女，今年 32</td></tr><tr><td>小丽</td><td>姓名：小丽，年龄：43 岁，性别：女</td><td>自我介绍：大家好，我是小丽，性别女，今年 43</td></tr></tbody></table></li></ul></blockquote><blockquote><ul><li>根据之前学过的知识，可以一个一个来单独创建</li></ul></blockquote><pre><code>// 创建对象小明var obj1 = &#123;  name: &quot;小明&quot;,  age: 22,  sex: &quot;男&quot;,  sayHello: function () &#123;    console.log(&quot;大家好，我叫&quot; + this.name + &quot;,&quot; + this.sex + &quot;今年&quot; + obj.age);  &#125;,&#125;;</code></pre><blockquote><blockquote><p>显然是不合理的，如果我们要创建 100 个这样的相似对象，难道我们要写 100 次吗 ？</p></blockquote></blockquote><ol><li>工厂方法 - 批量创建对象<blockquote><ul><li>利用<strong>函数的封装特性</strong>来创建对象，只要调用下函数，就能产生一个类似的对象，我们把这种方式称为<strong>工厂模式</strong>。</li><li>因为他有点类似于工厂批量生产物品，把材料放到机器中，修改下参数，就能出来一个类似的物品。</li></ul></blockquote></li></ol><pre><code>function Person(name, age, sex) &#123;  var obj = &#123;&#125;;  obj.name = name;  obj.age = age;  obj.sex = sex;  obj.sayHello = function () &#123;    console.log(      &quot;大家好，我叫&quot; + this.name + &quot;,&quot; + this.sex + &quot;,&quot; + &quot;今年&quot; + obj.age    );  &#125;;  return obj;&#125;// 创建对象小明var obj1 = Person(&quot;小明&quot;, 22, &quot;男&quot;);console.log(obj1); //&#123;name: &#39;小明&#39;, age: 22,sex:&#39;男&#39;，sayHello:f&#125;obj1.sayHello(); //大家好，我叫小明，男，今年22&gt;// 用来创建狗对象的 函数function Dog(name, age) &#123;  var obj = &#123;&#125;;  obj.name = name;  obj.age = age;  return obj;&#125;var dog = Dog(&quot;小黑&quot;, 7);console.log(dog); //&#123;name: &#39;小黑&#39;, age: 7&#125;&gt;//检测类型console.log(typeof obj1); // objectconsole.log(typeof dog); // object</code></pre><blockquote><blockquote><p>工厂方式创建对象，看似完美，其实他还有一个很大的问题 !</p><ul><li>我们用 <code>typeof</code> 来检测两个对象的类型时，得到的都是 <code>Object</code>，也就是我们用这种方法创建出来的对象，我们是没有办法区分他们的具体类型。</li><li>如果我们希望在类型检测时得到的是 Person 和 Dog 类型，那要如何办呢？这就需要用到我们接下来讲到的构建函数的方式创建对象</li></ul></blockquote></blockquote><ol start="2"><li><p>构造函数 - 创建对象</p><blockquote><ul><li>用<code>new</code>调用一个函数，这个函数就被称为构造函数，任何函数都可以是构造函数，只需要用new调用它。</li><li>构造函数：主要用来<strong>在创建对象时初始化对象</strong>， 即为对象成员变量赋初始值</li><li>构造函数的<strong>首字母需要大写</strong>，这是开发者约定的规范，并非说首字不大写就是错</li><li>声明一个变量接收不同参数的new函数<br><code>var p1 = new Person(&quot;小明&quot;, 22, &quot;男&quot;);</code></li></ul></blockquote></li><li><p>new 调用函数四步曲</p><blockquote><ul><li>第一步：会在函数体内<strong>自动</strong>创建一个新的空对象{} 即：<code>var obj = &#123;&#125;</code></li><li>第二步：函数体内的 this 被赋值为这个新对象, 即 <code>this = obj</code></li><li>第三步：从上往下，执行函数体内的代码，相当于给新创建的空对象 obj <strong>添加属性</strong></li><li>第四步：函数体内代码执行完，会<strong>自动返回</strong>创建的新对象 obj（所以构造函数体内不需要 return）<blockquote><p>提示：在第一步和第二步中间，其实还省略了一步：将新对象 obj 的__proto__指向构造函数的prototype属性</p></blockquote></li></ul></blockquote></li></ol><pre><code> // 用来创建人对象的 函数 function Person(name, age, sex) &#123;   // 第一步：创建一个新对象 var obj=&#123; &#125;   // 第二步：把函数体内的this指向新对象 this=obj;   this.name = name;   this.age = age;   this.sex = sex;   // 第三步：从上往下执行代码，相当于给obj对象添加属性   // obj.name=name,obj.age=age,obj.sex=sex   // 第四步：代码执行完，自动返回obj这个对象，相当于return obj; &#125;&gt; // new调用函数 var p1 = new Person(&quot;小明&quot;, 22, &quot;男&quot;); console.log(p1); //Person&#123;name:&#39;小明&#39;，age:22,sex:&#39;男&#39;&#125; var p2 = new Person(&quot;小红&quot;, 32, &quot;女&quot;); console.log(p2); //Person&#123;name:&#39;小红&#39;，age:32,sex:&#39;女&#39;&#125;</code></pre><blockquote><blockquote><p>其实最后<code>p1 = this = obj</code>，也就是 p1 和 this 都指向 new 调用函数 内部新创建的对象 obj。</p></blockquote></blockquote><ol start="4"><li><p>构造函数中的 this 指向</p><blockquote><ul><li>构造函数中的 this，指向的是 new 调用函数 创建出来的新对象</li></ul></blockquote></li><li><p>构造函数注意事项</p><blockquote><ul><li>一定要记住：<strong>一个函数是不是构造函数，要看它是否用 new 调用</strong>，而至于名称首字母大写，完全是开发者的习惯约定</li><li>如果一个函数名首字母大写，但调用是没有用 new，而是<strong>直接调用</strong>，其不是构造函数，内部 this 指向 window</li></ul></blockquote></li></ol><pre><code>function People(name, age, sex) &#123;  this.name = name;  this.age = age;  this.sex = sex;  console.log(this);&#125;//直接调用，this指向windowPeople(&quot;arry老师&quot;, 18, &quot;男&quot;);//new调用,this指向新创建的对象var p1=new People(&quot;arry老师&quot;, 18, &quot;男&quot;);</code></pre><ol start="6"><li>构造函数的问题<blockquote><ul><li>构造函数虽然很有用，但也有他的问题存在。他的主要问题在于，其定义的方法会在<strong>每个实例</strong>上都创建一遍。</li><li>如果我们用这个构造函数创建出来 10 个实例，那这 10 个实例上都有相同的方法，这些相同的方法在创建实都会单独占用一定的内存空间，所以<strong>增大了内存的开销</strong>。</li><li>但是这些方法本质上是做的相同的事情，所以没必要定义那么多同名函数。</li></ul></blockquote></li></ol><ul><li>当然，我们可以把这些方法写在外面，然后在构造函数中引用他们，如下：</li></ul><pre><code>function Person(name, age, sex) &#123;  this.name = name;  this.age = age;  this.sex = sex;  this.sayHello = sayHello;&#125;&gt;function sayHello() &#123;  console.log(&quot;大家好，我叫&quot; + this.name + &quot;,&quot; + this.sex + &quot;今年&quot; + this.age);&#125;&gt;var p = new Person(&quot;小明&quot;, 32, &quot;男&quot;);p.sayHello();</code></pre><blockquote><blockquote><ul><li>但这种做法，会<strong>造成全局作用域的污染</strong>。因为这些(函数)方法只是供这些对象来调用的。</li><li>在 JS 中为每个函数提供了<strong>原型</strong>这个属性，后面我们可以通过原型的方实来解决。后面接下来就会学到。</li></ul></blockquote></blockquote><h3 id="九、类和实例（对象）"><a href="#九、类和实例（对象）" class="headerlink" title="九、类和实例（对象）"></a>九、类和实例（对象）</h3><ol><li>现实生活角度理解类和实例<blockquote><p><strong>什么是类</strong></p><ul><li>我们常说分门别类，其实就是根据事物的特点、性质将其分成各种<strong>门类</strong>。</li><li>这里的类<strong>并不指具体的东西</strong>，而是一类具有相同特点事物抽象的一个分类。</li><li>类好比一类物体的抽象出来的一个画像或模型。<br><strong>什么是实例</strong></li><li>实例可以理解为我们之前说的对象，他是一个实实在在，能摸得着，看得见的<strong>实物</strong>。</li><li>类可以理解为<strong>模型</strong>，那实例就是<strong>由模型制作出来的</strong>具体的一件东西。</li></ul></blockquote></li></ol><ul><li>区分类与实例<table><thead><tr><th>类</th><th>实例</th></tr></thead><tbody><tr><td>苹果、书包、人、动物、小猫、狗</td><td>这个苹果、小明的书包、清心、这条黑狗</td></tr></tbody></table></li></ul><ol start="2"><li><p>JS 角度来理解类和实例</p><blockquote><p><strong>什么是类</strong></p><ul><li>在 JS 中，类是用来<strong>描述</strong>对象会拥有那些属性和方法，但是并不具体指明属性的值。</li><li>JS 中的<strong>构造函数</strong>就好比是一个类，他只描述了这个类有那些属性和方法，但并不具体指明属性的值。<br><strong>什么是实例</strong></li><li>在 JS 中，实例就可以理解为 JS 中的对象，他有自己的属性和方法，同时有自己的<strong>属性值</strong></li><li>我们用 new 调用函数，本质就是创建了一个对象（实例化一个对象），我们称为对象实例化</li><li><strong>对象实例化</strong>： 是指将一个类实例化成对象,即用类创建对象的过程<blockquote><p>构造函数描述出属性和方法，new调用函数、赋值来创建不同实例</p></blockquote></li></ul></blockquote></li><li><p>创建一个球类和球对象</p><blockquote><ul><li>要求将创建好的球对象，添加到 body 中，在页面呈现出来。<table><thead><tr><th>类</th><th>属性</th><th>方法</th></tr></thead><tbody><tr><td>球</td><td>半径、颜色、透明度、坐标、DOM 元素</td><td>初始化，变色，运动</td></tr></tbody></table></li></ul></blockquote></li></ol><pre><code> // 构建函数,描述出对象和方法 // 对象：半径、颜色、透明度、坐标、DOM属性 // 方法：init()初始化将DOM插入到网页中、运动、改变颜色 function Ball(r, color, opacity, x, y) &#123;   this.r = r;   this.color = color;   this.opacity = opacity;   this.x = x;   this.y = y;   // 初始化小球，把球插入到页面中   this.init = function () &#123;     // 创建一个真实的DOM球放在页面中展示  this.dom = document.createElement(&quot;div&quot;);  this.dom.style.width = this.r + &quot;px&quot;;  this.dom.style.height = this.r + &quot;px&quot;;  this.dom.style.borderRadius = this.r + &quot;px&quot;;  this.dom.style.backgroundColor = this.color;  this.dom.style.opacity = this.opacity;  //一个球要动起来，必须是个定位元素  this.dom.style.position = &quot;absolute&quot;;  this.dom.style.left = this.x + &quot;px&quot;;  this.dom.style.top = this.y + &quot;px&quot;;  // 将小球添加到body上  document.body.appendChild(this.dom); &#125;;  // 当我调用这个方法，就让小球动起来  this.move = function () &#123;    this.dom.style.left = this.x + 250 + &quot;px&quot;;    this.dom.style.top = this.y + 250 + &quot;px&quot;;  &#125;;  // 当我调用这个方法，就让小球变色  this.changeColor = function () &#123;    this.dom.style.backgroundColor = &quot;skyblue&quot;;  &#125;;&#125;//new一个对象实例var ball = new Ball(100, &quot;pink&quot;, 0.5, 100, 100);ball.init(); // 初始化ball.changeColor(); // 变色ball.move(); // 移动</code></pre><blockquote><blockquote><ul><li>Javascript是<strong>基于对象</strong>（object-based）的语言，他<strong>并不是完全面向对象</strong>（object-oriented）语言。</li><li>java 、c++等是 “面向对象（object-oriented）” 语言</li></ul></blockquote></blockquote><h3 id="十、Object-构造函数"><a href="#十、Object-构造函数" class="headerlink" title="十、Object() 构造函数"></a>十、Object() 构造函数</h3><blockquote><p>Object 构造函数将给定的值包装为一个<strong>新对象</strong>。</p><ul><li>如果给定的值是<code>null</code>或<code>undefined</code>, 它会<strong>创建并返回</strong>一个<strong>空对象</strong>。</li><li>否则，它将返回一个和给定的值<strong>相对应</strong>的类型的对象。</li><li>如果给定值是一个<strong>已经存在</strong>的对象，则会返回这个已经存在的值（相同地址）。</li><li>语法：</li></ul></blockquote><pre><code>new Object();new Object(value);</code></pre><ul><li>创建一个新对象</li></ul><pre><code>var obj = new Object();console.log(obj); // &#123;&#125;obj.a = 1;obj.b = 2;console.log(obj); // &#123;a: 1, b: 2&#125;&gt;// 如果给定的值是`null`或 `undefined`, 它会创建并返回一个空对象var obj1 = new Object(null);var obj2 = new Object(undefined);console.log(obj1); // &#123;&#125;console.log(obj2); // &#123;&#125;&gt;// 给定值是基本数据类型  数字、字符串、boolean值var strObject = new Object(&quot;字符串包装成一个对象&quot;);console.log(strObject); //  String &#123;&#39;字符串包装成一个对象&#39;&#125;&gt;var numberObject = new Object(11);console.log(strObject); // Number &#123;11&#125;&gt;var booleanObject = new Object(true);console.log(strObject); // Boolean &#123;true&#125;&gt;// 给定值本身就是一个对象，返回这个对象var arr = [1, 2, 3];arrObject = new Object(arr);console.log(arr); // [1, 2, 3]</code></pre><h3 id="十一、原型（prototype）和原型链"><a href="#十一、原型（prototype）和原型链" class="headerlink" title="十一、原型（prototype）和原型链"></a>十一、原型（prototype）和原型链</h3><ol><li>什么是原型（prototype）<blockquote><ul><li>任何函数都有一个<code>prototype</code>属性，<code>pr</code>ototype的翻译成英语，就是“原型”的意思</li><li><code>prototype</code>属性值是一个<strong>对象</strong>，这个对象中拥有一个<code>constructor</code>属性，这个属性指向<strong>这个函数本身</strong>。</li></ul></blockquote></li></ol><pre><code>function sum(a, b) &#123;  return a + b;&#125;&gt;console.log(sum.prototype); // &#123;constructor: ƒ&#125;console.log(typeof sum.prototype); // objectconsole.log(sum.prototype.constructor === sum); // true</code></pre><blockquote><blockquote><p>对于普通函数， prototype属性没有任何用处，而 构造函数的 prototype 属性非常有用</p></blockquote></blockquote><ol start="2"><li>构造函数的 prototype 属性<blockquote><ul><li>构造函数的prototype属性是它的<strong>实例的原型</strong></li><li>在构造函数的实例中有一个<strong>隐含</strong>的属性<code>__proto__</code>，指向该构造函数的原型<code>prototype</code><br><code>实例.__proto__===构造函数.prototype</code><img src="prototype属性.png"></li></ul></blockquote></li></ol><blockquote><blockquote><p>实例的__proto__属性，指向构造函数的原型 prototype，到底有什么用 ？</p><ul><li>答案就是：原型链查找</li></ul></blockquote></blockquote><ol><li>什么是原型链查找<blockquote><ul><li>构造函数的原型 <code>prototype</code> 对象，相当于一个<strong>公共的区域</strong>，所有<strong>同一个类的实例</strong>都可以访问到这个原型对象</li><li>所以我们可以将对象中<strong>共有的内容</strong>，统一设置到原型对象中。</li><li>当我们通过对象访问属性时，会按照属性的名称开始查找，他<strong>最先</strong>开始在对象<strong>实例本身</strong>来查找，如果在实例身上找到了，则返回该属性对应的值。</li><li>如果没有找到，会去<strong>原型对象</strong>中寻找，如果原型对象中有，则使用</li><li>如原型对象中没有，则继续去<strong>原型的原型</strong>中寻找，直到找到 <code>Object</code>对象的原型</li><li>Object 对象的原型没有原型，如果在 Object 对象的原型中依然没有，则返回 <code>undefined</code><blockquote><p>对象访问属性时，会沿着原型去查找，好比原型形成了一个链条，一层一层向上找，我们把这种现象称为 原型链查找 。</p></blockquote></li></ul></blockquote></li></ol><pre><code>function People(name, age, sex) &#123;  this.name = name;  this.age = age;  this.sex = sex;&#125;&gt;// 在构造函数的prototype上添加nationality属性People.prototype.nationality = &quot;中国&quot;;&gt;// 实例化var cuihua = new People(&quot;翠花&quot;, 18, &quot;男&quot;);&gt;console.log(cuihua.nationality); // 输出：中国，这个就叫做原型链查找console.log(cuihua); // &#123;name: &#39;翠花&#39;, age: 18, sex: &#39;男&#39;&#125;&gt;// 总结：当一个对象打点调用一个属性时，这个对象的身上并没有这个属性的时候，系统并不会直接报错，它会寻找这个对象的原型上有没有这个属性，如果能找到这个属性，则证明打点调用是可以的</code></pre><img src="原型链查找.png"><blockquote><blockquote><p>JS 规定：一个对象（或一个实例）是可以<strong>打点调用</strong>原型上的属性的；因此：cuihua 是可以打点调用 nationality 属性的</p></blockquote></blockquote><ol start="4"><li>原型链的遮蔽效应<blockquote><ul><li>我们说当访问对象中的属性时，会<strong>先在自身</strong>找，如果找到就用自身的。</li><li>也就是说，如果自身有一个与原型对象上同名的属性，那自然在查找时，<strong>会以自身的为主</strong></li><li>这就相当于<strong>原型上的同名属性被遮蔽</strong>了，我们把这种现象称为原型链的遮蔽效应</li></ul></blockquote></li></ol><pre><code>function People(name, age, sex) &#123;  this.name = name;  this.age = age;  this.sex = sex;&#125;// 在构造函数的prototype(原型)上添加nationality属性People.prototype.nationality = &quot;中国&quot;;// 实例化var cuihua = new People(&quot;翠花&quot;, 18, &quot;男&quot;);// 再实例化一个mini对象var mini = new People(&quot;mini&quot;, 19, &quot;女&quot;);// 给mini本身添加nationality属性mini.nationality = &quot;美国&quot;;&gt;console.log(cuihua.nationality); // 输出：中国console.log(cuihua); // &#123;name: &#39;翠花&#39;, age: 18, sex: &#39;男&#39;&#125;&gt;console.log(mini.nationality); // 输出：美国，这就是原型链的遮蔽效应</code></pre><ol start="5"><li>hasOwnProperty<blockquote><ul><li><code>hasOwnProperty</code>方法可以检查对象是否真正 “<strong>自己拥有</strong>” 某属性或者方法</li><li>也就是这个属性或方法，是<strong>在实例本身</strong>身上，并不是在原型上。</li><li>如果是真正自身属性，返回 true，否则返回 false</li></ul></blockquote></li></ol><pre><code>function People(name, age, sex) &#123;  this.name = name;  this.age = age;  this.sex = sex;&#125;// 在构造函数的prototype(原型)上添加nationality属性People.prototype.nationality = &quot;中国&quot;;//new一个实例var cuihua = new People(&quot;翠花&quot;, 18, &quot;男&quot;);&gt;console.log(cuihua.hasOwnProperty(&quot;name&quot;)); // trueconsole.log(cuihua.hasOwnProperty(&quot;age&quot;)); // trueconsole.log(cuihua.hasOwnProperty(&quot;sex&quot;)); // trueconsole.log(cuihua.hasOwnProperty(&quot;nationality&quot;)); // false</code></pre><ol start="6"><li>in<blockquote><ul><li>in 运算符<strong>只能</strong>检查某个属性或方法是否可以被对象访问，<strong>不能</strong>检查<strong>是否是自己的</strong>属性或方法</li><li>也就是不管这个属性是对象自身还是原型上的，都返回 true,找不到，则返回 false</li></ul></blockquote></li></ol><pre><code>function People(name, age, sex) &#123;  this.name = name;  this.age = age;  this.sex = sex;&#125;// 在构造函数的prototype(原型)上添加nationality属性People.prototype.nationality = &quot;中国&quot;;var cuihua = new People(&quot;翠花&quot;, 18, &quot;男&quot;);console.log(&quot;name&quot; in cuihua); // trueconsole.log(&quot;age&quot; in cuihua); // trueconsole.log(&quot;sex&quot; in cuihua); // trueconsole.log(&quot;nationality&quot; in cuihua); // true</code></pre><ol start="7"><li>在 prototype 添加方法<blockquote><ul><li>在之前的课程中，我们把方法都是直接写到了构造函数身上，这种方式会造成<strong>内存的浪费</strong>，因为每创建一个实例，就需要单独为同一个方法分配一块内存空间。</li><li>如果将方法写在构造函数的原型 prototype 上，就不会了，因为并不会创建一个实例，就为方法分配一块内存，所有实例都是共用原型上的同一个方法。</li></ul></blockquote></li></ol><ul><li>写在构造函数身上</li></ul><pre><code>function Count(a, b) &#123;  this.a = a;  this.b = b;  // 方法写在构造函数中  this.add = function () &#123;    return this.a + this.b;  &#125;;&#125;&gt;var c1 = new Count(2, 3);var c2 = new Count(2, 3);var c3 = new Count(2, 3);// 指向内存中的不同地址，每个对象身上的方法都分配了一块内存console.log(c1.add === c2.add); //  falseconsole.log(c2.add === c3.add); // false</code></pre><ul><li>写在构造函数的原型上</li></ul><pre><code>function Count(a, b) &#123;  this.a = a;  this.b = b;&#125;// 将方法，加在构造函数的原型上Count.prototype.add = function () &#123;  return this.a + this.b;&#125;;&gt;var c1 = new Count(2, 3);var c2 = new Count(3, 3);var c3 = new Count(6, 3);console.log(c1.add === c2.add); // trueconsole.log(c2.add === c3.add); // true;console.log(c1.add(), c2.add(), c3.add()); // 5 6 9</code></pre><ol start="8"><li>原型链的终点<blockquote><ul><li>原型对象也是对象，所以原型也有原型，最终所有的对象都会继承 Object 的原型</li><li>Object 原型的的原型是 <code>null</code>，即原型链的<strong>终点</strong></li></ul></blockquote></li></ol><pre><code>function People(name, age) &#123;  this.name = name;  this.age = age;&#125;&gt;var p1 = new People(&quot;小丽&quot;, 32);console.log(People.prototype === p1.__proto__);console.log(People.prototype.__proto__ === Object.prototype);console.log(Object.prototype.__proto__ === null);</code></pre><img src="原型链的终点.png"><ol start="9"><li>原型链</li></ol><ul><li>数组是<code>Array</code>类（构造函数）构造出来的，Array的原型指向 <code>Object</code>的原型</li></ul><pre><code>var arr = [123, 55, 33, 66, 88];&gt;console.log(arr.__proto__ === Array.prototype); // trueconsole.log(Array.prototype.__proto__ === Object.prototype);console.log(arr.__proto__.__proto__ === Object.prototype); // true</code></pre><img src="数组的原型链.png"><ul><li>验证 hasOwnProperty() 和 toString() 方法</li></ul><pre><code>function People(name, age, sex) &#123;  this.name = name;  this.age = age;&#125;&gt;var cuihua = new People();console.log(cuihua.__proto__.__proto__ === Object.prototype); // true,说明cuihua的原型的原型是 Object.prototypeconsole.log(Object.prototype.__proto__); // null，说明Object.prototype没有自己的原型了，即 它就是原型链的终点&gt;console.log(Object.prototype.hasOwnProperty(&quot;hasOwnProperty&quot;)); // true，说明hasOwnProperty方法是定义在Object.prototypeconsole.log(Object.prototype.hasOwnProperty(&quot;toString&quot;)); // true，同理</code></pre><blockquote><blockquote><p>每个对象，比如数组、字符串、数字等<strong>都重写</strong>了<code>toString()</code>方法</p></blockquote></blockquote><ol start="10"><li>函数的原型链</li></ol><pre class=" language-js"><code class="language-js"><span class="token keyword">function</span> <span class="token function">fn</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span><span class="token operator">></span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>fn<span class="token punctuation">.</span>__proto__ <span class="token operator">===</span> Function<span class="token punctuation">.</span>prototype<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// true</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>Function<span class="token punctuation">.</span>prototype<span class="token punctuation">.</span>__proto__ <span class="token operator">===</span> Object<span class="token punctuation">.</span>prototype<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// true</span><span class="token comment" spellcheck="true">// 所有对象，本质都是构造函数构造出来的</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>Object<span class="token punctuation">.</span>__proto__ <span class="token operator">===</span> Function<span class="token punctuation">.</span>prototype<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// true</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>Object<span class="token punctuation">.</span>__proto__<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// ƒ () &amp;#123; [native code] &amp;#125;</span></code></pre><blockquote><ul><li>Object也是一个函数，所有的函数都是Function构造出来的；所以Object是Function的一个实例，因此<code>Object.__proto__ === Function.prototype</code><img src="函数的原型链.png"></li></ul></blockquote><ol start="11"><li>instanceof<blockquote><ul><li>检查一个对象是否是一个类的<strong>实例</strong>。</li><li>底层机理:就是检查<strong>构造函数.prototype 属性</strong>是否在实例的<strong>原型链</strong>上（多少层都行）</li><li>所有对象都是 <code>Object</code> 的后代，所以任何对象与 Object 做 instanceof 检查时都会返回 true</li></ul></blockquote></li></ol><pre><code>function People(name, age) &#123;  this.name = name;  this.age = age;&#125;function Dog(name, age) &#123;  this.name = name;  this.age = age;&#125;&gt;var p1 = new People(&quot;小丽&quot;, 32);var dog = new Dog(&quot;小黑&quot;, 3);console.log(p1 instanceof People); //trueconsole.log(dog instanceof People); //falseconsole.log(dog instanceof Dog); //trueconsole.log(dog instanceof Object); //trueconsole.log(p1 instanceof Object); //true&gt;console.log(p1.__proto__.__proto__ === Object.prototype); // trueconsole.log(dog.__proto__.__proto__ === Object.prototype); // trueconsole.log(People.prototype.__proto__ == Object.prototype); // trueconsole.log(Dog.prototype.__proto__ == Object.prototype); // trueconsole.log(Object.prototype.__proto__); // null</code></pre><img src="instanceof.png"><ol start="12"><li>类数组转换数组<blockquote><blockquote><p>常用来将类数组转换为数组的方法有</p></blockquote><ul><li><code>Array.prototype.slice.call(arguments);</code> &#x2F;&#x2F; 把slice当成arguments的一个方法<ul><li><code>Array.prototype.slice()</code>是返回一个包含所有元素的新数组</li><li><code>.call(arguments)</code>改变this指向；组合起来就是把arguments的所有元素塞到一个新数组里</li><li>如果arguments后有参数，表示start和end</li></ul></li><li><h2 id="Array-prototype-concat-apply-arguments-concat-是返回一个合并所有元素后的新数组-合并arguments和-apply-arguments-改变this指向"><a href="#Array-prototype-concat-apply-arguments-concat-是返回一个合并所有元素后的新数组-合并arguments和-apply-arguments-改变this指向" class="headerlink" title="Array.prototype.concat.apply([], arguments);- .concat([])是返回一个合并所有元素后的新数组,合并arguments和[]- .apply(arguments)改变this指向"></a><code>Array.prototype.concat.apply([], arguments);</code><br>- <code>.concat([])</code>是返回一个合并所有元素后的新数组,合并arguments和[]<br>- <code>.apply(arguments)</code>改变this指向</h2></li></ul></blockquote></li></ol><pre><code>function sum(a, b, c) &#123;  var arr1 = Array.prototype.slice.call(arguments);  var arr2 = Array.prototype.concat.apply([], arguments);  console.log(arr1);  console.log(arr2);&#125;sum(1, 2, 3);//[1,2,3]//[1,2,3]</code></pre><ol start="13"><li>手写 JS 的 slice 方法</li></ol><pre><code> /**  * slice(start,end)方法的功能，返回值，注意事项  * 1、功能：从指定start下标开始复制数组中元素，添加到新数组中，到下标end结束，不包括end  * 2、返回值：查询到的元素组成的新数组  * 3、注意事项  * - 如果start和end为null 、undefind，和非数字类型，则start=0  * - 如果end 为null或其它类型，end=0,如果end为undefined则表示数组长度  * - 如果start或end为负值时，要确定好查询的起始于结束的位置  * - 本质就是要把对应的负数转成正数对应下标 （难点，很多同学想不到）  */ Array.prototype._slice = function (start, end) &#123;   var result = [];   // null和数字类型转成 0或数字;其它都转为NaN，start赋值为0   start = Number(start) !== Number(start) ? 0 : Number(start);   // 这里不用处理NaN的情况，因为结束是NaN时,本质上是什么也查不到，也就相当于0，不做任何查询   end = end === undefined ? arr.length : Number(end);   // 如果start小于0，则确定start的查找位置   if (start &lt; 0) &#123;     start = -start &gt; this.length ? 0 : this.length + start;   &#125;   // 如果start小于0，则确定end的结束位置   if (end &lt; 0) &#123;     end = -end &gt; this.length ? 0 : this.length + end;   &#125;   // 循环遍历，从起始位置到结束位置，查找元素，添加到新数组中   // 不用判断 start与end的大小关小，因为start如果大于end不会执行   for (var i = start; i &lt; end; i++) &#123;     result[result.length] = this[i];   &#125;   return result; &#125;;&gt; var arr = [1, 9, 3, 4, 5]; arr2 = arr._slice(NaN, &quot;2&quot;); //[1,9] arr3 = arr.slice(true, NaN); //[] arr4 = arr.slice(undefined, &quot;4&quot;); //[1,9,3,4] console.log(arr2); console.log(arr3); console.log(arr4);</code></pre><ol start="14"><li>手写数组的 concat 方法</li></ol><pre><code>&gt;/**&gt; * concat(value,value2) 方法的功能，返回值，注意事项&gt; * 功能：将数组或值，被合并到一个新的数组中&gt; * 返回值：返回合并后组成的新数组&gt; * 注意事项：concat后的参数如果不是数组的情况，要考虑进去，不要漏掉&gt; */Array.prototype._concat = function () &#123;  var newArr = [];  // 浅浅拷贝调用concat方法的数组  for (var i = 0; i &lt; this.length; i++) &#123;    newArr.push(this[i]);  &#125;  for (var i = 0; i &lt; arguments.length; i++) &#123;    if (!Array.isArray(arguments[i])) &#123;      newArr[newArr.length] = arguments[i];    &#125; else &#123;      for (var j = 0; j &lt; arguments[i].length; j++) &#123;        newArr[newArr.length] = arguments[i][j];      &#125;    &#125;  &#125;  return newArr;&#125;;&gt;var arr = [1, 2, 3];//   var arr2 = arr._concat(1, [5, 6], [7], 9);var arr2 = [].concat(1, 2, 3);console.log(arr2);</code></pre><ol start="15"><li>Object.prototype.toString()方法<blockquote><ul><li>该方法返回一个表示该对象的字符串。</li><li>返回值为”[object type]”，其中 type 是对象的类型</li></ul></blockquote></li></ol><pre><code>Object.prototype.toString([]); // &#39;[object Object]&#39;Object.prototype.toString(&#123;&#125;); // &#39;[object Object]&#39;Object.prototype.toString(function () &#123;&#125;); // &#39;[object Object]&#39;Object.prototype.toString(1); // &#39;[object Object]</code></pre><ol start="16"><li>经典应用：toString() 来获取每个对象的类型<blockquote><ul><li>通过<code>Object.prototype.toString.call(thisArg)</code>或</li><li><code>Object.prototype.toString.apply(thisArg)</code>来判断<code>thisArg</code>的类型</li><li>要检查的对象作为第一个参数，称为<code>thisArg</code></li></ul></blockquote></li></ol><pre><code> console.log(Object.prototype.toString.call([])); //&#39;[object Array]&#39; console.log(Object.prototype.toString.call(&#123;&#125;)); //&#39;[object object]&#39; console.log(Object.prototype.toString.call(function () &#123;&#125;)); //&#39;[object Function]&#39; console.log(Object.prototype.toString.call(null)); //&#39;[object Null]&#39; console.log(Object.prototype.toString.call(undefined)); //&#39;[object Undefined]&#39; console.log(Object.prototype.toString.call(true)); //&#39;[object Boolean]&#39; console.log(Object.prototype.toString.call(111)); //&#39;[object Number]&#39; console.log(Object.prototype.toString.call(&quot;aaa&quot;)); //&#39;[object string]&#39;</code></pre><blockquote><blockquote><p>温馨提示：</p></blockquote><ul><li>Array、String、Number、Boolean、RegExp、Date 等类型都重写了 toString()<ul><li>数组的toString()方法是将数组转成以<code>,</code>逗号分隔的字符串，同时返回该字符串</li></ul></li><li>所以实例本身调用 toString()方法，并不能达到检测类型的作用。</li><li>因为直接调用是调用自身的原型对象上已有 toString()方法,就不会调用到 Object 原型对象上的 toString()方法了</li></ul></blockquote><h3 id="十二、本章节经典面试题"><a href="#十二、本章节经典面试题" class="headerlink" title="十二、本章节经典面试题"></a>十二、本章节经典面试题</h3><ol><li>手写一个 getType 方法，可以判断出任意的<strong>数据类型</strong>（经典面试题）<blockquote><ul><li>getType 方法可以准确获取任意数据类型，如 number、string、boolean、null、undefined、object、array、function 、regexp</li><li>上面我们学习了<code>Object.prototype.toString()</code>方法，我们知道他可以判断出任意的类型，所以我们就用这个方法实现</li><li><code>indexOf()</code>方法,返回在数组中可以找到给定元素的第一个索引，如果不存在，则返回-1</li><li><code>slice()</code>提取原数组的一部分并返回一个新数组</li></ul></blockquote></li></ol><pre><code>function getType(x) &#123;  var originType = Object.prototype.toString.call(x); // &#39;[object type]&#39;  var spaceIndex = originType.indexOf(&quot; &quot;); // 查找空隙所在下标  var type = originType.slice(spaceIndex + 1, -1); // 从空格下标+1位位置查询字符串，查询到字符串最后一位  return type.toLowerCase(); // 将分格出来的类型，统一转成小写字&#125;var type = getType(2); //numbervar type1 = getType(&quot;ss&quot;); //stringvar type2 = getType(null); //nullvar type3 = getType(&#123;&#125;); //objectconsole.log(type, type1, type2, type3);</code></pre><ol start="2"><li>判断数据类型有那些方法，分别有什么区别 ？<table><thead><tr><th>判断数据类操作符或方法</th><th>功能</th><th>用法</th></tr></thead><tbody><tr><td>typeof</td><td>只能区分基本数据类型和引用数据类型;但不能区分 null、Object、array;typeof null得到object;typeof 检测函数得到 function</td><td>typeof a;</td></tr><tr><td>Array.isArray()</td><td>判断某个变量，是不是数组</td><td>Array.isArray(arr)</td></tr><tr><td>in</td><td>检查某个属性或方法<strong>是否可以被对象访问</strong>，不能检查是否是自己的属性或方法</td><td>‘name’ in obj</td></tr><tr><td>hasOwnProperty</td><td>检查对象是否真正 “自己拥有” 某属性或者方法</td><td>obj.hasOwnProperty(属性&#x2F;方法)</td></tr><tr><td>instanceof</td><td>检查一个对象是否是一个类的实例</td><td>实例 instanceof Object</td></tr><tr><td>constructor</td><td>判断实例对象是不是这个构造函数的实例</td><td>an1.constructor &#x3D;&#x3D; Anamil</td></tr><tr><td>Object.prototype.toString().call()</td><td>可以用来判断任意数据类型</td><td>Object.prototype.toString().call(X)</td></tr></tbody></table></li></ol><ul><li>constructor<blockquote><ul><li>构造函数的原型<code>prototype</code>上有一个属性 constructor，这个属性指向<strong>构造函数本身</strong></li><li>构造函数构造的<strong>实例</strong>可以直接访问<code>prototype</code>对象身上的属性和方法</li><li>即：<code>实例.constructor === 构造函数</code> 那就说明这个实例是这个构造函数的实例</li></ul></blockquote></li></ul><blockquote><blockquote><p>注意事项</p></blockquote><ul><li>constructor 是<strong>不稳定</strong>的，因为开发者可以重写 prototype，重写后，原有的 constructor 引用会<strong>丢失</strong>，需要我们<strong>重新指定</strong> constructor 的引用</li></ul></blockquote><blockquote><ul><li>未重写prototype时</li></ul></blockquote><pre><code> function People(name, age) &#123;   this.name = name;   this.age = age; &#125; var p1 = new People(&quot;小明&quot;, 32); console.log(p1.__proto__ === People.prototype); console.log(People.__proto__ === Function.prototype); console.log(Function.prototype.__proto__ === Object.prototype); console.log(Object.prototype.__proto__ === null); console.log(Object.__proto__ === Function.prototype); console.log(People.prototype.constructor); //People console.log(p1.constructor); //People,说明这个p1是这个构造函数People的实例</code></pre><img src="未改写constructor.png"><ul><li>重写prototype后</li></ul><pre><code> function F() &#123;&#125; F.prototype = &#123;&#125;; var p = new F(); console.log(p.constructor); //Object,改写后p1变成了Object的实例，因为&#123;&#125;所有对象都是Object构造出来的 console.log(p.__proto__.__proto__.constructor); //Object console.log(F.prototype.constructor); //Object console.log(F.prototype.__proto__.constructor); //Object</code></pre><img src="改写constructor.png"> <blockquote><ul><li>当 <code>F.prototype = &#123;&#125;</code> 时， {} 是 new Object() 创建出来的实例</li><li>所以{}的proto指向<code>Object</code>构造函数的原型prototype,Object 的 prototype 对象上的属性 <code>constructor</code> 指 Object 构造函数</li></ul></blockquote><ol start="3"><li>ES6版本——手写 call 方法（经典面试题）<blockquote><ul><li>函数.call(obj),类似于把函数当成了obj 的方法来使用</li><li>我们就是要利用这个特点来实现 手写 call 函数</li></ul></blockquote></li></ol><ul><li><p>第一步：</p><blockquote><ul><li>call 方法，是函数身上的方法，所以肯定手写的 call 方法，是要绑定到函数的原型上。</li><li>因为构造函数的原型 prototype 对象，相当于一个公共的区域，所有同一个类的实例都可以访问到这个原型对象<br><code>Function.prototype._call = function () &#123;&#125;;</code></li></ul></blockquote></li><li><p>第二步：搭建基础结构</p><blockquote><ul><li>call 方法的第一个参数是用来改变 this 指向（函数上下文），后面的参数相当于是传递给函数的参数,且个数不定，所以我们定义函数时，可以用写形参，最后用实参来接受传过来的参数</li></ul></blockquote></li></ul><pre><code>// context 表示传入的上下文对象Function.prototype._call = function (context) &#123;&#125;;```- 第三步：把函数处理成 context 对象的方法&gt;- 要主函数成为`context`的方法，我们需要为 context 对象添加一个属性 key，然后把这个属性指向这个函数&gt;- `_call`方法内部的 this 就是调用_call方法的函数，即 `context[key]=this`&gt;- 当然要保证 context 对象新添加的属性 key 不能与对象原有的属性**重名**，如果重名就会对象原有的属性给覆盖了。&gt;- 用 ES6 的 `Symbol` 来创建一个唯一的标识符。</code></pre><p>Function.prototype._call &#x3D; function (context) {<br>  &#x2F;&#x2F; 创建一个变量，用来做为context对象的属性<br>  &#x2F;&#x2F; 防止属性名与context身上的属性重名，则我们需要用Symbol();方式来创建<br>  var key &#x3D; Symbol();<br>  &#x2F;&#x2F; 这里的this指向的是函数本身，把函数转换成context身上的方法<br>  context[key] &#x3D; this;<br>};</p><pre><code>- 第四步：调用函数，并处理参数&gt;- 调用_call方法的函数如果有对应的参数，我们需要在调用函数即`context[key]()`时，把对应的参数传递进去&gt;- 我们不清楚调用 call 方法的函数，具体有多少个参数，（这里用 `arguments` 来处理相对麻烦，在 es5 版本中，我们来讲 arguments 的方式如何处理）所以我们用剩余参数`..args`来接受所有参数，接受过来的参数是以数组的形式组合在一起 ,即类传于`args=[1,2,3]`&gt;- 利用`ES6`的**展开运算符**，把args数组展开放在调用的函数后面，作为实参传递过去</code></pre><p>  &#x2F;&#x2F; 调用函数，取得函数的返回结果<br>  var result &#x3D; context<a href="...args">key</a>;<br>  &#x2F;&#x2F; 返回函数执行后的返回值<br>  return result;</p><pre><code>- 第五步：**删除**新创建的属性，保证 context 不被修改，恢复原貌</code></pre><p>Function.prototype._call &#x3D; function (context, …args) {<br>  &#x2F;&#x2F; 创建一个变量，用来做为context对象的属性<br>  &#x2F;&#x2F; 防止属性名与context身上的属性重名，则我们需要用Symbol();方式来创建<br>  var key &#x3D; Symbol();<br>  &#x2F;&#x2F; 这里的this指向的是函数本身，把函数转换成context身上的方法<br>  context[key] &#x3D; this;<br>  &#x2F;&#x2F; 调用函数，取得函数的返回结果<br>  var result &#x3D; context<a href="...args">key</a>;<br>  &#x2F;&#x2F; 这里要特别注意，我们不能修改context对象<br>  &#x2F;&#x2F; 所以这里要把创建的属性，使用完，删除掉<br>  delete context[key];<br>  &#x2F;&#x2F; 返回执行结果<br>  return result;<br>};</p><pre><code>- 第六步：考虑 context 的数据类型&gt;如果传递过来的第一个参数context，不是一个对象呢 ？&gt;- 如果传过的是`null、nudefined` ，此时 context 指向全局对象 `globalThis`&gt;- 如果是**原始**数据类型呢 ？context 要被转换成对应的**包装对象**</code></pre><p> &#x2F;&#x2F; 如果传过来的是null 或undefind，则this指向window<br>  &#x2F;&#x2F; null &#x3D;&#x3D;null 返回true  undefined&#x3D;&#x3D;null也是true<br>  &#x2F;&#x2F; globalThis 在浏览器中指向window ，在nodejs中指向global<br>  if (context &#x3D;&#x3D; null) context &#x3D; globalThis;<br>  &#x2F;&#x2F; 如果传过来的是基本数据类型（原始数据类型）<br>  &#x2F;&#x2F; new Object(1) 转成 Number {1} ….<br>  if (typeof context !&#x3D;&#x3D; “object”) context &#x3D; new Object(context);</p><pre><code>- 第七步：判断调用 call 方法的对象，是不是一个函数&gt;- 按正常思维来思考，call 方法是在 `Function.prototype`上，只有函数才会调用到 call 方法。&gt;- 在实际上，会有一些特殊的情况，一个对象也能访问到 call 方法。比如：&gt;- 如果一个对象是用 `Function.prototype` 构造出来的，那他这个对象就能调用 call 方法，但他不是一个函数&gt;- Object.create()方法用于创建一个新对象，使用现有的对象来作为新创建对象的原型（prototype）</code></pre><p>var obj &#x3D; Object.create(Function.prototype);<br>&#x2F;&#x2F; obj是一个对象，但他能调用call方法</p><blockquote></blockquote><p>console.log(obj.<strong>proto</strong> &#x3D;&#x3D;&#x3D; Function.prototype); &#x2F;&#x2F; true</p><pre><code>&gt;- 所以需要判断调用 call方法的对象，是不是一个函数</code></pre><p> &#x2F;&#x2F; 判断调用 call方法的对象，是不是一个函数<br>  if (typeof this !&#x3D;&#x3D; “function”) {<br>    throw new TypeError(“Type Error !”);<br>  }</p><pre><code>- ES6版本——手写call方法</code></pre><p>&#x2F;&#x2F;实现：函数._call(obj,arg1,arg2,……)<br>&#x2F;&#x2F;context是指obj,参数通过…args传进去<br>Function.prototype._call &#x3D; function (context, …args) {<br>  &#x2F;&#x2F; 判断调用 call方法的对象，是不是一个函数<br>  if (typeof this !&#x3D;&#x3D; “function”) {<br>    throw new TypeError(“Type Error !”);<br>  }</p><blockquote></blockquote><p>  &#x2F;&#x2F; 如果传过来的是null 或undefind，则this指向window<br>  &#x2F;&#x2F; null &#x3D;&#x3D;null 返回true  undefined&#x3D;&#x3D;null也是true<br>  &#x2F;&#x2F; globalThis 在浏览器中指向window ，在nodejs中指向global<br>  if (context &#x3D;&#x3D; null) context &#x3D; globalThis;<br>  &#x2F;&#x2F; 如果传过来的是基本数据类型（原始数据类型）<br>  &#x2F;&#x2F; new Object(1) 转成 Number {1} ….<br>  if (typeof context !&#x3D;&#x3D; “object”) context &#x3D; new Object(context);</p><blockquote></blockquote><p>  &#x2F;&#x2F; 创建一个变量，用来做为context对象的属性<br>  &#x2F;&#x2F; 防止属性名与context身上的属性重名，则我们需要用Symbol();方式来创建<br>  var key &#x3D; Symbol();<br>  &#x2F;&#x2F; 这里的this指向的是函数本身，把函数转换成context身上的方法<br>  context[key] &#x3D; this;<br>  &#x2F;&#x2F; 调用函数，取得函数的返回结果<br>  var result &#x3D; context<a href="...args">key</a>;<br>  &#x2F;&#x2F; 这里要特别注意，我们不能修改context对象<br>  &#x2F;&#x2F; 所以这里要把创建的属性，使用完，删除掉<br>  delete context[key];<br>  &#x2F;&#x2F; 返回执行结果<br>  return result;<br>};<br>  var a &#x3D; 0;<br>  var obj &#x3D; {<br>    a: 1,<br>    b: 2,<br>    c: 3,<br>  };<br>  function sum(a, b, c) {<br>    console.log(this.a + b + c);<br>  }<br>  sum(5, 6, 7); &#x2F;&#x2F;13 this是window<br>  sum._call(obj, 8, 9, 10); &#x2F;&#x2F;20 this是obj</p><pre><code>1. ES5 版本-手写 Call 方法（经典面试题）&gt;在 ES5 中，是没有 Symbol 、 剩余参数 和 扩展运算符的，所以在 ES5 中，我们要如何处理下面两个问题 ？&gt;- 第一：如何创建出一个 context 对象身上没有的属性&gt;- 第二：如何解决动态传参的问题- 如何创建出一个 context 对象身上没有的属性名&gt;- 随机生成属性名，&gt;- 然后判断这个属性名是否在原来的上下文对象中存在,如果存在，重新生成，如果不存在就可以使用</code></pre><p>&#x2F;&#x2F; 随机生成一个属性名，保证context对象身上没有与之同名的属性<br>var key&#x3D;”fn”+Math.random()+new Date().getTime();<br>while(context.hasOwnProperty(key)){<br>  key&#x3D;”fn”+Math.random()+new Date().getTime();<br>}</p><pre><code>&gt;&gt;`new Date().getTime()`用来获取当前时间的时间戳- Function 构造函数&gt;- ES5要解决动态传参的问题，就要利用`new Function()`动态创建函数来实现&gt;- 语法：`var fn = new Function(arg1,arg2,arg3...,functionBody)`&gt;- fn 为新创建出来的函数&gt;- `arg1,arg2，arg3...` 都是一个字符串，为新创建出来的函数的**形参**&gt;- `functionBod`是Function()构造函数的**最后一个参数**，表示新创建出来的函数的**函数体代码**，如果`new Function()`中只一个参数，那这个函数就是函数体代码，这个新创建出来的函数没有参数。</code></pre><p>&#x2F;&#x2F; 以下代码相当于创建了匿名函数  sum&#x3D; function anonymous(a,b){return a+b}<br>var sum &#x3D; new Function(“a”, “b”, “return a+b”);<br>sum(1, 2); &#x2F;&#x2F; 3</p><blockquote></blockquote><p>&#x2F;&#x2F; 相当于创建了匿名函数<br>&#x2F;&#x2F; sayHello&#x3D;sayHell&#x3D;function anonymous(){console.log(“大家好，我是…”)}<br>var sayHello &#x3D; new Function(‘console.log(“大家好，我是…”)’);<br>sayHello(); &#x2F;&#x2F; 大家好，我是…</p><pre><code>&gt;- **实现动态传递参数**&gt;- fn 函数，除去第一个参数外，后面传过来多少个参数，就要把这些参数一一作为sum()的实参**解决办法**&gt;- 我们可以根据 argArr 的长度，结合 new Function 来动态创建如下函数</code></pre><p>&#x2F;&#x2F; 假设argArr的长度是2,则创建出如下函数<br>function anonymous(argArr) {<br>  return sum(argArr[0], argArr[1]);<br>}</p><blockquote></blockquote><p>&#x2F;&#x2F; 假设argArr的长度为3，则创建出如下函数<br>function anonymous(argArr) {<br>  return sum(argArr[0], argArr[1], argArr[2]);<br>}</p><pre><code>&gt;- 相当于，我在 fn 的函数体内，只要调用上面创建出来的函数，就可以达到动态传参，并执行 sum 函数。</code></pre><p>function fn(context) {<br>  &#x2F;&#x2F; 处理fn动态传过来的参数，除去第一个参数，你传几个，我这里就接受几个<br>  &#x2F;&#x2F; 处理办法，先把接受过来的实参，添加到一个数组中<br>  var argArr &#x3D; [];<br>  for (var i &#x3D; 1; i &lt; arguments.length; i++) {<br>    argArr.push(arguments[i]);<br>  }</p><blockquote></blockquote><p>  &#x2F;&#x2F; 假设 argArr长度为3 ，则下面代码<br>  &#x2F;&#x2F; 内部会执行  sum(argArr[0],argArr[1],argArr[2])<br>  return anonymous(argArr);<br>}</p><pre><code>&gt;- 根据 argArr 长度，动态创建需要的函数&gt;&gt;- 要构造的函数：</code></pre><p>function fn(context,key,args){<br>  return context<a href="args%5B0%5D,args%5B1%5D,args%5B2%5D...">key</a>；&#x2F;&#x2F;code拼接函数体<br>}</p><pre><code>&gt;&gt; 因为参数个数不定，所以用new function构造函数</code></pre><p>function createFn(argArrLength) {<br>  var code &#x3D; “return sum(“;<br>  for (var i &#x3D; 0; i &lt; argArrLength; i++) {<br>    if (i &gt; 0) {<br>      code +&#x3D; “,”;<br>    }<br>    code +&#x3D; “argArr[“ + i + “]”;<br>  }<br>  code +&#x3D; “)”;</p><blockquote></blockquote><p>  return new Function(“argArr”, code);<br>}</p><pre><code>&gt;- 最终我们只需要在 fn 函数内部调用 createFn 函数就可以实现了</code></pre><p>function fn(context) {<br>  &#x2F;&#x2F; 处理fn动态传过来的参数，除去第一个参数，你传几个，我这里就接受几个<br>  &#x2F;&#x2F; 处理办法，先把接受过来的实参，添加到一个数组中<br>  var argArr &#x3D; [];<br>  for (var i &#x3D; 1; i &lt; arguments.length; i++) {<br>    argArr.push(arguments[i]);<br>  }</p><blockquote></blockquote><p>  &#x2F;&#x2F; 假设 argArr长度为3 ，则下面代码<br>  &#x2F;&#x2F; 内部会执行  sum(argArr[0],argArr[1],argArr[2])<br>  return createFn(argArr.length)(argArr);&#x2F;&#x2F;立即执行函数<br>}</p><pre><code>- 实现动态传递参数 - 优化版</code></pre><p>function createFn(argArrLength) {<br>  var code &#x3D; “return sum(“;<br>  for (var i &#x3D; 0; i &lt; argArrLength; i++) {<br>    if (i &gt; 0) {<br>      code +&#x3D; “,”;<br>    }<br>    code +&#x3D; “argArr[“ + i + “]”;<br>  }<br>  code +&#x3D; “)”;</p><blockquote></blockquote><p>  return new Function(“argArr”, code);<br>}</p><pre><code>以上方法还有很大的局限性&gt;- 如果 fn 内部调用的函数不是sum是add、min、max呢 ？&gt;- 那就得把最开始的`var code=&#39;return sum(&#39;` 修改成`var code=&#39;return add(&#39;`&gt;- 为了让所有代码都能通用，我们把上面函数再做简单修改，修改如下：</code></pre><p>function createFn(argArrLength) {<br>  var code &#x3D; “return fnName(“;<br>  for (var i &#x3D; 0; i &lt; argArrLength; i++) {<br>    if (i &gt; 0) {<br>      code +&#x3D; “,”;<br>    }<br>    code +&#x3D; “argArr[“ + i + “]”;<br>  }<br>  code +&#x3D; “)”;</p><blockquote></blockquote><p>  return new Function(“argArr”, “fnName”, code);<br>}</p><pre><code>&gt;- 这样修改后，不管 fn 内部调用的函数名是什么，我们只需要在调用 createFn 函数时，把对应的函数名传进去就可以了。</code></pre><p>return createFn(argArr.length)(argArr, add); &#x2F;&#x2F; fn内调用add函数</p><blockquote></blockquote><p>return createFn(argArr.length)(argArr, min); &#x2F;&#x2F; fn内调用min函数</p><pre><code>- 总结：解决 call 方法内部动态传参问题&gt;- 我们需要根据 argArr 的长度，来动态创建一个如下形式的函数</code></pre><blockquote><p>&#x2F;**</p><ul><li>如果argArr长度为 3，则创建如下函数</li><li>context 上下文对象，call中的第一个参数</li><li>key 对象context的属性名</li><li>argArrs参数数组<br>*&#x2F;<br>function anonymous(context, key, argArr) {<br>  return context[key](argArr[0], argArr[1], argArr[2]);<br>}</li></ul></blockquote><p>&#x2F;&#x2F; 如果argArr 长度为2，则创建如下函数<br>function anonymous(context, key, argArr) {<br>  return context[key](argArr[0], argArr[1]);<br>}</p><pre><code>&gt;- 创建上面函数的函数</code></pre><blockquote><p>&#x2F;**</p><ul><li>此函数用来处理call内部动态传参问题，根据数组长度来创建函数</li><li>argsLength 传入的数组的长度<br>*&#x2F;<br>function createFun(argsLength) {<br>&#x2F;&#x2F; 动态创建函数体执行代码<br>var code &#x3D; “return context[key](“;<br>&#x2F;&#x2F; 拼接参数<br>for (var i &#x3D; 0; i &lt; argsLength; i++) {<br>  &#x2F;&#x2F; 第二个开始加逗号<br>  if (i &gt; 0) {<br>code +&#x3D; “,”;<br>  }<br>  code +&#x3D; “argArr[“ + i + “]”;<br>}<br>code +&#x3D; “)”;</li></ul></blockquote><p>  &#x2F;&#x2F;  return context<a href="args%5B0%5D,args%5B1%5D,args%5B2%5D....">key</a><br>  &#x2F;&#x2F; 函数前三个参数分别代表： 执行上下文   属性名    参数   context<a href="args">key</a><br>  &#x2F;&#x2F; 但args是数组，所以需要动态的来拼接，不能直接用<br>  return new Function(“context”, “key”, “argArr”, code);<br>}</p><pre><code>&gt;- 完整版代码&gt;`函数.call(thisArg,arg1,arg2,arg3,...);`</code></pre><p>Function.prototype._call &#x3D; function (context) {<br>  &#x2F;&#x2F; context 表示传入的上下文对象，用实参来接受传过来的参数</p><blockquote></blockquote><p>  &#x2F;&#x2F; 判断调用 call方法的对象，是不是一个函数<br>  if (typeof this !&#x3D;&#x3D; “function”) {<br>    throw new TypeError(“Type Error !”);<br>  }<br>  if (context &#x3D;&#x3D; null) context &#x3D; globalThis;<br>  if (typeof context !&#x3D;&#x3D; “object”) context &#x3D; new Object(context);</p><blockquote></blockquote><p>  &#x2F;&#x2F; 随机生成一个属性名，保证context对象身上没有与之同名的属性<br>  var key &#x3D; “fn_” + Math.random() * new Date().getTime();<br>  while (context.hasOwnProperty(key)) {<br>    key &#x3D; “fn_” + Math.random() * new Date().getTime();<br>  }</p><blockquote></blockquote><p>&#x2F;&#x2F;把调用call的函数改成obj的方法，所以为context对象添加一个属性key<br>  context[key] &#x3D; this;</p><blockquote></blockquote><p>  &#x2F;&#x2F; 解决动态传参问题：<br>  &#x2F;&#x2F;1.获取参数组成的数组和参数个数<br>  var argArr &#x3D; [];<br>  var len &#x3D; arguments.length;<br>  &#x2F;&#x2F;索引为0的是this&#x2F;obj对象<br>  for (var i &#x3D; 1; i &lt; len; i++) {<br>    argArr[i - 1] &#x3D; arguments[i];<br>  }<br>  &#x2F;&#x2F; 2. 传参给createFun函数来解决<br>  var result &#x3D; createFun(len - 1)(context, key, argArr);<br>  &#x2F;&#x2F;立即执行createFun(len - 1)函数<br>  &#x2F;&#x2F;并把(context, key, argArr)传参给new Function函数，执行code代码</p><blockquote></blockquote><p>  delete context[key];<br>  return result;<br>};</p><blockquote></blockquote><p>&#x2F;&#x2F;传入实参len-1<br>function createFun(argsLength) {<br>  &#x2F;&#x2F; 动态创建函数体执行代码<br>  var code &#x3D; “return context[key](“;<br>  &#x2F;&#x2F; 拼接参数，第二个起是参数<br>  for (var i &#x3D; 0; i &lt; argsLength; i++) {<br>    if (i &gt; 0) {<br>      code +&#x3D; “,”;<br>    }<br>    code +&#x3D; “argArr[“ + i + “]”;<br>  }<br>  code +&#x3D; “)”;<br>  &#x2F;&#x2F;传入(context, key, argArr)参数，执行code函数体<br>  return new Function(“context”, “key”, “argArr”, code);<br>}</p><blockquote></blockquote><p>var obj &#x3D; {<br>  a: 1,<br>  b: 2,<br>};<br>&#x2F;&#x2F;函数名随意，可以不是sum<br>function sum(a, b, c) {<br>  console.log(this.a, b, c);<br>}<br>sum._call(obj, 7, 8, 9);&#x2F;&#x2F;1 8 9</p><pre><code>1. 手写 apply 方法（经典面试题）&gt;- apply 和 call 方法一样，唯一的区别就在于，**其后的参数是数组**&gt;- 所以要判断下，传过来的值是不是数组类型，如果不是，则赋值一个空数组- ES6方法</code></pre><p>Function.prototype._apply &#x3D; function (context, args &#x3D; []) {<br>  &#x2F;&#x2F; 判断传过来的是不是一个数组,不是就赋值一个空数组<br>  args &#x3D; Array.isArray(args) ? args : [];<br>  &#x2F;&#x2F; 如果传过来的是null 或undefind，则this指向window<br>  &#x2F;&#x2F; null &#x3D;&#x3D;null 返回true  undefined&#x3D;&#x3D;null也是true<br>  &#x2F;&#x2F; globalThis 在浏览器中指向window ，在nodejs中指向global<br>  if (context &#x3D;&#x3D; null) context &#x3D; globalThis;<br>  &#x2F;&#x2F; 如果传过来的是基本数据类型（原始数据类型）<br>  &#x2F;&#x2F; new Object(1) 转成 Number {1} ….<br>  if (typeof context !&#x3D;&#x3D; “object”) context &#x3D; new Object(context);</p><blockquote></blockquote><p>  &#x2F;&#x2F; 创建一个变量，用来做为context对象的属性<br>  &#x2F;&#x2F; 防止属性名与context身上的属性重名，则我们需要用Symbol();方式来创建<br>  var key &#x3D; Symbol();<br>  &#x2F;&#x2F; 这里的this指向的是函数本身，把函数转换成context身上的方法<br>  context[key] &#x3D; this;<br>  &#x2F;&#x2F; 调用函数，取得函数的返回结果<br>  var result &#x3D; context<a href="...args">key</a>;<br>  &#x2F;&#x2F; 这里要特别注意，我们并没有真正的在context对象上，创建了属性<br>  &#x2F;&#x2F; 所以这里要把创建的属性，使用完，删除掉<br>  delete context[key];<br>  &#x2F;&#x2F; 返回执行结果<br>  return result;<br>};</p><pre><code>- ES5方法</code></pre><p>Function.prototype._call &#x3D; function (context,args &#x3D; []) {<br>&#x2F;&#x2F; context 表示传入的上下文对象，用实参来接受传过来的参数</p><blockquote></blockquote><p>&#x2F;&#x2F; 判断传过来的是不是一个数组,不是就赋值一个空数组<br>  args &#x3D; Array.isArray(args) ? args : [];</p><blockquote><p>&#x2F;&#x2F; 判断调用 call方法的对象，是不是一个函数<br>if (typeof this !&#x3D;&#x3D; “function”) {<br>  throw new TypeError(“Type Error !”);<br>}<br>if (context &#x3D;&#x3D; null) context &#x3D; globalThis;<br>if (typeof context !&#x3D;&#x3D; “object”) context &#x3D; new Object(context);</p></blockquote><p>&#x2F;&#x2F; 随机生成一个属性名，保证context对象身上没有与之同名的属性<br>var key &#x3D; “fn_” + Math.random() * new Date().getTime();<br>while (context.hasOwnProperty(key)) {<br>  key &#x3D; “fn_” + Math.random() * new Date().getTime();<br>}</p><blockquote></blockquote><p>&#x2F;&#x2F;把调用call的函数改成obj的方法，所以为context 对象添加一个属性key<br>context[key] &#x3D; this;</p><blockquote></blockquote><p>&#x2F;&#x2F; 解决动态传参问题：<br>&#x2F;&#x2F;1.获取参数组成的数组和参数个数<br>var argArr &#x3D; args;<br>var len &#x3D; arguments.length;</p><blockquote></blockquote><p>&#x2F;&#x2F; 2. 传参给createFun函数来解决<br>var result &#x3D; createFun(len - 1)(context, key, argArr);<br>&#x2F;&#x2F;立即执行createFun(len - 1)函数<br>&#x2F;&#x2F;并把(context, key, argArr)传参给new Function函数，执行code代码</p><blockquote></blockquote><p>delete context[key];<br>return result;<br>};</p><blockquote></blockquote><p>&#x2F;&#x2F;传入实参len-1<br>function createFun(argsLength) {<br>&#x2F;&#x2F; 动态创建函数体执行代码<br>var code &#x3D; “return context[key](“;<br>&#x2F;&#x2F; 拼接参数，第二个起是参数<br>for (var i &#x3D; 0; i &lt; argsLength; i++) {<br>  if (i &gt; 0) {<br>    code +&#x3D; “,”;<br>  }<br>  code +&#x3D; “argArr[“ + i + “]”;<br>}<br>code +&#x3D; “)”;<br>&#x2F;&#x2F;传入(context, key, argArr)参数，执行code函数体<br>return new Function(“context”, “key”, “argArr”, code);<br>}</p><pre><code>6. 手写 bind 方法- 核心功能&gt;- 改变函数的this指向&gt;- 返回一个新函数&gt;- 可以提前预设参数- 思路&gt;- bind 的方法在 Function 的原型上</code></pre><blockquote><p>Function.prototype._bind &#x3D; function () {};</p></blockquote><pre><code>&gt;- bind 的第一个参数是更改原函数中的 this 指向，后面参数个数不限&gt;- 改变原函数中 this，可以用原函数.apply(context)方法&gt;- 预设参数：用 concat 来拼接两次调用函数传来参数&gt;- bind 函数的返回值，又是一个函数</code></pre><p>Function.prototype._bind &#x3D; function (context) {<br>  return function () {};<br>};</p><pre><code>&gt;- 考虑 bind 返回的新函数作为构造函数的情况&gt;   - bind 的新函数作为构造函数，其内部 this 指向的还是原函数 new 出来的实例对象&gt;   - 同时内部相当于直接调用了`new 原函数()`&gt;- 考虑调用 bind 的对象不是一个函数&gt; - 如果 bind 的第一个参数 thisArg 是&gt;   - 一个 null 或 undefined 时，其函数会自动将 this 替换为指向全局对象&gt;   - 如果 thisArg 是一个原始值会被包装成一个对象- 完整代码</code></pre><p>Function.prototype._bind &#x3D; function (context) {<br>  &#x2F;&#x2F; null &#x3D;&#x3D;null 返回true  undefined&#x3D;&#x3D;null也是true<br>  &#x2F;&#x2F; globalThis 在浏览器中指向window ，在nodejs中指向global<br>  if (context &#x3D;&#x3D; null) context &#x3D; globalThis;<br>  &#x2F;&#x2F; 如果传过来的是基本数据类型（原始数据类型）<br>  &#x2F;&#x2F; new Object(1) 转成 Number {1} ….<br>  if (typeof context !&#x3D;&#x3D; “object”) context &#x3D; new Object(context);</p><blockquote></blockquote><p>  var self &#x3D; this; &#x2F;&#x2F; 保存原函数<br>  &#x2F;&#x2F; 第一次传入的参数<br>  var arg1 &#x3D; Array.prototype.slice.call(arguments, 1);<br>  function fn() {<br>    &#x2F;&#x2F; 第二次传入的参数<br>    var arg2 &#x3D; Array.prototype.slice.call(arguments);<br>    &#x2F;&#x2F; 合并两次传入的参数<br>    var arg &#x3D; arg1.concat(arg2);<br>    &#x2F;&#x2F; 如果this指向的是fn的实例,则说明外部是以构造函数形式调用的<br>    if (this instanceof fn) {<br>      return new self(…arg1, …arg2);<br>    } else {<br>      return self.apply(context, arg);<br>    }<br>  }<br>  return fn;<br>};</p><blockquote></blockquote><p>function Point(x, y) {<br>  this.x &#x3D; x;<br>  this.y &#x3D; y;<br>  &#x2F;&#x2F; console.log(this.x, this.y);<br>}<br>Point.prototype.toString &#x3D; function () {<br>  return this.x + “,” + this.y;<br>};</p><blockquote></blockquote><p>var point &#x3D; Point._bind([], 0);<br>var p &#x3D; new point(5, 9);<br>console.log(p.toString());</p><blockquote></blockquote><p>&#x2F;&#x2F; 测试样例<br>var obj &#x3D; {<br>  a: 1,<br>  b: 2,<br>  c: 3,<br>};<br>function sum(a, b, c) {<br>  console.log(this.a, this.b, c);<br>}<br>var fn &#x3D; sum.bind(obj, 6);<br>fn(3, 4);</p><pre><code></code></pre>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JS核心知识点（七）</title>
      <link href="/2023/12/05/JS%E6%A0%B8%E5%BF%83%E7%9F%A5%E8%AF%86%E7%82%B9%EF%BC%88%E4%B8%83%EF%BC%89/"/>
      <url>/2023/12/05/JS%E6%A0%B8%E5%BF%83%E7%9F%A5%E8%AF%86%E7%82%B9%EF%BC%88%E4%B8%83%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<span id="more"></span><h3 id="一、手写-flat-方法，指定深度，实现数组的扁平化"><a href="#一、手写-flat-方法，指定深度，实现数组的扁平化" class="headerlink" title="一、手写 flat 方法，指定深度，实现数组的扁平化"></a>一、手写 flat 方法，指定深度，实现数组的扁平化</h3><blockquote><ul><li><code>flat()</code>方法会按照一个<strong>可指定的深度</strong>递归遍历数组，并将所有元素与遍历到的子数组中的元素合并为一个新数组返回。</li></ul></blockquote><ul><li>我们首先来看下 JS 中数组的 flat 方法<blockquote><ul><li><code>arr.flat(层数)</code></li></ul></blockquote></li></ul><pre><code>var arr = [0, 1, 2, [3, [4, 5], 6], 7, 8, 9];var arr1 = arr.flat(); // 默认将数组展平1层console.log(arr1); //  [0, 1, 2, 3, [4, 5], 6, 7, 8, 9]&gt;var arr2 = arr.flat(2); // 将数组展平2层console.log(arr2); // [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]</code></pre><ul><li>手写<code>flat</code>方法源码<blockquote><ul><li>可以用for循环，也可以用forEach</li><li>由于嵌套了两个函数，所以在第一层一定要<strong>自己调用</strong>第二层的函数</li><li>注意为什么要n–、n++</li></ul></blockquote></li></ul><pre><code>function flat(arr, n) &#123;var newArr = [];//for循环遍历function fn(arr, n) &#123;  //for循环遍历数组的每一个元素  for (var i = 0; i &lt; arr.length; i++) &#123;    //如果是数组，则再次进入函数    if (Array.isArray(arr[i])) &#123;      //用n控制层数，一层代表进入一次本if语句      if (n &lt;= 0) &#123;        //层数用完,直接把该数组塞进新数组        newArr.push(arr[i]);      &#125; else &#123;        //有次数，每进来一次就展开一层，进一次减一次        n--; //n-1后会直接成为后面fn的实参        fn(arr[i], n);        n++; //为了不影响同一层级数组的展开次数      &#125;    &#125; else &#123;      //如果不是数组，则加入新数组      newArr.push(arr[i]);    &#125;  &#125;&#125;&gt;//forEach方法function fn(arr) &#123;  //for循环遍历数组的每一个元素  arr.forEach(function (el) &#123;    if (Array.isArray(el)) &#123;      //用n控制层数，一层代表进入一次本if语句      if (n &lt;= 0) &#123;        //层数用完,直接把该数组塞进新数组        newArr.push(el);      &#125; else &#123;        //有次数，每进来一次就展开一层，进一次减一次        n--; //n-1后会直接成为后面fn的实参        fn(el, n);        n++; //为了不影响同一层级数组的展开次数      &#125;    &#125; else &#123;      //如果不是数组，则加入新数组      newArr.push(el);    &#125;  &#125;);&#125;//自己调用fn函数fn(arr, n);return newArr;&#125;var arr = [0, 1, 2, [3, [4, 5], 6], 7, [8, [ [9], 10]]] ;console.log(flat(arr, 1));</code></pre><h3 id="二、将一个数组旋转-k-步"><a href="#二、将一个数组旋转-k-步" class="headerlink" title="二、将一个数组旋转 k 步"></a>二、将一个数组旋转 k 步</h3><blockquote><ul><li>将数组<code>[1, 3, 5, 7, 9, 11, 13]</code>旋转 K 步</li></ul></blockquote><ol><li><p>审题：理解题目的意思</p><blockquote><p>假设 k&#x3D;4 ，即旋转 4 步</p><ul><li>第一步，得到数组 <code>[ 13, 1, 3, 5, 7, 9, 11 ]</code></li><li>第二步，得到数组 <code>[ 11, 13, 1, 3, 5, 7, 9 ]</code></li><li>第三步，得到数组 <code>[ 9 , 11, 13, 1, 3, 5, 7]</code></li><li>第四步，得到数组 <code>[ 7, 9, 11, 13，1, 3, 5]</code><br>即数组旋转 4 步后，得到数组[ 7, 9, 11, 13，1, 3, 5]</li></ul></blockquote></li><li><p>解题思路</p></li></ol><ul><li>方法1：去尾插头<blockquote><ul><li>每旋转一步，就把最后一个元素<strong>删除</strong>并<strong>调到最前面</strong></li><li>删除最后一个元素：<code>.pop</code></li><li>把元素填充到最前面<code>.unshift</code></li></ul></blockquote></li></ul><pre class=" language-js"><code class="language-js">  <span class="token keyword">function</span> <span class="token function">rotate1</span><span class="token punctuation">(</span>arr<span class="token punctuation">,</span> k<span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//检验输入值</span><span class="token comment" spellcheck="true">//arr是否为数组</span>  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>Array<span class="token punctuation">.</span><span class="token function">isArray</span><span class="token punctuation">(</span>arr<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token keyword">return</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//i &lt; k 有隐式转换，所以不用检测k是否为数字</span><span class="token comment" spellcheck="true">//判断如果数组长度为0，或k不存在，则直接返回原数组</span>  <span class="token keyword">if</span> <span class="token punctuation">(</span>arr<span class="token punctuation">.</span>length <span class="token operator">==</span> <span class="token number">0</span> <span class="token operator">||</span> <span class="token operator">!</span>k<span class="token punctuation">)</span> <span class="token keyword">return</span> arr<span class="token punctuation">;</span><span class="token comment" spellcheck="true">//考虑k为负数、小数、k的长度大于数组长度的情况</span>  k <span class="token operator">=</span> Math<span class="token punctuation">.</span><span class="token function">abs</span><span class="token punctuation">(</span>k <span class="token operator">%</span> arr<span class="token punctuation">.</span>length <span class="token operator">></span><span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">//for循环</span>  <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">var</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> k<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>    <span class="token keyword">var</span> item <span class="token operator">=</span> arr<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    arr<span class="token punctuation">.</span><span class="token function">unshift</span><span class="token punctuation">(</span>item<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>  <span class="token keyword">return</span> arr<span class="token punctuation">;</span><span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span><span class="token keyword">var</span> arr <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">7</span><span class="token punctuation">,</span> <span class="token number">9</span><span class="token punctuation">,</span> <span class="token number">11</span><span class="token punctuation">,</span> <span class="token number">13</span><span class="token punctuation">]</span><span class="token punctuation">;</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token function">rotate1</span><span class="token punctuation">(</span>arr<span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><ul><li>方法2：拆分数组，然后拼接<blockquote><ul><li>要旋转k步，就把倒数k个元素组成数组，调到最前面</li><li>把最后k个元素组成数组：<code>.slice</code></li><li>把剩余元素组成一个数组：<code>.slice</code></li><li>数组拼接：<code>.concat</code></li></ul></blockquote></li></ul><pre class=" language-js"><code class="language-js">  <span class="token keyword">function</span> <span class="token function">rotate1</span><span class="token punctuation">(</span>arr<span class="token punctuation">,</span> k<span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//检验输入值</span><span class="token comment" spellcheck="true">//arr是否为数组</span>  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>Array<span class="token punctuation">.</span><span class="token function">isArray</span><span class="token punctuation">(</span>arr<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token keyword">return</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//i &lt; k 有隐式转换，所以不用检测k是否为数字</span><span class="token comment" spellcheck="true">//判断如果数组长度为0，或k不存在，则直接返回原数组</span>  <span class="token keyword">if</span> <span class="token punctuation">(</span>arr<span class="token punctuation">.</span>length <span class="token operator">==</span> <span class="token number">0</span> <span class="token operator">||</span> <span class="token operator">!</span>k<span class="token punctuation">)</span> <span class="token keyword">return</span> arr<span class="token punctuation">;</span><span class="token comment" spellcheck="true">//考虑k为负数、小数、k的长度大于数组长度的情况</span>  k <span class="token operator">=</span> Math<span class="token punctuation">.</span><span class="token function">abs</span><span class="token punctuation">(</span>k <span class="token operator">%</span> arr<span class="token punctuation">.</span>length <span class="token operator">></span><span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//取出倒数k个元素</span>  <span class="token keyword">var</span> item1 <span class="token operator">=</span> arr<span class="token punctuation">.</span><span class="token function">slice</span><span class="token punctuation">(</span><span class="token operator">-</span>k<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//取出剩余元素</span>  <span class="token keyword">var</span> item2 <span class="token operator">=</span> arr<span class="token punctuation">.</span><span class="token function">slice</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> arr<span class="token punctuation">.</span>length <span class="token operator">-</span> k<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//组成新数组</span>  <span class="token keyword">return</span> item1<span class="token punctuation">.</span><span class="token function">concat</span><span class="token punctuation">(</span>item2<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span><span class="token keyword">var</span> arr <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">7</span><span class="token punctuation">,</span> <span class="token number">9</span><span class="token punctuation">,</span> <span class="token number">11</span><span class="token punctuation">,</span> <span class="token number">13</span><span class="token punctuation">]</span><span class="token punctuation">;</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token function">rotate1</span><span class="token punctuation">(</span>arr<span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><ol start="3"><li>复杂度分析<blockquote><ul><li>方法1：时间复杂度是 O(n<sup>2</sup>) 、空间复杂度 O(1)， 为什么呢？<ul><li>因为<code>unshift</code>相当于一个for循环，每新增一个元素，其他所有元素的索引都会变化</li><li>而所定义的变量都是基本数据类型，输出单值；与输入量无关</li></ul></li></ul></blockquote></li></ol><blockquote><ul><li>方法2：时间复杂度是 O(1)、空间复杂度是 O(n)<ul><li>没有用到for循环，执行次数是可数的</li><li>定义两个数组，并且所需要的内存空间与输入量成正比</li></ul></li></ul></blockquote><ol start="4"><li>性能测试</li></ol><ul><li>测试得出结果的时长</li></ul><pre><code>// 输入量要比较大var arr = [];for (var i = 0; i &lt; 100 * 1000; i++) &#123;  arr.push(i);&#125;&gt;console.time(&quot;rotate&quot;);rotateArr(arr, 4000);console.timeEnd(&quot;rotate&quot;);</code></pre><ul><li>对比结果<blockquote><ul><li>随着数据规模量变大和旋转次数的增多，方法2的耗时变化不大，但方法1的耗时巨增。</li><li>在前端领域是重时间轻空间的，所以我们肯定首先思路 1</li></ul></blockquote></li></ul><h3 id="三、字符串中括号匹配是否正常"><a href="#三、字符串中括号匹配是否正常" class="headerlink" title="三、字符串中括号匹配是否正常"></a>三、字符串中括号匹配是否正常</h3><blockquote><p>判断一个字符串中的括号{} [] ()是否匹配正常，这是一个非常经典的面试题。</p></blockquote><ol><li><p>审题：理解题目的意思</p><blockquote><ul><li>字符串1：<code>a&#123;(b&#123;c[1,2,3]&#125;)&#125;</code>的匹配是正常的</li><li>字符串2：<code>a&#123;(b&#123;c[1,2,(3)&#125;]</code>的匹配是错的</li></ul></blockquote></li><li><p>栈</p><blockquote><p>这个问题本质是在考查什么呢 ？</p><ul><li>他是在考你理不理解<strong>栈</strong>这种数据结构，如果你会，那这个题就很容易做了。</li><li>所以我们先来了解下，栈这种数据结构，然后再回过头来看，这道题如何解。</li></ul></blockquote></li></ol><ul><li><strong>什么是栈</strong><blockquote><ul><li>栈是一种<strong>先进后出</strong>的数据结构，要弄明白什么是栈，我们先举一个生活中的例子来帮助大家理解</li><li>假如你现在有一个长长的圆筒，圆筒的一端是封闭的，另一端是开口，现在往圆筒底部放气球，那先放的是不是在圆筒的底部，后放的是不是在靠近圆筒的位置，如下图：<img src="栈.jpg"></li></ul></blockquote></li></ul><blockquote><ul><li>我们现在要从圆筒中取出气球，那我们是不是得<strong>先取离圆筒出口最近的</strong>一个，即取球时的顺序正好和放的时候的顺序是<strong>反</strong>的。</li><li>我们把圆筒比喻从栈，那<strong>放气球</strong>的过程叫入栈(压栈)，<strong>拿气球</strong>的过程叫<strong>出栈</strong>；</li><li>圆筒的底部称为<strong>栈底</strong>，圆筒出口的第一个气球位置叫<strong>栈顶。</strong></li></ul></blockquote><blockquote><p>总结：</p><ul><li>栈是什么：栈是一种<strong>先进后出</strong>的数据结构（逻辑层面）</li><li><strong>入栈</strong>：进栈时，先进去的在底部，后进去的在栈顶</li><li><strong>出栈</strong>：出栈时，先进去的后出，后进去的先出</li></ul></blockquote><ul><li>数组演示入栈和出栈<blockquote><ul><li>如果我们把<strong>数组想象成一个栈结构</strong>，最左边是栈底，最先放入元素，最右边是栈顶</li><li>入栈：相当于 <code>push</code> 元素时，从左往右放入元素</li><li>出栈：相当于 <code>pop</code> 删除数据，从最右边的第一个元素开始删</li></ul></blockquote></li></ul><pre><code>// 声明一个空数组，用来当成栈var arr = [];&gt;// 向数组中添加元素for (var i = 0; i &lt; 6; i++) &#123;  arr.push(i); // 入栈  console.log(arr);&#125;&gt;// 取出数组中的元素for (var i = 0; i &lt; 6; i++) &#123;  arr.pop(); // 出栈  console.log(arr);&#125;</code></pre><ul><li><strong>栈和数组的关系</strong><blockquote><ul><li><strong>本质上</strong>栈和数组完全不是一个层面上的东西，是不能拿 来做比较的</li><li>栈：是一种<strong>逻辑结构</strong>，是一种<strong>理论模型</strong>，他是抽象出来的一种结构。</li><li>数组：数组是一种<strong>物理结构</strong>，是实实在在<strong>存在的</strong>，可能用来操作的和存储数据的，同时还提供了相关的 API，让我们来操作数组。<blockquote><p>我们有很多种方式来实现栈这种结构来存储和取数据等，其中数组就可以实现栈这种结构来存储和操作数据。</p></blockquote></li></ul></blockquote></li></ul><ol start="3"><li>利用栈结构思想来解题<blockquote><ul><li>我们可以用 <code>for</code> 循环来遍历字符串中的每一个字符串</li><li>声明一个空数组</li><li>遇到左括号 <code>&#123; ( [</code>就压栈，存入数组中</li><li>遇到右括号<code>] ) &#125;</code> ，就判断栈顶是否与当前括号匹配，匹配就<strong>出栈</strong>，删除该括号，接着查看下一个符号<blockquote><p>因为右括号只能与离自己最近的左括号匹配，不会间隔其他括号，所以只需逐个排除</p></blockquote></li><li>最后判断栈中数据的 <code>length</code> 长度是否为 0，如果不为 <code>0</code>，则不匹配，为 0 就匹配成功<blockquote><p>一旦有一个括号不匹配，整个数组就是不匹配的</p></blockquote></li></ul></blockquote></li></ol><blockquote><img src="符号匹配.jpg"></blockquote><ol start="4"><li>代码实现</li></ol><ul><li>粗糙版</li></ul><pre class=" language-js"><code class="language-js"><span class="token keyword">function</span> <span class="token function">matchStr</span><span class="token punctuation">(</span>str<span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">//先转为字符串</span>  str <span class="token operator">=</span> str <span class="token operator">+</span> <span class="token string">""</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// 如果长度为0，则直接返回true</span>  <span class="token keyword">if</span> <span class="token punctuation">(</span>str<span class="token punctuation">.</span>length <span class="token operator">===</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">//定义新数组</span>  <span class="token keyword">var</span> arr <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">//for循环,遍历字符串的每个元素</span>  <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">var</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> str<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//遇到左括号就存入/压栈</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>      str<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token string">"&amp;#123;"</span> <span class="token operator">||</span>       str<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token string">"["</span> <span class="token operator">||</span>       str<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token string">"("</span><span class="token punctuation">)</span>       <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>arr<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>str<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>     <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>      str<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token string">"&amp;#125;"</span> <span class="token operator">||</span>       str<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token string">"]"</span> <span class="token operator">||</span>       str<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token string">")"</span><span class="token punctuation">)</span>       <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>        <span class="token keyword">var</span> arrTop <span class="token operator">=</span> arr<span class="token punctuation">[</span>arr<span class="token punctuation">.</span>length <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>          <span class="token punctuation">(</span>arrTop <span class="token operator">==</span> <span class="token string">"&amp;#123;"</span> <span class="token operator">&amp;&amp;</span> str<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token string">"&amp;#125;"</span><span class="token punctuation">)</span> <span class="token operator">||</span>          <span class="token punctuation">(</span>arrTop <span class="token operator">==</span> <span class="token string">"["</span> <span class="token operator">&amp;&amp;</span> str<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token string">"]"</span><span class="token punctuation">)</span> <span class="token operator">||</span>          <span class="token punctuation">(</span>arrTop <span class="token operator">==</span> <span class="token string">"("</span> <span class="token operator">&amp;&amp;</span> str<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token string">")"</span><span class="token punctuation">)</span>          <span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>arr<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>           <span class="token keyword">else</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>   <span class="token comment" spellcheck="true">// 如果不匹配，直接返回false，也就意示着整个字符串括号不匹配</span>   <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>              <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>      <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>  <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>  <span class="token keyword">return</span> arr<span class="token punctuation">.</span>length <span class="token operator">===</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span><span class="token operator">></span> <span class="token keyword">var</span> str <span class="token operator">=</span> <span class="token string">"a&amp;#123;(b&amp;#123;c[1,2,3]&amp;#125;)&amp;#125;"</span><span class="token punctuation">;</span> <span class="token keyword">var</span> str1 <span class="token operator">=</span> <span class="token string">"a&amp;#123;(b&amp;#123;c[1,2,(3)&amp;#125;]"</span><span class="token punctuation">;</span> console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token function">matchStr</span><span class="token punctuation">(</span>str<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//true</span> console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token function">matchStr</span><span class="token punctuation">(</span>str1<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//false</span></code></pre><ul><li>完善版</li></ul><pre><code>function matchStr1(str) &#123;//先转为字符串str = str + &quot;&quot;;// 如果长度为0，则直接返回trueif (str.length === 0) return true;//定义新数组var arr = [];// 定义一个变量用来放左括号的字符串var leftSymbols = &quot;&#123;[(&quot;;// 定义一个变量用来放右括号的字符串var rightSymbols = &quot;)]&#125;&quot;;//for循环,遍历字符串的每个元素for (var i = 0; i &lt; str.length; i++) &#123;  //遇到左括号就存入/压栈  if (leftSymbols.includes(str[i])) &#123;    arr.push(str[i]);  &#125; else if (rightSymbols.includes(str[i])) &#123;    var arrTop = arr[arr.length - 1];    if (isMatch(arrTop, str[i])) &#123;      arr.pop();    &#125; else &#123;      return false;    &#125;  &#125; &#125;// 如果arr长度为0，说明全部匹配成功，返回true，不匹配就返回falsereturn arr.length === 0;&#125;// 检测栈顶元素与当前右括号元素是否匹配function isMatch(left, right) &#123;  if (left === &quot;&#123;&quot; &amp;&amp; right === &quot;&#125;&quot;) return true;  if (left === &quot;[&quot; &amp;&amp; right === &quot;]&quot;) return true;  if (left === &quot;(&quot; &amp;&amp; right === &quot;)&quot;) return true;  return false;&#125;&gt;var str = &quot;&#123;[]&#125;&quot;;console.log(matchStr1(str)); //truevar str1 = &quot;a&#123;(b&#123;c[1,2,(3)&#125;]&quot;;console.log(matchStr1(str1)); //false</code></pre><ol start="5"><li>算法复杂度分析<blockquote><ul><li>时间复杂度 O(n)</li><li>整个过程就一次 <code>for</code> 循环，其内部的 <code>includes</code> 判断，其遍历次数不受输入量的影响，一直是 3 次</li></ul></blockquote></li></ol><blockquote><ul><li>空间复杂度 O(n)</li><li>主要是要用一个变量 <code>arr</code> 来存储<strong>入栈</strong>的数据，其大小<strong>不会完全</strong>受输入量的影响，但是输入量大，也是有一定影响的，所以定为 O(n)</li></ul></blockquote><h3 id="四、找出一个数组中和为-n-的两个数"><a href="#四、找出一个数组中和为-n-的两个数" class="headerlink" title="四、找出一个数组中和为 n 的两个数"></a>四、找出一个数组中和为 n 的两个数</h3><blockquote><p>给出一个有序的递增数组，找出数组中和为 n 的两个数的所有情况</p></blockquote><ol><li><p>审题</p><blockquote><p>如：</p><ul><li>找出数组<code>[1,3,5,7,10,13,15,20,22,25]</code>中和为 20 的两个数的所有情况</li><li>满足条件的有两组：5 和 15 是一组，7 和 13 是一组</li></ul></blockquote></li><li><p>解题思路</p><blockquote><ul><li>方法一：<strong>嵌套循环</strong>，找到一个数，然后和数组中的其它数都加一遍，如果和为 20，则就保存这两个数</li><li>方法二：利用<strong>单层 for 循环+双指针</strong>来实现。</li></ul></blockquote></li><li><p>方法一：两层 for 循环嵌套</p><blockquote><ul><li>最基础思想：每一个数与数组的每个元素相加遍历一遍</li><li>优化：<ul><li>每一次循环不用从第一个数开始加，而是从<code>i+1</code>开始；第一，按照题目要求不能和自己加；第二，在前一轮循环中外层的数已经和本次循环的数加过了</li><li>每一次内层循环的终点是上一次符合要求的下标</li></ul></li></ul></blockquote></li></ol><pre><code>function findNumber(arr, n) &#123;  var result = []; // 用来存入符合要求的元素  //检查数组  if (!Array.isArray(arr)) return result;  //检查数组  if (isNaN(n)) return result;  var len = arr.length - 1;  var maxLen = arr.length; // 记录上一次找到的元素的下标，确定下次查找的范围  for (var i = 0; i &lt; arr.length; i++) &#123;    for (var j = i + 1; j &lt; maxLen; j++) &#123;      var sum = arr[i] + arr[j];      if (sum == 20) &#123;        var obj = &#123;&#125;;        obj.a = arr[i];        obj.b = arr[j];        result.push(obj);        maxLen = j; // 因为是升序，所以下次查找的范围，肯定要小于第一次找到的元素下标        break; // 找到就退出      &#125;    &#125;  &#125;  return result;&#125;var arr = [1, 3, 5, 7, 10, 13, 15, 20, 22, 25];console.log(findNumber(arr, 20));</code></pre><ol start="4"><li>方法二：双指针</li></ol><ul><li><p>指针：</p><blockquote><ul><li>在汉语里，指钟表、仪器上面指示时间和度数的针</li><li>在程序中，指针就是一个<strong>变量</strong>，相当于保持了对某一数据的引用</li><li>比如，你定义了两个变量，分别保存数组中的两个不同的元素，就相当于定义了两个指针，分别用来指向数组中的不同元素。</li></ul></blockquote></li><li><p>双指针解题思路</p><blockquote><ul><li>我们以查找数组 arr &#x3D; <code>[1,3,5,7,10,13,15,20,22,25]</code>中和为 <code>20</code> 的两个数的所有情况为例来讲解</li><li>这是一个递增的数组 arr，我们定义两个变量<code>i=0</code> ;<code>j=数组长度-1</code>，从数组的头尾开始<ul><li>如果<code>arr[i] + arr[j] &gt; 20</code> 则 <code>j--</code></li><li>如果<code>arr[i] + arr[j] &lt; 20</code> 则<code>i++</code></li><li>如果<code>arr[i] + arr[j] = 20</code>则找到了一组满足要求的数，保存<code>arr[i]</code>和<code>arr[j]</code>，同时<code>i++</code>,<code>j--</code>，继续查找</li></ul></li><li>当 <code>i = j</code> 时，两者重合，就没有查找的必要，所以当<code>i &lt; j</code>时，一直查找</li></ul></blockquote></li></ul><pre><code>function findNumber(arr, n) &#123;  var result = []; // 用来存入符合要求的元素  //检查数组  if (!Array.isArray(arr)) return result;  //检查数组  if (isNaN(n)) return result;  len = arr.length - 1;  var i = 0;  var j = len;  while (i &lt; j) &#123;    if (arr[i] + arr[j] &gt; n) &#123;      j--;    &#125; else if (arr[i] + arr[j] &lt; n) &#123;      i++;    &#125; else &#123;      var obj = &#123;&#125;;      obj.a = arr[i];      obj.b = arr[j];      result.push(obj);      i++;      j--;    &#125;  &#125;  return result;&#125;var arr = [1, 3, 5, 7, 10, 13, 15, 20, 22, 25];console.log(findNumber(arr, 20));</code></pre><ol start="5"><li>算法复杂度分析</li></ol><ul><li>时间复杂度<blockquote><p>第一种方式：</p><ul><li>时间复杂度介于 O(n) 与 O(n<sup>2</sup>) 之间，如果查找的两数之后比较大，则每次要遍历到数且的最后面才能找到对应的数，如果查找的两数之后较小，则时间复杂度就低，因为很快就找到，并且后面的查找范围也会相应索小<br>第二种方式：</li><li>时间复杂度为 O(n)</li></ul></blockquote></li><li>空间复杂度<blockquote><ul><li>两者的空间复杂度都为 O(1) ，其内存占用，并不因为 arr 增大而成倍成大。</li></ul></blockquote></li></ul><h3 id="五、二分法找查数组的的某个元素"><a href="#五、二分法找查数组的的某个元素" class="headerlink" title="五、二分法找查数组的的某个元素"></a>五、二分法找查数组的的某个元素</h3><blockquote><p>我们要查找<strong>有序</strong>数组<code>[1,3,4,5,7,8,9,12,15,18,30,32,45]</code>中元素值为 15 的元素的下标。</p></blockquote><ol><li><p>审题：理解题目的意思</p><blockquote><ul><li>比如，要找到数组中元素为 5 的下标，则 5 的下标是 3</li><li>比如，要找到数组中元素为 9 的下标，则 9 的下标是 6</li></ul></blockquote></li><li><p>解题思路</p></li></ol><ul><li><p>思路一：for 循环遍历查找<br>最简单的方式，就是通过一次 for 循环的遍历，拿当前值与数组中的每个值一个一个做比较，如果全等，则就返回当前数组中元素的下标</p></li><li><p>思路二：二分查找</p><blockquote><ul><li>每一次都从剩下元素的中间位置开始查找。</li></ul></blockquote></li></ul><ol start="3"><li>二分查找思路和规律<blockquote><ul><li>我们每一次都要从<strong>中间位置</strong>查找，所以我们需要有办法得到中间位置元素</li><li>我们定义三个变量 <code>startIndex</code>、<code>endIndex</code>、<code>midIndex</code> 分别来记录当前的起始、结束、中间下标</li><li>刚开始 <code>startIndex</code> 和 <code>endIndex</code> 的值是知道的，<code>startIndex = 0</code>, <code>endIndex = arr.length - 1</code></li><li>通过公式 <code>midIndex = Math.floor((starIndex+endIndex/2))</code> ，得到<strong>中间元素下标</strong>，获取中间元素</li></ul></blockquote></li></ol><blockquote><ul><li>如果，<strong>当前值 &gt; 中间值</strong> ，则下一轮在中间值<strong>右边</strong>部分的中间查找，这时<ul><li>startIndex &#x3D; midIndex + 1;</li><li>endIndex值不变</li><li>midIndex &#x3D; Math.floor((startIndex+midIndex)&#x2F;2)</li></ul></li></ul></blockquote><blockquote><ul><li>如果，<strong>当前值 &lt; 中间值</strong> ，则下一轮在中间值的左边部分中间查找，这时<ul><li>startIndex 不变</li><li>endIndex &#x3D; midIndex - 1;</li><li>midIndex &#x3D; Math.floor((startIndex+midIndex)&#x2F;2)</li></ul></li></ul></blockquote><blockquote><ul><li>如果，<strong>当前值 &#x3D;&#x3D;&#x3D; 中间值</strong> ，则找到，返回midIndex ，即元素下标</li></ul></blockquote><blockquote><ul><li>如果，一轮找下来 ，当midIndex &#x3D;&#x3D;&#x3D; endIndex时还找不到元素，则说明当前值不在数组中。</li></ul></blockquote><ol start="4"><li>二分法 + while 循环代码实现<blockquote><ul><li>上面要重复循环做相同的事，但是我们<strong>并不能确定具体的循环次数</strong>，所以这里我们不用 for 循环，选用<strong>while 循环</strong>，只要<code>startIndex &lt;= endIndex</code>，就可以一直循环下</li></ul></blockquote></li></ol><pre><code>//如果没找到就返回-1function findIndex(arr, num) &#123;  //检测数组  if (!Array.isArray(arr)) return -1;  //检测数字  if (isNaN(num)) return -1;  var len = arr.length;  var startIndex = 0;  var endIndex = len - 1;  while (startIndex &lt;= endIndex) &#123;    var midIndex = ((startIndex + endIndex) / 2) &gt;&gt; 0;    var midvalue = arr[midIndex];    if (num &gt; midvalue) &#123;      startIndex = midIndex + 1;    &#125; else if (num &lt; midvalue) &#123;      endIndex = midIndex - 1;    &#125; else &#123;      return midIndex;    &#125;  &#125;  return -1;&#125;var arr = [1, 3, 4, 5, 7, 8, 9, 12, 15, 18, 30, 32, 45];console.log(findIndex(arr, 15));</code></pre><ol start="5"><li>二分 + 递归实现<blockquote><blockquote><p>这里还要考虑传过来的参数 <code>startIndex</code>和<code>endIndex</code>的类型处理，参考手写的slice方法来处理，（在面向对象原型和原型链那里），两者代码实现上一模一样</p></blockquote></blockquote></li></ol><pre><code>function findIndex(arr, num, startIndex, endIndex) &#123; //检测数组 if (!Array.isArray(arr)) return -1; //检测数字 if (isNaN(num)) return -1; //假如没有传入startIndex和endIndex if (startIndex == null) startIndex = 0; if (endIndex == null) endIndex = arr.length - 1; if (startIndex &gt; endIndex) return -1; var midIndex = ((startIndex + endIndex) / 2) &gt;&gt; 0; var midValue = arr[midIndex]; if (num &gt; midValue) &#123;   return findIndex(arr, num, midIndex + 1, endIndex); &#125; else if (num &lt; midValue) &#123;    return findIndex(arr, num, startIndex, midIndex - 1);  &#125; else &#123;    return midIndex;  &#125;&#125;var arr = [1, 3, 4, 5, 7, 8, 9, 12, 15, 18, 30, 32, 45];var result = findIndex(arr, 9, 0, 15);console.log(result);</code></pre><ol start="6"><li>算法复杂度分析<blockquote><ul><li>二分法+while 和 二分+递归 的时间复杂度都是<code>O(logn)</code>，空间复杂度都是<code>O(1)</code>级别</li><li>但循环要比递归在<strong>性能上</strong>更好，因为递归在内部会一直调用函数，所以会更消耗性能。</li><li>递归代码逻辑更清晰</li></ul></blockquote></li></ol><blockquote><blockquote><ul><li>只要是有序查找(有序数组)，则必定考虑必二分法 ！</li><li>只要是二分查找，时间复杂度必包含 <code>O(logn)</code></li></ul></blockquote></blockquote><h3 id="六、求字符串中连续最多的字符，以及次数"><a href="#六、求字符串中连续最多的字符，以及次数" class="headerlink" title="六、求字符串中连续最多的字符，以及次数"></a>六、求字符串中连续最多的字符，以及次数</h3><blockquote><ul><li>求以字符串<code>aaabbccddaaaaaffffdddd</code>中，连续出现最多的字符及字数 （以<strong>最先出现</strong>的为主）</li></ul></blockquote><ol><li><p>解题思路</p><blockquote><ul><li>方法一：for 循环嵌套 + 跳步思想来解决</li><li>方法二：for 循环 + 双指针</li></ul></blockquote></li><li><p>方法一： for 循环嵌套+跳步</p><blockquote><ul><li>count 用来<strong>临时存储</strong>连续相同字符出现的次数</li><li>定义变量 var obj &#x3D; {char:’’,len&#x3D;0} 用来保存连续出现最多的字符及次数</li></ul></blockquote></li></ol><blockquote><ul><li>用两层 for 循环来遍历元素，取出每一个元素，与原字符串做比较<ul><li>如果相等，则统计次数加 1，即 <code>count++</code></li><li>如果不相等，则把当前统计的次数与<code>obj.len</code>作比较</li><li>如果<code>obj.len &gt; count</code> ，则更新 <code>count</code> 的值，同时更新 <code>i 和 j</code> 的值，开始下一个字符的比较</li></ul></li></ul></blockquote><blockquote><blockquote><p>要特别注意</p></blockquote><ul><li>最后一次比较，如果<strong>最后的字符</strong>是多个连续相同字符，那比较结果相等时，也是要<strong>更新数据</strong>的</li><li>如果字符串中只有一个字符时，其第一次比较也就是最后一次比较，两都也是相等，也要更新数据</li></ul></blockquote><pre><code>function findContinuousChar(str) &#123;  // 不管传入的是啥，统一转成字符串  str = str + &quot;&quot;;  // obj用来存储连续出现字符最多的字符和次数  var obj = &#123;    char: &quot;&quot;,    len: 0,  &#125;;  // 如果字符串长度为0  if (str.length === 0) return obj;  // 临时记录当前连续字符的长度,最少出现1次  var count = 0;  for (var i = 0; i &lt; str.length; i++) &#123;    // 每一次循环，重置count的值为0    count = 0;    for (var j = i; j &lt; str.length; j++) &#123;      if (str[i] === str[j]) &#123;        count++;      &#125;      // 如果比较到数组的最后一个元素是相等的，也要更新数据      if (str[i] !== str[j] || j === str.length - 1) &#123;        if (obj.len &lt; count) &#123;          obj.char = str[i];          obj.len = count;        &#125;        // 写在外面，否则会进入死循环        if (j &lt; str.length - 1) &#123;          i = j - 1;        &#125;        break; // 不相等或最后一个元素，退出for循环      &#125;    &#125;  &#125;  return obj;&#125;var str = &quot;aaabbccddaaaaaffffdddd&quot;;var obj = findContinuousChar(str);console.log(obj);</code></pre><ol start="3"><li>方法二：for 循环 + 双指针<blockquote><ul><li>我们可以利用 for 循环来遍历字符串，把每个字符串取出来</li><li>定义变量 count 统计临时出现的次数</li><li>定义变量 obj &#x3D; {char:’’,len&#x3D;0} 来记录连续出现次数最多的字符及次数</li><li>我们定义两个变量，i 和 j，相当两个指针，最开始两个字符串指向同一个元素</li></ul></blockquote></li></ol><pre><code>function findContinuousChar(str) &#123;  // 用来存储出现连续次数最多的字符及次数  var obj = &#123;    char: &quot;&quot;,    len: 0,  &#125;;  str = str + &quot;&quot;; // 不管输入的是否是字符串，统一转成字符串  var len = str.length; // 字符串长度  if (len === 0) return obj;  // 定义两个变量，用来做为两个指针，指定元素  var i = 0;  var j = 0;  var count = 0; // 临时记录当前连续字符出现的次数  for (; i &lt; len; i++) &#123;    if (str[i] === str[j]) &#123;      count++;    &#125;    // 这里移动的是i，所以要拿i来做判断    if (str[i] !== str[j] || i === len - 1) &#123;      // 等于的情况没有处理，则不会进到这里面来      if (obj.len &lt; count) &#123;        obj.len = count;        obj.char = str[j]; // 这里是str[j],不要写成str[i]了      &#125;      count = 0; // 重置count的值      j = i; // 更新j的值，开始下一个字符统计      if (i &lt; len - 1) &#123;        i--; // 这里的i--不能放在上面的if中，否则某种情况下会死循环      &#125;    &#125;  &#125;  return obj;&#125;var str = &quot;12345566&quot;;var obj = findContinuousChar(str);console.log(obj);</code></pre><blockquote><blockquote><p>双指针常用于解决嵌套循环</p></blockquote></blockquote><ol start="4"><li>算法复杂度分析<blockquote><ul><li>方法一 和 方法二的时间复杂度都为 <code>O(n)</code>，空间复杂度也是 <code>O(1)</code></li></ul></blockquote></li></ol><h3 id="七、快速排序"><a href="#七、快速排序" class="headerlink" title="七、快速排序"></a>七、快速排序</h3><blockquote><p>采用快速排序的算法，将以下数组<code>[1,33,43,5,76,8,9,12,15,18,30,32,45]</code>按<strong>升序</strong>来进行排序</p></blockquote><ol><li><p>什么是快速排序？</p><blockquote><ul><li>快速排序是在每一轮排序时，会将数组的<strong>中间元素</strong>作为基准元素</li><li>并让其他比基准元素大的元素移到基准元素的一边</li><li>比基准元素小的元素移到基准元素的另一边</li></ul></blockquote></li><li><p>利用二分思想</p><blockquote><ul><li>首先找到中间元素</li><li>遍历数组中的每个元素，每个元素都与中间元素作比较<ul><li>所有小于中间元素的，放一个数组leftArr</li><li>所有除中间元素外等于中间元素的，放一个数组midArr</li><li>所以大于中间元素的，放一个数组rightArr</li></ul></li><li>然后将这几个数组从左到右拼接到一起</li><li>当 leftArr 和 rightArrr 长度为 1 时，不用再查找和判了<blockquote><p>如果找到midValue值为当前数组中的最大值或最小值时，本次排序相当于只排了一个元素，效率也是会很低。</p></blockquote></li></ul></blockquote></li><li><p>解题思路</p><blockquote><p>我们有三种方式来实现</p><ul><li>方法一：利用递归 + slice()方法，这种情况不会动原数组，返回的是一个新数组</li><li>方法二：利用递归 + splice() 方法，这种情况会动原数组，返回的是一个新数组</li><li>方法三：利用递归 + 双指针，这种情况不会动原数组，返回的也是原数组</li></ul></blockquote></li><li><p>方法一：利用递归 + slice()法</p><blockquote><ul><li>slice(start,end)查找元素，返回的是包含所查元素的新数组</li></ul></blockquote></li></ol><pre><code> function quickArr(arr) &#123;   //检查数组   if (!Array.isArray(arr)) return;   if (arr.length &lt;= 1) return arr;   //检查长度   var len = arr.length;   var midIndex = (len / 2) &gt;&gt; 0;   // var midValue=arr[midIndex];   var midValue = arr.slice(midIndex, midIndex + 1)[0]; //slice返回的是一个包含查询元素的数组   var leftArr = [];   var midArr = [];   var rightArr = [];   if (leftArr.length == 1) return leftArr;   if (rightArr.length == 1) return rightArr;   for (var i = 0; i &lt; len; i++) &#123;     if (i == midIndex) continue;     if (arr[i] &lt; midValue) &#123;       leftArr.push(arr[i]);     &#125;     if (arr[i] === midValue) &#123;       midArr.push(arr[i]);     &#125;     if (arr[i] &gt; midValue) &#123;       rightArr.push(arr[i]);     &#125;   &#125;   return quickArr(leftArr).concat(midArr, midValue, quickArr(rightArr)); &#125; var arr = [1, 33, 43, 5, 76, 8, 9, 12, 15, 18, 30, 32, 45]; var result = quickArr(arr); console.log(result);</code></pre><ol start="5"><li>方法二：利用递归 + splice()法<blockquote><ul><li>splice(index, deleteCount);删除元素，被删除的元素组成一个数组，被返回</li></ul></blockquote></li></ol><pre><code> function quickArr(arr) &#123;   //检查数组   if (!Array.isArray(arr)) return;   if (arr.length &lt;= 1) return arr;   //检查长度   var len = arr.length;   var midIndex = (len / 2) &gt;&gt; 0;   // var midValue=arr[midIndex];   var midValue = arr.splice(midIndex, 1)[0];    //slice返回的是一个包含查询元素的数组   var leftArr = [];   var midArr = [];   var rightArr = [];   if (leftArr.length == 1) return leftArr;   if (rightArr.length == 1) return rightArr;   for (var i = 0; i &lt; len; i++) &#123;     if (arr[i] &lt; midValue) &#123;       leftArr.push(arr[i]);     &#125;     if (arr[i] === midValue) &#123;       midArr.push(arr[i]);     &#125;     if (arr[i] &gt; midValue) &#123;       rightArr.push(arr[i]);     &#125;   &#125;   return quickArr(leftArr).concat(midArr, midValue, quickArr(rightArr)); &#125; var arr = [1, 33, 43, 5, 76, 8, 9, 12, 15, 18, 30, 32, 45]; var result = quickArr(arr); console.log(result);</code></pre><blockquote><blockquote><p>方法1和方法2的区别：</p><ul><li>语法不一样</li><li>splice每次都会删除中间元素，所以在进行for循环时，不需要再像slice一样，循环到中间元素就跳过</li><li>splice会改变原数组，slice不会</li></ul></blockquote></blockquote><ol start="6"><li>方法三：利用递归+双指针<blockquote><ul><li>选定当前组组中的<strong>第一个元素</strong>作为基准元素（pivot）</li><li>定义两个变量 <code>left</code> 和 <code>right</code>，分别指向数组的第一个元素和最后一个元素</li><li>接下来进行第一次循环<ul><li><code>right</code> 指针开始(一定要先进行right)，让指针所指向的元素与基准元素比较。如果<strong>大于或等于 pivot</strong>，则指针向左移动;如果小于 pivot，则 right 指针停止移动，切换到 left 指针</li><li>left 指针开始，让指针所指向的元素与基准元素做比较，如果<strong>小于等于 pivot</strong>，则指针向右移动;如果大于 pivot，则 left 指针停止移动。</li></ul></li><li>当 left 与 right 指针<strong>都停止</strong>后，让 left 指针和 right 指针所指向的元素进行<strong>交换</strong>。</li><li>循环条件：left !&#x3D;&#x3D; right 时才循环，即 left &gt;&#x3D; right，则停止循环</li></ul></blockquote></li></ol><blockquote><p>接下来重第一次循环的动作，开始第二次循环。</p><ul><li>一直到 left 与 right 指针<strong>重合时</strong>（相等时），则让 <code>left</code> 指针指向的元素与 <code>pivot</code> 中元素交换。</li><li>接下来 left 左边的元素再循环一遍，left &#x3D; stratIndex,right &#x3D; left-1;</li><li>left 右边元素再循环一遍,left &#x3D; left+1 right &#x3D; endIndex</li><li>递归出口：startIndex&gt;&#x3D;endIndex</li></ul></blockquote><pre><code>function quickArr(arr, startIndex, endIndex) &#123; if (startIndex == null) startIndex = 0; if (endIndex == null) endIndex = arr.length - 1; //递归的出口 if (startIndex &gt;= endIndex) return; var left = startIndex; var right = endIndex; var pivot = arr[startIndex]; //不相等时 while (left !== right) &#123;   while (arr[right] &gt;= pivot &amp;&amp; left &lt; right) &#123;     right--;     &#125;     while (arr[left] &lt;= pivot &amp;&amp; left &lt; right) &#123;       left++;     &#125;     //left和right都不动时     if (left &lt; right) &#123;       var tempt = arr[left];       arr[left] = arr[right];       arr[right] = tempt;     &#125;   &#125;   //相等时   arr[startIndex] = arr[left];   arr[left] = pivot;   //左边元素排序   quickArr(arr, startIndex, left - 1);   //右边元素排序   quickArr(arr, left + 1, endIndex); &#125; var arr = [1, 33, 5, 43, 5, 76, 76, 8, 9, 12, 15, 18, 30, 32, 45]; quickArr(arr); console.log(arr);</code></pre><blockquote><ul><li>另一种写法：</li></ul></blockquote><pre><code>function quickSort(arr, startIndex, endIndex) &#123;  if (startIndex &gt;= endIndex) &#123;    return;  &#125;&gt;  // 第一轮排序，得到基准元素  var pivotIndex = partition(arr, startIndex, endIndex);  // 根据基准元素，排序左边  quickSort(arr, startIndex, pivotIndex - 1);  // 根据基准元素，排序右边  quickSort(arr, pivotIndex + 1, endIndex);&#125;&gt;  function partition(arr, startIndex, endIndex) &#123;  // 获取基准元素  var pivot = arr[startIndex];  var left = startIndex;  var right = endIndex;&gt;  // 不相等时  while (left != right) &#123;    // 右指针向左移动    while (left &lt; right &amp;&amp; arr[right] &gt; pivot) &#123;      right--;    &#125;    // 左指针向右移    while (left &lt; right &amp;&amp; arr[left] &lt;= pivot) &#123;      left++;    &#125;    // 交换两者的位置    if (left &lt; right) &#123;      var temp = arr[left];      arr[left] = arr[right];      arr[right] = temp;    &#125;  &#125;&gt;  // 相等时  arr[startIndex] = arr[left];  arr[left] = pivot;&gt;  return left;&#125;&gt;var arr = [10, 33, 43, 5, 76, 8, 9, 12, 15, 18, 30, 32, 45];quickSort(arr, 0, 12);</code></pre><ol start="7"><li>算法复杂度分析<blockquote><ul><li>方法一和方法二的时间复杂度是 <code>O(nlogn)</code> ，外层 for 循环是 <code>O(n)</code> ，for 循环里面是二分 <code>O(logn)</code></li><li>方法一和方法二的空间复杂度是 <code>O(n)</code>，它所定义的变量是可数的</li><li>方法三的时间复杂度是 <code>O(nlogn)</code>，但比方法一二所用时间更短，因为<code>concat</code>比较消耗性能，空间复杂度是 <code>O(n)</code>，但它所定义的变量是不可数的，因为它不断要进行递归</li></ul></blockquote></li></ol>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JS核心知识点（六）</title>
      <link href="/2023/12/04/JS%E6%A0%B8%E5%BF%83%E7%9F%A5%E8%AF%86%E7%82%B9%EF%BC%88%E5%85%AD%EF%BC%89/"/>
      <url>/2023/12/04/JS%E6%A0%B8%E5%BF%83%E7%9F%A5%E8%AF%86%E7%82%B9%EF%BC%88%E5%85%AD%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<span id="more"></span><blockquote><p>本章节我们来学习数组相关的方法，操作数组的方法非常多，我们先学习 <code>ES5</code> 中的一些方法，等学习到 <code>ES6</code> 之后，再学习 ES6 中新增的相关方法。</p></blockquote><h3 id="一、数组的头尾操作"><a href="#一、数组的头尾操作" class="headerlink" title="一、数组的头尾操作"></a>一、数组的头尾操作</h3><blockquote><ul><li>首先我们来学习，如何在数组的头部或尾部添加元素或删除元素的操作<table><thead><tr><th>实例方法</th><th>描述</th><th>是否更改原数组</th></tr></thead><tbody><tr><td>push()</td><td>将一个或多个元素添加到数组的末尾，并返回该数组的新长度</td><td>是</td></tr><tr><td>pop()</td><td>从数组中删除最后一个元素，并返回被删除元素的值</td><td>是</td></tr><tr><td>unshift()</td><td>将一个或多个元素添加到数组的头部，并返回该数组的新长度</td><td>是</td></tr><tr><td>shift()</td><td>从数组中删除第一个元素，并返回该元素的值</td><td>是</td></tr></tbody></table></li></ul></blockquote><ol><li>push()方法<blockquote><ul><li>向数组的末尾添加<strong>一个或多个</strong>元素，每个元素之间用<code>,</code>逗号隔开</li><li>并<strong>返回</strong>数组的<strong>新长度</strong></li><li>括号内是要新增的元素</li></ul></blockquote></li></ol><pre><code>var arr = [1, 2, 3];&gt;// 向数组的尾部添加元素4arr.push(4);// 向数组的尾部添加5，&#39;我&#39; ,同时用变量len接受数据的新长度var len = arr.push(5, &quot;我&quot;);&gt;console.log(arr);console.log(&quot;数组的长度：&quot; + len); // 数组的长度：6</code></pre><blockquote><blockquote><p>push 方法根据 length 属性来决定从哪里开始插入给定的值</p></blockquote></blockquote><ol start="2"><li>pop() 方法<blockquote><ul><li>从数组中<strong>删除最后一个</strong>元素，并<strong>返回</strong>该元素（被删除元素）的<strong>值</strong></li><li>当数组为<strong>空</strong>时，返回值为<code>undefined</code></li></ul></blockquote></li></ol><pre><code>var arr = [12, 23, 56, 11];var item = arr.pop();&gt;console.log(arr); // 输出删除最后一项后的值 [12, 23, 56]console.log(item); // 返回被删除元素的值 11</code></pre><blockquote><blockquote><p>pop 方法根据 length 属性来确定最后一个元素的位置</p></blockquote></blockquote><ol start="3"><li>unshift() 方法<blockquote><ul><li>一个或多个元素<strong>添加</strong>到数组的<strong>开头</strong>，每个元素之间用<code>,</code>逗号隔开</li><li>并<strong>返回</strong>该数组的<strong>新长度</strong></li></ul></blockquote></li></ol><pre><code>var arr = [12, 23, 56, 11];arr.unshift(66);var len = arr.unshift(0);console.log(len); // 6console.log(arr); // [0, 66, 12, 23, 56, 11]</code></pre><ol start="4"><li>shift() 方法<blockquote><ul><li>从数组中<strong>删除第一个</strong>元素，并返回该元素的值</li><li>当数组为<strong>空</strong>时，返回值为<code>undefined</code></li></ul></blockquote></li></ol><pre><code>var arr = [12, 23, 56, 11];var item = arr.shift(); // 删除数组中下标为0的项&gt;console.log(item); // 返回被删除的项 12console.log(arr); // [23, 56, 11]</code></pre><ol start="5"><li>案例：筛选数组中所有大于等于 10 的元素</li></ol><pre><code>var arr = [1, 3, 68, 33, 5, 9, 34, 55];function filter(arr) &#123;  var arr2 = [];  for (var i = 0; i &lt;= arr.length; i++) &#123;    if (arr[i] &gt;= 10) &#123;      arr2.push(arr[i]);    &#125;  &#125;  return arr2;&#125;console.log(filter(arr));</code></pre><h3 id="二、数组中元素的（增、删、改、查）"><a href="#二、数组中元素的（增、删、改、查）" class="headerlink" title="二、数组中元素的（增、删、改、查）"></a>二、数组中元素的（增、删、改、查）</h3><blockquote><p>如果我们要对数组中非头尾的元素，做相关的增、删、改、查操作，就需要用到下面的这些方法</p><table><thead><tr><th>实例方法</th><th>描述</th><th>是否更改原数组</th></tr></thead><tbody><tr><td>slice()</td><td>（查询）：提取原数组的一部分并返回一个新数组</td><td>否</td></tr><tr><td>splice()</td><td>（新增）：在指定位置插入一项或多项新元素;（删除）：在指定位置删除指定项;（更新）：在指定位置删除指定项，同时在此处添加一项或多项</td><td>是</td></tr></tbody></table></blockquote><ol><li>slice()方法<blockquote><ul><li>查询原数组中的一部分元素，然后将查询到的元素<strong>复制</strong>到一个新数组，并将新数组返回</li><li>slice() 方法<strong>不会更改</strong>原数组</li><li>slice() 中返回的元素是从原数组中<strong>浅拷贝</strong>过来的。</li></ul></blockquote></li></ol><p><strong>浅拷贝：</strong></p><blockquote><ul><li>数组中的值如果是<strong>基本类型</strong>，直接把值拷贝一份过来，修改拷贝后的数组<strong>不会影响</strong>原数组</li><li>如果是<strong>引用类型</strong>，拷贝的是引用类型的<strong>地址</strong>，当修改 slice()返回数组中的引用类型值时，<strong>原数组也会变</strong></li></ul></blockquote><p><strong>语法：</strong></p><blockquote><p><code>slice(start, end);</code></p><ul><li><code>start</code>和<code>end</code>表示查找的起始与结束索引，其值<strong>可正可负</strong>，<strong>正索引</strong>是从左往右数，下标从 <code>0</code> 开始，<strong>负索引</strong>是从右往左数，下标从<code>-1</code> 开始</li><li>不论正负索引，元素查找方向，都是从起始索引<strong>从左往右</strong>查找，从右到左只能得到空数组<code>[]</code></li><li>查找的元素，不包含结束索引的值</li><li>如果只有一个参数，表示起始位置，从这个位置提取往后<strong>所有元素</strong>。</li><li><code>start</code> 的默认值可以理解为 <code>0</code>，<code>end</code> 的默认值可以理解为<strong>数组长度-1(索引的最大值)</strong></li><li><code>arr.slice()</code> 相当于把整个数组浅拷贝一份</li><li>特殊情况：当起始索引和结束索引为同一值时，结果为<code>[]</code></li></ul></blockquote><pre><code>var arr = [1, 2, 3, 4, 5, 6];// 两个参数都是正数console.log(arr.slice(1, 3)); //2,3console.log(arr.slice(3, 2)); //[]&gt;// 两个参数都是负数console.log(arr.slice(-1, -3)); //[]console.log(arr.slice(-3, -1)); //4,5&gt;// 参数一正一负console.log(arr.slice(1, -2)); //2,3,4console.log(arr.slice(-2, 4)); //[]&gt;// 只有一个参数console.log(arr.slice(1)); //2,3,4,5,6console.log(arr.slice(-4)); //3,4,5,6&gt;// 注意：console.log(arr.slice(3, -1)); //4,5console.log(arr.slice(-2, 4)); //[]console.log(arr.slice(3, -3)); //[]</code></pre><ol start="2"><li>splice()方法<blockquote><ul><li><code>splice()</code>方法，可以实现对数组中元素的 删除，添加，更新（删除并替换）操作</li><li>被删除的元素组成一个数组，被返回，如果没有删除元素，则返回空数组</li><li>语法：<code>splice(index, deleteCount, item1, item2, itemN);</code></li><li><code>splice</code> 删除元素，包含 index 索引位置元素</li><li><code>index</code> 表索引，索引<strong>可正可负</strong>，<strong>正</strong>表示从左往右数，下标从 <code>0</code> 开始，<strong>负</strong>表示从右往左数，下标从<code>-1</code> 开始<ul><li>如果<strong>超过</strong>数组长度，表示从数组尾部开始添加内容</li><li>如果是<strong>负值</strong>，表示数组尾部开始的第几位（尾部第一位表示<code>-1</code>）</li></ul></li><li><code>deleteCount</code> 表示删除长度，<strong>0 和负数</strong>不删除，如果<strong>不写</strong>，表示 index 处删除往后<strong>所有元素</strong>（包括 index 处元素）</li><li><code>item1,item2...</code>可选，表示要添加进数组的元素，从 <code>index</code>位置开始</li></ul></blockquote></li></ol><ul><li>添加元素<blockquote><ul><li><code>deleteCount=0</code></li></ul></blockquote></li></ul><pre><code>var arr = [1, 2, 3, 4, 5];// 从下标1位置前面插入两个数var arr1 = arr.splice(1, 0, &quot;A&quot;, &quot;B&quot;);console.log(arr); // [1, &#39;A&#39;, &#39;B&#39;, 2, 3, 4, 5]console.log(arr1); // []</code></pre><ul><li>删除元素<blockquote><ul><li>没有新增元素</li></ul></blockquote></li></ul><pre><code>var arr = [1, 2, 3, 4, 5];var arr1 = arr.splice(1, 2);console.log(arr); // [1, 4, 5]console.log(arr1); // [2, 3]&gt;var arr = [1, 2, 3, 4, 5];var arr1 = arr.splice(2); // 删除索引2后所有元素，包括索引2位置上元素console.log(arr); // [1, 2]console.log(arr1); // [3, 4, 5]</code></pre><ul><li>更新（删除并替换）元素</li></ul><pre><code>var arr = [1, 2, 3, 4, 5];// 从下标1的位置，删除2个元素（包括下标1的元素），然后再加两个元素var arr1 = arr.splice(1, 2, &quot;A&quot;, &quot;B&quot;);console.log(arr); // [1, &#39;A&#39;, &#39;B&#39;, 4, 5]console.log(arr1); // [2, 3]</code></pre><ul><li>index 下标为<strong>负数</strong>时<blockquote><ul><li>index 为负数，表示从后往前找元素的位置，从后往前，元素下标从<code>-1</code>开始</li></ul></blockquote></li></ul><pre><code>var arr = [1, 2, 3, 4, 5];// 从倒数第三个元素开始，删除 2个元素（包括倒数第三个）var arr1 = arr.splice(-3, 2);console.log(arr); // [1, 2, 5]console.log(arr1); // [3,4]</code></pre><h3 id="三、数组与字符串相互转换"><a href="#三、数组与字符串相互转换" class="headerlink" title="三、数组与字符串相互转换"></a>三、数组与字符串相互转换</h3><table><thead><tr><th>实例方法</th><th>描述</th><th>是否更改原数组</th></tr></thead><tbody><tr><td>join()</td><td>将一个数组的所有元素以特定的某种字符连接成一个字符串，并返回这个字符串</td><td>不会</td></tr><tr><td>toString()</td><td>将数组转换为字符串，然后返回该 字符串</td><td>不会</td></tr></tbody></table><blockquote><ul><li>以下方法为字符串的实例方法</li></ul></blockquote><table><thead><tr><th>实例方法</th><th>描述</th></tr></thead><tbody><tr><td>split()</td><td>根据指定的分隔符将一个<strong>字符串</strong>分割成一个字符串<strong>数组</strong></td></tr><tr><td>charAt()</td><td>从一个字符串中返回指定的字符<code>str.charAt(index)</code></td></tr></tbody></table><ol><li>join()方法<blockquote><ul><li>将一个<strong>数组</strong>的所有元素以<strong>特定</strong>的<strong>某种字符</strong>连接成一个字符串，并<strong>返回</strong>这个字符串</li><li>如果<strong>不指定</strong>连接字符，则默认以<code>,</code>逗号来分隔连接</li><li>这个方法<strong>不会改变</strong>原数组，会生成一个新的字符串</li></ul></blockquote></li></ol><pre><code>var arr = [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;];var str = arr.join();console.log(str); // a,b,c,dconsole.log(arr); // [&#39;a&#39;,&#39;b&#39;,&#39;c&#39;,&#39;d&#39;]&gt;var str2 = arr.join(&quot;&quot;);console.log(str2); // abcdvar str3 = arr.join(&quot;**&quot;);console.log(str3); //  a**b**c**d</code></pre><ol start="2"><li>toString()方法<blockquote><ul><li>将数组转成以<code>,</code>逗号分隔的字符串，同时返回该字符串</li></ul></blockquote></li></ol><pre class=" language-js"><code class="language-js"><span class="token keyword">var</span> arr <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token keyword">var</span> str <span class="token operator">=</span> arr<span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>str<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//1,2,3</span></code></pre><blockquote><ul><li><code>toString</code>方法在内部调用<code>join()</code>方法拼接数组中的元素并返回一个字符串，其中包含用逗号分隔的每个数组元素</li></ul></blockquote><pre><code>var arr = [1, 2, 3, 4];  var str = arr.toString();console.log(str);&gt;// 修改原型上join方法Array.prototype.join = function () &#123; var str = &quot;&quot;;for (var i = 0; i &lt; this.length; i++) &#123;  str += this[i] + &quot;*&quot;;&#125;return str;&#125;;// 也可以只修改当前实例的join方法 arr.join=function()&#123;  &#125;console.log(arr.toString()); //1*2*3*4*</code></pre><ol start="3"><li>split()方法 字符串操作方法<blockquote><ul><li>数组的<code>join()</code>方法可以使数组转为字符串</li><li>字符串的<code>split()</code>方法可以使字符串转为数组<img src="./src/字符串和数组相互转换.png"></li></ul></blockquote></li></ol><blockquote><ul><li><code>split()</code>可以使字符串以某种分隔符进行分隔，分隔后的字符串组成一个数组返回</li><li>分隔符为<strong>空字符串</strong>，则将原字符串中每个字符的数组形式返回</li></ul></blockquote><pre><code>var str = &quot;a*b*c*d&quot;;var arr1 = str.split(&quot;&quot;);var arr2 = str.split(&quot;*&quot;);console.log(arr1); // [&#39;a&#39;, &#39;*&#39;, &#39;b&#39;, &#39;*&#39;, &#39;c&#39;, &#39;*&#39;, &#39;d&#39;]console.log(arr2); // [&#39;a&#39;, &#39;b&#39;, &#39;c&#39;, &#39;d&#39;]&gt;&quot;a-b-c-d-e-f-g-h&quot;.split(&quot;&quot;); // [&#39;a&#39;, &#39;-&#39;, &#39;b&#39;, &#39;-&#39;, &#39;c&#39;, &#39;-&#39;, &#39;d&#39;, &#39;-&#39;, &#39;e&#39;, &#39;-&#39;, &#39;f&#39;, &#39;-&#39;, &#39;g&#39;, &#39;-&#39;, &#39;h&#39;]&quot;a-b-c-d-e-f-g-h&quot;.split(&quot;-&quot;); // [&#39;a&#39;, &#39;b&#39;, &#39;c&#39;, &#39;d&#39;, &#39;e&#39;, &#39;f&#39;, &#39;g&#39;, &#39;h&#39;]</code></pre><blockquote><ul><li>回顾之前讲的<code>rgb(2,33,55)</code>颜色的分隔</li></ul></blockquote><pre><code>var rgb = &quot;rgb(2,33,55)&quot;;//只要不是[0-9]之间的单个或多个数字，其它字符都可以做为分隔符来分隔字符串var rgbArr = rgb.split(/[^\d]+/);console.log(rgbArr);</code></pre><blockquote><ul><li><code>\d</code> 表示 0-9之间的任意数字 </li><li><code>[^\d]</code> 排除0-9之间的任意数字  </li><li><code>+</code>表示前面的字符可以出现<strong>任意次</strong></li></ul></blockquote><pre><code>var url =  &quot;https://www.icodingedu.com/goods/show/42?targetId=71&amp;preview=0&quot;;var obj = &#123;&#125;;var str = url.split(&quot;?&quot;)[1].split(&quot;&amp;&quot;);//url.split(&quot;?&quot;)[1] = targetId=71&amp;preview=0//url.split(&quot;?&quot;)[1].split(&quot;&amp;&quot;) = [&#39;targetId=71&#39;, &#39;preview=0&#39;]console.log(str); //  [&#39;targetId=71&#39;, &#39;preview=0&#39;]for (let i = 0; i &lt; str.length; i++) &#123;  var param = str[i].split(&quot;=&quot;);  obj[param[0]] = param[1];&#125;//i=0时,param=str[0].split(&quot;=&quot;)//即：param=targetId=71.split(&quot;=&quot;) =[&#39;targetId&#39;,&#39;71&#39;]//obj[targetId]=71console.log(obj); // &#123;targetId: &#39;71&#39;, preview: &#39;0&#39;&#125;</code></pre><ol start="5"><li>charAt()方法 字符串操作方法<blockquote><p><code>str.charAt(index);</code></p><ul><li><code>charAt()</code> 方法从一个字符串中返回指定的字符</li><li>一个介于 0 和字符串长度减 1 之间的整数</li><li>如果没有提供索引，charAt() 将使用 0</li><li>字符串中的字符从左向右索引，第一个字符的索引值为 <code>0</code>，最后一个字符（假设该字符位于字符串 str 中）的索引值为 <code>str.length - 1</code></li></ul></blockquote></li></ol><pre><code>var str = &quot;我爱你!&quot;;console.log(str.charAt(0)); // 我console.log(str.charAt(1)); // 爱console.log(str.charAt(2)); // 你</code></pre><ol start="6"><li>字符串与数组相似点<blockquote><ul><li>字符串也可以像数组一样，使用下标进行访问</li><li>也可以用 charAt()方法来访问，charAt()</li><li>字符串可以像数组一样，利用 for 循环来遍历</li><li>没有负索引</li></ul></blockquote></li></ol><pre><code>var str = &quot;我爱你!&quot;;console.log(str[0]);// 我console.log(str[1]);// 爱console.log(str[2]);// 你console.log(str[-1]); //undefinedconsole.log(str[4]);//undefinedvar str = &quot;我爱你!&quot;;for (var i = 0; i &lt; str.length; i++) &#123;  console.log(str[i]);&#125;</code></pre><blockquote><blockquote><p>但字符串并不是类数组</p><ul><li>尽管它具有length属性、能通过下标访问，但它的数据类型不是对象，它是基本数据类型</li></ul></blockquote></blockquote><h3 id="四、判断数组中元素方法"><a href="#四、判断数组中元素方法" class="headerlink" title="四、判断数组中元素方法"></a>四、判断数组中元素方法</h3><table><thead><tr><th>实例方法</th><th>描述</th><th>是否更改原数组</th></tr></thead><tbody><tr><td>indexOf()</td><td>返回在数组中可以找到给定元素的第一个索引，如果不存在，则返回 -1</td><td>否</td></tr><tr><td>lastIndexOf()</td><td>返回指定元素在数组中的最后一个的索引，如果不存在则返回-1;从指定位置开始<strong>逆向</strong>查找（即从后往前找）</td><td>否</td></tr><tr><td>includes()</td><td>用来判断一个数组是否包含一个指定的值，根据情况，如果包含则返回 true，否则返回 false</td><td>否</td></tr></tbody></table><blockquote><p>三者共同点：</p><ul><li>都是全等，不适合引用数据类型</li><li>都包含起始位置</li></ul></blockquote><ol><li>indexOf() 方法<blockquote><ul><li>返回在数组中可以找到给定元素的<strong>第一个索引</strong>，如果不存在，则返回 <code>-1</code>。</li><li>查找时，使用的是（<strong>全等运算</strong><code>===</code>)，所以不适合引用数据类型</li><li>语法：<code>indexOf(searchElement, fromIndex);</code><ul><li>searchElement 要查找的元素</li><li>fromIndex 开始查找的位置（索引）</li></ul></li><li><code>fromindex</code>可正可负，正从0开始，负从-1开始；并且包含起始位置元素</li><li>如果<code>fromindex</code>不写，则默认从下标为0的元素开始查找</li><li>查找方向只能是<strong>从左往右</strong>，而且不会回头</li><li><code>fromindex</code>为负时，返回的索引为正索引</li></ul></blockquote></li></ol><pre><code>var arr = [2, 9, 1, 1, 5, 2, 4, 9];//不写index，默认从0开始console.log(arr.indexOf(2)); //0//index可以为正，并包含起始元素console.log(arr.indexOf(9, 1)); //1//index可以为负console.log(arr.indexOf(9, -arr.length)); //1//找不到的时候，返回-1console.log(arr.indexOf(&quot;a&quot;)); //-1//只能从左往右，不会回头console.log(arr.indexOf(1, 4)); //-1console.log(arr.indexOf(1, -3)); //-1</code></pre><blockquote><blockquote><p>特别注意，用负索引时，一定记得查找方向是从左往右，易出错</p></blockquote></blockquote><ol start="2"><li>lastIndexOf()<blockquote><ul><li>返回指定元素在数组中的<strong>最后一个</strong>的索引，如果不存在则返回 -1</li><li>内容判断使用的 <strong>全等(&#x3D;&#x3D;&#x3D;)</strong></li><li>从指定位置开始<strong>逆向查找</strong>（即从后往前找）</li><li>语法：<code>lastIndexOf(searchElement, fromIndex);</code></li><li><code>fromIndex</code>查找的的开始下标，默认值为 <code>arr.length-1</code>,（即从后向前查找整个数组）</li><li>如果 <code>fromIndex</code> 为负值，从指定位置向前查找</li><li>如果 <code>fromIndex</code> <strong>负值的绝对值</strong>大于数组长度，则数组不会被查找，返回-1</li><li>如果 <code>fromIndex</code> <strong>正数的绝对值</strong>大于数组长度，则整个数组都会被查找</li><li><code>fromindex</code>为负时，返回的索引为正索引<blockquote><p>注意：方向是<strong>从右往左</strong>查找，但找的是数组<strong>从左往右</strong>数该元素最后一个的索引，也就是从右往左遇到的第一个</p></blockquote></li></ul></blockquote></li></ol><pre><code>var arr = [1, 3, 4, 5, 3, 8, 1];//index不写console.log(arr.lastIndexOf(3)); //4//index为正值console.log(arr.lastIndexOf(1, 1)); //0//index为负值console.log(arr.lastIndexOf(1, -2)); //0//index超过数组长度console.log(arr.lastIndexOf(1, 8)); //6console.log(arr.lastIndexOf(1, -8)); //-1</code></pre><ol start="3"><li>includes() 方法<blockquote><ul><li>用来判断一个数组<strong>是否包含</strong>一个指定的值</li><li>根据情况，如果包含则返回 <code>true</code>，否则返回 <code>false</code></li><li>查找时，使用的是(<strong>全等</strong>运算&#x3D;&#x3D;&#x3D;)</li><li>语法：<code>includes(searchElement, fromIndex);</code></li><li>查找方向：从左往右</li><li>如果fromIndex超过<code>&gt;=</code>数组长度，直接返回 false</li><li>如果<code>fromindex</code>不写，则默认从下标为<code>0</code>的元素开始查找</li><li>包含起始位置的元素</li></ul></blockquote></li></ol><pre><code>var arr = [1, 3, 4, 5, 3, 8, 1];console.log(arr.includes(1)); //trueconsole.log(arr.includes(1, 3)); //trueconsole.log(arr.includes(1, 8)); //falseconsole.log(arr.includes(6)); //falseconsole.log(arr.includes(3, -1)); //falseconsole.log(arr.includes(4, -5)); //true</code></pre><ol start="4"><li>应用案例：数组去重<blockquote><ul><li>创建一个空数组，如果数组内的元素和新数组的元素不一样，则把该元素放入新数组</li></ul></blockquote></li></ol><pre><code>function unique(arr) &#123;  // 如果传入的类型不是数组，啥也不做  if (!Array.isArray(arr)) &#123;    return;  &#125;  var result = [];  for (var i = 0; i &lt; arr.length; i++) &#123;    // if(!~result.indexOf(arr[i]))    if (!result.includes(arr[i])) &#123;      result.push(arr[i]);    &#125;  &#125;  return result;&#125;var arr = [1,1, 2,2,&quot;true&quot;,&quot;true&quot;,true,true,undefined,undefined,null,null,[]，[],NaN,NaN,&quot;NaN&quot;,&#123;&#125;,&#123;&#125;,function () &#123;&#125;,function () &#123;&#125;];  console.log(unique(arr));//这种方式，是没有办法过滤 引用类型的,但针对基本数据类型没有问题</code></pre><ol start="5"><li>案例：查找元素在数组中所有索引（下标）<blockquote><ul><li>利用 <code>indexOf</code> 方法，返回查找到的元素索引</li><li>如果返回索引不为<code>-1</code>，把索引添加到新数组，</li><li>则继续从当前索引的<strong>下一个索引位置</strong>开始查找，找到就返回索引继续查找，找不到则停止查找。</li></ul></blockquote></li></ol><pre><code>function findIndexs(arr, element) &#123;  var indexArr = [];  var _index = arr.indexOf(element);  // 返回索引不是-1，则继续查找 _index!=-1  //while (~_index)  while (_index!==-1) &#123;    indexArr.push(_index);    _index = arr.indexOf(element, _index + 1);  &#125;  return indexArr;&#125;var arr = [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;, &quot;e&quot;, &quot;b&quot;, &quot;b&quot;, &quot;f&quot;, &quot;b&quot;];console.log(findIndexs(arr, &quot;b&quot;));</code></pre><h3 id="五、数组拼接与反转"><a href="#五、数组拼接与反转" class="headerlink" title="五、数组拼接与反转"></a>五、数组拼接与反转</h3><table><thead><tr><th>实例方法</th><th>描述</th><th>是否更改原数组</th></tr></thead><tbody><tr><td>concat()</td><td>方法用于合并两个或多个数组。此方法不会更改现有数组，而是返回一个新数组</td><td>否</td></tr><tr><td>reverse()</td><td>方法将数组中元素的位置颠倒，并返回该数组;该方法会改变原数组。</td><td>是</td></tr></tbody></table><ol><li>concat()方法<blockquote><ul><li>用于合并两个或多个数组</li><li>此方法不会更改现有数组，而是返回一个<strong>新数组</strong></li><li>concat 返回的新数组是元素的<strong>浅拷贝</strong></li><li>也可以像<code>.push</code>一样合并基本数据类型</li></ul></blockquote></li></ol><pre><code>var arr1 = [1, 2, 3, 4];var arr2 = [5, 6, 7, 8];var arr3 = [9, 10, 11, 12];//合并数组arr1,arr2,arr3var newArr = arr2.concat(arr1, arr3);//在数组最后添加基本数据类型var newArr = arr1.concat(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;);//还可以混用var newArr = arr2.concat(&quot;a&quot;, &quot;b&quot;, arr3);console.log(newArr);</code></pre><ol start="2"><li>reverse()方法<blockquote><ul><li><code>reverse()</code>方法可以将一个数组中的全部项<strong>顺序反过来</strong>显示。</li><li>它会改变原数组。</li></ul></blockquote></li></ol><pre><code>var arr = [1, 2, 3, 4, 5];arr.reverse();console.log(arr); // [5,4,3,2,1]</code></pre><blockquote><ul><li>与其他方法结合，将字符串进行倒序显示</li></ul></blockquote><pre><code>var str = &quot;清晨我上马&quot;;var arr = str.split(&quot;&quot;);arr.reverse();var str2 = arr.join(&quot;&quot;);console.log(str2); // 马上我晨清</code></pre><h3 id="六、筛选数组元素"><a href="#六、筛选数组元素" class="headerlink" title="六、筛选数组元素"></a>六、筛选数组元素</h3><table><thead><tr><th>方法</th><th>描述</th><th>是否更改原数组</th></tr></thead><tbody><tr><td>filter()</td><td>返回所有通过函数测试成功的元素;其返回值为测试成功的元素组成的新数组</td><td>不会</td></tr><tr><td>find()</td><td>返回数组中满足提供的测试函数的第一个元素的值;否则返回<code>undefined</code></td><td>不会</td></tr></tbody></table><blockquote><blockquote><p>判断条件都写在return后面，结果为true时才会通过</p><ul><li>回调函数<code>function (element, index, array)</code>这块相当于一个for循环遍历,<code>filter\find\forEach</code>都是如此</li></ul></blockquote></blockquote><pre><code> var arr = [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;, &quot;e&quot;]; arr.filter(function (element, index, array) &#123;   console.log(element + &quot;-&quot; + index + &quot;-&quot; + arr); &#125;); arr.find(function (element, index, array) &#123;   console.log(element + &quot;-&quot; + index + &quot;-&quot; + arr); &#125;); arr.forEach(function (element, index, array) &#123;   console.log(element + &quot;-&quot; + index + &quot;-&quot; + arr); &#125;); //结果都是： //a-0-a,b,c,d,e //b-1-a,b,c,d,e //c-2-a,b,c,d,e //d-3-a,b,c,d,e //e-4-a,b,c,d,e</code></pre><ol><li>filter()方法<blockquote><ul><li>返回所有通过函数测试成功的元素，其返回值为测试成功的元素组成的<strong>新数组</strong></li><li>语法：</li></ul></blockquote></li></ol><pre><code>// 回调函数filter(callbackFn);filter(callbackFn, thisArg);&gt;// 内联回调函数filter(function (element) &#123;  /* … */&#125;);filter(function (element, index) &#123;  /* … */&#125;);filter(function (element, index, array) &#123;  /* … */&#125;);//完整版filter(function (element, index, array) &#123;  /* … */&#125;, thisArg);</code></pre><ul><li><p><strong>详细解读</strong></p><blockquote><ul><li>callbackFn 用来测试数组中每个元素的函数，返回 <code>true</code>表示该元素通过测试，保留该元素，<code>false</code>则不保留</li><li>callbackFn 函数，接受以下三个参数<ul><li>element 数组中当前正在处理的元素</li><li>index 正在处理的元素在数组中的索引</li><li>array 调用了 filter()的数组本身</li></ul></li><li>thisArg 可选，执行 callbackFn 时，用于 this 的值</li></ul></blockquote></li><li><p>案例：找出数组中所有小于 10 的元素</p></li></ul><pre><code>// 筛选出所有小于10的元素var arr = [1, 22, 5, 12, 45, 9, 10, 33, 8];var arr2 = arr.filter(function (value) &#123;  return value &lt; 10;&#125;);console.log(arr2); //  [1, 5, 9, 8]</code></pre><ul><li>灵活运用判断条件<blockquote><ul><li>只要结果是true就能通过</li><li>可以是<code>return el&gt;10</code></li><li>也可以是布尔类型的：</li></ul></blockquote></li></ul><pre><code>var arr = [&quot;bc&quot;, &quot;cad&quot;, &quot;aff&quot;, &quot;scs&quot;];var result = arr.filter(function (el) &#123;  //将数组转换成字符串  var arr = el.split(&quot;&quot;);  console.log(arr);  //查找包含&quot;a&quot;的元素  var boole = arr.includes(&quot;a&quot;);  //返回包含&quot;a&quot;的元素的数组  return boole;&#125;);console.log(result);</code></pre><ul><li>自已封装简单版 filter 方法</li></ul><pre><code>// 大于等于10var arr = [1, 3, 68, 33, 5, 9, 34, 55];function filter(arr) &#123;  var arr2 = [];  for (var i = 0; i &lt;= arr.length; i++) &#123;    if (arr[i] &gt;= 10) &#123;      arr2.push(arr[i]);    &#125;  &#125;  return arr2;&#125;console.log(filter(arr));&gt;&gt;/**&gt; * 找到数组中所有满足测试函数条件的元素&gt; * @param arr 查找的数组&gt; * @param fn 测试函数&gt; */function filter(arr, fn) &#123;  var arr2 = [];  for (var i = 0; i &lt;= arr.length; i++) &#123;    // 为真，就添加    if (fn(arr[i])) &#123;      arr2.push(arr[i]);    &#125;  &#125;  return arr2;&#125;// 定义数组var arr = [1, 3, 68, 33, 5, 9, 34, 55];// 筛选出大于等于10的元素var arr2 = filter(arr, function (value) &#123;  return value &gt;= 10;&#125;);console.log(arr2);// 筛选出小于等于10的元素var arr3 = filter(arr, function (value) &#123;  return value &lt; 10;&#125;);console.log(arr3);</code></pre><ol start="2"><li>find() 方法<blockquote><ul><li>返回数组中满足提供的测试函数的<strong>第一个元素的值</strong>。否则返回 <code>undefined</code></li></ul></blockquote></li></ol><pre><code>// 回调函数find(callbackFn);find(callbackFn, thisArg);// 内联回调函数find(function (element) &#123;  /* … */&#125;);find(function (element, index) &#123;  /* … */&#125;);find(function (element, index, array) &#123;  /* … */&#125;);//完整版find(function (element, index, array) &#123;  /* … */&#125;, thisArg);</code></pre><ul><li><p>详细解读</p><blockquote><ul><li>callbackFn 用来测试数组中每个元素的函数</li><li>callbackFn 有三个参数<ul><li>element 当前数组中正在遍历到的元素</li><li>index 当前数组中正在遍历到的索引</li><li>array 当前调用 find 方法的数组</li></ul></li><li>执行回调时用作 this 的对象。</li></ul></blockquote></li><li><p>筛选出小于10的第一个元素</p></li></ul><pre><code>var arr = [1, 22, 5, 12, 45, 9, 10, 33, 8];var arr2 = arr.find(function (value) &#123;  return value &lt; 10;&#125;);console.log(arr2); //  [1]</code></pre><blockquote><ul><li>也可以像filter一样，与其他方法结合使用</li></ul></blockquote><h3 id="七、数组排序"><a href="#七、数组排序" class="headerlink" title="七、数组排序"></a>七、数组排序</h3><table><thead><tr><th>方法</th><th>描述</th><th>是否更改变原数组</th></tr></thead><tbody><tr><td>sort()</td><td>用于对数组的元素进行排序</td><td>是</td></tr></tbody></table><ul><li>语法</li></ul><pre><code>// 无函数sort();// 内联比较函数  函数可以是匿名的sort(function compareFn(a, b) &#123;  /* … */&#125;);</code></pre><ol><li>sort()未指定函数参数<blockquote><ul><li>当 <code>sort</code> 中没有给定参数时，数组中的元素会先被转换为<strong>字符串</strong>，然后比较的时候是按 <code>Unicode</code> 编码来进行排序</li><li>英文字母对应的 Unicode 编码<ul><li><code>A~Z</code> 对应 <code>65~ 90</code> 也就是A的Unicode编码是65 、 Z 的Unicode编码是 90</li><li><code>a~z</code> 对应 <code>97~122</code></li><li><code>0~9</code> 对应 <code>48~57</code></li></ul></li></ul></blockquote></li></ol><pre><code>var arr = [&quot;A&quot;, &quot;Z&quot;, &quot;b&quot;, 1, 80, 9, 100, 70, &quot;a&quot;];arr.sort();console.log(arr); // [1, 100, 70, 80, 9, &#39;A&#39;, &#39;Z&#39;, &#39;a&#39;, &#39;b&#39;]</code></pre><blockquote><blockquote><p>在没有函数做为参数时，这种比较本质上是没有办法做数字数组的排序</p></blockquote></blockquote><ol start="2"><li>sort()指定函数参数<blockquote><ul><li>sort中的函数，可以自拟函数名，也可以是匿名函数</li><li><code>a，b </code>是用于比较的两个元素</li><li>函数返回值为<code>a-b</code>，则数组按<strong>升序</strong>排序，即从小到大</li><li>函数返回值为<code>b-a</code>,则数组按<strong>降序</strong>排序，即从大到小</li></ul></blockquote></li></ol><pre><code>sort(function compareFn(a, b) &#123;  return a - b;&#125;);&gt;// sort中的函数，也可以是匿名函数sort(function (a, b) &#123;  return b - a;&#125;);</code></pre><ul><li>如何理解：a-b 即升序，b-a 即降序<blockquote><p>在之前的数组中我们学过冒泡排序，冒泡排序的原则就是如果相邻的两个数(a,b)比较时</p><ul><li>如果 a-b 大于 0，交换两者位置，即大的数 a 的放后面，小的 b 放前面，升序</li><li>如果 b-a 大于 0 ，交换两者位置，即大的数 b 放在前面，小的数 a 放在后面，降序<blockquote><p>所以你可以把这里的 a 和 b 当成数组成<strong>相邻的</strong>两个比较元素</p></blockquote></li><li>如果<code>compareFn(a, b)</code><strong>大于</strong> 0 ，b会被排列到 a 之前。</li><li>如果<code>compareFn(a, b)</code><strong>小于</strong> 0 ，那么 a会被排列到 b 之前；</li><li>如果<code>compareFn(a, b)</code><strong>等于</strong> 0 ，a和b的相对位置不变。</li></ul></blockquote></li></ul><ol start="3"><li>冒泡排序法封装成函数</li></ol><pre><code>// 封装冒泡排序function bubbleSort(arr, fn) &#123;  // 数组长度  var len = arr.length;  // 当前是否是有序的  var isSorted;  var flag = 0;  // 有序的边界  var sortBorder = len - 1;  // 外层for控制交换轮数  for (var i = 0; i &lt; len - 1; i++) &#123;    // 内层for控制每一轮，元素交换次数处理    isSorted = true; // 有序标记，每轮开始默认为有序，如果一旦发生交换，就会变成flag=false,无序&gt;    for (var j = 0; j &lt; sortBorder; j++) &#123;      if (fn(arr[j], arr[j + 1]) &gt; 0) &#123;        // 交换两元素位置        var tmp; // 用来交换两个变量的中间变量        tmp = arr[j];        arr[j] = arr[j + 1];        arr[j + 1] = tmp;        isSorted = false;        // 把无序列表的边界，更新为最后一次交换元素的位置        flag = j;      &#125;    &#125;    if (!isSorted) &#123;      sortBorder = flag;    &#125;    // 这一轮多次交换下来，flag没有变为false,说明没有发生元素交换，此时数组已是有序的    if (isSorted) &#123;      break; // 退出最外层for循环    &#125;  &#125;&#125;&gt;// 排序数组var arr = [2, 3, 4, 1, 5, 6, 7, 8, 9, 35, 76];bubbleSort(arr, function (a, b) &#123;  return a - b; // 升序&#125;);console.log(arr); // [1, 2, 3, 4, 5, 6, 7, 8, 9, 35, 76]&gt;bubbleSort(arr, function (a, b) &#123;  return b - a; // 降序&#125;);console.log(arr); // [76, 35, 9, 8, 7, 6, 5, 4, 3, 2, 1]</code></pre><h3 id="八、forEach数组遍历"><a href="#八、forEach数组遍历" class="headerlink" title="八、forEach数组遍历"></a>八、forEach数组遍历</h3><blockquote><ul><li><code>forEach()</code>方法对数组的每个元素执行一次给定的函数</li><li>返回值为<code>undefined</code></li><li>会更改原数组</li></ul></blockquote><pre><code>// 回调函数forEach(callbackFn, thisArg);forEach(function (element, index, array) &#123;/* … */&#125;, thisArg);</code></pre><blockquote><ul><li>callbackFn 为数组中每个元素执行的函数，函数带有以下三个参数：<ul><li>element 当前数组中正在遍历到的元素</li><li>index 当前数组中正在遍历到的索引</li><li>array <code>forEach()</code>方法正在操作的数组</li></ul></li><li>thisArg可选参数，当执行回调函数<code>callbackFn</code>时，用作<code>this</code>的值，如果此参数不写，其<code>callbackFn</code>函数中this指向全局对象</li></ul></blockquote><ul><li>forEach底层逻辑</li></ul><pre><code>//用forEach方法实现var arr = [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;, &quot;e&quot;];arr.forEach(function (el, index, arr) &#123;  if (el == &quot;c&quot;) &#123;    arr.splice(index, 1);  &#125;&#125;);console.log(arr);&gt;//底层逻辑就是用for循环遍历function forEach(arr, fn) &#123;  for (var i = 0; i &lt; arr.length; i++) &#123;    //for循环把每个元素拿出来后，要做的操作    fn(arr[i], i, arr);  &#125;&#125;forEach(arr, function (el, index, arr) &#123;  //想做的操作&#125;);</code></pre><blockquote><ul><li>从性能方面来说，<code>forEach</code>比单独用<code>for循环</code>来实现是要差的，但差别不大，主要原因是<code>forEach</code>没执行一次都要调用一次回调函数</li><li>但在实际开发中，倾向于用<code>forEach</code>，因为性能差别不大，而<code>forEach</code>可读性更强</li></ul></blockquote><h3 id="九、数组相关方法总结"><a href="#九、数组相关方法总结" class="headerlink" title="九、数组相关方法总结"></a>九、数组相关方法总结</h3><table><thead><tr><th>实例方法</th><th>描述</th><th>是否改变原数组</th><th>返回结果</th></tr></thead><tbody><tr><td>push()</td><td>将一个或多个元素添加到数组的末尾，并返回该数组的新长度</td><td>会</td><td>原数组的新长度</td></tr><tr><td>pop()</td><td>从数组中删除最后一个元素，并返回该元素的值</td><td>会</td><td>返回被删除元素</td></tr><tr><td>unshift()</td><td>将一个或多个元素添加到数组的头部，并返回该数组的新长度</td><td>会</td><td>原数组的新长度</td></tr><tr><td>shift()</td><td>从数组中删除第一个元素，并返回该元素的值</td><td>会</td><td>被删除元素</td></tr><tr><td>slice()</td><td>（查询）：提取原数组的一部分并返回一个新数组</td><td>不会</td><td>将查询到元素组成的新数组返回</td></tr><tr><td>splice()</td><td>（新增）：在指定位置插入一项或多项新元素；（删除）：在指定位置删除指定项；（更新）：在指定位置删除指定项，同时在此处添加一项或多项</td><td>会</td><td>返回被删除元素组成的数组</td></tr><tr><td>join()</td><td>将一个数组的所有元素以特定的某种字符连接成一个字符串</td><td>不会</td><td>并返回连接后的字符串</td></tr><tr><td>toString()</td><td>将数组转换为字符串</td><td>不会</td><td>返回该字符串</td></tr><tr><td>indexOf()</td><td>返回在数组中可以找到给定元素的第一个索引，如果不存在，则返回 -1。</td><td>不会</td><td>返回元素索引或-1</td></tr><tr><td>lastIndexOf()</td><td>返回指定元素在数组中的最后一个的索引，如果不存在则返回 -1;从指定位置开始逆向查找（即从后往前找）</td><td>否</td><td>返回指定元素在数组中的最后一个的索引</td></tr><tr><td>includes()</td><td>用来判断一个数组是否包含一个指定的值，根据情况，如果包含则返回 true，否则返回 false</td><td>不会</td><td>返回值为 true 或 false</td></tr><tr><td>concat()</td><td>方法用于合并两个或多个数组。此方法不会更改现有数组，而是返回一个新数组</td><td>不会</td><td>将合并成的新数组返回</td></tr><tr><td>reverse()</td><td>方法将数组中元素的位置颠倒，并返回该数组</td><td>会</td><td>返回置返后的原数组</td></tr><tr><td>sort()</td><td>对数组中的元素进行排序（降序或升序）</td><td>会</td><td>返回排序后的原数组</td></tr><tr><td>filter</td><td>返回所有通过函数测试成功的元素；其返回值为测试成功的元素组成的新数组</td><td>不会</td><td>返回符合要求的所有元素</td></tr><tr><td>find</td><td>返回数组中满足提供的测试函数的第一个元素的值；否则返回 undefined (opens new window)</td><td>不会</td><td>返回符合要求的第一个元素</td></tr><tr><td>forEach</td><td>forEach()方法对数组的每个元素执行一次给定的函数</td><td>会</td><td>返回值为undefined</td></tr></tbody></table><h3 id="十、综合应用案例"><a href="#十、综合应用案例" class="headerlink" title="十、综合应用案例"></a>十、综合应用案例</h3><ol><li>求数组中每一项的总和、平均数<blockquote><ul><li><code>forEach()</code>方法对数组的每个元素执行一次给定的函数</li></ul></blockquote></li></ol><pre><code> function sum(arr) &#123; var sum = 0; socreArr.forEach(function (el) &#123;   sum += el; &#125;); return sum; &#125; var socreArr = [99, 96, 95, 89, 86, 88, 67, 53, 69, 36]; var result = sum(socreArr); console.log(result); console.log(result / socreArr.length);</code></pre><ol start="2"><li>随机样本：请随机从原来数组中取 3 项<blockquote><ul><li>取随机下标：<code>Math.random()</code></li><li>过滤数组和数字<ul><li><code>Array.isArray()</code>确定输入的是数组</li><li>Number转数字，<code>NaN</code>永远不等于它自身</li></ul></li></ul></blockquote></li></ol><ul><li>取样后，把原数组中的元素给删除了<blockquote><ul><li>删除数组中的元素：<code>splice</code></li></ul></blockquote></li></ul><pre><code>  function randomArr(arr, k) &#123;  var randomArr = [];  //过滤数组  if (!Array.isArray(arr)) return;  //若转数字后是NaN,则返回0  Number(k) !== Number(k) ? 0 : Number(k);  //如果k大于数组长度，则k等于数组长度  if (k &gt; arr.length) &#123;    k = arr.length;  &#125;  for (var i = 0; i &lt; k; i++) &#123;    //遍历k次，生成k个随机下标,n是每次的随机下标    var n = (Math.random() * arr.length) &gt;&gt; 0;    //将随机下标添加到新数组中    randomArr.push(arr[n]);    //删除已生成的下标,splice包括起始元素    arr.splice(n, 1);  &#125;  return randomArr;&#125;var arr = [2, 1, 5, 8, 6, 9, 4, 3, 7];console.log(randomArr(arr, &quot;5&quot;));</code></pre><ul><li>取样后，不动原数组<blockquote><ul><li>不删除已出现元素，但不能重复出现,用<code>includes</code></li></ul></blockquote></li></ul><pre><code>  function randomArr(arr, k) &#123;  var randomArr = [];  //过滤数组  if (!Array.isArray(arr)) return;  //若转数字后是NaN,则返回0  Number(k) !== Number(k) ? 0 : Number(k);  //如果k大于数组长度，则k等于数组长度  if (k &gt; arr.length) &#123;    k = arr.length;  &#125;  for (var i = 0; i &lt; k; i++) &#123;    //遍历k次，生成k个随机下标,n是每次的随机下标    var n = (Math.random() * arr.length) &gt;&gt; 0;    //如果新数组中不包括该随机数，则将该元素加进新数组    if (!randomArr.includes(arr[n])) &#123;      //将随机下标添加到新数组中      randomArr.push(arr[n]);    &#125; else &#123;      i--;    &#125;  &#125;  return randomArr;&#125;var arr = [2, 1, 5, 8, 6, 9, 4, 3, 7];console.log(randomArr(arr, 4));</code></pre><ol start="2"><li>手写 Flatten 方法，实现数组的扁平化 (面试题)</li></ol><ul><li>方法1：递归</li></ul><pre><code>var arr = [1, 2, 3, [4, [5], [6]], 7, 8];function flatten(arr) &#123;  var newArr = [];  for (var i = 0; i &lt; arr.length; i++) &#123;    if (Array.isArray(arr[i])) &#123;      // 是数组,递归调用；这一步很关键！      newArr = newArr.concat(flatten(arr[i])); // concat返回新的拼接好的数组    &#125; else &#123;      newArr.push(arr[i]);    &#125;  &#125;  return newArr;&#125;console.log(flatten(arr));</code></pre><ul><li>方法2：forEach+递归</li></ul><pre><code>var arr = [1, 2, 3, [4, [5], [6]], 7, 8];function flatten(arr) &#123;  var newArr = [];  arr.forEach(function (el) &#123;    if (Array.isArray(el)) &#123;      // 是数组,递归调用      newArr = newArr.concat(flatten(el)); // concat返回新的拼接好的数组    &#125; else &#123;      newArr.push(el);    &#125;  &#125;);  return newArr;&#125;console.log(flatten(arr));</code></pre>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JS核心知识点（五）</title>
      <link href="/2023/12/04/JS%E6%A0%B8%E5%BF%83%E7%9F%A5%E8%AF%86%E7%82%B9%EF%BC%88%E4%BA%94%EF%BC%89/"/>
      <url>/2023/12/04/JS%E6%A0%B8%E5%BF%83%E7%9F%A5%E8%AF%86%E7%82%B9%EF%BC%88%E4%BA%94%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<span id="more"></span><h3 id="一、函数的理解"><a href="#一、函数的理解" class="headerlink" title="一、函数的理解"></a>一、函数的理解</h3><blockquote><ul><li>函数就是语句的<strong>封装</strong>，可以让封装后的代码很方便的被反复使用</li><li>函数具有<strong>一次定义，多次调用</strong>‘的优点</li><li>使用函数，可以<strong>简化代码</strong>，让代码更具有可读性</li></ul></blockquote><p><strong>计算任意两个数之间所有数之和</strong></p><blockquote><ul><li>比如1-10，10-20，20-30 等</li><li>按照之前的学习，我们只能根据初始值和范围写for循环，而且每计算一次，就要写一次 for 循环</li></ul></blockquote><pre><code>var sum = 0;for (var i = 1; i &lt;= 10; i++) &#123;  sum += i;&#125;console.log(sum); // 55&gt;var sum = 0;for (var i = 10; i &lt;= 20; i++) &#123;  sum += i;&#125;console.log(sum); // 165</code></pre><blockquote><blockquote><p>有了函数之后，我们就可以实现输入起始的两个数，自动就出来我们想要的结果</p></blockquote></blockquote><h3 id="二、函数的声明和调用"><a href="#二、函数的声明和调用" class="headerlink" title="二、函数的声明和调用"></a>二、函数的声明和调用</h3><blockquote><ul><li>和变量一样，函数必须<strong>先定义</strong>（声明）然后才能使用</li><li>定义一个函数，有两种方式</li></ul></blockquote><ol><li>方式1：以<strong>函数声明</strong>的方式-创建一个函数<blockquote><ul><li>使用<code>function</code>关键字声明函数，必需全部<strong>小写</strong>，function是 “功能” 的意思</li><li>函数名必须符合<strong>JS标识符命名规则</strong></li><li>( ) 圆括号中是<strong>形参列表</strong>，即使没有形参，也必须书写圆括号</li><li>{ } 大括号里是<strong>函数体语句</strong></li></ul></blockquote></li></ol><pre><code>// 声明函数function 函数名() &#123;  // 函数体语句&#125;&gt;function hello() &#123;  console.log(&quot;大家好！&quot;);&#125;</code></pre><ol start="2"><li>方式2：以函数<strong>表达式</strong>的方式创建一个函数<blockquote><ul><li><code>function()&#123; &#125;</code>是一个<strong>匿名函数</strong>，即<strong>没有函数名</strong>的函数。</li><li>但是我们最后要使用这个函数，所以我们把这个匿名函数赋值给了一个<strong>变量</strong></li><li>后面我们通过这个变量来调用这个函数</li><li>匿名函数，经常以<strong>回调函数</strong>的形式出现</li></ul></blockquote></li></ol><pre><code>var 变量 = function () &#123;  // 函数体语句&#125;;&gt;var hello = function () &#123;  console.log(&quot;大家好！&quot;);&#125;;</code></pre><ol start="3"><li>函数的调用<blockquote><ul><li>调用函数非常简单，只需在<strong>函数名字&#x2F;变量名后书写圆括号对</strong>即可</li><li>所谓函数的调用，就是执行函数体内的所有语句。<blockquote><p>函数被声明后，是不会自动执行的，只有被调用才会被执行</p></blockquote></li></ul></blockquote></li></ol><blockquote><ul><li>通过方式1声明的函数：</li></ul></blockquote><pre><code>function hello() &#123;  console.log(&quot;大家好！&quot;);&#125;hello();// 函数定义一次，可以多次调用hello();hello();</code></pre><blockquote><ul><li>通过方式2声明的函数：</li></ul></blockquote><pre><code>var hello = function () &#123;  console.log(&quot;大家好！&quot;);&#125;;hello();// 函数定义一次，可以多次调用hello();</code></pre><ol start="4"><li>函数类型判断<blockquote><ul><li>利用 typeof 来检测函数类型，得到 function</li></ul></blockquote></li></ol><pre><code>function fn() &#123;&#125;typeof fn;console.log(typeof fn); // &#39;function&#39;console.log(typeof fn === &quot;function&quot;);//true</code></pre><h3 id="三、函数的参数"><a href="#三、函数的参数" class="headerlink" title="三、函数的参数"></a>三、函数的参数</h3><ol><li>函数参数分类<table><thead><tr><th>参数</th><th>说明</th></tr></thead><tbody><tr><td>形参</td><td>在<strong>声明函数</strong>时，我们可以在函数名后面的小括号（）中添加一些参数，这些参数被称为形参</td></tr><tr><td>实参</td><td>在<strong>调用函数</strong>时，我们可以在函数名后面的小括号（）中，添加的参数，这些参数被称为实参</td></tr></tbody></table></li></ol><blockquote><ul><li>在函数的()中可以指定<code>&gt;=0</code>个参数，参数可以是<strong>任意类型</strong></li><li>多个参数之间用<code>,逗号</code>隔开</li></ul></blockquote><pre><code>// 函数声明，这里的a,b被称为形参function sum(a, b) &#123;  console.log(a + b);&#125;&gt;// 调用函数sum(1, 2); // 这里的 1，2 被称为 实参sum(2, 3); // 这里的 2，3 被称为 实参</code></pre><ol start="2"><li>形参与实参的关系<blockquote><ul><li>在函数调用时，<strong>实参</strong>会将其值，<strong>赋值</strong>给到函数声明时对应的<strong>形参</strong>。</li><li>实参与形参在赋值时，是<strong>一一对应</strong>的顺序，所以顺序不要弄错<br><strong>我们以下面这个代码的执行过程来作为讲解</strong></li></ul></blockquote></li></ol><pre><code>// 函数声明，这里的a,b被称为 形参function sum(a, b) &#123;  console.log(a + b);&#125;// 调用函数，sum(1, 2); // 这里的 1，2被称为 实参</code></pre><blockquote><ul><li>代码从上往下执行</li><li>遇到<code>sum(1,2)</code>被调用，相当于就要<strong>开始执行</strong>sum函数。</li><li>在执行代码前，还有一个<strong>预解析</strong>的过程，这个时候，会根据形参个数，来创建对应的变量，<strong>接收</strong>传过来的实参的值。相当于如下代码：</li></ul></blockquote><pre><code>function sum() &#123;  var a = 1;  var b = 2;  console.log(a + b);//3&#125;</code></pre><ol start="3"><li>实参与形参个数不同时<br><strong>情况1：当实参个数 &gt; 形参个数时</strong><blockquote><ul><li>对函数本身的功能<strong>并没有任何的影响</strong></li><li>实参和形参一一对应，多余的实参没有对应的形参接应它，但也不会有什么影响</li></ul></blockquote></li></ol><p><strong>情况2：当实参个数 &lt; 形参个数时</strong></p><blockquote><ul><li>会引发报错，最终得不到想要的结果</li><li>因为如果对应的形参没有接受到对应实参的值，则默认值是<code>undefined</code></li></ul></blockquote><pre><code>// a,b,c 是形参function sum(a, b, c) &#123;  // 这里的c没有接受任何值，则默认值是undefined，undefined 进行任何运算结果都是 NaN  var sum = a + b + c;  console.log(sum);&#125;&gt;// 2,5 是实参sum(2, 5); // NaN</code></pre><blockquote><blockquote><p>在实际开发中，实参和形参尽量相同，否则会引发报错或 NaN</p></blockquote></blockquote><p><strong>总结：形参和实参</strong></p><table><thead><tr><th>参数个数</th><th>输出结果</th></tr></thead><tbody><tr><td>实参 &#x3D; 形参</td><td>正常输出结果</td></tr><tr><td>实参 &gt; 形参</td><td>正常输出结果</td></tr><tr><td>实参 &lt; 形参</td><td>形参默认值为undefined，多出的形参没有对应实参，则最后得不到想要的结果</td></tr></tbody></table><ol start="4"><li>参数默认值<blockquote><ul><li>如果实参的个数小于形成，那函数在调用后，则会报错，或得不到想要的结果。那有没有办法可以规避这种问题呢 ？有，就是我们接下来要讲到的参数的默认值。</li></ul></blockquote></li></ol><blockquote><ul><li>在函数<strong>声明时</strong>，我们可以给<strong>形参赋值</strong>，这个值我们称为参数的默认值</li><li>如果在函数调用时，<strong>没有</strong>传入对应的实参，则参数值就以默认值代替</li><li>如果<strong>传入了</strong>对应的实参，参数值就以实参传过来的值为准。</li></ul></blockquote><p><strong>方式1：</strong></p><pre><code>function sum(a=0,b) &#123;    console.log(a + b);&#125;sum(); // NaN  没有对应实参，则 采用默认值 a=0,b=undefined ,即a+b=NaNsum(1); // NaN 只传了第1个实参，则a=1,b=undefined，即a+b=NaNsum(1, 2); // 3 传入2个实参，则a=1,b=2,即a+b=3sum(,2); // 报错</code></pre><blockquote><blockquote><ul><li>注意形参与实参在接受值时，是一一对应关系</li><li>绝对不要这样写：<code>sum(,2);</code></li></ul></blockquote></blockquote><p><strong>方式2：</strong></p><pre><code>// 形参a，b同时赋初始值function sum(a, b) &#123;  // a,b 如果没有值，则默认为undefined，undefined转boolean是false  a = a || 0; // a有值，则用a的值，没值用0代替  b = b || 0; // b有值，则用b的值，没值用0代替  console.log(a + b);&#125;</code></pre><blockquote><blockquote><p>形参，在函数内部<strong>不需要</strong>用 <code>var</code> 声明，直接使用就可以</p><ul><li>注意场景：当a等于布尔值为<code>false</code>的值时，不适合用该方法，例如：null、undefined、””</li></ul></blockquote></blockquote><ol start="5"><li>案例1：计算任意两个数之间所有数之和<blockquote><ul><li>首先要<strong>判断</strong>输入的<strong>是否是数字</strong>，如果不是数字，则把参数默认值设为 0</li><li>然后要<strong>判断两个数的大小</strong>，<strong>for 循环</strong>遍历两个数之间的所有数，用<strong>累加器</strong>累加</li><li>最后输出累加器的值。</li></ul></blockquote></li></ol><p><strong>知识点1：</strong></p><blockquote><p><code>条件表达式 ? 表达式1 : 表达式2;</code><br><strong>执行流程：</strong></p><ul><li>首先对条件表达式进行求值</li><li>如果条件表达式的值为 true，则执行语句 1，并返回执行结果</li><li>如果条件表达式的值为 false，则执行语句 2，并返回执行结果</li></ul></blockquote><p><strong>知识点2：</strong></p><blockquote><p>判断是否为数字</p><ul><li><code>typeof</code>的值为<code>number</code></li><li><code>NaN</code>为不是数字的数字类型，所以typeof筛不掉它</li><li><code>isNaN</code>：判断这个参数是否“不是数值”<blockquote><p>所以数字同时满足<code>typeof a === &quot;number&quot;</code>和<code>!isNaN()</code>为true;</p></blockquote></li></ul></blockquote><pre><code>function sum(a, b) &#123;  // 如果a是数字，则返回a，否则返回0  a = typeof a === &quot;number&quot; &amp;&amp; !isNaN(a) ? a : 0;  // 如果b是数字，则返回b，否则返回0  b = typeof b === &quot;number&quot; &amp;&amp; !isNaN(b) ? b : 0;  var sum = 0;  if (a &gt;= b) &#123;    for (var i = b; i &lt;= a; i++) &#123;      sum += i;    &#125;  &#125; else &#123;    for (var i = a; i &lt;= b; i++) &#123;      sum += i;    &#125;  &#125;  console.log(sum);&#125;sum(-1, -2); // -3sum(1, 2); // 3sum(-1, 5); // 14sum(); // 0sum(&quot;-1&quot;, 0); // 0</code></pre><p><strong>总结：判断是否为纯数字</strong></p><blockquote><p>方法1：</p><ul><li>先用<code>Number</code>或者<code>+</code>转换成数字类型<ul><li>缺陷：<code>&quot;&quot;</code>会被转成0</li></ul></li><li>用<code>isNaN</code>判断是不是数字，<code>NaN</code>为不是数字的数字类型，可以过滤<code>NaN</code></li></ul></blockquote><blockquote><p>方法2：</p><ul><li>同时满足”数字类型”和数字</li><li>typeof() &#x3D;&#x3D;&#x3D; “Number”，typeof 返回值的类型都是字符串类型，所以要加<strong>双引号</strong></li><li>isNaN()为<code>false</code></li></ul></blockquote><ol start="6"><li>案例2:写一个函数，该函数对用户输入的用户名进行验证<blockquote><ul><li>当用户输入的用户名&lt;4 位数时，弹出提示“用户名不能小于 4 位数”</li><li>当用户输入的用户名&gt;&#x3D;4 位并且&lt;&#x3D;8 位时，弹出提示”用户名格式正确”</li><li>当用户输入的用户名&gt;8 位数时，弹出提示“用户名不能大于 8 位数”</li></ul></blockquote></li></ol><pre><code>function userMatch(username) &#123;  if (username.length &lt; 4) &#123;    alert(&quot;用户名不能小于4位&quot;);  &#125; else if (username.length &lt;= 8) &#123;    alert(&quot;用户名格式正确&quot;);  &#125; else &#123;    alert(&quot;用户名不能大于8位&quot;);  &#125;&#125;var username = prompt(&quot;请输入用户名&quot;);userMatch(username);</code></pre><ol start="7"><li><code>arguments</code> 实参列表<blockquote><p>如果我们在函数声明时，<strong>不确定</strong>我们到底要几个<strong>形参数</strong>，而希望在函数调用时，传递几个实参，就接受几个实参。这个时候 <code>arguments</code> 就派上用场了。</p><ul><li>arguments实际上是当前函数的一个<strong>内置对象</strong>，函数调用时创建</li><li>函数内arguments表示它接收到的实参列表</li></ul></blockquote></li></ol><blockquote><p>arguments 是一个<strong>类数组对象</strong>，所谓的类数组对象，具有以下特点：</p><ul><li>具有 <code>length</code> 属性</li><li>可以用<code>[]</code>方括号书写，用下标方式访问对象中属性值，下标从 <code>0</code> 开始</li><li><strong>不具备</strong>数组的所有方法，如<code>push,pop,unshift,shift</code>等方法，arguments 都没有</li></ul></blockquote><blockquote><blockquote><p>不管用户传入多少个实际参数，永远能够计算他们的和</p></blockquote></blockquote><pre><code>function sum() &#123;  var sum = 0;  for (var i = 0; i &lt; arguments.length; i++) &#123;    sum += arguments[i];  &#125;  console.log(&quot;所有参数的和是：&quot; + sum);&#125;&gt;sum(11, 22, 33, 44, 55); // 165sum(66); // 66sum(-3, 9); // 6</code></pre><ol start="8"><li>arguments 的注意事项<blockquote><ul><li>函数内<code>arguments</code>表示它接收到的<strong>实参</strong>列表</li><li><code>arguments</code>对象的值<strong>不反映</strong>参数的<strong>默认值</strong></li></ul></blockquote></li></ol><pre><code>function sum(a = 1, b = 2) &#123;  console.log(arguments);//[3,5, callee:(...) ,Symbol(Symbol.iterator): ƒ]  console.log(arguments[0]);//3  console.log(arguments[1]);//5&#125;sum(3, 5);sum();</code></pre><p><strong>参数的作用</strong></p><blockquote><ul><li>如果函数体内的某些值不能固定，我们可以在调用函数时，通过实参的形式传递不同值进去。</li><li>如上面代码中，求两个数的和，这两个数 a,b 的值是不固定的，就可以通过传参来解决</li></ul></blockquote><p><strong>函数的封装</strong></p><blockquote><ul><li>所谓函数的封装，就是把具有一定功能的代码，通过<strong>函数的形式</strong>封装起来</li><li>当我们需要使用的时候，只需要调用下这个函数就可以。</li></ul></blockquote><ol start="9"><li>类数组转换为数组<blockquote><p>arguments 是一个<strong>类数组</strong>对象，所谓的类数组对象，具有以下特点</p><ul><li>肯定是一个<strong>对象</strong>，同时具有 <code>length</code> 属性</li><li>可以用<code>[]</code>方括号，书写下标方式访问对象中属性值，下标从 <code>0</code> 开始</li><li>它<strong>并不拥有全部</strong>的 Array 对象的操作方法，如push,pop,unshift,shift等方法，arguments 都没有<blockquote><p>类数组是一个对象，他是 <code>Object</code> 的实例，而数组是 <code>Array</code> 的实例，所以类数组并不具有 Array 对象的方法<br>但类数组和数组，他们的<strong>原型终点</strong>都指向 <code>Object</code> 的原型，所以他们都具有 <code>Object</code> 对象上的方法</p></blockquote></li></ul></blockquote></li></ol><pre><code>function fn() &#123;  var isArr = Array.isArray(arguments);  console.log(isArr); // false  不是数组  console.log(typeof arguments); // object  是一个对象  console.log(arguments instanceof Object); // true 是Object的实例&#125;fn();</code></pre><p><strong>类数组转换为数组的几种方法：</strong></p><blockquote><blockquote><p>我们想要类数组拥有数组的相关方法，则可以把类数组转换为数组再操作。</p></blockquote><ul><li>for 循环遍历</li></ul></blockquote><pre><code>// for循环遍历function fn() &#123;  var arr = [];  // 将arguments中元素取出，放到一个新数组中，后面操作的都是这个新数组  for (var i = 0; i &lt; arguments.length; i++) &#123;    arr[i] = arguments[i];  &#125;  // 接下来操作arr这个数组就好  arr.push(&quot;A&quot;);  console.log(arr); // [1, 2, 3, &#39;A&#39;]&#125;fn(1, 2, 3);</code></pre><blockquote><blockquote><p>注意，并不是直接把类数组转换成数组，而是定义一个新数组，将类数组的元素取出来放入新数组中，操作新数组</p></blockquote></blockquote><blockquote><ul><li>使用数组的 <code>slice() </code>和 <code>concat() </code>方法</li></ul></blockquote><pre><code>function fn() &#123;  // 本质是把arguments中元素遍历后放到一个新数组中，换成后将新数组返回。  var arr = Array.prototype.slice.call(arguments);  // var arr = Array.prototype.concat.apply([], arguments);  arr.push(&quot;A&quot;);  console.log(arr);  console.log(arguments); // arguments并没有做任何改变&#125;fn(1, 2, 3);</code></pre><blockquote><ul><li>Array.from：该静态方法从可迭代或类数组对象创建一个新的浅拷贝的数组实例。</li><li>Array.apply</li></ul></blockquote><pre><code>// 创建一个类数组对象var obj = &#123;  length: 2,  0: 1,  1: 2,&#125;;// var arr = Array.from(obj);var arr = Array.apply(null, obj);arr.push(&quot;A&quot;);console.log(arr);</code></pre><p><strong>常见的类数组有</strong></p><blockquote><ul><li>arguments、NodeList，HTMLCollection 、DOMTokenList 等<blockquote><p><strong>特别注意</strong></p><ul><li>字符串，有 <code>length</code> 属性，也可以<code>[]</code>括号的方式访问元素，但是他<strong>不是一个对象</strong>，所以他不是类数组。</li></ul></blockquote></li></ul></blockquote><ol start="10"><li>案例：编写一个函数，根据输入的参数，在页面输出所有参数相加的公式<blockquote><ul><li><code>fn(1)</code> 得到 <code>0+1=1</code></li><li><code>fn(1,2)</code> 得到 <code>1+2=3</code></li><li><code>fn(1,2,3)</code> 得到 <code>1+2+3=6</code></li></ul></blockquote></li></ol><pre class=" language-js"><code class="language-js"><span class="token keyword">function</span> <span class="token function">sum</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>  <span class="token keyword">var</span> sum <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>  <span class="token keyword">var</span> str <span class="token operator">=</span> <span class="token string">""</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 拼接字符串</span>  <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">var</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> arguments<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>    sum <span class="token operator">+</span><span class="token operator">=</span> arguments<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//累加器</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>arguments<span class="token punctuation">.</span>length <span class="token operator">===</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>      str <span class="token operator">=</span> <span class="token string">"0+"</span> <span class="token operator">+</span> arguments<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>      <span class="token comment" spellcheck="true">//只有一个数时</span>    <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>i <span class="token operator">&lt;</span> arguments<span class="token punctuation">.</span>length <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>      str <span class="token operator">+</span><span class="token operator">=</span> arguments<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">+</span> <span class="token string">"+"</span><span class="token punctuation">;</span>      <span class="token comment" spellcheck="true">//非末尾数时</span>    <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span> <span class="token keyword">else</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>      str <span class="token operator">+</span><span class="token operator">=</span> arguments<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>      <span class="token comment" spellcheck="true">//最后一位数，不需要带+号</span>    <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>  <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>str <span class="token operator">+</span> <span class="token string">"="</span> <span class="token operator">+</span> sum<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span><span class="token function">sum</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 0+1=1</span><span class="token function">sum</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 1+2=3</span><span class="token function">sum</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 1+2+4=7</span></code></pre><h3 id="四、函数返回值"><a href="#四、函数返回值" class="headerlink" title="四、函数返回值"></a>四、函数返回值</h3><blockquote><ul><li>函数体内可以使用<code>return</code>关键字来返回<strong>函数的返回值</strong></li><li><code>return</code>可以返回<strong>任意类型的值</strong>，即函数返回值可以是任意类型，但只能返回一个值</li><li><code>return</code>后面的值，就是函数调用执行后的返回值</li></ul></blockquote><pre><code>function sum(a, b) &#123;  return a + b;&#125;var result = sum(1, 3);console.log(result); // 4</code></pre><blockquote><ul><li>return 后面只能返回 1 个值，如果多个值，则以最后一个为准</li></ul></blockquote><pre><code>function fn() &#123;  return 1, &quot;A&quot;, [1, 2, 3];&#125;console.log(fn()); // [1, 2, 3]</code></pre><blockquote><ul><li>函数里没有<code>return</code> 或 <code>return ;</code> ，则函数的返回值是<code>undefined</code>;</li></ul></blockquote><pre><code>function fn() &#123;  console.log(&quot;没有返回值&quot;);&#125;console.log(fn());//没有返回值//undefined</code></pre><blockquote><ul><li>函数的返回值，可以被一个变量接收，这个变量可以参与后续的使用<blockquote><p>return 只能出现在函数中，出现在其它地方会报错</p></blockquote></li></ul></blockquote><ol><li>遇见 <code>return</code> 即<strong>退出</strong>函数<blockquote><ul><li>函数中<code>return</code>语句<strong>之后</strong>的内容，是不会被执行的</li><li><code>return</code>相当于<strong>立即退出</strong>函数</li><li><code>return</code>只能出现在<strong>函数体</strong>中</li></ul></blockquote></li></ol><blockquote><blockquote><p>只有第一个<code>console.log(result);</code>会被执行</p></blockquote></blockquote><pre><code>function sum(a, b) &#123;    console.log(&quot;return前内容&quot;);    return a + b;    console.log(result);   &#125;  var result = sum(1, 3);  console.log(result);   //return前内容  //4</code></pre><blockquote><blockquote><p>遇到return 立即退出函数体</p></blockquote></blockquote><pre><code>function max(a, b) &#123;  if (a &gt; b) return a;  return b;&#125;console.log(max(12, 5)); // 12console.log(max(5, 6)); // 6</code></pre><ol start="2"><li>return 与 if 的结合<blockquote><ul><li>结合if语句的时候，如果if语句体中<strong>只有一条</strong>语句，不需要写<code>&#123; &#125;</code><br><strong>题目：请编写一个函数，判断一个数字是否是偶数</strong></li></ul></blockquote></li></ol><pre><code>function checkEven(n) &#123;  // if(n % 2 == 0)&#123;  //   return true;  // &#125;  // return false;&gt;  // 单行语句，也可以省略&#123;&#125; ,在实际工作中类似写法很常见  if (n % 2 == 0) return true;  return false;&#125;&gt;var result = checkEven(5);console.log(result); // false</code></pre><ol start="3"><li>return 与循环语句结合<blockquote><ul><li>return 可以在函数体中与 <code>if</code> 语句，<code>循环语句</code>结合使用<br><strong>题目：</strong></li><li>找出数组<code>[200,500,900,1200,1500]</code>中比600大的第一个值出现的位置，并将其返回。</li></ul></blockquote></li></ol><pre><code>var arr = [200, 500, 900, 1200, 1500];  function firstIndex(n) &#123;      for (var i = 0; i &lt; arr.length; i++) &#123;        if (arr[i] &gt;= n) return i;      &#125;    &#125;  var _index = firstIndex(600);  console.log(_index);</code></pre><ol start="4"><li>return、break、continue 三者区别<table><thead><tr><th>关键字</th><th>描述</th></tr></thead><tbody><tr><td>break</td><td>在循环语句中使用，结束当前循环体（如 for 循环，while 循环）</td></tr><tr><td>continue</td><td>在循环语句中使用，跳出本次循环，继续执行下一次循环（如：for 循环，while 循环）</td></tr><tr><td>return</td><td>return 关键 字，只能出现在函数体中，不仅能退出循环，退出函数体，还能将 return 语句中的值返回，其返回值为函数返回值</td></tr></tbody></table></li></ol><blockquote><ul><li>break 退出当前 for 循环</li></ul></blockquote><pre><code>function fn() &#123;  for (var i = 0; i &lt; 10; i++) &#123;    if (i == 3) &#123;      break;    &#125;    console.log(i);  &#125;  console.log(&quot;break,continue退出时，我会出来&quot;);&#125;fn();//0//1//2//break,continue退出时，我会出来</code></pre><blockquote><ul><li>continue 跳出本次循环，继续执行下一次循环</li></ul></blockquote><pre><code>function fn() &#123;  for (var i = 0; i &lt; 10; i++) &#123;    if (i == 3) &#123;      continue;    &#125;    console.log(i);  &#125;  console.log(&quot;break,continue退出时，我会出来&quot;);&#125;fn();//0 1 2 4 5 6 7 8 9//break,continue退出时，我会出来</code></pre><blockquote><ul><li>return 不仅能退出循环，<strong>退出函数体</strong></li></ul></blockquote><pre><code>function fn() &#123;  for (var i = 0; i &lt; 10; i++) &#123;    if (i == 3) &#123;      return;    &#125;    console.log(i);  &#125;  console.log(&quot;break,continue退出时，我会出来&quot;);&#125;fn();//0 1 2</code></pre><h3 id="五、函数作为参数"><a href="#五、函数作为参数" class="headerlink" title="五、函数作为参数"></a>五、函数作为参数</h3><ol><li>函数做为参数的应用<blockquote><ul><li>函数作为函数的参数，在实际的开发中经常用到，特别是我们常用的各种API（那些封装好的函数就叫做API），其参数经常是一个函数。</li><li>所以理解函数做为函数的参数，在内部是如何处理的，对我们学习API方法是非常用帮助的。</li></ul></blockquote></li></ol><ul><li>函数fn2作为函数fn的参数，函数fn2不带参数时</li></ul><pre><code>// 声明一个函数，其参数a也是一个参数function fn(a) &#123;  a(); // 内部执行函数a&#125;// 声明一个函数function fn2() &#123;  console.log(&quot;我是在fn的内部被调用&quot;);&#125;// 调用fn函数，把函数fn2作为fn函数的参数fn(fn2);</code></pre><ul><li>函数fn2 作为函数fn的参数，函数fn2带参数时（非常重要，一定要掌握）</li></ul><pre><code>// 声明一个函数，其参数a是一个函数function fn(a) &#123;  a(2, 4); // 调用函数&#125;// 声明一个函数function fn2(a, b) &#123;  console.log(a + b);&#125;// 调用fn函数，把函数fn2作为fn函数的参数fn(fn2); // 6&gt;// fn(fn2(2,4));   错误的用法</code></pre><blockquote><blockquote><p>初学常见错误</p></blockquote><ul><li>函数带参数时，常会引发这种错误的使用<code>fn(fn2(2,4))</code></li><li>这里的<code>fn2(2,4)</code>被调用，返回值为<code>undefined</code>，相当于传过去的实参是<code>undefined</code>(因为没有return)</li><li><strong>切记：</strong> 函数做为参数，是没有办法把实参传过去，实参只能在函数调用的时候传递</li></ul></blockquote><ol start="2"><li>手写一个函数，返回数组中最大值或最小值</li></ol><ul><li>写一个函数，返回数组中最大值</li></ul><pre class=" language-js"><code class="language-js"><span class="token comment" spellcheck="true">//声明函数find(arr)</span> <span class="token keyword">function</span> <span class="token function">find1</span><span class="token punctuation">(</span>arr<span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>   <span class="token keyword">var</span> max <span class="token operator">=</span> arr<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span>   <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">var</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> arr<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>     <span class="token comment" spellcheck="true">//max &lt; arr[i]</span>     <span class="token keyword">if</span> <span class="token punctuation">(</span>max <span class="token operator">-</span> arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>       max <span class="token operator">=</span> arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>     <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>   <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>   <span class="token keyword">return</span> max<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//遍历之后返回最大值</span> <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//声明数组</span> <span class="token keyword">var</span> arr1 <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">6</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">40</span><span class="token punctuation">,</span> <span class="token number">39</span><span class="token punctuation">,</span> <span class="token number">58</span><span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//调用函数</span> <span class="token keyword">var</span> result <span class="token operator">=</span> <span class="token function">find1</span><span class="token punctuation">(</span>arr1<span class="token punctuation">)</span><span class="token punctuation">;</span> console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>result<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><ul><li>写一个函数，返回数组中最小值</li></ul><pre class=" language-js"><code class="language-js"><span class="token keyword">function</span> <span class="token function">find2</span><span class="token punctuation">(</span>arr<span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>   <span class="token keyword">var</span> min <span class="token operator">=</span> arr<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span>   <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">var</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> arr<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>     <span class="token comment" spellcheck="true">// min > arr[i]</span>     <span class="token keyword">if</span> <span class="token punctuation">(</span>arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">-</span> min <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>       min <span class="token operator">=</span> arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>     <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>   <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>   <span class="token keyword">return</span> min<span class="token punctuation">;</span> <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span> <span class="token keyword">var</span> arr1 <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">6</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">40</span><span class="token punctuation">,</span> <span class="token number">39</span><span class="token punctuation">,</span> <span class="token number">58</span><span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token keyword">var</span> result <span class="token operator">=</span> <span class="token function">find2</span><span class="token punctuation">(</span>arr1<span class="token punctuation">)</span><span class="token punctuation">;</span> console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>result<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><blockquote><blockquote><p>我们对比以上两个函数会发现：</p></blockquote><ul><li>他们的实现除了<code>if (max &lt; arr[i])</code>和<code>if (min &gt; arr[i])</code>不一样，其它全一样</li><li>那我们是不是可以写一个函数，把<code>max</code>和<code>arr[i]</code>作为函数的参数，让用户来决定输出最大值还是最小值</li></ul></blockquote><ul><li>根据函数参数，来决定返回数组中最大值，还是数组中最小值<blockquote><ul><li>用不同函数作为参数</li></ul></blockquote></li></ul><pre><code>function minmax(arr, fn) &#123;   var value = arr[0];   for (var i = 1; i &lt; arr.length; i++) &#123;     // fn1:max-arr[i] &lt; 0,a-b&lt;0     // fn2:arr[i]-min &lt; 0,b-a&lt;0     if (fn(value, arr[i]) &lt; 0) &#123;       value = arr[i];     &#125;   &#125;   return value; &#125; var arr = [1, 4, 5, 6, 2, 40, 39, 58]; function fn1(a, b) &#123;   return a - b; &#125; function fn2(a, b) &#123;   return b - a; &#125; var max = minmax(arr, fn1); var min = minmax(arr, fn2); console.log(max, min);</code></pre><ol start="3"><li>手写一个 filter 函数<blockquote><ul><li>函数功能： 实现返回数组中所有大于&#x2F;小于 n 的元素，返回值为所有满足条件的元素组成的数组</li></ul></blockquote></li></ol><blockquote><blockquote><p>返回<strong>大于10</strong>的元素</p></blockquote></blockquote><pre class=" language-js"><code class="language-js"> <span class="token keyword">function</span> <span class="token function">filter1</span><span class="token punctuation">(</span>arr<span class="token punctuation">,</span> value<span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>   <span class="token keyword">var</span> arr2 <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span>   <span class="token keyword">var</span> len <span class="token operator">=</span> arr<span class="token punctuation">.</span>length<span class="token punctuation">;</span>   <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">var</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> len<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>     <span class="token comment" spellcheck="true">// arr[i]-value>0</span>     <span class="token keyword">if</span> <span class="token punctuation">(</span>arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">></span> value<span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>       arr2<span class="token punctuation">[</span>arr2<span class="token punctuation">.</span>length<span class="token punctuation">]</span> <span class="token operator">=</span> arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>     <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>   <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>   <span class="token keyword">return</span> arr2<span class="token punctuation">;</span> <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span> <span class="token keyword">var</span> arr1 <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">15</span><span class="token punctuation">,</span> <span class="token number">6</span><span class="token punctuation">,</span> <span class="token number">10</span><span class="token punctuation">,</span> <span class="token number">12</span><span class="token punctuation">,</span> <span class="token number">13</span><span class="token punctuation">,</span> <span class="token number">9</span><span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token keyword">var</span> result <span class="token operator">=</span> <span class="token function">filter1</span><span class="token punctuation">(</span>arr1<span class="token punctuation">,</span> <span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">;</span> console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>result<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><blockquote><blockquote><p>返回<strong>小于10</strong>的值</p></blockquote></blockquote><pre class=" language-js"><code class="language-js"> <span class="token keyword">function</span> <span class="token function">filter2</span><span class="token punctuation">(</span>arr<span class="token punctuation">,</span> value<span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>   <span class="token keyword">var</span> arr2 <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span>   <span class="token keyword">var</span> len <span class="token operator">=</span> arr<span class="token punctuation">.</span>length<span class="token punctuation">;</span>   <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">var</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> len<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>     <span class="token comment" spellcheck="true">// value-arr[i]>0</span>     <span class="token keyword">if</span> <span class="token punctuation">(</span>arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">&lt;</span> value<span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>       arr2<span class="token punctuation">[</span>arr2<span class="token punctuation">.</span>length<span class="token punctuation">]</span> <span class="token operator">=</span> arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>     <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>   <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>   <span class="token keyword">return</span> arr2<span class="token punctuation">;</span> <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span> <span class="token keyword">var</span> arr1 <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">15</span><span class="token punctuation">,</span> <span class="token number">6</span><span class="token punctuation">,</span> <span class="token number">10</span><span class="token punctuation">,</span> <span class="token number">12</span><span class="token punctuation">,</span> <span class="token number">13</span><span class="token punctuation">,</span> <span class="token number">9</span><span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token keyword">var</span> result <span class="token operator">=</span> <span class="token function">filter2</span><span class="token punctuation">(</span>arr1<span class="token punctuation">,</span> <span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">;</span> console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>result<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><blockquote><blockquote><p>封装成方法：</p></blockquote></blockquote><pre><code>function filter(arr, fn) &#123;   var arr2 = [];   var len = arr.length;   for (var i = 0; i &lt; len; i++) &#123;     // value-arr[i]&gt;0     if (fn(arr[i], value) &gt; 0) &#123;       arr2[arr2.length] = arr[i];     &#125;   &#125;   return arr2; &#125; function fn1(a, b) &#123;   // a=arr[i],b=value   return a - b; &#125; function fn2(a, b) &#123;   // a=arr[i],b=value   return b - a; &#125; //测试：改变value、arr，选择范围 //   比10更大的 var arr1 = [1, 15, 6, 10, 12, 13, 9]; var value = 10; var moreMax = filter(arr1, fn1); console.log(moreMax); //   比8更小的 var value = 8; var moreMin = filter(arr1, fn2); console.log(moreMin);</code></pre><ol start="4"><li>函数作为参数的常见 API<blockquote><ul><li>在后期的学习中，我们经常会碰到方法的参数是一个函数，所以这个点一定要理解透。<blockquote><p>学好一个 API，本质就是掌握以下三点：</p><ul><li>这个 <code>API</code> 方法的<strong>主要功能</strong>是什么。</li><li>作为<strong>函数参数的函数</strong>，他的功能是什么，他的参数是什么，有什么用。</li><li>了解 API 方法，<strong>内部</strong>大概是如何实现的。</li></ul></blockquote></li></ul></blockquote></li></ol><blockquote><ul><li>以下是数组中常见的方法，其参数是一个函数</li></ul></blockquote><pre><code>// 排序函数sort(function(a,b)&#123;    return a-b;&#125;)&gt;// 返回数组中满足条件的元素组成一个新数组（过滤数组中不满足条件的）filter(function(element, index, array) &#123;    return element &gt;10;&#125;&gt;// 返回满足条件的 第一个元素find(function(element) &#123;    return element &gt;10;&#125;)</code></pre><pre><code>// 定义数组var arr = [1, 3, 34, 5, 20, 68, 56];&gt;// 返回数组中所有大于10的元素组成的新数组var result = arr.filter(function (value) &#123;  return value &gt; 10;&#125;);console.log(result); // [34, 20, 68, 56]&gt;// 返回数组中第一个大于10的元素var result2 = arr.find(function (value) &#123;  return value &gt; 10;&#125;);console.log(result2); // 34&gt;// 数组升序排序arr.sort(function (a, b) &#123;  return a - b; // a-b 升序  b-a 降序&#125;);console.log(arr); //  [1, 3, 5, 20, 34, 56, 68]</code></pre><p><strong>强烈建议</strong></p><blockquote><ul><li>在学习相关 API 时，如果 API 中的参数是一个函数，可以尝试自己去实现这个方法。</li><li>只有这样，你未来在应用这个 API 时，才能保持最大的灵活性，把优势发挥到最大。</li></ul></blockquote><h3 id="六、作用域和作用域链"><a href="#六、作用域和作用域链" class="headerlink" title="六、作用域和作用域链"></a>六、作用域和作用域链</h3><blockquote><p>以下关于作用域和作用域链，我们并不涉及底层执行原理，底层执行原理在对象讲完后再讲。<br><strong>作用域：</strong></p><ul><li>可以理解为一套规则，这套规则规定了变量的作用范围。在 <code>JS</code> 中我们就是根据这套规则来查找变量的。</li></ul></blockquote><ol><li>作用域的分类<blockquote><p>JS 中有 3 种类型作用域：全局作用域、函数作用域、块级作用域（ES6 中新增）<br><strong>全局作用域：</strong></p><ul><li>直接编写在<code>&lt;script&gt;</code>标签中的<code>JS</code>代码<strong>或</strong>单独的<code>JS</code> 文件中代码，都是在全局作用域</li><li>声明在全局作用域中的变量为<strong>全局变量</strong></li></ul></blockquote></li></ol><pre class=" language-js"><code class="language-js"><span class="token operator">></span><span class="token operator">&lt;</span>script<span class="token operator">></span>  <span class="token keyword">var</span> a <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span>  <span class="token keyword">function</span> <span class="token function">fn</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span><span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>  <span class="token keyword">function</span> <span class="token function">fn2</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>    <span class="token keyword">var</span> b <span class="token operator">=</span> <span class="token number">3</span><span class="token punctuation">;</span>  <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span><span class="token operator">></span><span class="token operator">&lt;</span><span class="token operator">/</span>script<span class="token operator">></span></code></pre><blockquote><ul><li>a是全局变量，fn和fn2是全局变量也称全局函数</li></ul></blockquote><p><strong>函数作用域：</strong></p><blockquote><ul><li>函数作用域，也称为局部作用域，所有写在<strong>函数内部</strong>的代码，就是在函数作用域中。</li><li>声明在函数作用域中的变量为<strong>局部变量</strong></li></ul></blockquote><pre><code>var a = 2;  function fn() &#123;&#125;  function fn2() &#123;    var b = 3;    function fn3() &#123;      console.log(&quot;fn3中&quot;);    &#125;  &#125;</code></pre><blockquote><ul><li>fn2函数体中的变量 b，函数fn3 都是在函数作用域中</li></ul></blockquote><p><strong>块级作用域</strong>： </p><blockquote><ul><li>使用 let 或 const 关键字声明的变量，会形成块级作用域，暂不做介绍，等学到 ES6 时再讲</li></ul></blockquote><ol start="2"><li>作用域中变量访问权限<blockquote><ul><li>在<strong>全局</strong>作用域中，是<strong>没有办法</strong>访问到<strong>函数</strong>作用域中的变量（局部变量）（除闭包外）</li></ul></blockquote></li></ol><pre><code>var a = 2; // 全局作用域中function fn() &#123;  var b = 3; // 函数作用域中&#125;// 全局作用域是不能访问函数作用域中变量console.log(b); // Uncaught ReferenceError: b is not defined</code></pre><blockquote><ul><li>在<strong>函数</strong>作用域中，是<strong>可以</strong>访问全局作用域中的变量（全局变量）</li></ul></blockquote><pre><code>var a = 2; // 全局作用域function fn() &#123;  var b = 3; // 函数作用域  console.log(a); // 2  函数作用域，是可以访问全局作用域中的变量&#125;fn();</code></pre><ol start="3"><li>作用域链<blockquote><ul><li>当在一个函数内部嵌套一个函数时，就会发生作用域的嵌套。其<strong>内部函数</strong>可以访问到<strong>外层函数</strong>和<strong>全局作用域</strong>中的变量，其就是沿着作用域链<strong>一层一层</strong>来查找的。</li><li>你可以把作用域理解为，当函数发生嵌套时，内层函数会沿着嵌套的作用域一层层往外查找变量，这种查找方式就好比作用域形成了一个链条，故称为作用域链查找。</li></ul></blockquote></li></ol><ul><li><strong>作用域链查找规则</strong><blockquote><ul><li>在函数作用域中，操作一个变量时，会由当前函数作用域向外层作用域寻找变量</li><li>如果在<strong>当前作用域</strong>中能找到，就直接使用</li><li>如果找不到就向<strong>上一层</strong>作用域中寻找，找到就直接使用</li><li>如果一直找到<strong>全局作用域</strong>中依然找不到，则会报错。</li></ul></blockquote></li></ul><pre><code>var a = 1;function fn() &#123;  var b = 2;  console.log(a); // 1  function fn2() &#123;    var c = 3;    console.log(b); // 2    console.log(c); // 3  &#125;  fn2();&#125;fn();&gt;// 代码从上往下执行，当fn()被执行后，就会执行fn函数体中的代码，当执行到console.log(a)时，在当前函数作用域中，没有变量a，其就会往fn函数的外层作用域，即全局作用域中去查找，找到a=1,然后在控制台打印1// 接着执行fn2(),当执行到console.log(b)，他会先在当前作用域中找，找不到，则往外层作用域中找，最后在fn函数作用域中找到，b=2,直接使用值，在控制台输出2// 接着执行console.log(c),首先在当前作用域找，找到了c=3，则直接在控制台输出3</code></pre><ul><li><strong>遮蔽效应</strong><blockquote><ul><li>所谓的遮蔽效应是指，如果函数中定义了和全局同名的变量，则<strong>函数内</strong>的变量会将全局的变量“遮蔽”</li></ul></blockquote></li></ul><pre><code>var a = 2;function fn() &#123;  var a = 3;  console.log(a); // 3&#125;fn();</code></pre><ul><li><strong>形参也是局部变量</strong></li></ul><pre><code>var a = 12;  function fn(a) &#123;    //形参相当于 var a;    console.log(a); // 8  &#125;  fn(8);  console.log(a); // 12</code></pre><ul><li><strong>特殊的全局变量</strong><blockquote><ul><li><strong>非严格模式</strong>下,在函数里没有用 <code>var</code> 关键字声明的变量，是<strong>全局变量</strong> (但严格模式下会报错)</li></ul></blockquote></li></ul><pre><code>function fn() &#123;  a = 4;&#125;fn(); // 函数调用后，a全局变量会被创建console.log(a, window.a); // 4 4</code></pre><pre><code>function fn() &#123;  &quot;use strict&quot;;  a = 4;&#125;fn(); console.log(a, window.a); // ncaught ReferenceError: a is not defined</code></pre><ol start="4"><li>严格模式<blockquote><p>在 ES5 中增加了严格模式概念，在严格模式下，之前的一些不规范的写法在这种模式下会被处理掉，甚至会直接抛出错误。<br><strong>为什么使用严格模式 ？</strong></p><ul><li>严格模式消除了 JavaScript 语法的一些不合理、不严谨之处，减少一些怪异行为</li><li>消除代码运行一些不安全之处，保证代码运行的安全</li><li>提高代码编译效率，增加运行速度</li><li>为未来新版本的 JavaScript 做好铺垫</li></ul></blockquote></li></ol><ul><li>对<strong>整个</strong> JS 代码开启严格模式:<blockquote><ul><li>在所有 JS 代码的<strong>最前面</strong>加上”use strict”</li></ul></blockquote></li></ul><pre class=" language-js"><code class="language-js"><span class="token operator">></span><span class="token operator">&lt;</span>script<span class="token operator">></span>  <span class="token comment" spellcheck="true">// 'use strict ' 是一个预处理执令，告诉JS引擎启用严格模式</span>  <span class="token string">"use strict"</span><span class="token punctuation">;</span>  a <span class="token operator">=</span> <span class="token number">6</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 在严格模式下，定义变量必需用var关键词</span>  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// Uncaught ReferenceError: a is not defined</span><span class="token operator">></span><span class="token operator">&lt;</span><span class="token operator">/</span>script<span class="token operator">></span></code></pre><ul><li><strong>单独指定</strong>一个函数在严格模式下执行<blockquote><ul><li>只需要把”use strict”放在函数体的最前面。函数体中的代码就需要遵顺严格模式</li></ul></blockquote></li></ul><pre><code>c = 4;console.log(c); // 4&gt;function b() &#123;  &quot;use strict&quot;; // 严格模式只能函数体内有效  a = 4;  console.log(a); // Uncaught ReferenceError: a is not defined&#125;b();</code></pre><ol start="5"><li><p>在严格模式下：</p><blockquote><ul><li>变量必须<strong>先声明，再使用</strong>（声明变量用 var、const、let）</li><li>在严格模式中，全局作用域中的函数内部 <code>this</code> 默认指向 <code>undefined</code><ul><li>而在非严格模式中，全局作用域中的函数内部 this 默认指向 <code>window</code></li></ul></li><li>函数参数不能重名<ul><li>非严格模式下，允许重复变量命名</li></ul></li><li>禁止使用 <code>with</code></li></ul></blockquote></li><li><p>静态作用域和动态作用域</p><blockquote><ul><li>静态作用域：又称词法作用域，是指作用域在词法阶段就被确定了<strong>（函数定义的位置就决定了函数的作用域）</strong>，以后是不会改变。</li><li>动态作用域：函数的作用域在函数调用时才决定的。<blockquote><p>特别注意：Javascript采用的是词法作用域 ( 静态作用域 )</p></blockquote></li></ul></blockquote></li></ol><pre><code> var a = 3; var b = 4; function fn(a) &#123;   function fn2(b) &#123;     fn3(b); //fn3(4)=4     fn3(); //undefined   &#125;   function fn3(b) &#123;     console.log(b); //4   &#125;   fn2(b); //b=4 &#125; fn(a); //a=3</code></pre><ol start="7"><li>测试题</li></ol><pre><code> var a = 3; var b = 4; function fn(a) &#123;   function fn2(b) &#123;     var b = 2;     console.log(a); //3     fn3(b); //b=2     fn3(); //undefined     fn4();   &#125;   function fn3(b) &#123;     console.log(b); //2   &#125;   function fn4() &#123;     console.log(b); //4   &#125;   fn2(b); //b=4 &#125; fn(a); //a=3</code></pre><pre><code> var a = 1; var b = 3; var c = 2; function fn(a) &#123;   var b = 3;   console.log(a, b);//1,3   function fn2(b) &#123;     //b=c=2     var c = 4;     console.log(a);//1     console.log(b);//2     console.log(c);//4   &#125;   fn2(c);//c=2 &#125; fn(a);//a=1</code></pre><h3 id="七、变量提升与函数声明提升"><a href="#七、变量提升与函数声明提升" class="headerlink" title="七、变量提升与函数声明提升"></a>七、变量提升与函数声明提升</h3><blockquote><p>以下关于变量和函数提升，我们并不涉及底层执行原理，底层执行原理在对象讲完后再讲。</p></blockquote><ul><li>在讲解变量提升与函数声明提升前，我们先来看下面这一段代码</li></ul><pre><code>console.log(a); // undefinedfn(); // undefinedvar a = 2;console.log(a); // 2function fn() &#123;  console.log(a);&#125;fn(); // 2console.log(c);//报错</code></pre><p><strong>我们都知道</strong></p><blockquote><ul><li><code>Javascript</code> 代码是按顺序从上往下执行的，若按这个逻辑来理解的话<ul><li>当执行到第 1 行时，由于a这个变量还没有被声明，那肯定是要报错的，但这里没有报错，而是输出了<code>undefined</code></li><li>同理，当执行到第 2 行时，fn 这个函数还没有声明，那肯定也会报错，但同样没有报错，输出了<code>undefined</code></li></ul></li><li>但是当我们使用全程<strong>没有声明</strong>的c时，则直接报错</li></ul></blockquote><p><strong>由此我们可以得出如下三个结论：</strong></p><blockquote><ul><li>JS 在执行过程中，若使用了<strong>未声明</strong>的变量，那 JS 执行就会<strong>报错</strong></li><li>如果在一个变量<strong>声明之前使用他</strong>，不会报错，但输出值为 <code>undefined</code></li><li>如果在一个函数<strong>声明前</strong>使用它，不会出错，<strong>可以正常执行</strong></li></ul></blockquote><ol><li>变量提升和函数提升<blockquote><ul><li>js是边编译，边执行的，所以他在执行js代码前，有一个预编译的过程</li></ul></blockquote></li></ol><ul><li>变量提升<blockquote><ul><li>是指使用 var 关键字声明的变量会被提升到当前作用域的最顶部</li><li>变量提升，提升的是变量，变量提升后，变量的默认值是undefined</li></ul></blockquote></li><li>函数提升<blockquote><ul><li>是指使用函数声明创建的函数，其也会被提升到当前作用域的最前面</li><li>这里要区分函数声明和函数表达式</li></ul></blockquote></li></ul><pre><code>console.log(a);b();var a = 2;function b() &#123;  console.log(&quot;要注意我喽！&quot;);&#125;&gt;// 上面代码，会先把带var声明的变量和用function声明的函数，提升到当前作用域的最前面// 提升后代码其形式如下：var a;function b() &#123;  console.log(&quot;要注意我喽！&quot;);&#125;console.log(a);b();a = 2;&gt;// 提升后，其代码执行流程如下：// - 代码从上往下执行// - 执行到第1行，a的默认值是undefined// - 执行到第2行，是函数声明，啥也不做，往下继续执行// - 执行到第5行，打印a,，结果是undefined// - 执行到第6行，调用函数，函数体中打印  **”要注意我喽！“**</code></pre><ol start="2"><li>函数提升，区分函数声明与函数表达式<blockquote><ul><li>函数声明：<code>function b()&#123;&#125;;</code></li><li>函数表达式：<code>var a=function b()&#123;&#125;;</code></li></ul></blockquote></li></ol><pre><code>console.log(a);console.log(b);b();a();var a = function () &#123;  console.log(&quot;我在a函数中&quot;);&#125;;function b() &#123;  console.log(&quot;我在b函数中&quot;);&#125;&gt;// 首先把var和function声明的函数，提升到当前作用域最前面，提升后代码如下：var a;function b() &#123;  console.log(&quot;我在b函数中&quot;);&#125;console.log(a);console.log(b);b();a();a = function () &#123;  console.log(&quot;我在a函数中&quot;);&#125;;&gt;// 提升后代码，代码从上往下执行// 执行到console.log(a); 在控制台输出 undefined,因为此时a声明了，但没有赋值,默认值为undefined// 执行到console.log(b); 在控制台输出整个 b的函数声明// 执行到 b() ，调用函数,在控制台输出  &quot;我在b函数中&quot;// 执行到a()，因为些时a还是undefined，所以没有办法调用，即报错</code></pre><ol start="3"><li>函数提升优先级<strong>高于</strong>变量提升<blockquote><p><strong>在同一作用域下</strong></p><ul><li>如果出现<strong>同名的</strong>函数和变量，则在变量和函数提升时，会以<strong>函数</strong>为主</li><li>同名的函数在函数声明提升时，写在后面的会<strong>覆盖</strong>前面的</li></ul></blockquote></li></ol><p><strong>同名的函数</strong></p><pre><code>a(); // 2function a() &#123;  console.log(&quot;1&quot;);&#125;function a() &#123;  console.log(&quot;2&quot;);&#125;a(); // 2//预编译之后：//后面的覆盖前面的function a() &#123;  console.log(&quot;2&quot;);&#125;a();a();</code></pre><p><strong>同名的变量和函数</strong></p><pre><code>console.log(a);a();function a() &#123;  console.log(&quot;a中&quot;);&#125;var a = 3;console.log(a);a = 4;console.log(a);&gt;// 上面代码在执行前，变量和函数声明提升后代码如下：function a() &#123;  console.log(&quot;a中&quot;);&#125;console.log(a);a();a = 3;console.log(a);a = 4;console.log(a);// - 代码从上往下执行// - 执行到console.log(a)时，打印函数a// - 执行到a()时，调用函数，执行函数体中代码，输出 &#39;a中&#39;// - a=3，给a重赋值，console.log(a)  打印出 3// - a=4,给a重新赋值，console.log(a),打印出4</code></pre><blockquote><blockquote><p>注意第一个<code>console.log(a);</code>打印出的是函数</p></blockquote></blockquote><ol start="4"><li>测试题1</li></ol><pre><code>console.log(a);a();function a() &#123;  console.log(&quot;a1&quot;);&#125;var a = 2;function a() &#123;  console.log(&quot;a2&quot;);&#125;var b = a;console.log(b);&gt;//预编译后：function a() &#123;  console.log(&quot;a2&quot;);&#125;var b;console.log(a);//函数aa();//&quot;a2&quot;var a = 2;b = a;console.log(b);//b=a=2</code></pre><blockquote><blockquote><p>注意<code>var a=2;</code>由于优先级低，所以不会被预编译(并不代表他不会被执行)，但是，当执行到它时，会覆盖前面的a，此时a就由函数变成了基本数据类型。</p></blockquote></blockquote><ol start="4"><li>测试题2</li></ol><pre><code>console.log(a);a();function a() &#123;  console.log(&quot;a1&quot;);&#125;var a = 2;function a() &#123;  console.log(&quot;a2&quot;);&#125;console.log(a);var a = function () &#123;  console.log(&quot;a3&quot;);&#125;;console.log(a);&gt;&gt;预编译后：function a() &#123;  console.log(&quot;a2&quot;);&#125;console.log(a);//函数aa();//&quot;a2&quot;var a = 2;//覆盖aconsole.log(a);//2var a = function () &#123;  console.log(&quot;a3&quot;);&#125;;//覆盖aconsole.log(a);//函数a</code></pre><h3 id="八、算法的核心理论"><a href="#八、算法的核心理论" class="headerlink" title="八、算法的核心理论"></a>八、算法的核心理论</h3><blockquote><p>算法有好有坏，判断算法好的重要标准就是算法的复杂度。</p></blockquote><ol><li>算法复杂度<blockquote><ul><li>算法复杂度： 是指程序执行时需要的<strong>计算量</strong>（计算时长）和<strong>内存空间</strong> （和代码是否简洁无关）</li><li>计算量： 是指<strong>时间复杂度</strong>，也就是计算一个算法运行得到结果所花的时间</li><li>内存空间： 是指<strong>空间复杂度</strong>，也就是计算一个算法运行得到结果所占用的内存空间的大小<blockquote><p>时间复杂度和空间复杂度 是衡量算法好环的两个非常重要的标准</p></blockquote></li></ul></blockquote></li></ol><ul><li><p>复杂度的概念</p><blockquote><ul><li>不管是空间复杂度，还是时间复杂度，这个复杂度，他指的是一个<strong>数量级</strong>（方便 记忆和推广）</li><li>他不是具体的数字，因为没办法计算。因为一个算法，他到底耗时多少，占用多少内存空间，多少次 CPU 的计算，我们没法精准的计算。</li><li>我们说，如果不能精准的去算，但是可以粗略的去计算和判断。这个粗略的方式就是我们提到的数量级的概念。</li></ul></blockquote></li><li><p>数量级概念</p><blockquote><ul><li>所谓的数量级，指数量的尺度或大小的级别，他是一个数的<strong>区间范围</strong>。</li></ul></blockquote></li></ul><ol start="2"><li>时间复杂度<blockquote><ul><li>如果代码还没有运行，我怎么能预知代码运行所花的时间呢？而且受<strong>运行环境</strong>和<strong>输入规模</strong>的影响，代码的绝对执行时间是无法预估的，但是我们可以预估代码的<strong>基本操作</strong>执行次数</li><li>我们根据代码的<strong>执行次数</strong>，来判断算法的时间复杂度，他分为以下几个等级：<img src="数量级.png"></li></ul></blockquote></li></ol><table><thead><tr><th>时间复杂度</th><th>说明</th></tr></thead><tbody><tr><td>O(1)</td><td>表示执行次数是可数的，同时和输入量<strong>无关</strong>。无论执行次数是 1、1000，10000，只要是可数的，同时和输入量无关，都不影响它的级别</td></tr><tr><td>O(logn)</td><td>执行次数是输入量（输入数据量）的<strong>对数</strong>。比如输入量是 100，计算量是 10，因为 10<sup>2</sup>是 100；当输入量是 1 亿时，计算量是 1 万 因为 10000<sup>2</sup>是 1 亿</td></tr><tr><td>O(n)</td><td>执行次数和输入量（输入数据量）是<strong>“一样”</strong>的，这里的一样，并不是说完全相等，是指同等级别增加。比如输入量是 n，计算量是 1n,2n,100n，那都属于这个等级。</td></tr><tr><td>O(n<code>*</code>logn)</td><td>执行次数&#x3D;数据量<code>*</code>数据量的对数 &#x3D; n<code>*</code>logn</td></tr><tr><td>O(n<sup>2</sup>)</td><td>执行次数&#x3D;输入量的平方，输入 10，执行 100 次，输入 100，执行 10000 次</td></tr></tbody></table><ul><li><strong>O(1)级别-时间复杂度</strong><blockquote><ul><li>只要是我们<strong>能够识别</strong>出来的一个计算量，同时和输入量<strong>无关</strong>，那他复杂度就是<code>O(1)</code></li><li>比如，不管输入量是多少，执行次数都是<strong>固定的</strong> 1 次或 1000 次或 10000 万，都属于<code>O(1)</code>级别</li></ul></blockquote></li></ul><pre><code>var arr = [1, 2, 3, 4]; // arr可以是 arr=[1,2,3,4,5,6,7,8,.....1000] 等function fn(arr) &#123;  console.log(arr[0]);&#125;// 时间复杂度 O(1)级别// 不管arr 数组长度是多少，我的计算量都是1次，是可数的，不受输入量影响</code></pre><ul><li><p><strong>O(logn) 级别-时间复杂度</strong></p><blockquote><ul><li>执行次数是输入量（数据量）的<strong>对数</strong>(折半)</li><li>比如输入量是 100，计算量是 10，因为 10<sup>2</sup>是 100，</li><li>当输入量是 1 亿时，计算量是 1 万 因为 10000<sup>2</sup>是 1 亿<br><strong>常见的二分法：</strong> 其时间复杂度就是这个级别，每一次执行次数都为原来的 1&#x2F;2</li></ul></blockquote></li><li><p><strong>二分查找-数组中的某个元素</strong></p><blockquote><p>在升序的数组<code>[1,2,4,5,7,12,15,18,30,32,45]</code>中，查找值为 15 的元素<br><strong>如果用二分查找，我们会如何查找</strong></p><ul><li>我们首先会找到数组中的中间一个元素 12</li><li>然后拿 15 与 12 对比，如果小于 12，则在 12 左边元素中查找，如果大于 12，则在 12 的右边元素中查找</li><li>如果没找到，按上面查找方式，继续查找<img src="二分法.png"></li></ul></blockquote></li></ul><blockquote><p><strong>二分查找：</strong></p><ul><li>每次查找，查找范围都会缩小为上一次查找范围的<code>1/2</code>，其执行执数是输入量的对数</li><li>这个级别的时间复杂度，随着数据量的暴增，其时间消耗越来越<strong>趋向平缓</strong>。</li></ul></blockquote><ul><li>O(n)级别-时间复杂度<blockquote><ul><li>执行次数和输入量（数据量）是 <strong>“一样”</strong> 的，这里的一样，并不是说完全相等，是指同等级别增加</li><li>比如：输入量是 n，计算量是 1n,2n,100n，那都属于这个等级</li></ul></blockquote></li></ul><pre><code>// 时间复杂度 O(n)级别function fn(arr) &#123;  for (var i = 0; i &lt; arr.length; i++) &#123;    console.log(arr[i]);    console.log(arr[i] + 10);  &#125;&#125;// 执行次数受 输入量的影响，同时是同等级别增加// 如果arr数组长度为10，执行20次，长度为100，执行200次，长度为10000，执行20000次</code></pre><ul><li>O(n*logn)级别-时间复杂度<blockquote><ul><li>执行次数 &#x3D; 数据量 * 数据量的对数 &#x3D; n * logn</li><li>这种级别的时间复杂度，通常<ul><li>外层是一个 for 循环，时间复杂度为O(n)；</li><li>for 循环里面，来一个二分查找，二分查找复杂度是 O(logn), 两者一组合，时间复杂度就是 O(n*logn)</li></ul></li><li>我们后面算法中讲到的快速排序，其时间复杂度就是<code>O(n*logn)</code>级别，因为代码过于复杂，目前不做演示，后面学到再说</li></ul></blockquote></li></ul><pre><code>// 以下代码没有任何实际的意义，只是用来简单理解O(n*logn)的时间复杂度var arr = [1, 2, 3, 4, 5, 6, 7, 8];for (var i = 0; i &lt; arr.length; i++) &#123;  for (j = i; j &gt; 1; j /= 2) &#123;    console.log(&quot;二分&quot;);  &#125;&#125;</code></pre><blockquote><blockquote><p>算法的时间复杂度，达到 <code>O(n*logn)</code>这个级别，只能算 ok，能接受，但肯定不是最优的</p></blockquote></blockquote><ul><li>O(n<sup>2</sup>)级别-时间复杂度<blockquote><ul><li>执行次数（计算量）是输入量的平方</li><li>输入量是 10，执行 100 次，输入 100，执行 10000 次</li><li>常见的双层嵌套 for 循环，就是这个级别的时间复杂度</li></ul></blockquote></li></ul><pre><code>// 时间复杂度 O(n^2)级别  n^2表示n的平方// 执行次数是输入量的平方// 如果n=10，则执行100次，如果n=100，则执行10000次function fn(n) &#123;  for (var i = 0; i &lt; n; i++) &#123;    for (var j = 0; j &lt; n; j++) &#123;      console.log(i + &quot;-&quot; + j);    &#125;  &#125;&#125;fn(10);</code></pre><blockquote><blockquote><p>算法时间复杂度，达到 O(n<sup>2</sup>)级别，几乎是没有办法用的，因为输入量越大，计算量暴增</p></blockquote></blockquote><ul><li>总结<blockquote><ul><li>当 n 的取值足够大时，其算法耗时时间从小到大依次为：<ul><li>O(1) &lt; O(logn) &lt; O(n) &lt; O(n*logn) &lt; O(n<sup>2</sup>)</li></ul></li><li>当然，在编程世界中，各种各样的算法，除了上面提到的，还有许多不同形式的时间复杂度，如下<ul><li>O(n<sup>3</sup>)、O(mn)、O(2n)、O(n!)</li></ul></li></ul></blockquote></li></ul><ol><li>空间复杂度<blockquote><ul><li><strong>空间复杂度：</strong> 是指计算一个算法运行得到结果所占用的内存空间的大小</li><li>这个比时间复杂度相对要容易些，因为在<strong>前端领域</strong>，我们相对来说是<strong>重时间，轻空间</strong>的。</li><li>因为前端需要的更多的是<strong>运行的速度更快</strong>，比如我们常说的性能优化，本质就是在追求在尽可能最短的时间内来完成页面的渲染到呈现等。</li><li>因为前端是运行在浏览器中，相对来说内存空间是完全足够用的。只有那些做嵌入式开发的，内存相对比较少，需要节约着来用，对空间复杂度的要求会更高<img src="数量级.png"></li></ul></blockquote></li></ol><table><thead><tr><th>等级</th><th>说明</th></tr></thead><tbody><tr><td>O(1)</td><td>输入量增大，并不会影响需要的空间;当然，输入量增大，本身输入量占的空间肯定是会变大的</td></tr><tr><td>O(logn)</td><td>所需内存空间为输入量内存空间的的对数;输入量占内存空间为 100k，则对应增加内存空间为 10k</td></tr><tr><td>O(n)</td><td>输入量增大，所需要的内存空间与输入量成正比;比如输入量所需空间为 n，则相应的内存空间也会增到 1n，2n，3n 等，都属于 O(n)级别</td></tr><tr><td>O(n*logn)</td><td>所需内存空间 &#x3D; 输入量空间 * 输入量空间的对数</td></tr><tr><td>O(n<sup>2</sup>)</td><td>输入量增大，其所需要的内存空间为原来的平方；如：输入量所占内存空间为 n，则其内存空间会增加到 n<sup>2</sup></td></tr></tbody></table><ul><li>O(1)级别-空间复杂度<blockquote><ul><li>输入量增大，并不会影响<strong>需要的</strong>空间</li></ul></blockquote></li></ul><pre><code>// 空间复杂度为 O(1)// 输入量增大，并不会影响所需要的空间，不管arr多大，则变量a,b对应空间相对稳定function fn(arr) &#123;  var a = arr[1];  var b = arr[2];&#125;</code></pre><blockquote><ul><li>并不是说<code>arr</code>长度的增加，所需要的内存不会增加</li><li>而是说函数体里声明的a、b变量所需要的空间不会随输入量的增大而增加</li></ul></blockquote><ul><li>O(n)级别- 空间复杂度<blockquote><ul><li>输入量增大，所需要的内存空间与输入量成正比</li><li>比如：常见的数组拷贝(深克隆)，输入的数组变大，那拷贝到对应的数组也就会变大</li></ul></blockquote></li></ul><pre><code>// 空间复杂度为O(n)// 数组arr的输入量变大，其对应 arr2占用的内存也就相应变大, 这里假设arr中存的都是基本数据类型function deepClone(arr) &#123;  // ......  var arr2 = []; //  占用的内存空间  for (var i = 0; i &lt; arr.length; i++) &#123;    arr2.push(arr[i]);  &#125;&#125;</code></pre><ul><li>O(n<sup>2</sup>)级别- 空间复杂度<blockquote><ul><li>输入量增大，其所需要的内存空间为原来的平方</li><li>比如：常见的二维数组生成</li></ul></blockquote></li></ul><pre><code>// 空间复杂度 O(n2)// 当输入n为2时，所需要的空间为原来的4倍，当输入为7时，所需空间为原来的49倍function fn(n) &#123;  var arr = [];  for (var i = 0; i &lt; n; i++) &#123;    var arr2 = [];    for (var j = 0; j &lt; n; j++) &#123;      arr2[j] = j;      arr[i] = arr2;    &#125;  &#125;  console.log(arr);&#125;fn(7);</code></pre><ol start="4"><li>空间与时间的取舍<blockquote><ul><li>在前端这个领域，我们更注重时间复度，所以我们很多时候会牺牲一部分空间来换取时间。</li><li>如果实现同一个效果，有两种方法：<ul><li>方法一的时间复杂度 &lt; 方法二的空间复杂度</li><li>方法一的空间复杂度 &gt; 方法二的空间复杂度<br> 这个时候，我们会可能会选取方法一，因为前端更看重时间。当然在某些情况下，也有可能选择方法二，因为更看重空间内存的占用。具体情况以实际业务需求为主。<br><strong>重要提示：</strong></li></ul></li><li>程序员是必须掌握算法复杂度</li><li>如果你没有复杂度的概念和敏感度，写程序是非常危险的</li><li>代码功能测试正常，但数量大了，程序就会崩溃</li></ul></blockquote></li></ol><h3 id="九、递归与深克隆"><a href="#九、递归与深克隆" class="headerlink" title="九、递归与深克隆"></a>九、递归与深克隆</h3><ol><li>递归的定义和理解<blockquote><ul><li>所谓的递归 可以简单理解为一个函数的内部语句<strong>调用这个函数自身</strong>，一次一次的重复调用自身，直到函数执行到某一次时，因<strong>达到某种条件</strong>而终止了对自己的调用，然后返回最终结果。</li><li>递归是一种较为 高级的编程技巧，通常把一个大型复杂的问题层层转化为一个与原问题<strong>相似的规模较小的</strong>问题来求解 。</li></ul></blockquote></li></ol><ul><li>我们使用 5 的阶乘(factorial)来举例，了解什么是递归 ？<blockquote><ul><li>5！表示 5 的阶乘 5 的阶乘&#x3D;<code>5*4*3*2*1</code>; 4 的阶乘&#x3D;<code>4*3*2*1</code>; 3 的阶乘&#x3D;<code>3*2*1</code>;</li><li>转换思路： <code>5!=5*4!</code> <code>4!=4*3!</code> <code>3!=3*2!</code> <code>2!=2*1!</code> <code>1!=1</code><img src="递归-阶乘.png"></li></ul></blockquote></li></ul><pre><code>&gt;// 书写一个函数，这个函数内部自己会调用自己，从而形成递归// 函数的功能是计算n的阶乘，n的阶乘是 n*(n-1)的阶乘// n! = n * (n-1)!function factorial(n) &#123;  // 递归的出口，当n=1时，返回1  if (n == 1) return 1;  // 如果询问的不是1的阶乘，就返回 n * (n-1)  return n * factorial(n - 1);&gt;  // 三目运算符  // return n == 1 ? 1 : n * factorial(n - 1);&#125;&gt;var result = factorial(5); // 调用函数console.log(result); // 输出结果</code></pre><blockquote><blockquote><p>使用递归需要满足两个条件：</p></blockquote><ul><li>边界条件：确定递归何时终止，找到递归的终止条件。也称之为递归出口</li><li>递归模式：大问题如何分解为小问题，子问题需与原问题同样的事，且规模更小 。也称为递归体<br><strong>递归的简单理解：</strong></li><li>就是函数内部调用函数自身，达到某个条件之后，停止调用</li></ul></blockquote><ol start="2"><li>斐波那契数列(fibonacci)<blockquote><ul><li>斐波那契数列是这样的数列：<code>1,1,2,3,5,8,13,21</code> 。求第 n 项的斐波那契<strong>数列</strong><br><strong>找规律：</strong></li><li>第 1 项&#x3D;1</li><li>第 2 项&#x3D;1</li><li>第 3 项是&#x3D;第 1 项+第 2 项</li><li>第 4 项&#x3D; 第 2 项+第 3 项</li><li>依次类推，后面每一项都等于前两项之和<br><strong>求出第 n 项的值，并列出第n项的数列</strong></li></ul></blockquote></li></ol><ul><li><strong>递归法：</strong><blockquote><ul><li>求出第 n 项的值：<ul><li>递归出口： n&#x3D;1 时和 n&#x3D;2 时分别返回 1 1</li><li>递归模式：f(n)&#x3D;f(n-1) +f(n-2)</li></ul></li><li>求出 n 项的斐波那契数列：<ul><li>利用 for 循环结合递归，把每一项的值计算得到，然后拼接成字符串</li></ul></li></ul></blockquote></li></ul><pre><code>// 这个函数的功能是返回斐波那契数列中下标为n的那项的值function fibonacci(n) &#123;  // 数列的第1项和第2的项值是1  if (n === 1 || n === 2) return 1;&gt;  // 斐波那契数列的本质特征就是每一项，等于前面两项的和  return fibonacci(n - 1) + fibonacci(n - 2);&#125;&gt;  //  求出n项的斐波那契数列var result = &quot;&quot;; // 用来拼接每一项的值for (var i = 1; i &lt;= 10; i++) &#123;  result += fibonacci(i) + &quot;,&quot;;&#125;console.log(result);</code></pre><blockquote><ul><li>然而，这种做法的时间复杂度为2<sup>n</sup>，只要把值稍微改大点，电脑直接就崩溃了：<br><strong>递归版 - 时间复杂度</strong></li><li>我们假设，现在我们要找的是第 8 项的等差数列，那我们内部求出第 8 项的值，计算次数达到了2<sup>n</sup></li><li>再加上要求出整个数列，还要一次 for 循环，整个的级别已经远远超过 O(n<sup>2</sup>)了<img src="递归版斐波那契数列时间复杂度.png"></li></ul></blockquote><ul><li><strong>优化版——双指针法</strong><blockquote><ul><li>我们用两个变量分别来记录当前循环的<strong>前两项</strong></li><li>然后定义一个变量来计算当前项得结果，然后再更新下前两项的值，以便下一轮循环用到<blockquote><p>本次优化版本用到：双指针、字符串拼接</p></blockquote></li></ul></blockquote></li></ul><pre><code>// 1,1,2,3,5,8,13,21function fibnocci(n) &#123;  var n1 = 1;  var n2 = 1;  var item; // 临时存储每一项值  var str = &quot;&quot;; // 拼接字符串  if (n == 1) str = &quot;1&quot;;  if (n == 2) str = &quot;1,1&quot;;  if (n &gt;= 3) str = &quot;1,1&quot;;&gt;  for (var i = 3; i &lt;= n; i++) &#123;    item = n1 + n2; // 计算得到当前项    n1 = n2; // n1向右移    n2 = item; // n2 向右移    str += &quot;,&quot; + item; // 拼接得到的 斐波那契数列  &#125;  return str;&#125;console.log(fibnocci(15)); // 1,1,2,3,5,8,13,21,34,55,89,144,233,377,610</code></pre><blockquote><ul><li><strong>双指针版</strong></li><li>时间复杂度：整个过程下来，只有一层 for 循环，所以时间复杂度为 O(n)</li><li>空间复杂度为 O(n)，内存空间的占用，多了 <code>4</code> 个变量，其中 str 的空间占用受输入量 n 的影响最大，n 输入越大，str 的字符串越长。</li></ul></blockquote><ol start="4"><li>数组的深克隆<blockquote><ul><li>以下数组的克隆，只考虑<strong>数组中嵌套数组</strong>的情况，因为我们还没有学对象，等我们学完对象后，我们会再优化一个版本。<br><strong>深克隆函数功能</strong></li><li>用户希望在调用函数时，传入一个数组，然后就克隆一个和传入数组一模一样的数组出来。</li><li>这两个数组只是长得一样，但是两个完全独立的数组，互不干扰。即两个数组指向堆内存中的不同地址。</li></ul></blockquote></li></ol><pre><code>// 深克隆数组function deepClone(arr) &#123;  if (!Array.isArray(arr)) return;  var result = []; // 克隆成功后的结果数组  for (var i = 0; i &lt; arr.length; i++) &#123;    // 判断，如果是基本数据类型，则直接push到数组中    // 不是数组就如何，是数组如何    if (Array.isArray(arr[i])) &#123;      // 如果是数组,返回的数组是不是要push到上一个数组中去      result.push(deepClone(arr[i]));    &#125; else &#123;      result.push(arr[i]);    &#125;  &#125;  return result;&#125;&gt;var arr = [1, 2, 3, [&quot;A&quot;, &quot;B&quot;, [&quot;我&quot;, &quot;和&quot;, &quot;你&quot;]]];var arr2 = deepClone(arr); // 克隆数组console.log(arr2 === arr);arr2[3][2][0] = 1; // 更改数组中元素console.log(arr);console.log(arr2);</code></pre><p><strong>数组克隆 - 递归算法复杂度</strong></p><blockquote><ul><li>时间复杂度为 <code>O(n)</code>，只有一层 for 循环，其输入量与执行次数成<strong>正比</strong></li><li>空间复杂度为 <code>O(n)</code>，返回结果数组会<strong>受输入量</strong>的影响，输入量越大，返回结果数组越大<br>同时在中间会产生一些临时的数组。</li></ul></blockquote>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JS核心知识点（四）</title>
      <link href="/2023/12/03/JS%E6%A0%B8%E5%BF%83%E7%9F%A5%E8%AF%86%E7%82%B9%EF%BC%88%E5%9B%9B%EF%BC%89/"/>
      <url>/2023/12/03/JS%E6%A0%B8%E5%BF%83%E7%9F%A5%E8%AF%86%E7%82%B9%EF%BC%88%E5%9B%9B%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<span id="more"></span><blockquote><p>在数据类型那一章节，我们知道 JS 中数据类型分为：基本数据类型和引用数据类型</p><ul><li>基本数据类型有 7 种：Number、String、Boolean、null、undefined、Bigint、Symbol</li><li>引用数据类型（Object 对象类型）有：Array、Function、Date、Math、RegExp 等对象<br>本章节我们要学习的数组 Array 对象就是引用数据类型，接下来我们会从以下三个部分来展开讲解</li><li>数组的语法和基本用法</li><li>冒泡排序（基础版，中级版，最优版）</li><li>引用数据类型和基本数据类型</li></ul></blockquote><h3 id="一、数组的语法和基本用法"><a href="#一、数组的语法和基本用法" class="headerlink" title="一、数组的语法和基本用法"></a>一、数组的语法和基本用法</h3><blockquote><ul><li>编程过程中，我们经常会遇见处理 “一组数值” 的情况</li><li>按照之前的学习，我们只能定义 10 个变量来分别存储每个数值，但这样的方式显然是不合理的<ul><li>因为我们是没法看出这些值之间有什么相互关系和作用</li><li>其次我们在定义和使用这些数据时也特别麻烦</li></ul></li><li>所以我们需要有一种新的数据结构来存储这样一组具有相关性的数值，接下来要讲到的 <code>Array 数组</code>，就符合这一特点。</li></ul></blockquote><h4 id="什么是数组"><a href="#什么是数组" class="headerlink" title="什么是数组"></a>什么是数组</h4><blockquote><ul><li>数组（Array），简单理解为是指<strong>一组数据的集合</strong>，用来存储一组相关的数据；</li><li>数据可以是<strong>任意的数据类型</strong>；</li><li>每种高级编程语言中都有数组，它是非常重要的一种数据结构。</li></ul></blockquote><h4 id="创建数组"><a href="#创建数组" class="headerlink" title="创建数组"></a>创建数组</h4><blockquote><p>在 <code>ES5</code> 标准下，创建数组有以下 2 种形式：</p><ul><li>数组字面量方式创建数组 和 new Array() 方式创建数组</li></ul></blockquote><ol><li>数组字面量方式创建数组<blockquote><ul><li>一个封闭在方括号对<code>[]</code>中的包含有<strong>零个或多个</strong>数据</li><li>数组中的每个数据被称作<strong>元素</strong>，元素可以是<strong>任意的</strong>数据类型。</li></ul></blockquote></li></ol><pre><code>// 使用数组字面量方式创建了一个空数组,arr是数组名var arr = [];&gt;// 使用数组字面量方式创一个带初始值的数组// A，B，C，D 称为数组元素（项），数组的长度为4var arr = [&quot;A&quot;, &quot;B&quot;, &quot;C&quot;, &quot;D&quot;];&gt;// 使用数组字面量方式创一个带初始值的数组，数组长度为6// 数组元素(项)可以是任意数据类型var arr = [1, &quot;name&quot;, null, undefined, &#123;&#125;, function () &#123;&#125;]; // 一般不会这样用，仅当前了解</code></pre><blockquote><blockquote><p>数据创建同时赋值，称为数组初始化<br><strong>注意：</strong></p></blockquote><ul><li><code>var arr=[1,2,3,,4];</code>长度是5</li><li><code>var arr=[1,2,3,4,];</code>长度是4<blockquote><p>有空元素的数组，称为<strong>稀疏数组</strong></p></blockquote></li></ul></blockquote><ol start="2"><li><code>new Array()</code> 方式创建数组<blockquote><ul><li>在实际开发中，这种方式用的少，大家只要了解即可</li><li>建议大家掌握了数组字面量创建方式，再来了解这种方式<blockquote><p>注意：</p></blockquote></li><li>不支持<code>var arr=new Array(1,2,,3);</code>的写法</li><li><code>var arr=new Array(1,2,);</code>，长度是2</li></ul></blockquote></li></ol><blockquote><blockquote><p>括号内只有一个数字时，创建的是数组长度</p></blockquote></blockquote><pre><code>var arr = new Array(5);console.log(arr.length); // 5console.log(arr[0]); // undefined;//创建一个数组，数组长度为5 ，每一项为空，打印出来为undefined</code></pre><blockquote><blockquote><p>括号内是一个字符串时，是创建一个数组</p></blockquote></blockquote><pre><code>var arr = new Array(&quot;5&quot;);console.log(arr.length); // 1console.log(arr[0]); // 5// 创建一个数组，数组长度为1，同时赋初始值为‘5’</code></pre><blockquote><blockquote><p>括号内为多个值时，创建的是数组</p></blockquote></blockquote><pre><code>var arr = new Array(&quot;A&quot;, &quot;B&quot;, &quot;C&quot;);console.log(arr.length); // 3console.log(arr[0]); // A// 创建一个数组，数组长度为3，同时赋初始值为 &#39;A&#39;、&#39;B&#39;、&#39;C&#39;```#### 访问数组元素（项）&gt;- 数组的每一项都有索引（下标），索引是从 0 开始的正整数，从左至右，从0开始&gt;- 我们通过 数组名`[索引]`的方式来访问数组中元素，如下</code></pre><p>var arr &#x3D; [“A”, “B”, “C”, “D”];<br>&#x2F;&#x2F; 通过索引来访问数组中元素<br>console.log(arr[0]); &#x2F;&#x2F; A<br>console.log(arr[1]); &#x2F;&#x2F; B<br>console.log(arr[2]); &#x2F;&#x2F; C<br>console.log(arr[3]); &#x2F;&#x2F; D</p><pre><code>#### 数组的长度&gt;- 数组的 `length` 属性，表示它的长度&gt;- 用`.length`的方式访问数组长度</code></pre><p>&#x2F;&#x2F; 创建数组<br>var arr &#x3D; [“A”, “B”, “C”, “D”];<br>&#x2F;&#x2F; arr.lenght 访问数组长度<br>console.log(arr.length); &#x2F;&#x2F; 4</p><pre><code>&gt;- 数组最后一项的下标= 数组长度- 1#### 修改数组项的值&gt;**方式一：**&gt;- 如果修改项的索引在0 到数组长度 -1 内，**正常修改值**</code></pre><p>var arr &#x3D; [1, 2, 3, 4, 5];<br>&#x2F;&#x2F; 更改第二项值，也就是下标为1的项的值<br>arr[1] &#x3D; “A”;<br>console.log(arr); &#x2F;&#x2F; [1, ‘A’, 3, 4, 5]</p><pre><code>&gt;**方式二：**&gt;- 如果修改项的索引不在0 到数组长度 -1 内，相当于**创建**这一项&gt;- 而且会**修改**数组的**长度**，同时在这个长度内**没有值的项都是空**，通过下标访问这些没有值的项时，结果是`undefined`;</code></pre><p>var arr &#x3D; [1, 2, 3, 4, 5];<br>var arr[9]&#x3D;’B’;<br>console.log(arr);<br>&#x2F;&#x2F; [1, ‘A’, 3, 4, 5, empty × 4, ‘B’]<br>console.log(arr.length); &#x2F;&#x2F; 10 数据长度变为10<br>console.log(arr[5]); &#x2F;&#x2F; undefined 下标为5的这一项，访问值为undefined</p><pre><code>&gt;**方式三：**&gt;- 先创建一个空数组，然后再赋值&gt;- 而且会根据索引修改数组长度，没有赋值的项都是空的，通过下标访问这些没有值的项时，结果是`undefined`;</code></pre><p>var arr &#x3D; [];<br>arr[0] &#x3D; 1;<br>arr[2] &#x3D; 2;<br>arr[5] &#x3D; 5;<br>console.log(arr.length); &#x2F;&#x2F; 6<br>console.log(arr); &#x2F;&#x2F; [1, empty, 2, empty × 2, 5]</p><pre><code>#### 访问数组注意事项1. 访问数组中不存在的项，不会报错，回返回undefined</code></pre><p>var arr &#x3D; [“A”, “B”, “C”, “D”];<br>console.log(arr[5]); &#x2F;&#x2F; undefined</p><pre><code>2. 数组项对应的值为空时，在访问时，返回undefined</code></pre><p>var arr &#x3D; [“A”, , “B”, “C”];<br>console.log(arr[1]); &#x2F;&#x2F; undefined</p><blockquote></blockquote><p>&#x2F;&#x2F; 这两种情况，要注意区分<br>var arr &#x3D; [“A”, undefined, “B”, “C”];<br>console.log(arr[1]); &#x2F;&#x2F; undefined</p><pre><code>3. 经典面试题：&gt;将数组的length设置为 0，取第一个元素会返回什么 ？</code></pre><p>var arr &#x3D; [1, 2, 3, 4, 5];<br>arr.length &#x3D; 0;<br>console.log(arr);<br>&#x2F;&#x2F;arr&#x3D;[],数组值清空<br>console.log(arr[0]);<br>&#x2F;&#x2F;undefined</p><pre><code>#### 数组的遍历&gt;- 所谓数组遍历，就是把数组中的每一项都访问一遍。就好比篮子里有 10 个苹果，一个一个拿 出来。&gt;- 至于拿出来做什么，这就要看实际的需求了。比如可以拿出来放在桌子上，什么都不做，也可以拿出来一个一个洗一下。&gt;- 这里我们利用 `for` 循环，把数组中的**每一项**拿出来，在控制台打印输出。&gt;   - for循环中的i是从 0 开始的，是计数器，当**索引**使用&gt;   - `arr[i]`就是访问数组中下标为i的那一项</code></pre><p>var arr &#x3D; [“A”, “B”, “C”, , , , “G”, “H”, “I”, ,];<br>for (var i &#x3D; 0; i &lt; arr.length; i++) {<br>  console.log(arr[i]);<br>}<br>&#x2F;&#x2F; 输出：A B C undefined undefined undefined G H I undefined</p><pre><code>#### 二维数组&gt;- 以**数组**作为**数组元素**的数组，即：&quot;数组的数组&quot;&gt;- 二维数组，可以认为是数组中的元素也是一个数组1. 创建二维数组</code></pre><p>var arr &#x3D; [<br>  [2, 5, 8],<br>  [11, 22, 33],<br>  [55, 88, 66],<br>  [23, 56, 89],<br>];<br>console.log(“数组的长度：” + arr.length); &#x2F;&#x2F; 4</p><pre><code>2. 访问数组的长度与值：&gt;- 外侧数组长度：`arr.length`&gt;- 内数组长度：`arr[i].length`,i是所访问数组的下标&gt;- 访问内侧数组的值：`arr[i][j]`</code></pre><p>var arr &#x3D; [<br>        [2, 5, 8],<br>        [11, 22, 33],<br>        [55, 88, 66],<br>        [23, 56, 89],<br>      ];<br>  console.log(arr.length); &#x2F;&#x2F;4<br>  console.log(arr[1].length); &#x2F;&#x2F;3<br>  console.log(arr[2][1]); &#x2F;&#x2F;88</p><pre><code>3. 循环遍历二维数组中的每一项</code></pre><p>var arr &#x3D; [<br>  [2, 5, 8],<br>  [11, 22, 33],<br>  [55, 88, 66],<br>  [23, 56, 89],<br>];<br>&#x2F;&#x2F; 循环输出二维数组中的每一个项<br>for (var i &#x3D; 0; i &lt; arr.length; i++) {<br>  for (var j &#x3D; 0; j &lt; arr[i].length; j++) {<br>    console.log(arr[i][j]);<br>  }<br>}<br>&#x2F;&#x2F; 最终输出结果 2 5 8 11 22 33 55 88 66 23 56 89</p><pre><code>#### 数组类型的检测1. 用`typeof`检测数组和对象，得到的是`object`</code></pre><p>typeof [1, 2, 3]; &#x2F;&#x2F; object<br>typeof { name: “清心老师”, age: 18 }; &#x2F;&#x2F; object</p><pre><code>2. 如果要区分数组和对象，我们可以用`Array.isArray()`来检测是否是**数组类型**&gt;- 如果Array.isArray()的返回值是true，就是数组类型，否则就不是</code></pre><p>Array.isArray([1, 2, 3]); &#x2F;&#x2F; true<br>Array.isArray({ name: “清心老师”, age: 18 }); &#x2F;&#x2F; false<br>Array.isArray([]); &#x2F;&#x2F; true</p><pre><code>### 二、数组相关实践应用1. 数组相关实践应用&gt;将数组[1, 43, 23, 8, 4, 6, 8, 22, 9]翻转过来</code></pre><p>var arr &#x3D; [1, 43, 23, 8, 4, 6, 8, 22, 9];<br>  var arr1 &#x3D; [];<br>  for (var i &#x3D; arr.length - 1; i &gt;&#x3D; 0; i–) {<br>    arr1[arr1.length] &#x3D; arr[i];<br>  }<br>  console.log(arr1);</p><pre><code>&gt;&gt;思考：&gt;- 我们如何在不增加新数组的情况下，在原数组上对数组进行翻转 ？2. 找出数组 [1, 43, 23, 8, 4, 6, 8, 22, 9] 中的最大值&gt;- 声明一个变量 `max`，用来保存数组中的最大值&gt;- 刚开始默认数组中的第一项为最大值，存入变量 max&gt;- 然后拿 max 与数组中**每一项**（除第一项）去做比较&gt;- 如果数组中值大于 max，就把这个数存到 max 变量中去，否则就继续往下比</code></pre><p>var arr &#x3D; [1, 43, 23, 8, 4, 6, 8, 22, 9];<br>var max &#x3D; arr[0]; &#x2F;&#x2F; max用来保存最大值，刚开始默认取数组中第一项为最大值<br>for (var i &#x3D; 0; i &lt; arr.length; i++) {<br>  if (max &lt; arr[i]) {<br>    max &#x3D; arr[i];<br>  }<br>}<br>console.log(“数组中的最大值为:” + max);</p><pre><code>3. 删除数组中指定元素&gt;要求删除数组[1, 4, 12, 6, 33, 15, 30, 5, 8];中的所有大于 10 的数&lt;img src=&quot;删除指定元素.png&quot;&gt;&gt;**开启两层循环**&gt;- **外层**循环把数组中所有数遍历出来与 10 做比较，当判断当前项值`&gt; 10` 时&gt;- 开启**内层**循环，用来**删除当前项**（从当前项开始，把后面的每一项，赋值给前一项，达到删除当前项效果）&gt;- 每次有删除项时，其数组的长度就会减 1，数组长度减 1，可以**把最后一项干掉**。&gt;- 删除当前项后，下次外层循环开始位置，又要从**当前删除项**的下标开始查找(删除后，该项后面的数就会往前移一位)</code></pre><blockquote><p>var arr &#x3D; [1, 4, 12, 6, 33, 15, 30, 5, 8];<br>&#x2F;&#x2F; 外层循环，把数组中每个数拿出来与10做比较<br>for (var i &#x3D; 0; i &lt; arr.length; i++) {<br>  if (arr[i] &gt; 10) {<br>    &#x2F;&#x2F; 把当前项后面的每一项，都赋值给前一项，达到删除当前项效果<br>    for (var j &#x3D; i; j &lt; arr.length; j++) {<br>      arr[j] &#x3D; arr[j + 1];<br>    }<br>    &#x2F;&#x2F; 删除一项后，数组的总长度就要减1，这样就把数组中最后一项给干掉了<br>    arr.length &#x3D; arr.length - 1;<br>    &#x2F;&#x2F; 保证删除项后，下次遍历从当前删除项的序号开始遍历<br>    i–;<br>  }<br>}<br>console.log(arr);</p></blockquote><pre><code>&gt;&gt;重点学习：&gt;&gt;   - 如何删除数组中元素&gt;&gt;   - 删除数组中元素后，对后续元素和数组带的影响&gt;&gt;   - 后面数组有提供相关删除数组中元素的方法，这里就是让大家学习这种思维方式。4. 随机生成指定范围内的颜色基础：</code></pre><p>var arr &#x3D; [“pink”, “khaki”, “skyblue”, “tomato”, “orange”, “orchid”];<br>    var len &#x3D; arr.length;<br>    color &#x3D; arr[(Math.random() * len) &gt;&gt; 0];<br>    console.log(color);</p><pre><code>&gt;当我们在做烟花效果时，我们需要随机为 100 个小圆或正方形产生（指定范围内的）不同颜色。```js&gt;&lt;style&gt;  .ball &#123;    width: 100px;    height: 100px;    border-radius: 50%;  &#125;&gt;&lt;/style&gt;&gt;&lt;body&gt;&gt;&lt;div class=&quot;ball&quot; id=&quot;J_ball&quot;&gt;&lt;/div&gt;&gt;&lt;script&gt;  // 获取id为ball的元素  var ball = document.getElementById(&quot;J_ball&quot;);  // 定义一组颜色，存入到数组中  var bgColor = [&quot;pink&quot;, &quot;khaki&quot;, &quot;skyblue&quot;, &quot;tomato&quot;, &quot;orange&quot;, &quot;orchid&quot;];  // 数组长度  var len = bgColor.length;  // Math.random() * (len) 产生 0- len-1之间的随机数  // Math.random() * (len) &gt;&gt; 0  去掉小数，只留下整数部分  ball.style.backgroundColor = bgColor[(Math.random() * len) &gt;&gt; 0];&gt;  &lt;/script&gt;&gt;&lt;/body&gt;</code></pre><h3 id="三、引用数据类型和基本数据类型的区别"><a href="#三、引用数据类型和基本数据类型的区别" class="headerlink" title="三、引用数据类型和基本数据类型的区别"></a>三、引用数据类型和基本数据类型的区别</h3><blockquote><p>我们知道在 JS 中数据分为：<strong>基本数据类型</strong> 和 <strong>引用数据类型</strong>两大类</p><ul><li>基本类型：number、boolean、string、undefined、null</li><li>引用类型：array、object、function、regexp（正则表达式） …<blockquote><p>那这两类数据类型在内存中是<strong>如何存储</strong>的呢 ？这就是我们接下来要讨论的重点。</p></blockquote></li></ul></blockquote><p><strong>先来看下面两段代码：</strong></p><pre><code>// 代码片段一var a = 10;var b = a;a = 20;console.log(a); // 20console.log(b); // 10</code></pre><pre><code>// 代码片段二var arr1 = [1, 2, 3, 4];var arr2 = arr1;arr1[0] = &quot;A&quot;;console.log(arr1[0]); // Aconsole.log(arr2[0]); // A</code></pre><p><strong>以上代码解读</strong></p><blockquote><ul><li>通过代码片段一，我们发现，当 b&#x3D;a，赋值完成后，后续对 a 的操作并不会对 b 产生影响。</li><li>而代码代码片段二中的数组就不一样，当 arr2&#x3D;arr1 且，我们对 arr1 的操作，直接影响了 arr2，为什么会出现这个情况呢？</li><li>这就涉及到 Javascript 的基础数据类型和引用数据类型在内存中是如何存储的。</li></ul></blockquote><ol><li>基本数据类型在内存中的存储<blockquote><ul><li>基本数据类型存储在<strong>栈空间</strong>中</li></ul></blockquote></li></ol><p><strong>基本数据类型赋值过程</strong></p><blockquote><ul><li>变量a 是基本数据类型, 当代执行到 <code>var a = 10</code> 时，在<strong>栈内存</strong>中开辟一块空间，把值 <code>10</code> 存入进去</li><li>当执行到 <code>var b = a</code> 时，把 a 的值 10,<strong>复制</strong>一份保存在 b 对应的内存空间中</li><li>当执行 <code>a = 20</code> 时，其本质是修改了<code>a</code>对应内存中的值，并<strong>不会</strong>影响到 b<img src="基本数据类型的存储.png"></li></ul></blockquote><ol start="2"><li>引用数据类型在内存中的存储<blockquote><ul><li><strong>栈内存</strong>中存着引用数据类型的<strong>地址</strong>，<strong>堆内存</strong>中存着引用数据类型的<strong>最终数据内容</strong>。</li></ul></blockquote></li></ol><p><strong>引用数据类型赋值的整个过程：</strong></p><blockquote><ul><li>变量<code>arr1</code><strong>声明</strong>后，首先会在<strong>栈内存</strong>开辟一块内存空间，然后在<strong>赋值时</strong>，再在<strong>堆内存</strong>中开辟一块空间，堆内存存放引用数据类型的数据，然后在堆中就会有一个存放数据的<strong>地址</strong>，把这个地址存入变量对应的栈内存中。</li><li><strong>栈内存</strong>中存着指向堆内存中数据的<strong>地址</strong>。</li><li>当代码执行到<code>arr2=arr1</code>时，这里是把<code>arr1</code>存入栈中的<strong>地址</strong>复制给了<code>arr2</code>，所以本质上arr1和arr2<strong>指向</strong>的是堆内存中的<strong>同一个值</strong>（数据）</li><li>所以当我们操作<code>arr1[0]=&#39;A&#39;</code>时，<code>arr2[0]</code>的值也是’A’</li></ul></blockquote><p><strong>结论：</strong></p><blockquote><ul><li>当我们把一个引用数据类型当做值来赋值时，是把它存在栈中的<strong>地址复制一份</strong>来赋值。</li><li>当我们访问引用数据类型时，是通过栈中的<strong>引用地址</strong>来访问到堆中的数据。<img src="引用数据类型的存储.png"></li></ul></blockquote><ol start="3"><li><p>栈和堆的的介绍</p><blockquote><ul><li>到这里，你肯定会有一个疑问，为什么一定要分堆和 栈这两个存储空间呢？所有的数据都存放在栈中不就可以了吗？答案是不可以</li><li>因为 Javascript 引擎需要用栈来维护程序执行期间上下文的状态，如果栈空间太大的话，所有数据都存放在栈空间里面，那么会影响到上下文切换的效率，进而又影响到整个程序的执行效率。<table><thead><tr><th>比较</th><th>栈</th><th>堆</th></tr></thead><tbody><tr><td>大小固定</td><td>创建时，<strong>确定大小</strong>（值大小固定），故可能会<strong>溢出</strong></td><td>大小<strong>不固定</strong>，可随时增加</td></tr><tr><td>存储类型</td><td>存储基本数据类型及引用类型数据的堆地址</td><td>存储引用类型数据</td></tr><tr><td>如何访问</td><td>按<strong>值</strong>(by value)访问</td><td>按<strong>引用</strong>(by reference)（堆内存地址）访问</td></tr><tr><td>特点</td><td>空间小，运行效率高</td><td>空间大，运行效率相对较低</td></tr><tr><td>存放规则</td><td>按顺序存放，先进后出</td><td>无序存储，可根据引用（地址）直接获取</td></tr></tbody></table></li></ul></blockquote></li><li><p>总结：基本数据类型和引用数据类型的区别</p><table><thead><tr><th>比较</th><th>基本数据类型</th><th>引用数据类型</th></tr></thead><tbody><tr><td>数据存放位置</td><td>基本数据类型存放在<strong>栈</strong>中，数据大小确定，内存空间大小可以分配</td><td>引用数据类型存放在<strong>堆</strong>中，每个空间大小不一样，要根据情况进行特定的配置</td></tr><tr><td>变量存储内容</td><td>变量中存储的是<strong>值本身</strong></td><td>变量存储的是<strong>地址</strong></td></tr><tr><td>变量用来赋值时</td><td>把变量的<strong>值复制</strong>一份去赋值</td><td>把变量的<strong>内存地址复制</strong>一份去赋值</td></tr><tr><td>存储内容大小</td><td>存储值<strong>较小</strong></td><td>存储值<strong>较大</strong></td></tr></tbody></table></li><li><p>数组的深克隆(拷贝)和浅克隆(拷贝)</p><blockquote><ul><li>引用类型在赋值的过程中，指向的是同一个地址，所以本质上两个变量指向的是同一个东西。</li><li>那我们如何把一个引用类型（这里以数组为例），完全拷贝一份给到另一个变量，并且两者之间是<strong>完全独立</strong>的，没有任何的关联呢？</li><li>这就涉及到我们这里说的克隆问题。</li></ul></blockquote></li></ol><blockquote><ul><li><strong>浅</strong>克隆： 只克隆了数组的<strong>第一层</strong>，如果数组是多维数组，或数组中的项是其它的引用类型值，则不克隆其他层。</li><li><strong>深</strong>克隆：克隆数组的<strong>所有层</strong>，要使用递归技术，在讲到递归的时候再介绍。</li></ul></blockquote><pre><code>var arr = [1, 2, 3, [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;]];  var arr2 = [];  for (var i = 0; i &lt; arr.length; i++) &#123;    arr2[arr2.length] = arr[i];  &#125;  console.log(arr, arr2);  // arr[3] = &quot;更改&quot;;  // console.log(arr, arr2);  arr[3][0] = 1;  console.log(arr, arr2);</code></pre><blockquote><ul><li>更改arr的第一层值，不会影响arr2</li><li>但若是更改arr[3]这个引用数据类型里面的值(第二层)，就会同时影响arr2的值</li><li>因为第二层的是引用数据类型，存放的是<strong>地址</strong></li><li>arr[3]和arr2[3]指向的是同一地址<blockquote><p>关于深拷贝，讲完递归之后再来讲</p></blockquote></li></ul></blockquote><h3 id="四、冒泡排序-著名排序算法"><a href="#四、冒泡排序-著名排序算法" class="headerlink" title="四、冒泡排序 - 著名排序算法"></a>四、冒泡排序 - 著名排序算法</h3><blockquote><ul><li>冒泡排序的英文是bubble sort 的是一个著名的排序算法，也是在面试时，非常爱考察的算法</li><li>假设，我们现在要将这个无序数组[1,5,3,2,6]从小到大来排列<br><strong>按冒泡排序的思想：</strong></li><li>我们要把相邻的元素<strong>两两比较</strong>，当一个元素<strong>大于</strong>右侧相邻元素时，<strong>交换</strong>它们的位置；当一个元素<strong>小于或等于</strong>右侧相邻元素时，<strong>位置不变</strong>（啥也不做）</li></ul></blockquote><h4 id="基础版："><a href="#基础版：" class="headerlink" title="基础版："></a>基础版：</h4><ol><li>冒泡排序整个过程<blockquote><p>第一轮：交换过程<br><img src="冒泡排序第一轮.png"></p></blockquote></li></ol><blockquote><p>第二轮：交换过程<br><img src="冒泡排序第二轮.png"></p></blockquote><blockquote><p>第三轮：交换过程<br><img src="冒泡排序第三轮.png"></p></blockquote><blockquote><p>第四轮：交换过程<br><img src="冒泡排序第四轮.png"></p></blockquote><p><strong>我们来分析下面的过程</strong></p><blockquote><blockquote><p>我们来用表格来分析上面的执行过程，上面数组中有<code>5</code>个元素，数组长度为<code>5</code>，经过了<code>4</code>轮交换。具体如下：</p><table><thead><tr><th>轮数</th><th>对比次数</th><th>确认元素个数</th><th>有序区个数</th></tr></thead><tbody><tr><td>第1轮</td><td>4</td><td>1</td><td>1</td></tr><tr><td>第2轮</td><td>3</td><td>1</td><td>2</td></tr><tr><td>第3轮</td><td>2</td><td>1</td><td>3</td></tr><tr><td>第4轮</td><td>1</td><td>1</td><td>5</td></tr></tbody></table></blockquote></blockquote><p><strong>其实我们可以得出结论：</strong></p><blockquote><ul><li>元素交换轮数&#x3D;数组长度-1</li><li>每一轮交换次数&#x3D;数组长度-当前交换轮</li></ul></blockquote><p><strong>代码实现思路</strong></p><blockquote><ul><li>我们可以用<code>for</code>循环嵌套来实现，<strong>外部循环</strong>控制<strong>交换轮数</strong></li><li><strong>内部循环</strong>用来实现<strong>每一轮的交换处理</strong>。先进行元素比较，如果元素大于右侧相邻相元素，则两元素位置交换，如果不大于，则啥也不做</li><li>声明变量tmp用作<strong>交换变量</strong></li></ul></blockquote><pre><code>// 排序数组var arr = [1, 5, 3, 2, 6];// 数组长度var len = arr.length;// 外层for控制交换轮数for (var i = 0; i &lt; len - 1; i++) &#123;  // 内层for控制每一轮，元素交换次数处理  for (var j = 0; j &lt; len - i - 1; j++) &#123;    if (arr[j] &gt; arr[j + 1]) &#123;      // 交换两元素位置      var tmp; // 用来交换两个变量的中间变量      tmp = arr[j];      arr[j] = arr[j + 1];      arr[j + 1] = tmp;    &#125;  &#125;&#125;console.log(arr); // [1, 2, 3, 5, 6]</code></pre><h4 id="冒泡排序优化-1"><a href="#冒泡排序优化-1" class="headerlink" title="冒泡排序优化 1"></a>冒泡排序优化 1</h4><blockquote><blockquote><p>在每一轮开始时，默认打上 isSorted&#x3D;’有序’ 标记，数据一旦发生交换，就打上 isSorted&#x3D;’无序’，退出<strong>整个</strong> <code>for</code> 循环的执行。</p></blockquote></blockquote><ol><li>优化思路<blockquote><ul><li>让我们来回顾下刚才上面那个冒泡排序的细节，当我们第过第二轮排序后。<img src="冒泡排序第二轮.png"></li></ul></blockquote></li></ol><blockquote><ul><li>其实这个时候整个数组中的元素<strong>已经是有序的</strong>了，可是排序算法还是按部就班的执行第三，四轮的排序。</li><li>如果在第二轮完成后，我们就<strong>能判断出数列已经有序的，并做出标记</strong>，那么剩下的几轮排序就不必执行了，可以提前结束工作。这样是不是性能更高呢？</li><li>那如何判断出数列当前已经是有序的呢 ？<ul><li>在第二轮结束后，数列才是有序的了，所以第二轮中我们是找不到数组有序的标记</li></ul></li></ul></blockquote><ol start="2"><li>看第三轮：<img src="冒泡排序第三轮.png"></li></ol><p><strong>在第三轮中</strong></p><blockquote><ul><li>整个过程都没有发生数据交换，也就是说，如果在这一轮中，数据如果<strong>没有经过任何的交换</strong>，那就说明，在这一轮当中，数据<strong>已经是有序</strong>的了。</li><li>所以我们在<strong>每一轮开始时</strong>，默认<strong>打上 <code>isSorted=&#39;有序&#39;</code> 标记</strong>，如果在这一轮交换中，数据一旦发生交换，就打上 <code>isSorted=&#39;无序&#39;</code>，如果整轮交换中，都没有发生交换，那就表示数组是有序的了。我们就可以退出<strong>整个</strong> for 循环的执行。</li></ul></blockquote><pre><code>// 排序数组var arr = [1, 2, 3, 5, 6];// 数组长度var len = arr.length;// 外层for控制交换轮数var isSorted;for (var i = 0; i &lt; len - 1; i++) &#123;  // 内层for控制每一轮，元素交换次数处理  isSorted = true; // 有序标记，每轮开始默认为有序，如果一旦发生交换，就会变成flag=false,无序  for (var j = 0; j &lt; len - i - 1; j++) &#123;    if (arr[j] &gt; arr[j + 1]) &#123;      // 交换两元素位置      var tmp; // 用来交换两个变量的中间变量      tmp = arr[j];      arr[j] = arr[j + 1];      arr[j + 1] = tmp;      isSorted = false;    &#125;  &#125;  // 这一轮多次交换下来，flag没有变为false,说明没有发生元素交换，此时数组已是有序的  if (isSorted) &#123;    break; // 退出最外层for循环  &#125;&#125;console.log(arr); // [1, 2, 3, 5, 6]</code></pre><h4 id="进一步优化：冒泡排序优化-2"><a href="#进一步优化：冒泡排序优化-2" class="headerlink" title="进一步优化：冒泡排序优化 2"></a>进一步优化：冒泡排序优化 2</h4><blockquote><blockquote><p>记录每一轮最后一次交换元素的位置，该位置为无序列表的边界</p></blockquote></blockquote><ol><li><p>优化思路</p><blockquote><ul><li>为了让大家更好的理解最优的解决方案带来的好处，我们重新拿一个数组<code>[2,3,4,1,5,6,7,8]</code>来做为案例讲解。</li><li>我们先来观察上面的数列，这个数列有一个明显的特点，就是前半部分<code>2,3,4,1</code>是<strong>无序</strong>的，后半部分<code>5,6,7,8</code>是<strong>有序</strong>的,并且后半部分是<strong>升序排列</strong>的，其<strong>最小值</strong>也比前面部分的最大值要大。</li></ul></blockquote></li><li><p>交换过程</p><blockquote><ul><li>第一轮<img src="冒泡优化2-第一轮.png"></li></ul></blockquote></li></ol><blockquote><ul><li>第二轮<img src="冒泡优化2-第二轮.png"></li></ul></blockquote><ol start="3"><li>从上面的两轮交换中，大家有没有发现什么问题呢 ？<blockquote><ul><li>其实右边的许多元素已经是有序的了，但是每一轮还是规规矩矩的把所有数都比一轮，浪费了很多时间。</li><li>按正常的(系统的)冒泡排序逻辑，第一轮排序过后，有序区长度为 1，第二轮排序过后，有序区长度为 2，…..</li><li>但在实际的排序过程中，有序区的长度<strong>可能会大于</strong>系统的有序区长度。<ul><li>比如说，第一轮后，有序区的长度为 5，1 之后就是有序区了，但在计算机看来，有序区的长度是1</li></ul></li><li>有没有什么办法可以确定，<strong>有序区的长度呢</strong> ？<strong>每一轮比较时</strong>，比较到实际有序区的前一位就不再发生比较了呢 ？<ul><li>我们可以<strong>记录</strong>每一轮最后一次交换元素的<strong>位置</strong>，该位置为无序列表的边界，再往右就是有序区了</li><li>每一轮比较，<strong>比较到上一轮元素最后一次交换的位置</strong>就不再比较了。</li></ul></li></ul></blockquote></li></ol><pre><code>// 排序数组var arr = [98, 2, 3, 45, 4, 1, 5, 78, 6, 7, 8, 20];// 数组长度var len = arr.length;// 当前是否是有序的var isSorted;// 有序的边界var sortBorder = len - 1;// 记录每一轮最后一次交换的值，确定下一次循有序边界var index;&gt;// 外层for控制交换轮数for (var i = 0; i &lt; len - 1; i++) &#123;    // 内层for控制每一轮，元素交换次数处理    isSorted = true; // 有序标记，每轮开始默认为有序，如果一旦发生交换，就会变成flag=false,无序    for (var j = 0; j &lt; sortBorder; j++) &#123;        if (arr[j] &gt; arr[j + 1]) &#123;            // 交换两元素位置            var tmp; // 用来交换两个变量的中间变量            tmp = arr[j];            arr[j] = arr[j + 1];            arr[j + 1] = tmp;            isSorted = false;            // 把无序列表的边界，更新为最后一次交换元素的位置            index = j;        &#125;    &#125;    // 如果无序，记录上一次最后一次交换的元素下标    if (!isSorted) &#123;        sortBorder = index;    &#125;    // 这一轮多次交换下来，flag没有变为false,说明没有发生元素交换，此时数组已是有序的    if (isSorted) &#123;        break; // 退出最外层for循环    &#125;&#125;console.log(arr);</code></pre><h3 id="五、编码题"><a href="#五、编码题" class="headerlink" title="五、编码题"></a>五、编码题</h3><blockquote><p>题目如下：</p><ul><li>当用户进入页面时，<strong>不停的</strong>弹出输入框让用户输入班级学员的成绩，直到<strong>输出退出</strong>后，就不再弹出输入框，而是把全班同学的<strong>平均成绩</strong>以弹窗形式显示出来。</li></ul></blockquote><pre><code>var item; // 接收每次输入的值      var arr = []; // 把接收过的成绩，保存到数组中      var sum = 0; //累加器      while (item != &quot;退出&quot;) &#123;        item = prompt(&quot;请输入学员成绩&quot;);        arr[arr.length] = item;      &#125;      // 把数组长度-1,目的是为了去掉最后一次存入数组中的&#39;退出&#39;      arr.length = arr.length - 1;      //计算总和      for (var i = 0; i &lt; arr.length; i++) &#123;        sum = sum + Number(arr[i]);      &#125;      //   计算平均数      alert(sum / arr.length);</code></pre><blockquote><blockquote><p>注意：</p><ul><li>判断适合使用哪一个循环语句，只知道结果用<code>while</code></li><li>数组长度一定要<code>-1</code></li></ul></blockquote></blockquote>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JS核心知识点（三）</title>
      <link href="/2023/12/03/JS%E6%A0%B8%E5%BF%83%E7%9F%A5%E8%AF%86%E7%82%B9%EF%BC%88%E4%B8%89%EF%BC%89/"/>
      <url>/2023/12/03/JS%E6%A0%B8%E5%BF%83%E7%9F%A5%E8%AF%86%E7%82%B9%EF%BC%88%E4%B8%89%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<span id="more"></span><blockquote><ul><li>所谓的<strong>流程控制语句</strong>，就是指我们可以通过这些语句来控制代码按照什么样的顺序结构来执行。</li><li>在 JS 中流程控制主要有三种结构：顺序结构、分支结构、循环结构，这三种结构代表三种不同的代码执行顺序。<img src="流程控制结构.png"></li></ul></blockquote><blockquote><ul><li>顺序结构：代码默认执行结构就是按顺序结构，从上往下依次执行的。</li><li>分支结构语句：<ul><li>if 语句</li><li>switch 语句</li></ul></li><li>循环结构的语句：<ul><li>for 语句</li><li>while 语句</li><li>do while 语句</li></ul></li><li>其它语句<ul><li>break 退出当前循环</li><li>continue 跳过当前迭代，继续执行下一个迭代</li><li>label 给语句加标签，常和for嵌套循环一起使用</li></ul></li></ul></blockquote><h3 id="一、if语句"><a href="#一、if语句" class="headerlink" title="一、if语句"></a>一、if语句</h3><blockquote><p>if 语句是使用最频繁的语句之一，也是最简单的条件语句，也称为选择语句（条件判断语句）</p></blockquote><ol><li>最简单的if语句<blockquote><ul><li><code>if</code> 是如果的意思，如果<code>()</code>括号中的条件成立，则就执行<code>&#123; &#125;</code>大括号中的语句块。</li><li>如果不成立，则啥也不做</li></ul></blockquote></li></ol><pre><code>&gt;if (条件) &#123;&gt;  // 当条件为真，则执行这里的代码&gt;  // 语句块.....&gt;&#125;&gt;// if语句后面的代码.....</code></pre><blockquote><blockquote><p>注：</p></blockquote><ul><li>这里的语句块可能是一行代码，也可能是一个多行代码</li><li>()括号里的条件可以是任何值或任何表达式，并且求值结果<strong>不一定</strong>是布尔值。</li><li>但 JS 内部会<strong>自动调用</strong>Boolean()函数，将这个表达式的<strong>返回值</strong>转为 布尔值。</li><li>如果条件求值为true,则执行{}中的语句块，如果条件求值为false，则啥也不做。执行 if 语句后面的代码。</li></ul></blockquote><p><strong>if 语句写法</strong></p><pre><code>&gt;&lt;script&gt;&gt;  // 3&gt;2 条件表达式，返回值为true&gt;  if (3 &gt; 2) &#123;&gt;    console.log(3 &gt; 2); // true&gt;  &#125;&gt;&lt;/script&gt;</code></pre><p><strong>要注意区分那些是属于 if 语句体中的语句</strong></p><blockquote><ul><li>if语句体外的代码，不管if中的条件是满足，他都会执行</li></ul></blockquote><p><strong>if 语句的简写</strong></p><blockquote><ul><li>如果 if 语句体中<strong>只有一条</strong>语句，可以<strong>省略</strong>大括号和换行</li><li>如果<strong>超过一条</strong>语句，是万万不能简写的，简写会造成编译错误。</li></ul></blockquote><pre><code>&gt;&lt;script&gt;&gt;  if (2 &lt; 3) console.log(&quot;2&lt;3成立，在控制台输出&quot;);&gt;  if (2 &gt; 3) console.log(&quot;2&gt;3不成立，不在控制台输出&quot;);&gt;  console.log(&quot;我与if无关，我永远出来&quot;);&gt;&lt;/script&gt;</code></pre><ol start="2"><li>if-else 语句<blockquote><ul><li>如果条件求值为 true，则执行语句块 1 中的内容，否则执行语句块 2 中的内容</li></ul></blockquote></li></ol><pre><code>&gt;if (条件) &#123;&gt;  // 当条件为true，则执行这里代码&gt;  // 语句块1....&gt;&#125; else &#123;&gt;  // 当条件为false，则执行这里代码&gt;  // 语句块2....&gt;&#125;</code></pre><p><strong>案例实践：判断用户输入的数是偶数还是奇数</strong></p><blockquote><ul><li>结合<code>%</code>来实现</li><li>如果一个数除以 2,能整除，也就是余数为 0，就是偶数，否则就是奇数</li></ul></blockquote><pre><code>&gt;&lt;script&gt;&gt;  // 弹出弹窗，让用户输入内容&gt;  var num = Number(prompt(&quot;请用户输入一个数字&quot;));&gt;  // 上面num接收过来的值，是字符串类型，不过num%2时num会自动做隐式类型转换，转换成数字&gt;  if (num % 2 == 0) &#123;&gt;    alert(num + &quot;他是一个偶数&quot;);&gt;  &#125; else &#123;&gt;    alert(num + &quot;他是一个奇数&quot;);&gt;  &#125;&gt;&lt;/script&gt;</code></pre><blockquote><blockquote><p>但是如果用户啥也不输，以及<code>&#39;&#39;</code>和<code>&#39; &#39;</code>也会被转成 0，这里暂时不做讲解，下面案例中会完善</p></blockquote></blockquote><ol start="3"><li><code>if-else</code> if 多条件分支语句<blockquote><ul><li>如果条件 1 成立，则执行语句 1，后面的就不看了</li><li>如果条件 1 不成立，则看条件 2，如果条件 2 成立，则执行语句 2，如果不成立，则执行语句 3</li></ul></blockquote></li></ol><pre><code>&gt;if (条件1) &#123;&gt;  // 条件2为真，执行这里的代码&gt;  // 语句 1....&gt;&#125; else if (条件2) &#123;&gt;  // 条件1为假，条件2为真，执行这里代码&gt;  // 语句 2....&gt;&#125; else &#123;&gt;  // 条件1和1都为假，执行这里代码&gt;  // 语句2....&gt;&#125;</code></pre><p><strong>案例实践 1：根据用户的输入的成绩，判断用户是在那个成绩档次</strong></p><table><thead><tr><th>分数</th><th>档次</th></tr></thead><tbody><tr><td>90-100</td><td>优秀</td></tr><tr><td>89-70</td><td>良好</td></tr><tr><td>69-60</td><td>一般</td></tr><tr><td>0-59</td><td>不及格</td></tr></tbody></table><pre><code>&gt;&lt;script&gt;&gt;  var score = prompt(&quot;请输入你的考试成绩！&quot;);&gt;  if (score &gt;= 90) &#123;&gt;    alert(&quot;成绩优秀&quot;);&gt;  &#125; else if (score &gt;= 70) &#123;&gt;    alert(&quot;成绩良好&quot;);&gt;  &#125; else if (score &gt;= 60) &#123;&gt;    alert(&quot;成绩及一般&quot;);&gt;  &#125; else &#123;&gt;    alert(&quot;成绩不及格&quot;);&gt;  &#125;&gt;&lt;/script&gt;</code></pre><p><strong>案例实践 2：判断用户输入的内容是否为数字</strong></p><blockquote><p>思路分析：</p><ul><li>用户<strong>输入</strong>的内容，都是字符串，我们要判断是否为数字，肯定是要把类型转换数字，看能不能转成功。</li><li>将字符串转成数字的方法有很多Number()、parseInt()、parseFloat()、+号，我们选那个呢？</li><li>Number()和+都可以，只要字符串不是纯数字，都会转成NaN，纯数字符串都会转成数字，但<code>&#39; &#39;</code>空格不行，会被转成<code>0</code></li><li>所以接下来，接下来<strong>先过滤</strong>不是纯数字字符串，再过滤<code>&#39; &#39;</code> 空格，剩下的就都是纯数字字符串了</li><li>要判断 Number()函数转换后的结果是不是 <code>NaN</code> 和数，有两种办法，<ul><li><code>isNaN</code> 用来判断一个数是不是数字，而 NaN 正好不是数字，</li><li>还可以用 NaN <strong>不自等</strong>的方法来判断。</li></ul></li><li>接下来要过滤<code>&#39; &#39;</code>，<code>&#39; &#39;</code>空格 和 数字，可以通过 <code>parseInt()</code>和 <code>isNaN</code> 结合</li><li>剩下的就都是 纯数字字符串了</li></ul></blockquote><pre><code>&gt;&lt;script&gt;&gt;  var num=prompt(&#39;请输入数字！&#39;);&gt;  if(isNaN(Number(num)))&#123; &gt;// 如果条件成立，则num不是纯数字字符串，但不能过滤&#39;&#39; 空格&gt;      console.log(num+&#39;不是一个数字&#39;);&gt;  &#125;else if (isNaN(parseInt(num)))&#123; &gt;// &#39;&#39;空格，会被转成NaN，NaN不是数字，为真，剩下的，就全都是纯数字了&gt;      console.log(num +&#39;不是一个数字&#39;);&gt;  &#125;else&#123;&gt;      console.log(num+&#39;是一个纯数字&#39;);&gt;  &#125;&gt;&lt;/script&gt;</code></pre><p><strong>封装成方法使用：用来判断用户输入的是否是纯数字</strong></p><pre><code>&gt;function isNumber(num) &#123;&gt;  if (isNaN(+num)) &#123;&gt;    // 如果条件成立，则num不是纯数字字符串，但不能过滤&#39;&#39; 空格&gt;    return false;&gt;  &#125; else if (isNaN(parseInt(num))) &#123;&gt;    // 识别空格或者没有输入任何值&gt;    return false;&gt;  &#125; else &#123;&gt;    return true;&gt;  &#125;&gt;&#125;</code></pre><ol start="4"><li>if、if-else、if-else if 语句的嵌套</li></ol><pre><code>&gt;if()&#123;&gt;// 语句 1&gt;// 语句中可以嵌套 if()&#123;&#125;else&#123; &#125; 或if()else if()&#123;&#125;等if语句&gt;&#125;else&#123;&gt;// 语句 2&gt;// 语句2中可以嵌套 if()&#123;&#125;else&#123; &#125; 或if()else if()&#123;&#125;等if语句&gt;&#125;</code></pre><p><strong>案例实践 1：BMI 肥胖指数计算</strong></p><blockquote><ul><li>BMI 指数（Body Mass Index，身体质量指数）是用体重（以公斤为单位）除以身高（以米为单位）的<strong>平方</strong>得出的数字，是目前国际上常用的衡量人体胖瘦程度以及是否分赴康的标准。</li><li>BMI 指数 &#x3D; 体重 &#x2F; 身高 *身高<table><thead><tr><th>BMI值</th><th>分档</th></tr></thead><tbody><tr><td>低于 18.5</td><td>过瘦</td></tr><tr><td>18.5~24（不含）</td><td>正常</td></tr><tr><td>24~28（不含）</td><td>过胖</td></tr><tr><td>28~32（不含）</td><td>肥胖</td></tr><tr><td>大于等于 32</td><td>非常肥胖</td></tr></tbody></table></li></ul></blockquote><pre><code>&gt;&lt;script&gt;&gt;  // 要求用户输入身高,强制转换为数字&gt;  var height = parseFloat(prompt(&quot;请输入你的身高多少米&quot;));&gt;  // 要求用户输入体重&gt;  var weight = parseFloat(prompt(&quot;请输入你的体重&quot;));&gt;  // 判断输入是否合法&gt;  if (isNaN(height) || isNaN(weight)) &#123;&gt;    alert(&quot;你的输入有误！&quot;);&gt;  &#125; else &#123;&gt;    // 计算得到BMI指数&gt;    var bmi = weight / (height * height);&gt;&gt;    // 分档判断&gt;    if (bmi &lt; 18.5) &#123;&gt;      alert(&quot;偏瘦&quot;);&gt;    &#125; else if (bmi &lt; 24) &#123;&gt;      alert(&quot;正常&quot;);&gt;    &#125; else if (bmi &lt; 28) &#123;&gt;      alert(&quot;过胖&quot;);&gt;    &#125; else if (bmi &lt; 32) &#123;&gt;      alert(&quot;肥胖&quot;);&gt;    &#125; else &#123;&gt;      alert(&quot;非常肥胖&quot;);&gt;    &#125;&gt;  &#125;&gt;&lt;/script&gt;</code></pre><blockquote><blockquote><ul><li>注意！<strong>不要写成</strong><code>bmi = (weight / height) * height</code>，结果不同，重量除的是身高的平方</li><li>规律：用<code>大于号</code>就从大到小进行匹配，用<code>小于号</code>就从小到大</li></ul></blockquote></blockquote><p><strong>案例实践 2：判断用户输入的数是偶数还是奇数</strong></p><blockquote><ul><li>利用前面封装好的：判断是否为纯数字</li></ul></blockquote><pre><code>&gt;&lt;script&gt;&gt;  var num = prompt(&quot;请用户输入一个数字&quot;);&gt;  if (isNumber(num)) &#123;&gt;    if (num % 2 === 0) &#123;&gt;      alert(num + &quot;是一个偶数&quot;);&gt;    &#125; else &#123;&gt;      alert(num + &quot;是一个奇数&quot;);&gt;    &#125;&gt;  &#125; else &#123;&gt;    alert(&quot;你的输入有误,请重新输入一次&quot;);&gt;  &#125;&gt;&gt;  // 封装好的，用来判断用户输入的是否是纯数字&gt;  function isNumber(num) &#123;&gt;    if (isNaN(+num)) &#123;&gt;      // 如果条件成立，则num不是纯数字字符串，但不能过滤&#39;&#39; 空格&gt;      return false;&gt;    &#125; else if (isNaN(parseInt(num))) &#123;&gt;      // 识别空格或者没有输入任何值&gt;      return false;&gt;    &#125; else &#123;&gt;      return true;&gt;    &#125;&gt;  &#125;&gt;&lt;/script&gt;</code></pre><p><strong>案例实践 3：游乐园门票计算</strong></p><blockquote><ul><li>某游乐园的门票价格如下表所示</li><li>请用户输入年龄和星期几，弹出对话框显示门票价格</li><li>星期日到星期一，分别用阿拉伯数字 0、1、2、3、4、5、6 表示</li></ul></blockquote><table><thead><tr><th></th><th>年龄大于 12 岁</th><th>年龄小于等于 12 岁</th></tr></thead><tbody><tr><td>平日</td><td>100</td><td>50</td></tr><tr><td>周末</td><td>200</td><td>150</td></tr></tbody></table><blockquote><p>两种实现思路：</p><ul><li>左图：先判断星期几，再判断年龄</li><li>右图：先判断年龄，再判断星期几</li></ul></blockquote><pre><code>&gt;&lt;script&gt;&gt;  // 自动获取当前日期&gt;  var date = new Date();&gt;  // 设置日期 var date = new Date(&quot;2022/9/912&quot;);&gt;  // 获取当前星期，0-6分别表示星期日-星期六&gt;  var week = date.getDay();&gt;  // 让用户输入年龄&gt;  var age = Number(prompt(&quot;请输入你的年龄&quot;));&gt;&gt;  if (week == 0 || week == 6) &#123;&gt;    // 周末&gt;    if (age &gt; 12) &#123;&gt;      alert(&quot;周末门票价格&quot; + 200);&gt;    &#125; else &#123;&gt;      alert(&quot;周末门票价格&quot; + 150);&gt;    &#125;&gt;  &#125; else &#123;&gt;    // 平日&gt;    if (age &gt;= 12) &#123;&gt;      alert(&quot;今天门票价格&quot; + 100);&gt;    &#125; else &#123;&gt;      alert(&quot;今天门票价格&quot; + 50);&gt;    &#125;&gt;  &#125;&gt;&lt;/script&gt;</code></pre><blockquote><blockquote><ul><li><code>new Date()</code>：获取当前日期</li><li><code>.getDay()</code>获取日期对应星期</li></ul></blockquote></blockquote><blockquote><blockquote><p>注：</p></blockquote><ul><li>在实际业务场景中，年龄也不会让用户自己输入，而是通过扫描身份证或输入身份证号来识别</li><li>身份证识别相关技术：<ul><li>百度 AI 实践案例，点击查看<a href="https://ai.baidu.com/tech/ocr_cards/idcard">https://ai.baidu.com/tech/ocr_cards/idcard</a></li><li>阿里云 AI 实践案例，点击查看<a href="https://ai.aliyun.com/ocr/card">https://ai.aliyun.com/ocr/card</a></li></ul></li></ul></blockquote><h3 id="二、switch语句"><a href="#二、switch语句" class="headerlink" title="二、switch语句"></a>二、switch语句</h3><pre><code>switch (表达式或变量) &#123;  case 值1:    // 执行语句1....    break;  case 值2:    // 执行语句2....    break;  default:    // 执行语句3....    break;&#125;</code></pre><ol><li>switch 语句基本用法<blockquote><p>swith 后面的表达式或变量会<strong>依次</strong>会与case 后面的值进行<strong>比较</strong>，比较时是<strong>全等比较</strong>，因此<strong>不会</strong>做数据类型转换</p><ul><li>如果比较结果为<code>true</code>，就会执行当前case下面的执行语句,执行到 <code>break</code> 关键字，就会跳出switch语句，<strong>退出</strong>执行。</li><li>如果比较结果为<code>false</code>，则继续<strong>往下</strong>比较，如果所有结果都为 false，则最后会执行 default 下面的语句。</li><li>当然 <code>default</code> 也可以省略不写</li></ul></blockquote></li></ol><pre><code>&gt;&lt;script&gt;&gt;  var a = 1; // a的类型是数字，这里可以尝试把值换成 1,3看下结果&gt;  switch (a) &#123;&gt;    case &quot;1&quot;: // 1 与 &#39;1&#39; 在全等比较时，返回false 不成立，则继续与下一个case后面值比较&gt;      alert(&quot;这里是字符串1,匹配失败&quot;);&gt;      break;&gt;    case 2: // 1 与 2全等比较，false，继续往下比较&gt;      alert(&quot;这里是2,匹配失败&quot;);&gt;      break;&gt;    case 1: // 1 与 1 全等，则执行这个case后面的语句&gt;      alert(&quot;这里是1,匹配成功&quot;); // 在页面弹出弹窗&gt;      break;&gt;    default:&gt;      alert(&quot;找不到相匹配的内容&quot;);&gt;      break;&gt;  &#125;&gt;//以上代码最后执行结果，最后在页面弹出弹窗，弹窗内容为 &#39;这里是 1,匹配成功&#39;&gt;&lt;/script&gt;</code></pre><blockquote><blockquote><ul><li>当switch()为表达式时，输出的结果是布尔值，用布尔值来与case值比较</li><li>在实际开发时，switch()括号中表达式的值，经常是以<strong>变量形式</strong>出现</li></ul></blockquote></blockquote><ol start="2"><li>break 不写会有什么影响<blockquote><ul><li>如果不写<code>break</code>，则会在匹配成功之后，后面所有case 都将被视为匹配，<strong>直到遇见break</strong>，才会退出。</li><li>所有在 switch 语句中，程序员必须主动调用break来跳出switch语句体</li></ul></blockquote></li></ol><pre><code>&gt;&lt;script&gt;  var a = 1;  switch (a) &#123;    case 0: // 全等匹配失败      alert(&quot;这里是0,匹配成功&quot;); // 这里不会弹出来    case 1: // 全等匹配成功，下面代码会执行      alert(&quot;这里是1,匹配成功&quot;); // 这里会弹出来    // 但这个case中没有break，则会将后面所有case都被视为匹配，遇到break才退出    case 2:      alert(&quot;这里是字符串2,匹配成功&quot;); // 这里会弹出来      break; // 到这里退出    default:      alert(&quot;找不到相匹配的内容&quot;);      break;  &#125;&gt;&lt;/script&gt;</code></pre><blockquote><blockquote><p>在上面的代码中，与第二个case匹配成功后，由于没有break会直接执行后续的case，直至遇到break跳出语句体</p></blockquote></blockquote><ol start="3"><li>多条 case 共同一个语句体</li></ol><pre><code>&gt;var a = 1;&gt;  switch (a) &#123;&gt;    case 1:&gt;    case 2:&gt;    case 3:&gt;      alert(&quot;现在是工作日，记得要早起喽！&quot;);&gt;      break;&gt;  &#125;</code></pre><blockquote><ul><li>由于前两个case都没有语句和break，根据上一点可知，不管switch的值是1、2、3都会执行alert语句，再跳出语句体</li></ul></blockquote><p><strong>if语句形式</strong></p><pre><code>&gt;&lt;script&gt;&gt;  var week = 0;&gt;  if (week == 1 || week == 2 || week == 3 || week == 4 || week == 5) &#123;&gt;    alert(&quot;现在是工作日，记得要早起喽！&quot;);&gt;  &#125; else if (week == 0 || week == 6) &#123;&gt;    alert(&quot;今天是周末，尽情的享受吧&quot;);&gt;  &#125;&gt;&lt;/script&gt;</code></pre><p><strong>switch 语句</strong></p><pre><code>&gt;&lt;script&gt;&gt;  // week表时当前星期几&gt;  var week = 4;&gt;  // var week=new Date().getDay();   自动获取当天是星期几的方法&gt;  switch (week) &#123;&gt;    case 1:&gt;    case 2:&gt;    case 3:&gt;    case 4:&gt;    case 5:&gt;      alert(&quot;现在是工作日，记得要早起喽！&quot;);&gt;      break;&gt;    case 6:&gt;    case 0:&gt;      alert(&quot;今天是周末，尽情的享受吧&quot;);&gt;      break;&gt;  &#125;&gt;&lt;/script&gt;</code></pre><ol start="4"><li>switch 表达式值为布尔值<blockquote><ul><li><code>case</code>的结果也要是布尔值或者为布尔值的表达式<br><strong>判断一个人是否是未成年人，如果满 18，就是成功，否则是未成年。</strong></li></ul></blockquote></li></ol><pre><code>&gt;&lt;script&gt;&gt;  var a = Number(prompt(&quot;请输入你的年龄！&quot;));&gt;  switch (true) &#123;&gt;    case a &gt;= 18:&gt;      alert(&quot;成年人&quot;);&gt;      break;&gt;    default:&gt;      alert(&quot;未成年&quot;);&gt;      break;&gt;  &#125;&gt;&lt;/script&gt;</code></pre><ol start="5"><li>switch 的嵌套</li></ol><pre><code>&gt;switch()&#123;&gt;    case 值1:&gt;        // 执行语句&gt;        break;&gt;    case 值2:&gt;        // 执行语句&gt;        switch()&#123;&gt;            case 值1:&gt;                // 执行语句&gt;                break;&gt;                // .....&gt;        &#125;&gt;        break;&gt;        // ......&gt;&#125;</code></pre><ol start="6"><li>switch 嵌套案例<br><strong>根据年份和对应的月份，判断月份天数</strong><blockquote><ul><li>1，3，5，7，8，10，12 月，每月 31 天</li><li>4，6，9，11 月，每月 30 天</li><li>当年为闰年 2 月 29 天，其它年份，2 月 28 天</li></ul></blockquote></li></ol><pre><code>&gt;&lt;script&gt;&gt;  // var year=prompt(&#39;请输入当前年份&#39;)&gt;  // var year=new Date().getFullYear(); 获取当前年份&gt;  var year = 2022;&gt;  // 用户输入月份&gt;  var month = Number(prompt(&quot;请输出当前的月份&quot;));&gt;  // var month=new Date().getMonth()+1; 获取当前月份(new Date().getMonth()返回 0-11这间值,0代表1月)&gt;  switch (month) &#123;&gt;    case 1:&gt;    case 3:&gt;    case 5:&gt;    case 7:&gt;    case 8:&gt;    case 10:&gt;    case 12:&gt;      alert(&quot;当月有31天&quot;);&gt;      break;&gt;    case 4:&gt;    case 6:&gt;    case 9:&gt;    case 11:&gt;      alert(&quot;当月有30天&quot;);&gt;      break;&gt;    case 2:&gt;      var isRunNian =&gt;        (year % 4 == 0 &amp;&amp; year % 100 != 0) ||&gt;        (year % 100 == 0 &amp;&amp; year % 400 == 0);&gt;      switch (isRunNian) &#123;&gt;        case true:&gt;          alert(&quot;这个月有29天&quot;);&gt;          break;&gt;        case false:&gt;          alert(&quot;这个月有28天&quot;);&gt;          break;&gt;      &#125;&gt;      break;&gt;    default:&gt;      alert(&quot;你输入的月份有误！&quot;);&gt;  &#125;&gt;&lt;/script&gt;</code></pre><ol start="7"><li>if 语句和 switch 语句应用场景总结<table><thead><tr><th>条件判断句</th><th>应用场景</th></tr></thead><tbody><tr><td>if 语句</td><td>根据条件做出判断，符合条件做什么，不符合条件做什么</td></tr><tr><td>switch</td><td>一个变量存在多个值的情况，根据不同的值来分别讨论时</td></tr></tbody></table></li></ol><h3 id="三、for循环"><a href="#三、for循环" class="headerlink" title="三、for循环"></a>三、for循环</h3><blockquote><p>如果我们想在页面中，重复执行某个操作时，我们就可以用到 for 循环语句。</p></blockquote><ol><li>for 语句的语法</li></ol><pre><code>// 在控制台输出从0-9的数字for (var i = 0; i &lt; 10; i++) &#123;  console.log(i);&#125;</code></pre><blockquote><p><strong>for 的圆括号中有三个表达式：</strong></p><ul><li>表达式<code>var i=0;</code>表示定义一个“循环变量”i，赋值为 0;</li><li>表达式<code>i &lt; 10;</code> 表示继续执行循环的条件，只要这个条件为真，则会一直执行；</li><li>表达式<code>i++</code>用来<strong>更新循环变量</strong>，使循环变量的值越来越趋向终点</li></ul></blockquote><ol start="2"><li><p>for 语句的执行机理</p><blockquote><p>我们先来看一个简单的 for 循环语句：<br><img src="for循环语句.png"></p><ul><li>首先会执行语句①</li><li>然后判断语句②是否满足，如果满足则<strong>进入循环体</strong>，执行语句 ③，如果不满足则退出循环</li><li>语句体中的语句执行完毕后，执行语句 ④</li><li>再次判断语句 ②是否满足，如果满足则进入循环体，执行语句 ③，如果不满足则退出循环</li><li>①–&gt;②–&gt;③–&gt;④–&gt;②–&gt;③–&gt;④–&gt;②–&gt;③–&gt;④…… 依次继续循环执行</li></ul></blockquote></li><li><p>准确遍历 for 循环</p></li></ol><p><strong>案例 1：</strong></p><pre class=" language-js"><code class="language-js"><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">var</span> i <span class="token operator">=</span> <span class="token number">3</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> <span class="token number">15</span><span class="token punctuation">;</span> i <span class="token operator">+</span><span class="token operator">=</span> <span class="token number">3</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 3,6,9,12,15</span><span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">/*    当 i=3, 3&lt;=15, 满足条件，输出 3; 再执行i+=3更新循环变量，得到i=6    再次判断 i&lt;15这个条件， 即 6&lt;=15, 满足条件，输出 6;  再执行i+=3更新循环变量， 得到i=9    再次判断 i&lt;15这个条件，即 9&lt;=15, 满足条件，输出9; 再执行i+=3更新循环变量，得到 i=12    再次判断 i&lt;15这个条件，即 12&lt;=15, 满足条件，输出12; 再执行i+=3更新循环变量，得到 i=15    再次判断 i&lt;15这个条件，即 15&lt;=15, 满足条件，输出15; 再执行i+=3更新循环变量，得到 i=18    再次判断 i&lt;15这个条件，即 18&lt;=15, 不满足条件，退出for循环*/</span></code></pre><p><strong>案例2：</strong></p><pre class=" language-js"><code class="language-js"><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">var</span> i <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">12</span><span class="token punctuation">;</span> i <span class="token operator">+</span><span class="token operator">=</span> <span class="token number">3</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>  i <span class="token operator">+</span><span class="token operator">=</span> <span class="token number">4</span><span class="token punctuation">;</span>  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 6,13</span><span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">/*  当 i=2, i&lt;12, 满足条件，i+=4, 输出 6; 再执行i+=3 得到 i=9  当 i=9, i&lt;12, 满足条件，i+=4, 输出 13; 再执行 i+=3 得到 i=16  当 i=16, i&lt;12, 不满足条件，退出循环*/</span></code></pre><p><strong>案例 4：无循环体语句</strong></p><pre class=" language-js"><code class="language-js"><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">var</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">10</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span><span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 不在循环体中，输出循环体结束时 i 的值</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 10</span></code></pre><p><strong>案例 5：死循环</strong></p><pre class=" language-js"><code class="language-js"><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">var</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">10</span><span class="token punctuation">;</span> i<span class="token operator">--</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// i永远都会小于10 ，所以会进入死循环</span><span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span></code></pre><p><strong>案例 6：</strong></p><pre class=" language-js"><code class="language-js"><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">var</span> i <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">4</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 没有任何输出，一开始就不满足条件</span><span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 在循环体外输出：i=10</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><ol start="4"><li>for 循环案例<blockquote><blockquote><p>打断点：控制台–&gt;source–&gt;点击要选择的行–&gt;空白处右击重新加载–&gt;在watch里输入要监测的变量名–&gt;点击向下箭头就可以看到循环步骤<br><strong>求 1-10 之间所有数字之和</strong></p></blockquote></blockquote></li></ol><pre><code>// 这里一定要赋初始值为0，否则为undefined,在做+加法运算时，转换成NaN，NaN与任何数相加都得NaNvar sum = 0;for (var i = 1; i &lt;= 10; i++) &#123;  sum += i; // 等同于 sum=sum+i;&#125;console.log(sum); // 55</code></pre><p><strong>字符串的拼接（在页面输入 10 颗星星）</strong></p><pre><code>// 一定要赋初值始，并且只能是&#39;&#39;字符符串。var str = &quot;&quot;;for (var i = 0; i &lt; 10; i++) &#123;  str += &quot;★&quot;;&#125;console.log(str); // ★★★★★★★★★★</code></pre><ol start="5"><li>for 循环嵌套<blockquote><p>for 循环中可以嵌套 for 循环</p></blockquote></li></ol><pre><code>for (var i = 0; i &lt; 5; i++) &#123;  // ...循环体  for (var j = 0; j &lt; 5; j++) &#123;    // ...循环体  &#125;&#125;</code></pre><p><strong>for 循环嵌套的执行原理</strong></p><blockquote><ul><li>从<strong>最外层</strong> for 循环开始执行，执行到<strong>内部</strong> for 循环时，要把内部 for 循环<strong>执行完</strong></li><li>再<strong>更新最外层</strong>的循环变量，然后判条件是否成立，成立则执行循环体中代码，进入内部循环</li><li>内部循环全部执行完，再更新最外层循还变量……重复上面过程</li></ul></blockquote><ol start="6"><li>for 循环嵌套案例</li></ol><p><strong>案例实践 1：打印五行七列的星星</strong></p><pre><code>var str = &quot;&quot;;// 行for (var i = 0; i &lt; 5; i++) &#123;  // 列  for (var j = 0; j &lt; 7; j++) &#123;    str += &quot;★&quot;;  &#125;  str += &quot;\n&quot;;&#125;console.log(str);</code></pre><blockquote><blockquote><p>换行用转义符<code>\n</code></p></blockquote></blockquote><p><strong>案例实践 2：打印 99 乘法表</strong><br><img src="99乘法表.png"></p><pre><code>&gt;&lt;style&gt;  span &#123;    display: inline-block;    width: 100px;    line-height: 30px;    background-color: #ddd;    margin: 5px;    text-align: center;  &#125;&gt;&lt;/style&gt;&gt;&lt;script&gt;  // 最外层for循环打印对应行数  for (var i = 1; i &lt;= 9; i++) &#123;    // 内层for循环，打印对应列数    for (var j = 1; j &lt;= i; j++) &#123;      document.write(&quot;&lt;span&gt;&quot; + j + &quot;*&quot; + i + &quot;=&quot; + j * i + &quot;&lt;/span&gt;&quot;);    &#125;    document.write(&quot;&lt;br/&gt;&quot;);  &#125;&gt;&lt;/script&gt;</code></pre><blockquote><ul><li><code>document.write();</code>：往body后面追加内容</li><li>用<code>span</code>标签包裹，<code>&lt;/br&gt;</code>换行</li></ul></blockquote><p><strong>总结规律：</strong></p><blockquote><ul><li>最<strong>外层</strong> for 循环对应的<strong>行数</strong></li><li>最<strong>内层</strong> for 循环对应每一行中的<strong>列</strong></li><li>在执行 for 嵌套时，首先要找的就是<strong>行和列的关系</strong>（当然最难的也就是找出列和行之间的关系）</li></ul></blockquote><p><strong>案例实践 3：打印下表中的 3 个图形</strong></p><blockquote><p><code>document.writeln</code>是向文档中写入一串文本，并紧跟着一个换行符（换行符会被编译成<strong>空格</strong>效果）<br><img src="图形打印.png"></p></blockquote><blockquote><p>原理：</p><ul><li>先打印空白，再打印方块</li></ul></blockquote><p><strong>等腰三角形</strong></p><pre><code>&gt;&lt;script&gt;  // 行  for (var i = 0; i &lt;= 5; i++) &#123;    // 列左边空格    for (var j = 1; j &lt;= 5 - i; j++) &#123;      document.writeln(&quot;&amp;nbsp&quot;);    &#125;    // 列中口    for (var k = 0; k &lt; i + 1; k++) &#123;      document.writeln(&quot;口&quot;);    &#125;    document.writeln(&quot;&lt;/br&gt;&quot;);  &#125;&gt;&lt;/script&gt;</code></pre><p><strong>v字型</strong></p><pre class=" language-js"><code class="language-js"><span class="token operator">></span><span class="token operator">&lt;</span>script<span class="token operator">></span>  <span class="token comment" spellcheck="true">// 图形行</span>  <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">var</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> <span class="token number">5</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 列前面空格</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">var</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> i<span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>      document<span class="token punctuation">.</span><span class="token function">writeln</span><span class="token punctuation">(</span><span class="token string">"&amp;nbsp;"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 列中第1个星星</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">var</span> k <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> k <span class="token operator">&lt;=</span> <span class="token number">0</span><span class="token punctuation">;</span> k<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>      document<span class="token punctuation">.</span><span class="token function">writeln</span><span class="token punctuation">(</span><span class="token string">"*"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 每列两个星星中间的列空格</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">var</span> h <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> h <span class="token operator">&lt;</span> <span class="token number">9</span><span class="token operator">-</span><span class="token number">2</span><span class="token operator">*</span>i<span class="token punctuation">;</span> h<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>      document<span class="token punctuation">.</span><span class="token function">writeln</span><span class="token punctuation">(</span><span class="token string">"&amp;nbsp;"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 列中第2个星星</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">var</span> k <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> k <span class="token operator">&lt;=</span> <span class="token number">0</span><span class="token punctuation">;</span> k<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>      <span class="token keyword">if</span> <span class="token punctuation">(</span>i <span class="token operator">!=</span> <span class="token number">5</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>        document<span class="token punctuation">.</span><span class="token function">writeln</span><span class="token punctuation">(</span><span class="token string">"*"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>    <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>    document<span class="token punctuation">.</span><span class="token function">writeln</span><span class="token punctuation">(</span><span class="token string">"&lt;/br>"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span><span class="token operator">></span><span class="token operator">&lt;</span><span class="token operator">/</span>script<span class="token operator">></span></code></pre><p><strong>X图形</strong></p><pre class=" language-js"><code class="language-js"><span class="token operator">></span><span class="token operator">&lt;</span>script<span class="token operator">></span>  <span class="token comment" spellcheck="true">// 打印 x的上半部分</span>  <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">var</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> <span class="token number">5</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 列前面空格</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">var</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> i<span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>      document<span class="token punctuation">.</span><span class="token function">writeln</span><span class="token punctuation">(</span><span class="token string">"&amp;nbsp;"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 列中第1个星星</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">var</span> k <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> k <span class="token operator">&lt;=</span> <span class="token number">0</span><span class="token punctuation">;</span> k<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>      document<span class="token punctuation">.</span><span class="token function">writeln</span><span class="token punctuation">(</span><span class="token string">"*"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 每列两个星星中间的列空格</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">var</span> h <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> h <span class="token operator">&lt;</span> <span class="token number">9</span><span class="token operator">-</span><span class="token number">2</span><span class="token operator">*</span>i<span class="token punctuation">;</span> h<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>      document<span class="token punctuation">.</span><span class="token function">writeln</span><span class="token punctuation">(</span><span class="token string">"&amp;nbsp;"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 列中第2个星星</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">var</span> k <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> k <span class="token operator">&lt;=</span> <span class="token number">0</span><span class="token punctuation">;</span> k<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>      <span class="token keyword">if</span> <span class="token punctuation">(</span>i <span class="token operator">!=</span> <span class="token number">5</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 在v的底部，只要一个星，所以要去掉一个</span>        document<span class="token punctuation">.</span><span class="token function">writeln</span><span class="token punctuation">(</span><span class="token string">"*"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>    <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>    document<span class="token punctuation">.</span><span class="token function">writeln</span><span class="token punctuation">(</span><span class="token string">"&lt;/br>"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// x的下半部分</span>  <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">var</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> <span class="token number">5</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 列前面空格</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">var</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> <span class="token number">4</span> <span class="token operator">-</span> i<span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>      document<span class="token punctuation">.</span><span class="token function">writeln</span><span class="token punctuation">(</span><span class="token string">"&amp;nbsp;"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 列中第1个星星</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">var</span> k <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> k <span class="token operator">&lt;=</span> <span class="token number">0</span><span class="token punctuation">;</span> k<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>      <span class="token comment" spellcheck="true">// 保证上v和下v中*的个数相同，则下v左边最后一个星要去掉</span>      <span class="token keyword">if</span> <span class="token punctuation">(</span>i <span class="token operator">!=</span> <span class="token number">5</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>        document<span class="token punctuation">.</span><span class="token function">writeln</span><span class="token punctuation">(</span><span class="token string">"*"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>    <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 每列两个星星中间的列空格</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">var</span> h <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> h <span class="token operator">&lt;=</span> i <span class="token operator">*</span> <span class="token number">2</span><span class="token punctuation">;</span> h<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>      document<span class="token punctuation">.</span><span class="token function">writeln</span><span class="token punctuation">(</span><span class="token string">"&amp;nbsp;"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 列中第2个星星</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">var</span> k <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> k <span class="token operator">&lt;=</span> <span class="token number">0</span><span class="token punctuation">;</span> k<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>      <span class="token keyword">if</span> <span class="token punctuation">(</span>i <span class="token operator">!=</span> <span class="token number">5</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>        document<span class="token punctuation">.</span><span class="token function">writeln</span><span class="token punctuation">(</span><span class="token string">"*"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>    <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>    document<span class="token punctuation">.</span><span class="token function">writeln</span><span class="token punctuation">(</span><span class="token string">"&lt;/br>"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span><span class="token operator">></span><span class="token operator">&lt;</span><span class="token operator">/</span>script<span class="token operator">></span></code></pre><blockquote><blockquote><p>总结：</p><ul><li>首先切分图形，<strong>空白处和图形处</strong>(一个for循环里的不同子for循环)；还可以分为<strong>上下</strong>两部分(X字型,写在两个for循环里，会自动拼接)</li><li>也可以组合空格和图形，例如等腰三角形的例子，方块之间有空格，所以把方块和空格组合起来</li><li>写下每行对应列数，更加容易摸清规律</li></ul></blockquote></blockquote><h3 id="四、for循环算法题"><a href="#四、for循环算法题" class="headerlink" title="四、for循环算法题"></a>四、for循环算法题</h3><blockquote><ul><li>关于什么是算法，我们先不讲，我们做两道算法题，来找找感觉，然后在本章的第九个版块，我们会再深入探讨算法。</li><li>在接下来的算法题中，我们会接触 2 个重要的概念：累加器、累乘器。</li></ul></blockquote><ol><li>计算 1+2+3+ …… +99+100 的和<blockquote><blockquote><p>求 1+2+3+…..+99+100 的和，本质就是等差数列求和<br><strong>什么是等差数列 ？</strong></p></blockquote><ul><li>等差数列：如果一个数列从第二项起，每一项与它的前一项的差等于同一个常数，这个数列就叫做等差数列</li><li>如：1，2，3，4，5，6….. 或 1，3，5，7，9，11，….</li><li>如果我们要计算等差数列的求和，在数学中是有计算公式的，也就是前面讲到的高斯算法：<ul><li>计算等差数列前 n 项和：Sn&#x3D;(n*(a1+an))&#x2F;2</li><li>a1代表首项，a2 代表第 2 项…..an 代表第 n 项</li></ul></li></ul></blockquote></li></ol><blockquote><ul><li>在计算机中，并没有等差数的求和公式，我们必须一项一项的加起来，就要用到 <strong>for</strong> 循环</li><li>在 JS 中，我们使用<strong>累加器</strong>来操作</li></ul></blockquote><pre><code>// 创建累加器var sum=0;// 遍历1到100的每一个数字，每遍历一个数字就要把这个数字加到sum中去for(var i=1;i&lt;=100;i++)&#123;  sum+=i;  i++;&#125;console.log(sum);</code></pre><blockquote><ul><li>累加器（变量 sum)必须定义在循环外面的前面，不能写在循环体语句里</li><li>累加器的初始值必须设置，而且必须设置为 <code>0</code>，不会影响累加结果</li><li>使用最终累加<strong>结果</strong>时，必须在 for 循环结束后的<strong>外面</strong></li><li>很多 JS 大神喜欢将 sum 这样的变量，书写在 for 循环的括号中</li></ul></blockquote><pre><code>// 循环开始的时候定义sum，sum就是累加器，初始值是0// 遍历1到100的每一个数字，每遍历一个数字要把这个数字加到sum中去for (var i = 1, sum = 0; i &lt;= 100; i++) &#123;  sum += i;&#125;// 输出累加器的值console.log(sum);</code></pre><ol start="2"><li>计算 10 的阶乘<blockquote><ul><li>一个<strong>正整数</strong>的阶乘（factorial）是所有小于及等于该数的正整数的积，并且 <strong>0 的阶乘为 1</strong>。</li><li>自然数 n 的阶乘写作 <code>n!</code></li><li>在 JS 中，我们使用<strong>累乘器</strong>来操作</li></ul></blockquote></li></ol><pre><code> // 累乘器,初始值必须是1    var n = 1;    for (var i = 10; i &gt;= 1; i--)&#123;        // 将每一次的数据 i 要累乘到 n 中去        n *= i;    &#125;    // 循环结束后使用累乘结果    console.log(n); // 3628800</code></pre><blockquote><ul><li>累乘器必须<strong>定义</strong>在循环外部前面</li><li>累乘器的初始值必须是 <code>1</code>，因为 1 乘以任何数都等于本身</li><li>累乘器最终<strong>结果</strong>必须在 for 循环结束后的外面</li></ul></blockquote><h3 id="五、while-循环"><a href="#五、while-循环" class="headerlink" title="五、while 循环"></a>五、while 循环</h3><blockquote><ul><li>while 表示 “当” 的意思，是一种<strong>先测试语句</strong>，和 for 循环一样，先测试条件，根据测试条件再判断是否执行行环循体中代码</li><li>while括号里放的是：使循环继续的条件</li></ul></blockquote><pre><code>while (测试条件) &#123;  // 执行语句，代码块&#125;</code></pre><img src="while循环.png"><ol><li><p>while 循环注意事项</p><blockquote><ul><li>while 语句事先<strong>不指定</strong>循环开始、结束的范围，只要测试条件满足，就一直执行循环体</li><li>所以 while 循环体内的语句，必须使循环测试条件<strong>趋向不成立</strong>，否则会死循环</li><li>while 循环没有指定循环的变量，必须在循环外定义好循环的变量</li><li>while 循环体内要更新循环变量</li></ul></blockquote></li><li><p>更适合 while 的应用场景</p><blockquote><ul><li>while 循环更适合，没有定范围的循环，根据结果，找条件</li></ul></blockquote></li></ol><p><strong>应用实践 1：寻找 n^2大于 23450 的最小整数</strong></p><pre><code>var n=0;while(n*n&lt;=23450)&#123;  n++;&#125;console.log(n);</code></pre><p><strong>应用实践 2：</strong></p><blockquote><p>小兔子拔萝卜，第 1 天拔 1 个，第 2 天拔 2 个，第 3 天拔 3 个 …. 以此类推。请问小兔子多少天能把 500 个萝卜扒光 ？</p></blockquote><p><strong>题目解析：</strong></p><blockquote><ul><li>当等差数列 1,2,3,4….n-1,n 之和第一次&gt;500 时，这里的 n 就是我们要找的 n</li><li>所以我们需要有一个累加器来累加所有天数萝卜之和，当累加器的值&lt;500 时，就一直累加，加到&gt;500 时，就不加了。</li></ul></blockquote><pre><code>var sum=0;var day=1;while(sum&lt;=500)&#123;  sum+=day;  day++;&#125;console.log(day-1);</code></pre><blockquote><blockquote><p>注意：天数需要减1，因为当sum到500时，day++后才会到判断条件这步</p></blockquote></blockquote><h3 id="六、do-while-循环"><a href="#六、do-while-循环" class="headerlink" title="六、do while 循环"></a>六、do while 循环</h3><img src="do%20while.png"><pre><code>do &#123;  // 循环体&#125; while (循环执行条件);</code></pre><blockquote><blockquote><p>while()放的是：使循环继续的条件，当这个条件不满足时，就跳出循环</p></blockquote></blockquote><p><strong>详细解读</strong></p><blockquote><ul><li><code>do while</code>循环是一种 <strong>后测试</strong>循环语句，这一点和 while 和 for 都不一样。</li><li>for循环和while循环每次都是 “先测试条件是否满足，然后执行循环体”</li><li>do while 循环是 “先执行循环，然后测试条件是否满足”</li><li>循环体一定会至少执行一次，然后再检测循环执行条件是否为 true，决定是否继续执行循环体。</li><li>do while 循环将循环执行条件写到了循环体的后面</li><li>循环语句要更新循环变量</li></ul></blockquote><ol><li><p>随机数函数</p><blockquote><p>之前讲到过随机数函数：Math.random()方法，可以得到 0-1 之间的小数</p><ul><li><code>Math.random()方法，可以得到 0-1 之间的小数</code></li></ul></blockquote></li><li><p>更适合 do while 的应用场景</p><blockquote><ul><li>先运行一次代码，再进行条件判断</li></ul></blockquote></li></ol><p><strong>应用实践 1：</strong></p><blockquote><p>随机生成 2 个 1-10 之内的整数，但是这 2 个数之和要等于 10</p></blockquote><pre><code> do &#123;    var a = (Math.random() * 10 + 1) &gt;&gt; 0;    var b = (Math.random() * 10 + 1) &gt;&gt; 0;    var sum = a + b;      &#125; while (sum != 10);      console.log(a, b, sum);</code></pre><p><strong>应用实践 2：</strong></p><blockquote><p>随机移动元素的位置</p><ul><li>在做游戏开发和动画的时候，我们想随机生成两个数 a 和 b，作为元素在 x，y 轴方向上的移动距离</li><li>要求 a 和 b 的值均在[-10 , 10]区间随机整数</li><li>但 a 和 b，<strong>不能同时</strong>为 0</li></ul></blockquote><pre><code>do &#123;    var a = (Math.random() * 21 - 10) &gt;&gt; 0;    var b = (Math.random() * 21 - 10) &gt;&gt; 0;   &#125; while (a == 0 &amp;&amp; b == 0);console.log(a, b);</code></pre><h3 id="七、循环语句总结"><a href="#七、循环语句总结" class="headerlink" title="七、循环语句总结"></a>七、循环语句总结</h3><table><thead><tr><th>循环类型</th><th>语法</th><th>使用场景</th></tr></thead><tbody><tr><td>for 循环</td><td>for(语句 1; 语句 2; 语句 3){被执行的代码块;}</td><td>循环次数是固定的,知道明确的循环范围</td></tr><tr><td>while循环</td><td>while(条件){需要执行的代码;变量变化语句;}</td><td>循环次数不定,更适合根据结果，找条件</td></tr><tr><td>do … while 循环</td><td>do {需要执行的代码;}while(条件)</td><td>先运行一次代码，如果不符合条件再重做，符合就不做了。其不满足条件，是在事情做完后产生的。</td></tr></tbody></table><h3 id="八、break、continue、label-语句"><a href="#八、break、continue、label-语句" class="headerlink" title="八、break、continue、label 语句"></a>八、break、continue、label 语句</h3><blockquote><p>break 和 continue 语句为执行循环代码提供了更严格的控制手段</p></blockquote><ol><li>break 语句<br><strong>什么时候用 ？</strong><blockquote><ul><li>break 语句用于<strong>立即</strong>退出<strong>当前循环</strong>，他只能用在<strong>循环语句</strong>中，如 <code>for</code> 循环和 <code>while</code> 循环中都可以(if和switch不可以，他们是分支结构语句)</li></ul></blockquote></li></ol><blockquote><ul><li>break 在 for 嵌套中，他只会退出他<strong>所在的</strong>那个 for 循环语句，然后<strong>继续执行</strong>当前 for <strong>循环外</strong>的 for 循环体中语句</li></ul></blockquote><pre><code>&gt;&lt;script&gt;  for (var i = 0; i &lt; 4; i++) &#123;    for (var j = 0; j &lt; 4; j++) &#123;      if (j == 3) &#123;        break; // 每次执行到j==3时，就会退出当前for循环，继续执行当前for外的for循环      &#125;      console.log(i + &quot;-&quot; + j);    &#125;    console.log(&quot;j&quot; + j); // break退出for时，会从这里开始执行下一次的外层for循环//i=0 j=0,0-0 j=1,0-1 j=2,0-2 j=3,&quot;j&quot;3//i=1,j=0,1-0 j=1,1-1 j=2,1-2 j=3,&quot;j&quot;3//……  &#125;&gt;&lt;/script&gt;</code></pre><blockquote><ul><li>break 用在 while 语句中，通常和while(true){}搭配使用</li></ul></blockquote><pre><code>// 寻找最小的满足 n^2 &gt; 23450 的整数n// 方法一var n = 1;while (n * n &lt;= 23450) &#123;  n++;&#125;console.log(n); //154&gt;// 方法二var n = 1;while (true) &#123;  if (n * n &gt; 23450) &#123;    break;  &#125;  n++;&#125;// 输出：154</code></pre><ol start="2"><li>continue 语句<blockquote><ul><li>continue 用于跳过循环中的<strong>一个迭代</strong> ，并<strong>继续执行</strong>循环中的<strong>下一个</strong>迭代，for 循环更经常使用 continue</li><li>continue 在 <strong>for 嵌套</strong>中，也是跳过<strong>当前循环</strong>中的一个迭代，并继续执行循环中的下一个迭代</li></ul></blockquote></li></ol><pre><code>&gt;&lt;script&gt;  for (var i = 0; i &lt; 4; i++) &#123;    for (var j = 0; j &lt; 4; j++) &#123;      if (j == 2) &#123;        continue;      &#125;      console.log(i + &quot;-&quot; + j);    &#125;  &#125;//i=0 j=0,0-0 j=1,0-1 j=2(停止该次循环) j=3,0-3 //i=1 j=0,1-0 j=1,1-1 j=2(停止该次循环) j=3,0-3//…… &gt;&lt;/script&gt;</code></pre><ol start="3"><li>label 语句<blockquote><p>我们上面讲过，不管是 <code>continue</code> 还是 <code>break</code>，他最多能退出的也就是当前的 <code>for</code> 循环，如果我想退出<strong>最外层</strong>的 for 循环，那就可以借助这里的 <code>label</code></p><blockquote><p>在实际开发应用不多，了解即可</p></blockquote></blockquote></li></ol><blockquote><p><code>label: statement</code></p><ul><li>label 表示标签名，这个名字是可以<strong>自定义</strong>的标识符</li><li>statement 表示代码块</li><li>label 标签名和 statement 代码块之间使用英文状态下的<strong>冒号</strong>分隔</li><li>label 标签一般都是与 for 循环语句等<strong>循环语句</strong>配合使用,同时是由 break 和 continue 语句<strong>引用</strong>的。</li></ul></blockquote><p><strong>label 标签与 continue 语句结合</strong></p><blockquote><p>表示退出到 label 标记位置，继续从 label 标签标识的 for 循环开始执行下一次循环</p></blockquote><pre><code>// outer就是label标签，用来标识第一个for循环语句，其名字outer可以自定义，不一定是outerouter: for (var i = 0; i &lt; 4; i++) &#123;  for (var j = 0; j &lt; 4; j++) &#123;    if (j == 2) &#123;      continue outer;    &#125;    console.log(i + &quot;-&quot; + j);  &#125;  console.log(&quot;j&quot; + j); // 永远不会执行&#125;//i=0 j=0,0-0 j=1,0-1 j=2 //i=1 j=0,1-0 j=1,1-1 j=2</code></pre><p><strong>label 标签与 break 语句结合</strong></p><blockquote><p>表示立即退出到 label 标签标识后的 for 循环，<strong>不再执行</strong></p></blockquote><pre><code>// outer就是label标签，其名字可以自定义，不一定是outerouter: for (var i = 0; i &lt; 4; i++) &#123;  for (var j = 0; j &lt; 4; j++) &#123;    if (j == 2) &#123;      break outer;    &#125;    console.log(i + &quot;-&quot; + j);  &#125;  console.log(&quot;j&quot; + j); // 永远不会执行//i=0 j=0,0-0 j=1,0-1 j=2(立即停止)&#125;</code></pre><ol start="4"><li>关于break、continue、label语句总结<table><thead><tr><th>语句</th><th>描述</th></tr></thead><tbody><tr><td>break</td><td>break语句用于立即<strong>退出当前循环</strong>，他只能用在循环语句中，如for循环和while循环中都可以</td></tr><tr><td>continue</td><td>continue 用于跳过循环中的<strong>一个迭代</strong> ，并继续执行循环中的下一个迭代</td></tr><tr><td>label</td><td>与break配合：表示立即退出到label标签标识后的for循环，<strong>不再执行</strong>。与continue配合：表示退出到label标记位置，继续从label标签标识的for循环<strong>开始执行下一次循环</strong></td></tr></tbody></table></li></ol><pre><code>var str = &quot;icoding123&quot;;var num = parseInt(str);if (num == NaN) &#123;    alert(NaN);&#125; else &#123;    alert(str);&#125;//alert(&quot;icoding123&quot;)</code></pre><blockquote><blockquote><p>NaN永远不等于NaN</p></blockquote></blockquote><pre><code>var a = 1;var b = 0;var str1 = &quot;&quot;;var str2 = false;if (a || b || str1) &#123;  //1 || &quot;&quot; --&gt;true    alert(a + b + str1);  //a+b做加法运算=1,1+&quot;&quot;做字符串拼接=1&#125;if (a &amp;&amp; b &amp;&amp; !str2) &#123;  //false &amp;&amp; true--&gt;false    alert(!str2);&#125;if (a &amp;&amp; !str1 &amp;&amp; !str2) &#123;  //true &amp;&amp; true    alert(!str1);  //alert(true);&#125;//alert(1);//alert(true);</code></pre><blockquote><blockquote><p>当+号两边的数都是数值时，做加法运算，否则为”连字符”（字符串的拼接）<br>只有if括号里为true时才会执行</p></blockquote></blockquote><h3 id="九、算法"><a href="#九、算法" class="headerlink" title="九、算法"></a>九、算法</h3><h4 id="到底什么是算法-？"><a href="#到底什么是算法-？" class="headerlink" title="到底什么是算法 ？"></a>到底什么是算法 ？</h4><blockquote><ul><li>在<strong>数学领域</strong>中，算法是用来解决某一类问题的公式和思想。</li><li>而在<strong>计算机科学领域</strong>中，它本质是一系列<strong>程序指令</strong>，用来解决特定的运算和逻辑问题。</li><li>在计算机中，算法就是把一个问题，拆解为计算机能够一步一步执行的<strong>步骤</strong></li></ul></blockquote><ol><li><p><strong>衡量算法的好坏：</strong></p><blockquote><blockquote><p>算法有简单的也有复杂的，衡量算法的好环有以下几个指标</p></blockquote><ul><li>时间复杂度：代码运行得到结果所花的时间</li><li>空间复杂度： 代码运行是所占用的内存空间大小</li><li>正确性（经得起时间、规模、大范围应用也不会出错）</li><li>健壮性：是指一个计算机系统在执行过程中处理错误,以及算法在遭遇输入、运算等异常时继续正常运行的能力</li><li>可读性</li></ul></blockquote></li><li><p><strong>计算机的优势</strong></p><blockquote><ul><li>计算机最突出的能力就是<strong>计算</strong>，它<strong>没有</strong>归纳总结、逻辑推理的能力。</li><li>所以人们使用计算机解决问题的时候，要”扬长避短”</li><li>充分发挥计算机的计算优势，而<strong>不要</strong>让它进行逻辑推理</li></ul></blockquote></li></ol><blockquote><ul><li>但并不意味着，我们就可以完全不考虑计算机在计算一个算法时所需要<strong>耗费的时间</strong>和<strong>占用的内存</strong>。相同的结果，肯定是耗时越小，占用的内存空间越小越好了。</li><li>所以我们在写算法时，需要考虑<strong>算法的复杂度</strong>，那什么是算法的复杂度呢 ？我们暂时不学习，我们先做几道算法题，找找感觉，然后再下下节课，我们来重点学习算法的复杂度。</li></ul></blockquote><h4 id="累加器"><a href="#累加器" class="headerlink" title="累加器"></a>累加器</h4><blockquote><p>由用户输入数字 n，请计算下面算式的值:</p><ul><li>3&#x2F;2+4&#x2F;3+5&#x2F;4+……+(n+1&#x2F;n)<br><strong>首先我们来找规律：</strong></li><li>第一项是分母是从 <code>2</code> 开始的，每一项分子比分母大 1</li><li>所以在 for 循环，遍历时，只需要遍历分母就好，分母为 i ，分子为 i+1</li></ul></blockquote><pre><code>// 由用户输入数字n,计算 3/2 + 4/3 + 5/4 + ... + (n+1)/n 的结果&gt;// 用户输入数字nvar n = Number(prompt(&quot;请输入数字n&quot;));&gt;// 累加器var sum = 0;// 遍历分母就可以了，因为分子就是分母加1有关系for (var i = 2; i &lt;= n; i++) &#123;  sum += (i + 1) / i; // 每一项值 i+1/i&#125;// 输出累加结果alert(sum.toFixed(2)); // 这里要特别注意小数的处理</code></pre><h4 id="累乘器"><a href="#累乘器" class="headerlink" title="累乘器"></a>累乘器</h4><blockquote><p>由用户输入数字 n，请计算 n 的阶乘</p></blockquote><h4 id="累加器与累乘器的结合"><a href="#累加器与累乘器的结合" class="headerlink" title="累加器与累乘器的结合"></a>累加器与累乘器的结合</h4><blockquote><p>大厂经典面试真题：计算圆周率 π</p><ul><li>π &#x3D; <code>2 * (1 + 1/3 + (1*2)/(3*5) + (1*2*3)/(3*5*7) + (1*2*3*4)/(3*5*7*9)) + (1*2* ... *n)/(3*5*...*(2n+1));</code></li><li>第一步：找规律 ，除去第 1 项，每一项都等于前一项 * n&#x2F;(n*2+1)</li><li>这里需要用到累乘器来计算出每一项的值</li><li>然后利用累加器，把每一项加起来</li></ul></blockquote><pre><code>// 累加器，就是最后的答案var sum = 0;// 累乘器，用来制作每一项，制作出来的这个项，要往累加器中累加var item = 1;&gt;// 让用户输入nvar n = Number(prompt(&quot;请输入数字n&quot;));&gt;// 遍历for (var i = 1; i &lt;= n; i++) &#123;  // 要先制作项目  item *= i / (2 * i + 1);  console.log(item);  // 把每一项往累加器中累加  sum += item;&#125;&gt;// 显示结果alert((1 + sum) * 2);</code></pre><blockquote><blockquote><p>算法题最难的点在于找到背后的规律，和相关的一些通用处理算法的技巧。</p></blockquote></blockquote><h4 id="穷举法"><a href="#穷举法" class="headerlink" title="穷举法"></a>穷举法</h4><blockquote><p>穷举法的基本思想是根据题目的部分条件确定答案的<strong>大致范围</strong>，并在此范围内对所有的情况<strong>逐一验证</strong>，直到全部情况验证完毕。</p><ul><li>若某个情况验证符合题目的全部条件，则为本问题的一个解</li><li>若全部情况验证后都不符合题目的全部条件，则本题无解。</li><li>穷举法也称为枚举法。</li><li>穷举法是一种算法思想，把在条件范围内的所有情况都逐一验证一遍。</li></ul></blockquote><ol><li>穷举法应用1：寻找能被整除的数<blockquote><p>寻找 100 以内的既能被 3 整除，也能被 5 整除的数字<br><img src="穷举法1.png"></p></blockquote></li></ol><blockquote><blockquote><p>计算机不会找规律 和逻辑推理，他最大的优势就是强大的计算能力</p></blockquote></blockquote><pre><code>// 寻找100以内的既能被3整除，也能被5整除的数字// 穷举法，从1开始实验for (var i = 1; i &lt;= 100; i++) &#123;  if (i % 3 == 0 &amp;&amp; i % 5 == 0) &#123;    console.log(i); // 15、30、45、60、75、90  &#125;&#125;</code></pre><ol start="2"><li>穷举法应用：寻找约数<blockquote><p><strong>什么是约数</strong><br><code>48的约数 ： 1、2、3、4、6、8、12、16、24、48</code></p><ul><li>这些数字都是能够被48整除的</li><li>或者说 让48除以这些数字，余数都是0</li></ul></blockquote></li></ol><pre><code>// 用户输入数字 nvar n = prompt(&quot;请输入数字&quot;);// 穷举法 从1开始验证for (var i = 1; i &lt;= n; i++) &#123;  if (n % i == 0) &#123;    console.log(i);  &#125;&#125;</code></pre><blockquote><blockquote><p>除去操作符两边的操作数都是字符串这种情况外，其它情况在在作<strong>比较</strong>时(<code>i&lt;=n</code>)，会先自动调用<code>Number()函数</code>，将非数字类型转换为数字 （<strong>隐式转换</strong>） ，然后再进行比较。 所以可以不用写成<code>n = Number(prompt(&quot;请输入数字&quot;))</code>;</p></blockquote></blockquote><ol start="3"><li>穷举法应用：寻找符合条件的数字<blockquote><p>请问 <code>1~100</code> 中哪个数字除以 3 余 1，除以 4 余 2，除以 5 余 3 ？</p></blockquote></li></ol><pre><code>// 使用穷举法for (var i = 1; i &lt;= 100; i++) &#123;  if (i % 3 == 1 &amp;&amp; i % 4 == 2 &amp;&amp; i % 5 == 3) &#123;    console.log(i); // 58  &#125;&#125;</code></pre><ol start="4"><li>穷举法应用：求水仙花数<blockquote><p>请输入一个三位数，判断这个数是不是水仙花数<br><strong>什么是水仙花数 ？</strong></p><ul><li>如果一个数是水仙花数，那么这个数的个位 3 次方+十位数的 3 次方+百位数的 3 次方&#x3D;这个数本身</li><li>如 153 ,其中 13 + 53 + 33&#x3D;153 ，这里的 153 就是水仙花数</li><li>如 154，其中 13 + 53 + 43 &#x3D; 190，所以这里的 154 不是水仙花数<br><strong>关键点在于拆数</strong></li><li>方法1：<ul><li>百位：&#x2F;100取整(123&#x2F;100&#x3D;1.23)</li><li>十位：&#x2F;10取整–&gt;%10(123&#x2F;10&#x3D;12%10&#x3D;2)</li><li>个位：%10取整(123%10&#x3D;3)</li></ul></li><li>方法2：<code>str.charAt(index)</code><ul><li>str.charAt(index); str 要检索的字符串，index 查找的索引，字符串中第一个字符下标是 0，index 为正整数</li><li>从左至右分别是0位、1位、……</li></ul></li></ul></blockquote></li></ol><p><strong>方法1：</strong></p><pre><code> var n = Number(prompt(&quot;请输入一个3位数的整数&quot;));  if (n &gt;= 100 &amp;&amp; n &lt;= 999 &amp;&amp; n.length == 3) &#123;    var a = parseInt(n / 100);    var b = parseInt(n / 10) % 10;    var c = n % 10;    if (a * a * a + b * b * b + c * c * c == n) &#123;      alert(n + &quot;是水仙花数&quot;);    &#125; else &#123;      alert(n + &quot;不是水仙花数&quot;);    &#125;  &#125; else &#123;    alert(&quot;你输入的数字不合法！&quot;);  &#125;</code></pre><blockquote><blockquote><p>数字长度用n.length检验</p></blockquote></blockquote><p><strong>方法2：</strong></p><pre><code> var n = prompt(&quot;请输入一个3位数的整数&quot;);  if (n &gt;= 100 &amp;&amp; n &lt;= 999 &amp;&amp; n.length == 3) &#123;    var a = n.charAt(0);    var b = n.charAt(1);    var c = n.charAt(2);    if (a * a * a + b * b * b + c * c * c == n) &#123;      alert(n + &quot;是水仙花数&quot;);    &#125; else &#123;      alert(n + &quot;不是水仙花数&quot;);    &#125;  &#125; else &#123;    alert(&quot;你输入的数字不合法！&quot;);  &#125;</code></pre><ol start="5"><li>穷举法应用：寻找质数(反推)<blockquote><p>请寻找 1 ~ 100 的所有质数</p><ul><li>质数：只能被 1 和它本身整除的数字，<strong>最小的质数是 2</strong></li><li>比如：2、3、5、7、11、13、17、19、23、29 ……<blockquote><p>反推，能被除<strong>1和自身</strong>以外的数整除的就不是质数</p></blockquote></li></ul></blockquote></li></ol><pre><code>// 穷举法outer: for (var i = 2; i &lt;= 100; i++) &#123;  // 内层循环开始从2开始到小于这个数字的每一个数字都尝试除i,如果能够整除，说明它不是质数，就可以筛选下一个数字了  for (var j = 2; j &lt; i; j++) &#123;    if (i % j == 0) &#123;      // 说明数字 i不是质数，因为它找到了除1和它自身之外的约数了      // continue表示放弃这个数字，开始迭代下个数字，continue它负责的是它所在的最内层的for循环      // 要给for循环加上label,然后在continue的后面加上这个label      // 这样就表示立即开始迭代外层for循环的下一个数字了，而不是内层for循环      continue outer;    &#125;  &#125;  // 能够遇见这条语句的数字i,一定是质数，否则就被continue略过了  console.log(i);&#125;</code></pre><ol start="6"><li>穷举法应用：鸡兔同笼<blockquote><p>“今有雉兔同笼，上有三十五头，下有九十四足，问雉兔各几何 ？”<br><strong>数学方法解题思路：</strong></p><ul><li>鸡和兔子各有一个头：a + b &#x3D; 35</li><li>鸡有 2 只脚，兔子有 4 只脚：2a + 4b &#x3D; 94</li></ul></blockquote></li></ol><pre><code>// 鸡兔同笼&gt;// 方法1：// 假设小鸡有a只，兔子有b只for (var a = 0; a &lt;= 35; a++) &#123;  for (var b = 0; b &lt;= 35; b++) &#123;    if (a + b == 35 &amp;&amp; 2 * a + 4 * b == 94) &#123;      console.log(&quot;小鸡有：&quot; + a + &quot;只，兔子有：&quot; + b + &quot;只。&quot;); // 小鸡有：23只，兔子有：12只。    &#125;  &#125;&#125;&gt;// 方法2：优化算法（减少for循环的次数）for (var a = 0; a &lt;= 35; a++) &#123;  var b = 35 - a;  if (2 * a + 4 * b == 94) &#123;    console.log(&quot;小鸡有：&quot; + a + &quot;只，兔子有：&quot; + b + &quot;只。&quot;); // 小鸡有：23只，兔子有：12只。  &#125;&#125;</code></pre><h3 id="十、算法如何学习-？"><a href="#十、算法如何学习-？" class="headerlink" title="十、算法如何学习 ？"></a>十、算法如何学习 ？</h3><blockquote><p>在早期，我们学算法，学数据结构，最重要的是学基本功，只有把基本功学好了，算法的基本功就是算法的复杂度和数据结构。然后</p><ul><li>多敲、多练、多总结</li><li>经典的业务需求场景要熟记，多实践</li><li>多寻找算法题，进行练习</li><li>有了一定基础后，推荐在力扣上刷算法题：<a href="https://leetcode.cn/problemset/algorithms/">https://leetcode.cn/problemset/algorithms/</a></li></ul></blockquote>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JS核心知识点（二）</title>
      <link href="/2023/12/02/JS%E6%A0%B8%E5%BF%83%E7%9F%A5%E8%AF%86%E7%82%B9%EF%BC%88%E4%BA%8C%EF%BC%89/"/>
      <url>/2023/12/02/JS%E6%A0%B8%E5%BF%83%E7%9F%A5%E8%AF%86%E7%82%B9%EF%BC%88%E4%BA%8C%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<span id="more"></span><h2 id="JS表达式、操作符、位运算符"><a href="#JS表达式、操作符、位运算符" class="headerlink" title="JS表达式、操作符、位运算符"></a>JS表达式、操作符、位运算符</h2><blockquote><ul><li>操作符： 操作符，也称为运算符，是用于实现赋值、比较值、执行算术运算等功能的符号</li><li>表达式： 简单理解为是由<strong>数字、操作符、变量</strong>等组成的式子，并且这个式子<strong>能求得值</strong>。</li><li>返回值： 表达式最终都会有一个返回结果，这个结果我们称为返回值</li></ul></blockquote><blockquote><p><strong>表达式的分类</strong></p><ul><li>在 JS 中表达式的种类非常多，这里我们主要讲解以下 5 种表达式。</li><li>每种表达式就有与之相匹配的操作符。<img src="表达式的分类.png"></li></ul></blockquote><h3 id="一、算术运算符"><a href="#一、算术运算符" class="headerlink" title="一、算术运算符"></a>一、算术运算符</h3><blockquote><ul><li>说到算术表达式就离不开算术运算符。</li><li>算术运算符：用于执行两个变量或值的算术操作符。</li></ul></blockquote><table><thead><tr><th>算术运算符</th><th>描述</th></tr></thead><tbody><tr><td>+</td><td>加</td></tr><tr><td>-</td><td>减</td></tr><tr><td>*</td><td>乘</td></tr><tr><td>&#x2F;</td><td>除</td></tr><tr><td>%</td><td>取余（取模）</td></tr></tbody></table><ol><li><p>介绍</p><blockquote><ul><li>加减的符号和数学一致，乘法是 * 号，除法是 &#x2F; 号</li><li>%取余运算符：<ul><li>取余运算也叫作 “求模运算” ，用百分号”%”表示</li><li>a % b 表示，求 a 除以 b 的余数，它不关心整数部分，只关心余数<blockquote><p>任何数%模上大于他自身的数，结果是就是这个数本身</p></blockquote></li></ul></li></ul></blockquote></li><li><p>算术运算符优先级</p><blockquote><ul><li>默认情况下，<strong>乘除取模</strong>的优先级要高于加减</li><li>不过我们可以使用圆括号<code>()</code>来提升优先级，改变运算符的计算顺序。</li><li>这里提升优先级<strong>只能</strong>用<code>()</code>，没有<code>｛｝</code>这一说</li></ul></blockquote></li><li><p>+号的两种作用</p><blockquote><ul><li>加号有 “加法” 和 “连字符” 两种作用</li><li>当+号<strong>两边的数都是数值</strong>时，做加法运算，否则为”连字符”(字符串的拼接)</li></ul></blockquote></li><li><p>隐式类型转换</p><blockquote><ul><li>如果参与<code>数学运算</code>的某操作数不是数字类型，那么 JS 会<strong>自动</strong>将其转换为数字类型，然后再做计算。这一过程称为隐式转换</li><li>隐式转换的本质是内部自动调用了相关的函数来转换。比如我们做的是算术运算，他就会**自动调用Number()**函数，帮我们把操作数转换成数字后，再做算术计算。</li></ul></blockquote></li></ol><blockquote><p><strong>注意事项</strong></p><ul><li><strong>任何数</strong>与NaN做算述运算，结果都是NaN,除与字符串拼接外。</li><li><code>+</code>号参于字符串计算，他<strong>不会</strong>做隐式转换,把操作数转换为数字;而是会当成<strong>字符串拼接</strong>来处理。</li></ul></blockquote><pre><code>&gt;&lt;script&gt;&gt;  console.log(4 / &quot;2&quot;); // 2&gt;  console.log(5 % &quot;4&quot;); // 1&gt;  console.log(true + false); // 1&gt;  console.log(2 + null); // 2&gt;  // 任何类型与NaN做运算得到NaN,与字符串拼接除外&gt;  console.log(1 + undefined); // NaN&gt;  console.log(1 + &quot;true&quot;); // &#39;1true&#39;  字符串拼接&gt;&lt;/script&gt;</code></pre><ol start="5"><li><p>显示转换</p><blockquote><ul><li>我们之前讲过<strong>强制类型转换</strong>，其实就是<strong>显示类型</strong>转换。</li><li>也就是我们自己<strong>手动的</strong>调用相关函数或方法，比如前面讲过的Number()、parseInt()、parseFloat()来转换数据类型。<blockquote><p>数学运算时隐式转换自动调用的Number()函数将其它类型转换成数字，那 Number()实现不了的，就得手动调用其它方法来实现</p></blockquote></li></ul></blockquote></li><li><p><code>+</code>  <code> -</code> 的特殊用法</p><blockquote><ul><li>如果<code>Number</code>函数能把某个类型转换成数字，那+ 和-号也可以,且规则和number一样，能识别2 进制或 16 进制。</li><li>不过要<strong>特别注意</strong> <code>-true</code>和 <code>-false</code> <code>-null</code>这 3 个特殊情况，他们会将其转换成<strong>负数</strong></li></ul></blockquote></li><li><p>浮点数（小数）丢失精度</p><blockquote><p>在 Javascript 中，有些小数的<strong>数学运算</strong>不是很精准.所以不要直接判断两个浮点数是否相等</p><blockquote><ul><li>JavaScript 使用了 IEEE754 二进制浮点数算术标淮，这会使一些个别的小数产生”丢失精度”问题。</li><li>IEEE754 二进制浮点数算术标淮是计算机底层编译标准，了解即可。</li></ul></blockquote></blockquote></li></ol><p><strong>解决浮点数运算不精准办法</strong></p><blockquote><ul><li>小数运算时，运算后的结果,再调用<code>toFixed()</code>方法保留指定的小数位数；</li><li><code>toFixed()</code>方法的返回值类型，是<strong>字符串</strong>类型</li><li><code>toFixed()</code>在指小数位时，会采用<strong>4 舍 5 入</strong></li></ul></blockquote><h3 id="二、赋值表达式"><a href="#二、赋值表达式" class="headerlink" title="二、赋值表达式"></a>二、赋值表达式</h3><blockquote><p>赋值操作符：就是给变量赋值用的</p><table><thead><tr><th>赋值操作符</th><th>描述</th></tr></thead><tbody><tr><td>&#x3D;</td><td>赋值</td></tr><tr><td>+&#x3D;、-&#x3D;、*&#x3D;、&#x2F;&#x3D;、%&#x3D;</td><td>快捷赋值</td></tr><tr><td>++</td><td>自增运算</td></tr><tr><td>–</td><td>自减运算</td></tr></tbody></table></blockquote><ol><li>赋值运算符<code>=</code><blockquote><ul><li>赋值运算符：会将等号右边的数值，赋值给等号左边的变量</li><li><code>var a=2;</code>：将&#x3D;等号右边的2赋值给左边的变量a</li><li>赋值运算符左边只能是变量，右边既可以是变量也可以是数值</li></ul></blockquote></li></ol><blockquote><ul><li>赋值运算也产生值,将等号后面的计算结果，作为“赋值运算的值”(因为每个表达式都有返回值)<blockquote><p>这就意味着，可以连续使用赋值运算符</p></blockquote></li></ul></blockquote><pre><code>&gt;&lt;script&gt;&gt;  var a, b, c;&gt;  a = b = c = 12 + 2;&gt;  console.log(a, b, c); // 14 14 14&gt;&lt;/script&gt;</code></pre><ol start="2"><li>快捷赋值（+&#x3D;、-&#x3D;、*&#x3D;、&#x2F;&#x3D;、%&#x3D;）<blockquote><ul><li>快捷赋值运算符：表示在原数值基础上进一步计算<blockquote><p>快捷赋值操作符仅仅是简写语法，使用它们并不会提升性能</p></blockquote></li></ul></blockquote></li></ol><pre><code>&gt;&lt;script&gt;&gt;  var a = 1;&gt;  a += 5; // 相当于 a = a + 5;&gt;  console.log(a); // 6&gt;  var b = 4;&gt;  b *= 2; // 相当于 b = b * 2&gt;  console.log(b); // 8&gt;  b /= 2; // 相当于 b = b / 2&gt;  console.log(b); // 4&gt;  b %= 2; // 相当于 b = b % 2;&gt;  console.log(b); // 0&gt;&lt;/script&gt;</code></pre><ol start="3"><li>++ 自增 和 – 自减 运算符<blockquote><ul><li><code>++</code> 自增：表示在自己的基础上+1</li><li><code>--</code> 自减：表示在自己的基础上-1<blockquote><p>++ 和 – 只能和变量搭配使用</p></blockquote></li></ul></blockquote></li></ol><pre><code>&gt;&lt;script&gt;&gt;  var a = 1;&gt;  a++; // a++ 相当于 a = a + 1&gt;  console.log(a); // 2&gt;&lt;/script&gt;</code></pre><ol start="4"><li>++a 和 a++ 的区别<blockquote><ul><li>++a 是先自增再赋值</li><li>a++ 是先赋值再自增</li></ul></blockquote></li></ol><pre><code>&gt;&lt;script&gt;&gt;  var b = 3;&gt;  var c = ++b; // 先自增，再赋值，所以b先自增1，得到b=4,然后把4赋值给变量c，所以c的值也是 4&gt;  console.log(c); // 4&gt;  console.log(b); // 4&gt;  console.log(c++); // 4 先赋值，再自增，所以打印是4，c自增后是5&gt;  console.log(++c); // 6 先自增，再赋值，c上面已经是5，再自增就是6，自增后再赋值，所以打印是6&gt;&lt;/script&gt;</code></pre><ol start="5"><li>–a 和 a–的区别<blockquote><ul><li>与上面同理</li><li><code>--a</code> 是先自减再赋值</li><li><code>a--</code> 是先赋值再自减</li></ul></blockquote></li></ol><h3 id="三、关系表达式"><a href="#三、关系表达式" class="headerlink" title="三、关系表达式"></a>三、关系表达式</h3><blockquote><ul><li>说到关系表达式，肯定就离不开关系操作符。</li><li>关系操作符： 用来比较两个值之间的大小关系，如果关系成立它返回<code>true</code>，如果关系不成立则返回<code>false</code><table><thead><tr><th>关系操作符</th><th>描述</th></tr></thead><tbody><tr><td>&gt;</td><td>大于</td></tr><tr><td>&lt;</td><td>小于</td></tr><tr><td>&gt;&#x3D;</td><td>大于或等于</td></tr><tr><td>&lt;&#x3D;</td><td>小于或等于</td></tr><tr><td>&#x3D;&#x3D;</td><td>等于</td></tr><tr><td>!&#x3D;</td><td>不等于</td></tr><tr><td>&#x3D;&#x3D;&#x3D;</td><td>全等于（值和类型都比较）</td></tr><tr><td>!&#x3D;&#x3D;</td><td>不全等于（其结果与&#x3D;&#x3D;&#x3D;比较的结果正好相反）</td></tr></tbody></table></li></ul></blockquote><h4 id="和-和"><a href="#和-和" class="headerlink" title="&gt;和&lt;以及&gt;=和&lt;="></a><code>&gt;</code>和<code>&lt;</code>以及<code>&gt;=</code>和<code>&lt;=</code></h4><blockquote><p>以上操作符主要是用来比较两个值的大小关系</p><ul><li>如果操作符两边的操作数，<strong>都是字符串</strong>，则不会将操作数转换成数字进行比较，而会分别比较字符串的<code>Unicode</code>编码</li><li><strong>除去</strong>操作符两边的操作数都是字符串这种情况外，其它情况在在作比较时，会先将**非数字类型转换为数字 **（隐式转换） ，然后再进行比较。 整个隐式转换过程是程序内部自动调用Number()函数来实现的<blockquote><p>以上规则，只针对基本数据类型而言</p></blockquote></li></ul></blockquote><ol><li>操作符两边的数，<strong>不都是</strong>字符串</li></ol><pre><code>&gt;//  数字与数字作比较，最简单&gt;1 &gt; 2; // false&gt;// 数字与非数字作比较&gt;1 &gt; true; // false  等价于 1&gt;1&gt;// 字符串与布尔值作比较&gt;&quot;&quot; &lt;= false; // true  等价于 0&lt;=0&gt;// null 和 undefined与数字作比较&gt;null &gt;= 0; // true 等价于 0&gt;=0&gt;undefined &lt;= 0; // false 等价于 NaN&lt;=0&gt;// 字符串与null 和undefined作比较&gt;&quot;&quot; &gt;= null; // true 等价于 0&gt;=0&gt;&quot;&quot; &lt;= undefined; // false 等价于 0&lt;=NaN&gt;// null与undefined作比较&gt;null &gt;= undefined; // false 等价于 0&gt;=NaN</code></pre><ol start="2"><li>字符串与字符串做比较<blockquote><ul><li>字符串与字符串作比较时，不会将其转换成数字进行比较，而会分别比较字符串的<code>Unicode</code>编码</li><li>比较字符编码时，是<strong>一位一位</strong>进行比较，如果两位一样，则比校下一位</li></ul></blockquote></li></ol><p><strong>英文字母对应的 Unicode 编码</strong></p><blockquote><ul><li><code>A~Z</code> 对应 <code>65~ 90</code> 也就是A的Unicode编码是65 、 Z 的Unicode编码是 90</li><li><code>a~z</code> 对应 <code>97~122</code></li><li><code>0~9</code> 对应 <code>48~57</code></li></ul></blockquote><pre><code>&gt;// 先把两边的第一位拿出来作比较，即 &#39;a&#39; &lt; &#39;b&#39; ，比较时比较的是Unicode编码，则 97&lt;98，所以结果为 true&gt;&quot;abc&quot; &lt; &quot;b&quot;; // true;&gt;&gt;// 先把两边的第一位拿出来作比较，即 &#39;1&#39; &lt; &#39;5&#39; ，比较时比较的是Unicode编码，则49 &lt; 53 ,所以结果为 true&gt;&quot;11&quot; &lt; &quot;5&quot;; // true;&gt;&gt;// 先把两边的第一位拿出来作比较，如果两位一样，则比较下一位，所以拿第二位来比较，则&#39;b&#39;&lt;&#39;c&#39;，比较时比较的是Unicode编码，则 98 &lt; 99 ,所以结果为 true&gt;&quot;abc&quot; &lt; &quot;acd&quot;; // true</code></pre><h4 id="JS-中没有连比"><a href="#JS-中没有连比" class="headerlink" title="JS 中没有连比"></a>JS 中没有连比</h4><blockquote><p>JS 中是没有连比的功能，我们来看下面的列子</p></blockquote><pre><code>&gt;&lt;script&gt;&gt;  console.log(1 &lt; 3 &lt; 2); // true 但是本质上是错的，3不可能小于 2&gt;  /*&gt;   *  1&lt;3&lt;2 为什么会得到 true ?&gt;   *  他是从左往右开始比较，1 &lt; 3 这个表达式返回值为true&gt;   *  再拿true与2作比较，那 true &lt; 2&gt;   *  数值与其它类型做比较时，会先将其转换成数字，再比较，true转数字转成 1&gt;   *  即 1 &lt; 2 吗 ？那肯定小于，所以返回结果就为 true&gt;   */&gt;&lt;/script&gt;</code></pre><blockquote><blockquote><p>那如果要判断一个数是不是&gt; 1同时&lt; 4，我们可以用后面学到的&amp;&amp;与操作符和||或操作符来实现</p></blockquote></blockquote><h4 id="和"><a href="#和" class="headerlink" title="&#x3D;&#x3D; 和 !&#x3D;"></a>&#x3D;&#x3D; 和 !&#x3D;</h4><blockquote><ul><li>&#x3D;&#x3D;用来比较操作符两边值（隐式转换后）是否相等，在比较时，<strong>不会</strong>比较两边值的类型</li><li>如果值（隐式转换后）相等，返回true，不相等，则返回false</li><li>在比较时同样会做隐式类型转换，非数字类型会自动调用Number()函数，转成数字再比较</li><li>以上规则，只适用于基本数据类型</li></ul></blockquote><pre><code>&gt;1 == true; // true&gt;0 == &quot;&quot;; // true&gt;// ‘’ 转成数字是 0   false转成数字是 0 所以0==0 是true&gt;&quot;&quot; == false; // true</code></pre><blockquote><ul><li>!&#x3D;是用来比较两个值（隐式转换后）是否不相等，如果相等返回 false,如果不相等，返回 true<blockquote><p>**特殊情况!!**：</p></blockquote></li></ul></blockquote><pre><code>&gt;null == undefined; //true&gt;&quot;&quot; ==null;//false&gt;0==null;//false</code></pre><h4 id="和-1"><a href="#和-1" class="headerlink" title="===和 !=="></a><code>===</code>和<code> !==</code></h4><blockquote><ul><li><code>===</code>用来比较两边的值是否全等，如果全等则为true,不全等则为false。</li><li>全等：不仅在比较是会比较值大小，还会比较值的类型</li><li><code>===</code>只有操作符两边的数长的<strong>一模一样</strong>，才会是 true，否则就是 false</li><li>注意区分： 而前面讲的<code>==</code>只会比较两个值（隐式转换后）的大小，不会比较类型。</li></ul></blockquote><pre><code>&gt;1 == &quot;1&quot;; // true 只比较值&gt;1 === &quot;1&quot;; // false  同时比较值和类型&gt;1 == true; // true 只比较值&gt;1 === true; // false 同时比较值和类型</code></pre><blockquote><p><strong><code>!==</code> 不全等</strong></p><ul><li><code>!==</code> 用来比较两边值是否不全等，如果是则返回true,不是返回false</li><li><code>!==</code>的结果，正好是<code>===</code>结果的<strong>反面</strong>，如果<code>===</code>返回结果是true，那！<code>==</code>返回结果就是false</li></ul></blockquote><h4 id="特殊的比较"><a href="#特殊的比较" class="headerlink" title="特殊的比较"></a>特殊的比较</h4><pre><code>&gt;undefined == null; // true&gt;undefined === null; // false&gt;&gt;NaN == NaN; // false&gt;NaN === NaN; // false&gt;&gt;NaN !== NaN; // true&gt;NaN != NaN; // true</code></pre><h4 id="区分-、-、-的区别"><a href="#区分-、-、-的区别" class="headerlink" title="区分 &#x3D; 、&#x3D;&#x3D; 、&#x3D;&#x3D;&#x3D; 的区别"></a>区分 &#x3D; 、&#x3D;&#x3D; 、&#x3D;&#x3D;&#x3D; 的区别</h4><blockquote><ul><li><code>=</code> 是赋值</li><li><code>==</code> 是比较 但只比较值</li><li><code>===</code> 是比较 同时比较值和类型</li></ul></blockquote><h3 id="四、逻辑表达式"><a href="#四、逻辑表达式" class="headerlink" title="四、逻辑表达式"></a>四、逻辑表达式</h3><table><thead><tr><th>逻辑运算符</th><th>描述</th></tr></thead><tbody><tr><td><code>!</code></td><td>逻辑非 否定的意思</td></tr><tr><td><code>&amp;&amp;</code></td><td>逻辑与 并且的意思</td></tr><tr><td>&#96;</td><td></td></tr></tbody></table><h4 id="非运算符"><a href="#非运算符" class="headerlink" title="!非运算符"></a>!非运算符</h4><blockquote><ul><li>!非运算符也叫”<strong>取反</strong>运算符”</li><li>!非是一个<strong>单目运算符</strong>，所谓单目运算符，就是这个操作符<strong>只能有一个</strong>操作数</li><li>操作数可以是任何类型的</li><li>!运算时也会用到隐式转换，如果操作数为非布尔值，其内部会自动调用<strong>Boolean函数</strong>，将其隐式转换为布尔类型的值后，再<strong>取反</strong>操作，最后将<strong>值</strong>返回。</li><li>所以!非运算的结果一定是<strong>布尔值</strong><blockquote><p>因此！我们可以通过对一个值两次取反操作，将其变为一个 Boolean 类型的值</p></blockquote></li></ul></blockquote><pre><code>&gt;!true; // false&gt;!3; // false&gt;!0; // true&gt;!undefined; // true</code></pre><blockquote><blockquote><p>总结：将基本数据类型转换为布尔值的 2 种方法</p></blockquote><ul><li>方法一：调用Boolean()函数来实现</li><li>方法二：在一个数值或变量前加!!(两次取反)操作，也可以实现</li></ul></blockquote><pre><code>&gt;!!3; // true;&gt;!!undefined; // false</code></pre><h4 id="与操作符"><a href="#与操作符" class="headerlink" title="&amp;&amp;与操作符"></a>&amp;&amp;与操作符</h4><blockquote><ul><li><code>&amp;&amp;</code>与操作符，表示<strong>并且</strong>的意思，可以对<code>&amp;&amp;</code>符号两侧的值进行<strong>与运算</strong>并返回结果</li><li><code>&amp;&amp;</code>与操作符是一种<strong>短路</strong>操作符，他有一个非常重要计算规则，就是 &amp;&amp;与的短路计算<blockquote><p>注意：当返回第一个表达式的值时，就不会再看第二个表达式了。第二个表达式<strong>不会</strong>被运行！</p></blockquote></li></ul></blockquote><ol><li>&amp;&amp;与的短路计算规则<blockquote><ul><li>如果<strong>第一个</strong>操作数转为布尔值是<code>false</code>，则就<strong>不会</strong>看第二个操作数了。返回结果为<strong>第一个</strong>操作数的<strong>返回结果</strong></li><li>如果第一个操作数转为布尔值是<code>true</code>，则<strong>会看</strong>第二个操作数。返回结果为<strong>第二个</strong>操作数的返回结果</li><li>上面提到的”操作数”，可以是一个表达式、值、函数、对象等任何类型</li></ul></blockquote></li></ol><pre><code>&gt;false &amp;&amp; true; // false&gt;1 &amp;&amp; 2; // 2  1转换为布尔值是true，所以看第二个操作数，返回值为第二个操作数 2&gt;0 &amp;&amp; 3; // 0  0转换为布尔值是false，所不看第二个操作数，返回值为第1个操作数 0&gt;true &amp;&amp; alert(&quot;我能出来喽&quot;); // 页面显示弹窗&gt;3 - 3 &amp;&amp; 1; // 0  3-3结果为0,转换为布尔值是false,则不看第二个操作数，返回值为第一个操作数，第1个操作数是表达式，所以返回值为第1个表达式的返回值0</code></pre><ol start="2"><li><strong>测试题</strong><blockquote><ul><li>以下代码的执行后的结果是多少？</li></ul></blockquote></li></ol><pre><code>&gt;&lt;script&gt;&gt;  var a = 1,&gt;    b = 2,&gt;    c;&gt;  c = a &lt; b &amp;&amp; a++;//a&lt;b:true，所以a++被运行,c=1,a=2&gt;  console.log(c, a);//c=1,a=2&gt;  c = a &gt; b &amp;&amp; --a;//a&gt;b:false=c,--a不会被运行&gt;  console.log(c, a);//c=false,a=2&gt;  a == b &amp;&amp; alert(&quot;a和b相等了&quot;);//a=b=2,true,运行alert&gt;&lt;/script&gt;</code></pre><ol start="3"><li>如何判断一个数的范围</li></ol><pre><code>var a = 10;console.log(a &gt; 5 &amp;&amp; a &lt; 12); // true   这个逻辑表达示的含 义是： a&gt;5 同时 a&lt;12 ？console.log(a &gt; 5 &amp;&amp; a &lt; 8); // false</code></pre><blockquote><blockquote><p>表达式都会有一个返回值，所以我们可以用一个变量来接受表达式的返回值</p></blockquote></blockquote><pre><code>&gt;&lt;script&gt;&gt;  var a = 10;&gt;  var b;&gt;  b = a &gt; 5 &amp;&amp; a &lt; 12;&gt;  console.log(b); // true&gt;  b = a &gt; 5 &amp;&amp; a + 2;&gt;  console.log(b); // 12&gt;&lt;/script&gt;</code></pre><ol start="4"><li>如何判断一个值是不是 NaN<blockquote><ul><li>方法1：利用 <strong>NaN是一个不是数字的，但是数字类型</strong>，这个特性来判断</li></ul></blockquote></li></ol><pre><code>&gt;var a = NaN;&gt;var _isNaN = isNaN(a) &amp;&amp; typeof a === &quot;number&quot;;&gt;consloe.log(_isNaN);</code></pre><blockquote><ul><li>方法2：利用 <strong>NaN自己不等于自已</strong> 这个特性来判断</li></ul></blockquote><pre><code>&gt;&lt;script&gt;&gt;  function _isNaN(n) &#123;&gt;    if (n !== n) &#123;&gt;      return true;&gt;    &#125; else &#123;&gt;      return false;&gt;    &#125;&gt;  &#125;&gt;  console.log(_isNaN(NaN)); // true&gt;&lt;/script&gt;</code></pre><h4 id="或-操作符"><a href="#或-操作符" class="headerlink" title="|| 或 操作符"></a><code>||</code> 或 操作符</h4><blockquote><ul><li><code>||</code>或操作符，表示或者的意思，可以对<code>||</code>符号两侧的值进行或运算并返回结果</li><li><code>||</code>或操作符是一种短路操作符，他一个非常重要计算规则，就是<code>||</code>或的短路计算</li></ul></blockquote><ol><li>|| 或的短路计算规则：<blockquote><ul><li><strong>第一个</strong>操作数转换为布尔值是<code>true</code>,则就<strong>不会</strong>看第二个操作数。返回结果为<strong>第一个</strong>操作数的返回结果，第二个表达式不会被执行</li><li>第一个操作数转换为布尔值是<code>false</code>，则就<strong>会看第二个</strong>操作数。返回结果为<strong>第二个</strong>操作数的返回结果</li><li>上面提到的”操作数”，可以是一个表达式、值、函数、对象等任何类型</li></ul></blockquote></li></ol><pre><code>&gt;true || false; // true  第1个操作数是true，则不看第2个操作数，将第1个操作数作为结果返回 true&gt;false || true; // true  第1个操作数是false，则看第二个操作数，将第2个操作数作为结果返回 true&gt;0 || 3; // 3  第1个操作数转boolean值是false，则看第2个操作数，将第2个操作数作为结果返回 3&gt;&quot;&quot; || 1; // 1  第1个操作数转boolean值是false，则看第2个操作数，将第2个操作数作为结果返回 1&gt;undefined || NaN; // NaN  第1个操作数转boolean值是false，则看第2个操作数，将第2个操作数作为结果返回 NaN</code></pre><ol start="2"><li>测试题<blockquote><p>以下代码，输出的结果？</p></blockquote></li></ol><pre><code>&gt;&lt;script&gt;&gt;  var a = 1,&gt;    b = 2,&gt;    c;&gt;  c = a &lt; b || a++;//c=ture,a++不会被执行&gt;  console.log(c); &gt;  c = a &gt; b || a--;//c=1,a=0,先赋值后自减&gt;  console.log(a, c); &gt;&lt;/script&gt;</code></pre><h4 id="逻辑操作符优先级"><a href="#逻辑操作符优先级" class="headerlink" title="逻辑操作符优先级"></a>逻辑操作符优先级</h4><blockquote><p>逻辑操作符优先级是： <code>！非</code> &gt; <code>&amp;&amp; 与</code> &gt; <code>|| 或</code> </p><blockquote><p>自己写代码的时候，建议加括号增强可读性</p></blockquote></blockquote><pre><code>&gt;(1 &amp;&amp; false) || (4 &amp;&amp; 5); //false||5--&gt;5&gt;(1 &amp;&amp; 2) || (4 &amp;&amp; 5); //2||5--&gt;2&gt;(1 &amp;&amp; true) || (!&quot;&quot; &amp;&amp; 2);//true||2--&gt;true</code></pre><h3 id="五、综合表达式"><a href="#五、综合表达式" class="headerlink" title="五、综合表达式"></a>五、综合表达式</h3><blockquote><ul><li>综合表达式：就是 算术操作符、赋值操作符、关系操作符、逻辑操作符出现在同一个表达式中。</li><li>那这些操作符混在一起使用，他们的优先级就显得很重要。</li></ul></blockquote><ol><li><p>操作符的优先级，从上往下，优先级从高到低，如下：</p><blockquote><ul><li><code>++</code> 和 <code>--</code> 运算符</li><li>非运算符(!)</li><li>算术运算符( %、&#x2F;、* 、+、-,先乘除取模再加减)</li><li>关系运算符(&gt;、&lt;、&gt;&#x3D;、&lt;&#x3D;、&#x3D;&#x3D; 、!&#x3D;、<code>===</code>、<code>!==</code>)</li><li>逻辑运算符(<code>&amp;&amp;</code> &gt; <code>||</code>)</li><li>赋值运算符（&#x3D;、+&#x3D;、-&#x3D;、&#x2F;&#x3D;、%&#x3D;）<blockquote><ul><li>单目运算符优先级较高</li><li>当自增<code>++</code>、自减<code>--</code>运算符遇到逻辑运算符时，要注意：由于短路特性，它需要先看左边的结果</li></ul></blockquote></li></ul></blockquote></li><li><p>综合表达式的计算规则</p><blockquote><ul><li>如果操作符优先级一样，则从左往右算</li><li>可以用()来改变优先级,改变计算顺序</li><li>为了提高代码可读性，在实际开发中，我们都会添加()，这样能更直接的知道代码的执行顺序</li></ul></blockquote></li><li><p>测试题<br><strong>测试题1</strong></p></li></ol><pre><code>&gt;&lt;script&gt;&gt;  var a = 0,&gt;    c;&gt;  c = !3 + 4 / 2 &gt; 5 &amp;&amp; ++a;&gt;//!-&gt;/-&gt;+-&gt; &gt;,即：false+2&gt;5,**注意**此时false自动转换为0,2&gt;5为false,c=false &amp;&amp; ++a,由于左边是false，所以++a不会被执行,c=false,a=0&gt;  console.log(c, a); // false 0&gt;&lt;/script&gt;</code></pre><p><strong>测试题2</strong></p><pre><code>&gt;&lt;script&gt;&gt;  var a = 10;&gt;  var b = a++ &amp;&amp; a &lt; 11 || a++;&gt;//a++先将10赋值给&amp;&amp;,然后自增a=11,即true&amp;&amp;false,--&gt;false||a++,此时a将11赋值给||,所以b=11,然后a自增,a=12&gt;  var c = a + 1 &amp;&amp; a + 2;&gt;//c=13&amp;&amp;14,c=14&gt;  console.log(b, c, a); // 11  14  12&gt;&lt;/script&gt;</code></pre><blockquote><blockquote><p><code>var b = a++ &amp;&amp; a &lt; 11 || a++;</code>这步的顺序很重要，</p></blockquote></blockquote><ol start="4"><li>所有操作符优先级<blockquote><ul><li>关于每一个运算符的详细优先级，可以参考下面这张图</li><li>在下图中，越在最上面的，优先级越高，越优先计算。<img src="操作符优先级.png"></li></ul></blockquote></li></ol><h3 id="六、三元-条件-运算符"><a href="#六、三元-条件-运算符" class="headerlink" title="六、三元(条件)运算符"></a>六、三元(条件)运算符</h3><blockquote><ul><li>JavaScript 中提供了一种叫做 “三元运算” 的语法形式，让我们可以方便地实现选择</li><li>他更像是if..else语句的紧凑版<br><code>条件表达式 ? 表达式1 : 表达式2;</code></li></ul></blockquote><p><strong>执行流程</strong></p><blockquote><ul><li>首先对条件表达式进行求值</li><li>如果条件表达式的值为 true，则执行语句 1，并返回执行结果</li><li>如果条件表达式的值为 false，则执行语句 2，并返回执行结果</li></ul></blockquote><p><strong>注意事项</strong></p><blockquote><ul><li>三元运算符，虽然回有返回结果，但我们并不一定要用一个变量来接受，<strong>有些时候</strong>，我们并不关心他的返回值</li></ul></blockquote><pre><code>&gt;var a = 2;&gt;// 这种情况下，我们更关心，满足条件要做什么事，不满足条件做什么事，并不关心返回结果&gt;a &gt; 1 ? alert(a + &quot;大于1&quot;) : alert(a + &quot;小于1&quot;);&gt;// 同时这种情况，不管 a&gt;1 是真是假，最终返回结果都是undefined,因为 alert() 方法返回值是undefined&gt;var b = a &gt; 1 ? alert(a + &quot;大于1&quot;) : alert(a + &quot;小于1&quot;);&gt;console.log(b); // undefined</code></pre><p><strong>实战案例：补 0 操作</strong></p><blockquote><ul><li>当我们获取当前日期时，如果计算得到的日，月小于 10 的时候，都会以一位数的方式显示，如：2022年8月17日，而我们希望以两位的方式显示，如：2022年08月17日</li><li>这个时候就会涉及到补 0 的问题了。<blockquote><p>通过三元运算符判断，并执行加0操作</p></blockquote></li></ul></blockquote><pre><code>&gt;// 完整的补0后效果&gt;// var date = new Date(&quot;2019/1/3&quot;);&gt;var date = new Date();&gt;var year = date.getFullYear(); // 获取完整的年份(4位)&gt;var month = date.getMonth() + 1; // date.getMonth()获取当前月份(0-11,0代表1月),所以要加1&gt;var day = date.getDate(); // 获取当前日(1-31)&gt;month = month &lt; 10 ? &quot;0&quot; + month : month; // 月份小于10，数字前补0&gt;day = day &lt; 10 ? &quot;0&quot; + day : day; // 日小于10，数字前补0&gt;var currentDate = year + &quot;年&quot; + month + &quot;月&quot; + day + &quot;日&quot;;&gt;console.log(currentDate); // 2022年08月17日</code></pre><h3 id="七、综合案例"><a href="#七、综合案例" class="headerlink" title="七、综合案例"></a>七、综合案例</h3><p><strong>判断当前输入年份，是否是闰年 ?</strong></p><blockquote><p>需求分析：</p><ul><li>公历闰年的简单计算方法（符合以下条件之一即可）</li><li>能被 4 整除且不能被 100 整除</li><li>能被 100 整除也能被 400 整除</li><li>1950-2050 年之间的闰年有: 1952、1956、1960、1964、1968、1972、1976、1980、1984、1988、1992、1996、2000、2004、2008、2012、2016、2020、2024、2028、2032、2036</li></ul></blockquote><blockquote><p>代码实现思路：</p><ul><li>利用 prompt() 弹出输入框，让用户输入年份</li><li>定义变量 var year 来接受，用户输入的年份</li><li>对接收到的值做判断，判断条件就是需求中提到的，两个条件中有一个满足就可，所以选择||操作符</li><li>判断表达式： 左边条件 1 ||右边条件 2</li></ul></blockquote><pre><code>&gt;var y = parseInt(prompt(&quot;请输入年份&quot;));&gt;var a = (y % 4 == 0 &amp;&amp; y % 100 != 0) || (y % 100 == 0 &amp;&amp; y % 400 == 0);&gt;a == true ? alert(&quot;是闰年&quot;) : alert(&quot;不是闰年&quot;);&gt;//   alert(y + &quot;是闰年吗？&quot; + a);</code></pre><h3 id="八、小结"><a href="#八、小结" class="headerlink" title="八、小结"></a>八、小结</h3><ol><li><p>由于在进行&#x3D;&#x3D;数学运算&#x3D;&#x3D;时，会自动调用Number函数进行隐式转换，所以要注意一些特殊值的转换</p><blockquote><ul><li>Number(“”); &#x2F;&#x2F; 0</li><li>Number(“ “); &#x2F;&#x2F; 0</li><li>Number(true); &#x2F;&#x2F; 1</li><li>Number(false); &#x2F;&#x2F; 0</li><li>Number(null); &#x2F;&#x2F; 0</li><li>Number(undefined); &#x2F;&#x2F; NaN</li></ul></blockquote></li><li><p>使用<code>==</code>时<br><strong>根据上一条的转换，正常的情况：</strong></p><blockquote><ul><li>0 &#x3D;&#x3D; “”; &#x2F;&#x2F; true</li><li>“” &#x3D;&#x3D; false; &#x2F;&#x2F; true</li></ul></blockquote></li></ol><p><strong>特殊情况</strong></p><blockquote><ul><li>null &#x3D;&#x3D; undefined; 结果为true</li><li>“”&#x3D;&#x3D;null ; 结果为false</li><li>0&#x3D;&#x3D;null ; 结果为false</li></ul></blockquote><h3 id="九、位运算符（难点-大厂必考）"><a href="#九、位运算符（难点-大厂必考）" class="headerlink" title="九、位运算符（难点-大厂必考）"></a>九、位运算符（难点-大厂必考）</h3><blockquote><blockquote><p>位运算符都可以去掉小数</p></blockquote></blockquote><h4 id="前情提要：二进制知识点"><a href="#前情提要：二进制知识点" class="headerlink" title="前情提要：二进制知识点"></a>前情提要：二进制知识点</h4><ol><li><p>正十进制如何转二进制</p><blockquote><ul><li>10 进制转 2 进制，就是用当前数除 2 取余数的方式得到的</li><li>如求 5 的二进制<ul><li>5&#x2F;2&#x3D;2 余 1 得到右边第 1 位</li><li>2&#x2F;2&#x3D;1 余 0 得到 右边第 2 位</li><li>1&#x2F;2&#x3D;0 余 1 得到 右边 第 3 位<br> 最后商为 0 时， 把所有从上往下的<strong>余数</strong>&#x3D;&#x3D;从右往左&#x3D;&#x3D;写出来就是最后的二进制数 <code>101</code><blockquote><p>十进制转x进制，就把十进制的值除以x直至余数为0，将得到的余数从右往左排列<br>位运算符只有<code>32</code>位，从右到左位数递增，最左边的是第32位，是最高位</p></blockquote></li></ul></li></ul></blockquote></li><li><p>二进制如何转换成十进制</p><blockquote><p><strong>计算公式</strong></p><ul><li><code>b0</code>表示二进制右边第<code>1</code>位上的数字</li><li><code>b1</code>表示二进制右边第<code>2</code>位上的数字</li><li><code>b2</code>表示二进制右边第<code>3</code>位上的数字</li><li>……依次类推<img src="二进制计算公式.png"></li></ul></blockquote></li></ol><blockquote><p>举例：<code>00000000000000000000000000000101</code>转换为十进制<br><img src="5的进制转换.png"></p><blockquote><p>最低位的平方值是0！</p></blockquote></blockquote><ol start="3"><li><strong>负</strong>十进制数如何转换成二进制<blockquote><ul><li>负数和正数的存储方式不一样，负数是以一种<strong>二补数(或补码)<strong>的二进制编码</strong>存储</strong>。</li><li>我们来看下，负数是如何转成对应二进制数，然后存储的。这里以<code>-5</code>来为例<img src="负十进制的转换.png"></li></ul></blockquote></li></ol><p><strong><code>-5</code>的二进制计算过程：</strong></p><blockquote><ul><li>第一步：暂时去掉负号，先将正数的<code>5</code>转换为二进制，得到<code>00000000000000000000000000000101</code></li><li>第二步：反转每一位的二进制数，即 1 变成 0，0 变成 1,得到<code>11111111111111111111111111111010</code></li><li>第三步：把上面反转得到二进制<code>+1</code>，就得到了最后负数的二进制</li></ul></blockquote><p><strong>验证方法：</strong></p><pre><code>&gt;var a = 0b11111111111111111111111111111011; // js中2进制数以0b开头&gt;console.log(a &gt;&gt; 0); // -5</code></pre><ol start="4"><li><p>如何一眼区分二进制数是正数还是负数</p><blockquote><ul><li><strong>有符号整数</strong>使用 32 位的前 31 位表示整数值，第 32 位表示数值的符号，如果 32 位是 <code>0</code>，表示<strong>正数</strong>，如果是 <code>1</code> 表示是<strong>负数</strong>。</li><li>第 <code>32</code> 位称为<strong>符号位</strong>，他的值决定了数值其余部分的格式。</li><li><strong>正数</strong>以真正的二进制格式存储，而负数是以我们上面提到的补码的二进制编码存储的。</li></ul></blockquote></li><li><p>最终版，二进制如何转换成十进制</p><blockquote><ul><li>拿到一个二进制数，首先看<strong>第 32 位</strong>是 0 还是 1</li><li>如果是 <code>0</code>，就按<strong>正</strong>二进制转十进制方式转</li><li>如果是 <code>1</code>，则就按<strong>负</strong>十进数转二进制的方式，<strong>反转</strong>回去，步骤倒放</li></ul></blockquote></li></ol><table><thead><tr><th></th><th>十进制转二进制</th><th>二进制转十进制</th></tr></thead><tbody><tr><td>正数</td><td>除2取余,从右到左</td><td>公式法</td></tr><tr><td>负数</td><td>除2取余+ 反转+1法</td><td>-1反转法 + 公式法</td></tr></tbody></table><p><strong>正二进制转十进制</strong></p><blockquote><p><code>var num4 = 00000000000000000000000000011001;</code></p><ul><li>1、num4 的二进制，第 32 位是 0，则是一个正数，按正常的正二进制转十进制方式转 1</li><li>2、num4 对应 10 进制计算公式&#x3D; 1+0+0+1<em>23+1</em>24 &#x3D; 1+8+16 &#x3D; 25</li></ul></blockquote><p><strong>负二进制转十进制</strong></p><blockquote><p><code>var num1 = 11111111111111111111111111111101;</code></p><ul><li>1、num1 的二进制第 32 位是 1，则是一个负数，负数就要以补码的方式反转回去</li><li>2、先拿二进制 <code>11111111111111111111111111111101</code><strong>-1</strong> 得到 <code>11111111111111111111111111111100</code><blockquote><p>二进制如何做减法：</p></blockquote></li><li><code>-1</code>就是减1的二进制数</li><li>和数学一样，不够的话往前借，数学是十进制，借到的是<code>10</code>,二进制借到的是<code>2</code></li></ul></blockquote><blockquote><ul><li>3、再把上面得到的二进制<strong>反码</strong>回去，0 变 1，1 变 0，得到<code>00000000000000000000000000000011</code>，此时得到的是正数的二进制</li><li>4、所以可以用正数的公式法：<code>1*2+1*1=3</code>，因为是负数，所以最后结果为-3</li></ul></blockquote><h4 id="位运算符"><a href="#位运算符" class="headerlink" title="位运算符"></a>位运算符</h4><ol><li><p>基础知识</p><blockquote><ul><li>位运算的操作数，都会被转成&#x3D;&#x3D;32位&#x3D;&#x3D;<code>bit</code>的整数（32 位的二进制数）,再做运算</li><li>速度是 <code>T0</code>（最高，速度最快）级别的，因为是在二进制下进行运算的。</li></ul></blockquote></li><li><p>按位与<code>&amp;</code> 操作符</p><blockquote><ul><li><code>&amp;</code>与位操作符会先把值转换为<strong>32位整数</strong>（二进制数），然后再进行位操作。</li><li>按位<code>&amp;</code>就是将两个操作数的每一位对齐，然后按下表中的规则，对每一位执行相应的操作<table><thead><tr><th>第一个数值的位</th><th>第二个数值的位</th><th>结果</th></tr></thead><tbody><tr><td>1</td><td>1</td><td>1</td></tr><tr><td>1</td><td>0</td><td>0</td></tr><tr><td>0</td><td>1</td><td>0</td></tr><tr><td>0</td><td>0</td><td>0</td></tr></tbody></table><blockquote><p>按位与操作的两个位数都是1时返回1，只要两个中有一个是 0，则返回 0</p></blockquote></li></ul></blockquote></li></ol><p><strong>&amp; 运算过程</strong></p><blockquote><ul><li>我们来看下面这个与&amp;运算的运算过程</li></ul></blockquote><pre><code>&gt;var result = 5 &amp; 3;&gt;console.log(result); // 1</code></pre><blockquote><ul><li>先把 5 和 3 都转换为对应的 32 位<strong>二进制数</strong>，然后再 <strong>1 位 1 位的</strong>比较，最后结果为 1<img src="&运算过程.png"></li></ul></blockquote><p><strong>按位&amp;操作符判断奇偶数 （经典面试题）</strong></p><blockquote><ul><li>如果 (一个数 &amp; 1) &#x3D;&#x3D; 1 这个数是<strong>奇数</strong></li><li>如果 (一个数 &amp; 1 )&#x3D;&#x3D; 0 这个数是<strong>偶数</strong></li></ul></blockquote><blockquote><p><strong>其背后的逻辑</strong></p><ul><li>根据二进制转 10 进制的公式，除第 1 位之外的每一位上的值都是 2 的倍数</li><li>也就是第<code>1</code>位上如果是<code>0</code>就是偶数，如果是<code>1</code>就是奇数<table><thead><tr><th>10进制</th><th>3</th><th>4</th><th>5</th><th>6</th><th>7</th><th>8</th><th>9</th><th>10</th></tr></thead><tbody><tr><td>二进制</td><td>11</td><td>100</td><td>101</td><td>110</td><td>111</td><td>1000</td><td>1001</td><td>1010</td></tr></tbody></table></li><li>如果一个数是奇数，他的第 1 位是 1，这个数 &amp; 1 永远得到 1<img src="判断奇偶数.png"></li></ul></blockquote><ol start="3"><li>按位或 <code>|</code> 操作符<blockquote><ul><li>按位或<code>|</code>操作符会先把值转换为 32 位整数（二进制数），然后再进行位操作</li><li>按位或<code>|</code>就是将两个操作数的每一位对齐，然后按下表中的规则，对每一位执行相应的操作<table><thead><tr><th>第一个数值的位</th><th>第二个数值的位</th><th>结果</th></tr></thead><tbody><tr><td>1</td><td>1</td><td>1</td></tr><tr><td>1</td><td>0</td><td>1</td></tr><tr><td>0</td><td>1</td><td>1</td></tr><tr><td>0</td><td>0</td><td>0</td></tr></tbody></table><blockquote><p>按位或操作的两个位数，只要有一个是 1 就返回 1，两位都是 0 时返回 0</p></blockquote></li></ul></blockquote></li></ol><p><strong>| 或运算过程</strong></p><pre><code>&gt;var result = 5 | 3;&gt;console.log(result); // 7</code></pre><blockquote><ul><li>先把 5 和 3 都转换为对应的 32 位二进制数，然后再 1 位 1 位的比较<img src="或运算过程.png"></li></ul></blockquote><p><strong>应用：将一个数取整</strong></p><pre><code>&gt;var num = 5.467;&gt;console.log(num | 0); // 5</code></pre><blockquote><ul><li>一个数在<strong>按位或</strong>运算时，会先将其转换为 32 位的<strong>整数</strong>（二进制），这个过程就会把<strong>小数转换为整数</strong></li><li>然后这个整数 <code>| 0</code> 永远得到这个整数。因为 <code>0</code> 和 <code>1</code> 与 <code>0</code> 做<strong>或运算</strong>，都得到<strong>自身</strong>。<img src="取整运算.png">>任何数与 0 做或|运算，最后结果都为这个数的**整数部分**。</li></ul></blockquote><ol start="4"><li>按位非 <code>~</code> 操作符<blockquote><ul><li>按位非<code>~</code>操作符会先把值转换为<strong>32位整数</strong>（二进制数）,再运算</li><li>按位非<code>~</code>操作符，用来反转操作数对应的位数，所以要进行一次反转</li><li>根据反转的结果，使用对应的 <strong>正数&#x2F;负数</strong> 二进制转十进制的方法</li><li>其最终结果的呈现是将一个数<strong>取反并减 1</strong></li></ul></blockquote></li></ol><p><strong><code>~5</code>的计算过程</strong></p><blockquote><ul><li>先转换为二进制，<code>5</code>的二进制是 <code>00000000000000000000000000000101</code></li><li><strong>再进行反转</strong>是：<code>11111111111111111111111111111010</code></li><li>由于反转后是一个<strong>负数</strong>，因为第32位为<code>1</code>，此时使用&#x3D;&#x3D;负二进制转为十进制&#x3D;&#x3D;的方法：<code>-1反转+公式法</code><ul><li><strong>减 1</strong>，得到 <code>11111111111111111111111111111001</code></li><li>再<strong>反转</strong>，得到00000000000000000000000000000110</li><li>再用<strong>公式法</strong>将二进制转换为十进制</li></ul></li><li>最后结果就是 6，因为是负数，所以最后结果是<code>-6</code><blockquote><p><code>~5</code>的结果是<code>-6</code>，即：取反并减1</p></blockquote></li></ul></blockquote><p><strong><code>~-5</code>的计算过程</strong></p><blockquote><ul><li>先将<code>-5</code>转为二进制(<strong>负十进制转二进制</strong>，使用除2取余,+1反转法)，得到<code>11111111111111111111111111111011</code></li><li>反转：<code>00000000 00000000 00000000 00000100</code></li><li>由于得到的是<strong>正数</strong>，所以使用&#x3D;&#x3D;公式法&#x3D;&#x3D;将其转为十进制：<code>1*2*2=4</code></li></ul></blockquote><p><strong>按位非<code>~</code>应用</strong></p><blockquote><ul><li>将一个数（<strong>整数</strong>）,<strong>两次按位非</strong>运算，就能将这个数<strong>取反</strong><ul><li>推导过程如下：</li><li><code>~~ x = ~(-x-1)=-(-x-1)-1 = x+1-1 = x</code></li></ul></li><li>取得一个数的相反数<code>~x + 1</code><ul><li><code>~x+1 = -x-1+1 = -x</code></li></ul></li></ul></blockquote><ol start="5"><li>按位异或 <code>^</code><blockquote><ul><li>按位异或<code>^</code>操作符，会先把值转为32位整数（二进制数）,再运算</li><li>按位异或<code>^</code>在做运算时，就是将两个操作数的每一位对齐，然后按下表中的规则，对每一位执行相应的操作<table><thead><tr><th>第一个数的位</th><th>第二个数的位</th><th>结果</th></tr></thead><tbody><tr><td>1</td><td>1</td><td>0</td></tr><tr><td>1</td><td>0</td><td>1</td></tr><tr><td>0</td><td>1</td><td>1</td></tr><tr><td>0</td><td>0</td><td>0</td></tr></tbody></table><blockquote><p>只有当两个数对应的位都是 1 或都是 0 时，返回 0，其它都返回 1</p></blockquote></li></ul></blockquote></li></ol><p><strong>运算过程</strong></p><pre><code>&gt;var result = 5 ^ 3;&gt;console.log(result); // 6</code></pre><blockquote><ul><li>先把 5 和 3 转换为二进制数，再一位一位来运算，如下<img src="异或运算过程.png"></li><li>再用公式转换成十进制&#x3D;6</li></ul></blockquote><p><strong>按位异或^（归零律）</strong></p><blockquote><ul><li>归零律: 一个数异或自已得到 0 ，即 <code>a ^ a=0</code> ，因为只有两个数上对应位数是<strong>一样</strong>时，才会得到 <code>0</code></li><li>用来判两个数<strong>是否相等</strong>，如果 <code>a^b=0</code>，则 <code>a=b</code></li></ul></blockquote><p><strong>按位异或^（恒等律）</strong></p><blockquote><ul><li>恒等律：<code>a ^ 0= a</code>（<strong>整数</strong>），自己异或 0，得到自己</li></ul></blockquote><p><strong>按位异或 ^（自反）</strong></p><blockquote><ul><li>自反：<code>a ^ a ^ a= 0 ^ a= a</code> ，一个（整数）异或自身 <strong>2</strong> 次，得到<strong>自身</strong>。</li><li>结合律 : <code>a ^ b ^c = c ^ b ^ a</code> ，计算结果一样，<strong>与先后顺序无关</strong></li></ul></blockquote><p><strong>应用：按位异或 ^ （用来交换两个数值变量的值）</strong></p><blockquote><p>经典面试题：变量为数字(整数)，在不增加临时变量时，交换两个变量的值,使用<code>^=</code></p></blockquote><pre><code>&gt;var a = 5;&gt;var b = 10;&gt;a ^= b;&gt;b ^= a;&gt;a ^= b;&gt;console.log(a, b); // 10 5&gt;/*&gt; * 整个推演过程如下：&gt; * 1、 a ^ = b 得到 a = a ^ b&gt; * 2、 b ^ = a 得到 b = b ^ a 在第1步得到a = a ^ b，则推倒出b = b ^ a ^ b=b ^ b ^ a =0 ^ a =a&gt; * 3、 a ^ = b 得到 a = a ^ b ,在第1步得到a = a^b,第2步得到b = a,则推倒出： a = a ^ b ^ a = b ^ b ^ a = 0 ^ b = b&gt; *&gt; */</code></pre><h4 id="位移操作符-、"><a href="#位移操作符-、" class="headerlink" title="位移操作符(&gt;&gt;、&lt;&lt;、&gt;&gt;&gt;)"></a>位移操作符(<code>&gt;&gt;</code>、<code>&lt;&lt;</code>、<code>&gt;&gt;&gt;</code>)</h4><blockquote><blockquote><p>除了<code>&gt;&gt;&gt;</code>是无符号的，其他位移操作符都是有符号的</p></blockquote></blockquote><ol><li><code>&lt;&lt;</code>左操作符<blockquote><ul><li>左移操作符用两个小于号<code>&lt;&lt;</code>表示，会按<strong>指定的位数</strong>将数值的<strong>所有位</strong>向<strong>左</strong>移动。</li><li>左移后，<strong>左边</strong>移出去的<strong>指定位数</strong>去掉，<strong>右端</strong>空出的位数会以<code>0</code>来填充这些空位。</li></ul></blockquote></li></ol><p><strong><code>5&lt;&lt;5</code>运算过程如下</strong></p><blockquote><ul><li>先把<code>5</code>转换为二进制数</li><li>再左移5位，把左边超出部分去掉，右侧的空缺用0填充</li><li>使用公式法，转换为十进制数<img src="左位移.png"></li></ul></blockquote><p><strong><code>-5&lt;&lt;5</code>的运算过程</strong></p><blockquote><ul><li>先把<code>5</code>转换为二进制数(除2取余)<code>00000000000000000000000000000101</code></li><li>使用<code>反转+1法</code>，得到<code>-5</code>的二进制数<code>11111111111111111111111111111011</code></li><li><strong>保留第32位的符号</strong>，左移5位，把左边超出部分去掉，右侧的空缺用0填充<code>11111111111111111111111101100000</code></li><li>转十进制<code>-1反转法+公式法</code><ul><li><code>-1</code>得到：<code>1111 1111 1111 1111 1111 1111 0101 1111</code></li><li>反转得到：<code>0000 0000 0000 0000 0000 0000 1010 0000</code></li><li>公式法：得到<code>160</code>，由于是负数，所以最终结果为<code>-160</code></li></ul></li></ul></blockquote><blockquote><blockquote><p>注：<br>在有符号整数中，第 32 位中的第 32 位是 符号位</p></blockquote><ul><li>如果是 0 表示正数</li><li>如果是 1 表示负数，在左移时，会保留操作数的符号</li></ul></blockquote><ol start="2"><li><code>&gt;&gt;</code> <strong>有符号</strong> <strong>右移</strong>操作符<blockquote><ul><li>有符号右移由两个大于号<code>&gt;&gt;</code>表示,会将数值的<strong>所有 32 位</strong>都向右移。同时<strong>保留符号</strong>（正和负）</li><li>有符号右移，左边空出的位会在左侧，在<strong>符号位后</strong>用<strong>符号位的值</strong>来填充这些空位。</li></ul></blockquote></li></ol><p><strong><code>160 &gt;&gt; 5;//5</code>的运算过程</strong></p><blockquote><ul><li>先将<code>160</code>转换成二进制数</li><li>向右移动5位，用符号位的值来填充第32位后的空缺，右侧超出部分的值去掉不要</li><li>用<code>公式法</code>转换为十进制&#x3D;5<img src="有符号右移.png"></li></ul></blockquote><p><strong><code>-160 &gt;&gt; 5;//-5</code>的运算过程</strong></p><blockquote><ul><li><code>除2取余</code>得到<code>160</code>的二进制数：<code>0000 0000 0000 0000 0000 0000 1010 0000</code></li><li><code>反转+1法</code>，得到<code>-160</code>的二进制数<code>1111 1111 1111 1111 1111 1111 0110 0000</code></li><li>右移5位，用<code>1</code>填充空缺<br><code>11111111111111111111111111111011</code></li><li><code>-1反转+公式法</code>转成十进制：<ul><li><code>-1</code>得到<code>11111111111111111111111111111010</code></li><li><code>反转</code>得到<br><code>00000000000000000000000000000101</code></li><li>公式法，结果&#x3D;<code>-5</code></li></ul></li></ul></blockquote><ol start="3"><li><code>&gt;&gt;&gt;</code> 无符号右移操作符<blockquote><ul><li>无符号右移会将数值的<strong>所有32位</strong>都向右移，位移造成的左侧空位<strong>全补0</strong>.</li><li>所以对于<strong>正数</strong>，&gt;&gt;&gt;无符号右移 和 有符号右移&gt;&gt;的<strong>结果是相同的</strong>。因为正数的符号位是 0，所以两者都是补 0 的方式来填充右移造成的空位。</li><li>但是负数，就完全不一样了。</li></ul></blockquote></li></ol><p><strong>55 &gt;&gt;&gt; 5;运算过程</strong></p><blockquote><ul><li>55 的二进制是：<code>00000000000000000000000000110111</code></li><li><code>&gt;&gt;&gt;</code>无符号右移<code>5</code>，左侧造成的空位 0 来补，则得到<code>00000000000000000000000000000001</code></li><li>用公式法得到十进制结果：<code>5</code></li></ul></blockquote><p><strong>-55 &gt;&gt;&gt; 5;运算过程</strong></p><blockquote><ul><li>55 的二进制是：<code>00000000000000000000000000110111</code></li><li><code>反转+1</code>得到<code>-55</code>的二进制数<code>11111111111111111111111111001001</code></li><li>右移5位，用<code>0</code>填充空缺：<code>00000111111111111111111111111110</code></li><li>公式法得到十进制结果：<code>134217726</code><blockquote><p>负数，在无符号位移后（至少 1 位），会被转换成一个正数</p></blockquote></li></ul></blockquote><h4 id="位移操作符的应用"><a href="#位移操作符的应用" class="headerlink" title="位移操作符的应用"></a>位移操作符的应用</h4><ol><li>随机数函数<blockquote><ul><li>Math.random()方法，可以得到 0-1 之间的小数，随机生成</li><li>得到 [a , b] 区间的整数，方式如下:<ul><li>方法1：parseInt(Math.random() * (b - a + 1)) + a;</li><li>方法2：(Math.random() * (b - a + 1)&gt;&gt;0) + a;用任一位<strong>运算符</strong>都可以</li><li>方法3：Math.floor(Math.random() * (b - a + 1)) + a;</li><li>方法4：Math.round(Math.random() * b)+a;<blockquote><p>只有<code>Math.round</code>是向上取整，四舍五入，可以取到<code>1</code></p></blockquote></li></ul></li></ul></blockquote></li></ol><p><strong>推算过程：</strong></p><blockquote><p>要得到 [0 , 5] 区间的<strong>整数</strong></p><ul><li>Math.random()方法，可以得到 0-1 之间的小数</li><li>Math.random()*6，可以得到<code>0-6</code>之间的随机数</li><li>去掉小数，就可以得到[0 , 5] 区间的整数</li></ul></blockquote><blockquote><blockquote><p>要得到 [5 , 8] 区间的<strong>整数</strong></p></blockquote><ul><li>Math.random()方法，可以得到 0-1 之间的小数</li><li><code>Math.random()*4</code>，可以得到<code>0-4</code>之间的随机数</li><li>Math.random()*4+5,可以得到 5-9 之间的小数</li><li>去掉小数，就可以得到[5 , 8] 区间的整数</li></ul></blockquote><ol start="2"><li>如何随机生成随机色（经典面试题）<br><strong>生成rgb(r,g,b)原理：</strong><blockquote><blockquote><p>十进制转rgb</p></blockquote><ul><li>利用<code>Math.random()</code>生成随机数<ul><li>var r &#x3D; parseInt(Math.random() * 256);</li><li>var g&#x3D; parseInt(Math.random() * 256);</li><li>var b &#x3D; parseInt(Math.random() * 256);</li></ul></li><li>用+号拼接出<code>rgb()</code>的值<ul><li><code>var rgb=&quot;(&quot;+r+&quot;,&quot;+g+&quot;,&quot;+b+&quot;)&quot;;</code></li><li>括号和逗号用<strong>引号</strong>包裹、用<strong>加号</strong>拼接，变量不需要</li></ul></li></ul></blockquote></li></ol><p><strong>生成HEX十六进制颜色原理：</strong></p><blockquote><blockquote><p>十进制转十六进制</p></blockquote><ul><li>随机生成十进制的数字，范围是<code>0~255</code></li><li>使用向上取整的<code>Math.round</code><ul><li><code>Math.round(Math.random() * 0xffffff)</code></li></ul></li><li>转换为十六进制<ul><li><code>.toString(16)</code></li></ul></li><li>不一定是六位数，所以需要在前面自动补<code>0</code><ul><li><code>.padStart(6, &quot;0&quot;)</code></li></ul></li><li>加上<code>#</code>号，使用+拼接</li></ul></blockquote><pre><code>&gt;// rgb颜色随机&gt;function rgb() &#123;&gt;  var r = Math.floor(Math.random() * 256);&gt;  var g = Math.floor(Math.random() * 256);&gt;  var b = Math.floor(Math.random() * 256);&gt;  var rgb = &quot;(&quot; + r + &quot;,&quot; + g + &quot;,&quot; + b + &quot;)&quot;;&gt;  return rgb;&gt;&#125;&gt;&gt;// 十六进制颜色&gt;var randomHex = function () &#123;&gt;  return (&gt;    &quot;#&quot; +&gt;    Math.round(Math.random() * 0xffffff)&gt;      .toString(16)&gt;      .padStart(6, &quot;0&quot;)&gt;  );&gt;&#125;;&gt;console.log(randomHex());&gt;&gt;// 十六进制颜色&gt;const randomColor = function () &#123;&gt;  return &quot;#&quot; + Math.random().toString(16).substr(2, 6);&gt;&#125;;&gt;console.log(randomColor());</code></pre><ol start="3"><li>GRB 颜色 转 16 进制颜色</li></ol><p><strong>基础知识</strong></p><table><thead><tr><th>RGB</th><th>R 对应范围</th><th>G 对应范围</th><th>B 对应范围</th></tr></thead><tbody><tr><td>rgb(0,24,255)</td><td>0-255</td><td>0-255</td><td>0-255</td></tr></tbody></table><table><thead><tr><th>16 进制</th><th>前两位对应 R，取值范围</th><th>中间两位对应 G，取值范围</th><th>最后两位对应 B，取值范围</th></tr></thead><tbody><tr><td>#05f3df</td><td>00-ff</td><td>00-ff</td><td>00-ff</td></tr></tbody></table><blockquote><img src="rgb转十六进制.png"></blockquote><p><strong>底层原理</strong></p><blockquote><p>将 rgb 的值，转成 32 位的二进制，然后再将 32 位二进制转成对应的 16 进制<br><img src="rgb转十六进制原理.png"></p></blockquote><blockquote><p><strong>过程分析：</strong></p><blockquote><ul><li>分别将rgb的三个值转为二进制，根据十六进制对应位置进行位移，组成一个二进制数，然后将它转为十六进制</li><li>每一个rgb值对应八位数，因为最大值255转换成八位数是<code>ffffffff</code></li><li>三个值拼接成32位的二进制数，最左边八位补0</li></ul></blockquote><ul><li><code>r</code>的值对应十六进制的前两位，也就是从右往左，第三个八位数，所以要左移16位才能到达</li><li><code>g</code>的值对应十六进制的中间两位，也就是从右往左，第二个八位数，所以要左移8位才能到达</li><li><code>b</code>的值对应十六进制的最后两位，也就是从右往左，第一个八位数，不用位移</li><li>位移之后怎么拼接？使用按位或<code>|</code><ul><li>按位或操作的两个位数，<strong>只要有一个</strong>是 1 就返回 1，两位都是 0 时返回 0</li></ul></li></ul></blockquote><pre><code>&gt;// rgb颜色转 16进制颜色&gt;function colorRGBToHex(rgb) &#123;&gt;  // rgbArr=[&#39;&#39;,&#39;2&#39;,&#39;33&#39;,&#39;55&#39;]&gt;  var rgbArr = rgb.split(/[^\d]+/);&gt;  // r 移掉丢掉高位   g移掉高位  b 不变&gt;  var color = (rgbArr[1] &lt;&lt; 16) | (rgbArr[2] &lt;&lt; 8) | rgbArr[3];&gt;  // color.toString(16) 的值，有可能不足6位，则需要向前补0&gt;  var _color = color.toString(16); // 转换成16进制&gt;  // padStart(6,&#39;0&#39;); // 不足6位，前面补0&gt;  return &quot;#&quot; + _color.padStart(6, &quot;0&quot;);&gt;&#125;&gt;var hexColor = colorRGBToHex(&quot;rgb(2,33,55)&quot;);&gt;console.log(hexColor); // #022137</code></pre><blockquote><p>**<code>.split(/[^\d]+/)</code>**，用非数字的值作为分隔符，将rgb值拆出来</p></blockquote><pre><code>&gt;var hexColor =(&quot;rgb(2,33,55)&quot;);&gt;var rgbArr = rgb.split(/[^\d]+/);&gt;console.log(rgbArr);&gt;// rgbArr=[&#39;&#39;,&#39;2&#39;,&#39;33&#39;,&#39;55&#39;,&#39;&#39;]&gt;console.log(rgbArr[1]);&gt;//rgbArr[1]=2</code></pre><blockquote><p><strong>toString 方法的三个作用</strong></p><ul><li>将其它类型转换为字符串类型</li><li>检测对象的类型</li></ul></blockquote><pre><code>&gt;Object.prototype.toString.call(arr) === &quot;[object Array]&quot;;</code></pre><blockquote><ul><li>返回该数字对应进制的字符串</li></ul></blockquote><pre><code>&gt;(10).toString(2); // 10 专为2进制是 &#39;1010&#39;&gt;(10).toString(16); // 10 转为 16制进是 &#39;a&#39;</code></pre><ol start="4"><li>16 进制转 RGB 颜色<blockquote><p><strong>原理：</strong>本质就是要把对应 16 进制的</p><ul><li>前 2 位转成 r 的值，</li><li>中间 2 位转成 g 的值，</li><li>后两位转成 b 的值</li></ul></blockquote></li></ol><blockquote><p><strong>思路</strong></p><ul><li>先去掉<code>#</code>，换成对应的<code>0x</code></li><li>把十六进制转换为32位的二进制数(只要做位移运算，就会<strong>自动</strong>把操作数转成 32 位二进制)</li><li>右移16位，得到<code>r</code>的二进制数，赋值时自动转成 10 进制</li><li>右移8位，同时<code>&amp; 0xff</code>，得到<code>g</code>的二进制数，赋值时自动转成 10 进制</li><li><code>&amp;0xff</code>，得到<code>b</code>的二进制数，赋值时自动转成 10 进制<img src="16进制转rgb.jpg"></li></ul></blockquote><pre><code>&gt;// 16进制颜色，转rgb&gt;function colorHexToRGB(hex) &#123;&gt;  var newHex = hex.replace(&quot;#&quot;, &quot;0x&quot;);&gt;  var r = newHex &gt;&gt; 16;&gt;  var g = (newHex &gt;&gt; 8) &amp; 0xff;&gt;  var b = newHex &amp; 0xff;&gt;  return &quot;rgb(&quot; + r + &quot;,&quot; + g + &quot;,&quot; + b + &quot;)&quot;;&gt;&#125;&gt;console.log(colorHexToRGB(&quot;#022137&quot;)); // rgb(2,33,55)</code></pre>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JS核心知识点（一）</title>
      <link href="/2023/12/01/JS%E6%A0%B8%E5%BF%83%E7%9F%A5%E8%AF%86%E7%82%B9%EF%BC%88%E4%B8%80%EF%BC%89/"/>
      <url>/2023/12/01/JS%E6%A0%B8%E5%BF%83%E7%9F%A5%E8%AF%86%E7%82%B9%EF%BC%88%E4%B8%80%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<span id="more"></span><h2 id="JS简介、核心语法、变量"><a href="#JS简介、核心语法、变量" class="headerlink" title="JS简介、核心语法、变量"></a>JS简介、核心语法、变量</h2><h3 id="一、js简介"><a href="#一、js简介" class="headerlink" title="一、js简介"></a>一、js简介</h3><ol><li>HTML、CSS、JavaScript 三者之间的关系</li></ol><table><thead><tr><th>前端三层</th><th>语言</th><th>功能</th><th>类比1</th><th>类比 2</th></tr></thead><tbody><tr><td>结构层</td><td>HTML</td><td>搭建结合、放置部件、描述语义</td><td>房子的框架</td><td>人的骨架</td></tr><tr><td>样式层</td><td>CSS</td><td>美化页面、实现布局</td><td>对房子装修</td><td>给人打扮、化妆</td></tr><tr><td>行为层</td><td>JavaScript</td><td>实现交互效果、数据收发、表单验证等</td><td>房子通水、通电</td><td>人的各种行为</td></tr></tbody></table><blockquote><ul><li>交互效果：比如网站看到的鼠标滑动显示的下拉菜单、轮播图、选项卡等网页特效</li><li>数据收发：网站页面的数据，都是能通过 ajax 向后台发送请求，然后后台把数据返回给到前端，我们再把数据渲染到页面中。</li><li>表单验证：当我们提交一个注册表单时，会验证我们输入的邮箱、手机、密码等格式是否符合要求，这些都是通过 JS 来验证的。</li></ul></blockquote><ol start="2"><li>JavaScript 发展史<blockquote><p>布兰登.艾奇 (Brendan Eich) JavaScript 创始人， 人称 JS 之父</p></blockquote></li></ol><blockquote><p><strong>JavaScript 创建背景</strong></p><ul><li>1995 年 34 岁的系统程序员 Brendan Eich，任职于网景公司（Netscape ，美国一家专注浏览器的公司）</li><li><code>JavaScript</code>当时开发的目的，处理用户在浏览器端的<strong>输入验证（常说的表单验证）</strong></li><li>布兰登.艾奇，仅用 10 天时间就把 JavaScript 设计出来了 😃</li><li><code>JavaScript</code> 的前身叫<code>LiveScript</code>，后面改名为<code>JavaScript</code></li></ul></blockquote><blockquote><p><strong>Java 与 JavaScript 的关系 ？</strong><br>本质上是没有任何关系，就好像老婆与老婆饼的关系，雷锋与雷峰塔的关系。</p></blockquote><blockquote><p><strong>JavaScript 的早期设计思路</strong></p><ul><li>借鉴 C 语言的基本语法</li><li>借鉴 Java 语言的数据类型和内存管理</li><li>借鉴 Scheme 语言，将函数提升到”第一等公民”(first class)的地位</li><li>借鉴 Self 语言，使用基于原型(prototype)的继承机制<blockquote><p>所以，JavaScript 语言实际上是两种语言风格的混合产物 -（简化的）函数式编程 +（简化的）面向对象编程</p></blockquote></li></ul></blockquote><blockquote><p><strong>JavaScript 的地位</strong></p><ul><li>JavaScript 垄断了浏览器端脚本语言，绝对唯一的霸主<blockquote><p>在这之前其实有三种脚本语言 VBScript 、JScrip、JavaScript 。随着时间的推移，有两种被淘汰了，只剩下 JavaScript</p></blockquote></li><li>任何做浏览器端开发的工程师都不可能绕开 JavaScript</li><li>js 现在能做什么？<ul><li>表单动态校验（密码强度检测）js 产生的最初目的</li><li>网页特效</li><li>服务端开发 Node.js (Node.js 是 JS 的一个运行平台)</li><li>桌面程序(Electron)</li><li>APP(Cordova)</li><li>游戏开发(cocos2d-js)</li></ul></li></ul></blockquote><ol start="4"><li>前端 与 后端<blockquote><p><strong>如何理解前端（客户端）</strong></p><ul><li>所谓前端（客户端），其本质就是直接面向用户的那一端。</li><li>前端主要是用来：处理界面，交互逻辑，用户能看见的东西，是我们前端开发要解决的问题</li><li>前端开发的主要编程语言：HTML、CSS、JavaScript<br><strong>如何理解后端（服务端）</strong></li><li>后端主要是用来：操作数据库，实现数据的增删改查，处理数据。</li><li>后端开发主要的编程语言：Java、Python、PHP、C&#x2F;C++、GO</li><li>前端和后端通过 HTTP 协议进行传输</li></ul></blockquote></li></ol><blockquote><p><strong>JavaScript 是一种前端开发语言，为什么他现在可以做服务端开发 ？</strong><br>在 2009 年，JavaScript 诞生了一个著名的平台 <code>NodeJS</code>。NodeJS 就是 JavaScript 的一个运行平台，NodeJS 的诞生，让 JS 的触角延伸到了服务器端。 也就是说随着 NodeJS 的诞生，JS 也可以操作数据库了，也就可以做服务端开发。</p></blockquote><ol start="5"><li>ECMAScript 与 JavaScript 的关系<blockquote><ul><li>1996 年 11 月，网景公司将 JavaScript 提交给欧洲计算机制造商协会（ECMA）进行标准化。</li><li>1997 年，欧洲计算机制造商协会（ECMA）设置了 JavaScript 的标准，命名为 ECMAScript</li></ul></blockquote></li></ol><blockquote><p><strong>JavaScript 有 ECMAScript 的关系</strong></p><ul><li>JavaScript 是语言，ECMAScript 是标准</li><li>JavaScript 实现了 ECMAScript 标准，而 ECMAScript 标准规范了 JavaScript</li></ul></blockquote><ol start="6"><li>JavaScript 知识体系<blockquote><ul><li>语言核心（ECMAScript5）</li><li>DOM （Document Object Model）文档对象模型</li><li>BOM （Browser Object Model）浏览器对象模型</li></ul></blockquote></li></ol><blockquote><p><strong>语言核心（ECMAScript5）</strong></p><ul><li>我们接下来要学习的 JS 语言核心，就是<strong>ECMAScript5</strong>中的标准，标准中规定了语言的</li><li>基本语法</li><li>类型</li><li>语句</li><li>关键字</li><li>保留字</li><li>操作符</li><li>全局对象<blockquote><p>学习完这个后，才会再学习后面的 ECMAScript6、7、8、9….13</p></blockquote></li><li>ES6 对应的是 ECMAScript2015( ES2015）改动最多，主要是让 JS 工程化，构建化，所以我们常把 ES6 之后的归到 ES6。</li><li>其它不同版本间的对应关系如下<ul><li>ES7（ES2016）、ES8（ES2017）、ES9（ES2018）、ES10（ES2019）、ES11（ES2020）、ES12（ES2021）、ES13（ES2022）</li></ul></li></ul></blockquote><blockquote><p><strong>DOM（Document Object Model）文档对象模型</strong><br>DOM 将整个页面抽象为一组分层节点（DOM 树），开发者可以通过操作 DOM 树来随心所欲的控制网页的内容和结构和样式。<br>我们常见的网页特效，就是通过 JS 来操作 DOM 实现的</p><ul><li>Document文档，表示的就是整个HTML网页文档</li><li>Object对象，表示将网页中的每一个部分都转换为一个对象</li><li>Model模型，表示对象之间的关系，这样方便我们获取对象。</li></ul></blockquote><blockquote><p><strong>BOM（Browser Object Model）浏览器对象模型</strong></p><ul><li>BOM 用于支持访问和操作浏览器的窗口，JS 通过操作 BOM，可以获取窗口的大小，窗口输入的地址，控制前进和后退，监听窗口大小的改变等</li></ul></blockquote><ol start="7"><li>JavaScript 为何称为脚本语言<blockquote><ul><li>所谓的脚本语言：是指不需要提前编译，运行的过程中边编译，边执行。</li><li>JS 本质上就是在运行过程中边编译，边执行的，JS 是由 JS 解释器（JS 引擎）来逐行进行解释并执行</li></ul></blockquote></li></ol><blockquote><p><strong>什么是 JS 解释器 ？</strong><br>这就需要我们了解浏览器的两大组成部分：渲染引擎 和 JavaScript 引擎</p><ul><li>渲染引擎：用来解析 HTML 与 CSS，俗称内核，比如 chrome 浏览器的 blink，老版本的 webkit</li><li>JS 引擎： 也称为 JS 解释器，用来读取网页中的 JavaScript 代码，对其处理后运行。比如 chrome 浏览器的 V8 引擎。<blockquote><p>浏览器本身并不会执行 JS 代码，而是通过内置 <strong>JavaScript 引擎（解释器）</strong>来编译和执行 JS 代码。JS 引擎执行代码时逐行解释每一句源码（转换为机器语言），然后由计算机去执行。</p></blockquote></li></ul></blockquote><h3 id="二、javascript基础语法"><a href="#二、javascript基础语法" class="headerlink" title="二、javascript基础语法"></a>二、javascript基础语法</h3><ol><li>书写位置<blockquote><p><strong>行内式</strong></p><ul><li>直接写在标签上，有点类似行内样式，这种写法基本不用，只做了解。</li></ul></blockquote></li></ol><pre><code>&gt;&lt;div onclick=&quot;alert(&#39;主人，你好&#39;);&quot;&gt;点我&lt;/div&gt;&gt;&lt;a href=&quot;JavaScript:;&quot;&gt;禁止页面刷新&lt;/a&gt;</code></pre><blockquote><p><strong>内部js</strong></p><ul><li>JS 代码直接写在写在<script><strong>标签内部</strong></li><li><script>标签，可以写在`<head></head>`标签中，也可以写在`<body></body>`标签中</li><li><script>标签中的type属性表示将<script></script>之间的文本内容，在浏览器中要转换为 js 脚本执行，现在可以省略不写。</li></ul></blockquote><blockquote><p><strong>外部js</strong></p><ul><li>把 js 代码，单独保存在一个 js 文件中</li><li>通过<code>&lt;script&gt;</code>标签的 src 属性来加载 js 文件</li><li><code>&lt;script&gt;</code>标签可以写在 head 或 body 标签中</li><li>如果采用了外部 JS 的写法，则<code>&lt;script&gt;</code>标签中，不能再写 JS 代码，写了也不会生效</li></ul></blockquote><pre><code>&gt;&lt;!--错误写法，如果src属性中引入了外部js文件，则&lt;script&gt;标签不能再写js代码--&gt;&gt;&lt;script src=&quot;js/demo.js&quot;&gt;&gt;  alert(&#39;错误写法，弹窗不会弹出&#39;);&gt;&lt;/script&gt;</code></pre><blockquote><blockquote><p>注意1：在实际的开发中，我们常用的就是外部 JS 这种写法，因为他有很多优点<br><strong>优点：</strong></p></blockquote><ul><li><p>结构彻底分离</p></li><li><p>多页面可以进行复用</p></li><li><p>后期好维护修改</p></li><li><p>浏览器可以根据特定的设置缓存所有外部 JS 文件，所以多个页面都用到同一个文件，那么这个文件只需要下载一次，页面加载速度更快。如果后续再打开网页，浏览器会直接从缓存中读取。</p></li></ul><p> <strong>唯一缺点：</strong></p><ul><li>增加请求数（外部文件），但相对上面的优点，完全可以忽略不计。<blockquote><p>提示：html文件是不会被缓存的！但css和js文件会被缓存，如果做了修改，就得重命名才能重新加载</p></blockquote></li></ul></blockquote><blockquote><blockquote><p>注意2：Javascrip 文件不能脱离 HTML 网页运行，只有在后面学到 Node.JS 时，JS 可以在 NodeJS 平台上独立运行。</p></blockquote></blockquote><ol start="2"><li>JS 注释<blockquote><ul><li>阿里巴巴js注释规范：<a href="https://github.com/airbnb/javascript#comments">https://github.com/airbnb/javascript#comments</a></li><li>百度js注释规范：<a href="https://github.com/ecomfe/spec/blob/master/javascript-style-guide.md#user-content-24-%E6%B3%A8%E9%87%8A">https://github.com/ecomfe/spec/blob/master/javascript-style-guide.md#user-content-24-%E6%B3%A8%E9%87%8A</a></li></ul></blockquote></li></ol><blockquote><p><strong>单行注释：</strong></p><ul><li><code>// ……</code></li><li>快捷键：<code>ctrl+/</code><br><strong>多行注释：</strong></li><li><code>/* */</code></li><li>快捷键<code>Alt + shift + a</code></li></ul></blockquote><ol start="3"><li><p>JavaScript 中的注意事项</p><blockquote><ul><li>严格区分<strong>大小写</strong></li><li>语句字符都要是<strong>英文</strong>状态下（字符串可以使用任意字符）</li><li>每条语句以<strong>分号（;）</strong>结尾<ul><li>如果不写分号，意味着由解析器来确定语句在哪里结尾。</li><li>加分号有助于在某些情况下提升性能，因为解析器会尝试在合适的位置补上分号以纠正语法错误</li><li>如果不加分号，在后期压缩代码时，有可能会造成语法错误</li><li>而且有些时候，浏览器会加错分号，所以在开发中分号必须写</li></ul></li><li>JS 中会忽略多个空格和换行<ul><li>可以利用空格和换行，对代码进行格式化，这样写出来的代码更美观</li></ul></li></ul></blockquote></li><li><p>JS 中的输入输出语句</p><blockquote><p><strong>alert('弹窗')</strong></p><ul><li>alert() 语句，会在页面打开时，弹出弹窗</li><li>alert()语句，会阻止程序的执行，他会在此代码执行确认后，才会接着执行后面的代码</li><li>可以用来调式代码</li></ul></blockquote></li></ol><blockquote><p>console.log('控制台输出内容')</p><ul><li>浏览器控制台打印输出信息</li><li>他<strong>不会</strong>打断程序运行</li><li>常用来调试代码</li><li>可以一次打印多条内容，每条内容间用<code>,</code>逗号隔开</li></ul></blockquote><blockquote><p>prompt('提示用户输入信息')</p><ul><li>浏览器弹出输入框，用户输入内容</li></ul></blockquote><blockquote><blockquote><p><code>alert</code>、<code>console.log</code>和<code>prompt</code> 中，如果输入的是<strong>数字、已声明的变量</strong>，则不用加引号；如果输入的是<strong>字符串</strong>，则要加上''单引号或""双引号包裹。</p></blockquote></blockquote><h3 id="三、javascript变量与字面量"><a href="#三、javascript变量与字面量" class="headerlink" title="三、javascript变量与字面量"></a>三、javascript变量与字面量</h3><ol><li>硬盘、内存、CPU 三者关系<blockquote><p>硬盘，内存，CPU 三者各自的作用</p><table><thead><tr><th>名称</th><th>作用</th></tr></thead><tbody><tr><td>硬盘</td><td>负责程序和数据的<strong>永久存储</strong>，断电数据不丢失的特点</td></tr><tr><td>内存</td><td>负责<strong>连接</strong>CPU和硬盘；存储<strong>临时</strong>使用的数据;保存从硬盘读取的数据，提供给 CPU 使用；保存 CPU 的一些临时执行结果，以便 CPU 下次使用或保存到硬盘；<strong>断电数据就会清空，丢失</strong></td></tr><tr><td>CPU</td><td>运行<strong>总指挥</strong>，负责发指令，数据处理与计算</td></tr></tbody></table></blockquote></li></ol><p><strong>他们三者之间如何工作的？</strong></p><blockquote><p>当我们要运行某个程序时：</p><ul><li>CPU首先接受到我们的命令，</li><li>然后它(CPU)告诉<strong>硬盘</strong>：我要运行存储在你那的程序，你把该程序送到<strong>内存</strong>去</li><li>CPU对<strong>内存</strong>说，我让硬盘把程序送到你这里来了，你保存一下。</li><li>等该程序被完整的送到内存之后。CPU就开始执行程序，可以进行一系列操作</li><li>当我们在编辑文档等程序时，如果没有<code>ctrl+s</code>，那么此时编辑的数据是存储在内存的，只有<code>ctrl+s</code>后才会保存到硬盘</li><li>因此，没有<code>ctrl+s</code>的数据，一旦断电就无法恢复，因为内存只能临时存储数据</li></ul></blockquote><p><strong>CPU 可以直接从硬盘中读取数据，为什么要在中间加一个内存呢？</strong></p><blockquote><ul><li>因为CPU的处理速度特别快，而硬盘的读取和存储数据的速度特别的慢</li><li>如果直接从硬盘读数据，而硬盘的速度跟上不 CPU 的速度，就会对 CPU 造成很大的浪费，同时我们操作电脑时，就会很卡。</li><li>而内存的数据就很快了，他可以跟上 CPU 的处理速度。</li><li>内存就是为了解决 cpu 和硬盘之间速度不匹配的冲突，内存是由电流实现的存取速度，相当快，不过断电就丢失。</li></ul></blockquote><p><strong>总结</strong></p><table><thead><tr><th>名称</th><th>作用</th><th>速度</th><th>类比</th></tr></thead><tbody><tr><td>硬盘</td><td>负责程序和数据的永久存储，断电数据不丢失的特点</td><td>很慢</td><td>大仓库</td></tr><tr><td>内存</td><td>负责连接CPU和硬盘；存储临时使用的数据；断电数据就会清空，丢失</td><td>很快，几乎硬盘的 100 倍</td><td>中转站</td></tr><tr><td>CPU</td><td>运行总指挥，负责发指令，数据处理与计算</td><td>很快，几乎硬盘的 100 倍</td><td>车间</td></tr></tbody></table><blockquote><blockquote><p>CPU，内存 决定你电脑运行的快慢，硬盘决定你可以放东西的多少 ！</p></blockquote></blockquote><ol start="2"><li><p>什么是变量</p><blockquote><ul><li>大白话：变量就是一个用来装东西的盒子，再往深里说，他就是用来存放数据的容器。</li><li>变量的本质： 变量是程序在内存中申请的一块用来存放数据的空间。</li></ul></blockquote></li><li><p>如何声明变量</p><blockquote><ul><li>在 js 中，使用<code>var</code>关键词来<strong>声明</strong>一个变量</li><li>a是自定义的<strong>变量名</strong></li><li>使用 var 关键字声明变量后，计算机会自动为变量分配<strong>内存空间</strong>，用来存储变量的值</li><li>变量声明后，就可以给变量<strong>赋值</strong>，<code>= </code>等号表示赋值</li></ul></blockquote></li></ol><pre><code>&gt;var a;&gt;a=&quot;小米&quot;</code></pre><blockquote><ul><li>通过变量名就可以访问变量在内存中存储的值。</li><li>赋值后我们就可以使用他了，我们可以在控制台通过输出语句输出变量 a 的值</li></ul></blockquote><pre><code>&gt;console.log(a);</code></pre><ol start="4"><li>变量的初始化<blockquote><p>我们在<strong>声明</strong>一个变量的<strong>同时</strong>为其<strong>赋值</strong>，称为变量的初始化</p></blockquote></li></ol><pre><code>&gt;var a=&quot;张三&quot;;&gt;concole.log(a);</code></pre><ol start="5"><li>更新变量的值<blockquote><ul><li>一个变量被重新赋值后，他之前的值就会被覆盖</li></ul></blockquote></li></ol><pre class=" language-js"><code class="language-js"><span class="token operator">></span><span class="token keyword">var</span> name <span class="token operator">=</span> <span class="token string">"张三"</span><span class="token punctuation">;</span><span class="token operator">></span><span class="token comment" spellcheck="true">// 给变量name 重新赋值</span><span class="token operator">></span>name <span class="token operator">=</span> <span class="token string">"李四"</span><span class="token punctuation">;</span><span class="token operator">></span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><ol start="6"><li>同时声明多个变量<br><strong>先声明后赋值：</strong></li></ol><pre class=" language-js"><code class="language-js"><span class="token operator">></span><span class="token keyword">var</span> x<span class="token punctuation">,</span>y<span class="token punctuation">,</span>x<span class="token punctuation">;</span><span class="token operator">></span>x<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span><span class="token operator">></span>y<span class="token operator">=</span><span class="token number">2</span><span class="token punctuation">;</span><span class="token operator">></span>z<span class="token operator">=</span><span class="token number">3</span><span class="token punctuation">;</span><span class="token operator">></span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>x<span class="token punctuation">,</span>y<span class="token punctuation">,</span>z<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p><strong>声明的同时赋值</strong></p><pre><code>&gt; var x=1,&gt;   y=2,&gt;   z=3;&gt;   console.log(x,y,z);</code></pre><p><strong>声明过程可赋值，可不赋值</strong></p><pre><code>&gt; var x,&gt;    y = 1,&gt;    z = 4;&gt;//在声明之后为x赋值&gt;  x = 2;&gt;  console.log(x, y, z);</code></pre><ol start="7"><li>声明变量的几种特殊情况<blockquote><ul><li>声明变量，但没有赋值，默认值为<code>undefined</code><blockquote><p>我们后期如果要判断一个变量是否成功赋值，我们就可以通过检测他的值是否是 undefined 来判断</p></blockquote></li><li>不声明变量,直接进行赋值</li></ul></blockquote></li></ol><pre><code>&gt;&lt;script&gt;&gt;  x = 7;&gt;  // 控制台输出得到的结果是 7&gt;  console.log(x);&gt;&lt;/script&gt;</code></pre><blockquote><blockquote><p>这是 js 的一个语法特性，只需要了解就好，在实际开发中非常<strong>不推荐</strong>这样写。</p></blockquote><ul><li>直接输出一个不存在的变量</li></ul></blockquote><pre class=" language-js"><code class="language-js"><span class="token operator">></span><span class="token operator">&lt;</span>script<span class="token operator">></span><span class="token operator">></span>  <span class="token comment" spellcheck="true">// 控制台**会报错** z is not defined</span><span class="token operator">></span>  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>z<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token operator">></span><span class="token operator">&lt;</span><span class="token operator">/</span>script<span class="token operator">></span></code></pre><ol start="8"><li>变量的命名（标识符）<blockquote><p>变量的命名必需要遵守一定的规则。</p><ul><li>标识符：在 js 中所有可以由我们自主命名的都可以称为标识符</li></ul></blockquote></li></ol><p><strong>标识符的命名规则</strong></p><blockquote><ul><li>只能由字母，数字，_下划线，$组成，但<strong>不能</strong>以数字开头</li><li>严格区分<strong>大小写</strong>，a 和 A 是两个不同的变量</li><li>不能使用<strong>关键字</strong>或<strong>保留字</strong>做为变量名</li></ul></blockquote><p><strong>关键字和保留字</strong></p><blockquote><ul><li>关键字：就是 JavaScript 语言本身已经使用的一些单词。这些单词具有特定的用途，用户自定义的标识符（名字）不能与关键字相同 。</li><li>保留字：就是 JavaScript 语本身没有使用，但是考虑后期随之着 JS 的发展，可能会使用的一些单词。这些单词建议用户不要使用。</li><li>以下是部分关键字和保留字：<table><thead><tr><th>abstract</th><th>arguments</th><th>boolean</th><th>break</th><th>byte</th></tr></thead><tbody><tr><td>case</td><td>catch</td><td>char</td><td>class*</td><td>const</td></tr><tr><td>continue</td><td>debugger</td><td>default</td><td>delete</td><td>do</td></tr><tr><td>double</td><td>else</td><td>enum*</td><td>eval</td><td>export*</td></tr><tr><td>extends*</td><td>false</td><td>final</td><td>finally</td><td>float</td></tr><tr><td>for</td><td>function</td><td>goto</td><td>if</td><td>implements</td></tr><tr><td>import*</td><td>in</td><td>instanceof</td><td>int</td><td>interface</td></tr><tr><td>let</td><td>long</td><td>native</td><td>new</td><td>null</td></tr><tr><td>package</td><td>private</td><td>protected</td><td>public</td><td>return</td></tr><tr><td>short</td><td>static</td><td>super*</td><td>switch</td><td>synchronized</td></tr><tr><td>this</td><td>throw</td><td>throws</td><td>transient</td><td>true</td></tr><tr><td>try</td><td>typeof</td><td>var</td><td>void</td><td>volatile</td></tr><tr><td>while</td><td>with</td><td>yield</td><td>eval</td><td>arguments</td></tr></tbody></table></li></ul></blockquote><ol start="9"><li>推荐两种优秀的命名法<br><strong>驼峰命名</strong>（最推荐）<blockquote><ul><li><strong>首个</strong>单词小写，其余每个单词开头字母大写<br><code>myFirstName 、myStudentCount 、getBoxColor、navList</code><blockquote><p>不建议使用全小写 myfirstname，可读性差</p></blockquote></li></ul></blockquote></li></ol><p><strong>C 语言风格</strong></p><blockquote><ul><li>所有单词全小写，单词之间用_下划线分隔<br><code>my_first_name 、 my_student_count</code></li></ul></blockquote><p>匈牙利命名法（了解即可）</p><blockquote><ul><li>基本原则是：变量名=属性+类型+对象描述</li></ul></blockquote><pre class=" language-js"><code class="language-js"><span class="token operator">></span><span class="token comment" spellcheck="true">// i 提示变量类型为 整型</span><span class="token operator">></span>iMyStudentCount<span class="token punctuation">;</span></code></pre><ol start="10"><li>字面量<blockquote><p>可以理解为<strong>不可能发生改变</strong>的(固定)值。他就是他的字面意思。</p></blockquote></li></ol><pre class=" language-js"><code class="language-js"><span class="token operator">></span><span class="token operator">&lt;</span>script<span class="token operator">></span><span class="token operator">></span>  <span class="token keyword">var</span> A <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span><span class="token operator">></span>  <span class="token keyword">var</span> A <span class="token operator">=</span> <span class="token string">"我爱你"</span><span class="token punctuation">;</span><span class="token operator">></span>  <span class="token keyword">var</span> A <span class="token operator">=</span> <span class="token string">"优秀"</span><span class="token punctuation">;</span><span class="token operator">></span><span class="token operator">&lt;</span><span class="token operator">/</span>script<span class="token operator">></span></code></pre><blockquote><ul><li>源代码解读<ul><li>上面代码中，1，'我爱你'，'优秀' 就是字面量。</li><li>A 是变量，A 可以表示 1，也可以表示'我爱你'，还可以表示'优秀'。</li><li>在实际开发中，我们都是<strong>通过变量来保存一个字面量</strong>，然后只需要在每次用到字面量的地方，调用下该变量就好</li></ul></li></ul></blockquote><h3 id="四、综合案例"><a href="#四、综合案例" class="headerlink" title="四、综合案例"></a>四、综合案例</h3><ol><li><p>弹出用户输入的信息 </p><blockquote><p><strong>需求：</strong></p><ul><li>当用户打开浏览器时，弹出输入框，要求用户输入姓名，点击确认后，以弹窗形式，显示用户的姓名。<br><strong>实现思路：</strong></li><li>使用 prompt() 函数弹出输入框，让用户输入内容</li><li>要通过变量来接受 prompt() 函数的返回值</li><li>通过 alert()函数，显示结果</li></ul></blockquote></li><li><p>如何交换两变量的值</p><blockquote><p><strong>需求：</strong></p><ul><li>定义两个变量同时赋值，然后交换两个变量中的值。<br><strong>实现思路：</strong></li><li>这里我们可以用现实生活中的例子来解答这道题</li><li>首先定义两个变量 apple 和 pear，然后分别赋值"苹果"和"梨子"</li><li>我们把这两个变量想像成两个盘子，变量的值，想像成盘子中放入了苹果和梨子。</li><li>现在的需求就是要把苹果放到 pear 盘中去，把梨子放到苹果盘子中去。</li><li>所以我们需要再借助第三个盘子，再声明一个变量 desk，不赋值。相当于空盘子</li><li>然后把苹果放到空盘子中 desk 中，再把梨子放到苹果盘中，再把 desk 盘中的苹果放到梨子盘中，就 ok 了</li></ul></blockquote></li></ol><h3 id="五、处理报错和REPL环境"><a href="#五、处理报错和REPL环境" class="headerlink" title="五、处理报错和REPL环境"></a>五、处理报错和REPL环境</h3><ol><li><p>处理报错</p><blockquote><p>在初学 JS 的时候，我们经常会写错代码，造成控制台报错，初学者经常会遇到以下两种常见错误</p><ul><li>Uncaught SyntaxError：未捕获的语法错误,<ul><li>常见的是使用了中文符号</li></ul></li><li>Uncaught ReferenceError：引用错误<ul><li>常见的是：误把字符串当变量用，或找不到变量，变量未定义</li></ul></li></ul></blockquote></li><li><p>REPL 执行环境</p><blockquote><ul><li>REPL(Read-Eval-Print-Loop)：交互式解析器</li><li>在 REPL 环境下，可以<strong>定义和运行</strong>变量、函数、对象</li><li><code>console</code>控制台其实也是一个 REPL 环境，可以使用它<strong>临时测试</strong>表达式的值<img src="REPL.png"></li></ul></blockquote></li></ol><blockquote><p>在控制台书写代码后，按回车，就会进入上面四个流程：</p><ul><li>先<strong>读取</strong>代码，再<strong>执行</strong>，执行后把结果<strong>打印</strong>出来，然后又可以<strong>重复</strong>刚才的动作。</li><li>接着在控制台书写代码，然后回车，又会进入上面四个流程</li></ul></blockquote><h2 id="JS数据类型和类型转换"><a href="#JS数据类型和类型转换" class="headerlink" title="JS数据类型和类型转换"></a>JS数据类型和类型转换</h2><h3 id="一、数据类型简介和检测"><a href="#一、数据类型简介和检测" class="headerlink" title="一、数据类型简介和检测"></a>一、数据类型简介和检测</h3><ol><li><p>为什么需要数据类型</p><blockquote><ul><li>程序需要处理大量的不同数据，如果用同一种方式处理那肯定是处理不了的。所以在计算机中同样需要将数据分成不同类型，然后用不同的方式来处理和计算。</li><li>数据类型背后，隐藏的是编译器或者解释器对数据处理方式的定义。把数据分成不同的数据类型，然后用使用不同的处理方式</li></ul></blockquote></li><li><p>JS 中数据类型的分类</p><blockquote><p>7 种<strong>基本</strong>数据类型（值类型）</p><ul><li>String 字符串类型</li><li>Number 数字类型</li><li>Boolean 布尔类型</li><li>Null 类型</li><li>Undefined 未定义</li><li>Symbol 符号</li><li>BigInt 任意精度的整数<br><strong>引用数据</strong>类型（对象类型）</li><li>对象（Object）、数组（Array）、函数（Function）</li><li>还有两个特殊的对象：正则（RegExp）和日期（Date）。</li></ul></blockquote></li><li><p>变量的类型</p><blockquote><ul><li>在 JS 中，变量的数据类型是由变量中存储的值的数据类型来决定的。</li><li>同时 JS 是一种弱类型的语言，他不用提前声明变量的类型。</li><li>代码运行时，变量的数据类型是由JS引擎根据=右边变量的数据类型来判断的。</li><li>运行完毕之后，变量就确定了数据类型。</li><li>也就是说相同的变量在不同的时刻可以是不同的类型。</li></ul></blockquote></li></ol><pre class=" language-js"><code class="language-js"><span class="token operator">></span><span class="token operator">&lt;</span>script<span class="token operator">></span><span class="token operator">></span>  <span class="token keyword">var</span> a <span class="token operator">=</span> <span class="token string">"小明"</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 此时a是 string字符串类型</span><span class="token operator">></span>  a <span class="token operator">=</span> <span class="token number">23</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 此时a就是 number 数字类型</span><span class="token operator">></span>  a <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 此时a就是 boolean布尔型</span><span class="token operator">></span><span class="token operator">&lt;</span><span class="token operator">/</span>script<span class="token operator">></span></code></pre><ol start="4"><li>typeof 操作符<blockquote><p><code>typeof</code> 检测返回值的类型，然后 <code>console.log</code> 把值的类型在控制台输出。</p><ul><li>JS 有很多种数据类型，我们需要有一种手段来确定变量的数据类型，那么<code>typeof</code>运算符就可以做到。</li><li>使用 typeof 运算符可以检测值或者变量的类型。</li><li>用法：<ul><li>检测<strong>值</strong>类型 typeof 值; 或 typeof(值)</li><li>检测<strong>变量</strong>类型 typeof 变量名; 或 typeof(变量名)</li><li>如果 typeof 标测的是一个<strong>表达式</strong>，则一定要带上括号,如 typeof(2+'2');</li></ul></li></ul></blockquote></li></ol><pre class=" language-js"><code class="language-js"><span class="token operator">></span><span class="token comment" spellcheck="true">//值类型</span><span class="token operator">></span> console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">typeof</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// number</span><span class="token operator">></span> console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">typeof</span> <span class="token string">"艾编程"</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// string</span><span class="token operator">></span> console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">typeof</span> <span class="token punctuation">(</span><span class="token number">2</span> <span class="token operator">+</span> <span class="token string">"2"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// string</span><span class="token operator">></span><span class="token comment" spellcheck="true">//变量类型</span><span class="token operator">></span> <span class="token keyword">var</span> a <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">,</span><span class="token operator">></span>    b <span class="token operator">=</span> <span class="token string">"艾编程"</span><span class="token punctuation">;</span><span class="token operator">></span>  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">typeof</span> a<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// number</span><span class="token operator">></span>  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">typeof</span> b<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// string</span><span class="token operator">></span></code></pre><blockquote><blockquote><p>注意区分变量和值：变量是不能用' '单引号或"" 双引号包裹的，用<code>&#39;&#39;</code>或<code>“”</code>包裹的是字符串</p></blockquote><ul><li>typeof的<strong>返回值类型</strong>是字符串类型</li></ul></blockquote><pre class=" language-js"><code class="language-js"><span class="token operator">></span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">typeof</span> <span class="token keyword">typeof</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// string</span><span class="token operator">></span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">typeof</span> <span class="token keyword">typeof</span> 小米 <span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//string</span><span class="token operator">></span><span class="token comment" spellcheck="true">//注意：</span><span class="token operator">></span> <span class="token keyword">var</span> obj <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span><span class="token operator">></span> console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">typeof</span> <span class="token keyword">typeof</span> obj<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// string</span></code></pre><blockquote><ul><li>只要是通过输入框得到的值，typeof类型都是<code>string</code>字符串类型</li></ul></blockquote><pre><code>&gt;&lt;script&gt;&gt;  var age = prompt(&quot;请输入你的年龄&quot;); // 用户输入 18&gt;  console.log(typeof age);&gt;&lt;/script&gt;</code></pre><h3 id="二、5种基本数据类型"><a href="#二、5种基本数据类型" class="headerlink" title="二、5种基本数据类型"></a>二、5种基本数据类型</h3><blockquote><p>在接下的数据类型学习中，我们主要学习Number、String、Boolean、null、undefined 的 5 种基础数据类型<br>关于BigInt和Symbol在后面的 ES6 中，我们再来学习。</p></blockquote><h4 id="Number-数字类型"><a href="#Number-数字类型" class="headerlink" title="Number 数字类型"></a>Number 数字类型</h4><ol><li><p>什么是 Number 数字类型</p><blockquote><ul><li>所有数字都是 Number 类型，包括整数（正负数）和浮点数（小数）；</li><li>在表达小于 1 的数时，小数点前面的 0 可以去掉，比如 0.2可以写成.2</li></ul></blockquote></li><li><p>不同进制的数字</p><blockquote><p>不同进制在线转换工具：<a href="https://tool.lu/hexconvert/">https://tool.lu/hexconvert/</a></p></blockquote></li></ol><p><strong>二进制数</strong></p><blockquote><ul><li>二进制数以<code>0b</code>开头</li><li>二进制数字序列范围 0-1，逢 2 进 1</li></ul></blockquote><p><strong>八进制数</strong></p><blockquote><ul><li>八进制数值以<code>0</code>开头</li><li>八进制数字序列范围 0-7 ,逢 8 进 1</li></ul></blockquote><p><strong>十六进制数</strong></p><blockquote><ul><li>十六进制数以<code>0x</code>开头</li><li>十六进制序列范围 0-9 以及 A-F</li></ul></blockquote><p><strong>科学记数法</strong></p><blockquote><ul><li>对于非常大或非常小的数，我们可以用科学记数法来表示</li><li><code>e7</code>表示 <code>10</code> 的 7 次方，小数点<strong>向右</strong>移动 7 个点的位置</li><li><code>e-7</code>表示 <code>0.1</code> 的 7 次方，小数点<strong>向左</strong>移动 7 个点的位置</li></ul></blockquote><p><strong>数字中最大值和最小值</strong></p><blockquote><ul><li>由于内存的限制，js 中不支持表示这个世界上所有数值。js 中能表示的</li><li>最小数保存在 <code>Number.MIN_VALUE</code> 中</li><li>最大数保存在 <code>Number.MAX_VALUE</code> 中</li></ul></blockquote><p><strong>正无穷和负无穷大</strong></p><blockquote><ul><li>因为计算机内存限制，js 中不支持表示这个世界上所有数值。</li><li>如果计算的数值超出了 js 能表示正数范围，则会以 <code>Infinity</code> 正无穷表示</li><li>如果计算的数值超出了 js 能表示负数范围，则以<code>-Infinity</code> 负无穷表示<blockquote><p>非零数字除以<code>0</code>时，结果是<code>infinity</code>或<code>-infinity</code></p></blockquote></li></ul></blockquote><ol start="3"><li>NaN<blockquote><ul><li>NaN(Not a number) 不是一个数字</li><li>NaN 用 typeof 检测，得到的结果是 number，说明 NaN 是一个<strong>数字类型</strong></li><li>可以理解为 NaN <strong>不是数字</strong>的数字类型</li></ul></blockquote></li></ol><p><strong>NaN 的作用</strong></p><blockquote><ul><li>NaN 表示本来要返回的数值<strong>操作失败</strong>了</li><li>两个数值做运算，如果操作失败了，就会返回 NaN，而不是抛出错误</li><li>用 0 除任意数值<strong>在其他语言中</strong>通常都会导致错误，从而中止代码执行。<strong>但是在 js</strong> 中，不会，而是返回 NaN</li></ul></blockquote><p><strong>关于 NaN 的运算</strong></p><blockquote><ul><li>0 除以 0 的结果是 NaN</li><li>在数学运算中，如果得不到数字的结果，其结果往往是 NaN。</li><li>任何数与 NaN 做运算，都会得到 NaN，<strong>除了</strong>与<strong>字符串</strong>拼接。</li></ul></blockquote><pre><code>&gt;&lt;script&gt;&gt;  console.log(NaN + true + &quot;false&quot;);&gt;//NaN+true=NaN,NaN+字符串即拼接&gt;//结果为&quot;NaNfalse&quot;,typeof为string&gt;//字符串与任何类型拼接，得到的都是字符串类型&gt;&lt;/script&gt;</code></pre><blockquote><ul><li>NaN 自己不与自己相等</li></ul></blockquote><pre class=" language-js"><code class="language-js"><span class="token operator">></span>script<span class="token operator">></span><span class="token operator">></span> <span class="token keyword">var</span> a <span class="token operator">=</span> <span class="token number">0</span> <span class="token operator">/</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// NaN</span><span class="token operator">></span> <span class="token keyword">var</span> b <span class="token operator">=</span> <span class="token string">"a"</span> <span class="token operator">-</span> <span class="token string">"b"</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// NaN</span><span class="token operator">></span> <span class="token keyword">var</span> d <span class="token operator">=</span> <span class="token number">NaN</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// NaN</span><span class="token operator">></span> <span class="token keyword">var</span> str <span class="token operator">=</span> <span class="token number">NaN</span> <span class="token operator">+</span> <span class="token string">"1"</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//'NaN1'</span><span class="token operator">></span> console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span> b<span class="token punctuation">,</span> c<span class="token punctuation">,</span> d<span class="token punctuation">,</span> str<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token operator">></span> console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token number">NaN</span> <span class="token operator">==</span> <span class="token number">NaN</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// false</span><span class="token operator">></span><span class="token operator">&lt;</span><span class="token operator">/</span>script<span class="token operator">></span></code></pre><p><strong>isNaN()</strong></p><blockquote><ul><li>这个函数接收一个参数，可以是<strong>任意</strong>数据类型，然后判断这个参数是否<strong>“不是数值”</strong></li><li>isNaN 会尝试把它<strong>个值转换为数值</strong>，如果转换成数值字成功，也会认为是数字，则结果也是 false<blockquote><p>特别注意：isNaN 并不是用来判断这个参数是不是NaN这个值<br>isNaN(NAN)结果是true</p></blockquote></li><li>如果参数是数值，则返回 false，否则返回 true</li></ul></blockquote><pre class=" language-js"><code class="language-js"><span class="token operator">></span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token function">isNaN</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// false  1是一个数字，所以返回false假的</span><span class="token operator">></span><span class="token comment" spellcheck="true">//特别注意："1"原本是字符串，但被转换成了数字</span><span class="token operator">></span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token function">isNaN</span><span class="token punctuation">(</span><span class="token string">"1"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// false '1'被转成数字1，所以返回false</span></code></pre><h4 id="String字符串类型"><a href="#String字符串类型" class="headerlink" title="String字符串类型"></a>String字符串类型</h4><blockquote><ul><li>符串就是 "人类的自然语言"</li><li>字符串要用引号包裹，<strong>双引号</strong>或者<strong>单引号</strong>均可</li></ul></blockquote><ol><li><p>分清数字和字符串</p><blockquote><ul><li>数字11和字符串'11'在语义上是不同的，前者表达一个数量，后者是一个文本</li></ul></blockquote></li><li><p>双引号 与 单引号嵌套</p><blockquote><ul><li>双引号里面可以嵌套''单引号，单引号也可以嵌套""双引号</li><li><strong>但</strong>双引号里不能直接嵌套双引号，单引号里也不能直接嵌套单引号</li><li>单引号或双引号，在匹配的时候，都是以就近原则来进行匹配的</li><li>推荐使用单引号内嵌套双引号</li></ul></blockquote></li><li><p>转义字符</p><blockquote><p>如果需要在字符串中使用特殊字符，可以用转义符 \ 转义</p><table><thead><tr><th>转义符</th><th>解释说明</th></tr></thead><tbody><tr><td><code>\n</code></td><td>换行符， n 是 newline 的意思</td></tr><tr><td><code>\\</code></td><td>反斜杠<code> \</code></td></tr><tr><td><code>\&quot;</code></td><td><code>&#39;</code>单引号</td></tr><tr><td><code>\&quot;</code></td><td><code>&quot;</code>双引号</td></tr><tr><td><code>\t</code></td><td>tab 缩进</td></tr></tbody></table></blockquote></li><li><p>字符串的拼接</p><blockquote><ul><li><code>+ </code>号，可以用来拼接两个 或 多个字符串</li><li>字符串与<strong>任何</strong>类型拼接，得到的都是字符串</li><li>字符串与变量拼接时，变量不能添加引号</li></ul></blockquote></li><li><p>空字符串</p><blockquote><ul><li>空字符串，直按书写空的 ''单引号 或 ""双引号 表示空字符串</li><li>空字符中的空格会占一个字符</li><li>空字符串有什么用 ？<ul><li>可以用来转换数据类型</li><li>可以提前预设变量保存值为字符串类型，如果不设置为<code>&#39;&#39;</code>，有可能会出现错误的结果</li></ul></li></ul></blockquote></li><li><p>length 属性</p><blockquote><ul><li>通过 length 属性，可以获取整个字符串的长度</li></ul></blockquote></li></ol><pre class=" language-js"><code class="language-js"><span class="token operator">></span><span class="token operator">&lt;</span>script<span class="token operator">></span><span class="token operator">></span>  <span class="token keyword">var</span> str <span class="token operator">=</span> <span class="token string">"我就是我，不一样的花朵"</span><span class="token punctuation">;</span><span class="token operator">></span>  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>str<span class="token punctuation">.</span>length<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 11</span><span class="token operator">></span><span class="token operator">&lt;</span><span class="token operator">/</span>script<span class="token operator">></span></code></pre><h4 id="Boolean类型"><a href="#Boolean类型" class="headerlink" title="Boolean类型"></a>Boolean类型</h4><blockquote><ul><li>布尔值主要是用来做<strong>逻辑判断</strong></li><li>布尔类型只有两个值：true(真)和false（假），没有引号</li><li>如果给true和false加上<code>&quot;&quot;</code>双引号或<code>&#39;&#39;</code>单引号，那就变成了字符串了</li></ul></blockquote><h4 id="null-空类型"><a href="#null-空类型" class="headerlink" title="null 空类型"></a>null 空类型</h4><blockquote><ul><li>null 类型只有一个值，就是<code>null</code></li><li>null 表示一个<strong>空对象指针</strong></li><li>用typeof检测 null 的类型，得到的是<code>Object</code></li></ul></blockquote><blockquote><blockquote><p>虽然 typeof null 得到值为 Object,但是 null 是基本数据类型，这是一个历史遗留问题，如果要深究，那就只能用下面这段话来解释 (以下内容来自：你不知道的 JavaScript 上卷-103 页)</p></blockquote><ul><li>不同的对象在底层都表示为二进制，在 JavaScript 中二进制前三位都为 0 的话会被判断为 object 类型</li><li>null 的二进制表示是全 0，自然前三位也是 0，所以执行 typeof 时会返回 "object"<blockquote><p>面试中会问到这个点，问这个问题的本质不是考这个点，因为没有意义，而是想通过这个点，看你平时学习是否研究底层，会阅读相关 JS 书籍。</p></blockquote></li></ul></blockquote><p><strong>null 的作用</strong></p><blockquote><ul><li>如果一个变量被声明后，<strong>将来</strong>是用来保存<strong>对象值</strong>的，那建议用 null 来初始化，不要使用其他值。</li><li>当我们需要将对象、数组、事件监听进行销毁时，我们就可以把他们设置为 null，只有把他们设置为 null 时，JS 垃圾回收器才会把他们当成垃圾，进行<strong>垃圾回收</strong></li></ul></blockquote><h4 id="undefined"><a href="#undefined" class="headerlink" title="undefined"></a>undefined</h4><blockquote><ul><li>undefined 类型，只有一个值，就是undefined</li><li>当声明一个变量，但是<strong>并不给变量赋值</strong>时，它的值就是<code>undefined</code></li></ul></blockquote><pre class=" language-js"><code class="language-js"><span class="token operator">></span><span class="token operator">&lt;</span>script<span class="token operator">></span><span class="token operator">></span>  <span class="token keyword">var</span> a<span class="token punctuation">;</span><span class="token operator">></span>  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// a的值是undefined</span><span class="token operator">></span>  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">typeof</span> a<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 变量a的类型是 undefined</span><span class="token operator">></span><span class="token operator">&lt;</span><span class="token operator">/</span>script<span class="token operator">></span></code></pre><blockquote><blockquote><p>我们经常在调试中或报错中会发现有些值打印是 undefined，就说明这个变量定义了，没有赋值，或赋值不成功。</p></blockquote></blockquote><h3 id="三、数据类型转换"><a href="#三、数据类型转换" class="headerlink" title="三、数据类型转换"></a>三、数据类型转换</h3><blockquote><ul><li>JavaScript 是一种<strong>动态类型语言</strong>(dynamically typed language)。</li><li>这意味着你在声明变量时可以不必指定数据类型，而数据类型会在代码执行时会根据需要<strong>自动转换</strong>。</li><li>JS 中通常会有三种方式的数据类型转换<ul><li>其它类型 --> 数值</li><li>其它类型 --> 字符串</li><li>其它类型 --> 布尔值</li></ul></li></ul></blockquote><h4 id="其它类型转换为数字型"><a href="#其它类型转换为数字型" class="headerlink" title="其它类型转换为数字型"></a>其它类型转换为数字型</h4><blockquote><p>将其它数据类型转换为数字型，有以下 4 种方法</p><table><thead><tr><th>函数</th><th>说明</th><th>实例</th></tr></thead><tbody><tr><td>Number()函数 强制转换</td><td>将<strong>非数字类型</strong>转换成数字</td><td>Number(''); // 0 或 Number(' '); // 0</td></tr><tr><td>paresInt() 函数</td><td>将<strong>字符串</strong>转换为数字</td><td>parseInt('ab123'); // NaN 或 parseInt('200px'); // 200</td></tr><tr><td>parseFloat() 函数</td><td>将<strong>字符串</strong>转换为浮点数</td><td>parseFloat('3.14 元'); // 3.14 或 parseFloat('圆周率 3.14'); // NaN</td></tr><tr><td>（+ - * /） JS 隐式转换</td><td>利用算术运算隐式转换为数字型</td><td>-</td></tr></tbody></table></blockquote><ol><li>Number 函数<blockquote><p>Number()函数：用来将非数字类型转换成数字。</p><ul><li>''空字符串会转换成数字0</li><li>只有前后包含：空格、纯数字类字符串、2 进制或 16 进制表示的数字、科学记数表示法的<strong>字符串</strong>能转换成数字</li><li>其它会转换成 <code>NaN</code></li><li>以上规则，只针对基本数据类型而言</li><li>Number([]) 结果是 0</li><li>Number({})结果是 NaN</li></ul></blockquote></li></ol><pre><code>&gt;&lt;script&gt;&gt;Number(&quot;-12&quot;); // -12&gt;Number(&quot;2e3&quot;); // 2000&gt;Number(&quot;0b11&quot;); // 3&gt;Number(&quot;2021年&quot;); // NaN&gt;Number(&quot;&quot;); // 0&gt;Number(&quot; &quot;); // 0&gt;Number(true); // 1&gt;Number(false); // 0&gt;Number(null); // 0&gt;Number(undefined); // NaN&gt;&lt;/script&gt;</code></pre><ol start="2"><li>parseInt(函数)<blockquote><ul><li>parseInt()函数，主要是将<strong>字符串类型</strong>转换为<strong>整数</strong>数字</li><li><strong>转换规则</strong><ul><li>从第一个非空字符开始转换，如果<strong>第一个字符</strong>不是数值、加号或减号，parseInt 立即返回 <code>NaN</code></li><li>这就意味着<strong>空字符串</strong>也会返回 <code>NaN</code>。</li><li>如果第一个非空字符是<strong>数值、加号、减号</strong>，则继续检测，直到字符串末尾，或碰到<strong>非数值字符</strong>，就停止。</li></ul></li><li>parseInt() 函数，<strong>不能</strong>识别二进制，八进制，<strong>但是</strong>他可以识别十六进制</li><li>parseInt() 函数，还有第二个参数，可以指定以什么进制数来进行转换parseInt() 函数,指定之后就可以进行转换,但仍然识别不了二、八进制</li></ul></blockquote></li></ol><pre class=" language-js"><code class="language-js"><span class="token operator">></span><span class="token operator">&lt;</span>script<span class="token operator">></span><span class="token operator">></span><span class="token function">parseInt</span><span class="token punctuation">(</span><span class="token string">"0b10"</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 0</span><span class="token operator">></span><span class="token function">parseInt</span><span class="token punctuation">(</span><span class="token string">"0110"</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 110</span><span class="token operator">></span><span class="token function">parseInt</span><span class="token punctuation">(</span><span class="token string">"0x14"</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 20</span><span class="token operator">></span><span class="token function">parseInt</span><span class="token punctuation">(</span><span class="token string">"0x14年"</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 20</span><span class="token operator">></span><span class="token function">parseInt</span><span class="token punctuation">(</span><span class="token string">"2.3"</span> <span class="token operator">+</span> <span class="token string">"3.5"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//2</span><span class="token operator">></span><span class="token function">parseInt</span><span class="token punctuation">(</span><span class="token string">"10"</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 2</span><span class="token operator">></span><span class="token function">parseInt</span><span class="token punctuation">(</span><span class="token string">"10"</span><span class="token punctuation">,</span> <span class="token number">8</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 8</span><span class="token operator">></span><span class="token function">parseInt</span><span class="token punctuation">(</span><span class="token string">"10"</span><span class="token punctuation">,</span> <span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 10</span><span class="token operator">></span><span class="token function">parseInt</span><span class="token punctuation">(</span><span class="token string">"0b1001"</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">//0</span><span class="token operator">></span><span class="token operator">&lt;</span><span class="token operator">/</span>script<span class="token operator">></span></code></pre><ol start="3"><li>parseFloat(函数)<blockquote><ul><li>他的转换原则 和 parseInt()函数一样，唯一两点区别在于：<ul><li>parseFloat() 函数，主要是将<strong>字符串类型</strong>转换为<strong>浮点数</strong></li><li>parseFloat( )函数，他<strong>不能</strong>识别进制数</li></ul></li></ul></blockquote></li></ol><pre class=" language-js"><code class="language-js"><span class="token operator">></span><span class="token operator">&lt;</span>script<span class="token operator">></span><span class="token operator">></span>  <span class="token function">parseFloat</span><span class="token punctuation">(</span><span class="token string">""</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// NaN</span><span class="token operator">></span>  <span class="token function">parseFloat</span><span class="token punctuation">(</span><span class="token string">"3.14"</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 3.14</span><span class="token operator">></span>  <span class="token function">parseFloat</span><span class="token punctuation">(</span><span class="token string">"3.2.32"</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 3.2</span><span class="token operator">></span>  <span class="token function">parseFloat</span><span class="token punctuation">(</span><span class="token string">"3.14元"</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 3.14</span><span class="token operator">></span>  <span class="token function">parseFloat</span><span class="token punctuation">(</span><span class="token string">"圆周率3.14"</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// NaN</span><span class="token operator">></span>  <span class="token function">parseFloat</span><span class="token punctuation">(</span><span class="token string">"0b10"</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 0</span><span class="token operator">></span>  <span class="token function">parseFloat</span><span class="token punctuation">(</span><span class="token string">"0110"</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 110</span><span class="token operator">></span>  <span class="token function">parseFloat</span><span class="token punctuation">(</span><span class="token string">"0x14"</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 0</span><span class="token operator">></span><span class="token operator">&lt;</span><span class="token operator">/</span>script<span class="token operator">></span></code></pre><ol start="4"><li>JS 隐式转换 (+ - * /)<blockquote><ul><li>利用算术运算隐式将其它类型转换为数字</li><li>在单个字符串前面加上 +号，可以将字符串转成数字,多个字符串，是字符串拼接<br><code>typeof +&quot;1&quot;; // number</code></li></ul></blockquote></li></ol><h4 id="其它类型转换为字符串"><a href="#其它类型转换为字符串" class="headerlink" title="其它类型转换为字符串"></a>其它类型转换为字符串</h4><table><thead><tr><th>方法或函数</th><th>说明</th><th>实例</th></tr></thead><tbody><tr><td>String()函数 强制转换</td><td>其它类型转换字符串</td><td>String(0b10); // '2' 或 String(NaN); // 'NaN'</td></tr><tr><td>toString() 方法</td><td>数字和boolean类型转换为字符串0b10.toString(); // '2' 或 NaN.toString(); // 'NaN'</td><td></td></tr><tr><td>+ '' 空字符串拼接</td><td>所有类型与''空字符串拼接得到的都是字符串类型。</td><td>typeof (1 + ""); // 'string'</td></tr></tbody></table><blockquote><blockquote><p>以上方法或函数，将任何类型转换为字符串，都会转换成长得相同的字符串，除了科学记数法和非10进制数字会将其转换为 10 进制值的字符串</p></blockquote></blockquote><ol><li>String()函数<br><strong>数字转换字符串</strong></li></ol><pre><code>&gt;&lt;script&gt;&gt;  String(123); // &#39;123&#39;&gt;  String(2.14); // &#39;2.14&#39;&gt;  String(2e4); // &#39;20000&#39;&gt;  String(0b10); // &#39;2&#39;&gt;  String(NaN); // &#39;NaN&#39;&gt;  String(Infinity); //&#39; Infinity&#39;&gt;&lt;/script&gt;&gt;```**布尔值转换为字符串**</code></pre><blockquote><script> String(true); // 'true' String(false); // 'false'</script></blockquote><pre><code>**undefined 和 null 转换为字符串**</code></pre><blockquote><script> String(undefined); // 'undefined' String(null); // 'null'</script></blockquote><pre><code>2. toString() 方法**数字转换为字符串**</code></pre><blockquote><script> (123).toString(); // '123' (2e4).toString(); // '20000' (0b10).toString(); //'2'; NaN.toString(); // 'NaN' Infinity.toString(); // 'Infinity'</script></blockquote><pre><code>**boolean 类型转换为字符串**</code></pre><blockquote><script> true.toString(); // 'true' false.toString(); // 'false'</script></blockquote><pre><code>&gt;&gt;null和undefined没有 toString()这个方法3. `+ &#39;&#39;` 空字符串&gt;所有类型与`&#39;&#39;`空字符串拼接得到的都是字符串类型。</code></pre><blockquote><script> true + ""; // 'true' false + ""; // 'false' NaN + ""; // 'NaN' 0 + ""; // '0' 0b10 + ""; // '2'</script></blockquote><pre><code>#### 其他类型转boolean 布尔类型&gt;其它数据类型转换成 Boolean 方法：&gt;- 方法一：调用Boolean()函数来实现&gt;- 方法二：在一个数值或变量前加!!(两次取反)操作，也可以实现&gt;**转换原则：**&gt;- 代表空、否定的值会被转换为false。 如：&#39;&#39;、0、NaN、null、undefined&gt;- 除了上面列出的 5 个值，其它值字都转换为 true**字符串转换为布尔类型**</code></pre><blockquote><script> Boolean(""); // false Boolean(" "); // true Boolean("NaN"); // true Boolean("false"); // true</script></blockquote><pre><code>**数字类型转换为布尔类型值**</code></pre><blockquote><script> Boolean(NaN); // false Boolean(0); // false Boolean(Infinity); // true</script></blockquote><pre><code>**null 和 undefined 转换为布尔类型值**</code></pre><blockquote><script> Boolean(null); // false Boolean(undefined); // false</script></blockquote><pre><code>#### 常见的类型转换|原始值|转换为 数字|转换为 字符串|转换为 布尔值||---|---|----|---||false|0|&quot;false&quot;|false||true|1|&quot;true&quot;|true||0|0|&quot;0&quot;|false||&quot;0&quot;|0|&quot;0&quot;|true||&#39;&#39;|0|&#39;&#39;|false||&#39; &#39;|0|&#39; &#39;|true||&quot;30&quot;|30|&quot;30&quot;|true||null|0|&quot;null&quot;|false||undefined|NaN|&quot;undefined&quot;|false||NaN|NaN|&quot;NaN&quot;|false||Infinity|Infinity|&quot;Infinity&quot;|true|### 四、综合案例**简单计算器**&gt;**需求分析**：&gt;- 当用户在浏览器打开页面时，弹出一输入框，要求用户输入数字，用户确认后，再弹出一输入框，再输入一个数字，确认后，最后弹出两次输入的数字之和。&gt;**代码实现思路：**&gt;- 使用 prompt() 函数弹出输入框，让用户输入两个数字&gt;- 对用户输入两个数字进行**加法运算**，而由于用户输入的内容是字符串类型，所以必须**先转为数字类型**，才能做加法运算&gt;- 最后用 alert() 显示结果，使用字符串拼接进行语句输出&gt;- 程序虽小，却体现了普遍计算机程序的执行步骤：用户输入-&gt;计算机处理 -&gt; 显示结果&gt;&gt;注意：&gt;&gt;- 通过输入框得到的值都是字符串类型&gt;&gt;- 进行加法运算的值必须为**数字类型**&gt;&gt;- 减法不用进行类型转换（因为JS支持隐式类型转换）### 五、扩展知识1. Javascript 为何称为弱类型的动态脚本语言&gt;- 在前面我们一直说，Javascript 是一种运行在客户端的脚本语言（Script 是脚本的意思）。&gt;- 本质上 Javascript 是一种弱类型的动态脚本语言。接下来我们分别来解释下，何为**弱类型**，何为**动态**，何为**脚本语言**。&gt;&lt;img src=&quot;语言类型.png&quot;&gt;2. 何为**动态**语言和**静态**语言&gt;- 在声明变量时，**不需要**确定变量类型的语言，称为动态语言。比如：Javascript，Python、Ruby、PHP等&gt;- 在声明变量时，需要确定变量类型的语言，称为静态语言。比如 Java、C、C++ 、C# 等&gt;- JS 在声明变量声明时，并不需要确定变量的类型，其类型是在代码执行的过程中,由变量对应值的类型来动态决定的。所以 JS 在执行过程中，需要检查数据的类型。3. 何为**弱**类型语言和**强**类型语言&gt;- 支持**隐式类型**转换的语言，称为 弱类型语言&gt;   - 弱类型语言：C、C++、Javascript、PHP、VB、Perl&gt;- 不支持隐式类型转换的语言，称为 强类型语言&gt;   - 强类型语言：C# 、Java 、Ruby、Python</code></pre><blockquote><p>var a = "4";<br>var b = 1;<br>console.log(a - b); //3</p></blockquote><pre><code>&gt;- 变量a是字符串，b是数字，a-b=&#39;4&#39;-1，在这个过程中会**自动**把字符串&#39;4&#39;转换成数字4，然后再做运算。&gt;- 这种在运算过程中会悄悄把数据类型转换的操作，叫**隐式类型转换**。4. 何为脚本语言&gt;- 所谓的脚本语言：是指不需要**提前编译**，而是在运行的过程中边编译，边执行。&gt;- 而 JS 本质上就是在运行过程中边编译，边执行的，JS 是由 **JS 解释器（JS 引擎）**来逐行进行解释并执行&gt;- 所以 JS 也称为**解释型**语言。5. 编译型语言 和 解释性语言&gt;**编译器和解释器**&gt;- 之所以存在编译器和解释器，是因为机器不能直接理解我们所写的代码，所以在执行程序之前，需要将我们所写的代码“翻译”成机器能读懂的机器语言。&gt;- 按语言的执行流程，可以把语言划分为编译型语言和解释型语言。&gt;**编译型语言**&gt;- 在程序**执行之前**，需要经过编译器的编译过程，并且编译之后会直接保留机器能读懂的二进制文件，这样每次运行程序时，都可以直接运行该二进制文件，而不需要再次重新编译了。比如 C/C++、GO 等都是编译型语言。&gt;**解释型语言**&gt;- 而由解释型语言编写的程序，在每次**运行时**都需要通过解释器对程序进行动态解释和执行。比如 Python、JavaScript 等都属于解释型语言。&gt;&gt;- 大部分后端语言，都是编译型语言，也就是要先编译，再执行。而 JS 是解释型语言，一边编译一边执行。&gt;&gt;- 编译型是一开始慢，后面快，而解释是刚开始快，但过程中是慢的。6. 什么是 JavaScript 解释器 ？&gt;要理解什么是解释器，就需要我们了解浏览器的两大组成部分：渲染引擎 和 JavaScript 引擎&gt;- 渲染引擎：用来解析 **HTML 与 CSS**，俗称内核，比如 chrome 浏览器的 blink，老板本的 webkit&gt;- JS 引擎：也称为 **JS 解释器**，用来读取网页中的 **JavaScript 代码**，对其处理后运行。比如 chrome 浏览器的 V8 引擎。&gt;&gt;- 浏览器本身并不会执行 JS 代码，而是通过内置 JavaScript 引擎（解释器）来编译和执行 Js 代码。&gt;&gt;- JS 引擎执行代码时逐行解释每一句源码（转换为机器语言），然后由计算机去执行。</code></pre>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>多终端响应式开发</title>
      <link href="/2023/11/30/%E5%A4%9A%E7%BB%88%E7%AB%AF%E5%93%8D%E5%BA%94%E5%BC%8F%E5%BC%80%E5%8F%91/"/>
      <url>/2023/11/30/%E5%A4%9A%E7%BB%88%E7%AB%AF%E5%93%8D%E5%BA%94%E5%BC%8F%E5%BC%80%E5%8F%91/</url>
      
        <content type="html"><![CDATA[<span id="more"></span><h3 id="一、什么是响应式布局"><a href="#一、什么是响应式布局" class="headerlink" title="一、什么是响应式布局"></a>一、什么是响应式布局</h3><blockquote><ul><li>响应式布局：只需要开发一套代码，就能使页面适应不同的屏幕 （一个网站兼容多种终端）</li><li>响应式设计原理：通过媒体查询来检测视口宽，针对不同视口宽做相应代码处理，来展现不同的布局和内容</li><li>流体布局和 rem&#x2F;vw 布局，只是针对移动端开发的，开发出来的网站在尺寸为（320 ~ 480px）之间的屏幕上显示，才能获得好的体验。并不能适应iPad和PC 端。</li><li>响应式布局开发出来的网站，在移动、ipad、PC 端都能有好的体验，能兼容不同的屏幕尺寸</li></ul></blockquote><h3 id="二、媒体查询的语法"><a href="#二、媒体查询的语法" class="headerlink" title="二、媒体查询的语法"></a>二、媒体查询的语法</h3><h4 id="什么是媒体查询"><a href="#什么是媒体查询" class="headerlink" title="什么是媒体查询"></a>什么是媒体查询</h4><blockquote><ul><li>我们知道，一套 CSS 样式是很难适应不同大小的屏幕，所以我们需要针对不同的屏幕尺寸来书写不同的样式，这样我们写出来的页面就能在不同大小的屏幕上都正常显示。</li><li>媒体查询就是用来解决这个问题的，他能帮助我们检测不同屏幕的尺寸，然后针对不同屏幕尺寸，显示不同的样式。</li><li>一个完整的媒体查询语句，包含以下四个部分：<ul><li>@media 关键字</li><li>媒体类型</li><li>逻辑运算符</li><li>媒体特性</li></ul></li></ul></blockquote><pre><code>&lt;style&gt;  /*  @media 媒体类型 逻辑操作符 (媒体特性) &#123;  ...css样式....;&#125;    @media 是关键字：媒体查询    screen 媒体类型：屏幕设备    and 逻辑运算符：与 (多个条件同时满足)    min-width 媒体特性：设备宽&gt;=400px以下整个媒体查询代码的含义：网页是在屏幕设备上显示，同时屏幕设备的宽&gt;=400px时，背景颜色变为红色。    */  @media screen and (min-width: 400px) &#123;    body &#123;      background-color: red;    &#125;  &#125;&lt;/style&gt;</code></pre><h4 id="媒体类型"><a href="#媒体类型" class="headerlink" title="媒体类型"></a>媒体类型</h4><blockquote><ul><li>媒体类型(Media types) 就是用来描述设备的一般类别，设备类别主要分为以下 4 种</li></ul></blockquote><table><thead><tr><th>媒体类型</th><th>说明</th></tr></thead><tbody><tr><td>all</td><td><strong>（默认值）</strong>适用于所有的设备</td></tr><tr><td>screen</td><td>适用于屏幕设备</td></tr><tr><td>print</td><td>适用于在打印预览模式下在屏幕上查看的分页材料和文档</td></tr><tr><td>speech</td><td>适用于语音合成器</td></tr></tbody></table><blockquote><p>如果媒体查询语句，只指定媒体类型，可以简写成如下:</p></blockquote><ul><li><code>@media 媒体类型 ｛ .... css样式..... ｝;</code></li></ul><blockquote><p>要看到<strong>打印模式</strong>下效果，按以下步骤操作即可</p></blockquote><ul><li>涉及到颜色一定要记得选彩色</li><li>在浏览器中右击 -&gt; 打印（点击进入） -&gt; 更多设置（点击）- <strong>背景图形</strong>（勾选上）<img src="打印模式.png"></li></ul><h4 id="媒体特性"><a href="#媒体特性" class="headerlink" title="媒体特性"></a>媒体特性</h4><blockquote><ul><li>媒体特性（Media features）描述了 user agent、输出设备，或是浏览环境的具体特征。</li><li>媒体特性表达式是完全可选的</li><li>它负责测试这些特性或特征是否存在、值为多少。</li><li><strong>每条</strong>媒体特性表达式都必须用 括号<code>()</code> 括起来。</li></ul></blockquote><blockquote><p><strong>常用的媒体特性</strong></p></blockquote><table><thead><tr><th>媒体特性</th><th>说明</th></tr></thead><tbody><tr><td>width</td><td>设备屏幕的宽</td></tr><tr><td>min-width</td><td>设备屏幕的最小宽(如min-width:400px;表示屏幕宽&gt;&#x3D;400px)</td></tr><tr><td>max-width</td><td>设备屏幕的最大宽(如max-width:1200px;表示屏幕宽&lt;&#x3D;1200px)</td></tr><tr><td>-webkit-device-pixel-ratio</td><td>设备像素比(dpr)的值（只有-webkit 内核的才支持）</td></tr><tr><td>-webkit-max-device-pixel-ratio</td><td>设备像素比(dpr)的最大值（只有-webkit 内核的才支持）</td></tr><tr><td>-webkit-min-device-pixel-ratio设备像素比(dpr)的最小值（只有-webkit 内核的才支持）</td><td></td></tr><tr><td>orientation</td><td>当前屏幕的方向，是横屏还竖屏</td></tr><tr><td>portrait: 表示竖屏(orientation : portrait;)</td><td></td></tr><tr><td>landscape:表示横屏 (orientation:landscape;)</td><td></td></tr></tbody></table><blockquote><p><strong>写法</strong></p><ul><li>如果只指定媒体特性，写法如下：</li></ul></blockquote><pre><code>@media （媒体特性） &#123;  ...css样式...;&#125;</code></pre><ul><li>如果同时指定媒体类型和媒体特性，中间需要有<strong>逻辑运算符</strong>，写法如下：</li></ul><pre><code>@media 媒体类型 逻辑运算符 （ 媒体特性） &#123;  .... css样式....;&#125;</code></pre><blockquote><ul><li>多个媒体特性中间也要有<strong>逻辑操运算符</strong></li></ul></blockquote><pre><code>@media 媒体类型 逻辑操运算符 （ 媒体特性） 逻辑操作符 （媒体特性） &#123;  .... css样式....;&#125;</code></pre><h4 id="逻辑运算符"><a href="#逻辑运算符" class="headerlink" title="逻辑运算符"></a>逻辑运算符</h4><blockquote><ul><li>逻辑运算符（logical operators） not,and和only可用于联合构造复杂的媒体查询</li><li>您还可以通过用<code>,</code>（逗号）分隔多个媒体查询，将它们组合为一个规则。</li></ul></blockquote><blockquote><p><strong>and 运算符</strong></p></blockquote><ul><li><code>and</code>操作符用于将多个媒体查询规则组合成单条媒体查询</li><li>当每个查询规则都为真时，则该条媒体查询为真</li><li>媒体类型为<code>all</code>时，不需要写<code>and</code></li></ul><blockquote><p><strong>逗号逻辑运算符</strong></p></blockquote><ul><li>逗号用于将多个媒体查询合并为一个规则</li><li>每个逗号前为一个<strong>独立</strong>的查询规则，逗号后为一个<strong>独立</strong>的查询规则</li><li>逗号分隔的每一个独立的查询规则中，只要有一个为true，则整个 media 语句返回true。</li><li>换句话说,逗号类似于js中的 逻辑或、or运算符</li></ul><blockquote><p><strong>not运算符</strong></p><ul><li><code>not</code>运算符会反转整个媒体查询的含义</li><li>如果不满足这个条件则返回true，否则返回false</li><li>如果使用<code>not</code>运算符，则还必须指定媒体类型,并且写在媒体类型之前</li><li><code>not</code>只能用来否定整个媒体查询</li><li>如果出现在以逗号分隔的查询列表中，它将仅否定应用了该查询的特定查询，因此，它不会应用于以逗号分隔的媒体查询列表中的每个媒体查询</li></ul></blockquote><pre><code>@media not screen and (min-width: 1000px), screen and (orientation: landscape) &#123;  body &#123;    background-color: red;  &#125;&#125;</code></pre><ul><li><code>not</code>只否定了<code>not screen and (min-width: 1000px)</code>，并不会否定逗号后面的</li><li>注意：<code>not</code>写在媒体类型之前，但是媒体类型和媒体特性中间必须写逻辑运算符</li></ul><blockquote><p><strong>only 运算符</strong></p><ul><li>only 关键字，主要是为了兼容一些老版本的浏览器时，防止出错而加上的。</li><li>因旧版本的浏览器会将 <code>screen and (max-width: 500px)</code>简单地解释为<code>screen</code>，忽略查询的其余部分，并将其样式应用于所有屏幕</li><li>加上 only 后，就会正常的解释</li></ul></blockquote><h3 id="三、响应式断点和书写位置"><a href="#三、响应式断点和书写位置" class="headerlink" title="三、响应式断点和书写位置"></a>三、响应式断点和书写位置</h3><blockquote><ul><li>当我们需要为不同的屏幕尺寸来设置不同的样式时，我们就需要知道在什么屏幕尺寸下需要做出响应。</li><li>那这些不同的屏幕尺寸，就称为响应式断点(阈值)</li></ul></blockquote><h4 id="响应式断点-阈值-的设定"><a href="#响应式断点-阈值-的设定" class="headerlink" title="响应式断点(阈值)的设定"></a>响应式断点(阈值)的设定</h4><blockquote><ul><li>在实际的开发中，响应式断点是由公司根据项目来定的。</li><li>不过行业也会有一个标准的参考断点（Breakpoint），这里我们以 Bootstrap 框架内部的断点来给大家做讲解</li></ul></blockquote><table><thead><tr><th>屏幕大小</th><th>栅格布局中class名区分</th><th>断点（阈值）</th></tr></thead><tbody><tr><td>超小屏Extra small</td><td>-xs</td><td>&lt;576px</td></tr><tr><td>小屏 (Small)</td><td>-sm</td><td>576px ~ 768px （含等于）</td></tr><tr><td>中屏 (Medium)</td><td>-md</td><td>768px ~ 992px （含等于）</td></tr><tr><td>大屏 (Large)</td><td>-lg</td><td>992px ~ 1200px（含等于）</td></tr><tr><td>超大屏 (X-Large)</td><td>-xl</td><td>1200px ~ 1400px（含等于）</td></tr><tr><td>超大大屏(XX-Large)</td><td>-xxl</td><td>&gt;1400px</td></tr></tbody></table><ul><li>断点并不是完全固定，按上面的要求值来的。而是根据我们所写的项目，在对屏幕做调整时，如果觉得当前效果不符合我们的需求，需要通过设置新的断点来调整，就可以在此添加相应的断点。</li><li>以上断点是 Bootstrap 框架内部的断点，我们可以用来作为我们开发的标准来参考。</li></ul><pre class=" language-css"><code class="language-css">&lt;style>  <span class="token comment" spellcheck="true">/* 当屏幕宽小于576px时，以下代码生效 */</span>  body &amp;<span class="token hexcode">#123</span><span class="token punctuation">;</span>    <span class="token property">background-color</span><span class="token punctuation">:</span> red<span class="token punctuation">;</span>  &amp;<span class="token hexcode">#125</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">/* 当屏幕宽大于等于576px，小于768px时，以下代码生效 */</span>  <span class="token atrule"><span class="token rule">@media</span> screen and <span class="token punctuation">(</span><span class="token property">min-width</span><span class="token punctuation">:</span> 576px<span class="token punctuation">)</span> &amp;#123<span class="token punctuation">;</span></span>    body &amp;<span class="token hexcode">#123</span><span class="token punctuation">;</span>      <span class="token property">background-color</span><span class="token punctuation">:</span> khaki<span class="token punctuation">;</span>    &amp;<span class="token hexcode">#125</span><span class="token punctuation">;</span>  &amp;<span class="token hexcode">#125</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">/* 当屏幕宽大于等于768px，小于992px时，以下代码生效 */</span>  <span class="token atrule"><span class="token rule">@media</span> screen and <span class="token punctuation">(</span><span class="token property">min-width</span><span class="token punctuation">:</span> 768px<span class="token punctuation">)</span> &amp;#123<span class="token punctuation">;</span></span>    body &amp;<span class="token hexcode">#123</span><span class="token punctuation">;</span>      <span class="token property">background-color</span><span class="token punctuation">:</span> skyblue<span class="token punctuation">;</span>    &amp;<span class="token hexcode">#125</span><span class="token punctuation">;</span>  &amp;<span class="token hexcode">#125</span><span class="token punctuation">;</span>&lt;/style></code></pre><ul><li>因为 css 选择器的权重相同时，写在后面的会覆盖写在前面的。所以不用书写具体的屏幕范围，不过要注意代码书写的位置</li></ul><h4 id="媒体查询的代码书写位置"><a href="#媒体查询的代码书写位置" class="headerlink" title="媒体查询的代码书写位置"></a>媒体查询的代码书写位置</h4><blockquote><p><strong>媒体查询的代码可以写在 style 标签中</strong></p></blockquote><blockquote><p><strong>可以写在单独的 CSS 文件中,通过 link 标签引入</strong></p><ul><li>不过都要写在所有 CSS 样式的代码之后。</li><li>这样就能保证断点生效时，写在媒体查询中的代码能生效，不会被正常的样式所覆盖。</li></ul></blockquote><blockquote><p><strong>不同断点代码写入不同 css 文件中（不推荐）</strong></p><ul><li>通过 link 来引用，在 media 中来设置对应断点</li><li>在满足媒体查询条件时，对应的css文件生效</li></ul></blockquote><pre class=" language-css"><code class="language-css">&lt;link rel=<span class="token string">"stylesheet"</span> href=<span class="token string">"a.css"</span> media=<span class="token string">"screen and (min-width:600px)"</span> />&lt;link rel=<span class="token string">"stylesheet"</span> href=<span class="token string">"b.css"</span> media=<span class="token string">"screen and (min-width:1000px)"</span> /><span class="token comment" spellcheck="true">/* a.css文件内容 */</span>body &amp;<span class="token hexcode">#123</span><span class="token punctuation">;</span>  <span class="token property">background-color</span><span class="token punctuation">:</span> skyblue<span class="token punctuation">;</span>&amp;<span class="token hexcode">#125</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">/* b.css文件内内容 */</span>body &amp;<span class="token hexcode">#123</span><span class="token punctuation">;</span>  <span class="token property">background-color</span><span class="token punctuation">:</span> red<span class="token punctuation">;</span>&amp;<span class="token hexcode">#125</span><span class="token punctuation">;</span></code></pre><h3 id="四、响应式两种适配方案"><a href="#四、响应式两种适配方案" class="headerlink" title="四、响应式两种适配方案"></a>四、响应式两种适配方案</h3><blockquote><p>在实际的响应式开发中，我们会有两种通用的适配方案</p></blockquote><ul><li>PC 端优先（先考虑 PC 端，最后再考虑移动端）</li><li>移动端优先（先考虑移动端，最后再考虑 PC 端）</li></ul><h4 id="PC端优先"><a href="#PC端优先" class="headerlink" title="PC端优先"></a>PC端优先</h4><ul><li>从大尺寸开始写，先大后小</li><li>用<code>max-width</code></li></ul><h4 id="移动端优先"><a href="#移动端优先" class="headerlink" title="移动端优先"></a>移动端优先</h4><ul><li>从小尺寸开始，先小后大</li><li>用<code>min-width</code></li></ul><h3 id="五、响应式栅格系统"><a href="#五、响应式栅格系统" class="headerlink" title="五、响应式栅格系统"></a>五、响应式栅格系统</h3><blockquote><p><strong>在实际开发中</strong></p></blockquote><ul><li>要完美的实现响应式系统或网站的开发，就需要利用响应式栅格系统来帮助我们实现。</li><li>BootStrap 框架实现响应式布局的本质就是他的响应式栅格系统。</li><li>响应式栅格系统是：栅格布局+响应断点+响应式适配方案 3 者结合实现的一套响应式解决方案</li></ul><h4 id="栅格布局"><a href="#栅格布局" class="headerlink" title="栅格布局"></a>栅格布局</h4><blockquote><ul><li>所谓的栅格布局，你可以简单理解为，要把一个页面或容器（如 div），分成多少份</li><li>然后设置其页面或容器中子元素占对应的份数</li><li>通常一个页面或容器会被分成：12 份，16 份，24 份</li><li>如果将网页（100%）分成 12 份，那对应不同份数所占的比例如下:</li></ul></blockquote><table><thead><tr><th>份数</th><th>占总份数的百分比%</th></tr></thead><tbody><tr><td>1</td><td>8.33333333%</td></tr><tr><td>2</td><td>16.6666667%</td></tr><tr><td>3</td><td>25%</td></tr><tr><td>4</td><td>33.33333333%</td></tr><tr><td>5</td><td>41.66666667%</td></tr><tr><td>6</td><td>50%</td></tr><tr><td>7</td><td>58.33333333%</td></tr><tr><td>8</td><td>66.6666667%</td></tr><tr><td>9</td><td>75%</td></tr><tr><td>10</td><td>83.33333333%</td></tr><tr><td>11</td><td>91.66666667%</td></tr><tr><td>12</td><td>100%</td></tr></tbody></table><h4 id="栅格系统实现响应式布局"><a href="#栅格系统实现响应式布局" class="headerlink" title="栅格系统实现响应式布局"></a>栅格系统实现响应式布局</h4><blockquote><p>我们说响应式栅格系统是：栅格布局+响应断点+响应式适配方案3者结合实现的一套响应式解决方案<br>&#x3D; 接下来我们来学习，如何利用前面学到的栅格布局，响应断点，响应式适配方案实现响应式布局。</p><ul><li>我们可以按以下 5 个步骤来操作</li></ul></blockquote><ul><li>你打算将页面分成多少份 ？</li><li>确定响应断点有哪些 ？</li><li>确定响应式适配方案。PC端优先还是移动端优先？</li><li>在对应的响应断点下，书写对应的栅格布局样式。</li><li>对着设计稿开发，搭建整个响应式的框架。如果是以移动端优先，则对着移动端设计稿来开发，如果是 PC 端优先，则对着 PC 端设计稿来开发。<blockquote><p>但是在开发前，一定要分清版块的归属问题，也就那些版块是在一个父容器中。</p></blockquote></li></ul><h3 id="五、响应式后台管理系统项目开发"><a href="#五、响应式后台管理系统项目开发" class="headerlink" title="五、响应式后台管理系统项目开发"></a>五、响应式后台管理系统项目开发</h3><blockquote><p><strong>确定栅格系统样式（media.css 样式）</strong></p><ul><li>将页面分成 12 份，确定栅格布局不同份数所点比例</li><li>确定项目对应的断点</li></ul></blockquote><ul><li>当视口宽大于 1400px 时，以正常效果显示</li><li>当视口宽 &lt;&#x3D; 1400px 时，左侧菜单缩放到 75px</li><li>当视口宽 &lt;&#x3D; 1300px 时，左侧菜单隐藏</li><li>当视口宽 &lt;&#x3D; 1200px 时，上面一行 4 列，变成 1 行 2 列</li><li>当视口宽 &lt;&#x3D; 992px 时，第二行的一行 2 列变 1 列，最下面的一行 3 列变成 1 行 2 列和 1 行 1 列</li><li>当视口宽 &lt;&#x3D; 768px 时，全部一行一列显示 ，同时上面的导航变成点击下拉菜单形式</li></ul><blockquote><p>最终确定 <code>media.css</code> 文件的代码如下</p></blockquote><ul><li>确定适配方案，以 PC 端优先，因此从大尺寸开始写，先大后小</li></ul><pre><code>/* 大于1400px时，样式写在这里 */.col-xxlg-1 &#123;  width: 8.33333333%;&#125;/* 此处省略了 .col-xxlg-2 到 .col-xxlg-11 样式，自己补充 */.col-xxlg-12 &#123;  width: 100%;&#125;/* 小于等于1400px的样式写在这里 */@media screen and (max-width: 1400px) &#123;  .col-xlg-1 &#123;    width: 8.33333333%;  &#125;  /* 此处省略了 .col-xlg-2 到 .col-xlg-11 样式，自己补充 */  .col-xlg-12 &#123;    width: 100%;  &#125;&#125;@media screen and (max-width: 1300px) &#123;  /*  ..... .... */&#125;/* 屏幕宽&gt;992px，同时&lt;=1200px时，样式写在这里 */@media screen and (max-width: 1200px) &#123;  .col-lg-1 &#123;    width: 8.33333333%;  &#125;  /* 此处省略了 .col-lg-2 到 .col-lg-11 样式，自己补充 */  .col-lg-12 &#123;    width: 100%;  &#125;&#125;/* 屏幕宽&gt;768px，同时&lt;=992px时，样式写在这里 */@media screen and (max-width: 992px) &#123;  .col-md-1 &#123;    width: 8.33333333%;  &#125;  /* 此处省略了 .col-md-2 到 .col-md-11 样式，自己补充 */  .col-md-12 &#123;    width: 100%;  &#125;&#125;/* 屏幕宽&gt;576px，同时&lt;=768px时，样式写在这里 */@media screen and (max-width: 768px) &#123;  .col-sm-1 &#123;    width: 8.33333333%;  &#125;  /* 此处省略了 .col-sm-2 到 .col-sm-11 样式，自己补充 */  .col-sm-12 &#123;    width: 100%;  &#125;&#125;</code></pre><blockquote><p><strong>注意</strong></p></blockquote><ul><li>要用怪异盒模型</li><li>echarts图表实现响应式缩放,在引用图表的<code>script</code>标签后面加上</li></ul><pre><code>window.addEventListener(&quot;resize&quot;,function()&#123;  mychart1.resize();&#125;);</code></pre>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 响应式开发 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>移动端开发必备知识</title>
      <link href="/2023/11/30/%E7%A7%BB%E5%8A%A8%E7%AB%AF%E5%BC%80%E5%8F%91%E5%BF%85%E5%A4%87%E7%9F%A5%E8%AF%86/"/>
      <url>/2023/11/30/%E7%A7%BB%E5%8A%A8%E7%AB%AF%E5%BC%80%E5%8F%91%E5%BF%85%E5%A4%87%E7%9F%A5%E8%AF%86/</url>
      
        <content type="html"><![CDATA[<h2 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h2><h3 id="一、什么是移动-Web、PC-web-和-web-App-开发？"><a href="#一、什么是移动-Web、PC-web-和-web-App-开发？" class="headerlink" title="一、什么是移动 Web、PC web 和 web App 开发？"></a>一、什么是移动 Web、PC web 和 web App 开发？</h3><blockquote><p><strong>什么是web开发？</strong></p><ul><li>简单理解为网页开发，主要使用HTML+CSS+Javascript编写，然后代码在浏览器中运行<br><strong>什么是移动 web开发和PC web 开发？</strong></li><li>本质上都是用HTML+CSS+Javascript来编写</li><li>只是移动web开发，代码是在手机、平板等浏览器中运行</li><li>而PC web开发，代码是在PC端浏览器中运行<br>什么是App开发</li><li>APP是application的缩写，指应用程序，一般指手机软件<table><thead><tr><th>APP 开发分类</th><th>说明</th></tr></thead><tbody><tr><td>Native APP</td><td>一般依托于操作系统，有很强的交互，是一个完整的 App，可拓展性强，需要用户下载安装使用。比如：基于操作系统的 IOS 开发和安卓开发</td></tr><tr><td>Web APP</td><td>应用程序在浏览器中运行，称为 Web APP</td></tr><tr><td>Hybrid APP(混合式 APP)</td><td>是<code>Native APP</code>和<code>Web APP</code>的混合体， 同时具有两者的特点。</td></tr></tbody></table></li></ul></blockquote><h3 id="二、移动-Web-与-PC-Web-开发区别？"><a href="#二、移动-Web-与-PC-Web-开发区别？" class="headerlink" title="二、移动 Web 与 PC Web 开发区别？"></a>二、移动 Web 与 PC Web 开发区别？</h3><blockquote><ul><li>移动 Web 与 PC Web <strong>最大的区别在于运行的终端设备不同</strong>。不同终端设备有不同特性，正是这些终端设备的不同特性，造成了移动 web 开发和 PC web 开发的不同。</li><li>具体的不同点有以下4个方面：<ul><li>屏幕大小不同</li><li>网络环境和设备性能不同</li><li>交互方式不同</li><li>兼容性不同</li></ul></li></ul></blockquote><ol><li><p>屏幕大小不同</p><blockquote><ul><li>我们都知道移动端的设备，如手机的屏幕大小相对 PC 端要小很多，所以针对 PC 端的那些布局在移动端肯定就不行了。所以我们需要专门针对移动端来做布局。</li><li>如果直接把 PC 端的网站在移动端打开，整个页面就会被压缩，压缩后就会看不清。  </li><li>常见的屏幕尺寸大小：<a href="http://shijuechuanda.com/screen/index.htm">http://shijuechuanda.com/screen/index.htm</a></li></ul></blockquote></li><li><p>交互方式不同</p><blockquote><ul><li>pc 端主要是用鼠标、键盘来实现交互</li><li>移动端主要是用手指来实现交互，所以我们在学移动端开发时，需要了解移动端的手机触摸事件。</li></ul></blockquote></li><li><p>网络环境和设备性能的不同</p><blockquote><ul><li>移动端的网络环境与 PC 端相比，无论是在网络下载速度还是在流量方面，都要比 PC 端差些。</li><li>PC 端的设备性能要比移动端的设备性能要强很多，所以我们在做移动端开发时，<strong>要更注重性能的优化</strong>，否则可能会带来较差的性能体验。</li></ul></blockquote></li><li><p>兼容性不同</p><blockquote><ul><li>移动端的兼容性要比 PC 端好的多，因为移动端相较 PC 端发展的要晚一些，所以国内的 UC、QQ、百度等手机浏览器都是根据 Webkit 修改过来的内核，所以 html5 的新特性在移动端我们可以放心大胆的使用。<table><thead><tr><th>PC 端常见浏览器</th><th>移动端常见浏览器</th></tr></thead><tbody><tr><td>谷歌浏览器、火狐浏览器、Edge 浏览器、360 浏览器、QQ 浏览器、搜狗浏览器 … 等</td><td>Safari 浏览器、UC 浏览器、QQ 浏览器、欧朋浏览器、百度手机浏览器、360 安全浏览器、谷歌浏览器、搜狗手机浏览器、猎豹浏览器 … 等</td></tr></tbody></table></li></ul></blockquote></li></ol><h3 id="三、什么是像素、分辨率、物理像素、逻辑像素、设备像素比？"><a href="#三、什么是像素、分辨率、物理像素、逻辑像素、设备像素比？" class="headerlink" title="三、什么是像素、分辨率、物理像素、逻辑像素、设备像素比？"></a>三、什么是像素、分辨率、物理像素、逻辑像素、设备像素比？</h3><ol><li>什么是像素<blockquote><ul><li>当我们把一张图片在 PS 放大 240 倍后，我们发现这张图其实是由许许多多的小方格拼凑起来。这一个个的小方格就被定义为一个单位，叫像素。只不过小方格本身很小，所以人肉眼看不出来。</li><li>1 个小方格为 1 像素大小，2 个小方格为 2 像素大小，那 n 个小方格就是 n 像素。</li></ul></blockquote></li></ol><blockquote><p><strong>图标尺寸 n * m 像素</strong></p><ul><li>比如图片大小是200 * 300像素，也就是说该 图片的宽有200个小方格，高有300个小方格， 那该图片一共占200 *300&#x3D;60000个小格子。</li></ul></blockquote><blockquote><p><strong>1像素（1个小方格）多大？</strong></p><ul><li>小方格的大小就是 1 像素，像素就像是厘米或毫米一样被定义好的单位，专门用于电子屏幕上描述图形尺寸的单位。</li><li>但像素不像厘米等长度单位一样有固定大小，像素没有固定大小，1 像素就是一个小方格。<strong>不同的分辨率下</strong>，1 像素（小方格）大小不一样</li></ul></blockquote><ol start="2"><li>什么是分辨率<blockquote><ul><li>各种设备的屏幕尺寸是以英寸为单位的。</li><li>英寸：是一个长度单位，是有固定大小的，1英寸&#x3D;2.54 厘米。</li><li>我们知道屏幕也是一个矩形，按正常我们应该也是用 长度 * 宽度 的形式来描述，为什么会用一个长度单位英寸来描述呢？是因为显示屏幕不是胡乱设计比例的，他是有固定的设计比例，如 16：9、4：3 等，因此屏幕给出<strong>斜对角线的大小</strong>，具体屏幕宽高就可以根据屏幕的设计比例计算出来。<ul><li>所以屏幕尺寸大小为 15.6 英寸，指的是屏幕斜对角线的大小</li></ul></li></ul></blockquote></li></ol><blockquote><p><strong>分辨率与屏幕的关系</strong></p><ul><li>比如屏幕宽有 n 个小方格，高有 m 个小方格，那屏幕的分辨率就是 n * m像素</li><li>屏幕是如何划分小方格？<ul><li>屏幕划分小方格就好比我们画表格一样，横着、竖着加线条，就划分成了一排排的小格子</li></ul></li><li>如何计算此时电脑划分出来的小格子的大小 ？<ul><li>通过屏幕给出的英寸大小，可以计算出屏幕的宽和高的大小</li><li>再通过宽和高及分辨率，就可以计算划出来的小方格的长和宽的大小</li><li>知道小方格的长和宽，就能计算出一个小格子的（面积）大小。</li></ul></li></ul></blockquote><blockquote><p><strong>分辨率大小影响什么？</strong></p><ol><li>分辨率影响图片清淅度，最终影响了我们的视觉</li></ol><ul><li>相同尺寸的屏幕下，分辨率越小，一个小方格(1物理像素)占据的空间越大，格子轮廓越明显，图片就越不清晰，体验感越差</li><li>由此可见，相同尺寸的图片，分辨率越高，图片显示的越清淅。</li></ul><ol start="2"><li>分辨率还影响图片展示效果，最终影响了我们的视觉</li></ol><ul><li>1像素的具体大小在不同的设备上是不一样的，屏幕大小相同，同一张图片:<ul><li>分辨率越高，划分的小格子数越多，1 像素占据的空间就会越小，图片显示出来的大小就越小，但是会越清晰，</li><li>分辨率越低，划分的小格子数越少，1 像素占据的空间就会越大，图片显示出来的大小就越大，但很模糊。</li></ul></li></ul></blockquote><ol start="3"><li>什么是物理像素与逻辑像素、设备像素比<blockquote><p><strong>物理像素（设备像素 dp）</strong></p><ul><li>在设备一生产出来后就确定的像素称作设备物理像素，也叫设备像素(device pixels),简称 dp。也就是我们前面讲到的显示屏幕划分出的物理小格子 ，1 个小格子就是一个物理像素。</li><li>所以尺寸大小一样时，分辨率越大，格子越小，1 个物理像素就越小，图片显示就越清淅。</li><li>设备生产出来后，尺寸是固定的，分辨率通常也是固定的，所以物理像素的大小是生产出来后就确定的，其大小是不能改变的。</li></ul></blockquote></li></ol><blockquote><p><strong>逻辑像素（CSS 像素）（设备独立像素 dip）</strong></p><ul><li>用于表示图片尺寸等，<strong>可时刻改变的像素</strong>称作逻辑像素，也叫设备独立像素(device independent pixels) ，简称 dip</li><li>也就是我们通常说的 CSS 像素，比如100px 、200px等</li><li>浏览器内的一切长度都是以 CSS 像素（逻辑像素）px为单位的。</li><li>为什么说逻辑像素是可以时刻改变的像素呢？<ul><li>是因为1px在屏幕上的具体显示大小，是由其所在的设备的<strong>设备像素比</strong>来决定的。</li></ul></li></ul></blockquote><blockquote><p><strong>设备像素比 (dpr)</strong></p><ul><li>设备像素比(devicePixelRatio)，简称 dpr，是指物理像素与逻辑像素的比例。</li><li>公式：<code>dpr = (在一个方向上)物理像素dp / 逻辑像素dip (没有缩放时)</code></li><li>物理像素dp与逻辑像素dip的显示关系<ul><li>当 dpr&#x3D;1 时，说明物理像素和逻辑像素是 1：1，此时一个物理像素显示一个逻辑像素</li><li>当 dpr&#x3D;2 时，说明物理像素是逻辑像素的 2 倍，此时<strong>2*2&#x3D;4</strong>个物理像素显示 1 个逻辑像素</li></ul></li><li>假设，以下两个手机的屏幕大小一样<ul><li>dpr&#x3D;1 的手机分辨率是2*4像素</li><li>dpr&#x3D;2 的手机分辨率是4*8像素</li></ul></li><li>现在1*1px的图片，在两台设备上显示效果如下：<ul><li>在dpr&#x3D;1 的设备上，则1个物理像素显示一个逻辑像素</li><li>在dpr&#x3D;2 的设备上，则4个物理像素显示一个逻辑像素<blockquote><p>注：</p></blockquote></li></ul></li><li>在一般的电脑上，设备像素是等于逻辑像素的，也就是dpr&#x3D;1.0,高分辨率的电脑上，二者不一定相等，浏览器提供一个接口可以查看二者的关系：</li><li>在 console 控制台输入 window.devicePixelRatio属性查看</li><li>dpr值，厂商在设备出厂时就已经进行设置，并且禁止用户进行更改</li></ul></blockquote><blockquote><p><strong>图片缩放，是在改变什么？</strong></p><ul><li>图片的缩放是在改变图片的<strong>逻辑像素</strong></li><li>一般情况下点开图片查看时是将图片的一个小格子(逻辑像素)对应到一个显示屏幕的小格子（物理像素）。</li><li>但图片在被放大或者缩小后，图片的像素小格子便不再是一一对应于显示屏幕的分辨率划分出的物理小格子了。<ul><li>图片放大 3 倍，其逻辑像素点也增为原来了3倍，此时 1 个逻辑像素占一个物理像素，但是因为逻辑像素为原来的 3 倍，那对应占的物理像素点也是原来的3倍。</li><li>此时相当于原来的一个图片小格子就占据3个物理小格子大小显示，因此图片就看起来放大了，甚至超出屏幕大小。</li><li>图片缩小到 0.5，则一个图片小格子就占据半个物理小格子，看起来就缩小了。</li></ul></li></ul></blockquote><ol><li><p>为什么要有物理像素和逻辑像素之分？</p><blockquote><ul><li>为什么不用物理像素表示图片的大小<ul><li>因为两个电脑尺寸完全一样，但分辨率不一样，看到的图片大小差别很大，这个体验非常不好。</li></ul></li><li>如果两台电脑的屏幕尺寸完全一样，一个分辨率是<code>1920 *1080</code>, 一个是<code>960 *540</code>,那么二者同时放一个<code>300* 300</code>的物理像素大小的图片，结果会怎么样？<ul><li>在高分辨率<code>1920 *1080</code>下1像素（小方格）要比低分辨率<code>960 *540</code> 1像素（小方格）要小很多，所以在 1920 *1080下看到的图片会很小，在960 *540 下看到的图片会很大。</li></ul></li></ul></blockquote></li><li><p>如何让相同尺寸屏幕下，不同分辨率，看同一图片效果差别不大？</p><blockquote><ul><li>实现的方法就是提高那些分辨率很高但是屏幕尺寸很小的设备的 dpr</li><li>分辨率很高，如果屏幕尺寸很小，则 1 个物理像素点会很小，那图片显示就会很小，提高 dpr 后，则 1px 逻辑像素会占用更多的设备像素点，这样图片看起来会更大些</li><li>例如 300 * 300 逻辑像素大小的图片，有屏幕尺寸相同的两个设备 A &#x2F; B<ul><li>A 的分辨率为 1920 * 1080，设置 A 的 dpr &#x3D;2，从而得到 4 个物理像素显示 1 个逻辑像素</li><li>B 的分辨率是 960 * 540 ，设置 B 的dpr &#x3D;1，从而得到 1 个物理像素显示 1 个逻辑像素</li><li>这样同一个图片在 B 设备中一个像素小格子占一个物理格子，在 A 设备中，因为 A 的物理小格子小，那就 4 个物理小格子显示 1 个逻辑像素，这样呈现的两个图片大小就看起来就一样大的了。<blockquote><p>这就是为什么相同尺寸的屏幕，其分辨率越高，对应的 dpr 往往会越大。</p></blockquote></li></ul></li></ul></blockquote></li><li><p>什么是标清屏和高清屏？</p><blockquote><ul><li>当设备的 dpr&#x3D;1 时，这个设备可以称为是标清屏</li><li>当设备的 dpr&gt;1 时，这个设备可以称为是高清屏</li><li>目前高清屏的 dpr 通常为 2，3 等。<blockquote><p>相同尺寸的屏幕，其分辨率越高，对应的 dpr 往往会越大,图像越高清</p></blockquote></li></ul></blockquote></li><li><p>移动开发为什么要使用 2 倍或 3 倍图？</p><blockquote><ul><li>思考题：标清屏中，1 个逻辑像素用一个物理像素显示，图片设计的效果正好和展示效果一样，在高清屏 dpr&#x3D;2 中，1 个逻辑像素用 4 个物理像素显示，图片到底是更清淅了，还是更模糊了？<ul><li>在高清屏中 1 个 CSS 像素点实际上由 4 个物理像素展示，1 分成 4，显然不够分，只能颜色近似选取,所以，图片感觉就会变的模糊了</li></ul></li><li>为了让移动端能够显示高清图效果，所以我们在设计的时候<ul><li>针对 dpr &#x3D; 2 的高清屏，专门设计 2 倍图来开发</li><li>针对 dpr &#x3D; 3 的高清屏，专门设计 3 倍图来开发<blockquote><p>比如: iPhone SE 的分辨率 750 * 1334，dpr &#x3D; 2，在水平方向上能显示的 CSS 像素为 375px,因此我们在设计稿时，就需要设计 2 倍图，即设计稿的宽为 750px，然后在实际开发时，按 750&#x2F;2 &#x3D; 375px 大小来开发。</p></blockquote></li></ul></li></ul></blockquote></li></ol><h3 id="四、viewport-视口设置"><a href="#四、viewport-视口设置" class="headerlink" title="四、viewport 视口设置"></a>四、viewport 视口设置</h3><ol><li><p>在 pc 端和移动端，网页中 html,body 的默认宽是多少 ？</p><blockquote><ul><li>pc 端（分辨率为<code>1920 * 1080</code>）下<ul><li>html 的默认宽为浏览器宽<code>1920px</code></li><li>body为块级元素，在设置 <code>margin: 0;</code>时，body的宽等于html宽<code>1920px</code><blockquote><p>在 PC 端，一个物理像素就等于 1 个 px 逻辑像素</p></blockquote></li></ul></li><li>移动端<ul><li>大部分手机浏览器的宽为<code>980px</code></li><li>手机端网页中 html 的默认宽等于浏览器宽为<code>980px</code></li><li>body 块级元素，在设置<code>margin: 0;</code>时，body的宽等于html 宽等于<code>980px</code></li></ul></li></ul></blockquote></li><li><p>如果把一个 PC 端的网站，在手机端显示打开，会看到什么样的效果？</p><blockquote><ul><li>当我们把 PC 端布局的页面(内容宽为 980px)，直接放在移动端来显示，会发现整体被压缩变小</li><li>原因：因为移动端的浏览器默认宽为 980px，而要把浏览器整个显示在 <code>iPhone SE</code>的屏幕下，而iPhone SE的可视宽只有375px，所以整个浏览器就会被压缩（缩放）到375px大小。则浏览器中的内容也要等比例压缩到到宽为 375px 的屏幕里。<ul><li>如果电脑端网站的宽<code>&gt; 980px</code>，则在移动端会出现水平滚动条，拖动滚动条可查看全部内容</li><li>如果电脑端网站的宽<code>&lt; 980px</code>，则在移动端并不能全屏展示，会在水平上留有空白</li></ul></li></ul></blockquote></li><li><p>为什么移动端 body 的默认宽为 980px</p><blockquote><ul><li>很早之前，电脑的分辨率比较低，写一个电脑端的网站基本都是在980px以内。为了让980px的网站可以在手机完美显示出来，浏览器开发商把浏览器的默认宽设置为了980px，也就是我们后面要提到的<strong>布局视口宽</strong>。</li><li>移动端是在这个布局视口来布局网页，所以移动端网页的html默认宽为980px，body是块级元素，在设置margin: 0;时，其宽会等于 html 的宽980px。</li><li>但是 PC 端的网页在移动那么小的屏幕里看时，会被压缩，所以需要通过双指来放大网页才能看得更清楚，本质上体验还是没有达到最佳状态。</li><li><strong>那如何才能让手机端看到的网页是最佳的状态呢？</strong><ul><li>那肯定要专门针对移动端的尺寸大小来设计和布局网页。但是移动端尺寸五花八门，没有办法把浏览器的大小固定到某个尺寸，这就有了接下来提出的viewport 视口的概念。</li></ul></li></ul></blockquote></li><li><p>视口分类</p><blockquote><p>在 PC 端，视口指的是浏览器的可视区域，其宽度和浏览器窗口的宽度保持一致。</p><ul><li>移动端涉及三个视口：布局视口(Layout Viewport)、视觉视口(Visual Viewport)、理想视口(Ideal Viewport)</li></ul></blockquote></li></ol><blockquote><p><strong>布局视口(Layout Viewport)</strong></p><ul><li>布局视口可以简单理解为移动端网页的宽度（浏览器宽），也就是我们在上面提到的 html、body 的默认宽为 980px。</li><li>默认我们是在这宽为 980px 的容器中来布局网页。<img src="布局视口.png"></li></ul></blockquote><blockquote><p><strong>视觉视口(Visual Viewport)</strong></p><ul><li>用户在默认情况下能看到的网站的区域</li><li>默认情况下浏览器大小会被压缩来适应视觉视口大小，所以默认情况下看到的内容大小要比实际小很多<img src="视觉视口.png"></li></ul></blockquote><blockquote><p><strong>理想视口(Ideal Viewport)</strong></p><ul><li>当<code>布局视口 = 视觉视口</code>时，就是我们期待的理想视口。</li><li>理想视口下，浏览器大小与视觉视口大小相等，内容不会被压缩）<img src="理想视口.png"></li></ul></blockquote><blockquote><ul><li>适配代码：<code>&lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot; /&gt;</code></li><li>width&#x3D;device-width 表示布局视口&#x3D;设备视口（视觉视口）</li></ul></blockquote><ol start="5"><li>viewport的设置<blockquote><p>为了让移动端能正常的显示网页，我们通常会在网页的<head>标签中添加如下代码</p><pre><code>&lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no&quot;/&gt;</code></pre><table><thead><tr><th>属性</th><th>值</th></tr></thead><tbody><tr><td>width</td><td>设置布局视口的宽</td></tr><tr><td>当 width&#x3D;device-width 时，即布局视口&#x3D;视觉视口，也就达到了我们想要的理想视口</td><td></td></tr><tr><td>initial-scale</td><td>设置页面的初始缩放值，为一个数字，可以带小数；值为 1，表示不缩放</td></tr><tr><td>minimum-scale</td><td>允许用户的最小缩放值，为一个数字，可以带小数</td></tr><tr><td>maximum-scale</td><td>允许用户的最大缩放值，为一个数字，可以带小数</td></tr><tr><td>height</td><td>设置 layout viewport 的高度，这个属性对我们并不重要，很少使用</td></tr><tr><td>user-scalable</td><td>是否允许用户进行缩放，值为”no”或”yes”, no 代表不允许，yes 代表允许</td></tr></tbody></table></blockquote></li></ol><blockquote><pre><code>/*JS 获取视口宽 */document.documentElement.clientWidth/* 获取屏幕尺寸 */screen.width</code></pre></blockquote><h3 id="五、真机查看"><a href="#五、真机查看" class="headerlink" title="五、真机查看"></a>五、真机查看</h3><ol><li><p>创建本地服务器</p><blockquote><p>通过 VSCode 来创建本地服务器，在VSCode通过<code>Open with Live Server</code>打开网页，在地址栏中就能看到类似以下的地址：<a href="http://127.0.0.1:5500/demo.html">http://127.0.0.1:5500/demo.html</a></p></blockquote></li><li><p>查看本机IP地址</p><blockquote><ul><li>在电脑的右下击输入 cmd,然后回车，就可以进到电脑的命令黑窗口</li><li>在命令黑窗口，输入 ipconfig ，然后回车，就能看到 IPv4 地址</li><li>我们将本地服务地址：<a href="http://127.0.0.1:5500/demo.html">http://127.0.0.1:5500/demo.html</a> 中的 <code>127.0.0.1</code>替换成 192.168.0.19(IPv4 地址)</li><li>修改完成后的最终地址：<a href="http://192.168.0.19:5500/demo.html">http://192.168.0.19:5500/demo.html</a> ，然后回车看在电脑端是否能正常访问到。</li></ul></blockquote></li><li><p>关闭防火墙</p><blockquote><ul><li>在电脑左下角，搜索 “ 控制面板 ” ，点击控制面板进入</li><li>点击系统和安全，进入</li><li>点击 windows Defender 防火墙</li><li>点击左边的启用或关闭 Windows Defender 防火墙</li><li>点击关闭防火墙</li></ul></blockquote></li><li><p>手机端访问地址</p><blockquote><ul><li>防火墙关闭后，要确保手机和电脑是在同一网络中<ul><li>方法一：电脑开热点，手机连电脑热点</li><li>方法二：电脑手机连同一无线网</li></ul></li><li>网络环境设置好了后，接下来只需在在手机端防问 <a href="http://192.168.0.19:5500/demo.html">http://192.168.0.19:5500/demo.html</a> 就可以正常访问了。</li><li>也可以把地址在草料网生成对应的二维码，手机直接扫二维码访问。</li></ul></blockquote></li></ol><h3 id="六、移动开发常用的单位"><a href="#六、移动开发常用的单位" class="headerlink" title="六、移动开发常用的单位"></a>六、移动开发常用的单位</h3><table><thead><tr><th>单位</th><th>说明</th></tr></thead><tbody><tr><td>px</td><td>绝对单位，当需要设置固定宽高时可用，也可用于设置字体大小</td></tr><tr><td>%</td><td>相对单位，可用来设置元素宽度，流体布局中会用到</td></tr><tr><td>em</td><td>相对单位，设置<strong>字体大小</strong>时，1em&#x3D;父元素字体大小；<strong>设置其它，比如宽、高等</strong>，1em&#x3D;自身字体的大小，比如之前讲的首行缩进。一般用来控制首行缩进，不用来布局</td></tr><tr><td>rem</td><td>rem(root element) 是相对于 html 的 font-size 的字体大小。1rem&#x3D;根元素（html）的字体大小，rem主要是用来做移动端布局</td></tr><tr><td>vw&#x2F;vh</td><td>相对单位，是视口单位，用来移动端布局，vw 用的多，vh 基本不用,1vw&#x3D;视口<strong>宽度</strong>的 1%，1vh&#x3D;视口<strong>高度</strong>的 1%</td></tr><tr><td>vmax</td><td>当前 vw 和 vh 中较大的一个值（竖屏时,100vmax&#x3D;100vh）</td></tr><tr><td>vmin</td><td>当前 vw 和 vh 中较小的一个值（竖屏时，100vmax&#x3D;100vw）</td></tr></tbody></table><h2 id="移动WebApp项目开发常用技术及标准、规范和最佳实践"><a href="#移动WebApp项目开发常用技术及标准、规范和最佳实践" class="headerlink" title="移动WebApp项目开发常用技术及标准、规范和最佳实践"></a>移动WebApp项目开发常用技术及标准、规范和最佳实践</h2><h3 id="一、基础知识"><a href="#一、基础知识" class="headerlink" title="一、基础知识"></a>一、基础知识</h3><ol><li>移动端与PC端有哪些不同？(上面有写)<blockquote><ul><li>屏幕大小不同</li><li>交互方式不同</li><li>网络环境和设备性能不同</li><li>兼容性不同</li></ul></blockquote></li></ol><blockquote><ul><li>因为屏幕大小的不同，所以造成我们在实际的移动端布局时，不能和 PC 端一样采用固定大小来布局，而需要自适应屏幕的宽。</li><li>移动端屏幕的常见可视区大小为<code>320-480px之间</code>，也就意味着我们在实际开发代码时，我们的页面宽在320-480px之间。</li><li>所以移动端开发，元素的宽肯定不能用px绝对定位写死，我们得采用<strong>相对单位</strong>来做开发。</li></ul></blockquote><ol start="2"><li><p>移动端常见的布局处理技术</p><blockquote><p><strong>移动端常见的5种布局技术如下：</strong></p><ul><li>流体布局</li><li>rem 和 vw 布局</li><li>响应式布局</li><li>Flex 弹性布局（工具）</li><li>Grid 网格布局（工具）<blockquote><ul><li>其中的流体布局、rem&#x2F;vw 布局、响应式布局是可以<strong>独立实现</strong>移动端页面的开发</li><li>Flex 弹性和 Grid 网格布局，并不能独立实现移动端布局的开发，他们更像是<strong>工具</strong>，配合流体布局、rem&#x2F;vw 布局、响应式布局来实现移动端页面的开发。</li></ul></blockquote></li></ul></blockquote></li><li><p>移动设计稿的标准与规范</p><blockquote><ul><li>京东视觉规范.pdf</li></ul></blockquote></li></ol><h3 id="二、流体布局"><a href="#二、流体布局" class="headerlink" title="二、流体布局"></a>二、流体布局</h3><blockquote><p>所谓的流体布局，也叫百分比%布局，本质上就是通过**%（百分比）<strong>和</strong>怪异盒子模型<strong>结合来实现</strong>元素的宽**相对视口缩放</p></blockquote><ol><li><p>搭建本项目的目录结构</p><blockquote><ul><li>首先新建项目文件夹 WebApp</li><li>在 WebApp 中新建 css、js、images 文件夹，分别用来存放 CSS、JS 文件和图片内容</li><li>在 CSS 中新建 reset.css、global.css、index.css 文件，分别用来存放重置默认样式、全局通用样式，首页样式</li><li>reset.css参考PC端重置样式<br>其它相关重要的重置样式介绍</li></ul><pre><code>/* 去掉点击的高亮显示效果 */-webkit-tap-highlight-color: transparent;/* 在移动端浏览器默认的外观在ios上加上这个属性才能给按扭和输入框自定义样式 */-webkit-appearance: none;/* 禁用长按页面时的弹出菜单 */img,a &#123; -webkit-touch-callout: none;&#125;/* 表单会有外轮廓 */input &#123; outline: none;&#125;/* 去掉图片下面的空隙 */vertical-align: top;</code></pre></blockquote></li><li><p>了解设计稿的整体标准和规范</p><blockquote><ul><li>将设计稿中的通用样式写在global.css文件中</li></ul></blockquote></li><li><p>新建 index.html 网页，进行首页开发</p><blockquote><ul><li>在当前根目录下新建<code>index.html</code>网页</li><li>做好viewport视口配置<br><code>&lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no&quot;&gt;</code></li><li>引用相关的 CSS 文件，注意引入文件的顺序</li></ul><pre><code>/* 重置样式 */css代码.../* 网站通用布局 */css代码.../* 通用模块 */css代码.../* 通用元件 */css代码.../* 通用响应式系统 */css代码...</code></pre></blockquote></li><li><p>网站整体（html）结构划分</p></li><li><p>每个版块开发</p><blockquote><ul><li>流体布局(%百分比 + 怪异盒子模型布局)：整个页面中会用到的所有元素，在最开始都需要设置为怪异盒子模型 。</li><li>由于一开始，我们并不清楚，页面可能会用到那些html元素，所以我们一开始可以用<code>*</code>来处理，等页面开发完，再把<code>*</code>换成对应的html标签。</li></ul></blockquote></li><li><p>iOS下tabbar底部留白与黑线遮挡问题</p><blockquote><p>要解决 IOS 下 tabbar 底部留白问题，我们需要先了解两个概念，安全区域和刘海区，案例如下：</p><pre><code>&lt;style&gt; html, body &#123;   margin: 0; &#125; .tabbar &#123;   width: 100%;   height: 100px;   background-color: red;   position: fixed;   z-index: 222;   bottom: 0; &#125;&lt;/style&gt;&lt;body&gt; &lt;footer class=&quot;tabbar&quot;&gt;&lt;/footer&gt;&lt;/body&gt;</code></pre><img src="安全区与刘海区.png">- 页面默认填充的是安全区域的高度，并不包括刘海区</blockquote></li></ol><blockquote><p><strong>那如何让页面高度填充到刘海区呢？</strong></p><ul><li>在viewport中添加viewport-fit&#x3D;cover</li></ul><pre><code>&lt;meta  name=&quot;viewport&quot;  content=&quot;width=device-width,viewport-fit=cover,initial-scale=1.0&quot;/&gt;`</code></pre></blockquote><blockquote><p><strong>而高度填充到刘海区后，tabbar的内容就会被底下的黑线给遮挡一小部分</strong></p><ul><li>方法一：<ul><li>添加以下代码的元素，不能是怪异盒子模型，否则元素自身高度会减少</li></ul></li></ul><pre><code>/* 兼容 IOS&lt;11.2 */padding-bottom: constant(safe-area-inset-bottom);/* 兼容 IOS&gt;11.2 */padding-bottom: env(safe-area-inset-bottom);</code></pre><ul><li>方法二：</li></ul><pre><code>/* 兼容 IOS&gt;11.2 */height: calc(50px+ constant(safe-area-inset-bottom));/* 兼容 IOS&gt;11.2 */height: calc(50px + env(safe-area-inset-bottom));</code></pre><blockquote><ul><li>100px 是 tabbar 原来的高度 </li><li>在实际开发中，我们一般是先 constant，再 env</li></ul></blockquote><ul><li>针对其它一些机型，不支持上面两种写法的，可以选择用CSS的<code>@supports</code></li></ul><pre><code>@supports not (constant(safe-area-inset-bottom)) &#123;  .tabbar &#123;    padding-bottom: 30px;  &#125;&#125;</code></pre></blockquote><ol start="7"><li>流体布局的布局思路与缺陷<blockquote><p><strong>（1） 流体布局思路</strong></p><ul><li>通过计算每个子元素占容器的比例，来平分父容器的整体大小。</li><li>所有子元素宽的百分比% 加起来要等于 100%。</li><li>然后通过给子元素设置对应的内边距来实现元素间的空隙。</li><li>为了保证给子元素添加内边距实现空隙时，不会造成元素宽度变宽，所有元素都设为 box-sizing: border-box;</li></ul></blockquote></li></ol><blockquote><p><strong>（2） 流体布局缺陷</strong></p><ul><li>只能实现图片和容器的宽高等比缩放，没有办法实现间距，字体大小的等比缩放</li><li>如果想实现对应的字体和间距在不同尺寸下，有所变化，可以与@media媒体查询结合来实现微调。</li></ul></blockquote><ol start="8"><li>从项目中学到的：<blockquote><ul><li><code>padding-bottom:100%;</code>：使高度等于宽度，宽度不包括<code>padding</code></li><li>页面缩放时，图片等比缩放&#x2F;避免图片尺寸不一：<ul><li>把图片的父盒子a标签改成块级元素，用<code>padding-bottom</code>固定宽高比例</li><li>使图片绝对定位于a标签，<code>top=0;left=0;</code>宽高100%,使用<code>object:cover;</code>等比缩放尺寸不一的图片；</li></ul></li><li>用@media实现文字在界面放大到一定宽度后的字体放大，响应式</li><li>流式布局因为是用百分比实现的，所以子元素所占的总百分比一定是百分之百，也就是把父元素全部分完；子元素之间的间隙，用padding实现，不能用margin</li><li>怪异盒模型下文字垂直居中的问题<ul><li>文字行高为18px,有1px边框时，标签行高就为20px，<code>line-height:18px</code>，不能惯性的设置为<code>line-height:20px</code>。</li></ul></li><li>媒体查询代码一定要放在样式的最后面</li><li>底部的tabbar导航的层级是最高的，并且内容区底部要设置padding≥tabbar的高度</li></ul></blockquote></li></ol><h3 id="二、移动端rem布局原理"><a href="#二、移动端rem布局原理" class="headerlink" title="二、移动端rem布局原理"></a>二、移动端rem布局原理</h3><ol><li><p>rem实现适配的原理</p><blockquote><p>假设我们现在要实现 750 * 400px 的 div，在 750px 宽的设备下，改用 rem 单位实现等比展现，那我们的 css 代码如何写呢 ？<br>假设此时1rem &#x3D; 10px，则对应 CSS 样式如下：</p><pre><code>div &#123;  /* 相当于将整个页面分成 75份  每一份大小为10px */  width: 75rem;  height: 40rem;&#125;</code></pre><p>如果以上 CSS 代码不变（将页面分成 75 份），要实现在不同大小屏幕上能等比缩放，我们来看下，对应的 rem 要设置为多少？</p><table><thead><tr><th>设备可视宽</th><th>750px</th><th>375px</th><th>540px</th></tr></thead><tbody><tr><td>1rem</td><td>大小</td><td>10px</td><td>5px</td></tr></tbody></table><ul><li>所以我们要用 rem 来开发移动端之前，需要思考，先将页面分成多少份？然后通过以下公式</li><li><code>1rem = 设备可视宽 / 对应份数</code></li><li>得到不同设备下 <code>1rem</code> 的大小<blockquote><p>在实际开发中，不同尺寸的手机屏幕下 1rem 的大小，是通过 js 来动态获取<strong>当前设备可视宽&#x2F;对应份数来实现</strong></p></blockquote></li></ul></blockquote></li><li><p>JS 动态实现不同设备下 1rem 的大小</p><blockquote><p>1rem&#x3D;（html）中 font-size 的大小，则我们只需要动态修改 html 的 font-size 的大小就可以</p></blockquote></li><li><p>px 单位如何转换为 rem</p><blockquote><p>在实际开发的时候，我们是以 750px 的设计稿为标准来开发的</p><ul><li>现在假设我将页面分成 10 份，那<code>1rem = 750px / 10 = 75px</code></li><li>那对应的 px 单位，转换成对应的 rem 单，计算公式：<code>?rem = 元素对应的px单位大小 / 1rem 大小</code></li><li>实际开发中我们并不会手动将px转换成对应rem单位，我们会用vscode的 <code>px to rem</code>插件来实现</li></ul></blockquote></li><li><p>px to rem 插件使用</p><blockquote><ul><li>参数配置：修改扩展设置，填写1rem的大小</li><li>快捷键：<code>alt+z</code></li><li>回到 html 页面，ctrl+A 选中所有 CSS 样式，然后按 Alt+Z，就会自动将 px 转成 rem 单位。</li></ul></blockquote></li><li><p>利用 rem 实现元素宽高等比缩放</p><blockquote><ul><li>将页面分成 10 份，通过 js 来实现不同视口下 1rem 的大小</li><li>利用 px to rem 插件，将 px 单位转换成对应 rem 单位</li><li>px to rem 插件中，1rem 大小设置为 75 （以 750px 设计稿开发）</li></ul></blockquote></li><li><p>总结：实际开发如何用 rem 做适配</p><blockquote><p>在实际开发中，我们会按以下步骤来实现开发</p><ul><li>1、要求设计师以 750px 宽，来设计移动端的设计稿；</li><li>2、我们按正常的 750px 的设计稿，以 px 单位来开发；</li><li>3、我们会假定将页面分成对应的份数，然后求得不同份数下的 1rem 的大小；<ul><li>如果在 750px 设备下，将页面分成 75 份，则 html 的 font-size 大小&#x3D;设备可视宽 (750) &#x2F; 75 &#x3D; 10px</li><li>如果在 750px 设备下，将页面分成 10 份，则 html 的 font-size 大小&#x3D;设备可视宽 (750) &#x2F; 10 &#x3D; 75px</li></ul></li><li>4、将 px 单位转换为对应的 rem 单位<ul><li>将 px 像素转换 rem 单,公式：?rem &#x3D; px值 &#x2F; 1rem大小得到最对应 rem 单位值</li><li>我们并不会手动一个一个去计算，而是利用 vscode 中的插件px to rem一次搞定</li><li>假定将页面分成 75 份，那就把px to rem插件中对应 1rem 大小设为 10</li><li>假定将页面分成 10 份，那就把px to rem插件中对应 1rem 大小设为 75</li><li>最后切换到 CSS 代码，ctrl+A选中所有代码，然后Alt+Z之后，就会自动把所有px单位，转换成对应vw单位。<blockquote><p>在实际开发中，我们是以 750px 的设计稿来开发，假定将页面分成 10 份，每 1rem &#x3D; 75px</p></blockquote></li></ul></li></ul></blockquote></li></ol><h3 id="四、移动端vw原理"><a href="#四、移动端vw原理" class="headerlink" title="四、移动端vw原理"></a>四、移动端vw原理</h3><ol><li><p>vw 的适配原理</p><blockquote><p>我们知道 100vw &#x3D; 视口宽，相当于把整个屏幕分成了 100 份，所以不同屏幕尺寸下，1vw 的大小如下</p><table><thead><tr><th>设备可视宽（屏幕宽）</th><th>1vw 大小</th></tr></thead><tbody><tr><td>750px</td><td>7.5px</td></tr><tr><td>680px</td><td>6.8px</td></tr><tr><td>480px</td><td>4.8px</td></tr><tr><td>375px</td><td>3.75px</td></tr></tbody></table><ul><li>上面表格中，不同屏幕尺寸下 1vw 的大小，不需要我们手动或通过 js 来计算，而是<strong>浏览自动会帮我转换</strong></li><li>其实你可以理解，如果用 rem 来实现，把页面分 100 份，不同屏幕下 1rem 的大小与对应的 1vw 的大小时一样。</li><li>唯一的区别，<code>1vw</code> 的大小是<strong>浏览器自动转换</strong>，而 <code>1rem</code> 的大小，需要通过<strong>js获取屏幕大小&#x2F;100</strong>来得到。</li></ul></blockquote></li><li><p>px 如何转换成对应 vw 单位</p><blockquote><p>我们同样以 750px 的设计稿为例，那 <code>1vw = 7.5px</code> ，则转换成对应 vw 单位，公式如下：</p><ul><li><code>? vw = 元素 px 大小 / 7.5</code></li></ul></blockquote></li><li><p>插件</p><blockquote><ul><li>我们不需要一个个手动将px转成vw，我们可以借助VScode的插件<code>px to vw</code>来实现。</li><li>px to vw的使用方法和上面讲到的px to rem是一样，唯 一的区别，就是在扩展设置时不一样，填写的是&#x3D;&#x3D;视口宽&#x3D;&#x3D;，而不是1vw的大小</li></ul></blockquote></li><li><p>实际开发如何用 vw 做适配</p><blockquote><p>在实际开发中，我们会按以下步骤来实现开发</p><ul><li>1、要求设计师以 750px 宽，来设计移动端的设计稿</li><li>2、我们按正常的 750px 的设计稿，以 px 单位来开发</li><li>3、将 px 单位转换为对应的 vw 单位<ul><li>将 px 像素转换 vw 单位，对应公式：?vw &#x3D; px值 &#x2F; 7.5</li><li>我们并不会手动一个一个去计算，而是利用 vscode 中的插件px to vw一次搞定</li><li>在 VSCode 中安装 px to vw 软件中，然后将“扩展设置” 中 Viewport Width 值设为 750</li><li>切换到 CSS 代码，ctrl+A选中所有代码，然后Alt+Z之后，就会自动把所有 px 单位，转换成对应 vw 单位</li></ul></li></ul></blockquote></li></ol><h3 id="五、移动端开发常见问题"><a href="#五、移动端开发常见问题" class="headerlink" title="五、移动端开发常见问题"></a>五、移动端开发常见问题</h3><ol><li><p>图片缩放</p><blockquote><p>效果：图片填充满当前区块，同时<strong>等比</strong>裁剪，<strong>居中显示</strong>在当前区块中</p><ul><li>在流体布局中<ul><li>父盒子利用<code>padding-bottom</code>保持宽高比</li><li>子盒子宽高100%+<code>object-fit:cover;</code></li></ul></li><li>在其他布局中<ul><li>父盒子宽高使用rem&#x2F;vw</li><li>子盒子宽高100%+<code>object-fit:cover;</code><br><strong>处理这个问题的意义</strong><br>在实际的网站上线后，数据都是从后台读取的，用户在上传图片尺寸时，并不一定会按照设计师设计的比例来上传，这样就会造成图片上传后，大小不一样。</li></ul></li><li>图片高度过小，会在下面留下空白，</li><li>图片高度过大，会有一部分下面的内容看不到</li><li>我们实际在设计一张图时，重要的内容会在中间显示，所以最理想的效果是让图片能水平垂直居中于容器中</li></ul></blockquote></li><li><p>背景图缩放</p><blockquote><ul><li>当背景图片的宽高比与容器的宽高比不一样时</li><li>我们希望不管容器宽高如何缩放，图片一直填充整个容器，然后水平垂直居中显示</li></ul><pre><code>&lt;style&gt;  body &#123; margin: 0;  &#125;  .box &#123; width: 100vw; height: 31.467vw; /* 背景图片  不重复  水平垂直居中显示 */ background: url(./images/banner1-@2x.png) no-repeat center; /* 背景图填充整个容器 */ background-size: cover;  &#125;&lt;/style&gt;&lt;body&gt; &lt;div class=&quot;box&quot;&gt;&lt;/div&gt;&lt;/body&gt;</code></pre></blockquote></li><li><p>精灵图使用</p><blockquote><ul><li>精灵图采用的是 2 倍图</li><li>所以在处理精灵图时，我们需要通过 background-size: 50%; ，来将背景图片大小缩小一半</li><li>测量尺寸时，也需要按一半的大小来测量</li></ul></blockquote></li><li><p>元素正方形缩放</p><blockquote><p>元素在缩放过程中，元素的高始终等于宽，同时元素中的内容在元素中水平垂直居中</p><ul><li>利用padding-bottom:100%;来实现元素的高与元素宽一样大小，同时等比缩放</li><li>利用absolute 绝对定位与transform实现子项在容器中水平垂直居中</li></ul></blockquote></li></ol><blockquote><blockquote><p><strong>图片缩放总结</strong></p></blockquote><ul><li>只要涉及到图片缩放问题，最好将图片放在一个 html 标签中，然后设置 html 标签的宽高</li><li>html 标签的宽高，就是我们希望图片等比例缩放的展示区大小</li></ul></blockquote><ol start="5"><li>经典的 1 像素问题<blockquote><p>在面试中，经常会问到移动端 1px 的处理问题，那到底 1px 问题，是个什么问题呢 ？<br><strong>何为 1 像素问题</strong><br>为了更好的理解 1 像素问题，我们从两个方面来展开讲解</p><ul><li>PSD 设计稿</li><li>1px 实际显示的大小</li></ul></blockquote></li></ol><blockquote><p><strong>PSD 设计稿</strong></p><ul><li>我们的设计稿是以 750px 宽来设计的，而我们实际开发时，代码是按 375px 来的。</li><li>在 750px 设计稿中的 1px，按我们实际的开发代码来说，要折半，折成 0.5px 才对。</li><li><strong>但是</strong>不同手机上，不同浏览器对小数的处理是不一样的</li><li><code>0.5px</code>在一些老的 IOS 和 Android 设备上不支持，他会把<code>低于0.5px</code>当成0来处理，<code>&gt;= 0.5px</code>当成1px来显示。</li><li>IOS上会: 把<code>&gt;= 0.75px</code> 的当作 1px 来处理 ，<code>&lt;0.75</code> 当成0.5px来处理,<code>&lt; 0.5px</code>当成0来处理</li><li>而且IOS上，用 <code>height: 1px</code> 来代替 <code>border-bottom: 1px solid red;</code>测出的效果不同</li><li>具体不同的手机上，效果不一样，具体以真机测试为主</li><li>所以直接把代码折半，设置成 0.5px 显然是达不到目的。</li></ul></blockquote><blockquote><p><strong>1px 实际显示的大小</strong></p><ul><li>我们都知道 1px 在 dpr 不同时，其显示的大小不同</li><li>而在设计师眼中，他设计的 1px，就是当前设备能显示的最小方格（最细的那个线），也就是物理像素中的 1 像素。</li><li>因此， 1px 像素问题，本质上不是问题，如果公司觉得没有必要，也就不用处理。</li><li>如果公司认为就是要用设备能显示的最细的那个小方格显示，那我们就要处理这个问题</li></ul></blockquote><blockquote><p><strong>1px 像素解决方案</strong><br>关于 1px 像素的处理方案有很多，这里我们提供一个最优的解决方案给到大家 transform+伪元素来实现<br><strong>实现原理：</strong></p><ul><li>利用伪元素来绘制 1px 的线条,然后利用定位，把线条放在对应位置</li><li>利用 media 查询判断不同的设备像素比对线条进行缩放</li></ul><pre><code>&lt;style&gt;  .box &#123;    height: 50px;    margin: px auto;    position: relative;  &#125;  .border-1px::before &#123;    position: absolute;    content: &quot;&quot;;    height: 1px;    width: 100%;    background-color: red;    bottom: 0;    /* transform: scaleY(0.5); */    /* 变换原点 */    transform-origin: 50% 0%;  &#125;  /* dpr=2，需要缩放一半，即0.5 */  @media only screen and (-webkit-min-device-pixel-ratio: 2) &#123;    .border-1px:before &#123;      transform: scaleY(0.5);    &#125;  &#125;  /* dpr=3，需要缩放到1/3，即0.33 */  @media only screen and (-webkit-min-device-pixel-ratio: 3) &#123;    .border-1px:before &#123;      transform: scaleY(0.33);    &#125;  &#125;&lt;/style&gt;&lt;body&gt; &lt;div class=&quot;box border-1px&quot;&gt;&lt;/div&gt;&lt;/body&gt;</code></pre></blockquote><blockquote><blockquote><p>当然，也可以通过 js 来判断 dpr,然后给元素添加对应的 Class 名字，来实现</p></blockquote><pre><code>if (window.devicePixelRatio &amp;&amp; devicePixelRatio &gt;= 2) &#123;  document.querySelector(&quot;.box&quot;).className = &quot;border-1px&quot;;&#125;</code></pre></blockquote><h3 id="六-注意事项"><a href="#六-注意事项" class="headerlink" title="六. 注意事项"></a>六. 注意事项</h3><ol><li><p>布局</p><blockquote><ul><li>在流体布局中，因为用px单位，距离会写死，所以我们在蓝湖查看尺寸使用的是自定义，指定宽度为设计稿宽度的一半</li><li>而在rem中，我们在ios平台下布局，使用rem单位，所以直接用原始宽度，不用减半</li></ul></blockquote></li><li><p>swiper</p><blockquote><ul><li>引入<code>swiper-bundle.min.js</code>和<code>swiper-bundle.min.css</code>文件</li><li>添加HTML内容，删掉不需要用到的</li><li>给Swiper定义一个大小,swiper-6.8.4下，容器名是<code>swiper-container</code></li><li>初始化Swiper，删掉不需要用到的</li><li>设置slider容器能够同时显示的slides数量<code>slidesPerView: &#39;数字/auto&#39;</code></li><li>给容器设置一个id名，根据id名修改样式。每一个swoper对应一个id名</li></ul></blockquote></li><li><p>要实现图片自适应缩放，必须要给它加宽&#x2F;高</p></li></ol>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 移动端 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Flex布局和Grid布局</title>
      <link href="/2023/11/30/Flex%E5%B8%83%E5%B1%80%E5%92%8CGrid%E5%B8%83%E5%B1%80/"/>
      <url>/2023/11/30/Flex%E5%B8%83%E5%B1%80%E5%92%8CGrid%E5%B8%83%E5%B1%80/</url>
      
        <content type="html"><![CDATA[<span id="more"></span><h2 id="Flex布局"><a href="#Flex布局" class="headerlink" title="Flex布局"></a>Flex布局</h2><h3 id="一、基本概念"><a href="#一、基本概念" class="headerlink" title="一、基本概念"></a>一、基本概念</h3><ol><li><p>简介</p><blockquote><ul><li>布局的传统解决方案，基于盒子模型，依赖display属性+position属性。它对于那些特殊布局非常不方便，比如垂直居中就不容易实现</li><li>2009年，W3C提出了一种新的方案：Flex布局，可以简便、完整、响应式地实现各种布局页面。目前，他已经得到了所有浏览器的支持，这意味着，现在就能很安全地使用这项功能，Flex布局将成为未来布局的首选方案</li></ul></blockquote></li><li><p>什么是flex布局？</p><blockquote><ul><li>flex(flexible box)，意为“弹性的盒子”，flex布局也称为flex弹性布局</li><li>任何一个HTML元素都可以指定为flex布局</li><li>flex布局是一种&#x3D;&#x3D;一维的&#x3D;&#x3D;布局模型，它给flexbox的子元素之间提供了强大的空间分布和对齐能力</li><li>之所以说flexbox是一种一维布局，是因为一个flexbox一次只能处理一个维度上的元素布局，一行或一列</li><li>在flex布局中，项目的float、clear和verticla-align属性将失效</li></ul></blockquote></li><li><p>什么是flex容器(flex container)？</p><blockquote><ul><li>凡是采用flex布局的元素，就称为flex容器</li><li>也就是设置了<code>display:flex;</code>或<code>display:inline-flex;</code>的元素称之为flex容器</li><li>布局有两种<ul><li><code>display:flex;</code>弹性布局，元素自身以块级元素显示</li><li><code>display:inline-flex</code>弹性布局，元素自身以行内块元素显示</li></ul></li></ul></blockquote></li><li><p>什么是flex项目(flex item)？</p><blockquote><ul><li>flex容器的所有子元素(仅指直接子元素，不包括孙元素及其后代的子元素)，自动成为容器成员，称为flex项目</li></ul></blockquote></li><li><p>什么是主轴，什么是交叉轴？</p><blockquote><ul><li>默认情况下，水平方向是主轴，垂直于主轴方向上的是交叉轴</li><li>flex项目默认沿主轴方向开始排列(即从左往右沿水平方向排列)</li><li>主轴的开始位置(与边框的交叉点)叫做<code>main start</code>，结束位置叫做<code>main end</code></li><li>交叉轴的开始位置叫做在<code>cross start</code>，结束位置叫做<code>cross end</code></li><li><strong>单个</strong>flex项目占据的主轴空间叫做<code>main size</code>(主轴尺寸)，占据的交叉轴空间叫做<code>cross size</code>(交叉尺寸)<img src="flex主轴交叉轴.png"></li></ul></blockquote></li><li><p>flex项目的默认表现形式</p><blockquote><p><strong>当flex容器和flex项目没有添加任何相关属性时，&#x3D;&#x3D;flex项目&#x3D;&#x3D;的默认表现形式如下：</strong></p><ul><li>子元素(项目)排列为一行(<code>flex-direction</code>属性的初始值是<code>row</code>)</li><li>子元素(项目)从主轴的起始线开始排列</li><li>子元素(项目)不会在主维度方向拉伸(放得下时不会拉伸)，但放不下时会缩小</li><li>子元素(项目)默认为行内块元素，不独占一行，但可以设置宽高；若没有设置宽度，则<strong>宽度</strong>由内容撑起</li><li>子元素(项目)没有设置高度时，被拉伸来填充交叉轴大小(单行时项目的高度等于容器高)</li><li><code>flex-basis</code>属性为<code>auto</code>(即元素的宽为自动)</li><li><code>flex-wrap</code>属性为<code>nowrap</code>(子项默认放不下时，不会<strong>换行</strong>)</li></ul></blockquote></li></ol><blockquote><p><strong>display:flex;</strong></p><ul><li>flex容器为块级元素，若没有设置宽高，则<strong>宽度</strong>自动填充父元素的宽度，<strong>高度</strong>由内容撑起</li></ul></blockquote><blockquote><p><strong>display:inline-flex;</strong></p><ul><li>flex容器为行内块元素，不独占一行，但可以设置宽高；若没有设置宽高，则<strong>宽高</strong>都由内容撑起</li></ul></blockquote><h3 id="二、flex容器属性"><a href="#二、flex容器属性" class="headerlink" title="二、flex容器属性"></a>二、flex容器属性</h3><ol><li><p>flex-direction设置主轴方向</p><blockquote><ul><li>默认主轴方向就是x轴，水平向右</li><li>默认交叉轴就是y轴，垂直向下<br><code>flex-direction:row;</code><table><thead><tr><th>属性值</th><th>说明</th></tr></thead><tbody><tr><td>row</td><td>(默认值)主轴为水平方向，起点在左端。(交叉轴在垂直方向，起点在元素上边框位置)</td></tr><tr><td>row-reverse</td><td>主轴为水平方向，起点在右端。(交叉轴在垂直方向，起点在元素上边框位置)</td></tr><tr><td>column</td><td>主轴在垂直方向，起点元素在上边框位置(交叉轴在水平方向，起点在左端)</td></tr><tr><td>column-reverse</td><td>主轴在垂直方向，起点在下沿(交叉轴在水平方向，起点在左端)</td></tr></tbody></table></li></ul></blockquote></li><li><p>flex-wrap项目如何换行</p><blockquote><ul><li>默认情况下，项目都在一条线上(轴线)上排列</li><li><code>flex-wrap</code>属性用来定义：如果项目在一条轴线上排不下时，如何换行<br><code>flex-wrap:nowrap;</code><table><thead><tr><th>属性值</th><th>说明</th></tr></thead><tbody><tr><td>nowrap</td><td>不换行(默认)</td></tr><tr><td>wrap</td><td>换行，第一行在上方(或第一列左边)</td></tr><tr><td>wrap-reverse</td><td>换行，第一行在下方(或第一列右边)</td></tr></tbody></table></li></ul></blockquote></li></ol><blockquote><table><thead><tr><th>主轴属性</th><th>主轴方向</th><th>wrap效果</th><th>wrap-reverse效果</th></tr></thead><tbody><tr><td><code>flex-direction:row;</code></td><td>水平，从左至右</td><td>第二行从上到下、从左至右排列</td><td>第二行从下到上、从左至右排列</td></tr><tr><td><code>flex-direction:row-reverse;</code></td><td>水平，从右到左</td><td>第二行从上到下、从右至左排列</td><td>第二行从下到上、从右到左排列</td></tr><tr><td><code>flex-direction:column;</code></td><td>垂直，从上到下</td><td>第二列从左到右、从上到下排列</td><td>第二列从右到左、从上到下排列</td></tr><tr><td><code>flex-direction:column-reverse;</code></td><td>垂直，从下到上</td><td>第二列从左到右、从下到上排列</td><td>第二列从右到左、从下到上排列</td></tr><tr><td><strong>总结：</strong></td><td></td><td></td><td></td></tr></tbody></table><ul><li>wrap：按照交叉轴方向start–&gt;end，主轴start–&gt;end方向换行</li><li>wrap-reverse：按照交叉轴方向end–&gt;start，主轴start–&gt;end方向换行</li><li>因此：wrap-reverse改变的是交叉轴的方向</li></ul></blockquote><ol start="3"><li><p>flex-flow 主轴方向和项目如何换行</p><blockquote><p><code>flex-flow</code>属性是<code>flex-direction</code>和<code>flex-wrap</code>属性的简写形式，默认值为<code>row nowrap</code><br><code>flex-flow:row nowrap;</code>第一个值规定主轴方向，第二个值规定项目如何换行</p></blockquote></li><li><p>justify-content 项目在<strong>主轴</strong>上对齐方式</p><blockquote><p><code>justify-content:flex-start;</code></p><table><thead><tr><th>属性值</th><th>说明</th></tr></thead><tbody><tr><td>flex-start</td><td>(默认值)，向主轴start方向对齐</td></tr><tr><td>flex-end</td><td>向主轴end方向对齐</td></tr><tr><td>center</td><td>居中</td></tr><tr><td>space-between</td><td>两端对齐，项目之间的间隔都相等,两端与项目之间不会有间隔</td></tr><tr><td>space-around</td><td>每个项目两侧的间隔相等。所以，项目之间的间隔比项目与边框的间隔大一倍(相当于加了左右外边距)</td></tr><tr><td>space-evenly</td><td>使每个元素之间和元素距离边距的距离都相等，但iphone的SE上不支持，会失效，基本不用</td></tr></tbody></table></blockquote></li><li><p>align-items 项目在<strong>交叉轴</strong>上对齐方式</p><blockquote><p><code>align-items</code>属性定义项目在<strong>交叉轴</strong>上如何对齐，<strong>只对单行有效</strong><br><code>align-items:stretch;</code></p><table><thead><tr><th>属性值</th><th>说明</th></tr></thead><tbody><tr><td>stretch</td><td>(默认值)：如果项目未设置高度或设为auto，将占满整个容器</td></tr><tr><td>flex-start</td><td>与交叉轴的起点对齐</td></tr><tr><td>flex-end</td><td>与交叉轴的终点对齐</td></tr><tr><td>center</td><td>与交叉轴的中点对齐</td></tr><tr><td>baseline</td><td>向项目的第一行文字的X的中间对齐</td></tr></tbody></table></blockquote></li></ol><blockquote><p><strong>注意</strong></p><ul><li>默认情况下，项目如果没有设置高度或设为auto，其高度会自动拉伸到容器高度。<strong>原因是：</strong><code>align-items:stretch;</code>为默认值。</li><li><strong>但是在其他几种情况下</strong>(即align不为stretch时)，项目未设置高度，其高度就为内容大小，并不会拉伸。</li></ul></blockquote><blockquote><p><strong>当主轴放不下，允许换行时</strong></p><ul><li>当项目放不下，换行时，可以把每一行看做一个”新的flex容器”</li><li><code>align-items</code>控制项目在”每一个容器”的交叉轴上的对齐方式</li><li>行与行之间的间隔高度是相等的，由于每一行的最高项目高度不一样，所以每一个”新容器”所占高度也不一样</li><li>当前行容器占的高度&#x3D;当前行最高元素的高+行与行之间的间隔&#x3D;当前行最高元素的高+(容器高-每一所有行最高元素的高)&#x2F;行数</li></ul></blockquote><ol start="6"><li>align-content 多根轴线对齐方式(多行)<blockquote><p>该属性规定了<strong>多根轴线</strong>在<strong>交叉轴</strong>上的对齐方式<br>如果项目只有一根轴线，该属性不起作用(允许换行)</p><table><thead><tr><th>属性值</th><th>说明</th></tr></thead><tbody><tr><td>stretch</td><td>(默认值)：轴线占满整个交叉轴</td></tr><tr><td>flex-start</td><td>与交叉轴的起点对齐</td></tr><tr><td>flex-end</td><td>与交叉轴的终点对齐</td></tr><tr><td>center</td><td>与交叉轴的中点对齐</td></tr><tr><td>space-between</td><td>两端对齐，与交叉轴两端对齐，轴线之间的间隔平均分布</td></tr><tr><td>space-around</td><td>每个轴线两侧的间隔都相等(每行加外边距)。所以，轴线之间的间隔比轴线与边框的间隔大一倍</td></tr></tbody></table></blockquote></li></ol><blockquote><p><strong>注意！！！</strong><br>可换行时，<code>align-items</code>与<code>align-content</code>的区别</p><ul><li><code>align-items</code>控制单行，因此每行都是一个”新容器”，<code>align-items</code>控制每个新容器内项目在交叉轴上的对齐方式，每个容器之间都有等高的间隔</li><li><code>align-content</code>同时控制多行<ul><li>使用<code>stretch</code>、<code>space-between</code>、<code>space-around</code>时，每行的高度等于当前行最高的项目高度+等高的行间隔,</li></ul></li><li>使用<code>flex-start</code>、<code>flex-end</code>、<code>center</code>时，行与行之间没有间隔，统一成”一个容器”</li></ul></blockquote><h3 id="三、flex项目属性"><a href="#三、flex项目属性" class="headerlink" title="三、flex项目属性"></a>三、flex项目属性</h3><blockquote><table><thead><tr><th>属性名</th><th>说明</th></tr></thead><tbody><tr><td>order</td><td>属性定义项目的排列顺序。数值越小，排列越靠前，默认为 0</td></tr><tr><td>align-self</td><td>单个项目有与其他项目不一样的对齐方式，可覆盖<code>align-items</code>属性,默认值为auto，表示继承父元素的<code>align-items</code>属性，如果没有父元素，则等同于<code>stretch</code>。</td></tr><tr><td>flex-grow</td><td>flex项<strong>主尺寸</strong>的flex增长系数。默认为0，即如果存在剩余空间，也不放大。</td></tr><tr><td>flex-shrink</td><td>flex项<strong>主尺寸</strong>的缩小比例，默认为1，即如果空间不足，该项目将缩小。</td></tr><tr><td>flex-basis</td><td>定义了在分配多余空间之前，项目占据的主轴空间（main size）</td></tr><tr><td>flex</td><td>flex属性是flex-grow, <code>flex-shrink</code>和<code>flex-basis</code>的简写默认值为:0 1 auto。后两个属性可选</td></tr></tbody></table></blockquote><ol><li><p>order项目的排列顺序</p><blockquote><ul><li><code>order</code>属性定义项目的排列顺序</li><li><code>order</code>属性值<code>&gt;0</code>的整数，数值越小，排列越靠前，默认为0<br><code>order:1;</code></li></ul></blockquote></li><li><p>align-self 单个项目交叉轴对齐方式</p><blockquote><ul><li><code>align-self</code>属性允许单个项目有与其他项目不一样的对齐方式，可覆盖<code>align-items</code>属性</li><li><code>align-self</code>的默认值为<code>auto</code>，表示继承父元素的<code>align-items</code>属性</li><li>如果父元素没有设置<code>align-items</code>属性，则等同于<code>stretch</code>(项目未设置高度时)</li><li><code>align-self:flex-start;</code><table><thead><tr><th>属性值</th><th>说明</th></tr></thead><tbody><tr><td>auto</td><td>默认值，表示继承父元素的<code>align-items</code>属性，如果没有父元素，则等同于<code>stretch</code></td></tr><tr><td>stretch</td><td>如果项目未设置高度或设为<code>auto</code>，将占满整个容器的高度</td></tr><tr><td>flex-start</td><td>交叉轴的起点对齐</td></tr><tr><td>flex-end</td><td>交叉轴的终点对齐</td></tr><tr><td>center</td><td>交叉轴的中点对齐</td></tr><tr><td>baseline</td><td>项目的第一行文字的基线对齐</td></tr></tbody></table></li><li>当项目换行时，其<code>align-self</code>单个项目对齐方式，是相当于其所在的哪一行的轴线而言</li><li>在今日头条案例中，用到<code>align-self:flex-start;</code>，使行内块元素宽度不占满整行(不设宽度时)</li></ul></blockquote></li><li><p>flex-grow 项目主轴放大系数</p><blockquote><ul><li><code>flex-grow</code>设置flex项目<strong>主尺寸</strong>的flex增长系数</li><li>主尺寸是项目的宽度或高度，这取决于<code>flex-direction</code>值</li><li><code>flex-grow</code>属性，在flex容器有剩余空间时生效</li><li><code>剩余空间=flex容器宽大小-所有flex项目宽加起来的大小</code><blockquote><p>注：剩余空间的值一定要大于0的</p></blockquote></li><li><code>flex-grow</code>默认值为0，表示即使有剩余空间，也不增长(放大)</li><li><code>flex-grow</code>的值&gt;&#x3D;0的数字</li></ul></blockquote></li></ol><blockquote><p><strong>项目放大后尺寸计算方式</strong></p><ul><li>当所有项目的<code>flex-grow</code>值的总结加<code>&lt;1</code>时<ul><li>项目放大后宽 &#x3D; 项目原始宽 + 剩余空间*项目的<code>flex-grow</code>值</li></ul></li><li>当所有项目的<code>flex-grow</code>值的总和加起来<code>&gt;=1</code>时<ul><li>项目放大后宽&#x3D;项目原始宽+剩余空间*(flex-grow值)&#x2F;所有项目的flex-grow值总和</li></ul></li><li>当flex容器的剩余空间为0时，不管flex项目的<code>flex-grow</code>的值是多少，项目都不会放大(因为没有多余空间)</li></ul></blockquote><ol start="4"><li>flex-shrink项目主轴上缩放系数<blockquote><ul><li><code>flex-shrink</code>属性指定了flex元素的收缩规则</li><li>当所有项目宽度大于容器的时候才会收缩(默认主轴为水平方向)</li><li>flex项目收缩的大小是依据所有项目的<code>flex-shrink</code>值决定的</li><li><code>flex-shrink</code>的默认值为1，表示容器空间不足时，所有项目等比缩小</li><li>只有当flex容器设置了<code>flex-grow:nowrap;</code>时，才能看到效果</li><li>当<code>flex-shrink:0;</code>时，无论如何不缩放</li></ul></blockquote></li></ol><blockquote><p><strong>项目收缩后尺寸大小计算方式</strong></p><ul><li>当flex-shrink总和&lt;1时<ul><li><ol><li>计算溢出宽 &#x3D;所有项目宽之和-容器宽</li></ol></li><li><ol start="2"><li><strong>计算所有子项的总缩放宽 &#x3D;溢出宽</strong></li></ol></li><li><ol start="3"><li>当前项目缩放比例 &#x3D;(当前项目原始宽<code>*</code>flex-shrink值)&#x2F;所有项目(宽<code>*``flex-shrink</code>值)之和</li></ol></li><li><ol start="4"><li>项目收缩宽&#x3D;所有子项的总缩放宽<code>*</code>当前项目缩放比例</li></ol></li><li><ol start="5"><li>项目收缩后宽&#x3D;原始宽-收缩宽</li></ol></li></ul></li><li>当flex-shrink总和&gt;&#x3D;1时<ul><li><ol><li>计算溢出宽 &#x3D;所有项目宽之和-容器宽</li></ol></li><li><ol start="2"><li>计算所有子项的总缩放宽 &#x3D;溢出宽<code>*</code>所有项目<code>flex-shrink</code>值之和</li></ol></li><li><ol start="3"><li>当前项目缩放比例 &#x3D;(当前项目原始宽<code>*</code>flex-shrink值)&#x2F;所有项目(宽<code>*``flex-shrink</code>值)之和</li></ol></li><li><ol start="4"><li>项目收缩宽&#x3D;所有子项的总缩放宽<code>*</code>当前项目缩放比例</li></ol></li><li><ol start="5"><li>项目收缩后宽&#x3D;原始宽-收缩宽<blockquote><p>注：当项目的搜索框&gt;项目原始宽时，此计算方式无效</p></blockquote></li></ol></li></ul></li></ul></blockquote><ol start="5"><li><p>flex-basis分配剩余空间前，项目占据主轴空间大小(main size)</p><blockquote><ul><li><code>flex-basis</code>属性定义了<strong>在分配多余空间之前</strong>，项目占据的主轴空间</li><li>浏览器根据这个属性聚酸主轴是否有多余空间</li><li>它的默认值为<code>auto</code>，即项目的本来大小(如果有with，则缩放以width为参考)</li><li><code>flex-basis</code>的优先级要高于<code>width</code></li><li>特殊：<code>flex-basis:0%;</code>元素宽为0；</li></ul></blockquote></li><li><p>flex项目放大、缩小、空间占据</p><blockquote><ul><li><code>flex</code>属性是<code>flex-grow</code>、<code>fleex-shrink</code>和<code>flex-basis</code>的缩写</li><li>默认值为<code>0 1 auto</code>，也就是不放大，等比缩放，占主轴宽度为auto</li><li>特殊<ul><li><code>flex:auto;</code>：<code>flex:1 1 auto;</code></li><li><code>flex:none;</code>：<code>flex:0 0 auto;</code></li><li><code>flex:1</code>：<code>flex:1 1 0%;</code></li></ul></li></ul></blockquote></li></ol><h3 id="四、flex实战"><a href="#四、flex实战" class="headerlink" title="四、flex实战"></a>四、flex实战</h3><ol><li><p>元素水平垂直居中</p><blockquote><ul><li>弹性布局:<code>display:flex;</code></li><li>水平居中:<code>jusity-content:center;</code></li><li>垂直居中:<code>align-items:center;</code>.(不同情况下还可以使用<code>align-content</code>和<code>align-self</code>)</li></ul></blockquote></li><li><p>画骰子</p><blockquote><ul><li>1~6点</li></ul></blockquote></li><li><p>双飞翼布局</p><blockquote><ul><li>左右固定，中间自适应，最中间的内容放在第一位，有利于SEO搜索引擎优化</li><li>注意点<ul><li>容器设置<code>display:flex;</code>使项目以弹性布局方式排列</li><li>中间的项目写在最上面，但利用<code>order</code>改变排版顺序</li><li>中间的项目设置<code>flex-grow:1;</code>：使中间项目的充分占据容器剩余空间</li><li>左右项目固定宽度，<code>flex-grow</code>默认为0，因此不会分配容器的剩余空间</li></ul></li></ul></blockquote></li><li><p>flex怎么实现盒子1在最左边，23在最右边</p></li><li><p>星级评估</p><blockquote><ul><li>利用后续兄弟元素选择器，把主轴方向调转</li><li>伪元素实现实心星星：代码<code>content=&quot;\2605&quot;</code></li><li><code>hover</code>鼠标滑动变色</li></ul></blockquote></li><li><p>如何解决 flex 布局 7 个元素使用 space-between 最后一行两边分布的问题？</p><blockquote><ul><li>如果我们每一行显示的个数为 n，那我们可以最后一行子项的后面加上 n-2 个 span 元素，span 元素的宽度和其它子项元素宽度一样，但不用设置高度,高度设置为0,不对其他元素产生影响。</li><li><strong>为什么是添加n-2个span元素呢 ？</strong><ul><li>当最后一行只有 1 个子元素时，他会默认靠左，不用处理</li><li>当最后一行子元素正好时，我们就不用关心这个问题</li></ul></li></ul></blockquote></li></ol><h2 id="Grid布局"><a href="#Grid布局" class="headerlink" title="Grid布局"></a>Grid布局</h2><h3 id="一、基本概念-1"><a href="#一、基本概念-1" class="headerlink" title="一、基本概念"></a>一、基本概念</h3><ol><li><p>什么是网格布局</p><blockquote><ul><li>grid网格布局是将容器分成了行和列，产生单元格，然后指定<strong>项目</strong>所在的单元格，可以看做是二维布局</li><li>grid比flex更加强大，flex更适合处理一维布局<img src="grid.png"></li></ul></blockquote></li><li><p>什么是grid容器和项目</p><blockquote><ul><li>与flex布局一样，采用网格布局的区域称为容器，其直接子元素称为项目</li><li>通过给元素添加<code>display:grid;</code>或<code>display:inline-grid;</code>来指定元素为grid网格布局<ul><li><code>display:grid;</code>元素自身以块级元素显示</li><li><code>display:inline-grid;</code>元素自身以行内块元素显示</li></ul></li><li>任何元素都可以指定为grid网格布局</li></ul></blockquote></li><li><p>什么是行、列、单元格</p><blockquote><ul><li>容器里面的水平区域称为行，垂直区域称为列</li><li>行和列交叉形成区域，称为单元格(cell)</li><li>正常情况下，<code>n</code>行和<code>m</code>列会产生<code>n*m</code>个单元格</li></ul></blockquote></li><li><p>什么是网线格</p><blockquote><ul><li>划分网格的线，称为”网线格”</li><li>水平网格线划分出行，垂直网格线划分出列</li><li>正常情况下,n行有<code>n+1</code>根水平网格线，m列有<code>m+1</code>根垂直网格线</li></ul></blockquote></li><li><p>什么是网格轨道</p><blockquote><ul><li>网格轨道是两条网格线之间的空间<img src="网格轨道.png"></li></ul></blockquote></li><li><p>什么是网格区域</p><blockquote><ul><li>网格区域是由网格中一个或多个单元格组成的一个矩形区域，有点类似与表格中的合并</li><li>也就是说，我们把grid容器划分成对应单元格后，可以对这些单元格做合并操作<img src="网格区域.png"></li></ul></blockquote></li><li><p>什么是网格间距</p><blockquote><ul><li>网格间距分为行间距和列间距</li><li>行与行的间隔，被称为行间距，列与列的间隔，被称为列间距。具体如下图所示<img src="网格间距.png"></li></ul></blockquote></li><li><p>什么是网格内容区域</p><blockquote><ul><li>Grid 容器的每一个子元素，被称为 Grid 项目。所有 Grid 项目看成一个整体，这个整体我们称为网格内容。<img src="网格内容.png"></li></ul></blockquote></li></ol><h3 id="二、grid-容器-属性"><a href="#二、grid-容器-属性" class="headerlink" title="二、grid&#x3D;&#x3D;容器&#x3D;&#x3D;属性"></a>二、grid&#x3D;&#x3D;容器&#x3D;&#x3D;属性</h3><blockquote><ul><li>当元素设置网格布局以后，项目的<code>float</code>、<code>display:inline-block</code>、<code>display:table-cell</code>、<code>vertical-align</code>、<code>column-*</code>等设置都将失效</li></ul></blockquote><ol><li>grid-template-rows、grid-template-columns属性<blockquote><p><strong>tips：</strong></p><ul><li><code>grid-template-rows</code>定义行及行高</li><li><code>grid-template-columns</code>定义列及列宽</li></ul></blockquote></li></ol><blockquote><p><strong>单位</strong></p><ol><li>绝对单位长度px</li></ol><ul><li>每行行高都是100px：<code>grid-template-rows:100px 100px;</code></li><li>每列列宽都是200px：<code>grid-template-column:200px 200px;</code></li></ul><ol start="2"><li>百分比单位</li></ol><ul><li>以容器宽高为基础。&#96;width:200px height:300px;</li><li><code>grid-template-rows:30% 70%;</code><ul><li>行高分别为：<code>300*30%</code> <code>300*70%</code>;</li></ul></li><li><code>grid-template-column:40% 60%;</code><ul><li>列宽分别为：<code>200*40%</code> <code>200*60%</code>;</li></ul></li></ul><ol start="3"><li>fr关键词</li></ol><ul><li><code>fr</code>关键字(fraction的缩写，片段)，表示比例关系</li><li>所有行&#x2F;列都用fr单位，则：<ul><li>每列宽&#x3D;容器宽 * (当前列fr值&#x2F;所有列fr值总和)</li><li>每行高&#x3D;容器高 * (当前列fr值&#x2F;所有列fr值总和)</li></ul></li><li>与绝对长度的单位结合使用,fr单位的行&#x2F;列，表示的是按比例分配剩余空间</li></ul></blockquote><blockquote><p><strong>repeat()函数</strong></p><ul><li>简化重复值</li><li>包括两个参数：repeat(重复次数，所重复的值)</li></ul><pre><code>/* 定义行，3行的行高都是100px */grid-template-rows: repeat(3, 100px);/* 定义了6行，第1，4行的高为50px 第2，5行的高为100px，第3，6行的高为80px */grid-template-rows: repeat(2, 50px 100px 80px);</code></pre></blockquote><blockquote><p><strong>auto-fill关键字</strong></p><ul><li>有时，单元格的大小是固定的，但是容器的大小不确定，如果希望每一行（或每一列）容纳尽可能多的单元格，这时可以使用auto-fill关键字表示自动填充。</li><li><code>grid-template-columns: repeat(auto-fill, 100px);</code><ul><li>意思是每列宽度为100px，列数自动填充</li></ul></li></ul></blockquote><blockquote><p><strong>minmax</strong><br><code>minmax()</code>函数产生一个长度范围，表示长度就在这个范围内</p><ul><li>&#96;minmax(最小值,最大值)</li><li>可以与px、fr、百分比混用</li></ul></blockquote><blockquote><p><strong>auto关键词</strong></p><ul><li>auto关键词表示(列宽&#x2F;行高)由浏览器自己决定</li><li>auto 表示当对应单元格中的元素（如 div）在未设置宽度时，当前列宽为自动计算的宽</li><li>情况一：</li></ul><pre><code>容器设置：grid-template-columns: 100px auto 100px;而且auto对应的第二个项目**未设置列宽**</code></pre><ul><li>表示第二个单元格宽度自适应</li><li>情况二</li></ul><pre><code>容器设置：grid-template-columns: 100px auto 100px;而且auto对应的第二个项目**设置了列宽**</code></pre><ul><li>若item2的宽度<strong>大于</strong>单元格自动计算的宽，则单元格宽度由对应项目决定</li><li>若item2的宽度<strong>小于</strong>单元格自动计算的宽，则单元格宽度以自动计算的为主</li></ul></blockquote><blockquote><p><strong>网格线的名称</strong></p><ul><li>使用方括号，指定每一根网格线的名字，方便以后的引用。</li><li><code>grid-template-rows: [a1] 200px [a2];</code></li><li>需要注意的是n行有<code>n+1</code>条网格线</li></ul></blockquote><ol start="2"><li><p>row-gap、column-gap、gap属性</p><blockquote><table><thead><tr><th>属性名</th><th>说明</th></tr></thead><tbody><tr><td>row-gap</td><td>设置行与行的间隔(行间距)</td></tr><tr><td>column-gap</td><td>设置列与列的间距(列间距)</td></tr><tr><td>gap</td><td>是<code>row-gap</code>和<code>column-gap</code>的合并简写形式</td></tr></tbody></table><ul><li>属性值单位是绝对单位px或百分比</li><li>百分比单位是网格容器的百分比</li><li>gap后如果只写一个值，表示列间距和行间距一样大小</li></ul></blockquote></li><li><p>grid-template-areas属性</p><blockquote><ul><li>grid-template-areas属性用于指定<strong>网格区域</strong>，一个区域由单个或多个单元格组成</li><li>这个属性需要配合项目属性<code>grid-area</code>一起使用</li><li><code>grid-area:区域名</code>用于指定grid项目放在哪个区域</li><li>不需要利用的区域，则使用点<code>.</code>表示</li><li>区域的命名会影响到网格线，每个区域的起始网格线，会自动命名为<code>区域名-start</code>；终止网格线自动命名为<code>区域名-end</code></li><li>注意：”合并单元格”时，所形成的区域必须是矩形</li><li>使用方法：</li></ul><pre><code>.container&#123; grid-template-areas:&quot;a a c&quot;&quot;a a f&quot;&quot;g h i&quot;;  &#125;.grid-item1 &#123; /* 将项目放在区域a中 */ grid-area: a; background-color: skyblue;  &#125;</code></pre></blockquote></li><li><p>grid-auto-flow属性</p><blockquote><ul><li>它决定了项目在容器中的排列顺序，是”先行后列”，还是”先列后行”<table><thead><tr><th>属性值</th><th>说明</th></tr></thead><tbody><tr><td>row</td><td>默认值，即先行后列，即项目默认从左往右，先天满第一行，再开始第二行</td></tr><tr><td>column</td><td>先列后行，即项目先从上往下填满第一列，再开始放第二列</td></tr><tr><td>row dense</td><td>某些项目指定位置以后，剩下的项目怎么自动放置。表示**”先行后列”**，并且尽可能紧密填满，尽量不出现空格</td></tr><tr><td>column dense</td><td>某些项目指定位置以后，剩下的项目怎么自动放置。表示**”先列后行”**，并且尽量填满空格</td></tr></tbody></table></li></ul></blockquote></li><li><p>grid-auto-columns和grid-auto-rows属性</p><blockquote><p><strong>什么是显示网格：</strong></p><ul><li>使用<code>grid-template-columns</code>和<code>grid-auto-rows</code>指定尺寸创建出来行和列形成的网格<br><strong>什么是隐藏网格</strong></li><li>是自动布局算法创建的额外的行或列形成的网格</li></ul></blockquote></li></ol><blockquote><ul><li><code>grid-auto-columns</code>：隐式创建的网格<strong>纵向</strong>轨道(track)的宽度。即设置隐式网格的<strong>宽度</strong></li><li><code>grid-auto-rows</code>：用于指定隐式创建的<strong>行</strong>轨道大小。即设置隐式网格的<strong>高度</strong></li><li><code>grid-auto-columns</code>与<code>grid-auto-rows</code>的写法与<code>grid-template-columns</code>和<code>grid-template-rows</code>完全相同。</li><li>但是！<code>grid-auto-columns</code>与<code>grid-auto-rows</code>不支持<code>repeat</code>写法</li><li>如果不指定<code>grid-auto-columns</code>与<code>grid-auto-rows</code>这两个属性，浏览器完全根据<strong>单元格内容的大小</strong>，决定新增网格的列宽或行高。</li><li>只有在“先行后列”：<code>grid-auto-flow:row;</code>的情况下，设置隐式行高<code>grid-auto-rows</code>才有用，此时的隐式列宽由<code>grid-template-columns</code>决定</li><li>类似的，只有在“先列后行”时，设置隐式列宽才有效；而隐式行高由<code>grid-template-rows</code>决定</li></ul></blockquote><ol start="6"><li><p>justify-items属性</p><blockquote><p>用来设置<strong>单元格内容</strong>的水平位置</p><table><thead><tr><th>属性值</th><th>说明</th></tr></thead><tbody><tr><td>stretch</td><td>(默认值)拉伸，占满单元格的整个宽度</td></tr><tr><td>start</td><td>与单元格最左边对齐</td></tr><tr><td>end</td><td>与单元格最右边对齐</td></tr><tr><td>center</td><td>单元格内水平居中对齐</td></tr></tbody></table></blockquote></li><li><p>align-items属性</p><blockquote><p>用来设置<strong>单元格内容</strong>的垂直对齐方式</p><table><thead><tr><th>属性值</th><th>说明</th></tr></thead><tbody><tr><td>stretch</td><td>(默认值)拉伸，占满单元格的整个高度</td></tr><tr><td>start</td><td>与单元格最上边对齐</td></tr><tr><td>end</td><td>与单元格最下边对齐</td></tr><tr><td>center</td><td>与单元格内垂直居中对齐</td></tr></tbody></table></blockquote></li><li><p>place-items属性</p><blockquote><p>它是<code>align-items</code>和<code>justify-items</code>属性的<strong>合并简写</strong>属性</p><ul><li><code>place-items:(垂直,水平)</code></li><li>如果只写一个值，则相当于两个值一样</li></ul></blockquote></li><li><p>justify-content属性</p><blockquote><p>设置<strong>整个内容区域</strong>在容器里面的<strong>水平</strong>位置</p><table><thead><tr><th>属性名</th><th>说明</th></tr></thead><tbody><tr><td>start</td><td>默认值，对齐容器的<strong>左</strong>边框</td></tr><tr><td>end</td><td>对齐容器的<strong>右</strong>边框</td></tr><tr><td>center</td><td>容器内部<strong>水平居中</strong>。</td></tr><tr><td>stretch</td><td>单元格大小没有指定时，<strong>拉伸</strong>宽占据整个网格容器。</td></tr><tr><td>space-around</td><td>每个项目两侧的间隔相等。所以，项目之间的间隔比项目与容器边框的间隔大一倍。</td></tr><tr><td>space-between</td><td>项目与项目的间隔相等，项目与容器边框之间没有间隔。</td></tr><tr><td>space-evenly</td><td>项目与项目的间隔相等，项目与容器边框之间也是同样长度的间隔。</td></tr></tbody></table><blockquote><p>注意：只有当单元格宽&#x2F;高为<code>auto</code>时，<code>justify-content:stretch;</code>拉伸才会生效</p></blockquote></blockquote></li><li><p>align-content属性</p><blockquote><p>是整个<strong>内容区域</strong>的<strong>垂直</strong>位置</p><table><thead><tr><th>属性名</th><th>说明</th></tr></thead><tbody><tr><td>start</td><td>默认值，对齐容器的起始边框</td></tr><tr><td>end</td><td>对齐容器的结束边框</td></tr><tr><td>center</td><td>容器内容垂直居中。</td></tr><tr><td>stretch</td><td>项目高度没有指定时，项目高度会被拉伸占据整个网格容器。</td></tr><tr><td>space-around</td><td>每个项目两侧的间隔相等。所以，项目之间的间隔比项目与容器边框的间隔大一倍。</td></tr><tr><td>space-between</td><td>项目与项目的间隔相等，项目与容器边框之间没有间隔。</td></tr><tr><td>space-evenly</td><td>项目与项目的间隔相等，项目与容器边框之间也是同样长度的间隔。</td></tr></tbody></table></blockquote></li><li><p>place-content属性</p><blockquote><ul><li><code>place-content</code>属性是<code>align-content</code>属性和<code>justify-content</code>属性的合并简写形式</li></ul></blockquote></li><li><p>grid-template和grid属性</p><blockquote><ul><li><code>grid-template</code>属性是<code>grid-template-rows</code>、<code>grid-template-columns</code>和<code>grid-template-areas</code>这三个属性的合并简写形式。</li><li>只定义行高和列宽<ul><li><code>grid-template:100px 200px/50px 100px;</code></li><li>行高分别为100px和200px，列宽分别为50px和100px</li></ul></li><li>定义行列，同时划分区域</li></ul><pre><code>grid-template:  &quot;a a b&quot; 50px  &quot;a a b&quot; 100px  &quot;c c c&quot; 50px / 100px 100px 100px;  /*定义行列和区域 3行 行高分别为 50px 100px 50px3列 列宽分别为 100px 100px 100px*/</code></pre></blockquote></li></ol><blockquote><ul><li><code>grid</code>属性是<code>grid-template-rows</code>、<code>grid-template-columns</code>、<code>grid-template-areas</code>、 <code>grid-auto-rows</code>、<code>grid-auto-columns</code>、<code>grid-auto-flow</code>这六个属性的合并简写形式。<ul><li>因为过于复杂，实际并不会用这种方式</li></ul></li></ul></blockquote><h3 id="三、grid-项目-的属性"><a href="#三、grid-项目-的属性" class="headerlink" title="三、grid&#x3D;&#x3D;项目&#x3D;&#x3D;的属性"></a>三、grid&#x3D;&#x3D;项目&#x3D;&#x3D;的属性</h3><ol><li>指定项目的位置<blockquote><ul><li>通过指定项目的四个边框的位置，四个边框分别定位在哪根网络线<table><thead><tr><th>属性</th><th>说明</th></tr></thead><tbody><tr><td>grid-column-start</td><td>项目左边框所在的垂直网格线</td></tr><tr><td>grid-column-end</td><td>项目右边框所在的垂直网格线</td></tr><tr><td>grid-row-start</td><td>项目上边框所在的水平网格线</td></tr><tr><td>grid-row-end</td><td>项目下边框所在的水平网格线</td></tr></tbody></table></li></ul></blockquote></li></ol><blockquote><ul><li>当项目只指定了4个属性中的一个，则其他未指定的会采用默认位置，并且一个项目只占一个单元格</li><li>项目的默认位置，由<code>grid-auto-flow</code>属性决定<ul><li>先行后列时，若未明确定位，则被指定项目会按前后顺序排列</li><li>先列后行时，若未明确定位，则被指定项目<strong>高于</strong>其前面的元素</li><li><code>row dense</code>表示 “先行后列”，并且尽可能紧密填满，尽量不出现空格。</li><li><code>column dense</code>表示”先列后行”，并且尽量填满空格</li></ul></li><li>指定方式(可混用)：<ul><li>数字：第几个网格线</li><li>名称：网格线名字</li><li>span关键字：表示跨越，后接数字表示跨越几个网格。不管是star还是end都是从默认的那个单元格开始算</li><li>auto关键字：表示自动放置，自动跨度或默认跨度为1</li></ul></li><li>如果项目发生重叠，通过<code>z-index</code>属性指定项目的重叠顺序</li></ul></blockquote><ol start="2"><li><p>grid-colum、grid-row属性</p><blockquote><ul><li><code>grid-column</code>是<code>grid-column-start</code>和<code>grid-column-end</code>的合并简写形式</li><li><code>grid-row</code>属性是<code>grid-row-start</code>属性和<code>grid-row-end</code>的合并简写形式</li><li>写法：<code>grid-column:1/3;</code>用<code>/</code>分隔</li></ul></blockquote></li><li><p>grid-area属性</p><blockquote><ul><li><code>grid-area</code>属性指定项目放在哪一个区域</li><li>配合<code>grid-template-areas</code>属性一起使用</li><li>特殊用法1：<ul><li><code>grid-area</code>属性还可用作<code>grid-row-start</code>、<code>grid-column-start</code>、<code>grid-row-end</code>、<code>grid-column-end</code>的合并简写形式，直接指定项目的位置。 </li><li><code>grid-area: &lt;row-start&gt; / &lt;column-start&gt; / &lt;row-end&gt; / &lt;column-end&gt;;</code></li><li><code>grid-area:1/2/3/4;</code></li></ul></li><li>特殊用法2(栅格布局)：<ul><li>所谓的栅格布局，你可以简单理解为，要把一个页面或容器(如 div)，分成多少份：<code>grid-template-columns: repeat(12, 1fr);</code></li><li>然后设置其页面或容器中子元素占对应的份数：</li></ul></li></ul><pre><code>.col-3 &#123;   /* 宽为父容器3份宽 */ grid-area: auto/auto/auto/span 3; &lt;!-- 不指定起始线，只规定所跨越的单元格 --&gt;  &#125;</code></pre></blockquote></li><li><p>justify-self、align-self、place-self 属性</p><blockquote><ul><li><code>justify-self</code>设置单元格内容的水平位置</li><li><code>align-self</code>设置单元格内容的垂直位置</li><li><code>place-self</code>是align-self属性和justify-self属性的<strong>合并</strong>简写形式，如果省略第二个值，place-self属性会认为这两个值相等。<br><strong>justify-self 和 align-self 属性的取值相同，都可以是以下 4 个</strong><table><thead><tr><th>属性值</th><th>说明</th></tr></thead><tbody><tr><td>stretch</td><td>默认值，拉伸，占满单元格的整宽或高</td></tr><tr><td>start</td><td>（水平居左或垂直居上）</td></tr><tr><td>end</td><td>（水平居右或垂直居下）</td></tr><tr><td>center</td><td>水平居中，或垂直居中</td></tr></tbody></table></li></ul></blockquote></li></ol><h3 id="四、兼容性查询办法"><a href="#四、兼容性查询办法" class="headerlink" title="四、兼容性查询办法"></a>四、兼容性查询办法</h3><ol><li><p>不同浏览器的私有前缀</p><table><thead><tr><th>私有前缀</th><th>说明</th></tr></thead><tbody><tr><td>-moz-</td><td>火狐等使用 Mozilla 浏览器引擎的浏览器</td></tr><tr><td>-webkit-</td><td>Safari, 谷歌浏览器等使用 Webkit 引擎的浏览器</td></tr><tr><td>-o-</td><td>Opera 浏览器</td></tr><tr><td>-ms-</td><td>IE 浏览器 、Edge 浏览器</td></tr></tbody></table><blockquote><blockquote><p>对于私有属性的顺序要注意，标准写法要写到最后面，兼容性写法放在前面</p></blockquote></blockquote></li><li><p>兼容性查询</p><blockquote><p>查询不同 CSS 属性的兼容性，可以进入地址：<a href="https://caniuse.com/%E6%9F%A5%E8%AF%A2">https://caniuse.com/查询</a></p></blockquote></li></ol><h3 id="五、案例"><a href="#五、案例" class="headerlink" title="五、案例"></a>五、案例</h3><ol><li><p>Grid 网格布局（开发 360 图片展示效果）</p><blockquote><ul><li>grid-area</li><li>grid-column、grid-rows</li></ul></blockquote></li><li><p>小米商城</p><blockquote><ul><li>滑动菜单栏切换商品列表</li><li>在对应的菜单栏的写商品列表</li><li>利用position定位到菜单栏左侧</li><li>每一个商品列表的类名都可以一样，随列表内容而变化</li><li>商品栏宽度随商品数量扩大</li><li>网格布局：先列后行，设置一列六行，隐藏网格的列宽设置成所需列宽</li><li>每行行高为1份，自动生成，列宽固定</li></ul></blockquote></li></ol><blockquote><ul><li>图片与文字垂直对齐</li><li>给单元格设置弹性布局</li><li>利用<code>align-items:center;</code>实现垂直居中</li></ul></blockquote>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Flex Grid </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>项目开发必备基础知识</title>
      <link href="/2023/11/30/%E9%A1%B9%E7%9B%AE%E5%BC%80%E5%8F%91%E5%BF%85%E5%A4%87%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
      <url>/2023/11/30/%E9%A1%B9%E7%9B%AE%E5%BC%80%E5%8F%91%E5%BF%85%E5%A4%87%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/</url>
      
        <content type="html"><![CDATA[<span id="more"></span><h2 id="web前端项目开发规范和最佳实践"><a href="#web前端项目开发规范和最佳实践" class="headerlink" title="web前端项目开发规范和最佳实践"></a>web前端项目开发规范和最佳实践</h2><h3 id="一、CSS发展史与CSS模块划分"><a href="#一、CSS发展史与CSS模块划分" class="headerlink" title="一、CSS发展史与CSS模块划分"></a>一、CSS发展史与CSS模块划分</h3><h4 id="1-HTML的诞生"><a href="#1-HTML的诞生" class="headerlink" title="1. HTML的诞生"></a>1. HTML的诞生</h4><blockquote><p>1991年8月6日，万维网之父蒂姆·伯纳斯·李创建了人类有史以来的第一个网站(即：<a href="http://info.cern.ch),它没有样式,只有文字和图像两种./">http://info.cern.ch)，它没有样式，只有文字和图像两种。</a></p></blockquote><h4 id="2-css的诞生"><a href="#2-css的诞生" class="headerlink" title="2. css的诞生"></a>2. css的诞生</h4><blockquote><p>1994年哈肯·维姆·莱和伯特·波斯共同提出层叠样式表的概念</p><ul><li>css从此成为网页开发的标准之一，对于网页排版印刷、美感、亲和力有着深远的影响和意义</li><li>在这之后两年，W3C的css工作小组(即哈肯·维姆·莱团队)推出了css1.0规范以及后续的迭代版本</li></ul></blockquote><h4 id="3-css的版本"><a href="#3-css的版本" class="headerlink" title="3. css的版本"></a>3. css的版本</h4><blockquote><p>2015年左右，w3c的css工作小组为了能更好的维护和管理css的特性，该组织决定不再以css的版本号比如css1.0、css2.1等方式来管理css，而是将每个css功能特性拆分成独立的功能模块，并且以Level1、Level2、Level3等方式来管理<br>可以通过W3C官网或<a href="https://drafts.csswg.org/%E6%9F%A5%E7%9C%8B%E5%88%B0CSS%E6%A8%A1%E5%9D%97%E7%9A%84%E5%90%84%E7%A7%8DLevel%E7%89%88%E6%9C%AC">https://drafts.csswg.org/查看到CSS模块的各种Level版本</a></p></blockquote><h4 id="4-CSS的研究方向"><a href="#4-CSS的研究方向" class="headerlink" title="4. CSS的研究方向"></a>4. CSS的研究方向</h4><blockquote><p>大体上css的学习可以朝三个方向进行研究</p><ul><li>特效(动画、3D、渐变等)</li><li>工程化(sass、less、postcss等)</li><li>布局(flex、grid、响应式等)</li></ul></blockquote><h3 id="二、CSS文件划分及功能分类"><a href="#二、CSS文件划分及功能分类" class="headerlink" title="二、CSS文件划分及功能分类"></a>二、CSS文件划分及功能分类</h3><h4 id="1-CSS文件划分"><a href="#1-CSS文件划分" class="headerlink" title="1.CSS文件划分"></a>1.CSS文件划分</h4><blockquote><p>在中大型项目中，一般会对CSS进行文件划分，根据文件的性质和用途，大概分为</p><ul><li>公共型样式<ul><li>可命名为<code>global.css</code>或<code>common.css</code>等名字，主要包括网站通用样式编写。例如：重置默认样式reset、网站通用布局、通用模块和元件、通用响应式系统等</li></ul></li><li>特殊型样式<ul><li>特殊型样式主要是根据当前页面来决定的文件，只针对当前页面做出特殊处理的样式，例如只在首页中用到的样式可放置在<code>index.css</code>中，在登录页面中用到的样式可放置在<code>login.css</code>中</li></ul></li><li>皮肤型样式<ul><li>皮肤型样式是针对网站需要皮肤功能时，把颜色、背景等抽离出来放到文件中的形式，例如：<code>theme-orange.css</code></li></ul></li></ul></blockquote><h4 id="2-CSS功能分类"><a href="#2-CSS功能分类" class="headerlink" title="2. CSS功能分类"></a>2. CSS功能分类</h4><blockquote><p>文件中具体包括哪些常见功能呢？</p><ul><li>重置样式</li><li>网站通用布局</li><li>通用模块</li><li>通用元件</li><li>通用响应式系统</li></ul></blockquote><h4 id="3-重置样式"><a href="#3-重置样式" class="headerlink" title="3. 重置样式"></a>3. 重置样式</h4><blockquote><p>主要是去除默认样式和统一不同设备下的表现形态</p><ul><li>通常为<code>Reset CSS</code>和<code>Normalize CSS</code>代码的结合版本</li><li>我们将在接下来的项目开发中把二者结合成为了一个<code>reset.css</code>文件，并在项目中进行使用</li></ul></blockquote><h4 id="4-网站通用布局"><a href="#4-网站通用布局" class="headerlink" title="4. 网站通用布局"></a>4. 网站通用布局</h4><blockquote><p>主要指的是对网站中出现的大块结构进行排版</p><ul><li>例如：PC端中的菜单、内容的左右布局方案；移动端中的头部、列表、尾部的上中下布局方案</li></ul></blockquote><h4 id="5-通用模块"><a href="#5-通用模块" class="headerlink" title="5. 通用模块"></a>5. 通用模块</h4><blockquote><p>指的是网页中可以重复使用的较大整体，比如：</p><ul><li>导航</li><li>登录</li><li>注册</li><li>各种列表</li><li>评论</li><li>搜索等</li></ul></blockquote><h4 id="6-通用元件"><a href="#6-通用元件" class="headerlink" title="6. 通用元件"></a>6. 通用元件</h4><blockquote><p>指的是不可再分的较为小巧的个体，通常被重复使用与各种模块中，比如：</p><ul><li>按钮</li><li>输入框</li><li>loading</li><li>图标等</li></ul></blockquote><h4 id="7-通用响应式系统"><a href="#7-通用响应式系统" class="headerlink" title="7. 通用响应式系统"></a>7. 通用响应式系统</h4><blockquote><p>指的是在不同设备下要实现响应式布局，当满足了某个断点设定后调用的相应变化样式，比如：</p><ul><li>浮动添加</li><li>栅格生效</li><li>显示隐藏</li><li>版心宽度等</li></ul></blockquote><h3 id="三、标签默认样式及清除"><a href="#三、标签默认样式及清除" class="headerlink" title="三、标签默认样式及清除"></a>三、标签默认样式及清除</h3><h4 id="1-标签默认样式"><a href="#1-标签默认样式" class="headerlink" title="1. 标签默认样式"></a>1. 标签默认样式</h4><blockquote><p>一些HTML标签在浏览器中都会有默认样式</p><ul><li>开发时浏览器的默认样式可能会给我们带来多浏览器兼容性问题，影响开发效率，所以解决办法就是一开始就将浏览器的默认样式全部去掉，更准确说是通过重新定义标签样式覆盖浏览器的css默认属性</li><li>还有一种方式是用通配符选择器<code>*</code>，这是一种非常强大、最简单、最安全的方法，但是非常占用资源。</li><li>推荐以下3种Reset CSS学习<ul><li>雅虎 YUI Reset CSS</li><li>CSS Tools:Reset CSS<ul><li>通常在网页开发中，要去掉在这些影响尺寸和位置的默认样式及其他影响布局的默认值，可以参考它</li></ul></li><li>Normalize CSS<ul><li><code>Reset css</code>相对暴力，不管你有没有用，统统重置成一样的效果，而且影响的范围很大</li><li><code>Normalize css</code>比<code>Reset css</code>更加平和</li></ul></li></ul></li></ul><blockquote><p>创造<code>Normalize css</code> 有以下几个目的</p></blockquote><ul><li>保护有用的浏览器默认样式而不是完全去掉他们</li><li>一般化的样式：为大部分HTML元素提供</li><li>修复浏览器自身的bug并保证各浏览器的一致性</li><li>优化CSS可用行政：用一些小技巧</li><li>解释代码：用注释和详细的文档</li></ul></blockquote><h4 id="2-CSS重置样式最佳实践"><a href="#2-CSS重置样式最佳实践" class="headerlink" title="2. CSS重置样式最佳实践"></a>2. CSS重置样式最佳实践</h4><blockquote><p>在接下来的项目开发中，我们会采用<code>Normalize CSS</code>和<code>Reset CSS</code>结合代码，形成一个更加强大的方案。</p></blockquote><h3 id="四、CSS方法论"><a href="#四、CSS方法论" class="headerlink" title="四、CSS方法论"></a>四、CSS方法论</h3><h4 id="1-CSS方法论"><a href="#1-CSS方法论" class="headerlink" title="1. CSS方法论"></a>1. CSS方法论</h4><blockquote><ul><li>CSS方法论是一种面向CSS、由个人和组织设计、已被诸多项目检验且公认有效的最佳实践</li><li>这些方法论都会涉及结构化的命名约定，并且在阻止CSS时可提供相应的指南，从而提升代码的性能、可读性以及可维护性</li></ul></blockquote><h4 id="2-常见的CSS方法论"><a href="#2-常见的CSS方法论" class="headerlink" title="2. 常见的CSS方法论"></a>2. 常见的CSS方法论</h4><blockquote><ul><li>OOCSS</li><li>BEM</li><li>SMACSS</li><li>Atomic CSS</li></ul></blockquote><h5 id="OOCSS"><a href="#OOCSS" class="headerlink" title="OOCSS"></a>OOCSS</h5><blockquote><p>OOCSS(object-oriented css)是指向面对对象的CSS，由Nicole Sullivan在2009年提出，借鉴了面向对象编程的抽象思维</p><ul><li>其核心概念是采用模块化的实现方式，将CSS分解成可复用和继承的对象，也就是将关注点从页面转移到页面内的组件</li><li>包含两条核心原则：<ul><li>结构与皮肤分离，即不要将位置、尺寸等结构属性和字体、颜色等皮肤属性写在一个选择器中</li><li>内容与容器分离，即让对象的行为可预测，避免对位置的依赖，子元素即使离开了容器也应该能正确显示</li></ul></li><li>命名约定：<ul><li>在OOCSS中，类名既要能传递对象的用途，也要有通用性，例如mod、complex、pop等</li><li>如果将CSS类命名的太语义化，如<code>navigation-bar</code>,那么就会将其限制在导航栏，无法应用到网页的其他位置<br><strong>缺点</strong></li><li>虽然样式的粒度变小了，但同时会产生许多充满类的HTML元素</li><li>在避免特殊性冲突时，OOCSS选择的方案是放弃层叠，这样就无法最大程度地利用关系选择器的优势</li><li>为了让类能更通用，在命名时就得弱化语义</li></ul></li></ul></blockquote><h5 id="BEM"><a href="#BEM" class="headerlink" title="BEM"></a>BEM</h5><blockquote><p>国内很多大厂主要采用BEM+SMACSS这两种方法论的结合命名约定<br>BEM(block element modifier)是指块级元素修饰符，BEM分为三个部分：</p><ul><li>块是一个独立实体，最高级抽象，例如菜单、文本框等</li><li>元素是块的组成部分，被包含在块中，无法自成一体，例如菜单项、标题等</li><li>修饰符是块或元素的状态，可更改它们的外观或行为，例如高亮、选中等</li></ul></blockquote><blockquote><p><strong>要求</strong></p><ul><li>BEM中的块、元素和修饰符需要全部小写</li><li>名称中的单词用连字符<code>-</code>分隔</li><li>元素由双下划线<code>__</code>分隔</li><li>修饰符由双连字符<code>--</code>分隔</li><li>注意：块和元素都既不能是HTML元素名或ID，也不依赖其他块或元素</li></ul><pre><code>&lt;style&gt;  .form &#123;  &#125;  .form--theme-xmas &#123;  &#125;  .form__input &#123;  &#125;  .form__submit &#123;  &#125;  .form__submit--disabled &#123;  &#125;&lt;/style&gt;&lt;form class=&quot;form form--theme-xmas&quot;&gt;  &lt;input class=&quot;form__input&quot; type=&quot;text&quot; /&gt;  &lt;input class=&quot;form__submit form__submit--disabled&quot; type=&quot;submit&quot; /&gt;&lt;/form&gt;</code></pre><ul><li>在上面的代码中<ul><li><code>.form</code>是块</li><li><code>.form_input</code>和<code>.form_submit</code>是其元素</li><li><code>.form--theme-xmas</code>是其修饰符</li><li><code>.form__submit--disabled</code>是<code>.form__submit</code>的修饰符<blockquote><p>BEM的核心思想就是用这种命名约定来清晰的表达出类的含义以及其他类之间的关系</p></blockquote></li></ul></li></ul></blockquote><blockquote><p><strong>BEM的缺点</strong> </p><ul><li>BEM与OOCSS一样，也抛弃了层叠，因此也不能挖掘出关系选择器的潜力</li><li>CSS类名可能会比较长而且复杂</li><li>需要完善规则说明文档，否则HTML结构将难以阅读</li></ul></blockquote><h5 id="SMACSS"><a href="#SMACSS" class="headerlink" title="SMACSS"></a>SMACSS</h5><blockquote><p>SMACSS(scalable and modular architecture for css)是指可伸缩及模块化的CSS架构<br>由Jonathan Snook在2011年雅虎工作时提出，他在OOCSS和BEM的基础上添加了五种类别的组件的处理规则，具体如下：</p><ul><li>1、**基础(base)**是为HTML元素定义默认样式，可以包含属性、伪类等选择器</li><li>2、**布局(layout)**会将页面分为几部分，可作为高级容器包含一个或多个模块，例如左右分栏、栅格系统等</li><li>3、**模块(module)**又名对象或块，是可用的模块化部分，例如导航栏、产品列表等</li><li>4、**状态(state)**描述的是任一模块或布局在特定状态下的外观，例如隐藏、激活等</li><li>5、**主题(theme)**也就是换肤，描述了页面的外观，特克修改前面四个类别的样式，例如链接颜色、布局方式<blockquote><p>命名约定：推荐使用前缀来区分布局、模块、状态和主题，如下列</p></blockquote></li><li><code>l-</code>或<code>layout-</code>用作布局的前缀，例如：<code>.l-inline</code></li><li><code>m-</code>或模块自身的命名用作其前缀，例如<code>.m-profile</code>、<code>field</code></li><li><code>is-</code>用作状态的前缀，例如<code>.is-collapsed</code>、<code>.is-active</code></li><li><code>theme-</code>用作主题的前缀，例如：<code>.theme-a-background</code><blockquote><p>注意，由于<code>base</code>规则是直接作用于元素的，因此不需要前缀</p></blockquote></li></ul></blockquote><blockquote><p><strong>共享</strong><br>在实际开发中，不需要局限于某一CSS方法论，很多时候可以结合使用，共享模块化CSS的规则。例如遵循OOCSS的第一条分离原则，BEM的命名约定，以及SMACSS的分类前缀，具体如下所列：</p><ul><li>基础仍旧沿用SMACSS的规则，布局和模块使用SMACSS的前缀</li><li>子元素用双下划线(__)分隔，其状态前缀沿用<code>is-</code></li><li>修饰符也以<code>is-</code>为前缀，与模块组合时用双连字符(–)分隔</li><li>适当层叠，最好保持在一层<blockquote><p>任何软件设计都存在不完美的地方，CSS方法论也一样，比如：命名过长不易维护，HTML不够简洁等；<br>但它的优势也很明显，比如样式不容易冲突，尤其是复杂的样式结构</p></blockquote></li></ul></blockquote><h3 id="五、样式规范"><a href="#五、样式规范" class="headerlink" title="五、样式规范"></a>五、样式规范</h3><blockquote><ul><li>使用<strong>类选择器</strong>，放弃ID选择器：ID在一个页面的唯一性导致了如果以ID为选择器来写CSS，就无法重用。</li><li>命名应简约而不失语义：<strong>反对过长</strong>命名和<strong>没有语义</strong>的命名</li><li>相同语义的不同类命名：直接加数字或字母区分即可</li><li>防止污染和被污染：为了防止后代选择器污染，尽量采用<code>&gt;</code>方式，例如：<code>-m-nav&gt;li</code>，而不是<code>-m-nav li</code></li><li>最后一个值也以分号结尾：通常在大括号结束前的值可以省略分号，但是这样做会对修改、添加和维护工作带来不必要的失误和麻烦</li><li>省略值为0时的单位：为节省不必要的字节同时也方便阅读</li><li>根据属性的重要性按顺序书写：先显示定位布局类属性，后写盒模型等自身属性，最后是文本类及修饰类属性</li><li>CSS需要进行格式化和对齐处理：推荐vscode插件</li></ul></blockquote><h3 id="六、CSS命名规范"><a href="#六、CSS命名规范" class="headerlink" title="六、CSS命名规范"></a>六、CSS命名规范</h3><blockquote><ul><li>见css文件夹中的代码规范文档</li></ul></blockquote><h2 id="CSS还原UI设计"><a href="#CSS还原UI设计" class="headerlink" title="CSS还原UI设计"></a>CSS还原UI设计</h2><blockquote><p><strong>企业前端项目开发的真实流程</strong></p><ul><li>产品经理出原型图</li><li>交给UI设计师根据需求设计UI源文件</li><li>推送至墨刀&#x2F;蓝湖等协作设计开发平台</li><li>给到程序员开发布局网页</li></ul></blockquote><h3 id="一、长度单位与颜色分类"><a href="#一、长度单位与颜色分类" class="headerlink" title="一、长度单位与颜色分类"></a>一、长度单位与颜色分类</h3><h4 id="1-长度"><a href="#1-长度" class="headerlink" title="1. 长度"></a>1. 长度</h4><blockquote><p>CSS中使用的每个属性值都允许拥有一个或一组值</p><ul><li>CSS中有两种长度单位——绝对长度单位和相对长度单位</li></ul></blockquote><blockquote><p><strong>绝对长度单位</strong></p><ul><li>它们与其他任何东西都没有关系<table><thead><tr><th>单位</th><th>名称</th></tr></thead><tbody><tr><td>cm</td><td>厘米</td></tr><tr><td>mm</td><td>毫米</td></tr><tr><td>in</td><td>英寸</td></tr><tr><td>pt</td><td>点</td></tr><tr><td>px</td><td>像素</td></tr></tbody></table><blockquote><p>除px外，其他单位并不常用</p></blockquote></li></ul></blockquote><blockquote><p><strong>相对长度单位</strong></p><ul><li>相对长度单位相对于其他一些东西，比如父元素、视图端口大小</li><li>使用相对单位的好处是，经过一些仔细的规划，可以是文本或其他元素的大小与页面上的其他内容相对应<table><thead><tr><th>单位</th><th>名称</th></tr></thead><tbody><tr><td>em</td><td>在font-size中使用是相对于父元素的字体大小，在其他元素中使用是相对于自身字体的大小</td></tr><tr><td>ex</td><td>字符”x”的高度</td></tr><tr><td>ch</td><td>数字”0”的宽度</td></tr><tr><td>rem</td><td>根元素的字体大小</td></tr><tr><td>lh</td><td>元素的line-height</td></tr><tr><td>vw</td><td>视图宽度的1%</td></tr><tr><td>vh</td><td>视图高度的1%</td></tr><tr><td>vmin</td><td>视图较小尺寸的1%</td></tr><tr><td>vmax</td><td>试图大尺寸的1%</td></tr></tbody></table></li></ul></blockquote><h4 id="2-颜色"><a href="#2-颜色" class="headerlink" title="2. 颜色"></a>2. 颜色</h4><blockquote><ul><li>在css中，相同的颜色值可以在任何额地方使用</li><li>现代计算机的标准颜色系统是24位的，它允许通过不同的红绿蓝通道的组合显示大约1670万种不同的颜色</li></ul></blockquote><blockquote><p><strong>颜色关键词</strong></p><ul><li>颜色单词</li></ul></blockquote><blockquote><p><strong>RGB颜色</strong></p><ul><li>在CSS中，可以使用公式<code>rgb(red,green,blue)</code>将颜色指定为RGB值，每个参数定义到0到255之间的颜色强度</li><li>黑色:rgb(0,0,0)</li><li>白色:rgb(255,255,255)</li></ul></blockquote><blockquote><p><strong>RGBA值</strong></p><ul><li>RGBA颜色值是具有alpha通道的RGB颜色值的扩展，他指定了颜色的不透明度</li><li>RGBA颜色值指定为rgba(red,green,blue,alpha),alpha参数是结余0.0(完全透明)和1.0(完全不透明)之间的数字</li></ul></blockquote><blockquote><p><strong>HEX颜色</strong></p><ul><li>在CSS中，可以使用<code>#rrggbb</code>格式的十六进制指定颜色</li><li>其中rr、gg、bb是介于00和ff之间的十六进制值</li><li><code>#aabbcc</code>可以简写为<code>#abc</code></li></ul></blockquote><blockquote><p><strong>HSL颜色</strong></p><ul><li>在CSS中，可以使用色相、饱和度和明度来指定颜色，格式如<code>hsla(hue,saturation,lightness)</code></li><li>色相(hue)是色轮上从0到360的度数，0是红色，120是绿色，240是蓝色</li><li>饱和度(saturation)是一个百分比值，0%表示灰色阴影，100%是全色</li><li>亮度&#x2F;明度(lightness)也是百分比，0%是黑色，50%是既不明也不暗，100%是白色</li></ul></blockquote><h3 id="二、UI设计图的源文件种类"><a href="#二、UI设计图的源文件种类" class="headerlink" title="二、UI设计图的源文件种类"></a>二、UI设计图的源文件种类</h3><h4 id="1-什么是设计图源文件"><a href="#1-什么是设计图源文件" class="headerlink" title="1. 什么是设计图源文件"></a>1. 什么是设计图源文件</h4><blockquote><p>源文件是可以查看到图片所有的图层、通道、参考线、注解和颜色模式等信息，开发人员通过操作源文件，可以更加方便的控制图片，并快速的获取到图片信息 </p></blockquote><h4 id="2-常见的源文件"><a href="#2-常见的源文件" class="headerlink" title="2. 常见的源文件"></a>2. 常见的源文件</h4><blockquote><ul><li><code>.psd</code>格式源文件通过Photoshop工具制作</li><li><code>.sketch</code>格式源文件，通过<code>sketch</code>工具制作</li><li><code>.xd</code>格式源文件，通过XXD工具制作</li></ul></blockquote><h4 id="3-进行切图处理和信息获取的方式"><a href="#3-进行切图处理和信息获取的方式" class="headerlink" title="3. 进行切图处理和信息获取的方式"></a>3. 进行切图处理和信息获取的方式</h4><blockquote><p><strong>PS获取信息</strong></p><ul><li>打开PS–&gt;窗口–&gt;信息–&gt;通过查看面板获取信息</li><li>修改标尺单位：右击信息面板–&gt;打开面板选项设置<code>鼠标坐标</code>为像素</li><li>尺寸测量方式：<ul><li>矩形选框工具，按shift&#x2F;ctrl来扩大&#x2F;缩小所选中范围</li><li>移动工具：按住ctrl键鼠标触碰到需要量尺寸区尺寸的两个元素的边缘或者选中对应图层即可</li></ul></li><li>颜色值的获取<ul><li>吸管工具：吸取需要元素的颜色，点开拾色器&#x2F;前景色查看不同类型的颜色值</li></ul></li><li>文字相关属性的获取<ul><li>矩形选框工具：选中对应的文字图层–&gt;在字符面板查看即可<br><strong>PS切图</strong></li></ul></li><li>编辑–&gt;首选项–&gt;打开增效工具–&gt;勾选“启用生成器”</li><li>选择移动工具–&gt;点击需要切图的图片–&gt;<strong>修改图层的名字</strong>，并添加常见的<strong>图片后缀</strong>–&gt;按下回车键即可</li><li>在源文件根目录里自动生成了一个文件夹，里面就是所切图片</li><li>切2倍图：修改图层名称时，在名称前添加<code>200% 空格</code></li></ul></blockquote><blockquote><p><strong>蓝湖</strong></p><ul><li>登录蓝湖，下载photoshop插件，安装成功后启动PS–&gt;选择”窗口”–&gt;扩展功能–&gt;选择蓝湖即可</li><li>一般是设计师切图后，把源文件上传至蓝湖，开发者就能在蓝湖查看各种信息、下载素材</li></ul></blockquote><blockquote><p><strong>Pxcook</strong></p></blockquote><blockquote><p><strong>imgcook设计稿智能平台</strong></p><ul><li>网址：<a href="https://www.imgcook.com/">https://www.imgcook.com/</a>(opens new window)</li><li>目前此产品是阿里巴巴前端委员会智能化小组的服务化的内外落地产品</li><li>通过智能化技术一键生成可维护的前端代码</li><li>生成后的代码还是需要根据实际需求调整，在学习阶段可供参考</li></ul></blockquote><h2 id="项目准备"><a href="#项目准备" class="headerlink" title="项目准备"></a>项目准备</h2><blockquote><ul><li>蓝湖打开设计稿</li><li>准备图标库、字体文件夹、图片文件夹</li><li>基础文件：<ul><li>重置样式：global&#x2F;reset.css</li><li>基础样式：base.css</li><li>放样式的文件：index.css</li></ul></li><li>网页文件：index.html<ul><li>搭建网页框架</li><li>引入重置样式、基础样式、其他样式、字体文件</li></ul></li><li>自定义字体<ul><li>先把重置样式文件里设置默认字体的代码注释掉</li><li>在base.css文件里自定义字体,设置body样式<br>-使用@font-face引入字体文件</li></ul></li></ul><pre class=" language-css"><code class="language-css"><span class="token atrule"><span class="token rule">@font-face</span> &amp;#123<span class="token punctuation">;</span></span>  <span class="token property">font-family</span><span class="token punctuation">:</span> <span class="token punctuation">;</span> <span class="token comment" spellcheck="true">/*字体类型*/</span>  <span class="token property">src</span><span class="token punctuation">:</span> <span class="token url">url()</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">/*引入字体文件*/</span>&amp;<span class="token hexcode">#125</span><span class="token punctuation">;</span></code></pre><blockquote><p>注意：ttf文件一定要加<code>format(&quot;ture&quot;)</code></p></blockquote></blockquote>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 基础知识 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CSS核心知识点（三）</title>
      <link href="/2023/11/29/CSS%E6%A0%B8%E5%BF%83%E7%9F%A5%E8%AF%86%E7%82%B9%EF%BC%88%E4%B8%89%EF%BC%89/"/>
      <url>/2023/11/29/CSS%E6%A0%B8%E5%BF%83%E7%9F%A5%E8%AF%86%E7%82%B9%EF%BC%88%E4%B8%89%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<span id="more"></span><h2 id="浮动、BFC规范、清除浮动的最佳实践"><a href="#浮动、BFC规范、清除浮动的最佳实践" class="headerlink" title="浮动、BFC规范、清除浮动的最佳实践"></a>浮动、BFC规范、清除浮动的最佳实践</h2><h3 id="一、实现CSS布局的几种策略"><a href="#一、实现CSS布局的几种策略" class="headerlink" title="一、实现CSS布局的几种策略"></a>一、实现CSS布局的几种策略</h3><blockquote><ul><li><strong>网页布局的本质是</strong>：用CSS来摆放盒子，把盒子摆放到页面对应位置。</li><li>CSS中提供了以下几种不同的CSS<strong>布局策略</strong>，来实现页面的布局<ul><li>正常布局流</li><li>浮动布局</li><li>定位布局</li><li>表格布局(<code>display:table;</code>)</li><li>响应式设计</li><li>弹性布局</li><li>网格布局</li><li>多列布局<blockquote><p>以上每种布局方式，都有自己的用途，也有各自的优缺点，相互辅助；通过理解各个布局方法的设计理念，我们能够找到构建理想网页需要的布局方案</p></blockquote></li></ul></li></ul></blockquote><h3 id="二、正常布局流"><a href="#二、正常布局流" class="headerlink" title="二、正常布局流"></a>二、正常布局流</h3><blockquote><p>概念：</p><ul><li>在不对页面进行任何布局控制时，浏览器默认的HTML布局方式</li><li>正常的布局流就是规定了。在默认情况下块级元素和内联元素的排版方式</li></ul></blockquote><ol><li><p>正常布局流中，块级元素的排列方式</p><blockquote><ul><li>块级盒子会从包含块的顶部开始，按序垂直排列</li><li>同级盒子间的垂直距离会由“margin”属性决定</li><li>相邻两个块级盒子之间的垂直距离会遵循外边距折叠原则</li></ul></blockquote></li><li><p>正常布局流中，内联元素排版方式</p><blockquote><ul><li>盒子会从包含块的顶部开始，按序水平排列</li><li>只有水平外边距(垂直方向无效)、边框和内边距会被保留</li><li>这些盒子可以以不同方式在垂直方向对齐：可以在底部对齐或顶部对齐，或者按文字底部进行对齐???</li></ul></blockquote></li></ol><blockquote><blockquote><p>注意：所有的HTML元素本质上都是一个盒子模型，并具有盒模型的结构和属性</p></blockquote></blockquote><h3 id="三、浮动布局"><a href="#三、浮动布局" class="headerlink" title="三、浮动布局"></a>三、浮动布局</h3><ol><li>浮动布局起源<blockquote><p><strong>最初</strong></p><ul><li>引入<code>float</code>属性是为了能让web开发人员实现简单的布局，包括在一列文本中浮动的图像，文字环绕在他的左边或右边</li><li>但web开发人员很快意识到，任何东西都可以浮动，而不仅仅是图像，所以浮动的使用范围扩大了</li></ul></blockquote></li><li>浮动是如何工作的<blockquote><ul><li>把一个元素”浮动”(float)起来，会改变该元素本身和在正常布局流(normal flow)中跟随它的其他元素的行为</li><li>这一元素会浮动到左侧或右侧，并且从正常布局流中移除，这时候其他的周围内容就会在这个被设置浮动的元素周围环绕</li><li><strong>简单理解</strong><br> 当元素添加浮动后，元素就会<strong>脱离文档流</strong>，按照指定方向(左右)发生移动，遇到父级边界或者相邻的浮动元素就会停下来，同时会影响到他后面元素的排版行为<ul><li>文档流：文档中可显示对象在排列时所占据的位置&#x2F;空间(在页面中占位置)</li><li>脱离文档流：元素相当于漂浮起来，不占据页面中的位置</li></ul></li></ul></blockquote></li><li>浮动的本质和要点<blockquote><ul><li>浮动的本质功能：用来实现并排</li><li>浮动使用要点：要浮动，并排的盒子<strong>都要</strong>设置浮动</li><li>父盒子要有足够的宽度，否则子盒子会掉下去</li></ul></blockquote></li><li>如何产生浮动<blockquote><ul><li>给需要浮动的元素添加float属性，对应值如下：<table><thead><tr><th>属性</th><th>值</th></tr></thead><tbody><tr><td><code>float</code></td><td>①<code>none</code>默认值，元素不浮动    ②<code>left</code>元素向左浮动    ③<code>right</code>元素向右浮动    ④<code>inherit</code>规定应该从父元素继承float属性的值(一般不用)</td></tr></tbody></table></li></ul></blockquote></li></ol><h3 id="四、元素浮动的特性"><a href="#四、元素浮动的特性" class="headerlink" title="四、元素浮动的特性"></a>四、元素浮动的特性</h3><ol><li>元素添加浮动后，脱离文档流<blockquote><p>同时会影响其后面的元素，但不影响它前面的元素</p></blockquote></li><li>如果父元素的宽度不够<blockquote><p>子元素在放不下的情况下会换行显示</p></blockquote></li><li>浮动的顺序贴靠特性<blockquote><p>子盒子会按顺序进行贴靠，如果没有足够空间，则会寻找前一个兄弟元素</p></blockquote></li><li>元素浮动后，具有行内块级元素特性<blockquote><ul><li>浮动的元素不再区分块级元素、行内元素，因为已经脱离了标准文档流</li><li>浮动后，任何标签都能设置宽高，但不独占一行</li></ul></blockquote></li><li>浮动的元素会造成父元素高度塌陷<blockquote><ul><li>当<strong>父元素没有设置高度</strong>、且子元素设置浮动时，父元素会形成高度塌陷</li><li>因为子元素浮动后不占据页面空间</li></ul></blockquote></li><li>浮动对文字的影响<blockquote><ul><li>会形成常见的文字环绕效果，其实现方式主要是将图片左&#x2F;右浮动</li><li>浮动后其相邻文字就会环绕图片排列</li><li>图片&#x2F;子盒子要放在文字前&#x2F;中间；若放在文字后，则没有环绕效果</li></ul></blockquote></li><li>使用浮动实现网页布局<blockquote><ul><li>垂直显示的盒子，不要设置浮动，只有并排显示的盒子才需要设置浮动</li><li>每个盒子都是独立存在的，盒子内部也可以继续使用浮动</li><li>注意点：<ul><li>先搭建好框架</li><li>使用语义化标签、进行注释</li><li>对最后一个盒子的处理<code>last-child</code></li><li>在实践中发现，ul的四个li，最靠近右边的是第一个,因为右浮动，从右往左排列</li></ul></li></ul></blockquote></li></ol><h3 id="五、BFC规范和浏览器差异"><a href="#五、BFC规范和浏览器差异" class="headerlink" title="五、BFC规范和浏览器差异"></a>五、BFC规范和浏览器差异</h3><blockquote><ul><li>BFC(Box Formatting Context，块级格式上下文)是页面上的一个隔离的独立容器</li><li>容器里的子元素和容器外的元素互不干扰</li><li>元素浮动的第五个特性：“父元不设高度，子元浮动，会造成父元素高度塌陷”，其原因就是这个盒子没有形成BFC</li></ul></blockquote><ol><li>创建BFC的方法<blockquote><ul><li>方法1：float的值不是<code>none</code><ul><li>缺点：该方法可以实现效果，但没有意义，不可能随意给盒子设置浮动</li></ul></li><li>方法2：position的值不是<code>static</code>或<code>relative</code><ul><li>缺点：该方法可以实现，但不靠谱</li></ul></li><li>方法3：display的值是<code>inline-block</code>、<code>flex</code>、<code>inline-flex</code><ul><li>缺点：该方法可以实现，但没有意义，因为不可能随意更改盒子类型</li></ul></li><li>方法4：<code>overflow:hidden;</code><ul><li>缺点：该方法可以实现，但不满足所有的场景，例如想要使溢出的元素显示的情况；</li><li>但这是非常好用的方法，比其他方式使用的更多</li></ul></li></ul></blockquote></li><li>BFC的其他作用<blockquote><ul><li>BFC可以取消盒子margin塌陷：<ul><li>方法1：既可以解决父子元素也可以解决兄弟元素的外边距塌陷</li><li>方法2：可以解决父子元素之间的塌陷，但兄弟元素无效</li><li>方法3：<code>inline-block</code>和<code>inline-flex</code>的效果和方法1一样，但转成行内块元素时，相邻的行内块元素会产生空白间隙。<code>flex</code>对兄弟元素无效，只能解决父子元素之间的塌陷</li><li>方法4：可以解决<strong>父子元素</strong>之间垂直方向外边距塌陷问题，但解决不了兄弟元素之间的塌陷</li></ul></li><li>BFC可以阻止元素被浮动元素覆盖</li></ul></blockquote></li><li>浏览器差异<blockquote><ul><li>IE6、7浏览器使用haslayout机制和BFC规范略有差异</li></ul></blockquote><ul><li>比如：IE浏览器可以使用zoom:1属性，让盒子拥有layout<blockquote><ul><li>如果要制作兼容到IE6、7的网页时，尽量让网页布局变得简单，内部有浮动的盒子要设置height属性，规范编程，就没有问题</li></ul></blockquote></li></ul></li></ol><h3 id="六、清除浮动"><a href="#六、清除浮动" class="headerlink" title="六、清除浮动"></a>六、清除浮动</h3><blockquote><ul><li>清除浮动：浮动一定要封闭到一个盒子中，否则就会对页面后续元素产生影响</li></ul></blockquote><ol><li>清除浮动方法1<blockquote><ul><li>给父盒子设置<code>clear:both;</code>属性</li><li><code>clear</code>表示清除浮动对自己的影响，<code>both</code>表示左右浮动全部清除</li><li>该方法不推荐。父盒子不会被撑起来。</li></ul></blockquote></li><li>清除浮动方法2<blockquote><ul><li>在两个父盒子之间”隔墙”隔一个携带<code>clear:both;</code>的盒子</li><li>可以清除浮动，但不能撑起盒子。而且新增一个div对页面有影响</li><li>不推荐</li></ul></blockquote></li><li>清除浮动方法3<blockquote><ul><li>原理是让内部有浮动的父盒子形成BFC，它就能关闭住内部的浮动</li><li>在创建BFC的四个方法中，最好的方法是<code>overflow:hidden;</code>，但这个方法有局限性</li><li>不能解决兄弟元素的外边距塌陷</li></ul></blockquote></li><li>清除浮动方法4——最佳方法<blockquote><ul><li>使用<code>::after</code>伪元素，给盒子添加最后一个子元素</li><li>给<code>::after</code>设置<code>clear:both</code></li><li>别忘了写<code>content=&quot;&quot;;</code></li><li><code>display:block</code>,伪元素默认是行内元素，所以要把它转化为块级元素。若不转换，则父元素不能被撑起来。</li><li>不能解决兄弟元素的外边距塌陷</li><li>强烈推荐</li></ul></blockquote></li></ol><h3 id="七、浮动实战应用"><a href="#七、浮动实战应用" class="headerlink" title="七、浮动实战应用"></a>七、浮动实战应用</h3><blockquote><ul><li>浮动的元素一般都会在其外边套一个标准流</li></ul></blockquote><ol><li>实现左右两列式布局</li><li>实现一行多列式布局</li><li>三列式布局，中间自适应<blockquote><ul><li>注意点：<ul><li>body里先写左右，再写中间。左右盒子各自浮动，再填充中间元素</li><li>用怪异盒模型保持内边距和边框不变</li><li>用外边距控制中间元素位置</li><li>用伪元素+clear:both来清除浮动</li></ul></li></ul></blockquote></li><li>多行多列式布局</li><li>实现整站结构布局</li><li>作业1：前端必会的三种CSS布局技术</li><li>作业2：酷狗音乐热门榜单</li><li>小米商城产品展示效果</li></ol><h2 id="CSS定位、层叠顺序、层叠上下文"><a href="#CSS定位、层叠顺序、层叠上下文" class="headerlink" title="CSS定位、层叠顺序、层叠上下文"></a>CSS定位、层叠顺序、层叠上下文</h2><blockquote><ul><li>CSS中利用position属性用于指定一个元素在文档中的定位方式。元素的定位方式有五种类型：<table><thead><tr><th>属性值</th><th>描述</th></tr></thead><tbody><tr><td><code>static</code></td><td>没有定位，元素出现在正常的流中(默认值，可以忽略)</td></tr><tr><td><code>relative</code></td><td>相对定位，相对于自身正常位置进行位置的调整</td></tr><tr><td><code>absolute</code></td><td>绝对定位，相对于其最近的定位的父元素定位，进行位置的调整</td></tr><tr><td><code>fixed</code></td><td>固定定位，相对于浏览器窗口进行位置调整</td></tr><tr><td><code>sticky</code></td><td>粘性定位，是基于用户的滚动位置来定位</td></tr></tbody></table><blockquote><p><code>static</code>相当于元素没有加定位效果，如果元素加了定位，后面需要去掉，可以添加<code>position:static;</code>|</p></blockquote></li></ul></blockquote><h3 id="一、相对定位"><a href="#一、相对定位" class="headerlink" title="一、相对定位"></a>一、相对定位</h3><blockquote><p>盒子可以想对自己&#x3D;&#x3D;原来的位置&#x3D;&#x3D;进行调整，称之为相对定位</p><ul><li>给需要添加相对定位的元素，加上<code>position:relative;</code></li><li>元素的位置通过(位置描述词):<code>left</code>、<code>top</code>、<code>right</code>、<code>bottom</code>属性进行位置调整</li><li>属性值可以是正数也可以是负数<table><thead><tr><th>定位的位置属性</th><th>描述</th></tr></thead><tbody><tr><td><code>top</code></td><td>向下移动</td></tr><tr><td><code>bottom</code></td><td>向上移动</td></tr><tr><td><code>left</code></td><td>向右移动</td></tr><tr><td><code>right</code></td><td>向左移动</td></tr><tr><td>值可以为负数</td><td>即往规定方向相反移动</td></tr></tbody></table></li></ul></blockquote><blockquote><p>相对定位的特点</p><ul><li>相对定位的元素，会在“老家留坑”，本质上仍然是在原来的位置，即:元素的初始位置占据的空间会被保留</li><li>只不过渲染在新的地方而已，渲染的图形可以比喻成影子，不会对页面其他元素产生任何影响</li></ul></blockquote><h3 id="二、相对定位应用场景"><a href="#二、相对定位应用场景" class="headerlink" title="二、相对定位应用场景"></a>二、相对定位应用场景</h3><blockquote><ul><li>用来微调元素自身的位置(案例1，2，3)</li><li>可以当做绝对定位的参考盒子(绝对定位中会讲到)</li><li>用来提升自身的层级</li></ul></blockquote><ol><li>鼠标滑动到元素，元素少量位置偏移动画 <img src="相对定位应用场景1.gif"></li><li>网站导航 <img src="相对定位场景2.png"></li><li>导航(鼠标滑动带过下划线)<blockquote><ul><li>鼠标滑过时，背景颜色和a标签的文字一起变化。其前提是a标签是&#x3D;&#x3D;块级元素&#x3D;&#x3D;</li><li>知识点：块级元素没有设置宽高时，将自动撑满父盒子，但并不是继承！！！ <img src="相对定位场景3.png"></li></ul></blockquote></li><li>水平进度条<blockquote><ul><li>右浮动实现元素从右往左开始排列成一行，第一个排在最后面，最后一个排在最左边</li><li>通过相对定位微调线条位置，使其与圆形在垂直方向对其</li><li>利用<code>~</code>后续兄弟选择器，来选择他后面的元素，修改样式 <img src="相对定位场景4.png"></li></ul></blockquote></li></ol><h3 id="三、绝对定位"><a href="#三、绝对定位" class="headerlink" title="三、绝对定位"></a>三、绝对定位</h3><blockquote><p>盒子可以在浏览器中以坐标进行位置精准描述，拥有自己的绝对位置</p><ul><li>给需要添加绝对定位的元素，加上<code>position:absolute;</code></li><li>元素的位置通过(位置描述词)：<code>left</code>、<code>top</code>、<code>right</code>、<code>bottom</code>属性进行调整位置</li><li>属性值可以是正数或负数<table><thead><tr><th>定位的位置属性</th><th>描述</th></tr></thead><tbody><tr><td>top</td><td>到上边的距离</td></tr><tr><td>bottom</td><td>到下边的距离</td></tr><tr><td>left</td><td>到左边的距离</td></tr><tr><td>right</td><td>到右边的距离</td></tr></tbody></table></li></ul></blockquote><blockquote><p><strong>绝对定位元素8大特性：</strong></p><ol><li>绝对定位的元素，相对离自己最近的定位的父元素进行位置调整</li></ol><ul><li>若父元素未定位(没有<code>position: ;</code>)，则用祖先元素定位，绝对定位是相对于定位的祖先元素进行位置调整</li></ul><ol start="2"><li>如果没有定位的父元素，则相对body进行位置调整</li><li>元素完全脱离文档流，释放器原本所占据的空间</li></ol><ul><li>不会对其他元素造成任何干扰，而是对他们进行压盖</li><li>脱离文档流的方法：浮动、绝对定位、固定定位</li><li>使用绝对定位的元素将会是一种漂浮状态</li></ul><ol start="4"><li>元素的层级提升，会覆盖在其他元素上</li><li>行内元素加上定位后，会具有行内块元素特性，支持宽高设置</li><li><code>margin:auto;</code>水平居中失效，因为它变成了行内块元素</li><li>定位元素未设置宽高情况下，同时设置top和bottom会改变元素高，同时设置left、right会改变元素宽</li><li>在元素设置了宽高情况下，同时设置top与bottom，会以top值为主，bottom不生效；同时设置left与right，则以left为主，right不生效</li></ol><ul><li>top &gt; bottom,left &gt; right</li></ul></blockquote><blockquote><p><strong>使盒子水平、垂直居中</strong></p><ol><li>方法1：</li></ol><ul><li>垂直居中：top&#x3D; [父盒子高度-子盒占位高(content+padding+border+margin)]&#x2F;2</li><li>水平居中：left&#x3D;[父盒子宽度-子盒占位宽(content+padding+border+margin)]&#x2F;2</li></ul><ol start="2"><li>方法2：</li></ol><ul><li>垂直居中：top:50%，margin-top:<code>-</code>自己高度的一半</li><li>水平居中：left:50%,margin-left:<code>-</code>自己宽度的一半</li><li>记得用负号</li></ul></blockquote><blockquote><p><strong>应用场景</strong></p><ul><li>绝对定位用来制作<strong>压盖、遮罩</strong>效果</li><li>结合CSS精灵使用</li><li>结合JS实现动画</li><li>绝对定位应用非常多，灵活度也很高，靠经验积累</li></ul></blockquote><ol><li>绝对定位实现黑色半透明遮罩层<blockquote><p>注意：</p><ul><li>伪元素+.hover的写法：<code>.box:hover::after</code>，中间不用空格</li></ul></blockquote></li><li>绝对定位实现带三角的会话框<blockquote><p>注意：</p><ul><li>用<code>border-radius</code>使背景图片&#x2F;图片变成圆形</li></ul></blockquote></li></ol><h3 id="四、固定定位"><a href="#四、固定定位" class="headerlink" title="四、固定定位"></a>四、固定定位</h3><blockquote><p><strong>介绍</strong></p><ul><li>给需要添加固定定位的元素加上position:fixed;</li><li>元素的位置通过位置描述词：left、top、right、bottom属性进行位置调整</li><li>属性值可以是正数或负数</li><li>固定定位只能以页面为参考点，并没有绝对定位的参考点</li><li>固定定位脱离标准文档流</li><li>除了其位置是相对于浏览器窗口而言以外，其他与绝对定位的特性一致</li></ul></blockquote><blockquote><p><strong>应用场景</strong></p><blockquote><p>不管浏览器的滚动条如何滚动，元素始终相对于&#x3D;&#x3D;浏览器窗口&#x3D;&#x3D;的位置不变</p></blockquote><ol><li>固定定位实现返回顶部</li><li>常见的登录弹窗效果 我的疑问：</li></ol><ul><li>点击登录怎么跳出登录框？a标签的href是否可以链接它？<ul><li>目前学到的东西还做不到</li></ul></li><li>点击登录框的取消，怎么返回原页面<ul><li>目前学到的东西还做不到</li></ul></li><li>mask的尺寸问题，怎么全页面遮罩？绝对定位top&#x3D;0,left&#x3D;0？<ul><li>固定定位，四个方向距离都&#x3D;0</li></ul></li><li>登录框怎么垂直、水平居中在页面上，不论界面怎么缩放。<ul><li>固定定位</li></ul></li></ul><pre><code>position:fixed;top:50%left:50%transform:translate(-50%,-50%)</code></pre><ol start="3"><li>左右固定，中间自适应</li></ol></blockquote><h3 id="五、粘性定位"><a href="#五、粘性定位" class="headerlink" title="五、粘性定位"></a>五、粘性定位</h3><blockquote><blockquote><p>它的诞生就是为了实现字母排序显示效果(应用场景2)<br><strong>粘性定位解读：</strong></p></blockquote><ul><li>给需要的添加粘性定位的元素，加上position:sticky;</li><li>粘性定位可以看做是相对定位与固定定位的混合产物(这里的固定定位，并不是上面第四点的position:fixed;只是具有相似点)</li><li>当滚动高度小于元素所在位置时，元素以&#x3D;&#x3D;相对&#x3D;&#x3D;定位呈现</li><li>当滚动高度大于元素所在位置时，元素以&#x3D;&#x3D;固定&#x3D;&#x3D;定位呈现</li><li>当滚动高度大于(元素的父元素底部与浏览器高)时，元素相对于父元素定位，一起移走</li><li>粘性定位相对离他最近的一个拥有“滚动机制”的祖先元素(当该祖先的overflow是hidden、scroll、auto、overplay时)定位&#x3D;&#x3D;或者&#x3D;&#x3D;直接块级父元素定位<blockquote><p>注意：</p></blockquote></li><li>当body为最近”滚动机制”的祖先，此时要看到元素相对浏览器固定效果，元素的&#x3D;&#x3D;直接父元素&#x3D;&#x3D;高度一定要大于元素本身</li><li>当元素的父级拥有”滚动机制”，若有滚动条，则元素固定在父级元素的最顶部</li></ul></blockquote><ol><li>当body为最近滚动机制的祖先<blockquote><ul><li>使用粘性定位的元素，其父元素高度一定要大于它自身的高度</li><li>使用粘性定位的元素，其父元素高度一定要大于它自身的高度</li><li>当滚动高度小于元素所在位置时，该元素随滚动条一起移动，但相对位置不变</li><li>当元素所在位置&lt;滚动高度&lt;其父元素的底部，该元素固定在顶部，与body的距离&#x3D;设置的position值</li><li>当元素所在位置大于其父元素底部时，该元素底部与父元素底部重合后，一起移走</li></ul></blockquote></li><li>当父元素拥有滚动机制<blockquote><ul><li>父盒子具有overflow，且父盒子高度比它大</li><li>当滚动body的滚动条时，该盒子会整体随页面滑动</li><li>当滚动高度小于元素所在位置时，该元素随滚动条一起移动，但相对位置不变</li><li>当元素所在位置&lt;滚动高度&lt;其父元素的底部，该元素固定在顶部，与body的距离&#x3D;设置的position值</li><li>由于父盒子高度一定小于子元素总高度(不然不会出现滚动条)，所以元素所在位置不会大于其父元素底部</li></ul></blockquote></li></ol><blockquote><p><strong>粘性定位应用场景</strong></p><ol><li>头部和左侧吸顶盒效果</li></ol><ul><li>我自己做的存在的问题<ul><li>左边侧栏无法实现效果</li><li>右侧盒子的书写方式可以更简洁，用序号选择器</li></ul></li><li>看视频后的解决方式<ul><li>左右侧栏用一个盒子包裹起来，左右浮动</li><li>一定要消除浮动，不然父盒子高度塌陷就实现不了粘性定位</li><li>给父盒子加上外边距以保持与第二个盒子之间的距离</li><li>给右侧栏加:nth-child()控制颜色,偶数2n,奇数2n-1</li></ul></li></ul><ol start="2"><li>字母排序显示效果</li></ol><ul><li>注意：用定义列表dl dt dd</li></ul><ol start="3"><li>表格首行冻结</li></ol><ul><li>注意：<ul><li>使表格贴合父盒子：width: 100%;</li><li>将表格边框合并成单边框：border-collapse: collapse;</li></ul></li></ul></blockquote><h3 id="六、定位的总结"><a href="#六、定位的总结" class="headerlink" title="六、定位的总结"></a>六、定位的总结</h3><blockquote><table><thead><tr><th>定位类型</th><th>描述</th><th>应用场景</th></tr></thead><tbody><tr><td>相对定位relative</td><td>相对自身原来的位置占位，站着原来的位置</td><td>1.微调元素的位置，但还占据着原来的空间 2.只想提升元素的层级，但还是站着原来的空间</td></tr><tr><td>绝对定位absolute</td><td>相对离自己最近的定位的父元素定位，原来的位置被释放，相当于悬浮在页面中，会覆盖在其他元素的上面显示</td><td>1.一个元素想覆盖在另一个元素上 2.配合JS来实现动画效果</td></tr><tr><td>固定定位fixed</td><td>相对浏览器窗口进行定位</td><td>你想让一个元素相对浏览器的位置一直不动</td></tr><tr><td>粘性定位</td><td>相对离自己最近的拥有滚动机制的父元素定位，或，直接父元素定位</td><td>吸附效果、冻结效果</td></tr></tbody></table></blockquote><h3 id="七、z-index设置定位元素层叠顺序"><a href="#七、z-index设置定位元素层叠顺序" class="headerlink" title="七、z-index设置定位元素层叠顺序"></a>七、z-index设置定位元素层叠顺序</h3><blockquote><blockquote><p>定位的元素脱离了正常文档流，它相当于漂浮在文档上面。那如果有很多元素都用了定位，那如何确定这些元素的层叠顺序？&gt;&gt;z-index就是用来指定定位元素的堆叠顺序</p></blockquote></blockquote><blockquote><p>同一层叠上下文中z-index值的特性</p><ul><li>默认值是0</li><li>值可正可负</li><li>z-index值相同的元素，写在后面的会覆盖前面的</li><li>值越大，元素越在上面显示</li><li>只针对定位元素有效，对其他元素无效</li></ul></blockquote><h3 id="八、CSS中的层叠上下文"><a href="#八、CSS中的层叠上下文" class="headerlink" title="八、CSS中的层叠上下文"></a>八、CSS中的层叠上下文</h3><ol><li>什么是层叠上下文<blockquote><ul><li>它是一个HTML中的三维概念</li><li>在css2.1规范中有明确强调，每个css盒模型都是处在一个三维空间里面，他们分别处在平面的X轴、Y轴以及表示层叠的Z轴<img src="层叠上下文.png">>注意： </li><li>但并不是所有的盒子都会在Z轴发生层叠，默认情况下，HTML元素使沿XY轴平铺，元素默认从上到下、从左往右依次排列 </li><li>一旦发生堆叠，就能感受到Z轴的存在。不管有无层叠，Z轴都存在</li></ul></blockquote></li></ol><blockquote><p><strong>具象化解释：</strong></p><ul><li>body这个html根元素，天生具有上下文。它是爷爷，其他所有元素都同属于&#96;body&#96;&#96;这个层叠上下文。</li><li>在body中可以放普通元素，还可以放创建了层叠上下文的元素,就像爷爷可以有很多儿子。每个儿子，各自等级不同、先后顺序也不同；创建了层叠上下文的元素就像当了官，它比普通元素等级更高，而且官越高等级越高。</li><li>每个儿子还会生更多孩子，也就是爷爷的孙子。子凭父贵，父亲等级越高，它在孙子辈里等级就越高。</li><li>这里的爷爷、儿子、孙子等辈分是指不同的层叠上下文。与父盒子盒&#x2F;父元子元有区别</li></ul></blockquote><blockquote><ul><li>问题1：怎么当官？(怎么提高&#x2F;降低元素的等级) 原理<ul><li>在同一层叠上下文中，创建了层叠上下文的**&gt;**普通元素</li><li>在同一层叠上下文中，z-index值越高的官越大，未设置z-index的定位元素默认z-index&#x3D;0</li><li>在同一层叠上下文中，相同等级的元素，写在后面的比写在前面的大，后面的覆盖前面的 </li><li>方法<ul><li><ol><li>后出生(写在后面)</li></ol></li><li><ol start="2"><li>当官(创建层叠上下文)</li></ol></li><li><ol start="3"><li>提高官职(提高z-index的值)</li></ol></li></ul></li></ul></li></ul></blockquote><ol><li>创建层叠上下文的方法<blockquote><ul><li>天生的：body(又称为根层叠上下文)<ul><li>我们在写body中的HTML时，默认就是处在根层叠上下文中</li></ul></li><li>定位元素的传统层叠上下文(当官老办法，但限制于定位元素)<ul><li><code>position:relative/absolute</code>的定位元素，当其z-index的值不是auto的时候就会创建层叠上下文</li><li><code>position:fixed/sticky</code>的定位元素直接创建，不用管z-index的值</li></ul></li><li>CSS3时代的新方法(新时代新办法)<ul><li>z-index不是auto的flex项(父元素display:flex|&gt;   inline-flex)会创建层叠上下文</li><li>元素的opacity值不是1</li><li>元素的transform值不是none</li><li>元素的mix-blend-mode的值不是normal</li><li>元素filter值不是none</li><li>元素的isolation值是isolate</li><li>will-change指定的属性值为上面的任意一个</li><li>元素的-webkit-overflow-scrollin设为touch</li></ul></li></ul></blockquote></li></ol><blockquote><ul><li>问题2：普通元素分三六九等吗？怎么分？(普通元素的层级) <img src="层叠顺序.png">- ！！！首先在同一层叠上下文中，背景和边框<z-index=负数<普通元素<z-index=0的定位元素<z-index值为正数的定位元素- 普通元素： block块级元素==<==float浮动盒子==<==inline或line-block盒子>在爷爷面前是这套规矩，在儿子辈、孙子辈等每一个小社会也遵循这套规矩，只新增**子凭父贵**这一条规矩</li></ul></blockquote><ol><li>如何确定两个元素的层叠顺序<blockquote><ul><li>先确定它们父亲是谁(确定他们所在的层叠上下文)</li><li>如果是同一父亲，那就直接比较元素类型、先后顺序、z-index的值</li><li>如果不是同一父亲，那就比较父亲之间的官级大小，子凭父贵</li></ul></blockquote></li></ol><h3 id="九、阿里图标库-icon-font"><a href="#九、阿里图标库-icon-font" class="headerlink" title="九、阿里图标库-icon-font"></a>九、阿里图标库-icon-font</h3><blockquote><p>可以下载各种样式的图标 使用方法</p><ul><li>把每个图标直接下载到本地</li><li>加入购物车，添加至项目中下载压缩包(压缩包里会有使用方法)<ul><li>Unicode引用：<ul><li>把第一步中的url改成自己电脑的相对路径</li><li>在第二步复制的代码中.iconfont中修改颜色大小</li><li>在第三步的内容中填写自己想要的图标编码</li></ul></li><li>Font class引用：<ul><li>把第一步中的href地址改成自己电脑里的相对路径</li><li>修改第二步的类名，根据图标下的名字&#x2F;看iconfon.css</li><li>修改图标颜色、大小：首先这些已经设置过了，若要修改则需提高优先级</li></ul></li><li>symbol引用</li></ul></li></ul></blockquote><h3 id="十、综合实践"><a href="#十、综合实践" class="headerlink" title="十、综合实践"></a>十、综合实践</h3><ol><li>酷狗音乐精选歌单效果<blockquote><ul><li>a标签包裹全部元素</li><li>遮罩要放在最上面，position+::after就可以实现</li></ul></blockquote></li><li>小米商城右侧悬浮菜单</li><li>带左右按钮的自动轮播图效果布局</li><li>CSS实现二级导航下拉菜单<blockquote><ul><li>下拉菜单：用绝对定位</li><li>下拉菜单和导航栏的居中对齐：left:50%,margin-left:自身宽度的一半</li><li>鼠标放置效果：给导航栏的li设置:hover</li></ul></blockquote></li><li>CSS时间轴效果布局<blockquote><ul><li>时间轴布局重要！！！</li><li>限制宽度，利用左右浮动的盒子，设置左右边框样式来绘制时间轴</li><li>双引号样式：字体：Arial</li></ul></blockquote></li></ol><h2 id="margin负值的最佳实践"><a href="#margin负值的最佳实践" class="headerlink" title="margin负值的最佳实践"></a>margin负值的最佳实践</h2><h3 id="一、margin负值特性"><a href="#一、margin负值特性" class="headerlink" title="一、margin负值特性"></a>一、margin负值特性</h3><ul><li>margin-left设置负值时，元素自身向左移动，后面的元素也向左移动</li><li>margin-right设置负值时，自身不受影响，右边元素向左移动</li><li>margin-top设置负值时，元素自身向上移动，下面的元素也向上移</li><li>margin-bottom设置负值时，自身不受影响，下方元素向上移动<blockquote><p>right和bottom设置负值时，就像是在页面上减小了占位，后面的元素随之补上，但实际上占位并没有变</p></blockquote></li></ul><h3 id="二、margin塌陷时合并规则"><a href="#二、margin塌陷时合并规则" class="headerlink" title="二、margin塌陷时合并规则"></a>二、margin塌陷时合并规则</h3><ul><li>&#x3D;&#x3D;口诀&#x3D;&#x3D;：符号相同时，看绝对值，听老大的；符号不同时，相加减</li></ul><blockquote><p>介绍</p></blockquote><ul><li>margin重叠也叫塌陷、合并、床头</li><li>只针对垂直方向，不针对水平方向<br><strong>分两种情况</strong><ul><li>兄弟元素之间：上下外边距重叠</li><li>父子元素之间：上下外边距合并(父元未设置内边距和边框时)</li></ul></li><li>应用场景和最佳实践</li></ul><ol><li>等高布局-左右布局：不管做左边盒子中内容多少，其高度都会随右边的粉色盒子变高</li></ol><ul><li>给左边盒子，用&#x3D;&#x3D;正值&#x3D;&#x3D;pdding-bottom增加盒子高度，并且加相同值的&#x3D;&#x3D;负值&#x3D;&#x3D;的margin-bottom抵消内边距的占位</li><li>给父盒子加overflow-hidden</li></ul><ol start="2"><li>一行多列网格布局</li></ol><ul><li>margin-left:-1px;使边框重叠在一起</li></ul><ol start="3"><li>头像叠加效果</li></ol><ul><li>先让每个子盒向左移动负外边距</li><li>然后单独修改第一个盒子的左外边距</li></ul><ol start="4"><li>元素水平垂直居中</li></ol><ul><li>先利用绝对定位使子盒子移动父盒子宽高的一半</li><li>top:50%、left:50%</li><li>再利用负外边距使子盒反向移动自身宽高的一半</li><li>一定给父盒子加相对定位</li></ul><ol start="5"><li>圣杯布局</li></ol><h2 id="圆角、阴影、文本图像处理、CSS函数"><a href="#圆角、阴影、文本图像处理、CSS函数" class="headerlink" title="圆角、阴影、文本图像处理、CSS函数"></a>圆角、阴影、文本图像处理、CSS函数</h2><h3 id="一、圆角"><a href="#一、圆角" class="headerlink" title="一、圆角"></a>一、圆角</h3><ol><li>简介</li></ol><ul><li><p>border-radius用来设置元素的(4个方向)外边框1&#x2F;4圆角效果 </p><table><thead><tr><th>圆角类型</th><th>描述</th><th>举例</th></tr></thead><tbody><tr><td>圆角边框</td><td>当使用一个半径时，确定一个圆，表示四个不同方向上边框圆角的半径大小</td><td>border-radius:50px;</td></tr><tr><td>椭圆边框</td><td>当使用两个半径时，确定一个椭圆；两个半径之间用&#x3D;&#x3D;反斜杠&#x3D;&#x3D;&#x2F;分隔，第一个值是水平半径，第二个值是垂直半径</td><td>border-radius:50px&#x2F;30px;</td></tr></tbody></table></li><li><p>圆角效果：是从边框四个角出发，根据半径得到圆心，与四条边相交，得到的1&#x2F;4圆角</p></li></ul><ol><li><p>圆的4种不同值写法：顺时针方向</p><table><thead><tr><th>属性值</th><th>举例</th><th>说明</th></tr></thead><tbody><tr><td>单值写法</td><td>border-radius:50px;</td><td>上右下左四个方向的圆角半径</td></tr><tr><td>双值写法</td><td>border-radius:30px 40px;</td><td>斜对角；第一个值：左上角和右下角；第二个值：右上角和左下角</td></tr><tr><td>三值写法</td><td>border-radius:30px 50px 80px;</td><td>分别表示：左上角，右上角和左下角，右下角；</td></tr><tr><td>四值写法</td><td>border:10px 20px 30px 40px;</td><td>分别表示：左上角，右上角，右下角，左下角</td></tr></tbody></table></li><li><p>椭圆的4种不同值的写法</p><table><thead><tr><th>属性值</th><th>举例</th><th>说明</th></tr></thead><tbody><tr><td>单值写法</td><td>border-radius:50px&#x2F;30px;</td><td>50px表示四个不同方向椭圆的水平半径，30px表示四个不同方向椭圆垂直半径</td></tr><tr><td>双值写法</td><td>border-radius:10px 20px&#x2F;30px 50px;</td><td>斜对角；左上角和右下角：水平半径10px，垂直半径30px；右上角和左下角：水平半径30px，垂直半径50px</td></tr><tr><td>三值写法</td><td>border-radius:30px 50px 60px&#x2F;20px 30px 50px;</td><td>分别表示：左上角30px&#x2F;20px，右上角和左下角50px&#x2F;30px，右下角60px&#x2F;50px；</td></tr><tr><td>四值写法</td><td>border:10px 20px 30px 40px&#x2F;40px 30px 20px 10px;</td><td>分别表示：左上角10px&#x2F;40px，右上角20px&#x2F;30px，右下角30px&#x2F;20px，左下角40px&#x2F;10px</td></tr></tbody></table></li><li><p>百分比表示法</p></li></ol><ul><li>百分比是相对于当前元素的&#x3D;&#x3D;可视宽高&#x3D;&#x3D;而言的</li><li>水平半径相当于元素的可视宽而言，水平半径&#x3D;(width+padding+border)*百分比</li><li>垂直半径相当于元素的可视高而言，垂直半径&#x3D;(height+padding+border)*百分比</li></ul><ol start="4"><li>单独设置四个方向圆角-小属性</li></ol><ul><li>此时，写一个值表示圆，写两个值表示椭圆，&#x3D;&#x3D;并且椭圆&#x3D;&#x3D;的两个值不需要用反斜杠分隔</li><li>先上下后左右</li><li>主要是用来层叠大属性的 <table><thead><tr><th>属性</th><th>描述</th></tr></thead><tbody><tr><td>border-top-left-radius</td><td>左上角</td></tr><tr><td>border-top-right-radius</td><td>右上角</td></tr><tr><td>border-bottom-left-radius</td><td>左下角</td></tr><tr><td>border-bottom-right-radius</td><td>右下角</td></tr></tbody></table></li></ul><pre><code>左上角椭圆：border-top-left-radius:30px 40px;右下角圆：border-bottom-right-radius:30px;</code></pre><h3 id="二、盒子阴影"><a href="#二、盒子阴影" class="headerlink" title="二、盒子阴影"></a>二、盒子阴影</h3><blockquote><p>box-shadow给盒子添加阴影效果，阴影是<strong>不占空间</strong>的</p></blockquote><ul><li>写法：<code>box-shadow:[inset] X偏移 Y偏移 模糊半径 [扩散半径] 颜色;</code>(右和上为正值方向)</li><li><code>[]</code>：表示这个值可以省略不写</li><li>inset:表示内阴影，当需要设置内阴影时，才添加</li><li>X偏移:阴影在x轴(水平)方向偏移量；正值表向右偏移，负值表向左偏移</li><li>Y偏移:阴影在Y轴(垂直)方向偏移量；正值表向上偏移，负值表向下偏移</li><li>模糊半径：值只能大于等于0，表示阴影的模糊半径</li><li>扩散半径：取正值表示阴影扩大，取负值表示阴影收缩。默认为0，此时阴影与元素同样大</li><li>颜色表示阴影的颜色</li></ul><ol><li>简单阴影</li></ol><ul><li><code>box-shadow:x偏移 y偏移 模糊量 颜色；</code></li></ul><ol start="2"><li>阴影扩展</li></ol><ul><li><code>box-shadow:x偏移 y偏移 模糊量 扩散半径 颜色；</code></li></ul><ol start="3"><li>内阴影</li></ol><ul><li><code>box-shadow:inset X偏移 Y偏移 模糊半径 扩散半径 颜色;</code></li></ul><ol start="4"><li>多个阴影</li></ol><ul><li>如果一个盒子有多个阴影，则每个阴影之间用<code>,</code>分隔</li><li>当阴影个数<code>&gt;1</code>时，阴影应用顺序为从前往后(z轴)，第一个指定阴影在最顶部显示</li><li>内阴影不管写在哪个位置，都会在外阴影上面</li></ul><ol start="5"><li>去掉阴影</li></ol><ul><li><code>box-shadow:none;</code></li></ul><ol start="6"><li>实战案例-纸张效果</li></ol><h3 id="三、文本阴影"><a href="#三、文本阴影" class="headerlink" title="三、文本阴影"></a>三、文本阴影</h3><ul><li><code>text-shadow</code>用来为文字添加阴影</li><li><code>text-shadow:X偏移 Y偏移 模糊半径 颜色;</code></li><li>多个阴影之间用逗号分隔</li><li>当阴影个数<code>&gt;1</code>时，阴影应用顺序从前到后，第一个指定阴影在最顶部显示</li></ul><h3 id="四、文本溢出显示省略号"><a href="#四、文本溢出显示省略号" class="headerlink" title="四、文本溢出显示省略号"></a>四、文本溢出显示省略号</h3><ol><li>单行文本溢出显示省略号</li></ol><ul><li>写法：</li></ul><pre><code>&lt;!-- 文字不换行 --&gt;white-space:nowrap;&lt;!-- 超出显示省略号 --&gt;text-overflow:ellipsis;&lt;!-- 超出部分隐藏 --&gt;overflow:hidden;</code></pre><ol start="2"><li>多行文本溢出显示省略号</li></ol><pre><code>&lt;!-- 超出部分隐藏 --&gt;overflow:hidden;&lt;!-- 超出显示省略号 --&gt;text-overflow:ellipsis;&lt;!-- 对象作为弹性盒子模型显示 --&gt;display:-webkit-box;&lt;!-- 快容器中的内容限制为指定行数 --&gt;-webkit-line-clamp:2;&lt;!-- 弹性盒子对象的子元素排列方式为竖排 --&gt;-webkit-box-orient:vertical;</code></pre><blockquote><p>注意：只有当元素的高&#x3D;<code>line-height</code>大小*<code>-webkit-line-clamp</code>时，才能显示出正确的效果</p></blockquote><ul><li>所以，一定要写行高，盒子高度根据行高和指定显示行数来设置，例如想让行高为25px的两行文字显示，则盒子高度为50px。</li></ul><h3 id="五、元素不透明度"><a href="#五、元素不透明度" class="headerlink" title="五、元素不透明度"></a>五、元素不透明度</h3><ul><li><p><code>opacity</code>指定了一个元素的不透明度</p><table><thead><tr><th>值</th><th>描述</th></tr></thead><tbody><tr><td>0</td><td>元素完全透明(即元素不可见)</td></tr><tr><td>0.0~1.0之间</td><td>元素半透明(元素背后的背景可见)</td></tr><tr><td>1</td><td>元素完全不透明(元素后面的背景不可见)</td></tr></tbody></table></li><li><p>如果超出0.0~1.0的范围，也会有效，但是会被解析为在取值范围内&#x3D;&#x3D;最靠近&#x3D;&#x3D;他的值|</p></li><li><p>可以用<code>opacity:0</code>隐藏一个元素，因为opacity会让这个元素及其子元素一起透明。</p></li><li><p>当<code>opacity</code>的属性值不为1时，元素会创建自己的层叠上下文</p></li></ul><blockquote><p>对比学习</p><table><thead><tr><th>属性</th><th>说明</th></tr></thead><tbody><tr><td><code>visibility:hidden</code></td><td>隐藏元素，但元素还占着原有的空间，在DOM树中</td></tr><tr><td><code>display:none</code></td><td>元素隐藏，不站着原来的空间，不在DOM树中</td></tr><tr><td><code>background-color:rgba(0,0,0,0.1)</code></td><td>仅背景颜色透明，并不影响元素中的内容</td></tr><tr><td><code>opacity:0;</code></td><td>元素透明，连同其内容和子元素一起透明掉</td></tr><tr><td><code>overflow:hidden</code></td><td>内容超出部分隐藏，影响的是子元素</td></tr></tbody></table></blockquote><h3 id="六、filter滤镜-图片模糊"><a href="#六、filter滤镜-图片模糊" class="headerlink" title="六、filter滤镜-图片模糊"></a>六、filter滤镜-图片模糊</h3><blockquote><p><code>filter:blur()</code>函数用于将高斯模糊效果应用于元素(图像)</p></blockquote><ul><li>单位是px</li><li>可以利用<code>filter:blur</code>与<code>background-size</code>的结合来实现背景模糊效果<ul><li>将背景放大到150%，然后模糊。参考艾编程官网老师们的简介</li></ul></li></ul><h3 id="七、object-fit-图片裁剪"><a href="#七、object-fit-图片裁剪" class="headerlink" title="七、object-fit 图片裁剪"></a>七、object-fit 图片裁剪</h3><ul><li>指定&#x3D;&#x3D;可替换元素&#x3D;&#x3D;的内容应该如何适应到其使用的高度和宽度确定的框</li><li>典型的可替换元素包括：img、video、iframe、embed</li><li>这个效果类似于<code>background-size</code><ul><li>但<code>object-fit</code> 在对齐时，是从元素框中间向两边的方式来填充</li><li>而<code>background-size</code>默认是是从左上角向右下角来填充，如果想设置以中间向两边，需要设置<code>background-position:center</code></li></ul></li></ul><p>|属性值|描述|<br>|contain|被替换的内容将被缩放，<strong>保持元素的宽高比</strong>，<strong>全部</strong>填充在内容框内|<br>|cover|被替换的内容将被缩放，<strong>保持元素的宽高比****，</strong>填满**整个内容框|<br>|fill|默认效果，被替换的内容正好填充元素的内容框，内容可能会被拉伸或压缩变形|<br>|none|被替换的内容保持其原有的尺寸|<br>|scale-down|内容的尺寸与<code>none</code>或<code>contain</code>中的一个相同，取决于他们两个之间谁得到的对象尺寸会更小一些|</p><ul><li>应用：防止图片拉伸或挤压-用户头像<ul><li>父盒子设置宽高</li><li>图片宽高设置100%全适应</li><li>添加<code>object-fit:cover</code>来等比例裁剪图片尺寸</li></ul></li></ul><h3 id="八、防止拖拽文本域"><a href="#八、防止拖拽文本域" class="headerlink" title="八、防止拖拽文本域"></a>八、防止拖拽文本域</h3><ul><li>resize属性规定是否可让用户调整元素的尺寸</li><li><code>textarea</code>表示多行文本框，拖动它的右下角可调整尺寸</li><li>写法：<code>textarea:none;</code></li></ul><h3 id="九、calc函数"><a href="#九、calc函数" class="headerlink" title="九、calc函数"></a>九、calc函数</h3><ul><li>用于动态计算长度值</li><li>写法：<code>width:calc(100px + 200px);</code></li><li>使用要点：<ul><li>支持<code>+</code>、<code>-</code>、<code>*</code>、<code>/</code>运算</li><li>运算符前后都需要保留一个空格，否则不生效，<code>*</code>、<code>/</code>可以没有空格，但建议有</li><li>任何长度值都可以使用calc()函数进行计算</li><li>可以使用百分比、px、em、rem等单位</li><li>使用标准的数学运算优先级规则</li></ul></li></ul><h3 id="十、var函数"><a href="#十、var函数" class="headerlink" title="十、var函数"></a>十、var函数</h3><ol><li><code>:root</code>选择器</li></ol><ul><li>用于匹配文档的htmlm根元素</li><li>与html选择器的区别在于：<code>:root</code>选择器的优先级要高于html标签选择器</li></ul><ol start="2"><li>var函数解读</li></ol><ul><li>var函数用于插入自定义的属性值</li><li>如果一个属性值在<strong>多处</strong>被使用，该方法就很有用</li><li>自定义属性一定要以<code>--</code>开头</li><li>&#x3D;&#x3D;就近原则&#x3D;&#x3D;，自定义属性会沿着父元素一直往外找，以最近找到的为主</li><li>应用场景：<ul><li>通常自定义属性值是写在:root选择器中，并且:root选择器会放在css的最上面，这样所有选择器就能用到这个自定义变量属性</li></ul></li><li>写法：</li></ul><pre><code>:root&#123;    &lt;!-- 自定义属性 --&gt;    --font-color:red;&#125;h3&#123;    color:var(--font-color);&#125;</code></pre><h3 id="十一、专项案例训练"><a href="#十一、专项案例训练" class="headerlink" title="十一、专项案例训练"></a>十一、专项案例训练</h3><ol><li>CSS开发天猫登录注册页<blockquote><p>没想到的地方</p></blockquote></li></ol><ul><li>天猫logo和登录框放在一个盒子里居中</li><li>表单元素：<code>option</code>、<code>input</code></li><li>区号部分：<ul><li>select：背景为选择图标，字体颜色设置为透明，宽高设置为图标大小</li><li>option：字体颜色为黑色</li></ul></li></ul><pre><code>&lt;dix class=&quot;box&quot;&gt; &lt;i&gt;+86&lt;/i&gt; &lt;select name=&quot;&quot; id=&quot;&quot;&gt; &lt;option value=&quot;+86&quot;&gt;+86中国大陆&lt;/option&gt;&lt;/select&gt;&lt;/div&gt;</code></pre><ul><li><code>pointer-events:none;</code>：盒子不受指针、click的影响</li><li>span标签之间的间隙：父盒子font-size&#x3D;0；</li><li>有些地方可以用怪异盒模型</li><li>最后一行可以用<code>text-align:right</code>水平居右，还有<code>cursor:pointer</code></li></ul><blockquote><p>需要用到JS的地方</p></blockquote><ul><li>区号，i绑定ption的value</li><li>登录方式的切换</li></ul><ol start="2"><li>CSS表格布局(QQ音乐排行榜效果)<blockquote><p>老师做的：</p></blockquote></li></ol><ul><li>用table标签</li><li>边框处理：缩小边距——<code>border-spacing:0</code>,边框重合——<code>border-collapse:collapse</code></li><li>不同列单独设置：在table和tr之间写上下面的代码，span表示<strong>选多少列</strong>，class是各列的类名</li></ul><pre><code>&lt;table&gt;  &lt;colgroup&gt;    &lt;col span=&quot;&quot; class=&quot;&quot;&gt; &lt;/clogroup&gt;</code></pre><ul><li>滑动效果：歌名变色，出现三个按钮，歌曲介绍有省略号<ul><li>三个按钮用display</li><li>省略号：滑动之后宽度缩短，并用单行文本溢出省略代码</li></ul></li><li>第三列不能设置宽度，自适应。用right、left</li></ul><h2 id="transtion过渡动画与animation自定义动画"><a href="#transtion过渡动画与animation自定义动画" class="headerlink" title="transtion过渡动画与animation自定义动画"></a>transtion过渡动画与animation自定义动画</h2><h3 id="一、transition过渡动画"><a href="#一、transition过渡动画" class="headerlink" title="一、transition过渡动画"></a>一、transition过渡动画</h3><blockquote><p><strong>如何理解过渡动画？</strong></p></blockquote><ul><li>一个元素由A状态经过一段时间变化成B状态。我们只需要定义其开始和结束的状态</li><li>而它中间的状态会自己添加”补间动画”</li><li>以前，网页的特效基本都是由JS定时器实现的，现在追捕改为使用CSS3过渡</li><li>优点：动画更细腻，内存开销小</li><li>兼容性：移动PC都兼容，但是需要加上对应的浏览器前缀<br><strong>过渡动画何时发生？</strong></li><li>当属性值发生变化时，才会触发transition动画</li><li>transition动画主要与<code>:hover</code>配合，来实现鼠标滑动动画效果</li></ul><ol><li>基本语法<blockquote><p><code>transition:transition-property transition-duration [transition-timing-function] [transition-delay];</code></p><ul><li>后面两个可以省略不写</li></ul></blockquote></li></ol><table><thead><tr><th>属性</th><th>描述</th></tr></thead><tbody><tr><td><code>transition-property</code></td><td>指定CSS属性的name，哪些属性要过渡</td></tr><tr><td><code>transition-duration</code></td><td>transition效果需要指定多少秒或毫秒才能完成，动画时间</td></tr><tr><td><code>transition-timing-function</code></td><td>指定transition效果的转速曲线，变化曲线</td></tr><tr><td><code>transition-delay</code></td><td>定义transition效果开始的时候(延迟时间)</td></tr></tbody></table><ol start="2"><li>可参与过渡的属性<blockquote><p><strong>可参与过渡的属性</strong></p></blockquote></li></ol><ul><li>所有数值类型的属性，都可参与过度</li><li>比如：width、height、left、top、border-radius、font-size、opacity </li><li>背景颜色和文字都可以被过渡</li><li>所有的变形(包括2D和3D)都能被过渡</li><li>在CSS中90%的属性都可以辈过渡<blockquote><p><strong>不能</strong>参与过渡动画的属性</p></blockquote></li><li>float和position</li><li>display无法过渡</li><li>font-family等</li></ul><ol start="3"><li>特殊属性：all</li></ol><ul><li>需要所有属性参与过渡，即定义为all</li><li>all不要随意使用，会引发效率问题，如果只需要某一个属性过渡，还是要指定特定的属性</li></ul><ol start="4"><li>定义多个过渡动画</li></ol><ul><li>多个过渡动画之间用<code>,</code>隔开</li></ul><ol start="5"><li>过渡的四个小属性<table><thead><tr><th>属性</th><th>描述</th></tr></thead><tbody><tr><td><code>transition-property</code></td><td>指定CSS属性的name，哪些属性要过渡</td></tr><tr><td><code>transition-duration</code></td><td>transition效果需要指定多少秒或毫秒才能完成，动画时间</td></tr><tr><td><code>transition-timing-function</code></td><td>指定transition效果的转速曲线，变化曲线</td></tr><tr><td><code>transition-delay</code></td><td>定义transition效果开始的时候(延迟时间)</td></tr></tbody></table></li></ol><ul><li>多个值之间用逗号隔开，没有指定的值，以属性第一个值为准</li></ul><ol start="6"><li>时间函数</li></ol><ul><li>时间函数(transition-timing-function),管理着动画在单位帧内播放的速度曲线<blockquote><p><strong>时间函数的预设值</strong></p><table><thead><tr><th>值</th><th>描述</th></tr></thead><tbody><tr><td><code>linear</code></td><td>规定以相同速度开始至结束的过渡效果cubic-bezier(0,0,1,1)</td></tr><tr><td><code>ease</code></td><td>规定慢速开始，然后变快，然后慢速结束的过渡效果(cubic-bezier(0.25,0.1,0.25,1))</td></tr><tr><td><code>ease-in</code></td><td>规定以慢速开始的过渡效果cubic-bezier(0.42,0,1,1)</td></tr><tr><td><code>ease-out</code></td><td>规定以慢速结束的过渡效果cubic-bezier(0,0,0.58,1)</td></tr><tr><td><code>ease-in-out</code></td><td>等于以慢速开始和结束的过渡效果cubic-bezier(0.42,0,0.58,1)</td></tr><tr><td><code>cubic-bezier(n,n,n,n)</code></td><td>在cubic-bezier函数中定义自己的值，0~1之间</td></tr></tbody></table></blockquote></li></ul><blockquote><p>贝塞尔曲线用法</p></blockquote><ul><li>官方网址上在线生成<a href="https://cubic-bezier.com/">https://cubic-bezier.com/</a></li><li>还可以在网页上右击审查元素，在代码的控制面板当中来调整贝塞尔曲线，来调节运动速度</li></ul><h3 id="二、transition过渡动画实战案例"><a href="#二、transition过渡动画实战案例" class="headerlink" title="二、transition过渡动画实战案例"></a>二、transition过渡动画实战案例</h3><ol><li>鼠标滑动，背景从透明到半透明效果</li><li>鼠标滑动，文字从下往上滑动效果</li></ol><ul><li>父盒子设置相对定位、overflow-hidden</li><li>用盒子装文字，设置绝对定位，鼠标滑动时bottom改变</li></ul><ol start="3"><li>商城右侧通栏导航</li></ol><ul><li>鼠标滑动后出现的框，在点击之前，宽度&#x3D;0，字体颜色为透明色</li></ul><h3 id="三、animation自定义动画"><a href="#三、animation自定义动画" class="headerlink" title="三、animation自定义动画"></a>三、animation自定义动画</h3><blockquote><p>步骤：先定义动画，再调用动画</p></blockquote><ol><li>动画的定义<blockquote><p><strong>使用<code>@keyframes</code>关键帧来定义动画</strong></p></blockquote></li></ol><ul><li>建动画的原理是，将一套CSS样式逐渐变化为另一套样式</li><li>在动画过程中，您可以多次更改CSS样式的设定</li><li>动画执行各阶段时间，可以通过百分比来规定改变发生的时间，或者通过关键词<code>from</code>和<code>to</code></li><li><code>from</code>和<code>to</code>等价于0%和100%,from和0%是动画的开始时间，to和100%是动画的结束时间</li><li>动画名是自己起的</li><li>写法</li></ul><pre><code>@keyframes 动画名&#123;&lt;!-- 起始状态 --&gt;from/0% &#123;样式&#125;&lt;!-- 结束状态 --&gt;to/100%&#123;样式&#125;&#125;</code></pre><ol start="2"><li>调用动画<blockquote><p>使用animation属性</p></blockquote></li></ol><ul><li>写法：</li><li>复合写法：<ul><li>简单版：</li><li><pre><code></code></pre></li><li>animation:动画名 动画完成时间 时间函数 延迟时间；</li><li><pre><code></code></pre></li><li>完整版：</li><li><pre><code></code></pre></li><li>animation:动画名 动画完成时间 时间函数 延迟时间 播放次数 是否反向播放 动画不播放或完成时状态 动画是否正在运行或已暂停；</li></ul></li><li>类似transition</li></ul><ol start="3"><li>多关键帧动画</li></ol><ul><li>用百分比分别表示动画执行的时间节点</li><li>设置多个时间节点，每个节点都可以设置不同状态</li></ul><ol start="4"><li>animation完整写法——小属性<table><thead><tr><th>属性</th><th>说明</th><th>属性值</th></tr></thead><tbody><tr><td><code>animation-name</code></td><td>指定应用的一系列动画名，即@keyframes定义的动画名</td><td>none表示不调用动画，动画名：由大小写敏感的字母a-z、数字0-9、下划线、短横线组成，不能以数字开头</td></tr><tr><td><code>animation-duration</code></td><td>指定动画周期时长，需要多少秒或毫秒完成</td><td>默认值为0s，表示无动画。时长单位为秒(s)&#x2F;毫秒(ms)</td></tr><tr><td><code>animation-timing-function</code></td><td>设置动画将如何完成一个周期</td><td>和transition一致的linear、ease、ease-in、ease-out、ease-in0out、贝塞尔函数；不一样的是steps(n,start&#x2F;end)</td></tr><tr><td><code>animation-delay</code></td><td>设置动画在启动前的延迟间隔时间</td><td>默认为0s，表示立即执行；时长单位为s&#x2F;ms</td></tr><tr><td><code>animation-iteration-count</code></td><td>定义动画的播放次数</td><td>n:一个数字，动画播放次数；<code>infinite</code>无限次播放</td></tr><tr><td><code>animation-direction</code></td><td>指定是否应该轮流反向播放动画</td><td><code>normal</code>:默认值，动画正常播放；<code>reverse</code>:动画反向播放，动画按步后退的效果；<code>alternate</code>:动画在奇数次正向播放，在偶数次反向播放；<code>alternate-reverse</code>:东湖在奇数次反向播放，在偶数次正向播放；</td></tr><tr><td><code>animation-fill-mode</code></td><td>规定当动画不播放时(动画完成时&#x2F;动画延迟未播放时)，要应用到的元素的样式</td><td><code>none</code>:默认值，动画在动画执行之前和之后不会应用任何样式到目标元素；<code>forwards</code>:在动画结束后，动画将停止在最后结束状态；<code>backwards</code>:在动画结束后，动画将停止在最开始的状态；<code>both</code>:动画遵循<code>forwards</code>和<code>backwards</code>的规则，也就是说，动画会在两个方向上扩展动画属性</td></tr><tr><td><code>animation-play-state</code></td><td>指定动画是否正在运行或已暂停</td><td><code>pause</code>:暂停动画；<code>running</code>:正在运行动画；</td></tr></tbody></table></li></ol><blockquote><p><code>animation-play-state</code>通常与<code>:hover</code>配合使用，当鼠标划上去时，可以暂停或开启动画</p></blockquote><ol start="5"><li>animation指定多组动画</li></ol><ul><li>用来指定一组或多组动画时，每组之间用逗号分隔</li></ul><ol start="6"><li>steps帧动画</li></ol><ul><li>steps定义一个动画从开始到结束，动画的<strong>每一帧</strong>中经历的步数</li><li>steps的特殊性：它设置的是<strong>每一步</strong>动画的跳跃步数，而不是整个动画的跳跃步数</li><li><code>start</code>:开始是在第一帧动画结束的位置</li><li><code>end</code>:开始是在第一帧动画开始的位置</li><li>盒子的右侧是起始点<blockquote><p>走路案例</p></blockquote></li><li>移动的是background-position</li></ul><ol start="7"><li>transition与animation的区别</li></ol><ul><li>1、transition是过渡，是样式值得变化过程，只有开始和结束；animation其实也叫关键帧，通过和@keyframe结合可以设置中间帧的状态</li><li>2、animation配合@keyframe可以不通过触发事件直接触发过程，而transition需要通过hover或者js事件来配合触发</li><li>3、animation可以设置很多的属性，比如循环次数、动画的结束状态等等，transition只能触发一次</li><li>4、animation可以结合@keyframe设置每一帧，但transition只有开始和结束这两帧</li></ul><h3 id="四、animationn-css动画库"><a href="#四、animationn-css动画库" class="headerlink" title="四、animationn.css动画库"></a>四、animationn.css动画库</h3><ol><li><p>是什么？</p><blockquote><ul><li>animation.css是非常强大的跨平台的预设css3动画库</li><li>内置了很多典型的css3动画，兼容性好，使用方便</li><li>英文网：<a href="http://animate.style/(%E8%8B%B1%E6%96%87%E7%BD%91%E6%9B%B4%E5%A5%BD)">http://animate.style/(英文网更好)</a></li></ul></blockquote></li><li><p>怎么用？</p></li></ol><ul><li>1、下载animate.css文件</li><li>2、在页面引入animate.css文件</li></ul><pre><code>&lt;!--引用时，要注意引用入的地址 --&gt;link rel=&quot;stylesheet&quot; href=&quot;./css/animate.css&quot; /&gt;</code></pre><ul><li>3、在网站的右侧选择想要的效果，复制其样式名</li><li>4、在需要应用的元素上加<code>.animate_animated</code>和需要的效果样式名</li></ul><pre><code>&lt;!-- 应用  bounce 这个样式效果 --&gt;&lt;div class=&quot;box animate__animated &gt;animate__bounce&quot;&gt;&lt;/div&gt;</code></pre><blockquote><p>注意：link要写在style前面</p></blockquote><h2 id="transform-2D与3D转换"><a href="#transform-2D与3D转换" class="headerlink" title="transform 2D与3D转换"></a>transform 2D与3D转换</h2><h3 id="一、transform属性"><a href="#一、transform属性" class="headerlink" title="一、transform属性"></a>一、transform属性</h3><ul><li>在CSS中，利用<code>transform</code>这个属性实现对元素的旋转、缩放、倾斜、平移</li><li>transform属性的值可以是<code>none</code>或一个或多个css变换函数</li><li>transform的值不是none时，元素会创建自己的层叠上下文</li></ul><ol><li><p>transform的2D变换函数</p><table><thead><tr><th>属性值</th><th>描述</th><th>实例</th></tr></thead><tbody><tr><td>translate(x,y)</td><td>x,y为长度单位，可以是px也可以是百分比；x表示元素在x轴上的移动量，y表示元素在y轴上的移动量，如果y轴不写，默认为0</td><td>transform:translate(100px,200px)</td></tr><tr><td>translateX(x)</td><td>表示元素在平面x轴上的位移量</td><td>transform:translateX(300px)</td></tr><tr><td>translateY(y)</td><td>表示元素在平面Y轴上的位移量</td><td>transform:translateY(300px)</td></tr><tr><td>rotate(ax)</td><td>ax代表旋转的角度，正角表示顺时针旋转，负角表示逆时针旋转</td><td>transform:rotate(30deg)</td></tr><tr><td>scaleX(x)</td><td>x数字类型，表示元素在x轴上的缩放比</td><td>transform:scaleX(2)</td></tr><tr><td>scaleY(y)</td><td>y数字类型，表示元素在y轴上的缩放比</td><td>transform:scaleY(2)</td></tr><tr><td>scale(x,y)</td><td>当只有x没有y时，则y默认为x，元素在x,y轴上均匀缩放</td><td>transform:scale(2,3)</td></tr><tr><td>skew(ax,ay)</td><td>ax,ay各表示一个角度</td><td>transform:skew(30deg,30deg)</td></tr><tr><td>skewX(ax)</td><td>ax表示一个角度，表示沿着x横坐标扭曲元素的角度，形成水平拉伸效果</td><td>transform:skewX(30deg)</td></tr><tr><td>skewY(ay)</td><td>ay表示一个角度，表示沿着y纵坐标扭曲元素的角度，形成垂直拉伸效果</td><td>transform:skewY(30deg)</td></tr></tbody></table></li><li><p>transform的3D转换属性值</p><table><thead><tr><th>属性值</th><th>描述</th><th>实例</th></tr></thead><tbody><tr><td>translateZ(z)</td><td>元素在3D空间z轴方向上的位移量</td><td>transform:translateZ(200px)</td></tr><tr><td>translate3d(x,y,z)</td><td>分别表示元素在x,y,z轴坐标上的位移量，该值不能使用百分比，如果使用会被认为是无效属性</td><td>transform:translate3d(50px,30px,50px)</td></tr><tr><td>rotateX(ax)</td><td>表示元素绕x轴旋转一定角度，ax表示度数，可以为正，也可以为负</td><td>transform:rotateX(30deg);</td></tr><tr><td>rotateY(ay)</td><td>表示元素绕Y轴旋转一定角度，ay表示度数，可以为正也可以为负</td><td>transform:rotateY(30deg);</td></tr><tr><td>rotateZ(az)</td><td>表示元素绕Z轴旋转一定角度，az表示度数，可以为正也可以为负</td><td>transform:rotateZ(30deg);</td></tr></tbody></table></li></ol><h3 id="二、2D转换"><a href="#二、2D转换" class="headerlink" title="二、2D转换"></a>二、2D转换</h3><ol><li>2D平面</li></ol><ul><li>下图这个x和y轴，就是基于2D平面图形，后期所有的2D动画特效都是在这个2D的平面上操作</li><li>注意事项：<ul><li>元素的左上角坐标为(0,0)</li><li>(0,0)坐标的右方，为x轴的正方向</li><li>(0,0)坐标的下方，为y轴的正方向<img src="2D.png"></li></ul></li></ul><ol><li>translate位移</li></ol><ul><li><p>css中通过给<code>transform</code>添加<code>translate(x,y)</code>、<code>translateX(x)</code>、<code>translateY(y)</code>来实现元素的水平或垂直位移</p></li><li><p><strong>translate(x,y)</strong></p></li><li><p>x和y是长度值length，可以是px，也可以是%百分比</p></li><li><p>x表示元素在x轴上的位移量，为正表示向右移动，为负表示向左移动</p></li><li><p>y表示元素在y轴上的位移量，为正表示向下移动，为负表示向上移动 </p></li><li><p>位移和相对定位非常像，位移也会”在老家留坑”，即会占据原来的位置 </p></li><li><p>同时不会对其他元素造成影响，相当于悬浮在其他元素上</p></li><li><p>创建了自己的层叠上下文</p></li><li><p>长度单位可以为px，也可以为百分比</p></li><li><p>x,y为百分比时，这个百分比是相对元素自身的可视宽高而言的</p></li><li><p>在标准盒子模型下</p><ul><li>水平位移：(width+左右padding+左右border)*x%</li><li>垂直位移：(width+左右padding+左右border)*y%</li></ul></li><li><p>特殊情况：y值不写，默认为0</p><ul><li><code>transform:translate(x)</code>&#x3D;<code>transform:translate(x,0)</code></li></ul></li><li><p><strong>translateX(x)与translateY(y)</strong></p></li><li><p><code>translateX(x)</code>实现元素在X轴的位移量</p></li><li><p><code>translateY(y)</code>实现元素在Y轴的位移量</p></li><li><p>本质上translate(x,y)是translateX与translateY两者的复合写法</p></li><li><p>transform后面如果跟多个变换函数，则各函数之间用<strong>空格</strong>隔开</p></li><li><p><strong>注意</strong></p></li></ul><pre><code>transform:translateX(10px);transform:transformY(10px);</code></pre><blockquote><p>这样写，后面的会覆盖前面的，只有transformY有效</p></blockquote><ul><li><p>正确写法是：<code>transform:translateX(10px) translateY(10px);</code> 用空格隔开</p></li><li><p><strong>translate与绝对定位结合实现元素水平垂直居中</strong></p></li><li><p>先利用绝对定位，<code>top:50%;left:50%;</code></p></li><li><p>再利用translate，&#96;transform:translate(-50%,-50%)</p></li><li><p>相比之前用的margin负值，可以不用知道盒子宽高，调整也不受影响</p></li></ul><ol start="3"><li>缩放scale</li></ol><ul><li><p>写法：<code>transform:scale(ax,ay)</code></p></li><li><p><strong>scale(x,y)</strong></p></li><li><p>xy可以用不带单位的数字或百分比表示，分别表示元素的宽高缩放比</p></li><li><p>值&gt;1：放大；值&lt;1：缩小</p></li><li><p>当只有x，没有y时，y默认为等于x，元素宽高同时均匀缩放</p></li><li><p>百分比是相对于元素的可视宽高而言的</p></li><li><p><strong>scaleX(x)与scaleY(y)</strong></p></li><li><p>本质上scale(x,y)是scaleX(x)与scaleY(y)的复合写法</p></li><li><p><code>transform:scale(x,y)</code>等于<code>transform:scaleX(x) scaleY(y)</code></p></li><li><p>可以利用transform-origin设置变换原点</p></li></ul><ol start="4"><li>斜切skew</li></ol><ul><li>实现元素斜切效果</li><li>写法：&#96;transform:skew(ax,ay)</li><li><code>skewX(ax)</code>:用于水平拉伸，使元素的每个点在水平方向上扭曲一定的角度</li><li><code>skewY(ay)</code>:用于垂直拉伸，使元素的每个点在垂直方向上扭曲一定的角度</li><li>ax,ay表示一个角度</li><li>单位为<code>deg</code>，正负数都可以</li><li>可以利用transform-origin设置变换原点</li></ul><ol start="5"><li>旋转rotate</li></ol><ul><li>元素旋转效果</li><li>写法<code>transform:rotate(ax)</code></li><li><code>ax</code>表示旋转的角度，正数表示顺时针，负数表示逆时针</li><li>单位是<code>deg</code></li><li>在三角形案例中可知，多次改变旋转角度，都是参考<strong>最初</strong>的视角，不是参考上一次旋转！</li><li>可以利用transform-origin设置变换原点</li></ul><ol start="6"><li>设置原点transform-origin</li></ol><ul><li>设置元素的变换原点</li><li>缩放、斜切、旋转都可以设置原点</li><li>默认值：<code>transform-origin:50% 50% 0;</code>，分别表示x,y,z轴，在2D转换中只需要前两个值</li><li>x,y的值可以是px、百分比、关键词</li><li>但z的值只能是px</li></ul><blockquote><p><strong>关键词</strong></p></blockquote><ul><li>类似于<code>background-position</code></li><li>(left,right)、(top,bottom)、center，这三组可以任意搭配<table><thead><tr><th>关键词</th><th>描述</th></tr></thead><tbody><tr><td>默认原点</td><td><code>transform-origin:center</code></td></tr><tr><td>left</td><td>原点为左边框中点，&#x3D;<code>left center</code></td></tr><tr><td>right</td><td>右边框中点，&#x3D;<code>right center</code></td></tr><tr><td>top</td><td>上边框中点，&#x3D;<code>top center</code></td></tr><tr><td>bottom</td><td>下边框中点，&#x3D;<code>bottom center</code></td></tr><tr><td>top left</td><td>原点为左上角，相当于坐标(0 0)</td></tr><tr><td>top right</td><td>元素右上角</td></tr><tr><td>bottom left</td><td>左下角</td></tr><tr><td>bottom right</td><td>右下角</td></tr></tbody></table></li></ul><blockquote><p><strong>数值表示法px</strong></p></blockquote><ul><li>y省略不写时，默认为元素的垂直中心点<blockquote><p><strong>百分比表示法</strong></p></blockquote></li><li>相对的是元素自身的可视宽高而言</li></ul><ol start="7"><li><p>2D转换综合写法顺序问题</p><blockquote><ul><li>同时使用多个变换，其多个变换函数之间用空格隔开</li><li>转换函数的顺序会影响转换的效果，比如先旋转会影响坐标轴方向</li><li>旋转之后，坐标轴也会跟着旋转，位移的方向就要按照旋转后的坐标轴来</li><li>所以当同时使用旋转和位移时，一定要注意书写顺序</li></ul></blockquote></li><li><p>使2D转换有动画效果<br><code>transition:transform 2s;</code></p><blockquote><ul><li>分清楚<code>transition</code>和<code>transform</code></li></ul></blockquote></li></ol><h3 id="2D转换实战应用"><a href="#2D转换实战应用" class="headerlink" title="2D转换实战应用"></a>2D转换实战应用</h3><ol><li><p>旋转的三角形</p><blockquote><p>注意点</p><ul><li>旋转的角度以最原始的状态为基准，而不是参考上一次旋转</li></ul></blockquote></li><li><p>QQ音乐效果</p><blockquote><ul><li>图片、按钮、遮罩层都有动画效果</li><li>隐藏元素的方式：opacity、rgba、display等</li></ul></blockquote></li></ol><h3 id="四、3D转换"><a href="#四、3D转换" class="headerlink" title="四、3D转换"></a>四、3D转换</h3><blockquote><p>在3D动画中，元素是围绕坐标x,y,z轴来变换的</p><ul><li>3D坐标图<img src="3D坐标图.png">- 元素左上角的坐标为(0,0,0)- x轴右边为正方向，y轴下方为正方向，z轴垂直电脑屏幕，射出屏幕的这头为正方向</li></ul></blockquote><ol><li>透视perspective<blockquote><p>没有<strong>透视定义</strong>，不成3D</p><ul><li>透视是指在平面上描绘物体的空间关系的方法或技术</li><li>要在平面上描绘物体的空间立体感，需要遵循透视原理中的近大远小规则</li></ul></blockquote></li></ol><blockquote><p><strong>视点</strong></p><ul><li>当我们站的越远，我们看到的物体就越小 </li><li>css3中3Dtransform透视点是在浏览器的前方<img src="视点.png"></li></ul></blockquote><blockquote><p><strong>perspective属性</strong></p><ul><li>在css3中，用<code>perspective</code>属性来设置透视距，即模拟人站在离屏幕多远的地方来看电脑上显示的元素</li><li>比如：<code>perspective:800px;</code>意思就是在离屏幕800px的地方看到这个元素</li><li>如果元素往z轴正方向移动，离我们越近，看到物体就越大</li><li>如果元素往z轴负方向移动，离我们越远，看到的物体就越小</li><li>注意：<code>perspective</code>这个属性要设置在父元素上面</li></ul></blockquote><ol><li><p>translate3D位移</p><blockquote><ul><li>**translateX(x)、translateY(y)**，与2D位移是一样的效果</li><li>**translateZ(z)**：<ul><li>表示垂直于电脑屏幕方向的位移量</li><li>必须配合<code>perspective</code>属性，用它来定义透视强度</li><li><code>translateZ=0</code>：图形大小正常显示</li><li><code>0 &lt; translateZ &lt; perspective值</code>：图形变大</li><li><code>translateZ &gt;= perspective</code>图片不见，相当于图片在你后面,你肯定是看不见的</li><li><code>translateZ &lt; 0</code>：图形变小</li></ul></li><li>translate3d(x,y,z)<ul><li>表示元素在x,y,z轴三个坐标上的位移量</li><li>z的值不能使用百分比，如使用则会被认为是无效属性</li></ul></li></ul></blockquote></li><li><p>rotate 3D旋转</p><blockquote><ul><li>css中通过给<code>transform</code>添加以下变换函数来实现3D旋转效果<table><thead><tr><th>属性值</th><th>描述</th></tr></thead><tbody><tr><td>rotateX(ax)</td><td>表示元素绕x轴旋转一定的角度，ax表示度数，可正可负</td></tr><tr><td>rotateY(ay)</td><td>表示元素绕y轴旋转一定的角度，ay表示度数，可正可负</td></tr><tr><td>rotateZ(az)</td><td>表示元素绕z轴旋转一定的角度，az表示度数，可正可负</td></tr></tbody></table></li><li>旋转方向</li><li>左手法则：大拇指指向正方向，四指的方向就是旋转的方向<img src="3D旋转.png">>rotateZ(az)和2d转换rotate(ax)效果一样</li></ul></blockquote></li><li><p>transform-style</p><blockquote><table><thead><tr><th>值</th><th>描述</th></tr></thead><tbody><tr><td>flat</td><td>表示所有子元素在2D平面呈现</td></tr><tr><td>preserve-3D</td><td>表示所有子元素在3D空间中呈现</td></tr></tbody></table></blockquote></li></ol><h3 id="五、实战案例"><a href="#五、实战案例" class="headerlink" title="五、实战案例"></a>五、实战案例</h3><ol><li>飞行的火箭<blockquote><ul><li>火箭左上角和右下角方向来回移动</li><li>气流动画效果：旋转后坐标轴变化，线条沿Y轴上下移动，用opacity实现隐藏效果</li></ul></blockquote></li><li>创建3D导航<blockquote><ul><li>关键是改变旋转原点<code>transform-origin</code></li><li>给两个a标签加父盒子.container,鼠标滑动设置在父盒子上</li><li>第二个a标签的初始状态是x轴反方向旋转90度，这样就藏在了第一个盒子下面,而且！它的原点要设置在上边框的中点</li><li>点击父盒子时，往x轴的正方向翻转90度，旋转原点是3D盒子的中心<code>transform-origin:50% 50% 高度的一半</code></li><li>想要有立体效果：在父盒子上加<code>transform-style: preserve-3d;</code></li></ul></blockquote></li><li>翻书效果<blockquote><ul><li>每一页构建一个父盒子，里面放正反两面，点击父盒子翻页</li><li>改变原点为左边框中点</li><li>反面比正面里电脑更远才能显示：改变<code>translateZ(z)</code></li><li>每一页都比前一页层级更低：改变<code>z-index</code>，整本书需要用JS实现</li><li>反面翻过来仍正面显示：在父盒子翻转180度的基础上再翻转180度</li><li>每一页有正反面两面的立体效果：在每页父盒子设置<code>transform-style:preserve-3D</code></li><li>注意位移和旋转的顺序，旋转会改变方向</li></ul></blockquote></li><li>长方体<blockquote><ul><li>将六个面都放在父盒子之中，用绝对定位固定在同一位置；</li><li>父盒子要用3D</li><li>通过位移旋转来移动每个面，先移动再旋转更简单</li><li>左右面若想正面朝外，则移动到合适位置再改变原点旋转</li><li>给父盒子设置旋转动画可以看到3D效果</li></ul></blockquote></li><li>鼠标移入文字划入效果<blockquote><ul><li>没注意到的地方：<ul><li>需要换行的文字，左右间距用绝对定位设置</li></ul></li></ul></blockquote></li><li>鼠标悬停缩放动画<blockquote><ul><li>没考虑到的地方<ul><li>鼠标悬停时的遮罩：缩小0.8，有盒子阴影，白色边框<br>注意：</li><li>遮罩层原本和父盒子宽高一致，加上边框后会偏移</li><li>缩放时是居中缩放，所以遮罩层要向上向下移动边框宽度的距离</li></ul></li></ul></blockquote></li><li>鼠标移入旋转动画<blockquote><p>没想到的地方</p><ul><li>背景模糊：受上一案例影响，只想到用盒子阴影，但本案例并不适合，实际应该滤镜效果<code>filter</code><br>不一致的地方：</li><li>遮罩效果<ul><li>长方形旋转角度：遮罩盒子宽度等于父盒子对角线的长度(勾股定理)，高度自拟，<code>top=-50%</code>，转换原点改为左侧，然后旋转，可以在检查页面调试角度</li><li>旋转效果：原遮罩盒子高度为0，top&#x3D;0,left&#x3D;0;鼠标滑动后再设置效果</li></ul></li></ul></blockquote></li><li>loading动画<blockquote><ul><li>设置var函数：写在style里，或写在行内，用<code>style=--name:值</code>。var函数一定要以<code>--</code>开头，后面接属性名和属性值。</li><li>var与函数运算结合，一定要在外面套上<code>calc()</code></li><li>var函数与动画结合：<code>transform:rotate(calc(var(--i)*40deg))</code></li><li>小圆围成一个大圆：先把小圆都放在父盒子顶部中间，设置原点为父盒子中点，但一定是以起始位置的xy轴为起点<ul><li><code>transform-origin:15px 140px</code>，140px就是大圆的半径<img src="loading动画.png"></li></ul></li><li>小圆轮流亮起：设置延迟效果，也要用到var函数</li></ul></blockquote></li><li>吃豆豆动画效果<blockquote><ul><li>嘴巴咬合效果：两个长方形朝不同方向旋转，父盒子边框变成圆(我一点都没想到！！！)</li><li>豆豆移动效果：盒子阴影!!!+translate+animation</li><li>细节：<ul><li>豆豆和头部都使用定位，豆豆写在后面，所以在头部上面，需要提高头部的层级</li><li>豆豆的移动速度等于嘴巴张合一轮的时间(嘴巴动画要使用alternate)</li></ul></li></ul></blockquote></li><li>鼠标悬停 3D 旋转动画效果<blockquote><ul><li>注意点<ul><li>背面的文字和图片在旋转前就要设置<code>rotate(180deg)</code>，否则在鼠标悬停旋转180度后会恢复初始状态</li></ul></li></ul></blockquote></li><li>3D旋转木马效果<blockquote><ul><li>点击第二个盒子实现旋转效果，其父盒子设置视距，其子盒子放置图片。要想让谁的子盒子有3D效果，就给谁设置<code>transform-style</code></li><li>图片怎么实现环绕效果：用绝对定位使他们都处于中心，先旋转一定的角度，在往z轴的方向移动,var函数+rotateY+translateZ</li></ul></blockquote></li></ol>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CSS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CSS核心知识点（二）</title>
      <link href="/2023/11/29/CSS%E6%A0%B8%E5%BF%83%E7%9F%A5%E8%AF%86%E7%82%B9%EF%BC%88%E4%BA%8C%EF%BC%89/"/>
      <url>/2023/11/29/CSS%E6%A0%B8%E5%BF%83%E7%9F%A5%E8%AF%86%E7%82%B9%EF%BC%88%E4%BA%8C%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<span id="more"></span><h2 id="CSS-display属性、背景属性、其他常用属性"><a href="#CSS-display属性、背景属性、其他常用属性" class="headerlink" title="CSS display属性、背景属性、其他常用属性"></a>CSS display属性、背景属性、其他常用属性</h2><h3 id="一、display属性"><a href="#一、display属性" class="headerlink" title="一、display属性"></a>一、display属性</h3><h4 id="display属性的作用"><a href="#display属性的作用" class="headerlink" title="display属性的作用"></a>display属性的作用</h4><blockquote><p><code>display</code>属性可以设置元素的<strong>内部</strong>和<strong>外部</strong>显示类型</p></blockquote><ul><li>外部显示类型：<ul><li>元素的外部显示类型有block块、inline内联等</li><li>外部显示类型将决定该元素在<strong>流式布局</strong>中的表现</li></ul></li><li>内部显示类型：<ul><li>内部显示类型flex布局、grid网格布局、流失布局等</li><li>元素的内部显示类型可以控制其子元素的布局方式</li></ul></li></ul><blockquote><p>流式布局(文档流或常规流)</p></blockquote><ul><li>它是指在对布局进行任何更改之前(默认情况下)，在页面上显示”块”和”内联”元素的方式</li><li>简单来说，它是一种排版方式，这种排版方式规定了块级和内联元素在页面中如何排版显示</li></ul><blockquote><p>流式布局中<strong>块级元素</strong>排版方式</p></blockquote><ul><li>块级盒子会从包含块的顶部开始，按序<strong>垂直</strong>排列</li><li>同级盒子间的垂直距离会由<code>margin</code>属性决定</li><li>相邻两个块级盒子之间的垂直间距会遵循外边距折叠原则被折叠</li></ul><blockquote><p>流式布局中<strong>内联元素</strong>排版方式</p></blockquote><ul><li>盒子会从包含块的顶部开始，按序<strong>水平</strong>排列</li><li>只有水平外边距、边框和内边距会被保留</li><li>这些盒子可以以不同方式在垂直方向上对齐：可以底部对齐或顶部对齐，或者按文字底部进行对齐</li></ul><h4 id="元素外部显示类型"><a href="#元素外部显示类型" class="headerlink" title="元素外部显示类型"></a>元素外部显示类型</h4><blockquote><p>display通过以下属性值来制定元素的显示类型</p></blockquote><ul><li>bolck 块级</li><li>inline-block 行内块</li><li>inline 行内</li></ul><blockquote><p>元素显示类型分为：块级和内联等<br>内联(行内)元素又分为：inline内联元素和inline-block行内块元素(可替换元素)</p></blockquote><ol><li>block块级元素</li></ol><ul><li>常见的块级元素有：<br><code>p</code>、<code>div</code>、<code>ul</code>、<code>ol</code>、<code>li</code>、<code>h</code>、<code>dl</code>等</li><li>块级元素的特点<ul><li>独占一行</li><li>可以设置宽高</li><li>在不设置宽高的情况下，宽默认为父元素内容区宽</li><li>一般来说块级元素里可以放任意元素，不过文字类元素标签内不能放其他块元素：<ul><li>p标签里不能放p和div标签</li><li>h1~h6标签里不能放p,div标签</li></ul></li></ul></li></ul><ol start="2"><li>inline-block行内块元素</li></ol><ul><li>以下元素具有行内块元素的特性，但本质上叫”可替换元素”(归类归到行内元素):<br> <code>img</code>、<code>表单类元素</code>、<code>video</code>、<code>audio</code>等</li><li>行内块元素的特点 <ul><li>相邻的行内块元素&#x2F;行内元素会在一行显示、放不下时会换行</li><li>相邻的行内块元素之间会有<strong>空白间隙</strong>(后面有案例解决这个问题)</li><li>元素默认宽为它本身内容宽</li><li>可设置width、height属性</li></ul></li></ul><ol start="3"><li>inline内联&#x2F;行内元素</li></ol><ul><li>常见的行内元素有：<code>a</code>、<code>strong</code>、<code>span</code>、<code>i</code>、<code>del</code>等</li><li>行内元素特点：<ul><li>相邻的行内元素会在一行显示，放不下时会换行显示</li><li>宽高的设置是无效的，其宽高随内容撑开</li><li>行内元素只能放文本或其他行内元素</li></ul></li><li>注意<ul><li><code>&lt;a&gt;</code>标签里不能再放<code>&lt;a&gt;</code>标签</li><li>但<code>&lt;a&gt;</code>标签里可以放块级元素</li><li>实际开发中，在某些情况下会把a标签转换为块级元素</li></ul></li></ul><blockquote><p>总结:三种元素类型对比</p><table><thead><tr><th>元素类型</th><th>排列方式</th><th>盒模型属性</th><th>内容</th></tr></thead><tbody><tr><td>块级block</td><td>独占一行</td><td>宽高有效</td><td>任意元素，p&#x2F;h特别</td></tr><tr><td>行内块line-block</td><td>不独占</td><td>可设置高</td><td>行内或行内块元素</td></tr><tr><td>内联inline</td><td>不独占</td><td>宽高设置无效</td><td>行内&#x2F;文本元素，a特别</td></tr></tbody></table></blockquote><ol start="4"><li>相互转换</li></ol><ul><li><code>display:block;</code>将元素转换为块级元素</li><li><code>diaplay:inline;</code>将元素转换为行内元素</li><li><code>display：inline-block</code>将元素转换为行内块</li></ul><ol start="5"><li>隐藏元素<table><thead><tr><th>属性</th><th>功能</th><th>描述</th></tr></thead><tbody><tr><td><code>diaplay:none;</code></td><td>隐藏元素</td><td>可以将元素隐藏；只要父元素隐藏，子孙元素就没有任何办法可见。元素隐藏后不会占空间，就好比页面中没有加过这个元素</td></tr><tr><td><code>display:hidden：</code></td><td>隐藏元素</td><td>将元素隐藏；如果父元素隐藏，子孙元素会隐藏，但是给子孙加上<code>visibility:visible;</code>时，子孙可见；隐藏后仍占其位置，会留下空白区域。基本不用</td></tr></tbody></table></li></ol><ul><li>注：<code>display</code>除<code>none</code>以外的值，均为显示元素</li></ul><ol start="6"><li>常见大厂面试题</li></ol><ul><li><code>display:none;</code>和<code>visibility:hidden;</code>二者的区别？<table><thead><tr><th>区别</th><th>display:none;</th><th>visibility:hidden;</th></tr></thead><tbody><tr><td>空间占据性</td><td>不占空间</td><td>占空间</td></tr><tr><td>回流与渲染性</td><td>会产生回流与重绘</td><td>不会产生回流，只会产生重绘</td></tr><tr><td>对子孙元素的影响</td><td>子孙元素全部不可见，并没有任何办法可见</td><td>子孙元素全部不可见，但是加上<code>visibility:visible；</code>就可见</td></tr></tbody></table></li></ul><ol start="7"><li>去掉行内块元素默认的空白间隙<blockquote><p>产生间隙的原因</p></blockquote></li></ol><ul><li>元素被当成行内元素排版的时候，元素之间的空白符(空格&#x2F;回车、换行等)都会被浏览器处理</li><li>根据white-space的处理方式(默认为normal，合并多余空白)，原来HTML代码中的空白符被转换成了一个空白符，所以元素之间出现了空隙</li><li>这些元素之间的间距会随着字体的大小而变化</li></ul><blockquote><p>解决办法</p></blockquote><ul><li>给父元素加上<code>font-size:0px;</code>,给子元素重写<code>font-size</code></li><li>给元素添加<code>float</code></li><li>图片间的空隙，给图片添加<code>display:block;</code>变成块级元素后，独占一行，空白间隔消失;更好的办法是添加<code>vertical-align:top;</code></li></ul><h3 id="二、background背景属性"><a href="#二、background背景属性" class="headerlink" title="二、background背景属性"></a>二、background背景属性</h3><h4 id="background-color背景颜色"><a href="#background-color背景颜色" class="headerlink" title="background-color背景颜色"></a>background-color背景颜色</h4><ul><li>背景颜色可以用十六进制、rgb()、rgba()、英文单词表示</li><li>padding区域是有背景颜色的</li></ul><h4 id="background-image图片"><a href="#background-image图片" class="headerlink" title="background-image图片"></a>background-image图片</h4><ul><li>用于设置背景图片</li><li>图片路径要写在<code>url()</code>圆括号里，可以是相对路径，也可以是绝对路径</li><li>地址相对路径是从CSS样式的位置出发(特别注意外部样式)</li><li>写法：<code>background-image: url();</code></li></ul><h4 id="background-repeat重复"><a href="#background-repeat重复" class="headerlink" title="background-repeat重复"></a>background-repeat重复</h4><ul><li>用来设置背景图片的重复模式</li><li>属性值<table><thead><tr><th>值</th><th>描述</th></tr></thead><tbody><tr><td><code>repeat;</code></td><td>x,y均平铺(默认)</td></tr><tr><td><code>repeat-x;</code></td><td>x平铺</td></tr><tr><td><code>repeat-y;</code></td><td>y平铺</td></tr><tr><td><code>no-repeat;</code></td><td>不平铺</td></tr></tbody></table></li></ul><h4 id="background-position-背景图片位置"><a href="#background-position-背景图片位置" class="headerlink" title="background-position 背景图片位置"></a>background-position 背景图片位置</h4><ul><li><p>用来控制背景图片在盒子中&#x3D;&#x3D;显示&#x3D;&#x3D;的开始位置</p></li><li><p>背景图片位置默认是从padding区开始计算，要将内边距算进去</p></li><li><p>写法：<code>background-position:  ;</code></p></li><li><p>位置表示法</p><table><thead><tr><th>写法</th><th>类型</th><th>说明</th></tr></thead><tbody><tr><td>数值表达法(x y)</td><td>两个值</td><td>x：与盒子左边距离 y与盒子上边距离</td></tr><tr><td>数值表达法(x)</td><td>单个值</td><td>数值只表示x，垂直方向居中显示</td></tr><tr><td>百分比表达法(x% y%)</td><td>两个值</td><td>左偏移量&#x3D;(容器width+左右padding-背景图width)<code>*</code>百分比,上偏移量&#x3D;(容器height+上下padding-背景图height)<code>*</code>百分比</td></tr><tr><td>百分比表达法(x%)</td><td>单个值</td><td>该值表示x%，垂直方向水平居中</td></tr><tr><td>关键字表达法</td><td>两个值</td><td>垂直方向 水平方向</td></tr><tr><td>关键字表达法</td><td>单个值</td><td>center被省略</td></tr></tbody></table></li><li><p>负值情况：</p><ul><li>在数值和百分比表达法下，可以使用负值</li><li>右是水平的正方向，<strong>下是垂直的正方向</strong>。所以负值代表向左、向上移动</li></ul></li><li><p>关键词表达法<br>可以用<code>(top、bottom)</code>、<code>(center)</code>、<code>(left、right)</code>三组中的任意两个组的一个值进行组合，也可以用单个值</p><ul><li>单一关键字与对应组合关键字表示法<table><thead><tr><th>单一关键字</th><th>等价的组合关键字</th></tr></thead><tbody><tr><td>center</td><td>center center</td></tr><tr><td>top</td><td>top center或center top</td></tr><tr><td>bottom</td><td>bottom center或center bottom</td></tr><tr><td>left</td><td>left center或center left</td></tr><tr><td>right</td><td>right center或center right</td></tr></tbody></table></li></ul></li></ul><h4 id="background复合属性"><a href="#background复合属性" class="headerlink" title="background复合属性"></a>background复合属性</h4><blockquote><ul><li><code>background-color</code>、<code>background-image</code>、<code>background-repeat</code>、<code>background-position</code>可以进行合写</li><li>不包括background-size&#x2F;clip&#x2F;origin&#x2F;attachment!!!</li><li>合写用的非常多，而其中的单条一般用来进行层叠</li><li>写法：<br><code>background:red url() no-repeat 10px 20px;</code></li><li>复合写法中，省略未写的值会以默认值替代<ul><li>背景色默认为透明色</li><li>背景图片默认为没有</li><li>重复默认为左右平铺</li><li>图片位置默认为0% 0%</li></ul></li></ul></blockquote><h4 id="CSS精灵图"><a href="#CSS精灵图" class="headerlink" title="CSS精灵图"></a>CSS精灵图</h4><blockquote><ul><li>将多个小图标合并制作在一张图上</li><li>使用<code>background-position</code>属性单独显示其中一个</li><li>这样的技术叫做CSS精灵技术，也叫作CSS雪碧图</li><li>CSS精灵可以减少HTTP请求数，加快网页显示速度，但缺点也很明显：不方便测量，后期改动麻烦</li><li>适用于小图，大图不合适</li><li>使用Pxcook测量距离,注意正负值</li></ul></blockquote><h4 id="background-attachment-背景固定"><a href="#background-attachment-背景固定" class="headerlink" title="background-attachment 背景固定"></a>background-attachment 背景固定</h4><blockquote><table><thead><tr><th>属性值</th><th>描述</th></tr></thead><tbody><tr><td><code>scroll</code></td><td>默认值，背景图片相对于元素本身固定，但随页面滚动而滚动</td></tr><tr><td><code>fixed</code></td><td>背景相对于视口固定。即使一个元素拥有滚动机制，背景也不会随着元素的内容滚动</td></tr><tr><td><code>local</code></td><td>背景相对于元素的内容固定，如果一个元素拥有滚动机制，背景会随元素的内容滚动，同时背景图片随着页面的滚动而滚动</td></tr></tbody></table></blockquote><blockquote><ul><li>srcoll <img src="scroll.gif">背景图随页面滚动条移动，但不随元素内容移动</li><li>fixed <img src="fixed.gif">背景图固定在页面左上角，不随元素且不随页面滚动</li><li>local <img src="local.gif">背景图随页面一起滚动，也随元素内容滚动</li></ul></blockquote><h4 id="background-size背景尺寸"><a href="#background-size背景尺寸" class="headerlink" title="background-size背景尺寸"></a>background-size背景尺寸</h4><blockquote><p><code>backgroung-size: ;</code></p><table><thead><tr><th>属性值</th><th>说明</th></tr></thead><tbody><tr><td>x y</td><td>分别表示背景图的宽高</td></tr><tr><td>x% y%</td><td>百分比是相对于盒子的宽高而言</td></tr><tr><td>x auto</td><td>x可以是数值也可以是百分比，auto是相对于宽来自动缩放</td></tr><tr><td>contain</td><td>背景图片智能改变尺寸以容纳到盒子里，把图片全部展示出来</td></tr><tr><td>cover</td><td>智能改变尺寸以撑满盒子，填充盒子的每个角落</td></tr></tbody></table></blockquote><h4 id="background-clip"><a href="#background-clip" class="headerlink" title="background-clip"></a>background-clip</h4><blockquote><ul><li>设置元素的背景(图片或颜色)是否延展到边框、内边距、内容<table><thead><tr><th>值</th><th>说明</th></tr></thead><tbody><tr><td>border-box</td><td>默认值，背景绘制在边框方框内</td></tr><tr><td>padding-box</td><td>背景绘制在内边距方框内</td></tr><tr><td>content-box</td><td>背景绘制在内容方框内</td></tr><tr><td>text</td><td>背景被裁剪成文字的前景色</td></tr></tbody></table></li><li>使用text时，要将文字颜色设置为透明才能看到效果</li></ul></blockquote><pre class=" language-css"><code class="language-css"><span class="token number">.</span>box<span class="token number">4</span> &amp;<span class="token hexcode">#123</span><span class="token punctuation">;</span>    <span class="token property">width</span><span class="token punctuation">:</span> <span class="token number">300</span>px<span class="token punctuation">;</span>    <span class="token property">height</span><span class="token punctuation">:</span> <span class="token number">300</span>px<span class="token punctuation">;</span>    <span class="token property">margin</span><span class="token punctuation">:</span><span class="token number">20</span>px<span class="token punctuation">;</span>    <span class="token property">padding</span><span class="token punctuation">:</span><span class="token number">30</span>px<span class="token punctuation">;</span>    <span class="token property">border</span><span class="token punctuation">:</span> <span class="token number">50</span>px solid <span class="token function">rgba</span><span class="token punctuation">(</span><span class="token number">0</span>, <span class="token number">0</span>, <span class="token number">0</span>, <span class="token number">0.2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">/* background-image:linear-gradient(to right,red, blue, green); */</span>    <span class="token property">background-image</span><span class="token punctuation">:</span> <span class="token url">url(../../src/image/peakflower.webp)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">/* 背景被裁剪成文字的前景色,可以用渐变或图片*/</span>    <span class="token property">background-clip</span><span class="token punctuation">:</span>text<span class="token punctuation">;</span>    <span class="token property">-webkit-background-clip</span><span class="token punctuation">:</span>text<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">/* 除文字下的背景以外都隐藏 */</span>     <span class="token property">color</span><span class="token punctuation">:</span><span class="token function">rgba</span><span class="token punctuation">(</span><span class="token number">0</span>, <span class="token number">0</span>, <span class="token number">0</span>, <span class="token number">0.1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token comment" spellcheck="true">/* 文字颜色设置为透明 */</span>&amp;<span class="token hexcode">#125</span><span class="token punctuation">;</span></code></pre><h4 id="background-origin"><a href="#background-origin" class="headerlink" title="background-origin"></a>background-origin</h4><blockquote><ul><li>背景图片的定位区域<table><thead><tr><th>值</th><th>描述</th></tr></thead><tbody><tr><td>padding-box</td><td>背景图片的摆放以padding区域为参考(默认值)</td></tr><tr><td>border-box</td><td>背景图片的摆放以border区域为参考</td></tr><tr><td>content-box</td><td>背景图片的摆放以content区域为参考</td></tr></tbody></table></li></ul></blockquote><img src="origin.png"><h3 id="三、线性渐变"><a href="#三、线性渐变" class="headerlink" title="三、线性渐变"></a>三、线性渐变</h3><ul><li>在background-image属性下，创建线性渐变背景</li><li>用<code>,</code>分隔方向和不同颜色<br><code>background-image:linear-gradient(direction,color);</code><table><thead><tr><th>值</th><th>描述</th></tr></thead><tbody><tr><td><code>direction</code></td><td>指定渐变的方向</td></tr><tr><td><code>color</code></td><td>用于指定渐变的起止颜色</td></tr></tbody></table></li></ul><ol><li>方向</li></ol><ul><li>未设置角度：则默认从上而下渐变</li><li>用关键词来指定渐变方向<ul><li>to (top,bottom) (left,right)</li></ul></li><li>用度数来指定渐变方向,度数单位为deg,顺时间方向<br><code>background-image:linear-gradient(45deg,red,blue)</code></li></ul><ol start="2"><li>颜色</li></ol><ul><li>多个颜色值，可以用百分数定义纯净的该颜色的起始点，百分数写在颜色后面(颜色的分布范围是从前往起始点渗透)<br>background-img:linear-gradient(red 40%,blue 50%)&#96;</li><li>转换中点是指：两个颜色相互融合的交点</li><li>默认转换中点：两个颜色转换的中点</li><li>自定义转换中点：在两个颜色之间添加未标记的%，以指示颜色的中转位置<br><code>background-img:linear-gradient(red,40%,blue)</code></li><li>未设置0%和100%的终止色<ul><li>默认情况下，如果不带0%终止的颜色，则起始色为声明的第一个颜色</li><li>最后一种颜色将持续到100%标记，或者如果在最后一个没有声明长度时，则在100%标记处</li></ul></li></ul><pre><code>.box7 &#123;    background-image: linear-gradient(yellow,red,blue);    &#125;.box8 &#123;    background-image: linear-gradient(green 0%,20%，yellow ,red,blue,green100%);    &lt;!-- green 0%表示纯净的绿色在0%，但0%处是看不到的所以能看到的是更浅的绿色渗透出来,20%的地方是黄绿两色的转换中点 --&gt;    &#125;</code></pre><ul><li>没有颜色转换的情况<ul><li>纯净色的终止点就是转换中点</li></ul></li></ul><pre><code>.box &#123;    background-image: linear-gradient(yellow 20%,20%,red,blue);    &#125;</code></pre><ol start="3"><li>浏览器私有前缀<blockquote><p>不同浏览器有不同的私有前缀，用来对实验性质的CSS属性加以标识</p><table><thead><tr><th>浏览器</th><th>前缀</th></tr></thead><tbody><tr><td>Chrome浏览器</td><td><code>-webkit-</code></td></tr><tr><td>Firefox火狐</td><td><code>-moz-</code></td></tr><tr><td>IE、Edge</td><td><code>-ms-</code></td></tr><tr><td>欧朋</td><td><code>-o-</code></td></tr></tbody></table></blockquote></li></ol><pre><code>background-image:-webkit-linear-gradient(to top,gold,red)background-image:-moz-linear-gradient(to top,gold,red)background-image:-ms-linear-gradient(to top,gold,red)background-image:-o-linear-gradient(to top,gold,red)</code></pre><ol start="4"><li>渐变色工具<br><a href="https://c.runoob.com/more/gradients/#Omolon">https://c.runoob.com/more/gradients/#Omolon</a></li></ol><h3 id="四、径向渐变"><a href="#四、径向渐变" class="headerlink" title="四、径向渐变"></a>四、径向渐变</h3><blockquote><ul><li>盒子的background-image属性可以用radial-gradient()形式创建径向渐变背景图</li><li>径向渐变由其中心点、边缘形状轮廓、两个或多个色值结束点定义而成</li></ul></blockquote><ol><li>设置颜色节点<br><code>color 10%</code>：设置颜色转换中点<br><code>color,10%,</code>：设置颜色起始点</li><li>设置径向渐变的形状 shape<br><code>ellipse</code>表示椭圆形(默认)<br><code>circle</code>表示圆形</li><li>指定径向渐变中心位置 position<br><code>at 10px 20px</code></li><li>指定不同尺寸的大小<br>|值|描述|<br>|<code>fathest-corner</code>|(默认)：渐变的边缘形状与容器距离渐变中心点最远的一个角相交|<br>|<code>closest-corner</code>|渐变的边缘形状与容器距离渐变中心点最近的一个角相交(水平与垂直边相交)|<br>|<code>fathest-side</code>|与closest-side相反，边缘形状与容器距离渐变中心点最远的一边相切(或最远的垂直或水平边)|<br>|<code>closest-side</code>|圆形：渐变的边缘形状与容器距离渐变中心点最近的一边想切；椭圆：距离渐变中心点最近的垂直和水平边相切|<blockquote><ul><li>径向渐变-椭圆<img src="径向渐变-椭圆.png"></li><li>径向渐变-圆<img src="径向渐变-圆.png"></li><li>注意：<code>shape</code>、<code>position</code>、<code>尺寸的关键词</code>，彼此之间用&#x3D;&#x3D;空格&#x3D;&#x3D;分隔，但是与颜色之间用<code>,</code>分隔。</li></ul></blockquote></li></ol><h3 id="五、背景相关属性的补充"><a href="#五、背景相关属性的补充" class="headerlink" title="五、背景相关属性的补充"></a>五、背景相关属性的补充</h3><blockquote><ul><li><code>background-image/size/position/repeat</code>后面都可以设置多个值，每组值之间用<strong>逗号</strong>分隔<ul><li>每个属性之间用逗号分割的值，都按顺序<strong>一一对应</strong>，如果后面的值没有写，则以当前属性设置的<strong>第一组值</strong>为默认显示</li></ul></li><li>线性渐变&#x2F;径向渐变实质上是绘制背景图片，所以既可以和<code>url()</code>写在一起，又可以被&#96;size&#x2F;position&#x2F;repeat等属性控制</li></ul></blockquote><h3 id="六、其他常用属性"><a href="#六、其他常用属性" class="headerlink" title="六、其他常用属性"></a>六、其他常用属性</h3><h4 id="1-cursor鼠标样式"><a href="#1-cursor鼠标样式" class="headerlink" title="1.cursor鼠标样式"></a>1.cursor鼠标样式</h4><blockquote><ul><li>设置光标的类型，在鼠标指针悬停在元素上时显示相应样式</li><li>可以用属性值设置样式，也可以用图片设置光标样式(即用url自定义)</li><li>使用方式：<code>cursor:url(自定义图片地址),pointer;</code></li></ul></blockquote><table><thead><tr><th>值</th><th>描述</th></tr></thead><tbody><tr><td>url</td><td>需使用的自定义光标的URL.注释:请在此列表的末端始终定义一种普通的光标，一方没有由URL定义的可用光标</td></tr><tr><td>default</td><td>默认光标(通常是一个箭头)</td></tr><tr><td>auto</td><td>默认，浏览器设置的光标</td></tr><tr><td>crosshair</td><td>光标呈现为十字线</td></tr><tr><td>pointer</td><td>光标呈现为指示链接的指针(一只手)</td></tr><tr><td>move</td><td>此光标指示某对象可被移动,四个箭头</td></tr><tr><td>n-resize</td><td>此光标指示矩形框的边缘可被向上(向北)移动</td></tr><tr><td>s-resize</td><td>向下(南)</td></tr><tr><td>w-resize</td><td>向左(西)</td></tr><tr><td>e-resize</td><td>向右(东)</td></tr><tr><td>ne-resize</td><td>东北向</td></tr><tr><td>nw-resize</td><td>西北向</td></tr><tr><td>se-resize</td><td>东南向</td></tr><tr><td>sw-resize</td><td>西南向</td></tr><tr><td>text</td><td>此光标指示文本</td></tr><tr><td>wait</td><td>此光标指示程序正忙(转圈圈&#x2F;一只表&#x2F;沙漏)</td></tr><tr><td>help</td><td>此光标指示可用的帮助(一个问号或一个气球)</td></tr></tbody></table><blockquote><p>关于url这个值需要注意：</p></blockquote><ul><li>图片地址，在实际开发中一般为绝对路径</li><li>图片大小最好是<code>32*32</code>的大小(各浏览器支持大小不一，但32都ok)</li><li>图片格式，不同浏览器格式不一，可以是<code>png</code>、<code>svg</code>、<code>ico</code>、<code>cur</code>，一般以ico和cur为主</li><li>ico在线图标生成器：<code>https://www.bitbug.net/</code><ul><li>文件路径有中文时，可以从浏览器复制地址</li></ul></li></ul><h4 id="2-outline外轮廓"><a href="#2-outline外轮廓" class="headerlink" title="2.outline外轮廓"></a>2.outline外轮廓</h4><blockquote><p>用于设置元素周围的轮廓，其用法与borser属性一样</p><ul><li>语法：<code>outline:1px solid red;</code></li></ul></blockquote><blockquote><p>小属性：</p></blockquote><ul><li><code>outline-width</code>边框宽</li><li><code>outline-style</code>边框风格</li><li><code>outline-color</code>边框颜色</li></ul><blockquote><p><code>outline</code>与<code>border</code>的区别</p></blockquote><ul><li><code>outline</code>不占据空间，绘制于元素内容周围的轮廓，不参与盒子模型的占位计算，不会因为添加这个属性，而造成盒子占位空间变化</li><li><code>outline</code>没办法单独控制某一边效果，也就是没有<code>outline-left</code>等属性</li><li><code>border</code>参与盒子模型计算，会因为边框值的变化而造成盒子占位空间的变化</li></ul><blockquote><p>去掉表单元素默认的<code>outline</code>属性</p></blockquote><ul><li><code>outline</code>的值设置为<code>0</code>或<code>none</code>会移除元素的默认轮廓</li><li>表单元素为了增加其可访问性(聚焦提示)，都有默认的outline值.在点击该元素后会出现黑色的外轮廓<img src="outlin.png"></li></ul><pre><code> input &#123;    outline:none; &#125;</code></pre><h4 id="3-overflow超出部分隐藏"><a href="#3-overflow超出部分隐藏" class="headerlink" title="3.overflow超出部分隐藏"></a>3.overflow超出部分隐藏</h4><blockquote><p>该属性规定当内容一出元素框时该做什么</p></blockquote><ul><li>属性值<table><thead><tr><th>值</th><th>描述</th></tr></thead><tbody><tr><td>visible</td><td>默认值，内容溢出，会呈现在元素框之外</td></tr><tr><td>hidden</td><td>内容溢出，则溢出内容不可见</td></tr><tr><td>scroll</td><td>不管内容是否溢出，都会显示滚动条</td></tr><tr><td>auto</td><td>内容溢出，则显示滚动条以便查看其余内容；若不溢出，则不显示滚动条</td></tr><tr><td>inherit</td><td>规定应该从父元素继承<code>overflow</code>属性的值</td></tr></tbody></table></li></ul><blockquote><p>overflow-x和overflow-y</p></blockquote><ul><li>overflow-x:水平方向溢出设置</li><li>overflow-y:垂直方向溢出设置</li><li>注意：是里面的盒子宽&#x2F;高比外面大，才是出效果，overflow要设置在外面盒子的样式中</li></ul><h4 id="4-vertical-align属性"><a href="#4-vertical-align属性" class="headerlink" title="4.vertical-align属性"></a>4.vertical-align属性</h4><blockquote><p>指定<strong>行内元素、行内块元素、表格单元格元素</strong>的&#x3D;&#x3D;垂直&#x3D;&#x3D;对齐方式</p><ul><li>对<strong>块级元素</strong>是无效的<table><thead><tr><th>属性值</th><th>描述</th></tr></thead><tbody><tr><td>baseline</td><td>使元素的基线与父元素的<strong>基线</strong>对齐</td></tr><tr><td>sub</td><td>使元素的基线与父元素的<strong>下标基线</strong>对齐</td></tr><tr><td>super</td><td>使元素的基线与父元素的<strong>上标基线</strong>对齐</td></tr><tr><td>text-top</td><td>使元素的<strong>顶部</strong>与父元素的<strong>字体顶部</strong>对齐</td></tr><tr><td>text-bottom</td><td>使元素的<strong>底部</strong>与父元素的<strong>字体底部</strong>对齐</td></tr><tr><td>middle</td><td>使元素的中部与父元素的基线加上父元素x-height(x高度)的一半对齐</td></tr><tr><td>数值(px)</td><td>使元素的基线对齐到与父元素的基线之上的给定长度，可以是负数</td></tr><tr><td>百分比</td><td>使元素的基线对齐到父元素的基线至上的给定百分比，该百分比是<code>line-height</code>属性的百分比，可以是负数</td></tr><tr><td>top</td><td>使元素及其后代元素的顶部与整行的顶部对齐</td></tr><tr><td>bottom</td><td>使元素及其后代元素的底部与整行的底部对齐</td></tr></tbody></table></li></ul></blockquote><blockquote><ul><li>小写字母x的下边缘线就是我们的基线</li><li>无论内容中有无x，都是以x下边缘为基线<img src="baseline.png"></li></ul></blockquote><blockquote><p>应用场景</p></blockquote><ul><li>用于控制文字与行内块元素或图片在垂直方向上的对齐方式</li><li>用于设置表格单元中内容的垂直对齐方式</li></ul><blockquote><p>对比</p></blockquote><ol><li>行文本&#x3D;&#x3D;垂直&#x3D;&#x3D;居中<br><code>line-height:盒子高度</code></li></ol><ul><li>对行内块元素无效</li></ul><ol start="2"><li>text-align属性</li></ol><ul><li>定义**行内内容(例如文字、图片、行内块元素)**相对于他的父元素的&#x3D;&#x3D;水平&#x3D;&#x3D;对齐方式</li></ul><ol start="3"><li>vertical-align属性</li></ol><ul><li>指定**行内元素、行内块元素、表格单元格元素的&#x3D;&#x3D;垂直&#x3D;&#x3D;对齐方式</li><li>对于块级元素无效</li></ul><h4 id="5-案例"><a href="#5-案例" class="headerlink" title="5.案例"></a>5.案例</h4><ol><li>常用的a标签布局按钮</li><li>水平居中的轮播图按钮</li><li>常见的产品展示效果-水壶</li><li>常见的分页导航</li><li>小米官网左侧菜单<blockquote><ul><li><code>:hover</code>：鼠标放上去之后变样式</li></ul></blockquote></li><li>精美的Tab选项卡菜单<blockquote><ul><li>圆角</li></ul></blockquote></li></ol><h2 id="CSS盒子模型"><a href="#CSS盒子模型" class="headerlink" title="CSS盒子模型"></a>CSS盒子模型</h2><h3 id="盒子模型"><a href="#盒子模型" class="headerlink" title="盒子模型"></a>盒子模型</h3><h4 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h4><blockquote><ul><li>网页本质上是由一个个盒子模型拼凑而成，每个盒子里放置相关的图片、文字、视频等内容</li><li>所有HTML标签都可以看成矩形盒子，具有盒子模型结构</li><li>盒模型由四个部分组成，分别是:<code>content</code>、<code>padding</code>、<code>border</code>、<code>margin</code></li><li>盒模型有5个属性:宽<code>width</code>、高<code>height</code>、边框<code>boder</code>、内边距<code>padding</code>、外边距<code>margin</code><img src="盒子模型.png"></li><li>注:<code>width</code>、<code>height</code>不是盒子的总宽度，而是内容<code>content</code>的宽高</li></ul></blockquote><h4 id="2-width和height属性"><a href="#2-width和height属性" class="headerlink" title="2. width和height属性"></a>2. width和height属性</h4><blockquote><ul><li>width属性<ul><li>单位:px、移动端开发(百分比、rem等单位)</li><li>如果不设置width,块级元素会被撑满(但不意味着width可以继承，是无法继承的)，非块级元素只能被内容撑开</li><li>块级元素的宽度可以设置，非块级元素无效</li></ul></li><li>height属性<ul><li>如果不设置height属性，它将自动被其内容撑开，若没有内容，则height默认是0</li><li>块级元素的高度可以设置，非块级元素由内容撑开</li></ul></li><li>总结<ul><li>块级元素支持设置宽高，没有设置时，宽度自动撑满它的父元素；高度为内容高度，无内容时<strong>高度</strong>为0；</li><li>内联元素设置宽高无效，没有设置时，宽高由内容决定，无内容时<strong>宽高</strong>默认为0</li></ul></li></ul></blockquote><blockquote><table><thead><tr><th>类型</th><th>元素</th><th>性质</th></tr></thead><tbody><tr><td>块级元素</td><td>h1~h6、p、div、ul&#x2F;ol-li、dtdd、figure、figcaption、form、table、canvas、pre</td><td>独占一行、默认自上而下排列，可以设置宽高</td></tr><tr><td>内联元素&#x2F;行内元素</td><td>a、span、lable、strong、em、mark、datalist</td><td>不会自占一行，宽高由内容撑起</td></tr><tr><td>特殊内联元素&#x2F;行内块级元素&#x2F;可替换元素</td><td>img、audio、video、input、select-option、textarea</td><td>不独占一行，可以设置宽高</td></tr></tbody></table></blockquote><h4 id="3-border属性"><a href="#3-border属性" class="headerlink" title="3. border属性"></a>3. border属性</h4><blockquote><ul><li>三要素:线宽度、线型、线颜色<br> 写法：<code>border:2px solid red</code>;以空格分隔<ul><li>线型:<table><thead><tr><th>常见线型值</th><th>描述</th></tr></thead><tbody><tr><td>solid</td><td>实线</td></tr><tr><td>dashed</td><td>虚线</td></tr><tr><td>dotted</td><td>点状线</td></tr><tr><td>double</td><td>双边框</td></tr><tr><td>groove</td><td>定义3D凹槽边框，效果取决于border-color的值</td></tr><tr><td>ridge</td><td>定义3D垄状边框，效果取决于boder-color的值</td></tr><tr><td>inset</td><td>3D inset 边框，其效果取决于 border-color的值</td></tr><tr><td>outset</td><td>3D outset 边框，其效果取决于 border-color 的值</td></tr><tr><td>none</td><td>无边框</td></tr><tr><td>hidden</td><td>隐藏边框</td></tr></tbody></table></li></ul></li></ul></blockquote><blockquote><ul><li>三要素的小属性：</li><li>注：是为了层叠大属性用的，进行局部修改<table><thead><tr><th>小属性</th><th>描述</th></tr></thead><tbody><tr><td>border-width</td><td>线宽</td></tr><tr><td>border-style</td><td>线型</td></tr><tr><td>border-color</td><td>线颜色</td></tr></tbody></table></li></ul></blockquote><blockquote><ul><li>四个方向的边框<table><thead><tr><th>大属性</th><th>小属性</th><th>描述</th></tr></thead><tbody><tr><td>border-top</td><td>border-top-width&#x2F;style&#x2F;color</td><td>上边框</td></tr><tr><td>border-right</td><td>border-right-width&#x2F;style&#x2F;color</td><td>右边框</td></tr><tr><td>border-bottom</td><td>同上</td><td>下边框</td></tr><tr><td>border-left</td><td>同上</td><td>左边框</td></tr></tbody></table></li><li>去掉边框<br>去掉左边框：<code>border-left:none;</code></li></ul></blockquote><h4 id="4-border的应用场景"><a href="#4-border的应用场景" class="headerlink" title="4. border的应用场景"></a>4. border的应用场景</h4><blockquote><ul><li>制作三角形<ul><li>不输入文字，把宽高设置为0</li><li>边框会聚集成正方形，每一边都是一个三角形，只要把其他三边设置成<code>transparent</code>透明色就可以了</li></ul></li></ul><pre class=" language-css"><code class="language-css">div &amp;<span class="token hexcode">#123</span><span class="token punctuation">;</span> <span class="token property">width</span><span class="token punctuation">:</span><span class="token number">0</span><span class="token punctuation">;</span> <span class="token property">height</span><span class="token punctuation">:</span><span class="token number">0</span><span class="token punctuation">;</span> <span class="token property">border</span><span class="token punctuation">:</span><span class="token number">30</span>px solid transparent<span class="token punctuation">;</span> <span class="token property">border-top-color</span><span class="token punctuation">:</span>red<span class="token punctuation">;</span>&amp;<span class="token hexcode">#125</span><span class="token punctuation">;</span>&lt;body> &lt;div>&lt;/div>&lt;/body></code></pre></blockquote><blockquote><ul><li>圆角属性border-radius<ul><li>该属性单位通常为<code>px</code>，表示圆角的半径</li><li>还可以使用百分比做单位，表示圆角起始于每条边的哪里</li><li>不输入文本内容，设置圆角</li><li>赋值方式：<ul><li>同时设置四个角<code>border-radius:20px;</code></li><li>单独设置四个角<code>border-radius:10px 20px 30px 40px;</code>分别代表“上右下左”</li><li>单独设置每一个角：小属性</li></ul></li></ul></li></ul><table><thead><tr><th>属性</th><th>描述</th></tr></thead><tbody><tr><td><code>border-top-left-radius</code></td><td>左上角</td></tr><tr><td><code>border-top-right-radius</code></td><td>右上角</td></tr><tr><td><code>border-bottom-left-radius</code></td><td>左下角</td></tr><tr><td><code>border-bottom-right-radius</code></td><td>右下角</td></tr></tbody></table><pre><code>border-radius:50%; /*盒子为正方形时是圆*/border-radius:  px;/*圆，数值正方形宽度的一半*/border-radius: 50%;/*盒子为长方形时是椭圆*/</code></pre></blockquote><h4 id="5-padding内边距"><a href="#5-padding内边距" class="headerlink" title="5. padding内边距"></a>5. padding内边距</h4><blockquote><ul><li>padding是边框内壁到内容之间的距离</li></ul></blockquote><blockquote><ul><li>数值的写法，以空格分隔<table><thead><tr><th>数值</th><th>说明</th><th>示范</th></tr></thead><tbody><tr><td>四个数值</td><td>分别表示<code>上右下左</code></td><td><code>padding:10px 20px 30px 40px</code></td></tr><tr><td>&#x3D;&#x3D;三个数值&#x3D;&#x3D;</td><td>分别表示<code>上、左右、下</code></td><td><code>padding:10px 20px 30px</code></td></tr><tr><td>两个数值</td><td><code>上下、左右</code></td><td><code>padding:10px 20px</code></td></tr><tr><td>一个数值</td><td>四个边距相等</td><td><code>padding:10px;</code></td></tr></tbody></table></li><li>应用场景：如果需要设置父子间间距，即给父元素添加内边距来实现</li></ul></blockquote><blockquote><ul><li>小属性：四个方向可以分别设置，用来层叠大属性<table><thead><tr><th>属性</th><th>说明</th></tr></thead><tbody><tr><td><code>padding-top</code></td><td>上内边距</td></tr><tr><td><code>padding-right</code></td><td>右内边距</td></tr><tr><td><code>padding-bottom</code></td><td>下内边距&#96;</td></tr><tr><td><code>padding-left</code></td><td>左内边距</td></tr></tbody></table></li></ul></blockquote><blockquote><p><code>padding-bottom:100%;</code>可以使元素高度等于宽度</p></blockquote><h4 id="6-margin外边距"><a href="#6-margin外边距" class="headerlink" title="6. margin外边距"></a>6. margin外边距</h4><blockquote><ul><li>是盒子与其他盒子之间的距离</li><li>有四个方向可以分别设置</li></ul></blockquote><blockquote><ul><li>数值的写法与<code>padding</code>相同<table><thead><tr><th>数值</th><th>说明</th><th>示范</th></tr></thead><tbody><tr><td>四个数值</td><td>分别表示<code>上右下左</code></td><td><code>padding:10px 20px 30px 40px</code></td></tr><tr><td>&#x3D;&#x3D;三个数值&#x3D;&#x3D;</td><td>分别表示<code>上、左右、下</code></td><td><code>padding:10px 20px 30px</code></td></tr><tr><td>两个数值</td><td><code>上下、左右</code></td><td><code>padding:10px 20px</code></td></tr><tr><td>一个数值</td><td>四个边距相等</td><td><code>padding:10px;</code></td></tr></tbody></table></li></ul></blockquote><blockquote><ul><li>小属性：四个方向可以分别设置，用来层叠大属性<table><thead><tr><th>属性</th><th>说明</th></tr></thead><tbody><tr><td><code>margin-top</code></td><td>上外边距</td></tr><tr><td><code>margin-right</code></td><td>右外边距</td></tr><tr><td><code>margin-bottom</code></td><td>下外边距</td></tr><tr><td><code>margin-left</code></td><td>左外边距</td></tr></tbody></table><blockquote><p>注意：</p></blockquote></li><li>如果数值是百分比，则是以其&#x3D;&#x3D;父盒子的宽度&#x3D;&#x3D;为基础的，等于父盒子宽度的百分之几</li></ul></blockquote><blockquote><ul><li>margin的塌陷</li><li>又称为：外间距重叠&#x2F;外边距合并&#x2F;外边距穿透</li></ul><ol><li>兄弟元素之间，<strong>垂直</strong>方向：上下外边距出现塌陷</li></ol><ul><li>第一个元素的下外边距与第二个元素的上外边距会发生合并</li><li>margin不会叠加，只以大值为准</li><li>解决办法：<ul><li>任何一个元素加上<code>display:inline-block;</code></li><li>把外边距只加在其中一个元素上</li><li>任意一个元素margin换成对应的<code>padding</code>：把其中一个盒子外边距删除，然后套上透明色，内边距为原本的margin的盒子或者套上<code>padding-top</code>&#x3D;margin的盒子</li></ul></li></ul><ol start="2"><li>margin在<strong>水平</strong>方向上不会塌陷</li><li>父子元素之间，垂直方向：上外边距塌陷</li></ol><ul><li>当一个元素包含在另一元素中时，如果父元素没有设置内边距<strong>或</strong>边框把外边距分隔开，他们的上外边距也会发生塌陷(合并)</li><li>原本子元素设置margin后会与父元素的边框产生距离，但因为发生塌陷，所以父子元素上边框重叠，子元素的外边距穿透出去，与父元素的外边距合并</li><li>塌陷是最大值为主</li><li>解决办法：<ul><li>给父元素加上<code>overfiow:hidden</code>;但子元素超出的部分会被隐藏</li><li>给父元素添加<code>border</code>边框；但占位宽会多两像素</li><li>把子元素外边距删除，然后套上透明色，内边距为原本的margin的盒子或者套上<code>padding-top</code>&#x3D;margin的盒子</li><li>还有更多方法，学完浮动、定位后会讲解</li></ul></li><li>垂直或者父子元素的解决办法3：</li></ul><pre><code>&lt;div class=&quot;box1&quot;&gt;&lt;/div&gt;&lt;div style=&quot;padding-top:30px;&quot;&gt;  &lt;div class=&quot;box2&quot;&gt;&lt;/div&gt;&lt;/div&gt;</code></pre></blockquote><blockquote><ul><li>margin负值</li><li>讲完浮动后再学习</li></ul></blockquote><h4 id="7-去掉元素的默认样式"><a href="#7-去掉元素的默认样式" class="headerlink" title="7. 去掉元素的默认样式"></a>7. 去掉元素的默认样式</h4><blockquote><ul><li>网页中的元素为了展示元素本身的用途和结构，都会给元素添加默认的样式</li><li>常见的默认样式如下：<ul><li><code>body</code>的默认margin&#x3D;8px</li><li><code>ul</code>添加了默认的<code>padding</code>、<code>list-style</code>、<code>margin</code></li><li>a标签添加了默认的颜色、下划线</li><li>p标签有默认的<code>margin</code></li></ul></li><li>怎么做？<ul><li>用通配符选择器；实际工作中不使用<br><code>* &#123;margin:0;padding:0;&#125;</code></li><li>使用并集选择器，用<code>,</code>分隔</li></ul></li></ul><pre><code>body,ul,p &#123;    margin:0;padding:0;    &#125;</code></pre></blockquote><h4 id="8-盒子的水平居中"><a href="#8-盒子的水平居中" class="headerlink" title="8. 盒子的水平居中"></a>8. 盒子的水平居中</h4><blockquote><ul><li>将盒子的左右margin设置为<code>auto</code>，将盒子水平居中，只对块级元素有效</li><li><code>auto</code>用在上下外边距时没有用</li><li>文字、图片、行内块元素水平居中：<code>text-align:center</code></li><li>块级元素水平居中，是给元素自身加上<code>margin:0 auto;</code></li><li>盒子的垂直居中，需要使用绝对定位技术实现(后边会讲到)</li></ul></blockquote><h4 id="9-盒子模型占位计算"><a href="#9-盒子模型占位计算" class="headerlink" title="9. 盒子模型占位计算"></a>9. 盒子模型占位计算</h4><blockquote><ul><li>盒模型内容区大小：</li><li>在标准盒子模型中，决定了父元中的子元素能占据的最大宽高<ul><li>如果只有一个子元素，其宽度超过父元，就会溢出(对内联元素无效，因为内联元素不能设置宽高)</li><li>如果有多个子元素(行内元素、行内块元素)，子元的宽度加起来超过了父元，那么超过的那些子元就会换行显示。(块级元素本来就独占一行)</li></ul></li></ul></blockquote><blockquote><ul><li>盒模型可视宽高：在页面呈现效果的区域<ul><li>可视宽度：内容区宽度+左右内边距+左右边框</li><li>可视高度：内容区高度+上下内边距+上下边框</li></ul></li></ul></blockquote><blockquote><ul><li>实际占位宽高</li><li>决定了这个元素在父元素中的占据面积<ul><li>实际宽度：内容区宽度+左右内边距+左右边框左右外边距</li><li>实际高度：内容区高度+左右内边距+左右边框左右外边距</li></ul></li></ul></blockquote><h3 id="怪异盒模型-IE盒子模型，CSS3新增"><a href="#怪异盒模型-IE盒子模型，CSS3新增" class="headerlink" title="怪异盒模型(IE盒子模型，CSS3新增)"></a>怪异盒模型(IE盒子模型，CSS3新增)</h3><h4 id="1-盒模型分为两种"><a href="#1-盒模型分为两种" class="headerlink" title="1. 盒模型分为两种"></a>1. 盒模型分为两种</h4><blockquote><ul><li>标准盒模型：盒子大小会因为设置的内外边距和边框而变化，即：外扩</li><li>怪异盒模型：盒子的实际大小是设置的大小(width、height),不会因为内外边距、边框的大小而变化，即内缩</li><li>二者之间的区别：<ul><li>标准盒模型的width和height设置的是内容区；而在怪异盒模型中，width和height包括内容区、边框、内边距</li><li>尺寸计算公式不同</li></ul></li></ul></blockquote><h4 id="2-计算公式"><a href="#2-计算公式" class="headerlink" title="2.计算公式"></a>2.计算公式</h4><blockquote><ul><li>width&#x3D;内容区宽度+边框+内边距</li><li>height&#x3D;内容区高度+边框+内边距</li><li>在以上公式中，除内容区以外的都可以设置宽高，所以内容区的宽高可以反推计算</li></ul></blockquote><h4 id="3-盒模型转换"><a href="#3-盒模型转换" class="headerlink" title="3. 盒模型转换"></a>3. 盒模型转换</h4><blockquote><p>通过<code>box-sizing</code>属性切换盒子模型</p><ul><li><code>box-sizing:content-box;</code>是默认值，盒子以标准盒子模型特性来渲染</li><li><code>box-sizing:border-box;</code>使盒子以怪异盒子模型特性来渲染</li></ul></blockquote><h4 id="4-button-按钮"><a href="#4-button-按钮" class="headerlink" title="4. button 按钮"></a>4. button 按钮</h4><blockquote><ul><li><code>button</code>标签自带<code>box-sizing:border;</code>属性</li><li>所以<code>div</code>和<code>button</code>的大小是有差异的，button内缩，div外扩</li></ul></blockquote><h4 id="5-box-sizing应用场景"><a href="#5-box-sizing应用场景" class="headerlink" title="5. box-sizing应用场景"></a>5. box-sizing应用场景</h4><blockquote><ul><li><code>box-sizing</code>属性大量应用于移动网页制作中，因为它结合百分比布局、弹性布局等非常好用，在PC页面开发中使用较少</li><li>该属性兼容到IE9</li><li>若我们期望不管内容、边框、内边距大小如何变化，元素的可视宽高始终不变时，就可以给元素添加<code>box-sizing:border-box;</code>属性，以怪异盒模型来渲染</li><li>不管元素的占位宽如何变化，始终保持边框和内边距不变，希望通过改变内容区大小来达到目的</li><li>常见的响应式开发中、栅格系统等</li></ul></blockquote><h3 id="前端切图工具"><a href="#前端切图工具" class="headerlink" title="前端切图工具"></a>前端切图工具</h3><table><thead><tr><th>软件名称</th><th>功能</th><th>描述</th><th>官网下载地址</th></tr></thead><tbody><tr><td>Snipaste</td><td>截图+贴图</td><td>个人模仿他人效果可用</td><td><a href="https://zh.snipaste.com/">https://zh.snipaste.com/</a></td></tr><tr><td>PxCook</td><td>标注+代码生成(psd)</td><td>是一款连接设计师到开发者之间的协作工具</td><td><a href="https://www.fancynode.com.cn/pxcook/">https://www.fancynode.com.cn/pxcook/</a></td></tr><tr><td>Photoshop</td><td>专业的图片软件处理工具</td><td>实际企业开发设计软件</td><td><a href="https://www.adobe.com/cn/products/photoshop.html">https://www.adobe.com/cn/products/photoshop.html</a></td></tr><tr><td>蓝湖</td><td>产品设计协作平台</td><td>实际企业团队开发协作</td><td><a href="https://lanhuapp.com/">https://lanhuapp.com/</a></td></tr></tbody></table><h4 id="1-photoshop设计软件"><a href="#1-photoshop设计软件" class="headerlink" title="1.photoshop设计软件"></a>1.photoshop设计软件</h4><blockquote><p>助理老师破解版安装教程</p><ul><li>下载、解压压缩包</li><li>&#x3D;&#x3D;断网安装&#x3D;&#x3D;，断网后直接点击Set-up-exe进入安装，过程中不需要任何操作，等待5-10分钟即可</li><li>安装好后,通过window键打开</li><li>使用时，把对应的psd设计稿拖动到软件区域即可</li></ul></blockquote><h4 id="2-PxCook像素大厨"><a href="#2-PxCook像素大厨" class="headerlink" title="2.PxCook像素大厨"></a>2.PxCook像素大厨</h4><blockquote><ul><li>设计师可以免去繁琐的标注功能，前端工程师也可以更加直观的查看设计稿中的元素的内容，间距，尺寸和样式等</li><li>它还可以为工程师直接呈现选中元素的多平台样式代码和素材切图</li><li>官方使用教程：<a href="https://www.fancynode.com.cn/pxcook/docs?ids=qa/pay">https://www.fancynode.com.cn/pxcook/docs?ids=qa/pay</a></li></ul></blockquote><h4 id="3-PS与PxCook配合"><a href="#3-PS与PxCook配合" class="headerlink" title="3.PS与PxCook配合"></a>3.PS与PxCook配合</h4><blockquote><ul><li>设计师用PS设计稿设计好的PSD的效果图后，接下来的工作就是交给程序员来开发成网页</li><li>首先程序员需要把PSD设计稿按开发的需求标记qieytu切图，导出需要的图片素材</li></ul></blockquote><blockquote><ul><li>连接Pxcook和PS</li></ul><ol><li>打开PS–&gt;编辑–&gt;远程连接–&gt;启用远程连接–&gt;设置密码</li><li>打开Pxcook，点击右上角的小刀图标，输入密码，连接成功</li></ol></blockquote><blockquote><ul><li>标记切图：<ul><li>打开pxccok，建立新项目</li><li>将图片拖入PS–&gt;选择图层–&gt;窗口–&gt;扩展功能–&gt;pxccok切图–&gt;选择设备类型、分辨率、保存–&gt;导出到pxcook</li><li>在pxcook后，点击黑色区域，就可以看到PNG，点击保存</li></ul></li><li>分析效果图<ul><li>分析结构，上下结构&#x2F;左右结构</li><li>先拿到效果图，分析它的html结构</li><li>清除默认样式(样式初始化)</li><li>搭建html结构，再写CSS样式</li></ul></li><li>自定义切图的尺寸<ul><li>首先需要确保被标记的图层为图层组，若不是则需要打组</li><li>建立一个组，然后把所需的图层放入组内</li><li>在组内创建一个名为<code>@bounds</code>或<code>#</code>的·图层，通过矩形工具，在该图层内绘制一个举行来描述要切除切片的范围</li><li>打开扩展工具——pxccok标记为切图–&gt;保存–&gt;导入pxcook<br>注意：自定义切图导出到pxcook界面也是完整图，双击项目图，左边就会出现自定义切图<img src="自定义切图.png"></li></ul></li></ul></blockquote><h4 id="4-出现的问题"><a href="#4-出现的问题" class="headerlink" title="4.出现的问题"></a>4.出现的问题</h4><blockquote><ul><li>PS安装后打开时一直在加载中</li></ul><ol><li>打开编辑–&gt;首选项–&gt;常规–&gt;勾选”停用主页屏幕”<img src="PS停用主页屏幕.png"></li></ol><ul><li>PS扩展界面无法打开</li></ul><ol><li>打开注册器(在win中搜索注册器，或者按住快捷键”WIN+R”,输入”regedit”)</li><li>打开以下路径：”计算机\HKEY_CURRENT_USER\Software\Adobe\CSXS.9”</li><li>新建字符串值，输入名称”PlayerDebugMode”，值为”1”</li><li>重新打开PS即可</li></ol></blockquote><h2 id="CSS-三大特性：继承、层叠性、优先级"><a href="#CSS-三大特性：继承、层叠性、优先级" class="headerlink" title="CSS 三大特性：继承、层叠性、优先级"></a>CSS 三大特性：继承、层叠性、优先级</h2><blockquote><p>在实际的开发中，经常会遇到CSS应用时的冲突问题。比如本来应该产生效果的样式没有生效，或有时候不想要的效果硬实现了。<br>CSS三大特性：继承性、层叠性、优先级就是为解决这些问题而来的。</p></blockquote><h3 id="一、CSS继承性"><a href="#一、CSS继承性" class="headerlink" title="一、CSS继承性"></a>一、CSS继承性</h3><ul><li>CSS的继承性是指特定的CSS属性会向下传递到子孙元素。即祖先元素设置，后代元素即生效</li></ul><h4 id="CSS继承性遵循”就近原则”"><a href="#CSS继承性遵循”就近原则”" class="headerlink" title="CSS继承性遵循”就近原则”"></a>CSS继承性遵循”就近原则”</h4><blockquote><ul><li>如果元素自身没有设置某个具有可继承的属性，则会向他的父元素继承</li><li>如果父元素没有，则再往上继承父元素的父元素的这个属性，一层一层向上找，如果找不到，就以默认的样式显示</li></ul></blockquote><blockquote><p>如何查看元素的默认值?</p></blockquote><ul><li>要了解一个属性的默认值，可以把这个属性值设置为<code>initial</code>，然后审查元素，在computed&#x2F;styles面板中可以看到其默认值，如<code>color:initial</code></li></ul><h4 id="可继承和不可继承属性有哪些"><a href="#可继承和不可继承属性有哪些" class="headerlink" title="可继承和不可继承属性有哪些"></a>可继承和不可继承属性有哪些</h4><blockquote><p>可继承属性:<strong>文本相关的属性</strong>普遍具有继承性，只需要给祖先标签设置，即可在后代所有标签中生效</p></blockquote><ul><li>字体系列：font-size、font-family、font-style、font、font-weight</li><li>文本系列：color、text-align、text-indent、line-height、word-spacing、letter-spacing、text-transform</li><li>列表布局属性：list-style、list-style-type、list-style-image、list-style-image</li><li>光标属性：cursor光标显示为何种形态</li><li>元素可见性：visibility控制元素显示和隐藏</li></ul><blockquote><p>不可继承属性</p></blockquote><ul><li>盒子模型：display、margin、border、padding、height、min-height、max-height、width、min-width、max-width</li><li>定位相关：position、left、right、top、bottom、z-index</li><li>浮动：float、clear</li><li>其他：background、overflow、table-layout、vertical-align、page-break-after、page-bread-before、unicode-bidi</li></ul><h4 id="特殊情况："><a href="#特殊情况：" class="headerlink" title="特殊情况："></a>特殊情况：</h4><ul><li>a标签的color值默认不继承，它自带默认效果</li></ul><h4 id="line-height的继承性"><a href="#line-height的继承性" class="headerlink" title="line-height的继承性"></a>line-height的继承性</h4><blockquote><p><code>line-height</code>的值有三种单位，在继承时是有差异的</p><table><thead><tr><th>父元素line-height值</th><th>继承规则</th><th>子元素line-height值</th></tr></thead><tbody><tr><td>50px</td><td>直接继承该值</td><td>50px</td></tr><tr><td>2</td><td>直接继承该比例</td><td>2</td></tr><tr><td>200%</td><td>继承百分比<strong>计算后</strong>的值</td><td>40px</td></tr></tbody></table></blockquote><ul><li>数值表示法和百分比表示法是以<code>font-size</code>为依据的<img src="line-height.png"></li></ul><h4 id="body标签样式初始化"><a href="#body标签样式初始化" class="headerlink" title="body标签样式初始化"></a>body标签样式初始化</h4><blockquote><p>因为文字相关属性具有继承性，所以通常会设置<code>&lt;body&gt;</code>标签的字号、颜色、行高等，这样就能当做整个网页的默认样式了</p></blockquote><h4 id="设置继承性"><a href="#设置继承性" class="headerlink" title="设置继承性"></a>设置继承性</h4><blockquote><p>默认不继承的属性想要继承，可以把属性值设置为<code>inherit</code>，表示这个属性的值继承父元素的<br>扩展补充知识</p></blockquote><ul><li><code>initial</code>：设置属性值和浏览器默认样式相同</li><li><code>inherit</code>：设置属性值默认继承父元素</li><li><code>unset</code>：为以上两个值的组合；如果属性有继承性，则继承父元素，没有则为默认值(不设置也是这个效果)</li></ul><h3 id="二、CSS层叠性"><a href="#二、CSS层叠性" class="headerlink" title="二、CSS层叠性"></a>二、CSS层叠性</h3><blockquote><ul><li>层叠性是CSS的一个基本特征，它是一个定义了如何合并来自多个源(css规则)的属性值的算法</li><li>它在CSS中处于核心地位，CSS的全称：层叠样式表正式强调了这一点</li></ul></blockquote><h4 id="CSS层叠性解读"><a href="#CSS层叠性解读" class="headerlink" title="CSS层叠性解读"></a>CSS层叠性解读</h4><blockquote><ul><li>层叠性是指多个CSS规则可以作用于同一个标签，效果叠加，并不完全覆盖</li><li>CSS的层叠性有两层含义：<strong>叠加</strong>和<strong>覆盖</strong></li><li>不同选择器作用于同一元素，不同属性会<strong>叠加</strong>，相同属性会<strong>覆盖</strong></li><li>在覆盖时需要遵循两大原则：”就近原则”和”优先级”</li></ul></blockquote><h4 id="CSS的叠加原理"><a href="#CSS的叠加原理" class="headerlink" title="CSS的叠加原理"></a>CSS的叠加原理</h4><blockquote><ul><li>不同选择器作用于同一元素，不同属性会叠加作用于元素</li></ul></blockquote><h4 id="CSS的覆盖原则"><a href="#CSS的覆盖原则" class="headerlink" title="CSS的覆盖原则"></a>CSS的覆盖原则</h4><blockquote><p>就近原则</p></blockquote><ul><li>当两个或多个<strong>优先级相同</strong>的选择器作用到同一个元素时。如果出现相同的属性，则以写在后面的选择器中的属性为主</li></ul><blockquote><p>优先级</p></blockquote><ul><li>当两条或多条规则(选择器)作用到同一个元素，如果出现相同的属性，则以优先级高的为主</li></ul><h4 id="层叠性的冲突处理"><a href="#层叠性的冲突处理" class="headerlink" title="层叠性的冲突处理"></a>层叠性的冲突处理</h4><ul><li>不同CSS规则集同时作用于同一个标签，不同属性相互叠加，相同属性会覆盖</li><li>相同属性覆盖，首先需要计算选择器的权重，最后以选择器权重高的为主</li><li>如果选择器权重相同，则写在后面的会覆盖写在前面的</li><li>如果想要实现的效果，因为选择器权重低而不生效，则通过提高选择器权重来达到效果</li></ul><h3 id="三、CSS选择器优先级"><a href="#三、CSS选择器优先级" class="headerlink" title="三、CSS选择器优先级"></a>三、CSS选择器优先级</h3><ul><li>当多个CSS规则集同时作用于同一个HTML标签时，不同属性会叠加，但相同属性会发生覆盖</li><li>在发生覆盖时，浏览器通过选择器的优先级来判断以哪个选择器中的属性值为主，从而在该元素上应用这些属性值</li></ul><h4 id="单个选择器类型的权重"><a href="#单个选择器类型的权重" class="headerlink" title="单个选择器类型的权重"></a>单个选择器类型的权重</h4><ul><li><p>基础选择器：id选择器&gt;class选择器&gt;标签选择器&gt;通配符选择器</p></li><li><p>本质上不同类型的选择器有不同的分数值，分数值越高，选择器的权重越高</p><table><thead><tr><th>选择器的类型</th><th>实例</th><th>选择器权重</th><th>等级</th></tr></thead><tbody><tr><td>!important</td><td><code>div&#123;color:red!important;&#125;</code></td><td>无穷大</td><td>特级</td></tr><tr><td>行内样式(style属性中样式)</td><td><code>style=&#39;color:red&#39;;</code></td><td>1000</td><td>第一等级</td></tr><tr><td>id选择器</td><td>#id</td><td>0100</td><td>第二等级</td></tr><tr><td>class、伪类、属性选择器</td><td><code>.box</code>、<code>:hover</code>、<code>type=text</code></td><td>0010</td><td>第三等级</td></tr><tr><td>标签选择器、伪元素选择器</td><td><code>div1、</code>::after&#96;</td><td>0001</td><td>第四等级</td></tr><tr><td>通配符、子选择器、相邻选择器等</td><td><code>*</code>、<code>&gt;</code>、<code>+</code>、<code>~</code></td><td>0000</td><td></td></tr><tr><td>继承的样式</td><td></td><td>0000</td><td></td></tr></tbody></table></li><li><p>通配符<code>*</code>权重实际是要大于继承的样式的；因为只有在没有设置样式是才会继承或者使用默认样式</p></li></ul><h4 id="复杂选择器优先级计算"><a href="#复杂选择器优先级计算" class="headerlink" title="复杂选择器优先级计算"></a>复杂选择器优先级计算</h4><ul><li>优先级就是分配给指定的CSS声明的一个权重</li><li>选择器的优先级是由选择器中的每一种**选择器类型的数值(权值)**相加的最终结果来决定</li><li>一个选择器的优先级是有四个部分相加计算得来的(数值越大，代表选择器的优先级越高)<br><strong>以下是复杂选择器的权重计算规则</strong></li><li>这里的行内样式<code>&lt;p style=&quot;color:red&quot;&gt;&lt;/p&gt;</code>并不是选择器，但我们把它放在一起，是因为它会影响我们最终的结果<table><thead><tr><th>选择器</th><th>千位</th><th>百位</th><th>十位</th><th>个位</th><th>优先级</th></tr></thead><tbody><tr><td>行内样式</td><td>1</td><td>0</td><td>0</td><td>0</td><td>1000</td></tr><tr><td><code>div p</code></td><td>0</td><td>0</td><td>0</td><td>2</td><td>0002</td></tr><tr><td><code>#box div p</code></td><td>0</td><td>1</td><td>0</td><td>2</td><td>0102</td></tr></tbody></table></li></ul><p>|<code>.box .item h3</code>|0|0|2|1|0021|<br>|<code>.box:hover p</code>|0|0|2|1|0021|</p><blockquote><p>注意事项：</p></blockquote><ul><li>在进行选择器权重计算时不允许进行<strong>进位</strong></li><li>例如，20个类选择器仅仅意味着20个十位，而不能视为两个百位；也就是说，无论多少个类选择器的权重叠加，都不会超过一个ID选择器</li><li>在比较选择器优先级时，从左往右比较，一位一位比较</li></ul><h4 id="important提升权重"><a href="#important提升权重" class="headerlink" title="!important提升权重"></a><code>!important</code>提升权重</h4><ul><li>当在一个样式声明中使用一个<code>!important</code>规则时，此声明将覆盖任何其他声明，只要CSS声明属性值后面带<code>!important</code>，就一定以它为主</li><li>从技术上讲，<code>!important</code>与优先级无关，但它与最终结果直接相关</li></ul><blockquote><p>注意：慎用<code>!important</code></p></blockquote><ul><li>因为这会带来样式的冲突，后面某个地方，需要重写这个样式时，会发现根本无效。一般你在利用第三方组件或css框架时，如果不能充下央视，那将会失去很多色彩</li><li>在某些情况下是一定要用的，比如在之前学的自定义字体时，<code>font-family</code>属性后面加了<code>!important</code>关键字</li></ul><h4 id="总结：CSS选择器优先级"><a href="#总结：CSS选择器优先级" class="headerlink" title="总结：CSS选择器优先级"></a>总结：CSS选择器优先级</h4><blockquote><p>首先要找到，有<strong>哪些选择器</strong>在控制标签元素的样式，然后按以下五步来分析</p></blockquote><ul><li>第一步：找有没有带<code>important</code>关键词的CSS声明，有就一定以他为主，没有看第二步</li><li>第二步：找有没有行内样式，有则以行内样式为主，没有看第三步</li><li>第三步：看选择器的优先级，优先级高的为主，如果优先级相同，则看第四步</li><li>第四步：优先级相同，以写在后面的为主。如果没有选择器作用于当前标签，则看第五步</li><li>看此CSS属性是否具有继承性，如果有，则继承父元素的样式，如果没有，则以默认样式显示</li></ul>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CSS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CSS核心知识点（一）</title>
      <link href="/2023/11/29/CSS%E6%A0%B8%E5%BF%83%E7%9F%A5%E8%AF%86%E7%82%B9%EF%BC%88%E4%B8%80%EF%BC%89/"/>
      <url>/2023/11/29/CSS%E6%A0%B8%E5%BF%83%E7%9F%A5%E8%AF%86%E7%82%B9%EF%BC%88%E4%B8%80%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<span id="more"></span><h2 id="CSS基础认知"><a href="#CSS基础认知" class="headerlink" title="CSS基础认知"></a>CSS基础认知</h2><h3 id="一、简介"><a href="#一、简介" class="headerlink" title="一、简介"></a>一、简介</h3><blockquote><p>CSS又称层叠样式表，它是一种标记语言，而不是编程语言</p><p>作用：给html标签添加样式</p><p>CSS已经发展到CSS3，在最新版本3.0中，增加了大量功能，以前只能用JS才能实现的现在用CSS3也能做到</p><p>要清楚CSS3新增了哪些功能，与之前版本的不同在哪</p><p>web前端三大核心基础：</p></blockquote><table><thead><tr><th>分层</th><th>语言</th><th>功能</th><th>描述</th></tr></thead><tbody><tr><td>结构层</td><td>HTML</td><td>搭建结构、放置部件、描述语义</td><td>骨骼</td></tr><tr><td>样式层</td><td>CSS</td><td>美化页面，实现布局</td><td>皮肤</td></tr><tr><td>行为层</td><td>JavaScript</td><td>实现交互效果，数据收发、表单验证等</td><td>神经</td></tr></tbody></table><h3 id="二、基本语法"><a href="#二、基本语法" class="headerlink" title="二、基本语法"></a>二、基本语法</h3><h4 id="CSS规则集：选择器-声明块"><a href="#CSS规则集：选择器-声明块" class="headerlink" title="CSS规则集：选择器+声明块"></a>CSS规则集：选择器+声明块</h4><ul><li>选择器是指需要改变样式的html元素</li><li>声明块用<code>&#123;&#125;</code>包裹，里面有多条声明，每条声明块之间用<code>;</code>间隔</li><li>每条声明包含一个属性名称和一个值，以冒号分隔<ul><li>最后一条声明可以不写<code>;</code>，但为了统一标准，建议书写完整</li></ul></li></ul><h4 id="CSS样式的书写方式"><a href="#CSS样式的书写方式" class="headerlink" title="CSS样式的书写方式"></a>CSS样式的书写方式</h4><ul><li><strong>方式一</strong>：每一行一条声明，选择器与声明之间一个空格，冒号后面一个空格</li></ul><pre><code>p &#123;    color: red;    font-size: 20px;&#125;</code></pre><blockquote><p>开发中使用方式一，方便阅读和修改</p></blockquote><ul><li><strong>方式二</strong>：选择器和声明写在一行</li></ul><pre><code>p &#123;color: red;font-size: 20px;&#125;</code></pre><ul><li>项目上线时，会把CSS样式进行压缩，压缩后就是方式二的写法</li></ul><h4 id="CSS注释"><a href="#CSS注释" class="headerlink" title="CSS注释"></a>CSS注释</h4><ul><li>注释方式：<code>/* 注释 */</code></li><li>位置：只能放置在style里</li><li>快捷键：<code>ctrl+/</code></li></ul><blockquote><p>与html注释的区别：</p></blockquote><ul><li>写法：<code>&lt;!-- 注释--&gt;</code></li><li>能放置在html的任何位置</li></ul><h4 id="CSS的书写位置"><a href="#CSS的书写位置" class="headerlink" title="CSS的书写位置"></a>CSS的书写位置</h4><ul><li><strong>方式一</strong>：行内样式<ul><li>在标签中加入style属性</li></ul></li></ul><pre><code>&lt;h2 style=&quot;color: red&gt;行内样式&lt;/h2&gt;</code></pre><ul><li><strong>方式二</strong>：内嵌样式&#x2F;内部样式<ul><li>在<code>&lt;head&gt;&lt;/head&gt;</code>标签对中写style属性</li><li>在HTML5中，type可以不写</li></ul></li></ul><pre><code>&lt;head&gt;省略html框架&lt;style type=&quot;text/css&quot;&gt;h1 &#123;    color: bule;    font-size: 20px    &#125;&lt;/style&gt;&lt;/head&gt;</code></pre><ul><li><strong>方式三</strong>：外链样式&#x2F;外部样式<ul><li>新建一个<code>.css</code>文件，使用link标签引入到界面中</li><li>link标签要写在head中</li><li>优点：多个网页可以共用一个CSS样式文件</li></ul></li></ul><pre><code>&lt;head&gt;&lt;link rel=&quot;stylesheet&quot; href=&quot;文件路径&quot;/&gt;&lt;/head&gt;</code></pre><blockquote><p>&#96;rel&#x3D;”stylesheet可以不写”</p></blockquote><ul><li><strong>方式四</strong>：导入式样式<ul><li>导入<code>.css</code>的文件</li><li>缺点：使用导入式的样式表，页面加载完成后才会加载样式；所以在CSS文件加载完成之前，网页就会呈现没有CSS样式的裸奔现象</li></ul></li></ul><pre><code>&lt;style&gt;    @import url(文件路径)&lt;/style&gt;</code></pre><ul><li>实际开发中很少用到</li></ul><blockquote><p>总结：CSS4 种书写位置特点与区别</p></blockquote><!-- |引入方式|书写位置|作用范围|优先级|使用场景||---|---|---|---|---||行内样式|css 样式写在标签的 style 属性中|当前标签|最高配合|JS 或特殊需求||内嵌样式|写在<style>标签中|当前页面|由书写位置和选择器优先级来共同决定|小案例 或 对网站首页首次打开速度要求很高的网页需要；如：百度、腾讯首页||外链样式|css 样式写在单独 css 文件中，通过 link 标签引入|多个页面|由书写位置和选择器优先级来共同决定|项目开发中高频使用||导入式样式|把@import 放在style标签中或 CSS 文件中，用于导入外部 CSS 样式文件|被导入的页面|最低|项目开发中几乎不用（用作了解即可）| --><h4 id="CSS样式的优先级"><a href="#CSS样式的优先级" class="headerlink" title="CSS样式的优先级"></a>CSS样式的优先级</h4><blockquote><p>&#x3D;&#x3D;行内样式&#x3D;&#x3D;的优先级最高</p><p>内联样式和外部样式优先级相同，按照&#x3D;&#x3D;就近原则&#x3D;&#x3D;渲染：渲染离标签更近的</p></blockquote><h3 id="三、CSS选择器"><a href="#三、CSS选择器" class="headerlink" title="三、CSS选择器"></a>三、CSS选择器</h3><h4 id="选择器分类"><a href="#选择器分类" class="headerlink" title="选择器分类"></a>选择器分类</h4><ul><li>传统 CSS2.1 选择器<ul><li>标签选择器和 id 选择器</li><li>class（类）选择器</li><li>复合选择器</li><li>伪类</li><li>CSS3 新增选择器</li></ul></li><li>元素关系选择器<ul><li>序号选择器</li><li>属性选择器</li><li>CSS3 新增伪类</li><li>伪元素</li></ul></li><li>层叠性和选择器权重计算</li></ul><h4 id="标签选择器"><a href="#标签选择器" class="headerlink" title="标签选择器"></a>标签选择器</h4><ul><li>又称元素选择器&#x2F;类型选择器</li><li>直接使用&#x3D;&#x3D;元素的标签名&#x3D;&#x3D;当做选择器，将选择页面上的&#x3D;&#x3D;所有<strong>该种标签</strong>&#x3D;&#x3D;，无论位置深浅</li><li>作用：由于覆盖面非常大，所以适用于标签样式的初始化</li></ul><pre><code>ul&#123;  list-style:none;&#125;a &#123;  text-decoration:none;&#125;</code></pre><h4 id="id选择器"><a href="#id选择器" class="headerlink" title="id选择器"></a>id选择器</h4><ul><li>id选择器是使用元素的id属性来选择特定元素</li><li>写法：<code>#+id名</code></li><li>作用:元素的id是唯一的，所以用于选择一个唯一的元素</li><li>id的正确命名规范：<ul><li>只能由字母、数字、下划线<code>_</code>、短横线<code>-</code>构成</li><li>不能以数字开头</li><li>区分大小写</li><li>最好多个单词之间以<code>-</code>分割</li></ul></li></ul><pre><code>&lt;style&gt;   #box1 &#123;       color:orange;   &#125;&lt;/style&gt;&lt;body&gt;   &lt;h3 id=&quot;box1&quot;&gt;三级标题&lt;/h3&gt;&lt;/body&gt;</code></pre><h4 id="class选择器"><a href="#class选择器" class="headerlink" title="class选择器"></a>class选择器</h4><ul><li>class属性表示”类名”</li><li>类名的命名规范与id相同</li><li>写法：<code>.+class名</code><ul><li>多个标签可以使用相同的类名</li><li>同一个标签可以属于多个类，类名之间用空格隔开</li></ul></li><li>原始类<ul><li>应用场景：组件化开发</li><li>在网页项目前，可以将所有的常用字号、文字、颜色、行高、外边距、内边距等设置为单独的类</li><li>HTML标签就可以”按需选择”它的类名，以快速添加样式</li></ul></li></ul><h4 id="通配符选择器"><a href="#通配符选择器" class="headerlink" title="通配符选择器"></a>通配符选择器</h4><ul><li>可以作用于页面当中的所有元素</li><li>基本不用，对性能消耗过大</li><li>写法：<code>*</code></li></ul><pre><code>* &#123;  color:green;&#125;</code></pre><h4 id="复合选择器"><a href="#复合选择器" class="headerlink" title="复合选择器"></a>复合选择器</h4><table><thead><tr><th>名称</th><th>示例</th><th>说明</th></tr></thead><tbody><tr><td>后代选择器</td><td><code>.box .para</code></td><td>选择类名为box的标签 内部的类名为para的标签</td></tr><tr><td>交集选择器</td><td><code>li.para</code></td><td>选择既是li标签，也属于para类的标签</td></tr><tr><td>并集选择器</td><td><code>ul,ol</code></td><td>选择所有ul和ol标签</td></tr></tbody></table><ol><li>后代选择器</li></ol><ul><li>在CSS中，使用&#x3D;&#x3D;空格&#x3D;&#x3D;表示<code>后代</code>，不一定是“儿子”</li><li>后代选择器可以有很多空格，表示隔开好几代</li><li>会同时选择满足条件的子和孙</li></ul><ol start="2"><li>交集选择器</li></ol><ul><li>没有空格</li><li>选择同时满足多个条件的标签</li></ul><ol start="3"><li>并集选择器</li></ol><ul><li>也叫做<code>分组选择器</code>，逗号表示分组</li><li>同时选择多个标签</li></ul><ol start="4"><li>复合选择器：选择器可以任意搭配结合</li></ol><h4 id="伪类"><a href="#伪类" class="headerlink" title="伪类"></a>伪类</h4><blockquote><p>伪类是添加到选择器的描述性词语，指定要选择元素的特殊状态</p><p>超链接拥有四个特殊状态</p><table><thead><tr><th>伪类</th><th>描述</th></tr></thead><tbody><tr><td><code>a:link</code></td><td>没有被访问的超级链接</td></tr><tr><td><code>a:visited</code></td><td>已经被访问过的超级链接</td></tr><tr><td><code>a:hover</code></td><td>正在被鼠标悬停的超级链接</td></tr><tr><td><code>a:active</code></td><td>正在被激活的超级链接(按下按键，但还没有松开按键)</td></tr><tr><td><strong>爱恨准则</strong></td><td></td></tr></tbody></table></blockquote><ul><li>a标签的伪类书写，按照”爱恨准则”的顺序，否则会与伪类不生效</li><li>LOVE HATE:<code>:link</code>、<code>:visited</code>、<code>:hover</code>、<code>:active</code></li></ul><pre><code>&lt;style&gt;    /*      顺序不能乱 ，爱恨准则 LOVE HATE      :link  -&gt; :visited -&gt; :hover -&gt; :active    */    a:link &#123;      color:red;    &#125;    a:visited &#123;      color:blue;    &#125;    a:hover &#123;      color: green;    &#125;    a:active &#123;      color:yellow;    &#125;&lt;/style&gt;</code></pre><blockquote><p><strong>注</strong></p></blockquote><ul><li>遵守了爱恨准则，但<code>a:link</code>不生效，是因为之前访问过的网址会被浏览器记录，就会显示<code>a:visited</code>的样式(修改网址或清除浏览记录即可)</li><li>四个样式可以根据实际情况单独使用</li><li>伪类<code>:hover</code>不仅可以用在a标签上，还可以用在其他标签上</li></ul><h4 id="元素关系选择器"><a href="#元素关系选择器" class="headerlink" title="元素关系选择器"></a>元素关系选择器</h4><ul><li>子选择器<ul><li><code>.bov&gt;p &#123; &#125;</code></li><li>两个标签要为父子关系，当使用<code>&gt;</code>符号分割两个元素时，他只会匹配那些作为第一个元素的直接后代元素</li><li>从IE7开始兼容</li></ul></li><li>相邻兄弟选择器<ul><li><code>.bov+p&#123; &#125;</code></li><li>第二个元素紧跟在第一个元素之后，并且这两个元素都属于同一个父元素的子元素</li><li>只会选择紧跟着的一个，就算有两个相同元素在第一个元素后面</li><li>a+b即选择紧跟在a后面的第一个b</li><li>从IE7开始兼容</li></ul></li><li>通用兄弟选择器<ul><li><code>.box~p&#123; &#125;</code></li><li><code>a~b</code>表示选择a元素&#x3D;&#x3D;之后&#x3D;&#x3D;所有的同级b元素</li><li>a之前的b元素是选择不到的</li><li>从IE7开始兼容</li></ul></li></ul><h4 id="序号选择器"><a href="#序号选择器" class="headerlink" title="序号选择器"></a>序号选择器</h4><table><thead><tr><th>选择器</th><th>描述</th><th>兼容性</th></tr></thead><tbody><tr><td><code>:first-child</code></td><td>第一个子元素</td><td>IE7</td></tr><tr><td><code>:last-child</code></td><td>最后一个子元素</td><td>IE9</td></tr><tr><td><code>:nth-child(n)</code></td><td>第n个子元素</td><td>IE9</td></tr><tr><td><code>:nth-last-child(n)</code></td><td>倒数第n个子元素</td><td>IE9</td></tr><tr><td><code>:nth-of-type(n)</code></td><td>第n个某类型子元素</td><td>IE9</td></tr><tr><td><code>:nth-last-of-type(n)</code></td><td>倒数第n个某类型子元素</td><td>IE9</td></tr><tr><td><code>:only-child</code></td><td>选择没有任何兄弟元素的元素</td><td></td></tr></tbody></table><blockquote><p>注：</p></blockquote><ul><li>动态值写法：()可以写成<code>an+b</code>的形式也可以用关键词，<ul><li>n是自然数，从0开始计算</li><li>a,b必须是整数，可正可负</li><li>2n&#x3D;偶数&#x3D;even,2n+1&#x3D;奇数&#x3D;odds，</li></ul></li><li><code>nth-of-type(n)</code>和<code>nth-last-of-type(n)</code>键选择&#x3D;&#x3D;同种标签&#x3D;&#x3D;指定序号的子元素</li></ul><h4 id="属性选择器"><a href="#属性选择器" class="headerlink" title="属性选择器"></a>属性选择器</h4><ul><li><p>写法：<code>标签[属性]</code></p><table><thead><tr><th>案例</th><th>描述</th><th>兼容性</th></tr></thead><tbody><tr><td><code>img[alt]</code></td><td>选择有alt属性的img标签</td><td>IE9</td></tr><tr><td><code>img[alt=&quot;icon&quot;]</code></td><td>选择alt属性是icon的img标签,属性里只能有icon这几个词</td><td>IE9</td></tr><tr><td><code>img[alt^=&quot;icon&quot;]</code></td><td>选择alt属性以icon开头的img标签,只有icon或者是以它开头都行</td><td>IE9</td></tr><tr><td><code>img[alt$=&quot;icon&quot;]</code></td><td>选择alt属性以icon结尾的img标签,只有icon或者以icon结尾的都行</td><td>IE9</td></tr><tr><td><code>img[alt*=&quot;icon&quot;]</code></td><td>选择alt属性中包含icon文字的img标签，sscion&#x2F;icon-c&#x2F;icon button都可以</td><td>IE9</td></tr><tr><td><code>img[alt~=&quot;icon&quot;]</code></td><td>选择alt属性中<strong>有空格隔开</strong>的icon字样的的img标签,只有icon属性&#x2F;有包含icon在内的多个属性值</td><td>IE9</td></tr><tr><td>&#96;img[alt</td><td>&#x3D;”icon”]&#96;</td><td>选择alt属性以<code>icon-</code>开头的img标签,只有icon属性&#x2F;以icon-开头的属性都行</td></tr></tbody></table></li><li><p>以上标签、属性、文字都可以替换</p></li><li><p>注：实际开发中用的很少，只做了解即可</p></li></ul><h4 id="CSS3新增伪类"><a href="#CSS3新增伪类" class="headerlink" title="CSS3新增伪类"></a>CSS3新增伪类</h4><table><thead><tr><th>伪类</th><th>描述</th></tr></thead><tbody><tr><td><code>:focus</code></td><td>选择当前获得焦点的表单元素</td></tr><tr><td><code>:checked</code></td><td>选择当前已经勾选的单选按钮或复选框</td></tr><tr><td><code>:empty</code></td><td>选择空标签</td></tr><tr><td><code>:enabled</code></td><td>选择当前有效的表单元素</td></tr><tr><td><code>:disabled</code></td><td>选择当前无效的表单元素</td></tr><tr><td><code>:root</code></td><td>选择根元素，即<code>&lt;html&gt;</code>标签</td></tr></tbody></table><blockquote><p><code>:focus</code>：</p></blockquote><ul><li>可修改当前获得焦点的表单元素样式</li><li>自带outline样式<blockquote><p><code>:checked</code></p></blockquote></li><li>可以用来修改复选框&#x2F;单选框样式(原样式优先级太高，用div模拟复选框&#x2F;单选框)，区别：单选框选中后不能取消</li><li>用label标签绑定复选框<code>input:checkbox</code>(&#x2F;单选框<code>input:radio</code>)、div.box、以及div下的div.item</li><li>设置新选择框.box的样式、.item:被选中后的样式</li><li>用<code>display:none</code>隐藏原选择框和.item</li><li><code>input:checked+ .box .item &#123;dispaly:block&#125;</code>表示被选中后，.box下的.item显示出来<blockquote><p><code>:empty</code>:只能是空内容，有空格的标签不会被选中</p></blockquote></li></ul><h4 id="CSS3新增伪元素"><a href="#CSS3新增伪元素" class="headerlink" title="CSS3新增伪元素"></a>CSS3新增伪元素</h4><ul><li>CSS3新增了”伪元素”特性，表示”虚拟动态创建的元素”</li><li>伪元素用双冒号<code>::</code>表示，IE8及以上兼容单冒号<code>:</code></li><li>语法：<code>element::before&#123; &#125;</code></li></ul><table><thead><tr><th>CSS3新增伪元素</th><th>描述</th></tr></thead><tbody><tr><td><code>::before</code></td><td>匹配选中的元素的第一个元素</td></tr><tr><td><code>::after</code></td><td>匹配选中元素的最后一个子元素</td></tr><tr><td><code>::selection</code></td><td>选择器匹配被用户选取的部分</td></tr><tr><td><code>::first-letter</code></td><td>会选中某元素中的第一行的第一个字母</td></tr><tr><td><code>::first-line</code></td><td>会选中某元素第一行的全部文字</td></tr><tr><td><code>::placeholder</code></td><td>自定义表单元素的占位文本样式</td></tr></tbody></table><blockquote><p><code>::before</code>和<code>::after</code></p></blockquote><ul><li><p>企业应用：各种小图标、CSS精灵图</p></li><li><p>这两个伪元素必须使用<code>content</code>属性表示其内容，绝对不能省掉</p></li><li><p>为选中的元素添加修饰性的内容，此元素默认为行内元素</p></li><li><p>第一种情况：给子元素&#x2F;没有子元素的盒子加，就是给对应标签的前&#x2F;后新增<code>content</code>内容及样式</p></li></ul><pre><code>&lt;div&gt;&lt;/div&gt;&lt;p&gt;&lt;/p&gt;!-- 给这种情况加伪元素就算新增内容 --&gt;</code></pre><ul><li>第二种情况：给父元素加，就会新增一个行内元素及样式</li></ul><pre><code>&lt;div&gt;&lt;p&gt;&lt;/p&gt;&lt;/div&gt;&lt;!-- &gt;这种情况就是新增行内元素 --&gt;</code></pre><img src="weiyuansu.png"><blockquote><p><code>::selection</code></p></blockquote><ul><li>被选中的部分会改变样式</li><li>只能向<code>::selection</code>选择器应用少量的CSS属性:color、background、cursor以及outline<blockquote><p><code>::first-letter</code></p></blockquote></li><li>会选中某元素的第一行的第一个字母</li><li>必须是块级元素<blockquote><p><code>::first-line1</code></p></blockquote></li><li>会选中某元素的第一行的全部文字</li><li>必须是块级元素</li></ul><h4 id="CSS-选择器的权重计算"><a href="#CSS-选择器的权重计算" class="headerlink" title="CSS 选择器的权重计算"></a>CSS 选择器的权重计算</h4><ol><li>层叠性</li></ol><ul><li>CSS 全名叫 层叠式样式表 ，层叠性是它很重要的性质</li><li>层叠性：多个选择器可以同时作用于同一个标签，效果叠加</li></ul><ol start="2"><li>层叠性的冲突处理</li></ol><ul><li>多个选择器定义同一元素的冲突问题</li><li>CSS 有严密的处理冲突的规则</li><li>id 权重 &gt; class权重 &gt; 标签权重 &gt; 通配符权重</li></ul><ol start="3"><li>复杂选择器权重计算</li></ol><ul><li>复杂选择器可以通过（id的个数，class的个数，标签的个数）的形式，计算权重</li></ul><ol start="4"><li>!important 提升权重</li></ol><ul><li>如果我们需要将某个选择器的某条属性提升权重，可以在属性后边写上 <code>!important</code></li><li>实际企业中，不允许使用 <code>!important</code> ，因为这会带来不经意的样式冲突</li></ul><h4 id="作业"><a href="#作业" class="headerlink" title="作业"></a>作业</h4><blockquote><p>开关按钮</p></blockquote><ul><li><code>input:checked</code>里面可以直接写按下开关后的样式</li><li>优化：用伪元素替代没有内容的标签</li></ul><h2 id="CSS文本属性、字体属性、列表属性"><a href="#CSS文本属性、字体属性、列表属性" class="headerlink" title="CSS文本属性、字体属性、列表属性"></a>CSS文本属性、字体属性、列表属性</h2><h3 id="一、CSS字体属性"><a href="#一、CSS字体属性" class="headerlink" title="一、CSS字体属性"></a>一、CSS字体属性</h3><h4 id="color属性"><a href="#color属性" class="headerlink" title="color属性"></a>color属性</h4><ul><li>可设置文本内容的字体颜色</li><li>color属性有四种表示法：</li></ul><blockquote><p><strong>英文单词表示法</strong></p></blockquote><ul><li>应用场景：仅用于学习和测试，工作中不常用</li></ul><pre><code>color:red;</code></pre><blockquote><p><strong>十六进制表示法</strong></p></blockquote><ul><li>设计图中标注的颜色通常为十六进制表示</li><li>每一种颜色分量都是0~255的数字，十六进制的ff就是十进制的255</li><li>如果颜色值是两两相同，并且有三对，<code>#aabbcc</code>的形式可以简写为<code>#abc</code></li><li>常用的十六进制表示法</li></ul><table><thead><tr><th>色值</th><th>描述</th></tr></thead><tbody><tr><td><code>#000</code></td><td>黑色</td></tr><tr><td><code>#fff</code></td><td>白色</td></tr><tr><td><code>#ccc</code>、<code>#333</code>、<code>#2f2f2f</code>、<code>#666</code>、<code>#ddd</code></td><td>灰色</td></tr></tbody></table><blockquote><p><strong>rgb()表示法</strong></p></blockquote><ul><li>rgb是红蓝绿三个单词的缩写</li><li>三个数字的范围是0~255,数字之间用<code>,</code>分隔</li></ul><pre><code>color:rgb(255,0,0);&lt;!-- 红色 --&gt;</code></pre><blockquote><p><strong>rgba()表示法</strong></p></blockquote><ul><li>前三个数字是颜色,范围是0~255</li><li>第四个参数是透明度，范围是0~1，值越大越不透明</li><li>rgba()表示法从IE9开始兼容</li></ul><pre><code>color: rgba(255,0,0,0.5)</code></pre><h4 id="font-size属性"><a href="#font-size属性" class="headerlink" title="font-size属性"></a>font-size属性</h4><ul><li>font-size属性用来设置文字的字号大小</li><li>单位通常为px(像素)、%(百分比)；移动端还会学习em、rem、vw、vh单位</li><li>网页文字正文默认为为16px，1em&#x3D;两个字符</li><li>浏览器最小支持12px字号</li><li><strong>面试题</strong>：如何在页面中设置小于12px的字体(学到动画时会讲)</li><li>百分比是相对于父元素的font-size而言</li></ul><pre><code>&lt;style&gt;.fon1 &#123;font-size:12px;&#125;.fon2 &#123;font-size:16px;&#125;div p &#123;font-size:50%;&#125;&lt;/style&gt;&lt;body&gt;    &lt;p&gt;这是一段默认大小的文字&lt;/p&gt;    &lt;p class=&quot;fon1&quot;&gt;字体大小为12px&lt;/p&gt;    &lt;div class=&quot;fot2&quot;&gt;        父元素为16px        &lt;p&gt;字体大小为父元素的50%&lt;/p&gt;    &lt;/div&gt;&lt;/body&gt;  </code></pre><h4 id="font-weight属性"><a href="#font-weight属性" class="headerlink" title="font-weight属性"></a>font-weight属性</h4><ul><li>用来设置字体的粗细程度</li><li>可以用属性值或者数字来设置大小</li><li>数字介于1~1000之间，数字越大，字体越粗</li><li>最终的粗细要在当前字体可行的精细范围之内</li></ul><table><thead><tr><th>属性</th><th>描述</th></tr></thead><tbody><tr><td><code>normal</code></td><td>正常粗细，与400等值</td></tr><tr><td><code>bold</code></td><td>加粗，与700等值</td></tr><tr><td><code>lighter</code></td><td>比从父元素继承来的值更细(处在字体可行的粗细值范围内)，大多数中文字体不支持</td></tr><tr><td><code>bolder</code></td><td>比从父元素继承来的值更粗(处于字体可行的粗细范围内)大多数中文字体不支持</td></tr></tbody></table><pre><code>&lt;style&gt;      .we1 &#123; font-weight: normal; &#125;      .we2 &#123;font-weight: bold; &#125;      .we3 &#123;font-weight: 500;&#125;      .we4 &#123;font-weight: lighter;&#125;      .we5 &#123;font-weight: bolder;&#125;  &lt;/style&gt;&lt;body&gt;    &lt;p class=&quot;we1&quot;&gt;正常粗细&lt;/p&gt;    &lt;p class=&quot;we2&quot;&gt;加粗文本&lt;/p&gt;    &lt;div class=&quot;we3&quot;&gt;        父元素为600        &lt;p class=&quot;we4&quot;&gt;比父元素更细&lt;/p&gt;        &lt;p class=&quot;we5&quot;&gt;比父元素更粗&lt;/p&gt;    &lt;/div&gt;&lt;/body&gt;</code></pre><h4 id="4-font-style属性"><a href="#4-font-style属性" class="headerlink" title="4.font-style属性"></a>4.font-style属性</h4><ul><li>设置字体的倾斜<table><thead><tr><th>属性</th><th>描述</th></tr></thead><tbody><tr><td><code>normal</code></td><td>取消倾斜，把默认倾斜的<code>i</code>、<code>em</code>等标签设置为不倾斜</td></tr><tr><td><code>italic</code></td><td>设置为倾斜字体(常用)，如果当前字体没有可用的斜体版本，会选用<code>oblique</code>替代</td></tr><tr><td><code>oblique</code></td><td>设置为倾斜字体，用常规字体模拟(不常用)</td></tr></tbody></table></li></ul><pre><code>&lt;style&gt;    .sty1 &#123;font-style: normal;&#125;    .sty2 &#123;font-style: italic;&#125;    .sty3 &#123;font-style: oblique;&#125;&lt;/style&gt;&lt;body&gt;    &lt;i&gt;这是一个默认倾斜字体&lt;/i&gt; &lt;br&gt;    &lt;i class=&quot;sty1&quot;&gt;把默认倾斜设置为不倾斜&lt;/i&gt;    &lt;p class=&quot;sty2&quot;&gt;italic下把不倾斜的设置为倾斜&lt;/p&gt;    &lt;p class=&quot;sty3&quot;&gt;oblique下把不倾斜设置为倾斜&lt;/p&gt;&lt;/body&gt;</code></pre><h4 id="font-family-字体类型"><a href="#font-family-字体类型" class="headerlink" title="font-family 字体类型"></a>font-family 字体类型</h4><ul><li>用于设置字体类型，浏览器默认字体为”微软雅黑”</li><li>可以设置多个字体类型，字体之间用<code>,</code>分隔，如果第一个字体浏览器不支持，则会往后找；若都不支持，则会使用默认字体；</li></ul><pre><code>font-family:&quot;Times New Rowman&quot;,Times,serif;</code></pre><blockquote><p>注：</p></blockquote><ul><li>中文字体要用<code>&quot;&quot;</code>包裹，英文字体中若有空格，也要用<code>&quot;&quot;</code>(不加也可以)</li><li>字体通常必须是用户计算机已经安装好的字体，所以设置为:”微软雅黑””宋体”较多</li><li>中文字体也可以用英文名</li></ul><table><thead><tr><th>中文字体名</th><th>英文字体名</th></tr></thead><tbody><tr><td>“微软雅黑”</td><td>“Microsoft Yahei”</td></tr><tr><td>“宋体”</td><td>“SimSun”</td></tr></tbody></table><h4 id="font-face自定义字体"><a href="#font-face自定义字体" class="headerlink" title="@font-face自定义字体"></a>@font-face自定义字体</h4><ul><li>用来设置用户电脑里没有的字体，用户浏览网页时会下载相关字体</li><li>准备工作<ul><li>必须自己定义新的字体(需要有字体文件)</li><li>用户加载网页时会同时下载字体文件</li><li>字体文件需要同时拥有五种格式的文件,因为根据操作系统和浏览器不同，有<code>eot</code>、<code>woff2</code>、<code>woff</code>、<code>ttf</code>、<code>svg</code></li></ul></li><li>如何定义字体</li></ul><pre><code>@font-face&#123;    font-family: ;/*字体类型*/    src: url();  /*引入字体类型*/&#125;</code></pre><ul><li>怎么做？<ul><li>获得字体文件：建议使用免费可商用的阿里巴巴普惠字体，地址：<a href="https://www.iconfont.cn/webfont">https://www.iconfont.cn/webfont</a></li><li>输入要定义的文字，选择字体，下载字体包</li><li>使用@font-face声明字体</li><li>定义使用webfont的样式</li><li>为文字加上对应样式<br>  注：可以直接复制demo的内容</li></ul></li></ul><pre><code>&lt;style&gt;  @font-face &#123;  &#125;&lt;!-- 使用font-face声明字体 --&gt;  .web-font &#123;  &#125;&lt;!-- 定义使用 webfont 的样式 --&gt;&lt;/style&gt;&lt;body&gt;&lt;p&gt;要定义的文字&lt;/p&gt;&lt;/body&gt;</code></pre><h3 id="二、CSS文本属性"><a href="#二、CSS文本属性" class="headerlink" title="二、CSS文本属性"></a>二、CSS文本属性</h3><h4 id="text-decoration属性-修饰线"><a href="#text-decoration属性-修饰线" class="headerlink" title="text-decoration属性-修饰线"></a>text-decoration属性-修饰线</h4><ul><li>用于设置文本的修饰线外观</li><li>text-decoration是以下四个属性的简写</li><li>可以写在一行，以空格分隔</li><li><strong>注</strong>：其他三个属性的前提是<code>line</code></li></ul><table><thead><tr><th>属性</th><th>属性值</th></tr></thead><tbody><tr><td>text-decoration-line</td><td>下划线<code>underline</code>、删除线<code>line-through</code>、没有修饰线<code>none</code></td></tr><tr><td>text-decoration-color</td><td>文本修饰的颜色</td></tr><tr><td>text-decoration-style</td><td>波浪线<code>wavy</code>、实线<code>solid</code>、虚线<code>dashed</code></td></tr><tr><td>text-decoration-thickness</td><td>文本修饰线的粗细</td></tr></tbody></table><pre><code>&lt;style&gt;    p &#123;text-decoration:underline red 5px;&#125;    div &#123;text-decoration:wavy underline purple 3px;&#125;    /*有underline才有wavy*/&lt;/style&gt;&lt;body&gt;    &lt;p&gt;有红色下划线的文本，下划线粗5px&lt;/p&gt;    &lt;div&gt;一行有紫色波浪线的文本，线粗3px&lt;/div&gt;&lt;/body&gt;</code></pre><h4 id="text-indent首行缩进"><a href="#text-indent首行缩进" class="headerlink" title="text-indent首行缩进"></a>text-indent首行缩进</h4><ul><li>定义首行文本内容之前的缩进量</li><li>常用单位是<code>em</code>、<code>2em</code>是两个字符的宽度</li><li>默认字符大小是16px，如果没有单独设置，那么2em&#x3D;32px</li></ul><pre><code>&lt;style&gt;        .line1 &#123;font-size:2em;&#125;        /*字体大小为32px*/        .line2 &#123;text-indent:2em;&#125;        /*首行缩进2em，也就是32px*/        .line3 &#123;font-size:2em;text-indent:2em;&#125;        /*字体大小为32px,首行缩进4em=64px*/&lt;/style&gt;&lt;body&gt;    &lt;p class=&quot;line1&quot;&gt;默认文本，设置字体大小是两字符&lt;/p&gt;    &lt;p class=&quot;line2&quot;&gt;首行缩进两字符&lt;/p&gt;    &lt;p class=&quot;line3&quot;&gt;首行缩进两字符，字体大小为两字符&lt;/p&gt;&lt;/body&gt;</code></pre><h4 id="行高"><a href="#行高" class="headerlink" title="行高"></a>行高</h4><ul><li><p>行高的测量方式</p><img src="测量行高.png"></li><li><p>①②是行高测量上的定义，&#x3D;&#x3D;③&#x3D;&#x3D;是行高的真实定义：文字所占空间高度的总高，文字在这个高度的垂直方向&#x3D;&#x3D;居中&#x3D;&#x3D;显示</p></li><li><p>主段落内容的行高至少应为<code>1.5</code></p></li><li><p>如果文字的大小要随页面的缩放而变化，请使用无单位的数值，以确保行高会等比例的缩放</p></li><li><p>行高的值</p></li></ul><table><thead><tr><th>单位</th><th>实例</th><th>说明</th></tr></thead><tbody><tr><td>px</td><td><code>line-height:30px;</code></td><td>行高为30px</td></tr><tr><td>数值表示法</td><td><code>line-height:2;</code></td><td>字号大小的两倍这是<strong>最推荐</strong>的写法，工作中常用倍数是<code>1.25,1.5,1.75</code></td></tr><tr><td>百分比表示法</td><td><code>line-height:200%;</code></td><td>字号大小的两倍</td></tr><tr><td>normal</td><td><code>line-height:normal</code>;</td><td>取决于客户端。桌面浏览器(包括Firefox)使用默认值，约为<code>1.2</code>，这取决于元素的<code>font-family</code></td></tr></tbody></table><pre><code>&lt;style&gt;     .p1 &#123;line-height:20px;          background-color:skyblue;&#125;      div &#123;line-height:40px;          background-color: red;          font-family:&quot;宋体&quot;&#125;      .p2 &#123;line-height: 3;          background-color: aqua;          font-family: &quot;微软雅黑&quot;;&#125;      .p3 &#123;line-heigt:normal;          background-color:coral;&#125;  &lt;/style&gt; &lt;body&gt; &lt;p class=&quot;p1&quot;&gt;设置行高为20px&lt;/p&gt;  &lt;div&gt;这是一行行高40px的宋体&lt;/div&gt;  &lt;p class=&quot;p2&quot;&gt;这是行高为3的微软雅黑&lt;/p&gt;  &lt;p class=&quot;p3&quot;&gt;行高为normal的文字&lt;/p&gt; &lt;/body&gt;</code></pre><h4 id="行文本垂直、水平居中"><a href="#行文本垂直、水平居中" class="headerlink" title="行文本垂直、水平居中"></a>行文本垂直、水平居中</h4><ul><li>行文本垂直居中<ul><li>设置**行高&#x3D;盒子高度(height)**，即可实现单行文本垂直居中</li><li>对行内块元素无效</li></ul></li></ul><pre><code>line-height: height的高度；</code></pre><ul><li>text-align属性<ul><li>定义<strong>行内内容</strong>(例如文字、图片、行内块元素)相对它的块父元素的对齐方式</li><li>注：块级元素不能用这个属性</li><li>常用属性值：<code>left</code>、<code>right</code>、<code>center</code></li></ul></li></ul><pre><code>&lt;style&gt;   .l &#123;text-align: left;&#125;   .c &#123;text-align:center;&#125;   .r &#123;text-align:right;&#125;&lt;/style&gt;&lt;body&gt;   &lt;p class=&quot;l&quot;&gt;这是居左文字&lt;/p&gt;   &lt;p class=&quot;c&quot;&gt;这是居中文字&lt;/p&gt;   &lt;p class=&quot;r&quot;&gt;这是居右文字&lt;/p&gt;&lt;/body&gt;</code></pre><h4 id="font合写属性"><a href="#font合写属性" class="headerlink" title="font合写属性"></a>font合写属性</h4><ul><li>font属性可以用来作为<code>font-style</code>、<code>font-weight</code>、<code>font-size</code>、<code>line-height</code>、<code>font-family</code>属性的合写</li><li>写法<ul><li>font属性连写时，必须设置<code>font-size</code>和<code>font-family</code>才能生效</li><li><code>font-style</code>和<code>font-weight</code>必须放在<code>font-size</code>之前</li><li>连写时任何未指定的值都将设置为其对应的初始值，所以即使没有写行高，也有默认行高1.2<br> -行高写在<code>fon-size</code>后面，用<code>/</code>分隔</li></ul></li></ul><pre><code>font:italic 20px/1.2 &quot;宋体&quot;;</code></pre><h4 id="word-spacing字间距"><a href="#word-spacing字间距" class="headerlink" title="word-spacing字间距"></a>word-spacing字间距</h4><ul><li>对中文无效，仅对英文单词有效<table><thead><tr><th>属性值</th><th>描述</th></tr></thead><tbody><tr><td>normal</td><td>正常的单词间距，有字体和&#x2F;或浏览器定义</td></tr><tr><td>长度</td><td>通过指定具体额外间距来增加字体的单词间距,可以是负数</td></tr></tbody></table></li></ul><h4 id="letter-spacing字符间距"><a href="#letter-spacing字符间距" class="headerlink" title="letter-spacing字符间距"></a>letter-spacing字符间距</h4><ul><li>用于设置文本字符的间距</li><li>对中文和英文都有效，单词会被分隔成一个个字母</li></ul><table><thead><tr><th>属性值</th><th>描述</th></tr></thead><tbody><tr><td>normal</td><td>正常的单词间距，有字体和&#x2F;或浏览器定义</td></tr><tr><td>长度</td><td>通过指定具体额外间距来增加字体的单词间距,可以是负数</td></tr></tbody></table><pre><code>&lt;style&gt;    .word1 &#123;word-spacing:normal;&#125;    .word2 &#123;word-spacing:-10px;&#125;    .letter1 &#123;letter-spacing:10px;&#125;    .letter2 &#123;letter-spacing:-10px;&#125;    .lo &#123;letter-spacing:10px;&#125;    &lt;/style&gt;&lt;body&gt;    &lt;p class=&quot;word1&quot;&gt;I love you ,我爱你,正常间距&lt;/p&gt;    &lt;p class=&quot;word2&quot;&gt;I love you ,我爱你,负间距&lt;/p&gt;    &lt;p class=&quot;letter1&quot;&gt;I love you ,我爱你,10Px间距&lt;/p&gt;    &lt;p class=&quot;letter2&quot;&gt;I love you ，我爱你，负间距&lt;/p&gt;    &lt;div&gt;I love you&lt;p class=&quot;lo&quot;&gt;我爱你&lt;/p&gt;&lt;/div&gt;&lt;/body&gt;</code></pre><h3 id="列表样式"><a href="#列表样式" class="headerlink" title="列表样式"></a>列表样式</h3><h4 id="list-style-type"><a href="#list-style-type" class="headerlink" title="list-style-type"></a>list-style-type</h4><ul><li>设置列表项标记的类型</li><li>实际开发中的一般会把前面的标记类型去掉，用做好的小图标替代</li></ul><table><thead><tr><th>值</th><th>描述</th></tr></thead><tbody><tr><td>none</td><td>无标记(去掉圆点)</td></tr><tr><td>disc</td><td>默认，实心圆</td></tr><tr><td>circle</td><td>空心圆</td></tr><tr><td>square</td><td>实心方块</td></tr><tr><td>decimal</td><td>数字</td></tr><tr><td>decimai-leading-zero</td><td>0开头的数字，01、02、03</td></tr><tr><td>lower-alpha</td><td>小写英文字母</td></tr><tr><td>upper-alpha</td><td>大写英文字母</td></tr><tr><td>……</td><td>标记的类型有20多项，但实际开发中几乎不用</td></tr></tbody></table><p><strong>联系之前在HTML学过的列表标签</strong>:</p><ul><li>注：<code>style=&quot;&quot;</code>等于写在<code>&lt;style&gt;</code>标签里</li></ul><table><thead><tr><th>html(已废弃)</th><th>CSS</th></tr></thead><tbody><tr><td><code>type=&quot;circle&quot;</code></td><td><code>style=&quot;list-style-type:circle&quot;</code></td></tr><tr><td><code>ol-li</code></td><td><code>list-type:decimal</code></td></tr></tbody></table><h4 id="2-list-style-image"><a href="#2-list-style-image" class="headerlink" title="2.list-style-image"></a>2.list-style-image</h4><ul><li>用来指定列表中的列表标记图像，几乎不用</li></ul><table><thead><tr><th>值</th><th>描述</th></tr></thead><tbody><tr><td>URL</td><td>图像的路径</td></tr><tr><td>none</td><td>默认，无图形被现实</td></tr><tr><td>inherit</td><td>规定从父元素继承该属性的值</td></tr></tbody></table><h4 id="3-list-style-position"><a href="#3-list-style-position" class="headerlink" title="3.list-style-position"></a>3.list-style-position</h4><ul><li>规定列表中列表项目标记的位置，几乎不用</li></ul><table><thead><tr><th>值</th><th>描述</th></tr></thead><tbody><tr><td>inside</td><td>列表标记项目放置在文本以内，环绕文本并根据标记对齐</td></tr><tr><td>outside</td><td>默认，标记位于文本的左侧、且放置在文本以外，环绕文本不根据标记对齐</td></tr><tr><td>inherit</td><td>规定从父元素继承该属性的值</td></tr></tbody></table><h4 id="4-list-style"><a href="#4-list-style" class="headerlink" title="4.list-style"></a>4.list-style</h4><ul><li>这是以上三个的综合写法</li></ul><pre><code>list-style:delcima-leading-zero outside;</code></pre><ul><li>实际开发中用的最多的是去掉标记:<code>list-style-type:none;</code>、<code>list-style:none;</code></li></ul>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CSS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>onlineOrdering-applet</title>
      <link href="/2023/11/27/onlineOrdering-applet/"/>
      <url>/2023/11/27/onlineOrdering-applet/</url>
      
        <content type="html"><![CDATA[<span id="more"></span><p><a href="https://github.com/hermiablog/onlineOrdering-applet">小程序链接</a></p><h2 id="效果"><a href="#效果" class="headerlink" title="效果"></a>效果</h2><img src="main.png" width="200"><img src="menu.png" width="200"><img src="cart.png" width="200"><img src="order.png" width="200"><img src="me.png" width="200"><h2 id="项目创建过程"><a href="#项目创建过程" class="headerlink" title="项目创建过程"></a>项目创建过程</h2><h4 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h4><ol><li>将项目的通用样式写在<code>app.wxss</code>中<blockquote><ul><li>在根目录<code>page</code>下设置主题色、字号、字体颜色等</li><li>注意：<code>page</code>要设置<code>min-height=100%;</code>才会占满屏幕</li></ul></blockquote></li><li>清除常用组件的自带样式<blockquote><ul><li>将外边距、内边距都设置为0</li><li>将组件都设置为怪异盒模型</li></ul></blockquote></li><li>新建<code>src</code>文件夹，用于存放不可动态获取的图片、图标</li><li>新建<code>component</code>文件夹，用于存放自定义组件</li><li>自定义<code>icon</code>组件，实现<code>icon</code>图标的复用<blockquote><ul><li>新建<code>iconfont</code>文件夹，保存图标<code>wxss</code>文件</li><li>单独存放有利于随时替换</li></ul></blockquote></li></ol><pre><code>order-online├─ .eslintrc.js├─ app.js├─ app.json├─ app.wxss├─ component│  └─ icon│     ├─ icon.js│     ├─ icon.json│     ├─ icon.wxml│     └─ icon.wxss├─ iconfont│  └─ iconfont.wxss├─ pages│  └─ index│     ├─ index.js│     ├─ index.json│     ├─ index.wxml│     └─ index.wxss├─ project.config.json├─ project.private.config.json├─ sitemap.json├─ src│  └─ icon│     ├─ cart.png│     ├─ index.png│     ├─ menu.png│     ├─ order.png│     ├─ selected-cart.png│     ├─ selected-index.png│     ├─ selected-menu.png│     ├─ selected-order.png│     ├─ selected-user.png│     ├─ takeBySelf.png│     ├─ user.png│     └─ waimai.png└─ utils   └─ util.js</code></pre><h3 id="首页"><a href="#首页" class="headerlink" title="首页"></a>首页</h3><h4 id="基础准备"><a href="#基础准备" class="headerlink" title="基础准备"></a>基础准备</h4><ol><li>需要实现的效果</li></ol><ul><li>在顶部搜索框，输入产品名，可跳转到对应产品</li><li>选择取餐方式后，跳转到菜单页，并保存取餐方式</li><li>点击新品图片，可跳转到对应产品</li></ul><ol start="2"><li>难点</li></ol><ul><li><p>顶部导航与胶囊按钮对齐</p><blockquote><ul><li>自定义导航<code>navigation</code></li><li>实现不同机型和开发工具的适配</li></ul></blockquote></li><li><p>搜索后跳转到对应产品&#x3D;&#x3D;(需补充)&#x3D;&#x3D;</p></li></ul><h4 id="第一步：实现tabBar"><a href="#第一步：实现tabBar" class="headerlink" title="第一步：实现tabBar"></a>第一步：实现<code>tabBar</code></h4><ol><li>根据项目需要，确认使用原生<code>tabBar</code></li><li>创建对应页面的文件</li><li>下载<code>tabBar</code>图标，存放至<code>src/icon</code>文件夹</li><li>在<code>app.json</code>里进行配置</li></ol><h4 id="第二步：自定义导航栏，并处理兼容性"><a href="#第二步：自定义导航栏，并处理兼容性" class="headerlink" title="第二步：自定义导航栏，并处理兼容性"></a>第二步：自定义导航栏，并处理兼容性</h4><blockquote><p>参考微信开发者社区回答：<a href="https://developers.weixin.qq.com/community/develop/article/doc/000aa842274d58cb15f74f81f56013">https://developers.weixin.qq.com/community/develop/article/doc/000aa842274d58cb15f74f81f56013</a></p><ul><li>新建<code>navigation-bar</code>组件构建自定义导航栏</li><li>菜单页引入该组件</li></ul></blockquote><p><strong><code>navigation-bar</code>组件内：</strong></p><blockquote><p><strong>实现对齐和适配的思路：</strong></p><ul><li>正常来讲，<code>iOS</code>和<code>Android</code>下的胶囊按钮的位置以及大小都是相同且不变的，我们可以通过胶囊按钮的位置和大小再配合 <code>wx.getSystemInfo</code> 或者 <code>wx.getSystemInfoSync</code> 中得到的 <code>statusBarHeight</code> 来计算出导航栏的位置和大小。</li><li>顶部导航区，包括状态栏、导航栏(导航条+胶囊)，都设置固定定位</li></ul></blockquote><blockquote><p><strong>实现步骤：</strong></p></blockquote><ol><li><p>首先需要知道不同<code>iOS</code>和<code>Android</code>下的胶囊按钮的位置以及大小</p><blockquote><ul><li>根据开发者的文档可知(非官方数据，自己进行微调)：</li></ul><pre><code>// iOS  top 4px  right 7px  width 87px  height 32px// Android  top 8px  right 10px  width 95px  height 32px// 开发者工具模拟器（iOS）  top 6px  right 10px  width 87px  height 32px// 开发者工具模拟器（Android）  top 8px  right 10px  width 87px  height 32px</code></pre><ul><li>这里<code>top</code>的值是从 <code>statusBarHeight</code> 作为原点开始计算的</li><li>因此最终位置还得加上状态栏的高度</li></ul></blockquote></li><li><p>通过<code>wx.getSystemInfoSync</code>可以得到状态栏<code>statusBarHeight</code>的位置和宽高</p><blockquote><ul><li>状态栏的宽度也就是可使用窗口宽度(手机屏幕宽度)</li></ul></blockquote></li><li><p>计算导航条的位置和大小</p><blockquote><ul><li>导航条要和胶囊平齐，所以：</li><li>top&#x3D;胶囊的top<blockquote><p>把胶囊离右边框的距离作为导航条的内边距</p></blockquote></li><li>left&#x3D;0</li><li>宽度&#x3D;可使用窗口宽度-胶囊右边距-胶囊宽度-导航条内边距&#x3D;可使用窗口宽度-胶囊宽度-胶囊右边距*3<blockquote><p>注意：胶囊的top是以状态栏为原点，但导航条是以屏幕左上角为原点</p></blockquote></li><li>height&#x3D;胶囊的height</li></ul></blockquote></li><li><p>计算整个导航栏(导航条+胶囊)的位置和大小</p><blockquote><ul><li>top&#x3D;状态栏的高度</li><li>left&#x3D;0</li><li>宽度&#x3D;可使用窗口宽度</li><li>高度&#x3D;<code>胶囊的height+胶囊的上外边距*2</code>&#x3D;<code>(胶囊的top-状态栏高度)*2+胶囊的height</code></li></ul></blockquote></li><li><p>格式化</p><blockquote><ul><li>前面的得到的所有数据都是对象的形式</li><li>而在页面上设置样式时，要在标签里用<code>style=&quot;&quot;</code>的方式</li><li>所以要把对象格式的数据，转为成字符串</li></ul><pre><code>formatStyle(position) &#123;  //声明一个数组，存放遍历出来的数据，加px  let styles = []  for (let key in position) &#123; styles.push(`$&#123;key&#125;: $&#123;position[key]&#125;px;`)  &#125;  // 将数组转成字符串，把逗号替换成空格  return styles.join(&#39; &#39;)&#125;</code></pre><ul><li>因为<code>wx.getSystemInfoSync()</code>得到的可使用窗口宽度，单位是px</li></ul></blockquote></li></ol><h4 id="第三步：搜索框"><a href="#第三步：搜索框" class="headerlink" title="第三步：搜索框"></a>第三步：搜索框</h4><ul><li>提高顶部导航区的层级，否则就会被<code>swiper</code>覆盖</li><li>搜索图标的显隐：在输入时，搜索图标自动消失</li><li>给输入框绑定<code>bind:input</code>事件，在<code>data</code>里设置一个变量<code>iconShow</code>来控制图标的显隐</li></ul><h4 id="第四步：顶部的swiper与底部banner区"><a href="#第四步：顶部的swiper与底部banner区" class="headerlink" title="第四步：顶部的swiper与底部banner区"></a>第四步：顶部的<code>swiper</code>与底部<code>banner</code>区</h4><blockquote><ul><li><code>swiper</code>使用<code>swiper</code>与<code>swiper-item</code>结合实现</li><li><code>banner</code>区的跳转&#x3D;&#x3D;(需补充)&#x3D;&#x3D;</li></ul></blockquote><h4 id="第五步-取餐方式跳转"><a href="#第五步-取餐方式跳转" class="headerlink" title="第五步 取餐方式跳转"></a>第五步 取餐方式跳转</h4><ol><li>思路<blockquote><ul><li>选择取餐方式之后进入菜单页面</li><li>菜单页面会根据点进来的方式，显示外卖还是自取，所以从首页跳转到菜单页必须<strong>携带参数</strong></li><li>根据之前学习过的声明式导航和编程式导航可知，这两种方式在跳转到<code>tabBar</code>页面时，不能携带参数</li></ul></blockquote></li></ol><blockquote><blockquote><p>解决方案：<br><a href="https://developers.weixin.qq.com/community/develop/article/doc/00000453df06f07a5c8d91ef856c13">参考回答</a></p></blockquote><ul><li>全局变量：通过<code>App</code>全局对象存放全局变量</li><li>数据缓存：通过存储到数据缓存中。</li><li>事件通信：通过事件通信通道。</li><li><code>wx.reLaunch(Object object)</code>，<code>url</code>路径后可以带参数，参数与路径之间使用<code>?</code>分隔</li></ul></blockquote><h4 id="数据动态化"><a href="#数据动态化" class="headerlink" title="数据动态化"></a>数据动态化</h4><img src="./src/首页获取数据.png"><ol><li>单独配置发起网络请求的方法(全局可使用)</li></ol><ul><li><p>新建<code>config</code>文件</p><blockquote><ul><li>新建<code>api.js</code>文件，保存服务器接口根地址</li><li>新建<code>exception-message</code>文件，保存错误码字典</li></ul></blockquote></li><li><p>在<code>utils</code>文件夹中</p><blockquote><ul><li>新建<code>wxToPromise</code>文件，用于转换原生不支持<code>Promise</code>的官方<code>API</code></li><li>新建<code>http</code>文件<ul><li><code>request</code>方法：用于通过<code>wxToPromise</code>获得带有数据的<code>promise</code>对象，并进行错误信息比对</li><li><code>_showError</code>方法，如果发生请求错误，用于在页面展示错误信息</li></ul></li></ul></blockquote></li></ul><ol start="2"><li>新建<code>model</code>文件夹<blockquote><ul><li>新建<code>Home</code>类，用于获取首页数据</li></ul></blockquote></li></ol><h3 id="菜单页"><a href="#菜单页" class="headerlink" title="菜单页"></a>菜单页</h3><h4 id="基础准备-1"><a href="#基础准备-1" class="headerlink" title="基础准备"></a>基础准备</h4><ol><li>需要实现的效果</li></ol><ul><li>获取离自己最近的店及距离(需要申请<code>wx.getLocation</code>接口)</li><li>点击左侧菜单栏，可获取对应分类的产品</li><li>点击产品，可选择产品规格、数量等</li><li>加入购物车后，其他页面的变化</li></ul><ol start="2"><li>难点</li></ol><ul><li>左侧导航与右侧商品的关联</li><li>选品框：产品规格的选择、价格与数量联动、所选信息在其他页面上的使用</li></ul><blockquote><ul><li>取消整个页面的滚动条：在<code>json</code>中配置”disableScroll”: true&#96;</li></ul></blockquote><h4 id="数据动态化-1"><a href="#数据动态化-1" class="headerlink" title="数据动态化"></a>数据动态化</h4><ul><li>新建<code>Menu</code>模块，获取菜单页数据</li><li>其他与首页类似</li></ul><h4 id="页面布局"><a href="#页面布局" class="headerlink" title="页面布局"></a>页面布局</h4><ol><li>顶部</li></ol><ul><li>为了将它固定在顶部，不随页面滚动，使用粘性定位</li><li>右侧的取餐方式，根据参数选中，默认为外卖<blockquote><ul><li>创建变量<code>takeWayIndex</code>保存参数</li><li>在<code>onLoad</code>生命周期函数里通过<code>options</code>获取首页传来的参数</li><li>注意！：<strong>只有</strong>点击首页的选择框跳转，<code>options</code>才会获取参数，但，如果首次加载是直接点击<code>tabBar</code>到菜单页，那<code>options</code>就是一个空对象<code>&#123;&#125;</code></li><li>因此只在<code>options</code>不为空对象时，修改<code>takeWayIndex</code></li><li>要使用<code>(JSON.stringify(options) === &quot;&#123;&#125;&quot;)</code>进行判断；携带了参数时，<code>options</code>也是对象，所以不能通过数据类型判断</li></ul></blockquote></li></ul><ol start="2"><li>下方商品列表</li></ol><ul><li>为了实现竖向滚动，左右都设为<code>scroll-view</code></li><li>左侧分类及右侧<code>banner</code>：动态获取数据，列表渲染</li><li>左侧选中状态：<blockquote><ul><li>创建一个变量<code>navLeftIndex</code>表示当前选中分类的索引，</li><li>绑定点击事件，使用自定义属性将当前被点击的分类下标传入，修改<code>navLeftIndex</code>；</li><li>只有当<code>navLeftIndex===index</code>时，被选中样式才会生效</li><li>为了不让选中标识影响文字，我给每个分类都设置了<code>divider </code>，选中时，只改变颜色</li></ul></blockquote></li></ul><ol start="3"><li>右侧商品栏</li></ol><ul><li>顶部<code>banner</code></li><li>动态渲染商品列表</li></ul><ol start="4"><li>如何点击左侧分类，右侧获取对应商品</li></ol><ul><li>定义变量<code>navLeftIndex</code>保存左侧被点击分类的索引</li><li>左侧被点击时，通过自定义属性修改<code>navLeftIndex</code>变量</li><li>右侧产品在进行列表渲染，根据<code>navLeftIndex</code>获取商品数据</li></ul><h4 id="选品页"><a href="#选品页" class="headerlink" title="选品页"></a>选品页</h4><ol><li><p>基础准备</p><blockquote><ul><li>新建组件<code>product-detail</code>，作为点击商品列表时打开的选品页</li><li>父页面：菜单页</li><li>需引入的子组件：图标组件<code>icon</code>、数量组件<code>cartNum</code><ul><li>数量组件也引用了图标组件<code>icon</code></li></ul></li></ul></blockquote></li><li><p>难点：</p><blockquote><ul><li>获取所点击的产品数据，并列表渲染嵌套了三层的数据</li><li>规格选择</li><li>金额与数量的联动，以及在其他页面的使用</li><li>商品加入购物车后，对其他页面的影响</li></ul></blockquote></li><li><p>本页面需要实现的效果及方法</p></li></ol><ul><li><p>选品页的打开与关闭</p><blockquote><ul><li>在父页面定义一个变量<code>detailFlag</code>，作为开关，默认为<code>true</code>；通过属性绑定将<code>detailFlag</code>传给组件</li><li>当父页面的产品发生点击事件时，将<code>detailFlag</code>修改为<code>false</code></li><li>组件的父容器<code>container</code>通过<code>hidden</code>属性来控制显隐</li><li>组件页面的关闭按钮，在被点击时，将<code>detailFlag</code>修改为<code>true</code></li></ul></blockquote></li><li><p>页面数据的动态化</p><blockquote><ul><li>在父页面的产品被点击时，保存该产品的<code>id</code></li><li>在<code>Menu</code>模块里，写一个静态方法，获取商品详情数据，保存在<code>detailInfo</code>变量里</li><li>通过属性绑定将该商品的数据传给组件，这样组件接收到的数据就是每次点击的商品数据了</li><li>使用<code>Mustache</code>语法将数据绑定到页面</li><li>注意产品规格的数据渲染，可定义<code>wx:for-item=&quot;&quot;</code>来区分子项：<ul><li>产品数据的<code>specs</code>里有三个规格</li><li>不同规格下有对应id和<code>specsDesc</code></li><li><code>specsDesc</code>放置的是不同的选择项及其<code>id</code></li></ul></li></ul></blockquote></li><li><p>商品规格的选择</p><blockquote><p>我踩过的坑</p><ul><li>一开始我选择的是<code>navLeftIndex===index</code>的方法，发现每个规格都会同时选中同一个选项</li></ul></blockquote></li></ul><blockquote><p>解决办法：<br><img src="./src/选品页.png"></p></blockquote><blockquote><ul><li>选中条件：选项的<code>isActive</code>为<code>true</code>；</li><li>而<code>isActive</code>在接口里已经定义了，也有默认选项；因此，需要改变页面所渲染的数据<code>detailInfo</code></li><li>如何改变？<ul><li>在点击规格选项时，将当前选项的id、当前规格的id、当前规格的所有数据都传到<code>js</code>里</li><li>在点击事件的事件处理函数里，for循环遍历当前规格的所有数据，先将所有选项的<code>isActive</code>改为<code>false</code>，再根据选项id，将该选项的<code>isActive</code>改为<code>true</code></li><li>遍历<code>detailInfo</code>，根据当前规格的id找到该规格下的数据，替换成前面修改过的；再将修改后的<code>detailInfo</code>更新到页面中</li></ul></li></ul></blockquote><ul><li>商品金额与数量的联动<blockquote><ul><li>数量的增减使用的是另一个组件</li></ul></blockquote></li></ul><blockquote><p>先分析下逻辑</p><ul><li>在产品点击后，数量默认为最小值1，此时选品框里的金额，就等于产品的单价</li><li>当数量增减时，金额等于单价*数量</li></ul></blockquote><blockquote><p>思路：</p><ul><li>数量组件需要通过事件绑定的方式将数量传给选品组件</li><li>选品组件定义一个变量<code>num</code>保存从子组件接收的值</li><li>选品组件定义一个变量<code>totalMoney</code>保存金额，默认为0，使用三元运算，当它为0时，页面使用接口里的值</li><li>和数量组件绑定的事件处理函数中，根据传来的<code>num</code>修改金额<blockquote><p>这样金额就和数量绑定在了一起，但存在以下问题：</p></blockquote></li></ul></blockquote><blockquote><p>问题：</p><ul><li>关闭选品框后，再打开另一产品，金额和数量不变</li></ul><p>解决方法：</p><ul><li>在关闭按钮的点击事件中，将金额重置为0，这样页面就会使用原始数据；将数量重置为最小值</li></ul></blockquote><ul><li>数量组件的优化<blockquote><p><strong>优化1：</strong>当数量达到边界值时，不再改变，且颜色变灰，表示不能再点击</p><ul><li>去掉图标组件的默认颜色，只声明类型(否则替换不了颜色，优先级太高)</li><li>父组件如何改变子组件的样式类？使用外部样式类<ul><li>在子组件中的<code>js</code>文件里用<code>externalClasses</code>定义外部样式类名，并写入对应标签的<code>class</code>中</li><li>父组件就可以直接在标签中用<code>外部样式类名=&quot;类名&quot;</code>的方式定义样式</li><li>当数量超过临界值时，就改变样式</li></ul></li></ul></blockquote></li></ul><blockquote><p><strong>优化2</strong>：点击事件的触发</p><ul><li>尝试1：使用<code>pointer-events: none;</code>发现无效，确认是小程序不支持该属性</li><li>尝试2：定义一个变量<code>isHandleClick</code>作为开关<ul><li>只在<code>isHandleClick</code>为<code>true</code>时才能点击</li><li>当<code>num</code>超过某一边的边界值时，<code>isHandleClick</code>变为<code>false</code>，不能再点击了，但！另一边的按钮也同时不能点击了</li></ul></li><li>尝试3：定义两个变量：<code>isAddClick</code>和<code>isMinClick</code><ul><li>这两个变量分别控制增加和减少按钮</li><li>和前面一样，当关闭选品页时，变量要重置，因此把这两个变量定义在选品组件里，通过属性绑定的方式传给数量组件</li><li>在增减按钮的点击事件函数中，根据临界值修改变量</li></ul></li></ul></blockquote><h4 id="Storage本地存储"><a href="#Storage本地存储" class="headerlink" title="Storage本地存储"></a>Storage本地存储</h4><ul><li><p>商品在选品时，加入购物车后，其他页面要显示对应的商品信息</p></li><li><p>因此需要将加入购物车的商品信息存在本地存储中</p></li><li><p>统一封装storage</p><blockquote><ul><li>在<code>utils</code>文件夹里，创建<code>storage.js</code>文件</li></ul></blockquote></li></ul><pre><code>/** * 微信小程序标准版：统一封装的 storage 操作类 */class Storage &#123;  //类数组，通过[属性]的方式调用  types = &#123;    1: &#39;get&#39;, // get    2: &#39;set&#39;, // set    3: &#39;rm&#39; // rm  &#125;  /**   * 检验本地存储 key 是否合法   * @param &#123;String&#125; key | 要操作的键值   * @param &#123;Number&#125; type | 类型，是 get set rm    * @param &#123;Boolean&#125; emptyFlag | 是否判断为空情况，默认判断 true，false 为不判断   */  checkKeyType(key, type, emptyFlag = true) &#123;    if (typeof key != &#39;string&#39;) &#123;      throw new Error(`Storage $&#123;this.types[type]&#125; func: key must be string`)      return false    &#125;    if (emptyFlag) &#123;      let tmpKey = key.TrimStr()      if (tmpKey == &#39;&#39;) &#123;        throw new Error(`Storage $&#123;this.types[type]&#125; func: key can not be empty`)        return false      &#125;      return tmpKey;    &#125;    return key  &#125;  /**   * get方法 从本地缓存中获取指定key的值   * @param &#123;String&#125; key | 要操作的键值   * @param &#123;Boolean&#125; syncFlag | 同步状态，默认 false (异步)，true 为同步   */  get = (key, syncFlag = false) =&gt; &#123;    const tmpKey = this.checkKeyType(key, 1)    if (tmpKey) &#123;      const errMsg = &#39;Storage get: failed to get data&#39;      return new Promise((resolve, reject) =&gt; &#123;        if (syncFlag) &#123;          let res = wx.getStorageSync(tmpKey)          if (res) &#123;            resolve(JSON.parse(res))          &#125; else &#123;            reject(errMsg)          &#125;        &#125; else &#123;          wx.getStorage(&#123;            key: tmpKey,            success: (res) =&gt; &#123;              resolve(JSON.parse(res.data))            &#125;,            fail: (err) =&gt; &#123;              reject(errMsg)            &#125;          &#125;)        &#125;      &#125;)    &#125;  &#125;  /**   * 将数据保存在本地存储的指定key中 会覆盖掉原来该 key 对应的内容   * @param &#123;String&#125; key | 要操作的键值   * @param &#123;*&#125; data | 要存储的值，会转换为 JSON 串进行存储   * @param &#123;Boolean&#125; syncFlag | 同步状态，默认 false (异步)，true 为同步   */  set = (key, data, syncFlag) =&gt; &#123;    const tmpKey = this.checkKeyType(key, 2)    if (tmpKey) &#123;      const sucMsg = &#39;Storage set: set data successfully&#39;      const errMsg = &#39;Storage set: failed to set data&#39;      return new Promise((resolve, reject) =&gt; &#123;        let tmpData = JSON.stringify(data)        if (syncFlag) &#123;          try &#123;            wx.setStorageSync(tmpKey, tmpData)            resolve(sucMsg)          &#125; catch (err) &#123;            console.log(err)            reject(errMsg)          &#125;        &#125; else &#123;          wx.setStorage(&#123;            data: tmpData,            key: tmpKey,            success: () =&gt; &#123;              resolve(sucMsg)            &#125;,            fail: (err) =&gt; &#123;              console.log(err)              reject(errMsg)            &#125;          &#125;)        &#125;      &#125;)    &#125;  &#125;  /**   * 可以移除本地存储中指定key的数据 如果不指定则清除全部数据   * @param &#123;String&#125; key | 要操作的键值，为空则清空所有，有值则清空指定的值   * @param &#123;Boolean*&#125; syncFlag | 同步状态，默认 false (异步)，true 为同步   */  rm = (key = &#39;&#39;, syncFlag = false) =&gt; &#123;    let tmpKey = this.checkKeyType(key, 3, false)    tmpKey = tmpKey.TrimStr()    const sucMsg = &#39;Storage rm: rm data successfully&#39;    const errMsg = &#39;Storage rm: failed to rm data&#39;    return new Promise((resolve, reject) =&gt; &#123;      if (tmpKey == &#39;&#39;) &#123;        if (syncFlag) &#123;          try &#123;            wx.clearStorageSync()            resolve(sucMsg)          &#125; catch (err) &#123;            console.log(err)            reject(errMsg)          &#125;        &#125; else &#123;          wx.clearStorage(&#123;            success: (res) =&gt; &#123;              resolve(sucMsg)            &#125;,            fail: (err) =&gt; &#123;              console.log(err)              reject(errMsg)            &#125;          &#125;)        &#125;      &#125; else &#123;        if (syncFlag) &#123;          try &#123;            wx.removeStorageSync(tmpKey)            resolve(sucMsg)          &#125; catch (err) &#123;            console.log(err)            reject(errMsg)          &#125;        &#125; else &#123;          wx.removeStorage(&#123;            key: tmpKey,            success: () =&gt; &#123;              resolve(sucMsg)            &#125;,            fail: (err) =&gt; &#123;              console.log(err)              reject(errMsg)            &#125;          &#125;)        &#125;      &#125;    &#125;)  &#125;&#125;/** * 清除字符串前后的空格 */String.prototype.TrimStr = function () &#123;  return this.replace(/(^\s*)|(\s*$)/g, &#39;&#39;);&#125;export &#123;  Storage&#125;</code></pre><ul><li>使用：<blockquote><ul><li>在<code>app.js</code>顶部引入并注册 App 上</li></ul></blockquote></li></ul><pre><code>// app.jsimport &#123; Storage &#125; from &#39;./utils/storage&#39;const storage = new Storage();App(&#123;  storage,  getStorage: storage.get,  setStorage: storage.set,  rmStorage: storage.rm,...省略&#125;)</code></pre><blockquote><ul><li>在页面中使用</li></ul></blockquote><pre><code>// component/product-detail/product-detail.js//获取应用实例const app = getApp()Component(&#123;  //app打点的方式调用&#125;)</code></pre><h4 id="加入购物车-详情页"><a href="#加入购物车-详情页" class="headerlink" title="加入购物车(详情页)"></a>加入购物车(详情页)</h4><ol><li>实现效果</li></ol><ul><li>当用户选择商品数量，点击添加购物车后，能将该商品信息及选择数量保存在缓存中，使其他页面也能得到该数据</li><li>交互效果：弹出提示框，超过库存或添加成功</li><li>徽标：商品添加购物车后，购物车的tabBar部分会出现相应的数量</li></ul><ol start="2"><li>难点</li></ol><ul><li>相同的<code>key</code>保存的数据会被覆盖</li><li>数量组件、选品页面、购物车页面之间的数据传递</li></ul><ol start="3"><li>实现步骤</li></ol><ul><li><p>给<code>加入购物车按钮</code>添加点击事件</p></li><li><p>变量<code>selectNum</code>，用于保存当次选择的数量，即数量组件传过来的值</p></li><li><p>变量<code>numInCart</code>，用于当前产品已添加的总数</p><blockquote><ul><li>以上两个字段都要添加到<code>storage</code>里面，设置两个变量的目的在于：重复添加同一产品时，<code>numInCart</code>保存着上一次添加的数量，<code>selectNum</code>为本次添加的数量，需要相加后更新到<code>numInCart</code>中，作为总数</li></ul></blockquote></li><li><p>用<code>cartInfo</code>作为key值，在本地存储中保存购物数据</p></li><li><p>由于同一key的数据会被覆盖，而商品数据不止一条；因此，把商品数据都放入数组中，新数据<code>push</code>进数组</p></li><li><p>在更新<code>cartInfo</code>时，会遇到三种情况</p><blockquote><ul><li>第一种，第一次添加时，<code>storage</code>中没有<code>cartInfo</code>数据<ul><li>为<code>detailInfo</code>添加<code>numInCart</code>字段，表示添加商品的总数，就等于<code>selectNum</code></li><li>声明一个空数组，并将<code>detailInfo</code>存进数组</li><li>使用<code>setStorage</code>方法，将数组加入本地缓存</li></ul></li><li>第二种，<code>cartInfo</code>已经有该商品</li><li>第三种，<code>cartInfo</code>没有该商品</li></ul></blockquote></li><li><p>后面两种情况：</p><blockquote><ul><li>首先需要判断是否已经存过<ul><li>声明一个变量作为标志<code>isExist</code>，默认为<code>false</code>，表示缓存中没有该商品</li><li>获取缓存中的<code>cartInfo</code>，并进行遍历</li><li>将缓存中数据的id与当前商品的id进行对比，如果相等就将<code>isExist</code>修改为<code>true</code></li></ul></li><li><code>isExist</code>为<code>true</code>，存在同一产品：<ul><li>将两次添加的数量相加</li><li>判断库存，如果不超过库存，就添加进<code>storage</code>，超过了就提示</li></ul></li><li><code>isExist</code>为<code>false</code>，没存过：<ul><li>更新<code>numInCart</code></li><li>判断库存，如果不超过库存，就添加进<code>storage</code>，超过了就提示</li></ul></li></ul></blockquote></li></ul><ol start="4"><li>购物车的徽标<br><strong>效果：</strong></li></ol><ul><li>初始化时，并没有徽标</li><li>商品加入购物车后，徽标显示当前添加的商品数量(不是杯数)</li></ul><p><strong>什么时候更新徽标数据</strong></p><ul><li>用户在关闭详情页时，此时已成功加入购物车</li><li>整个小程序在启动时，需要先获取本地存储中是否有数据<blockquote><ul><li>当数据存储在本地缓存中指定的key中，除非用户主动删除或因存储空间原因被系统清理，否则数据都一直可用</li></ul></blockquote></li><li>切换到购物车页面时，要获取最新数据</li></ul><h3 id="购物车页面"><a href="#购物车页面" class="headerlink" title="购物车页面"></a>购物车页面</h3><h4 id="基础准备-2"><a href="#基础准备-2" class="headerlink" title="基础准备"></a>基础准备</h4><ul><li>数据来源：本地缓存<code>storage</code></li><li>效果：<blockquote><ul><li>展示已选择商品的名称、价格、规格、数量等信息</li><li>商品结算时，金额与数量之间的联动、跳转到订单页结算</li><li>滑动删除商品</li></ul></blockquote></li><li>难点<blockquote><ul><li>单选&#x2F;全选商品时，总金额与数量之间的逻辑处理</li></ul></blockquote></li></ul><h4 id="购物车布局"><a href="#购物车布局" class="headerlink" title="购物车布局"></a>购物车布局</h4><ol><li>商品列表布局<blockquote><ul><li>拿到<code>storage</code>里的数据，遍历数据</li><li>规格需要三层遍历，分隔线<code>/</code>用伪元素做</li><li>选择按钮：给商品数据添加<code>selected</code>字段，用<code>wx:if</code>和<code>wx:else</code>控制显隐</li></ul></blockquote></li></ol><p><strong>细节：</strong></p><blockquote><ul><li>用户可以直接在购物车页面修改数量，因此需要保存修改后的值，更新页面</li><li>当页面隐藏&#x2F;切换时，要获取购物车页面的最新数据，并更新到<code>cartInfo</code>中</li></ul></blockquote><ol><li><p>空购物车界面</p><blockquote><ul><li>单独封装成自定义组件，实现复用</li></ul></blockquote></li><li><p>底部提交订单栏和滑动删除按钮</p></li></ol><p><strong>布局实现：使用<code>vant</code>组件</strong></p><blockquote><ul><li>初始化<code>npm -y</code></li><li>安装npm包：<code>npm i @vant/weapp -S --production</code></li><li>将 <code>app.json</code> 中的 <code>&quot;style&quot;: &quot;v2&quot;</code> 去除</li><li>打开微信开发者工具，点击 工具 -&gt; 构建<code>npm</code></li><li>在页面的<code>json</code>文件中引入组件</li></ul></blockquote><pre><code>&quot;usingComponents&quot;: &#123;  &quot;van-swipe-cell&quot;: &quot;@vant/weapp/swipe-cell/index&quot;,  &quot;van-submit-bar&quot;: &quot;@vant/weapp/submit-bar/index&quot;&#125;</code></pre><blockquote><ul><li>根据对应文档使用组件</li></ul></blockquote><p><strong>底部提交订单栏——js逻辑</strong></p><ul><li>效果<blockquote><ul><li>点击全选，可实现全选&#x2F;全不选购物车中所有商品</li><li>总金额会随选中的商品及其数量的变化而变化</li><li>结算的数量由<code>selected</code>字段决定</li></ul></blockquote></li><li>思路：<blockquote><p><strong>全选</strong></p><ul><li>声明一个变量<code>selectedAll</code>，作为全选的标识，默认为<code>false</code>，即没有全选</li><li>在全选按钮的点击事件中<ul><li>如果<code>selectedAll</code>为<code>false</code>，那就遍历购物车中所有商品，将<code>selected</code>字段都修改成<code>true</code>；修改完之后，再将<code>selectedAll</code>改为<code>true</code>，也就是已经<strong>全选</strong>了</li><li>在下一次点击时，看到<code>selectedAll</code>为<code>true</code>，就将购物车中所有商品的<code>selected</code>字段都修改成<code>false</code>，再将<code>selectedAll</code>改为<code>false</code>，这样就能实现<strong>全不选</strong></li><li>更新总金额和选择数量</li></ul></li></ul><p><strong>单选</strong></p><ul><li>拿到当前点击的商品数据，添加<code>selected</code>字段，并且值为相反值<br><code> cartInfo[index].selected = !cartInfo[index].selected</code><ul><li><code>selected</code>默认为<code>false</code>，这样既添加了新字段，又实现了两次点击的值相反</li><li>更新总金额和选择数量<br>细节：</li></ul></li><li>选中商品的数量为0时，结算按钮为灰色，不能点击；用三元运算符控制</li></ul></blockquote></li></ul><blockquote><p><strong>总金额和选择数量</strong></p><ul><li>由于单选或全选时都要更新总金额，因此单独定义一个方法<code>_updataMoney</code></li><li>声明一个变量<code>payMoney</code>，保存总金额</li><li>每次调用该方法，都会将<code>cartInfo</code>遍历一次，计算所有<code>selected</code>等于<code>true</code>的数据的 <strong>总金额和数量</strong></li><li>定义一个变量<code>isSelectedAll</code>，作为全选标志，默认为<code>true</code><ul><li>在遍历<code>cartInfo</code>时，任一商品的<code>selected</code>等于<code>false</code>，<code>isSelectedAll</code>就变成<code>false</code>，表示没有全选，因此将<code>selectedAll</code>修改为<code>false</code></li><li>在遍历完之后，如果<code>isSelectedAll</code>仍为<code>true</code>，就表示单选了购物车中所有商品，此时全选按钮应该亮起，因此将<code>selectedAll</code>修改为<code>true</code></li></ul></li><li>更新<code>cartInfo</code>和本地缓存</li></ul></blockquote><p><strong>滑动删除</strong></p><blockquote><ul><li>根据文档，使用<code>vant</code>组件进行布局</li><li>给删除按钮添加点击事件，用自定义属性传递索引</li><li>根据索引，找到当前点击的商品数据，把它从<code>cartInfo</code>数组中删除</li><li>调用方法更新总金额</li><li>更新缓存</li></ul></blockquote><p><strong>去结算</strong></p><blockquote><ul><li>声明一个空对象<code>acountData</code>保存要传递给订单页的数据</li><li>在结算按钮的点击事件中，将所有被选中的商品保存到一个空数组中</li><li>将总金额和结算数组保存到<code>acountData</code>对象中</li><li>将<code>acountData</code>作为新的<code>key</code>存入本地缓存，订单页可以通过该<code>key</code>获取数据</li><li>跳转到订单页</li></ul></blockquote><h3 id="订单页"><a href="#订单页" class="headerlink" title="订单页"></a>订单页</h3><p><strong>效果</strong></p><ul><li>滑动&#x2F;点击切换tabs标签可查看不同状态的订单</li><li>付款</li></ul><p><strong>难点</strong></p><ul><li>通过<code>WXS</code>和节流函数优化频繁划动切换带来的性能问题</li><li>支付成功后，删除购物车中的商品</li></ul><p><strong>布局</strong></p><ul><li>顶部分类栏</li><li>加入购物车的商品动态渲染</li><li>空订单时的界面：复用组件</li></ul><h4 id="实现tabs标签的切换"><a href="#实现tabs标签的切换" class="headerlink" title="实现tabs标签的切换"></a>实现tabs标签的切换</h4><ol><li>原理</li></ol><ul><li>在点击&#x2F;滑动事件中，将目标索引传入js中，保存在<code>currentTabIndex</code>中，当<code>tabs</code>标签的索引等于<code>currentTabIndex</code>时，激活选中样式</li><li>最重要的是传入目标索引，点击切换比较简单</li></ul><ol start="2"><li><p>滑动切换<br><strong>思路</strong></p><blockquote><ul><li>在视图层<code>wxml、wxs</code>中处理<code>touchmove</code>事件，在处理完成之后，再将事件的结果传给逻辑层</li><li>控制灵敏度：计算手指触摸开始和结束的距离，当该距离在一定范围内时，再向逻辑层传递结果</li></ul></blockquote></li><li><p>节流优化</p></li></ol><ul><li>在接收滑动&#x2F;点击事件传来的<code>index</code>时，引入节流函数，控制执行频率</li></ul><h4 id="与购物车页面相关"><a href="#与购物车页面相关" class="headerlink" title="与购物车页面相关"></a>与购物车页面相关</h4><ol><li><p>点击结算之后删除商品</p><blockquote><ul><li>循环遍历加入本地缓存中的<code>acountList</code>数组，与<code>cartInfo</code>数据进行对比，删除相同数据，更新缓存和页面的<code>cartInfo</code></li></ul></blockquote></li><li><p><code>acountData</code>的调整</p><blockquote><ul><li>如果用户分几次结算商品，那么为了不覆盖前面的数据</li><li>应该先获取缓存中的商品数组和金额，然后将本次的商品<code>push</code>进去，计算总金额时也要加上前面的，最后更新缓存</li></ul></blockquote></li></ol><h3 id="个人中心"><a href="#个人中心" class="headerlink" title="个人中心"></a>个人中心</h3><ul><li><p>布局</p><blockquote><ul><li>创建两种状态的登录框</li><li>下方的列表在登录状态不同时，也应该不一样</li></ul></blockquote></li><li><p>开放能力</p><blockquote><ul><li>微信官方有在线客服和意见反馈的功能</li><li>将 <code>button</code> 组件 <code>open-type</code> 的值设置为 <code>contact</code>，当用户点击后就会进入客服会话</li><li>将 <code>button</code> 组件 <code>open-type</code> 的值设置为 <code>feedback</code>，当用户点击后就会打开“意见反馈”页面，用户可提交反馈内容并上传日志</li></ul></blockquote></li></ul><h4 id="授权登录——云开发"><a href="#授权登录——云开发" class="headerlink" title="授权登录——云开发"></a>授权登录——云开发</h4><p><strong>步骤：</strong></p><ul><li><p>使用<code>wx.getUserProfile</code>获取用户头像和昵称</p></li><li><p>创建云开发环境</p><blockquote><ul><li>在项目根目录 <code>project.config.json</code> 项目配置文件中，初始化配置云函数的文件夹的目录</li><li>在项目根目录中，新建 <code>cloud</code> 文件夹，并选择项目对应的环境</li></ul></blockquote></li><li><p>初始化</p><blockquote><ul><li>在云开发控制台中，创建数据表 <code>users</code> 用于存储用户信息</li><li>在 <code>cloud</code> 文件夹上右键 -&gt; 选择”新建 <code>Node.js</code> 云函数”，输入云函数名称 <code>login</code> 即可新建成功</li><li>在小程序 <code>app.js</code> 中初始化云函数</li><li>上传并部署云函数(每次修改云函数都要重新上传)</li><li>在微信端调用云函数，将<code>wx.getUserProfile</code>获取的用户头像和昵称等用户信息传给后端，用于生成用户账号</li></ul></blockquote></li><li><p>在<code>cloud/login/index.js</code>中编写根据<code>openId</code>查询用户信息的方法，根据查询返回的数组的长度来决定下一步是注册还是登录</p></li><li><p>注册用户账号</p><blockquote><ul><li>在 <code>cloud/login/index.js</code> 云函数中完成用户信息的注册，在数据库中新增用户数据</li><li>当用户注册成功后，根据 ID 快速查询当前用户的信息，并返回给前端</li><li>上传并部署云函数</li></ul></blockquote></li><li><p>实现登录逻辑</p><blockquote><ul><li>如果已经注册，就可以返回根据<code>openId</code>到的查询用户信息</li></ul></blockquote></li><li><p>小程序页面逻辑</p><blockquote><ul><li>获取登录后的数据，并将数据库中真实的用户信息同步到本地存储中，做数据的持久化</li><li>当页面切换时，实时获取最新的用户数据</li><li>注意：要在云开发控制台中，修改数据库的权限，选择所有用户可读</li></ul></blockquote></li></ul>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> applet </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HTML及vscode</title>
      <link href="/2023/11/19/HTML%E5%8F%8Avscode/"/>
      <url>/2023/11/19/HTML%E5%8F%8Avscode/</url>
      
        <content type="html"><![CDATA[<span id="more"></span><div class="markmap-container" style="height:400px">  <svg data="{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:1,&quot;p&quot;:{&quot;lines&quot;:[0,1]},&quot;v&quot;:&quot;HTML&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:2,&quot;p&quot;:{&quot;lines&quot;:[2,3]},&quot;v&quot;:&quot;定义&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[4,5]},&quot;v&quot;:&quot;描述网页的语言 / 超文本标记语言&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:5,&quot;p&quot;:{&quot;lines&quot;:[6,7]},&quot;v&quot;:&quot;超出文本的限制：可使用img/audio/vedio等&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:5,&quot;p&quot;:{&quot;lines&quot;:[8,9]},&quot;v&quot;:&quot;超链接文本：实现文件间的跳转&quot;}]}]},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:2,&quot;p&quot;:{&quot;lines&quot;:[10,11]},&quot;v&quot;:&quot;html骨架&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[12,13]},&quot;v&quot;:&quot;文档声明：!DOCTYPE&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:5,&quot;p&quot;:{&quot;lines&quot;:[14,15]},&quot;v&quot;:&quot;告诉浏览器的解析器，用什么规范来解析页面&quot;}]},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[16,17]},&quot;v&quot;:&quot;语言类型：lang=&amp;quot;en&amp;quot;&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:5,&quot;p&quot;:{&quot;lines&quot;:[18,19]},&quot;v&quot;:&quot;声明语言类型&quot;}]},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[20,21]},&quot;v&quot;:&quot;网页配置：head&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:5,&quot;p&quot;:{&quot;lines&quot;:[22,23]},&quot;v&quot;:&quot;网页标题：title&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:5,&quot;p&quot;:{&quot;lines&quot;:[24,25]},&quot;v&quot;:&quot;meta：元标签&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:7,&quot;p&quot;:{&quot;lines&quot;:[26,27]},&quot;v&quot;:&quot;声明网页字符编码集：charset&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:9,&quot;p&quot;:{&quot;lines&quot;:[28,29]},&quot;v&quot;:&quot;UTF-8：全球语言&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:9,&quot;p&quot;:{&quot;lines&quot;:[30,31]},&quot;v&quot;:&quot;gbk：汉语、英语、少量日韩&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:9,&quot;p&quot;:{&quot;lines&quot;:[32,33]},&quot;v&quot;:&quot;ASCII：英语&quot;}]},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:7,&quot;p&quot;:{&quot;lines&quot;:[34,35]},&quot;v&quot;:&quot;http-equiv=&amp;quot;X-UA-Compatible&amp;quot; content=&amp;quot;IE=edge&amp;quot;&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:9,&quot;p&quot;:{&quot;lines&quot;:[36,37]},&quot;v&quot;:&quot;IE8及以上版本使用当前版本的最高级标准模式去渲染网页&quot;}]},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:7,&quot;p&quot;:{&quot;lines&quot;:[38,39]},&quot;v&quot;:&quot;name&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:9,&quot;p&quot;:{&quot;lines&quot;:[40,41]},&quot;v&quot;:&quot;移动端适配：viewport&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:11,&quot;p&quot;:{&quot;lines&quot;:[42,43]},&quot;v&quot;:&quot;宽度为设备实际宽度：width=device-width&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:11,&quot;p&quot;:{&quot;lines&quot;:[44,45]},&quot;v&quot;:&quot;不需要缩放：initial-scale=1.0&quot;}]},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:9,&quot;p&quot;:{&quot;lines&quot;:[46,47]},&quot;v&quot;:&quot;网页关键词：key&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:9,&quot;p&quot;:{&quot;lines&quot;:[48,49]},&quot;v&quot;:&quot;网页描述：description&quot;}]}]}]},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[50,51]},&quot;v&quot;:&quot;网页内容：body&quot;}]},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:2,&quot;p&quot;:{&quot;lines&quot;:[52,53]},&quot;v&quot;:&quot;HTML5优点/新特性&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[54,55]},&quot;v&quot;:&quot;形成了HTML5标准的文档声明，不再基于SGML&quot;},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[56,57]},&quot;v&quot;:&quot;新增了语义化标签&quot;},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[58,59]},&quot;v&quot;:&quot;支持多媒体：audio、vedio&quot;},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[60,61]},&quot;v&quot;:&quot;画布canvas可以绘制各种形状&quot;},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[62,63]},&quot;v&quot;:&quot;可以使用SOL数据库、支持存储离线数据：sessionStorage、localStorage&quot;},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[64,65]},&quot;v&quot;:&quot;新的文档属性：document.visibilityState&quot;},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[66,67]},&quot;v&quot;:&quot;支持定位、拖动和放置&quot;}]},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:2,&quot;p&quot;:{&quot;lines&quot;:[68,69]},&quot;v&quot;:&quot;语义化&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[70,71]},&quot;v&quot;:&quot;概念&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:5,&quot;p&quot;:{&quot;lines&quot;:[72,73]},&quot;v&quot;:&quot;使用有英文语义的标签&quot;}]},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[74,75]},&quot;v&quot;:&quot;作用/原因&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:5,&quot;p&quot;:{&quot;lines&quot;:[76,77]},&quot;v&quot;:&quot;在没有样式的情况下，也能够看得懂网页框架&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:5,&quot;p&quot;:{&quot;lines&quot;:[78,79]},&quot;v&quot;:&quot;爬虫依赖标签来确定上下文和关键词的权重，语义化有利于SEO优化&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:5,&quot;p&quot;:{&quot;lines&quot;:[80,81]},&quot;v&quot;:&quot;国际化，各国开发者都能看得懂&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:5,&quot;p&quot;:{&quot;lines&quot;:[82,83]},&quot;v&quot;:&quot;提供可维护性，减少差异&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:5,&quot;p&quot;:{&quot;lines&quot;:[84,85]},&quot;v&quot;:&quot;有利于帮助辅助技术更好地转义网页，例如无障碍阅读&quot;}]}]},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:2,&quot;p&quot;:{&quot;lines&quot;:[86,87]},&quot;v&quot;:&quot;html标签&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[88,89]},&quot;v&quot;:&quot;块级元素&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:5,&quot;p&quot;:{&quot;lines&quot;:[90,91]},&quot;v&quot;:&quot;标题：h1~h6&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:5,&quot;p&quot;:{&quot;lines&quot;:[92,93]},&quot;v&quot;:&quot;段落p&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:5,&quot;p&quot;:{&quot;lines&quot;:[94,95]},&quot;v&quot;:&quot;div&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:5,&quot;p&quot;:{&quot;lines&quot;:[96,97]},&quot;v&quot;:&quot;列表标签ul~li，ol~li&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:5,&quot;p&quot;:{&quot;lines&quot;:[98,99]},&quot;v&quot;:&quot;定义列表dl dt dd&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:5,&quot;p&quot;:{&quot;lines&quot;:[100,101]},&quot;v&quot;:&quot;表单form&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:7,&quot;p&quot;:{&quot;lines&quot;:[102,103]},&quot;v&quot;:&quot;action属性：规定向何处发送数据&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:7,&quot;p&quot;:{&quot;lines&quot;:[104,105]},&quot;v&quot;:&quot;methods属性：规定发送数据的HTTP方法&quot;}]}]},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[106,107]},&quot;v&quot;:&quot;行内块元素&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:5,&quot;p&quot;:{&quot;lines&quot;:[108,109]},&quot;v&quot;:&quot;img&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:7,&quot;p&quot;:{&quot;lines&quot;:[110,111]},&quot;v&quot;:&quot;gif：动画、布尔透明、无兼容问题&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:7,&quot;p&quot;:{&quot;lines&quot;:[112,113]},&quot;v&quot;:&quot;jpg：失真压缩法，色彩丰富&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:7,&quot;p&quot;:{&quot;lines&quot;:[114,115]},&quot;v&quot;:&quot;png：支持透明，高保真&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:7,&quot;p&quot;:{&quot;lines&quot;:[116,117]},&quot;v&quot;:&quot;webp：文件小，动画，透明，兼容性相对不好&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:7,&quot;p&quot;:{&quot;lines&quot;:[118,119]},&quot;v&quot;:&quot;svg：矢量图，体积小，动画&quot;}]},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:5,&quot;p&quot;:{&quot;lines&quot;:[120,121]},&quot;v&quot;:&quot;audio&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:5,&quot;p&quot;:{&quot;lines&quot;:[122,123]},&quot;v&quot;:&quot;vedio&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:5,&quot;p&quot;:{&quot;lines&quot;:[124,125]},&quot;v&quot;:&quot;input(不同的type属性有不同作用)&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:7,&quot;p&quot;:{&quot;lines&quot;:[126,127]},&quot;v&quot;:&quot;text：单行文本&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:7,&quot;p&quot;:{&quot;lines&quot;:[128,129]},&quot;v&quot;:&quot;radio：单选框&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:7,&quot;p&quot;:{&quot;lines&quot;:[130,131]},&quot;v&quot;:&quot;checkbox：多选框&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:7,&quot;p&quot;:{&quot;lines&quot;:[132,133]},&quot;v&quot;:&quot;button：按钮&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:7,&quot;p&quot;:{&quot;lines&quot;:[134,135]},&quot;v&quot;:&quot;submit：提交&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:7,&quot;p&quot;:{&quot;lines&quot;:[136,137]},&quot;v&quot;:&quot;password：密码&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:7,&quot;p&quot;:{&quot;lines&quot;:[138,139]},&quot;v&quot;:&quot;reset：重置&quot;}]},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:5,&quot;p&quot;:{&quot;lines&quot;:[140,141]},&quot;v&quot;:&quot;select&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:5,&quot;p&quot;:{&quot;lines&quot;:[142,143]},&quot;v&quot;:&quot;option&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:5,&quot;p&quot;:{&quot;lines&quot;:[144,145]},&quot;v&quot;:&quot;textarea&quot;}]},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[146,147]},&quot;v&quot;:&quot;行内元素&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:5,&quot;p&quot;:{&quot;lines&quot;:[148,149]},&quot;v&quot;:&quot;a标签&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:5,&quot;p&quot;:{&quot;lines&quot;:[150,151]},&quot;v&quot;:&quot;span&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:5,&quot;p&quot;:{&quot;lines&quot;:[152,153]},&quot;v&quot;:&quot;label&quot;}]},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[154,155]},&quot;v&quot;:&quot;空白折叠现象&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:5,&quot;p&quot;:{&quot;lines&quot;:[156,157]},&quot;v&quot;:&quot;多个换行或多个空格会被解析成一个空格&quot;}]},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[158,159]},&quot;v&quot;:&quot;转义符&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:5,&quot;p&quot;:{&quot;lines&quot;:[160,161]},&quot;v&quot;:&quot;空格：&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:5,&quot;p&quot;:{&quot;lines&quot;:[162,163]},&quot;v&quot;:&quot;&amp;amp;：&amp;amp;&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:5,&quot;p&quot;:{&quot;lines&quot;:[164,165]},&quot;v&quot;:&quot;版权符：©&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:5,&quot;p&quot;:{&quot;lines&quot;:[166,167]},&quot;v&quot;:&quot;商标：®&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:5,&quot;p&quot;:{&quot;lines&quot;:[168,169]},&quot;v&quot;:&quot;&amp;lt;：&amp;lt;&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:5,&quot;p&quot;:{&quot;lines&quot;:[170,171]},&quot;v&quot;:&quot;&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;paragraph&quot;,&quot;d&quot;:7,&quot;p&quot;:{&quot;lines&quot;:[170,171]},&quot;v&quot;:&quot;：&amp;gt;&quot;}]}]}]}]}"></svg></div><h2 id="一、基础知识"><a href="#一、基础知识" class="headerlink" title="一、基础知识"></a>一、基础知识</h2><h3 id="1、HTML是什么"><a href="#1、HTML是什么" class="headerlink" title="1、HTML是什么"></a>1、HTML是什么</h3><ul><li>HTML是用来描述网页的语言，又称“超文本标记语言”<blockquote><p>超文本有两层含义</p><ul><li>超出了文本的限制：他可以加入图片、视频、音频、链接等</li><li>超级链接文本：可以从一个文件跳转到另一个文件，与世界各地主机的文件相连</li></ul></blockquote></li></ul><h3 id="2、HTML骨架"><a href="#2、HTML骨架" class="headerlink" title="2、HTML骨架"></a>2、HTML骨架</h3><h4 id="文档声明DTD："><a href="#文档声明DTD：" class="headerlink" title="文档声明DTD："></a>文档声明DTD：</h4><pre><code>&lt;!DOCTYPE html&gt;</code></pre><blockquote><p>它并不是HTML标签，文档声明以下的都是HTML标签<br>作用：告诉浏览器的解析器使用HTML5的标准模式<br>HTML 4.01有三种声明：严格版、过渡版、框架版</p></blockquote><h4 id="声明语言类型"><a href="#声明语言类型" class="headerlink" title="声明语言类型"></a>声明语言类型</h4><pre><code>&lt;html lang=&quot;en&quot;&gt;</code></pre><blockquote><p>en：英语，zh：中文；网站有多国语言时修改</p></blockquote><h4 id="head标签"><a href="#head标签" class="headerlink" title="head标签"></a>head标签</h4><pre><code>&lt;head&gt;    &lt;meta charset=&quot;UTF-8&quot;&gt;    &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt;    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width,initial-scale=1.0&quot;&gt;    &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;</code></pre><blockquote><p>head标签里面是对网页的配置</p></blockquote><h4 id="声明网页字符编码集"><a href="#声明网页字符编码集" class="headerlink" title="声明网页字符编码集"></a>声明网页字符编码集</h4><pre><code>&lt;meta charset=&quot;UTF-8&quot;&gt;</code></pre><blockquote><p>meta是元标签，charset是字符集<br>在中国字符集有两种类型：”UTF-8”和”gb2312”</p></blockquote><table><thead><tr><th>字符集</th><th>涵盖字符</th><th>1个汉字的字节数</th><th>适用场景</th></tr></thead><tbody><tr><td>UTF-8</td><td>涵盖全球所有国家、民族的文字和大量图形字符</td><td>3</td><td>非汉字文字的网页</td></tr><tr><td>gb2312(gbk)</td><td>收录所有汉字字符、英语，少量韩文、日文、少量图形字符</td><td>2</td><td>只有汉语和英语的网页</td></tr><tr><td>ASCII</td><td>只有英文</td><td></td><td></td></tr><tr><td>ISO-8859-1</td><td>西欧字符</td><td></td><td></td></tr><tr><td>Unicode</td><td>世界通用</td><td></td><td>它只是符号集，并不是编码方式；具体编码方式包括UTF-8、UTF-16、UTF-32</td></tr></tbody></table><blockquote><p>由上表可以看出，gbk更加节省字节，有利于SEO优化<br>注意：VScode的设置要与此处一致，否则会乱码。且live serve插件不支持gbk</p></blockquote><h4 id="IE8及以上版本都使用当前版本所对应的最高级标准模式去渲染"><a href="#IE8及以上版本都使用当前版本所对应的最高级标准模式去渲染" class="headerlink" title="IE8及以上版本都使用当前版本所对应的最高级标准模式去渲染"></a>IE8及以上版本都使用当前版本所对应的最高级标准模式去渲染</h4><pre><code>&lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt;</code></pre><blockquote><p><code>X-UA-Compatible</code> 是IE8的专有meta属性，他告诉IE8采用何种IE版本去渲染网页<br>最佳兼容模式方案：</p></blockquote><pre><code>&lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge,chrome=1&quot;/&gt;</code></pre><blockquote><p><code>chrome=1</code>表示将允许站点在使用了谷歌浏览器内嵌框架的客户端渲染</p></blockquote><h4 id="移动端适配"><a href="#移动端适配" class="headerlink" title="移动端适配"></a>移动端适配</h4><ul><li>宽度为设备实际宽度，不需要缩放</li></ul><pre class=" language-html"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>meta</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>viewport<span class="token punctuation">"</span></span> <span class="token attr-name">content</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>width<span class="token punctuation">=</span>device-width,initial-scale<span class="token punctuation">=</span>1.0<span class="token punctuation">"</span></span><span class="token punctuation">></span></span></code></pre><ul><li>keywords</li></ul><pre class=" language-html"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>meta</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>keywords<span class="token punctuation">"</span></span> <span class="token attr-name">content</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>关键词内容<span class="token punctuation">"</span></span><span class="token punctuation">/></span></span></code></pre><ul><li>description</li></ul><pre><code>&lt;meta name=&quot;description&quot; content=&quot;描述的内容&quot;/&gt;</code></pre><h4 id="网页标题"><a href="#网页标题" class="headerlink" title="网页标题"></a>网页标题</h4><pre class=" language-html"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>title</span><span class="token punctuation">></span></span>Document<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>title</span><span class="token punctuation">></span></span></code></pre><h4 id="body标签"><a href="#body标签" class="headerlink" title="body标签"></a>body标签</h4><blockquote><p>里面包括网页的头部、主要内容、页脚各个部分</p></blockquote><h3 id="3、浏览器内核"><a href="#3、浏览器内核" class="headerlink" title="3、浏览器内核"></a>3、浏览器内核</h3><table><thead><tr><th>浏览器</th><th>内核</th></tr></thead><tbody><tr><td>IE、世界之窗浏览器</td><td>Trident</td></tr><tr><td>Edge</td><td>WebKit</td></tr><tr><td>chrome&#x2F;opera</td><td>Blink</td></tr><tr><td>Firefox（火狐）</td><td>Gecko</td></tr><tr><td>Safari（苹果）</td><td>webkit</td></tr><tr><td>360、猎豹、2345浏览器</td><td>trident+blink</td></tr><tr><td>UC、搜狗、遨游、QQ浏览器</td><td>trident+webkit</td></tr></tbody></table><h2 id="二、HTML标签及属性"><a href="#二、HTML标签及属性" class="headerlink" title="二、HTML标签及属性"></a>二、HTML标签及属性</h2><h3 id="1、标题标签"><a href="#1、标题标签" class="headerlink" title="1、标题标签"></a>1、标题标签</h3><p>h1~h6</p><table><thead><tr><th>html写法</th><th>markdown写法</th></tr></thead><tbody><tr><td><h1>一级标题</h1></td><td># H1</td></tr><tr><td><h2>二级标题</h2></td><td>## H2</td></tr><tr><td><h3>三级标题</h3></td><td>### H3</td></tr><tr><td><h4>四级标题</h4></td><td>#### H4</td></tr><tr><td><h5>五级标题</h5></td><td>##### H5</td></tr><tr><td><h6>六级标题</h6></td><td>###### H6</td></tr></tbody></table><h3 id="2、段落标签"><a href="#2、段落标签" class="headerlink" title="2、段落标签"></a>2、段落标签</h3><pre><code>&lt;p&gt;段落&lt;/p&gt;</code></pre><h3 id="3、HTML5特性"><a href="#3、HTML5特性" class="headerlink" title="3、HTML5特性"></a>3、HTML5特性</h3><h4 id="空白折叠现象：多个换行和多个空格都会被折叠成一个空格"><a href="#空白折叠现象：多个换行和多个空格都会被折叠成一个空格" class="headerlink" title="空白折叠现象：多个换行和多个空格都会被折叠成一个空格"></a>空白折叠现象：多个换行和多个空格都会被折叠成一个空格</h4><pre class=" language-html"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>h3</span><span class="token punctuation">></span></span>空白折叠现象<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>h3</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>h3</span><span class="token punctuation">></span></span>文字之间   的  多个空格会被折叠成一个空格<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>h3</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>h3</span><span class="token punctuation">></span></span>多个空行会被省略<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>h3</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>p</span><span class="token punctuation">></span></span>    标签内壁和文字之间的空格会被忽略<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>p</span><span class="token punctuation">></span></span></code></pre><p>效果展示：</p><h3>空白折叠现象</h3><h3>文字之间   的  多个空格会被折叠成一个空格</h3><h3>多个空行会被省略</h3><p>    标签内壁和文字之间的空格会被忽略</p><h4 id="常用转义符"><a href="#常用转义符" class="headerlink" title="常用转义符"></a>常用转义符</h4><pre class=" language-html"><code class="language-html">空格：<span class="token entity" title="&nbsp;">&amp;nbsp;</span>小于号：<span class="token entity" title="&lt;">&amp;lt;</span>大于号：<span class="token entity" title="&gt;">&amp;gt;</span>&amp;符号：<span class="token entity" title="&amp;">&amp;amp;</span>单引号：<span class="token entity" title="&quot;">&amp;quot;</span>版权符：<span class="token entity" title="&copy;">&amp;copy;</span>已注册商标：<span class="token entity" title="&reg;">&amp;reg;</span></code></pre><p>效果展示：<br>空格：&nbsp;<br>小于号：&lt;<br>大于号：&gt;<br>&amp;符号：&amp;<br>单引号：&quot;<br>版权符：&copy;<br>已注册商标：&reg;</p><blockquote><p>注：千万不要忘了分号;</p></blockquote><h3 id="4、列表标签"><a href="#4、列表标签" class="headerlink" title="4、列表标签"></a>4、列表标签</h3><h4 id="无序列表：ul-li"><a href="#无序列表：ul-li" class="headerlink" title="无序列表：ul li"></a>无序列表：ul li</h4><ul>    <li>ul、li是一对父子标签，必须同时存在</li>    <li>ul中只能嵌套li，但是li可以嵌套任何标签</li>    <li>type属性：</li>        <ul>            <li>旧版本使用type="square/circle/disc"</li>            <li>在html5中用CSS定义其type属性 style="list-style-type:cicle/square/disc"</li>        </ul>    </li></ul><ul type="disc">    <li>默认样式：实心圆disc</li></ul><ul style="list-style-type:circle">    <li>空心圆：circle</li></ul><ul style="list-style-type:square">    <li>实心正方形：square</li></ul><blockquote><p>markdown语法：</p><ul><li>实心圆：减号-+空格</li><li>空心圆：tab+减号-+一个空格</li></ul></blockquote><h4 id="有序列表-ol-li"><a href="#有序列表-ol-li" class="headerlink" title="有序列表 ol li"></a>有序列表 ol li</h4><ol>    <li>ol li也是父子标签，ol只能嵌套li，但li可以嵌套任何标签</li>    <li>有顺序的列表</li>    <li>type属性：type="1/A/a/I/i"</li>        <ol type="1">            <li>Java</li>            <li>C++</li>            <li>python</li>        </ol>    <li>start属性：指定起始值</li>        <ol type="I" start="3">            <li>Java</li>            <li>C++</li>            <li>python</li>        </ol>    <li>reversed属性：倒序，直接填写该单词</li>        <ol type="A" start="3" reversed >            <li>Java</li>            <li>C++</li>            <li>python</li>        </ol></ol><blockquote><p>markdown中直接输入数字+.+一个空格<br>根据上下顺序编号，而不是输入的数字</p></blockquote><pre><code>1. first5. second3. third </code></pre><p>效果：</p><ol><li>first</li><li>second</li><li>third</li></ol><h4 id="定义列表-dl-dt-dd"><a href="#定义列表-dl-dt-dd" class="headerlink" title="定义列表 dl dt dd"></a>定义列表 dl dt dd</h4><dl>    <dt>定义项1</dt>    <dd>解释说明1</dd>    <dd>解释说明2</dd>    <dt>定义项2</dt>    <dd>解释说明1</dd></dl><dl>    <dt>定义项3</dt>    <dd>解释说明1</dd></dt><blockquote><ul><li>dt dl可交替出现，也可以不交替出现(此时放在不同的dl中)</li><li>应用场景可参考小米官网底部</li><li>markdown语法：第一行术语，第二行冒号+一个空格+定义<br>定义项<br>: 解释说明</li></ul></blockquote><h3 id="5、多媒体标签"><a href="#5、多媒体标签" class="headerlink" title="5、多媒体标签"></a>5、多媒体标签</h3><h4 id="图片标签img"><a href="#图片标签img" class="headerlink" title="图片标签img"></a>图片标签img</h4><ul><li>正确写法：</li></ul><pre><code>&lt;img src=&quot; &quot; alt=&quot; &quot; width=&quot; &quot; height=&quot; &quot;/&gt;</code></pre><img src="3.avif"/><blockquote><p>pc端以上四要素必须填写<br>移动端必须填写alt属性，且需要表现出图片的含义</p></blockquote><ul><li>alt属性：图片的文本描述</li><li>width、height属性：图片宽度高度</li><li>src图片路径：<ul><li>相对路径：从当前网页出发，找到图片的路径。.&#x2F;是当前目录；..&#x2F;是返回上一级目录。</li><li>绝对路径：图片的精确地址</li></ul></li></ul><blockquote><p>markdown语法：<code>![alt](图片路径)</code></p></blockquote><h4 id="超级链接a标签"><a href="#超级链接a标签" class="headerlink" title="超级链接a标签"></a>超级链接a标签</h4><ul><li>正确写法：</li></ul><pre><code>&lt;a herf=&quot;链接&quot; title=&quot;悬停文本&quot; target=&quot;网页跳转方式&quot;&gt;网页显示&lt;/a&gt;</code></pre><p><a href="https://www.baidu.com" title="百度知道" target="_self">百度一下</a></p><blockquote><p>a标签是网页之间跳转的方式<br>href属性：支持相对属性和绝对属性<br>title属性：悬停文本<br>target属性：网页跳转的方式</p><ul><li>_blank&#x2F;blank:在新窗口打开网页</li></ul></blockquote><ul><li><p>_self:默认，当前页面跳转</p></li><li><p>_parent:在父窗口中打开</p></li><li><p>_top:在当前窗体打开链接，并替换当前的整个窗体</p><blockquote><ul><li>下面三个标签在网页上看效果一样，但在框架页中效果不同</li></ul></blockquote></li><li><p>点击图片跳转网页：</p><a href="https://www.baidu.com" title="手机"><img src="1.jpg"></a></li><li><p>页面锚点</p></li></ul><blockquote><p>给B处设置id，A处a标签链接为该id，点击A处则会跳转至B处</p></blockquote><pre><code>&lt;a href=&quot;#id名&quot;&gt;名称&lt;/a&gt;&lt;p id=&quot; &quot;&gt;名称&lt;/p&gt;</code></pre><p>效果：<br><a href="#yyhbq">语义化标签</a></p><blockquote><p>markdown语法：<br><a href="#A%E5%A4%84%E5%90%8D%E7%A7%B0-id%E5%90%8D-id">A处</a><br>B处 {id名-id}</p></blockquote><p><a href="#7%E3%80%81%E8%A1%A8%E6%A0%BC%E6%A0%87%E7%AD%BE-bg-id">表格标签</a></p><ul><li>下载链接<blockquote><p>支持exe、zip、rar、word、excel等格式的文件<br>链接为文件地址</p></blockquote></li></ul><p><a href="D:\arry\30天计划\配件\前端学习资料-超链接.docx">前端学习资料</a></p><ul><li><p>邮件链接</p><blockquote><p>链接为mailto:邮箱地址<br><a href="1234@qq.com">给我发邮件</a></p></blockquote></li><li><p>电话链接</p><blockquote><p>链接为tel:电话号码<br><a href="1234">给我打电话</a></p></blockquote></li></ul><h4 id="音频标签audio"><a href="#音频标签audio" class="headerlink" title="音频标签audio"></a>音频标签audio</h4><ul><li>正确写法1：</li></ul><pre><code>&lt;audio controls src=&quot;路径&quot; autoplay loop&gt;提示语&lt;/audio&gt;</code></pre><p><audio controls src="D:\arry\30天计划\配件\音标篇004.mp3" autoplay loop>抱歉，您的浏览器不支持audio标签，请升级您的浏览器哦</audio></p><ul><li><p>controls：显示播放空间</p></li><li><p>src：文件路径</p></li><li><p>提示语：浏览器不兼容时的文字显示</p></li><li><p>autoplay：自动播放</p></li><li><p>loop：循环播放</p></li><li><p>正确写法2(加入source标签)：</p></li></ul><pre><code>&lt;audio controls&gt;    &lt;source src=&quot;音频.mp3&quot; type=&quot;audio/mpeg&quot; autoplay loop/&gt;    &lt;source src=&quot;音频.ogg&quot; type=&quot;audio/ogg&quot; autoplay loop/&gt;    &lt;source src=&quot;音频.wav&quot; type=&quot;audio/wav&quot; autoplay loop/&gt;抱歉，您的浏览器不支持audio标签，请升级您的浏览器哦&lt;/audio&gt;</code></pre><ul><li>source标签为媒体元素定义媒体资源</li></ul><blockquote><p>它给浏览器提供多种格式的文件，浏览器会选择其支持的格式进行播放；如果都支持则任选一个，默认是第一个。</p></blockquote><table><thead><tr><th>Format</th><th>MIME-type</th><th>说明</th></tr></thead><tbody><tr><td>MP3</td><td>audio&#x2F;mpeg</td><td>一种音频压缩技术，用来大幅度的降低音频数</td></tr><tr><td>Ogg</td><td>audio&#x2F;ogg</td><td>新的音频压缩技术，完全免费，无专利限制</td></tr><tr><td>Wav</td><td>audio&#x2F;wav</td><td>由微软公司开发，声音质量接近CD</td></tr><tr><td><audio controls></td><td></td><td></td></tr></tbody></table><pre><code>&lt;source src=&quot;D:\arry\30天计划\配件\音标篇004.mp3&quot; type=&quot;audio/mpeg&quot; autoplay loop&gt;</code></pre><p>抱歉，您的浏览器不支持audio标签，请升级您的浏览器哦<br></audio></p><h4 id="视频标签video"><a href="#视频标签video" class="headerlink" title="视频标签video"></a>视频标签video</h4><ul><li>正确写法1：</li></ul><pre><code>&lt;video controls src=&quot;D:\arry\30天计划\配件\mi.mp4&quot; autoplay loop&gt;抱歉，您的浏览器不支持audio标签，请升级您的浏览器哦&lt;/video&gt;</code></pre><p><video controls src="D:\arry\30天计划\配件\mi.mp4" autoplay loop>抱歉，您的浏览器不支持audio标签，请升级您的浏览器哦</video></p><ul><li>正确写法2(加入source标签)：</li></ul><pre><code>&lt;video controls&gt;    &lt;source src=&quot;文件.mp4&quot; type=&quot;video.mp4&quot;/&gt;    &lt;source src=&quot;文件.webm&quot; type=&quot;video.webm&quot;/&gt;    &lt;source src=&quot;文件.ogv&quot; type=&quot;video.ogv&quot;/&gt;    &lt;source src=&quot;文件.avi&quot; type=&quot;video.avi&quot;/&gt;&lt;/video&gt;</code></pre><table><thead><tr><th>Format</th><th>MIME-type</th><th>说明</th></tr></thead><tbody><tr><td>mp4</td><td>video&#x2F;mp4</td><td>mp4即mpeg4,使用H264视频解编码器和AAC音频解编码器</td></tr><tr><td>webm</td><td>video&#x2F;webm</td><td>使用VP8视频解编码器和Vorbis音频解编码器</td></tr><tr><td>ogv</td><td>video&#x2F;ogv</td><td>支持256色和RLE压缩，它对视频文件采用了一种有损压缩方式</td></tr><tr><td>avi</td><td>video&#x2F;avi</td><td>使用Theora视频解编码器和Vorbis音频解编码器</td></tr></tbody></table><blockquote><p>视频和音频一样使用autoplay、loop标签<br>markdown语法：<a href="%E8%B7%AF%E5%BE%84/%E7%BD%91%E5%9D%80/%E9%93%BE%E6%8E%A5">title</a></p><blockquote><p>效果：<a href="https://www.baidu.com/">title</a></p></blockquote></blockquote><h3 id="6、表单元素-form"><a href="#6、表单元素-form" class="headerlink" title="6、表单元素 form"></a>6、表单元素 form</h3><ul><li>作用：收集不同类型的用户输入</li><li>属性<ul><li>action:提交表单时，向何处发送表单数据</li><li>method:规定发送表单数据的HTTP方法</li></ul></li><li>元素</li></ul><table><thead><tr><th>作用</th><th>标签</th><th>属性</th><th>说明</th></tr></thead><tbody><tr><td>单行文本框</td><td>input</td><td>type&#x3D;”text”</td><td>单标签</td></tr><tr><td></td><td>input</td><td>value&#x3D;””</td><td>文本框的值</td></tr><tr><td></td><td>input</td><td>placeholder&#x3D;””</td><td>提示文本</td></tr><tr><td></td><td>input</td><td>disabled</td><td>表示禁用</td></tr><tr><td>多行文本框</td><td>textarea</td><td>cols</td><td>定义行数</td></tr><tr><td></td><td>textarea</td><td>rows</td><td>定义列数</td></tr><tr><td>密码框</td><td>input</td><td>type&#x3D;”password”</td><td>会隐藏内容</td></tr><tr><td>lable标签</td><td>lable</td><td></td><td>用lable标签包裹单选按钮和文字，则文字与按钮绑定</td></tr><tr><td>按钮</td><td>input</td><td>type&#x3D;”button”</td><td>普通按钮</td></tr><tr><td></td><td>input</td><td>type&#x3D;”submit”</td><td>提交按钮</td></tr><tr><td></td><td>input</td><td>type&#x3D;”reset”</td><td>重置按钮</td></tr><tr><td>单选按钮</td><td>input</td><td>type&#x3D;”radio”</td><td></td></tr><tr><td></td><td>input</td><td>name&#x3D;”自定义名称”</td><td>name名称相同时互斥</td></tr><tr><td></td><td>input</td><td>value&#x3D;””</td><td>向服务器提交的值</td></tr><tr><td></td><td>input</td><td>checked</td><td>默认选中</td></tr><tr><td>复选框(多选)</td><td>input</td><td>type&#x3D;”checkbox”</td><td></td></tr><tr><td></td><td>input</td><td>name&#x3D;””</td><td>同组复选框name值相同</td></tr><tr><td></td><td>input</td><td>value\checked</td><td>与单选按钮相同</td></tr><tr><td>下拉菜单</td><td>select</td><td></td><td>包裹option</td></tr><tr><td></td><td>select</td><td>option</td><td>内部选项</td></tr></tbody></table><ul><li>以下是html5新增控件，兼容到IE9，手机端完全兼容<table><thead><tr><th>作用</th><th>标签</th><th>属性</th></tr></thead><tbody><tr><td>颜色选择</td><td>input</td><td>color</td></tr><tr><td>日期时间选择</td><td>input</td><td>date\time\datetime</td></tr><tr><td>电子邮件</td><td>input</td><td>email</td></tr><tr><td>文件选择</td><td>input</td><td>file</td></tr><tr><td>数字输入</td><td>input</td><td>number，可设置min、max</td></tr><tr><td>拖拽条</td><td>input</td><td>range，可设置min、max</td></tr><tr><td>搜索框</td><td>input</td><td>search</td></tr><tr><td>网址输入</td><td>input</td><td>url</td></tr><tr><td>备选框</td><td>input</td><td>datalist</td></tr></tbody></table></li><li>效果：<form>  <p>用户名：<input type="text" placeholder="真实姓名"/>  </p>  <p>年龄：<input type="text" value="22" disabled>  </p>  <p>  常住地址:  <textarea cols="100" rows="2"></textarea>  </p>  <p>请输入密码：<input type="password"/>  </p>  <p>性别：  <lable><input type="radio" name="sex"/>男</lable>  <lable><input type="radio" name="sex"/>女</lable>  <lable><input type="radio" name="sex"/>保密</lable>  </p>  <p>  爱好：  <lable><input type="checkbox" name="爱好">篮球</lable>  <lable><input type="checkbox" name="爱好">书画</lable>  <lable><input type="checkbox" name="爱好">游戏</lable>  </p>  <p>  省份：  <select>  <option value="湖南省">湖南省</option>  <option value="湖北省">湖北省</option>  <option value="海南省">海南省</option>  </select>  市区：  <select>  <option value="长沙市">长沙市</option>  <option value="湘潭市">湘潭市</option>  <option value="深圳市">深圳市</option>  </select>  </p>  <p>  <input type="button" value="这是一个普通按钮"><br>  <input type="submit">这个会跳转<br>  <input type="reset">  </p>  <p>颜色选择：<input type="color"></p>  <p>日期：<input type="date"></p>  <p>编程语言有：  <input type="text" list="language">  <datalist id="language">      <option value="JAVA">JAVA</option>      <option value="python">python</option>      <option value="c++">c++</option>  </p></form></li></ul><h3 id="7、表格标签-bg-id"><a href="#7、表格标签-bg-id" class="headerlink" title="7、表格标签 {bg-id}"></a>7、表格标签 {bg-id}</h3><ul><li>标签属性：<ul><li>border：表格的边框<blockquote><p>HTML的大部分table标签属性已被CSS替代</p></blockquote></li></ul></li><li>表格头部<ul><li>table定义表格</li><li>thead页眉</li><li>caption表格标题</li><li>tr表格的行</li><li>th定义表头</li></ul></li></ul><pre><code>&lt;table border=&quot;1&quot;&gt;    &lt;thead&gt;    &lt;caption&gt;版本规划任务分配表&lt;/caption&gt;    &lt;tr&gt;        &lt;th&gt;需求：V0.3版本规划&lt;/th&gt;        &lt;th&gt;优先级&lt;/th&gt;        &lt;th&gt;任务分解&lt;/th&gt;        &lt;th&gt;产品负责人&lt;/th&gt;    &lt;/tr&gt;    &lt;/thead&gt;&lt;/table&gt;</code></pre><p>-主体</p><ul><li>tbody表格的主体</li><li>tr表格的行</li><li>td表格的单元</li></ul><pre><code>&lt;tbody&gt;    &lt;tr&gt;    &lt;td&gt;功能模块&lt;/td&gt;    &lt;td&gt;具体事项&lt;/td&gt;    &lt;td&gt;3&lt;/td&gt;    &lt;td&gt;任务2&lt;/td&gt;    &lt;td&gt;熊二&lt;/td&gt;    &lt;/tr&gt;&lt;/tbody&gt;</code></pre><ul><li>尾部</li></ul><pre><code>&lt;tfoot&gt;</code></pre><ul><li>跨行跨列(合并单元格)-td或th标签的属性</li><li>colspan：跨列</li><li>rowspan：跨行</li><li>实战<table border="1">   <thead>  <caption>版本规划任务分配表</caption> <tr>  <th colspan="2">需求：V0.3版本规划</th>  <th>优先级</th>  <th>任务分解</th>  <th>产品负责人</th> </tr>  </thead>  <tbody> <tr>  <td rowspan="3">功能模块1</td>  <td>具体事项1</td>  <td>3</td>  <td>任务1</td>  <td rowspan="3">@熊二</td> </tr> <tr>  <td rowspan="2">具体事项2</td>  <td>4</td>  <td>任务2</td> </tr> <tr>  <td>1</td>  <td>任务3</td> </tr> <tfoot> <tr>  <td colspan="5">备注</td> </tr> <tr>  <td colspan="5">……</td> </tr> </tfoot>  </tbody></table></li></ul><blockquote><p>markdown语法：</p><ul><li>表头：管道符(|)+三个以上减号-</li><li>表格：管道符(|)<br>管道符不需要对齐<br>对齐方式：在减号旁添加冒号；居左：—，居中：—：，居右—：<br>可以在表格中添加：’’的代码(不能是代码块)、强调、链接<br>我的疑问：markdown怎么跨单元格</li></ul></blockquote><h3 id="8、语义化标签"><a href="#8、语义化标签" class="headerlink" title="8、语义化标签"></a>8、语义化标签</h3><h4 id="yyhbq">语义化标签</h4><ul><li><p>文本格式化标签</p><table><thead><tr><th>标签</th><th>说明</th><th>markdown写法</th></tr></thead><tbody><tr><td>b</td><td>粗体(已被CSS替代)</td><td><strong>粗体</strong></td></tr><tr><td>i</td><td>斜体(已被CSS替代)</td><td><em>斜体</em></td></tr><tr><td>u</td><td>下划线(已被CSS替代)</td><td><del>删除线</del></td></tr><tr><td>em</td><td>着重强调</td><td></td></tr><tr><td>strong</td><td>特别重要的文字</td><td></td></tr><tr><td>mark</td><td>高亮文本</td><td>&#x3D;&#x3D;高亮&#x3D;&#x3D;</td></tr><tr><td>sub</td><td>下标</td><td>H<del>2</del>O</td></tr><tr><td>sup</td><td>上标</td><td>X^2^</td></tr><tr><td>del</td><td>删除线</td><td></td></tr><tr><td>pre</td><td>预格式文本</td><td></td></tr><tr><td>figure</td><td>用以规定独立的流内容</td><td></td></tr><tr><td>figcaption</td><td>figure的标题</td><td></td></tr></tbody></table></li><li><p><code>pre</code>被包围在<code>&lt;pre&gt;</code>标签，元素中的文本通常会保留空格和换行符。<br>而文本也会呈现为等宽字体。</p></li></ul><pre><code>&lt;pre&gt;被包围在 pre 标签  元素中的文本通常会保留空格和换行符。而文本也会呈现为等宽字体。 &lt;/pre&gt;&lt;figure&gt;    &lt;figcaption&gt;小米家电&lt;/figcaption&gt;    &lt;img src=&quot;家电.webp&quot; &quot;width=20&quot;&gt;&lt;/figure&gt;&lt;figure&gt;    &lt;img src=&quot;&quot;&gt;    &lt;figcaption&gt;小米家电&lt;/figcaption&gt;&lt;/figure&gt;</code></pre><ul><li>HTML5区块标签<table><thead><tr><th>标签</th><th>说明</th></tr></thead><tbody><tr><td>span</td><td>文本中的区块标签</td></tr><tr><td>header</td><td>页头</td></tr><tr><td>nav</td><td>导航条</td></tr><tr><td>main</td><td>网页核心部分</td></tr><tr><td>article</td><td>文档的核心内容</td></tr><tr><td>section</td><td>文档的区域</td></tr><tr><td>aside</td><td>非必要内容：广告等</td></tr><tr><td>footer</td><td>页脚</td></tr></tbody></table></li></ul><pre><code>&lt;p&gt;商品价格：&lt;span&gt;苹果&lt;/span&gt;5元&lt;/p&gt;</code></pre><ul><li>网页的排版：</li></ul><pre class=" language-html"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>header</span><span class="token punctuation">></span></span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span><span class="token punctuation">></span></span>   <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>h1</span><span class="token punctuation">></span></span>网站logo<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>h1</span><span class="token punctuation">></span></span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>nav</span><span class="token punctuation">></span></span>网页的导航<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>nav</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>header</span><span class="token punctuation">></span></span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>main</span><span class="token punctuation">></span></span>   <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>aside</span><span class="token punctuation">></span></span>广告栏<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>aside</span><span class="token punctuation">></span></span>   <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>article</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>h3</span><span class="token punctuation">></span></span>商品标题<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>h3</span><span class="token punctuation">></span></span>     <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>section</span><span class="token punctuation">></span></span>商品信息1<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>section</span><span class="token punctuation">></span></span>   <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>article</span><span class="token punctuation">></span></span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>main</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>footer</span><span class="token punctuation">></span></span>页脚<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>footer</span><span class="token punctuation">></span></span></code></pre><h3 id="markdown语法"><a href="#markdown语法" class="headerlink" title="markdown语法"></a>markdown语法</h3><h4 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h4><table><thead><tr><th>写法</th><th>作用</th><th>说明</th></tr></thead><tbody><tr><td>‘’</td><td>原代码显示</td><td>单个代码、短语用</td></tr><tr><td>&#96;&#96;&#96;html</td><td>代码块</td><td>前后各三个，标注语言后会自动添加颜色</td></tr><tr><td>[数字&#x2F;单词]</td><td>脚注</td><td>添加注释和引用</td></tr><tr><td>-空格[空格]空格文字</td><td>待办事项</td><td>方框中加x是已完成，空格是未完成</td></tr><tr><td>表情符</td><td>表情</td><td>可以直接复制表情或者使用其简码</td></tr></tbody></table><blockquote><p>脚注的标识符可以标注数字或者英文单词<br>标注可以写在在除其他元素中的任何地方<br>英语[^1]  语文[^2]<br>[^1]:my footnote.<br>[^2]:hihihi</p></blockquote><pre><code>英语[^1]  [^1]:my footnote.</code></pre><blockquote><p>任务列表</p></blockquote><ul><li><input disabled="" type="checkbox"> 阅读</li><li><input checked="" disabled="" type="checkbox"> 运动</li></ul><pre><code>- [ ] 阅读- [x] 运动</code></pre><blockquote><p>表情</p><blockquote><p>😀</p></blockquote></blockquote><h4 id="扩展"><a href="#扩展" class="headerlink" title="扩展"></a>扩展</h4><ul><li><p>自动url链接<br>   百度：<a href="http://www.baidu.com/">http://www.baidu.com</a></p></li><li><p>禁用url链接<br>  加上符号：<code>http://www.baidu.com</code></p></li><li><p>徽章</p><ul><li>格式：<a href="%E8%B6%85%E9%93%BE%E6%8E%A5%E5%9C%B0%E5%9D%80"><img src="/%E5%9B%BE%E7%89%87%E6%BA%90%E5%9C%B0%E5%9D%80" alt="图片文字说明"></a></li><li>先获取在线徽章的地址，然后按照语言规则手动拼接</li><li><a href="https://github.com/snowdreams1006"><img src="https://img.shields.io/badge/github-snowdreams1006-brightgreen.svg" alt="github"></a></li></ul></li></ul><blockquote><p>徽章图形制作网站：<a href="https://shields.io/">https://shields.io/</a><br>相关知识点：<a href="https://segmentfault.com/search?q=%E5%BE%BD%E7%AB%A0">https://segmentfault.com/search?q=%E5%BE%BD%E7%AB%A0</a> </p></blockquote><h2 id="三、VScode基础配置"><a href="#三、VScode基础配置" class="headerlink" title="三、VScode基础配置"></a>三、VScode基础配置</h2><h3 id="1、下载：官网下载"><a href="#1、下载：官网下载" class="headerlink" title="1、下载：官网下载"></a>1、下载：官网下载</h3><h3 id="2、插件安装："><a href="#2、插件安装：" class="headerlink" title="2、插件安装："></a>2、插件安装：</h3><ul><li>简体中文语言包： chinese</li><li>图标：Material Icon Theme</li><li>通过编辑器打开默认浏览器：open in brower</li><li>开启本地服务，即时刷新：live server</li><li>自动修改标签对： auto rename tag</li><li>将代码生成一张图片：carbon-now-sh</li><li>格式化代码：prettier-code-formatter;打开设置中的save勾选保存时格式化文件</li></ul><h3 id="3、常用快捷键"><a href="#3、常用快捷键" class="headerlink" title="3、常用快捷键"></a>3、常用快捷键</h3><ul><li>单行注释：ctrl+&#x2F;</li><li>多行注释2：alt+shift+A</li><li>移动行：alt+up&#x2F;down</li><li>显示、隐藏目录栏：ctrl+b</li><li>控制台终端显示&#x2F;隐藏：ctrl+~</li><li>多行编辑：ctrl+alt+up&#x2F;down</li></ul>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> HTML </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>博客介绍及搭建过程分享</title>
      <link href="/2023/11/16/%E5%8D%9A%E5%AE%A2%E4%BB%8B%E7%BB%8D%E5%8F%8A%E6%90%AD%E5%BB%BA%E8%BF%87%E7%A8%8B%E5%88%86%E4%BA%AB/"/>
      <url>/2023/11/16/%E5%8D%9A%E5%AE%A2%E4%BB%8B%E7%BB%8D%E5%8F%8A%E6%90%AD%E5%BB%BA%E8%BF%87%E7%A8%8B%E5%88%86%E4%BA%AB/</url>
      
        <content type="html"><![CDATA[<span id="more"></span><h3 id="前情提要"><a href="#前情提要" class="headerlink" title="前情提要"></a>前情提要</h3><blockquote><p>写这篇文的目的</p></blockquote><ul><li>记录自己搭建过程，便于以后快速复用</li><li>总结经验和自己踩的坑，给其他小伙伴一些参考(由于是搭建后写的，所以没有参考图片)</li></ul><blockquote><p>介绍</p></blockquote><ul><li>初步效果参考我的博客：<a href="https://hermiablog.com/">hermia的个人博客</a></li><li>本博客基于Hexo框架，使用github托管</li><li>使用自定义域名：<code>hermiablog.com</code></li><li>hexo主题：<code>hexo-theme-matery</code></li></ul><blockquote><p>主题特性</p></blockquote><ul><li>简单漂亮，文章内容美观易读</li><li>Material Design 设计</li><li>响应式设计，博客在桌面端、平板、手机等设备上均能很好的展现</li><li>首页轮播文章及每天动态切换 Banner 图片(我选的图片都很美，期待你的每天访问哦)</li><li>瀑布流式的博客文章列表（文章无特色图片时会有漂亮的图片代替）</li><li>时间轴式的归档页</li><li>词云的标签页和雷达图的分类页</li><li>丰富的关于我页面（包括关于我、文章统计图、我的项目、我的技能、相册等）</li><li>可自定义的数据的友情链接页面</li><li>支持文章置顶和文章打赏</li><li>支持 MathJax</li><li>TOC 目录</li><li>可设置复制文章内容时追加版权信息</li><li>可设置阅读文章时做密码验证</li><li>Gitalk、Gitment、Valine 和 Disqus 评论模块（推荐使用 Gitalk）</li><li>集成了不蒜子统计、谷歌分析（Google Analytics）和文章字数统计等功能</li><li>支持在首页的音乐播放和视频播放功能<ul><li>博客正在建设中，更多功能敬请期待….</li></ul></li></ul><blockquote><p>跟着本篇文章，你会实现：</p></blockquote><ul><li>使用<code>github用户名.github.io</code>&#x2F;自定义域名访问博客</li><li>设置自己喜欢的主题</li></ul><blockquote><p>软件准备</p></blockquote><ul><li>git</li><li>Node.js</li><li>任一编辑器</li><li>注意：命令行操作使用git，文件内容编辑使用vscode</li></ul><blockquote><p>参考官方文档</p></blockquote><ul><li><a href="https://docs.github.com/zh/pages">Github Pages文档</a></li><li><a href="https://hexo.io/zh-cn/docs/">Hexo官方文档</a></li></ul><h3 id="低配版：github域名-默认hexo主题"><a href="#低配版：github域名-默认hexo主题" class="headerlink" title="低配版：github域名+默认hexo主题"></a>低配版：github域名+默认hexo主题</h3><blockquote><p>步骤</p></blockquote><ul><li>新建本地仓库</li><li>安装hexo</li><li>创建github仓库</li><li>链接远程仓库</li><li>部署</li></ul><h4 id="新建本地仓库"><a href="#新建本地仓库" class="headerlink" title="新建本地仓库"></a>新建本地仓库</h4><blockquote><p>我的电脑里同时使用了gitee和github仓库，且使用了不同的用户名及邮箱，因此</p><ul><li>不能使用全局的用户名、邮箱配置</li><li>所以在使用SSH链接远程仓库时要单独配置</li></ul></blockquote><ul><li>首先在本地新建空文件夹myblog</li><li>注意：<strong>不要</strong>使用<code>git init</code>来初始化仓库</li><li>因为hexo安装必须在空文件夹</li></ul><h4 id="安装Hexo"><a href="#安装Hexo" class="headerlink" title="安装Hexo"></a>安装Hexo</h4><ul><li>右击刚刚新建的文件夹myblog，点击Git Bash Here打开git窗口</li><li>输入<code>npm install -g hexo-cli</code>安装Hexo</li><li>验证是否安装成功<code>hexo -v</code></li><li>初始化Hexo：<code>hexo init</code></li><li>查看是否能在本地启动成功：<code>hexo s</code>；启动服务器，访问网址之后可以看到hexo的初始界面；停止服务器：<code>ctrl+c</code></li></ul><pre><code>npm install -g hexo-clihexo -vhexo inithexo s</code></pre><blockquote><p>Hexo相关目录文件</p></blockquote><ul><li>node_modules是node.js各种库的目录</li><li>public是生成的网页文件目录</li><li>scaffolds里面就三个文件，存储着新文章和新页面的初始设置</li><li>source是我们最常用到的一个目录，里面存放着文章、各类页面、图像等文件</li><li>themes存放着主题文件，一般也用不到。<ul><li>我们平时写文章只需要关注source&#x2F;_posts这个文件夹就行了</li></ul></li></ul><h4 id="创建github仓库"><a href="#创建github仓库" class="headerlink" title="创建github仓库"></a>创建github仓库</h4><blockquote><p>注意：仓库名必须是<code>用户名.github.io</code>，这有这样做，部署完之后才能使用<code>http://用户名.github.io</code>访问</p></blockquote><ul><li>打开<code>https://github.com/</code>，新建一个项目仓库</li><li>选择公开仓库和需要README文件</li><li>git仓库默认主分支名为main，建议修改为master，和本地仓库的主分支名相同</li></ul><h4 id="使用SSH密钥链接远程仓库"><a href="#使用SSH密钥链接远程仓库" class="headerlink" title="使用SSH密钥链接远程仓库"></a>使用SSH密钥链接远程仓库</h4><ul><li>回到本地仓库的git界面</li><li>绑定用户名和邮箱</li></ul><pre><code># 全局git config --global user.name &quot;yourname&quot;git config --global user.email &quot;youremail&quot;# 局部git config --global user.name &quot;yourname&quot;git config --global user.email &quot;youremail&quot;# 查看用用户名和邮箱信息是否配置成功git config  --list</code></pre><blockquote><ul><li>如果你和我一样有多个仓库，就去掉 –global</li><li>邮箱就是你github绑定的邮箱</li><li>检查是否配置成功</li></ul></blockquote><ul><li>创建SSH</li></ul><pre><code>ssh-keygen -t rsa -C 邮箱名</code></pre><blockquote><ul><li>后面是自己注册github的邮箱，然后敲三次回车</li></ul></blockquote><ul><li>接着就会发现<code>C:\Users\用户名</code>下多了一个.ssh目录，打开后有一个公钥，一个私钥。id_rsa.pub是公钥</li><li>我们需要打开它，复制里面的内容</li><li>打开github，在头像下面点击settings，再点击SSH and GPG keys，新建一个SSH，标题随意取，把刚刚复制id_rsa.pub里面的信息粘贴到钥匙框</li><li>在git bash输入<code>ssh -T git@github.com</code>；如果出现<code>...successfully...</code>就成功了</li></ul><h4 id="将hexo和GitHub关联"><a href="#将hexo和GitHub关联" class="headerlink" title="将hexo和GitHub关联"></a>将hexo和GitHub关联</h4><ul><li>打开本地仓库，博客文件夹，在根目录找到<code>_config.yml</code>文件，使用vscode或任一编辑器打开</li><li>修改配置：</li></ul><pre><code>deploy:  type: git  repository: github地址  branch: master</code></pre><blockquote><ul><li>获取repository：打开github仓库–&gt;Code–&gt;复制SSH地址填入即可</li><li>注意：hexo的所有文件，在修改时切记<strong>冒号后面有空格</strong>，否则报错</li></ul></blockquote><h4 id="部署"><a href="#部署" class="headerlink" title="部署"></a>部署</h4><ul><li>安装deploy-git</li></ul><pre><code>npm install hexo-deployer-git --save</code></pre><ul><li>依次执行以下命令</li></ul><pre><code># 清除缓存文件 (db.json) 和已生成的静态文件 (public)hexo c# 生成静态文件hexo g# 部署网站hexo d</code></pre><blockquote><ul><li>注意：虽然我们使用的是git，但是<code>hexo d</code>会自动把文件传到github上；不需要再使用<code>git push</code>了</li></ul></blockquote><ul><li>完成以上步骤，你就可以使用xxx.github.io来访问你的博客啦</li><li>以后写文章，只需要以下命令</li></ul><pre><code>hexo new post &quot;文章标题&quot;hexo chexo ghexo d</code></pre><h4 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h4><ul><li>新建文章 hexo new post 标题</li><li>部署</li></ul><pre><code>#清理之前的生成hexo c# 生成静态网站hexo g#开启本地服务 ctrl+c 停止hexo s#上传到githubhexo d</code></pre><h4 id="自定义域名"><a href="#自定义域名" class="headerlink" title="自定义域名"></a>自定义域名</h4><ul><li>首先，自定义域名需要花钱买，华为云&#x2F;腾讯云&#x2F;阿里云都可以</li><li>购买之后需要解析域名<blockquote><p>github绑定</p></blockquote></li><li>打开github仓库–&gt;点击setting–&gt;找到pages–&gt;拉到Custom domain处，填写你购买的域名，进行绑定</li><li>此时项目根目录会自动生成CNAME文件，如果没有的话自己创建一个，文档内容为你的域名<blockquote><p>DNS配置</p></blockquote></li><li>进入华为云控制台，打开云解析服务DNS</li><li>在域名解析集中添加一条<ul><li>记录类型为CNAME</li><li>记录值为博客的github仓库名，我的是hermiablog.github.io</li></ul></li><li>等待一段时间就可以使用域名访问了<img src="绑定自定义域名.png"></li></ul><h3 id="github的使用"><a href="#github的使用" class="headerlink" title="github的使用"></a>github的使用</h3><h4 id="git——仓库配置"><a href="#git——仓库配置" class="headerlink" title="git——仓库配置"></a>git——仓库配置</h4><blockquote><p>!!!首先 如果有仓库的用户名及邮箱不一样 就不要把它设置为全局</p></blockquote><ul><li>git安装后，点击文件夹–&gt;右击 git bash here打开</li><li>初始化本地仓库</li></ul><pre><code>git init</code></pre><ul><li>设置用户名和有效</li></ul><pre><code>git config  user.name &quot;你的名字（一定要是英文的）&quot;git config  user.email &quot;你的邮箱&quot;# 查看用用户名和邮箱信息是否配置成功git config --global --list# 删除全局设置git config --global --unset user.namegit config --global --unset user.email</code></pre><blockquote><p>添加SSH公钥</p></blockquote><ul><li>创建SSH密钥对</li></ul><pre><code>ssh-keygen -t rsa -C 邮箱名</code></pre><ul><li>如果不需要设置密码，可以直接按Enter键</li><li>之后就会在用户主目录下的<code>.ssh</code>文件夹中生成以下两个文件：</li></ul><pre><code>id_rsaid_rsa.pub</code></pre><ul><li>其中id_rsa为私钥，id_rsa.pub为公钥</li><li>将自定义路径的私钥添加到ssh秘钥搜索列表中</li></ul><pre><code>//连接认证agent（身份验证代理）ssh-agent bash//修改私钥路径ssh-add ~/.ssh/id_rsa_github</code></pre><ul><li>将公钥内容粘贴到自己github&#x2F;Gitee的设置中<ul><li>用记事本打开id._rsa.pub文件，复制内容</li><li>登录自己的github或gitee，在个人设置中找到“安全设置”–“ssh公钥”，标题自定，将公钥粘贴进去</li></ul></li><li>测试本机能否与github&#x2F;gitee使用ssh通信</li></ul><pre><code>ssh -T git@gitee.com//或ssh -T git@github.com</code></pre><ul><li><p>ssh返回 “……successfully ……”，这表示可以与远程愉快的通信了 </p></li><li><p>本地仓库与GitHub远程仓库进行关联</p></li></ul><pre><code>git remote add origin 远程仓库地址(HTTP/SSH)</code></pre><h4 id="将本地代码推送到github"><a href="#将本地代码推送到github" class="headerlink" title="将本地代码推送到github"></a>将本地代码推送到github</h4><ul><li>可以将已经做好的项目推送到远程</li><li>也可以解决git clone会嵌套一个文件夹的问题</li></ul><blockquote><p>本地</p></blockquote><ul><li>新建空文件夹</li><li>右击使用Git Bash打开文件夹，git init初始化仓库</li><li>配置用户名和邮箱</li></ul><pre><code>git config  user.name &quot;你的名字（一定要是英文的）&quot;git config  user.email &quot;你的邮箱&quot;</code></pre><ul><li>创建SSH密钥对</li></ul><pre><code>ssh-keygen -t rsa -C 邮箱名// 如果不需要设置密码，可以直接按Enter键</code></pre><ul><li>之后就会在用户主目录下的.ssh文件夹中生成以下两个文件：<br>id_rsa、id_rsa.pub；其中id_rsa为私钥，id_rsa.pub为公钥</li><li>打开id_rsa.pub，复制内容，将公钥内容粘贴到自己github&#x2F;Gitee的设置中</li><li>将自定义路径的私钥添加到ssh秘钥搜索列表中</li></ul><pre><code>//连接认证agent（身份验证代理）ssh-agent bash//修改私钥路径ssh-add ~/.ssh/id_rsa</code></pre><ul><li>测试本机能否与github&#x2F;gitee使用ssh通信</li></ul><pre><code>ssh -T git@github.com//ssh返回 “……successfully ……”，这表示可以与远程愉快的通信了</code></pre><ul><li>修改本地仓库主分支的命名</li></ul><pre><code>git branch -m master main</code></pre><ul><li>本地仓库与GitHub远程仓库进行关联</li></ul><pre><code>git remote add origin 远程仓库地址(HTTP/SSH)</code></pre><ul><li>将远程仓库拉取到本地(可以创建一个README文档，有内容可以看到变化)</li></ul><pre><code>git pull origin main</code></pre><ul><li>将项目文件复制到本地仓库(node_module除外)</li><li>将项目文件推送到远程</li></ul><pre><code>git add .git commit -m &quot;&quot;git push origin main</code></pre><h4 id="git基本操作"><a href="#git基本操作" class="headerlink" title="git基本操作"></a>git基本操作</h4><ul><li>将所有文件添加到暂存区中</li></ul><pre><code>git add .</code></pre><ul><li>检测当前git仓库的状态</li></ul><pre><code>git status</code></pre><ul><li>将暂存区中的更改保存到版本库中，并对本次的更改添加注释</li></ul><pre><code>git commit -m &quot;XXX&quot;</code></pre><ul><li>命令来检测当前git仓库的状态</li></ul><pre><code>git status</code></pre><ul><li>查看日志</li></ul><pre><code>git log</code></pre><ul><li>创建新分支</li></ul><pre><code>git branch 分支名</code></pre><ul><li>查看所有分支</li></ul><pre><code>git branch</code></pre><ul><li>切换分支</li></ul><pre><code>git checkout 分支名或git switch 分支名</code></pre><ul><li>push到远程仓库上</li></ul><pre><code>git push origin 分支名</code></pre><blockquote><p>将文件提交到分支上</p></blockquote><ul><li>切换到需要提交的分支上面</li></ul><pre><code>git checkout 分支名</code></pre><ul><li>提交到分支上面</li></ul><pre><code>git add 文件名/.git commit -m &quot;描述&quot;git push origin 分支名</code></pre><ul><li>切换到主分支</li></ul><pre><code>git checkout main</code></pre><ul><li>将本地分支和合并到本地主分支上</li></ul><pre><code>git merge 分支名</code></pre><ul><li>推动到远程仓库</li></ul><pre><code>git pull origin main</code></pre><blockquote><p>删除分支</p></blockquote><ul><li>查看所有的分支</li></ul><pre><code>git branch -a</code></pre><ul><li>删除远程分支</li></ul><pre><code>git push origin --delete 分支名</code></pre><ul><li>删除本地分支</li></ul><pre><code>git branch -D 分支名</code></pre>]]></content>
      
      
      <categories>
          
          <category> hexo </category>
          
      </categories>
      
      
        <tags>
            
            <tag> hexo blog </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
