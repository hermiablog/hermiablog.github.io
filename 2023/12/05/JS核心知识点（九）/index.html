<!DOCTYPE HTML>
<html lang="zh-CN">


<head>
    <meta charset="utf-8">
    <meta name="keywords" content="JS核心知识点（九）, 技术博客">
    <meta name="description" content="个人技术博客">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <meta name="renderer" content="webkit|ie-stand|ie-comp">
    <meta name="mobile-web-app-capable" content="yes">
    <meta name="format-detection" content="telephone=no">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <!-- Global site tag (gtag.js) - Google Analytics -->


    <title>JS核心知识点（九） | hermia&#39;s blog</title>
    <link rel="icon" type="image/png" href="/favicon.png">

    <link rel="stylesheet" type="text/css" href="/libs/awesome/css/all.css">
    <link rel="stylesheet" type="text/css" href="/libs/materialize/materialize.min.css">
    <link rel="stylesheet" type="text/css" href="/libs/aos/aos.css">
    <link rel="stylesheet" type="text/css" href="/libs/animate/animate.min.css">
    <link rel="stylesheet" type="text/css" href="/libs/lightGallery/css/lightgallery.min.css">
    <link rel="stylesheet" type="text/css" href="/css/matery.css">
    <link rel="stylesheet" type="text/css" href="/css/my.css">

    <script src="/libs/jquery/jquery.min.js"></script>

<meta name="generator" content="Hexo 6.3.0"><link rel="stylesheet" href="/css/prism-tomorrow.css" type="text/css"></head>



   <style>
    body{
       background-image: url(https://cdn.pixabay.com/photo/2012/04/14/16/37/sky-34536_1280.png);
       background-repeat:no-repeat;
       background-size:cover;
       background-attachment:fixed;
    }
</style>



<body>
    <header class="navbar-fixed">
    <nav id="headNav" class="bg-color nav-transparent">
        <div id="navContainer" class="nav-wrapper container">
            <div class="brand-logo">
                <a href="/" class="waves-effect waves-light">
                    
                    <img src="/medias/logo.png" class="logo-img" alt="LOGO">
                    
                    <span class="logo-span">hermia&#39;s blog</span>
                </a>
            </div>
            

<a href="#" data-target="mobile-nav" class="sidenav-trigger button-collapse"><i class="fas fa-bars"></i></a>
<ul class="right nav-menu">
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/" class="waves-effect waves-light">
      
      <i class="fas fa-home" style="zoom: 0.6;"></i>
      
      <span>首页</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/tags" class="waves-effect waves-light">
      
      <i class="fas fa-tags" style="zoom: 0.6;"></i>
      
      <span>标签</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/categories" class="waves-effect waves-light">
      
      <i class="fas fa-bookmark" style="zoom: 0.6;"></i>
      
      <span>分类</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/archives" class="waves-effect waves-light">
      
      <i class="fas fa-archive" style="zoom: 0.6;"></i>
      
      <span>归档</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/about" class="waves-effect waves-light">
      
      <i class="fas fa-user-circle" style="zoom: 0.6;"></i>
      
      <span>关于</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/friends" class="waves-effect waves-light">
      
      <i class="fas fa-address-book" style="zoom: 0.6;"></i>
      
      <span>友情链接</span>
    </a>
    
  </li>
  
  <li>
    <a href="#searchModal" class="modal-trigger waves-effect waves-light">
      <i id="searchIcon" class="fas fa-search" title="搜索" style="zoom: 0.85;"></i>
    </a>
  </li>
</ul>


<div id="mobile-nav" class="side-nav sidenav">

    <div class="mobile-head bg-color">
        
        <img src="/medias/logo.png" class="logo-img circle responsive-img">
        
        <div class="logo-name">hermia&#39;s blog</div>
        <div class="logo-desc">
            
            个人技术博客
            
        </div>
    </div>

    

    <ul class="menu-list mobile-menu-list">
        
        <li class="m-nav-item">
	  
		<a href="/" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-home"></i>
			
			首页
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/tags" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-tags"></i>
			
			标签
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/categories" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-bookmark"></i>
			
			分类
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/archives" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-archive"></i>
			
			归档
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/about" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-user-circle"></i>
			
			关于
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/friends" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-address-book"></i>
			
			友情链接
		</a>
          
        </li>
        
        
    </ul>
</div>


        </div>

        
    </nav>

</header>

    



<div class="bg-cover pd-header post-cover" style="background-image: url('/medias/featureimages/19.jpg')">
    <div class="container" style="right: 0px;left: 0px;">
        <div class="row">
            <div class="col s12 m12 l12">
                <div class="brand">
                    <h1 class="description center-align post-title">JS核心知识点（九）</h1>
                </div>
            </div>
        </div>
    </div>
</div>




<main class="post-container content">

    
    <link
  rel="stylesheet"
  href="/libs/tocbot/tocbot.css"
/>
<style>
  #articleContent h1::before,
  #articleContent h2::before,
  #articleContent h3::before,
  #articleContent h4::before,
  #articleContent h5::before,
  #articleContent h6::before {
    display: block;
    content: " ";
    height: 100px;
    margin-top: -100px;
    visibility: hidden;
  }

  #articleContent :focus {
    outline: none;
  }

  .toc-fixed {
    position: fixed;
    top: 64px;
  }

  /* .toc-widget {
        width: 345px;
        padding-left: 20px;
    } */
  .toc-widget {
    width: 345px;
    padding-left: 20px;
    background-color: rgb(255, 255, 255, 0.7);
    border-radius: 10px;
    box-shadow: 0 10px 35px 2px rgba(0, 0, 0, 0.15),
      0 5px 15px rgba(0, 0, 0, 0.07), 0 2px 5px -5px rgba(0, 0, 0, 0.1) !important;
  }

  .toc-widget .toc-title {
    padding: 35px 0 15px 17px;
    font-size: 1.5rem;
    font-weight: bold;
    line-height: 1.5rem;
  }

  .toc-widget ol {
    padding: 0;
    list-style: none;
  }

  #toc-content {
    padding-bottom: 30px;
    overflow: auto;
  }

  #toc-content ol {
    padding-left: 10px;
  }

  #toc-content ol li {
    padding-left: 10px;
  }

  #toc-content .toc-link:hover {
    color: #a3ddf0;
    font-weight: 700;
    text-decoration: underline;
  }

  #toc-content .toc-link::before {
    background-color: transparent;
    max-height: 25px;

    position: absolute;
    right: 23.5vw;
    display: block;
  }

  #toc-content .is-active-link {
    color: #a3ddf0;
  }

  #floating-toc-btn {
    position: fixed;
    right: 15px;
    bottom: 76px;
    padding-top: 15px;
    margin-bottom: 0;
    z-index: 998;
  }

  #floating-toc-btn .btn-floating {
    width: 48px;
    height: 48px;
  }

  #floating-toc-btn .btn-floating i {
    line-height: 48px;
    font-size: 1.4rem;
  }
</style>
<div class="row">
  <div id="main-content" class="col s12 m12 l9">
    <!-- 文章内容详情 -->
<div id="artDetail">
    <div class="card">
        <div class="card-content article-info">
            <div class="row tag-cate">
                <div class="col s7">
                    
                    <div class="article-tag">
                        
                            <a href="/tags/JS/">
                                <span class="chip bg-color">JS</span>
                            </a>
                        
                    </div>
                    
                </div>
                <div class="col s5 right-align">
                    
                    <div class="post-cate">
                        <i class="fas fa-bookmark fa-fw icon-category"></i>
                        
                            <a href="/categories/%E6%8A%80%E6%9C%AF/" class="post-category">
                                技术
                            </a>
                        
                    </div>
                    
                </div>
            </div>

            <div class="post-info">
                
                <div class="post-date info-break-policy">
                    <i class="far fa-calendar-minus fa-fw"></i>发布日期:&nbsp;&nbsp;
                    2023-12-05
                </div>
                

                
                <div class="post-date info-break-policy">
                    <i class="far fa-calendar-check fa-fw"></i>更新日期:&nbsp;&nbsp;
                    2023-12-18
                </div>
                

                
                <div class="info-break-policy">
                    <i class="far fa-file-word fa-fw"></i>文章字数:&nbsp;&nbsp;
                    16.4k
                </div>
                

                

                
            </div>
        </div>
        <hr class="clearfix">

        

        

        <div class="card-content article-card-content">
            <div id="articleContent">
                <span id="more"></span>
<blockquote>
<p>首先我们来回顾下，JS 这门课程需要学习的内容。<br><img src="JS课程内容.png"></p>
</blockquote>
<blockquote>
<ul>
<li>前面我们学习了 ECMAScript 标准中规定的基本语法中的一部分，还有 JS 高级部分+ES6+Ajax+本地存储等内容，等学完 DOM 和 BOM 后再学。</li>
<li>从今天开始，我们开始学习 DOM 和 BOM 相关的内容。</li>
</ul>
</blockquote>
<h3 id="一、API-与-Web-API"><a href="#一、API-与-Web-API" class="headerlink" title="一、API 与 Web API"></a>一、API 与 Web API</h3><ol>
<li>API 应用程序接口<blockquote>
<p>API即：<code>Application Programming Interface</code> ，<strong>应用程序接口</strong>。在编程中可以理解为一些<strong>预先定义好的函数</strong>，目的是提供应用程序与开发人员基于某软件或硬件得一访问一组<strong>例程</strong>的能力，而无须考虑其底层的源代码为何、或理解其内部工作机制的细节。</p>
<ul>
<li>例程： 是某个系统对外提供的功能接口或服务的集合</li>
<li>接口： 站在现实角度，可以理解为两个物体的口子相连接，而无需关心内部实现</li>
</ul>
</blockquote>
</li>
</ol>
<blockquote>
<blockquote>
<p>简单理解：</p>
<ul>
<li>API 是一个被封装好具有一定功能的函数，程序需要使用某种功能时，只需要调用这个函数，就能轻松实现想要完成的功能。</li>
</ul>
</blockquote>
</blockquote>
<ol start="2">
<li>Web API Web 应用程序接口<blockquote>
<p>Web API：<code>Web Application Programming Interface</code> 在前端可以理解为是浏览器提供的一套操作<strong>浏览器功能和页面元素</strong>的API，其中包括 DOM 和 BOM。</p>
<ul>
<li><code>DOM：Document Object Model</code>文档对象模型， 是 JavaScript <strong>操作网页</strong>的接口。它定义了访问<strong>HTML文档对象</strong>的一套属性、方法和事件。</li>
<li><code>BOM：Browser Object</code>浏览器对象模型， 是 JavaScript <strong>操作浏览器</strong>的接口，提供一系列与浏览器相关的信息<ul>
<li>DOM 与 BOM 是 W3C 国际组织定义的一套 Web 标准接口。</li>
<li>W3C（万维网联盟）创建于 1994 年，是 Web 技术领域最具权威和影响力的国际中立性技术标准机构。<blockquote>
<p>因为 Web API 很多，所以我们称其为 Web APIs。</p>
</blockquote>
</li>
</ul>
</li>
</ul>
</blockquote>
</li>
</ol>
<h3 id="二、DOM-概况与获取元素"><a href="#二、DOM-概况与获取元素" class="headerlink" title="二、DOM 概况与获取元素"></a>二、DOM 概况与获取元素</h3><h4 id="什么是-DOM"><a href="#什么是-DOM" class="headerlink" title="什么是 DOM"></a>什么是 DOM</h4><blockquote>
<p>DOM全称<code>Document Object Model</code>文档对象模型。</p>
<ul>
<li><code>Document</code>文档，表示的就是整个 <code>HTML</code> 网页文档</li>
<li><code>Object</code>对象 ，表示将网页中的<strong>每一个部分</strong>都转换为一个<strong>对象</strong></li>
<li><code>Model</code>模型，表示对象之间的关系，这样方便我们获取对象。</li>
</ul>
</blockquote>
<blockquote>
<ul>
<li><strong>DOM 是 JavaScript 操作网页的接口，那 JS 具体是如何操作 DOM 的呢 ？</strong></li>
<li>DOM 最大的特点，就是将整个HTML文档抽象成一个<strong>DOM 树</strong>，JS 可以通过操作DOM树来实现<strong>对HTML文档的添加、删除 、修改等操作</strong></li>
</ul>
</blockquote>
<ul>
<li>我们来下面这段简单的 HTML 代码</li>
</ul>
<pre><code>&gt;&lt;!DOCTYPE html&gt;
&gt;&lt;html lang=&quot;en&quot;&gt;
&gt;  &lt;head&gt;
&gt;    &lt;meta charset=&quot;UTF-8&quot; /&gt;
&gt;    &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot; /&gt;
&gt;    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot; /&gt;
&gt;    &lt;title&gt;DOM文档结构树&lt;/title&gt;
&gt;  &lt;/head&gt;
&gt;  &lt;body&gt;
&gt;    &lt;div&gt;
&gt;      &lt;div&gt;我是文本节点&lt;/div&gt;
&gt;      &lt;img src=&quot;&quot; alt=&quot;&quot; /&gt;
&gt;      &lt;h3&gt;&lt;/h3&gt;
&gt;    &lt;/div&gt;
&gt;    &lt;p&gt;&lt;/p&gt;
&gt;  &lt;/body&gt;
&gt;&lt;/html&gt;
</code></pre>
<img src="DOM树.png">

<blockquote>
<blockquote>
<p>注</p>
</blockquote>
<ul>
<li>DOM 的<strong>最小组成单位</strong>叫做节点（node）</li>
<li>根据 W3C 的<code>HTML DOM 标准</code>，HTML 文档中的<strong>所有内容</strong>都是节点。</li>
<li>DOM 树就是由各种不同类型的节点组成。</li>
</ul>
</blockquote>
<h4 id="节点（node）"><a href="#节点（node）" class="headerlink" title="节点（node）"></a>节点（node）</h4><blockquote>
<ul>
<li>DOM 中的节点的类型有如下七种：</li>
</ul>
</blockquote>
<table>
<thead>
<tr>
<th>节点分类</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>Document 文档节点</td>
<td>整个 DOM 树的顶层节点</td>
</tr>
<tr>
<td>DocumentType 文档类型节点</td>
<td>如 doctype 标签(<code>&lt;!DOCTYPE html&gt;</code>)</td>
</tr>
<tr>
<td>Element 元素节点</td>
<td>网页的各种 HTML 标，如：<code>&lt;p&gt;</code>、<code>&lt;div&gt;</code></td>
</tr>
<tr>
<td>Attr 属性节点</td>
<td>元素的各种属性，如：title&#x3D;’标题’、class&#x3D;’box’</td>
</tr>
<tr>
<td>Text 文本节点</td>
<td>标签之间或标签包含的文本</td>
</tr>
<tr>
<td>Comment 注释节点</td>
<td>网页中的注释</td>
</tr>
<tr>
<td>DocumentFragment 文档片段</td>
<td>文档片段，不存于 DOM 树上，是一种游离态，通常作为仓库来使用</td>
</tr>
</tbody></table>
<h4 id="document-文档对象"><a href="#document-文档对象" class="headerlink" title="document 文档对象"></a>document 文档对象</h4><blockquote>
<ul>
<li>document 文档对象是<code>HTMLDocument</code>的<strong>实例</strong>，表示整个 HTML 页面（HTMLDocument 继承 Document）</li>
<li>document 是 window 对象的属性，因此是一个<strong>全局对象</strong></li>
<li>控制台 console 可以输入下面两行代码，就可以获得当前网页的文档对象</li>
</ul>
</blockquote>
<pre><code>window.document; // 获取 文档节点对象
document; // 获取 文档节点对象
// 注意区分大小写， document 与 Document是两个不同的东西
// HTMLDocument 继承 Document
</code></pre>
<blockquote>
<blockquote>
<ul>
<li>document 对象是 DOM 中最重要的东西，几乎所有DOM 的功能都封装在了 document 对象中</li>
<li>我们可以通过 document 对象，来访问元素节点。</li>
</ul>
</blockquote>
</blockquote>
<h4 id="访问元素节点的常用方法"><a href="#访问元素节点的常用方法" class="headerlink" title="访问元素节点的常用方法"></a>访问元素节点的常用方法</h4><blockquote>
<ul>
<li>所谓 “访问” 元素节点，就是指 “得到”、”获取” 页面上的元素节点</li>
<li>对节点进行操作，第一步就是要得到它<table>
<thead>
<tr>
<th>方法</th>
<th>功能</th>
</tr>
</thead>
<tbody><tr>
<td>getElementById()</td>
<td>通过元素 id 名获取到元素</td>
</tr>
<tr>
<td>getElementsByTagName()</td>
<td>通过标签名获取元素，返回的是一个数组</td>
</tr>
<tr>
<td>getElementsByClassName()</td>
<td>通过 class 名获取元素，返回的是一个数组</td>
</tr>
<tr>
<td>querySelector()</td>
<td>通过选择器得到元素,只能得到第一个被找到的元素</td>
</tr>
<tr>
<td>querySelectorAll()</td>
<td>通过选择器得到元素，返回的是一个数组</td>
</tr>
</tbody></table>
</li>
</ul>
</blockquote>
<ol>
<li>getElementById()<blockquote>
<ul>
<li><code>document.getElementById()</code>的功能是，通过元素的<strong>id名</strong>来得到元素节点</li>
<li>不管元素藏的位置有多深，都能通过 id 把它找到<blockquote>
<p>如果页面上有相同 id 的元素，则只能得到<strong>第一个</strong> ，id 是唯一的。</p>
</blockquote>
</li>
</ul>
</blockquote>
</li>
</ol>
<pre><code>&gt;&lt;div id=&quot;box&quot;&gt;我是一个盒子&lt;/div&gt;
&gt;&lt;div id=&quot;box&quot;&gt;我是2&lt;/div&gt;
&gt;&lt;p id=&quot;title&quot;&gt;我是一个段落&lt;/p&gt;
&gt;
&gt;&lt;script&gt;
  var box = document.getElementById(&quot;box&quot;);
  var title = document.getElementById(&quot;title&quot;);
  console.log(box); // &lt;div id=&quot;box&quot;&gt;我是一个盒子&lt;/div&gt;
  console.log(title); // &lt;p id=&quot;title&quot;&gt;我是一个段落&lt;/p&gt;
  console.log(typeof box); // object
&gt;&lt;/script&gt;
</code></pre>
<ol start="2">
<li>getElementsByTagName()<blockquote>
<ul>
<li><code>getElementsByTagName()</code>方法的功能是通过<strong>标签名</strong>得到节点元素组成的<strong>数组</strong>,而且得到的是一个类数组，没有数组身上的方法</li>
<li>所以我们可以通过遍历数组，批量操控每一元素节点</li>
</ul>
</blockquote>
</li>
</ol>
<pre><code>&gt;&lt;div id=&quot;box1&quot;&gt;
&gt;  &lt;p&gt;我是p段落标签&lt;/p&gt;
&gt;&lt;/div&gt;
&gt;&lt;div id=&quot;box2&quot;&gt;
&gt;  &lt;p&gt;我是p段落标签&lt;/p&gt;
&gt;  &lt;p&gt;我是p段落标签&lt;/p&gt;
&gt;  &lt;h3&gt;我是h3标签&lt;/h3&gt;
&gt;&lt;/div&gt;
&gt;&lt;script&gt;
&gt;  var pList = document.getElementsByTagName(&quot;p&quot;);
&gt;  console.log(pList); // HTMLCollection(3) [p, p, p]
&gt;&lt;/script&gt;
</code></pre>
<blockquote>
<blockquote>
<p>HTMLCollection 对象，是一个类数组对象，他没有数组身上的方法。</p>
</blockquote>
</blockquote>
<blockquote>
<ul>
<li>即使页面上<strong>只有一个</strong>指定标签名的节点，也将得到长度为 1 的数组</li>
<li>如果<strong>没有</strong>找到指定标签名的节点，则返回一个空数组</li>
<li>任何一个节点元素也可以调用 <code>getElementsByTagName()</code>方法，从而得到其内部的某种类的元素节点</li>
</ul>
</blockquote>
<ol start="3">
<li>getElementsByClassName()<blockquote>
<ul>
<li><code>getElementsByClassName()</code>方法的功能是通过<strong>class 类名</strong>得到节点数组</li>
<li>如果只能获取一个元素，返回长度为 1 的数组，如果没有找到，则返回空数组</li>
<li>document和节点元素都可以调用 <code>getElementsByClassName()</code>方法，从而得到其内部的某类名的元素节点</li>
</ul>
</blockquote>
</li>
</ol>
<pre><code>&gt;&lt;div class=&quot;box box1&quot;&gt;box1&lt;/div&gt;
&gt;&lt;div class=&quot;box box2&quot;&gt;box2&lt;/div&gt;
&gt;&lt;div id=&quot;content&quot;&gt;
&gt;  &lt;div class=&quot;box box3&quot;&gt;box3&lt;/div&gt;
&gt;&lt;/div&gt;
&gt;
&gt;&lt;script&gt;
  // 获取所有class名中包含 box的元素
  var box = document.getElementsByClassName(&quot;box&quot;);
  console.log(box);
  // 获取id content的元素
  var content = document.getElementById(&quot;content&quot;);
  // 获取content中class名为box的元素
  var conBox = content.getElementsByClassName(&quot;box&quot;);
  console.log(conBox);
&gt;&lt;/script&gt;
</code></pre>
<ol start="4">
<li>querySelector()<blockquote>
<ul>
<li>通过<strong>CSS 选择器</strong>得到页面当中的元素，不过只能得到<strong>第一个</strong>被找到的元素</li>
</ul>
</blockquote>
</li>
</ol>
<pre><code>&gt;&lt;div class=&quot;box&quot;&gt;
  &lt;p&gt;我是p1&lt;/p&gt;
  &lt;p&gt;我是p2&lt;/p&gt;
&gt;&lt;/div&gt;
&gt;&lt;script&gt;
  var p = document.querySelector(&quot;.box p&quot;);
  console.log(p); // &lt;p&gt;我是p1&lt;/p&gt;
&gt;&lt;/script&gt;
</code></pre>
<ol start="5">
<li>querySelectorAll()<blockquote>
<ul>
<li>通过<strong>CSS选择器</strong>得到页面当中的元素，返回被找到元素组成的<strong>数组</strong></li>
<li>如果只有一个符合要求的，也将得到长度为 1 的数组</li>
<li>如果没有符合要求的，则返回一个空数组</li>
</ul>
</blockquote>
</li>
</ol>
<pre><code>&gt;&lt;div class=&quot;box&quot;&gt;
&gt;  &lt;div class=&quot;title&quot;&gt;
&gt;    &lt;p&gt;我是p&lt;/p&gt;
&gt;    &lt;p&gt;我是p&lt;/p&gt;
&gt;  &lt;/div&gt;
&gt;&lt;/div&gt;
&gt;
&gt;&lt;div class=&quot;title&quot;&gt;
&gt;  &lt;p&gt;我是p&lt;/p&gt;
&gt;  &lt;p&gt;我是p&lt;/p&gt;
&gt;&lt;/div&gt;
&gt;&lt;script&gt;
&gt;  var pList = document.querySelectorAll(&quot;.title p&quot;);
&gt;  console.log(pList); // NodeList(4) [p, p, p, p]
&gt;&lt;/script&gt;
</code></pre>
<ol start="6">
<li><p>querySelectorAll 、getElementsByClassName()、getElementsByTagName() 的区别</p>
<blockquote>
<ul>
<li><code>getElementsByClassName()</code>和 <code>getElementsByTagName()</code>方法是可以<strong>动态获取元素</strong>，也就是当页面上增加或删除元素时，获取的元素个数可以改变</li>
<li>而<code>querySelectorAll()</code>是做不到的</li>
</ul>
</blockquote>
</li>
<li><p>获取 body 与 HTML 元素</p>
<table>
<thead>
<tr>
<th>属性</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>document.body</td>
<td>获取 body 元素</td>
</tr>
<tr>
<td>document.documentElement</td>
<td>获取 html 元素</td>
</tr>
</tbody></table>
</li>
<li><p>获取页面中所有元素</p>
<blockquote>
<ul>
<li><code>document.all</code> 获取页面当中所有元素</li>
<li><code>document.getElementsByTagName(“*”) </code>获取页面当中所有元素<blockquote>
<p>以上方式几乎不用，只是当做了解即可</p>
</blockquote>
</li>
</ul>
</blockquote>
</li>
<li><p>onload 方法</p>
<blockquote>
<ul>
<li>浏览器在加载一个页面时，是按照<strong>自上而下</strong>的顺序加载的。</li>
<li>如果 JS 写在了 body 前面，那 JS 在获取页面元素时，页面上的元素标签还没有被加载出来，就会造成读取不到内容。<blockquote>
<p>通常 JS 代码一定要写到<code>&lt;/body&gt;</code>节点的前面，否则 JS 无法找到相应 HTML 节点</p>
</blockquote>
</li>
</ul>
</blockquote>
</li>
</ol>
<pre><code>&gt;&lt;script&gt;
&gt;  var box1 = document.getElementById(&quot;box1&quot;);
&gt;  console.log(box1); // null  没有获取到元素
&gt;&lt;/script&gt;
&gt;&lt;div id=&quot;box1&quot;&gt;box&lt;/div&gt;
</code></pre>
<blockquote>
<ul>
<li>如果 JS 代码写在 body 前面，也能正常执行，可以使用<code>window.onload = function()&#123;&#125;</code>事件，使页面加载完毕后，再执行指定的代码</li>
</ul>
</blockquote>
<pre><code>&gt;&lt;script&gt;
  // 给window对象添加onload事件监听，onload表示页面都加载完毕了
  window.onload = function () &#123;
    var box1 = document.getElementById(&quot;box1&quot;);
    console.log(box1);
  &#125;;
&gt;&lt;/script&gt;
&gt;&lt;body&gt;
&gt;  &lt;div id=&quot;box1&quot;&gt;box&lt;/div&gt;
&gt;&lt;/body&gt;
</code></pre>
<h3 id="三、操作元素属性"><a href="#三、操作元素属性" class="headerlink" title="三、操作元素属性"></a>三、操作元素属性</h3><h4 id="符合标准的-w3c-属性"><a href="#符合标准的-w3c-属性" class="headerlink" title="符合标准的 w3c 属性"></a>符合标准的 w3c 属性</h4><blockquote>
<p>常见的符合标准的 w3c 属性有</p>
<ul>
<li>id、alt、title</li>
<li>class、style 更改元素样式属性 比较特殊，我们放在后面单独来讲</li>
<li>src 、 href 修改图片地址和 a 标签链接地址</li>
<li>type、value、checked、selected、disabled 表单元素属性<blockquote>
<p>符合标准的 w3c 属性，我们可以直接用<code>对象.属性名</code>的方式来访问</p>
</blockquote>
</li>
</ul>
</blockquote>
<ol>
<li>id、alt 、title<blockquote>
<ul>
<li>id 这个属性在实际中，我们肯定不会去更改他的值</li>
<li>alt 图片描述属性</li>
<li>title 提示属性，主要用在 a 标签上</li>
<li>获取元素后，打点调用来修改或者新增属性</li>
</ul>
</blockquote>
</li>
</ol>
<pre><code>&gt;&lt;img src=&quot;../src/3.avif&quot; id=&quot;img&quot; /&gt;
&gt;&lt;a href=&quot;http://www.baidu.com&quot; id=&quot;link&quot;&gt;百度&lt;/a&gt;
&gt;&lt;script&gt;
&gt;  var img2 = document.getElementById(&quot;img&quot;);
&gt;  var a2 = document.getElementById(&quot;link&quot;);
&gt;  img2.id = &quot;img1&quot;;
&gt;  img2.alt = &quot;美女图片&quot;;
&gt;  a2.title = &quot;去百度走一趟&quot;;
&gt;&lt;/script&gt;
</code></pre>
<ol start="2">
<li>src 和 href<blockquote>
<ul>
<li>src 属性，用来修改图片的地址</li>
<li>href 属性，用来修改超链接的地址</li>
<li>获取元素后，打点调用来修改或者新增属性<blockquote>
<p>a标签对里的文字用<code>.innerText</code>调用</p>
</blockquote>
</li>
</ul>
</blockquote>
</li>
</ol>
<pre><code>&gt;&lt;img src=&quot;images/img1.png&quot; alt=&quot;&quot; id=&quot;img&quot; /&gt;
&gt;&lt;a href=&quot;http://www.baidu.com&quot; title=&quot;百度&quot; id=&quot;link&quot;&gt;百度&lt;/a&gt;
&gt;
&gt;&lt;script&gt;
  var img = document.getElementById(&quot;img&quot;);
  var a = document.getElementById(&quot;link&quot;);
&gt;
  img.src = &quot;images/logo.png&quot;;
  a.href = &quot;http://www.icodingedu.com&quot;;
  a.innerText = &quot;艾编程&quot;;
  a.title = &quot;艾编程&quot;;
&gt;&lt;/script&gt;
</code></pre>
<ol start="3">
<li>表单属性</li>
</ol>
<ul>
<li>value 表单值<blockquote>
<ul>
<li>获取元素后，调用value值可以获取<code>value的初始值</code>或<code>输入框中的内容</code></li>
</ul>
</blockquote>
</li>
</ul>
<pre><code>用户名：&lt;input type=&quot;text&quot; name=&quot;&quot; id=&quot;userName&quot; value=&quot;123&quot; /&gt;&lt;br /&gt;
&gt;&lt;script&gt;
  // 获取用户名
  var userName = document.getElementById(&quot;userName&quot;);
  console.log(userName.value);//123
  //在输入框输入aabb后
  console.log(userName.value);//aabb
&gt;&lt;/script&gt;
</code></pre>
<ul>
<li>type 表单类型<blockquote>
<ul>
<li>把<code>text</code>改成<code>password</code>隐藏密码，也可反向操作</li>
</ul>
</blockquote>
</li>
</ul>
<pre><code>密码：&lt;input type=&quot;text&quot; name=&quot;&quot; id=&quot;iphone&quot; value=&quot;&quot; /&gt;
&gt;&lt;script&gt;
// 获取电话号码输入框
var iphone = document.getElementById(&quot;iphone&quot;);
// 写入密码，将电话号码隐藏
iphone.value = &quot;1223333&quot;;
iphone.type = &quot;password&quot;;
&gt;&lt;/script&gt;
</code></pre>
<ul>
<li>checked 单选和复选框选中状态<blockquote>
<ul>
<li>单选框是互斥的</li>
<li>默认选中：<ul>
<li>在对应标签中写上<code>checked</code>或<code>checked=&quot;true&quot;</code></li>
<li>打点调用该元素的<code>checked</code>值修改为<code>true</code>或<code>checked</code></li>
</ul>
</li>
<li>单选</li>
</ul>
</blockquote>
</li>
</ul>
<pre><code>&gt;&lt;h3&gt;姓别&lt;/h3&gt;
&gt;&lt;input type=&quot;radio&quot; name=&quot;sex&quot; id=&quot;&quot; value=&quot;男&quot; /&gt;男
&gt;&lt;input type=&quot;radio&quot; name=&quot;sex&quot; checked=&quot;true&quot; id=&quot;&quot; value=&quot;女&quot; /&gt;女
&gt;&lt;script&gt;
 // 获取单选框
  var sex = document.getElementsByName(&quot;sex&quot;);
  // 选中第一个男
  //sex[0].checked = true;
  //sex[1].checked = &quot;checked&quot;;
&gt;&lt;/script&gt;
</code></pre>
<blockquote>
<ul>
<li>复选</li>
</ul>
</blockquote>
<pre><code>&gt;&lt;h3&gt;喜欢的水果&lt;/h3&gt;
&gt;&lt;input type=&quot;checkbox&quot; name=&quot;fruit&quot; id=&quot;&quot; /&gt; 苹果
&gt;&lt;input type=&quot;checkbox&quot; name=&quot;fruit&quot; id=&quot;&quot; /&gt;梨子
&gt;&lt;input type=&quot;checkbox&quot; name=&quot;fruit&quot; id=&quot;&quot; /&gt;葡萄
&gt;&lt;script&gt;
  // 获取复选框
  var fruit = document.getElementsByName(&quot;fruit&quot;);
  //选中第一个
  fruit[0].checked=true;//或者&quot;checked&quot;
  //取消选中
  fruit[0].checked=false;
&gt;&lt;/script&gt;
</code></pre>
<blockquote>
<blockquote>
<p><code>getElementsByName</code>：通过表单的<code>name</code>属性获取元素，得到的是一个类数组元素</p>
</blockquote>
</blockquote>
<ul>
<li>selected 下拉列表元素选中状态<blockquote>
<ul>
<li>修改默认选中元素：<ul>
<li>方式1：<code>.selected = true</code></li>
<li>方式2：下拉菜单有一个属性：<code>.selectedIndex</code>可以获取&#x2F;修改选中元素</li>
</ul>
</li>
</ul>
</blockquote>
</li>
</ul>
<pre><code>&gt;&lt;h3&gt;选择所在城市&lt;/h3&gt;
&gt;&lt;select name=&quot;&quot; id=&quot;city&quot;&gt;
&gt;  &lt;option value=&quot;湖南&quot;&gt;湖南&lt;/option&gt;
&gt;  &lt;option value=&quot;深圳&quot;&gt;深圳&lt;/option&gt;
&gt;  &lt;option value=&quot;上海&quot;&gt;上海&lt;/option&gt;
&gt;&lt;/select&gt;
&gt;&lt;script&gt;
&gt;  // 获取下拉列表
&gt;  var city = document.getElementById(&quot;city&quot;);
&gt;  var ops = city.getElementsByTagName(&quot;option&quot;);
&gt;  //修改被选中元素——方式1
&gt;  ops[2].selected = true;
&gt;  console.log(city.selectedIndex); //2
&gt;  //修改被选中元素——方式2
&gt;  city.selectedIndex = 0;
&gt;  console.log(city.selectedIndex); //0
</code></pre>
<ul>
<li>disabled 元素是否被禁用<blockquote>
<ul>
<li><code>.disabled = true</code></li>
<li><code>.disabled = &quot;disabled&quot;</code></li>
</ul>
</blockquote>
</li>
</ul>
<pre><code>&gt;&lt;input type=&quot;submit&quot; id=&quot;submit&quot; value=&quot;提交&quot; /&gt;
&gt;&lt;script&gt;
// 提交按扭
var submit = document.getElementById(&quot;submit&quot;);
submit.disabled = true; // 禁用
// submit.disabled = &quot;disabled&quot;;
&gt;&lt;/script&gt;
</code></pre>
<h4 id="自定义属性"><a href="#自定义属性" class="headerlink" title="自定义属性"></a>自定义属性</h4><blockquote>
<ul>
<li>自定义属性：由我们自己定义在元素身上的属性</li>
<li>自定义属性的目的：用来保存元素标签后期要用到的一些<strong>数据内容</strong>，一些简单数据存在自定义属性中，后期操作方便。</li>
<li>修改自定义属性，可以通过下面方法来操作(旧方法)<table>
<thead>
<tr>
<th>方法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>getAttribute(key)</td>
<td>获取属性，key 表示要获取的属性名</td>
</tr>
<tr>
<td>setAttribute(key,value)</td>
<td>添加或修改属性值，key 表示属性名，value 表示属性值</td>
</tr>
</tbody></table>
</li>
</ul>
</blockquote>
<pre><code>&gt;&lt;div id=&quot;box&quot; abs=&quot;值&quot; title=&quot;我是提示&quot;&gt;&lt;/div&gt;
&gt;&lt;script&gt;
  var box = document.getElementById(&quot;box&quot;);
  console.log(box.abs); // undefined
  console.log(box.getAttribute(&quot;abs&quot;)); // 值
  console.log(box.getAttribute(&quot;title&quot;)); // 我是提示
  box.setAttribute(&quot;mycustom&quot;, &quot;自定义属性值&quot;);//添加属性
  box.setAttribute(&quot;id&quot;, &quot;box2&quot;); //id=&quot;box2&quot;
  console.log(box.getAttribute(&quot;id&quot;));//box2
&gt;&lt;/script&gt;
</code></pre>
<blockquote>
<blockquote>
<p><code>setAttribute(key,value)</code>与<code>getAttribute(key)</code>也是可以操作标准属性</p>
</blockquote>
</blockquote>
<h4 id="Html5-中自定义属性规范"><a href="#Html5-中自定义属性规范" class="headerlink" title="Html5 中自定义属性规范"></a>Html5 中自定义属性规范</h4><blockquote>
<ul>
<li>Html5 中规定自定义属性名以<code>data-</code>开头</li>
<li>使用<code>data-</code>前缀自定义属性，可以解决属性混乱无管理的现状，区分自定义属性与标准属性</li>
</ul>
</blockquote>
<ol>
<li>设置自定义属性的 2 种方式</li>
</ol>
<ul>
<li>方式一： 可以直接在 HTML 标签上面书写</li>
</ul>
<pre><code>&gt;&lt;h2 data-weather=&quot;sunny&quot;&gt;今天是晴天&lt;/h2&gt;
&lt;!--
    data-weather 自定义属性名
    sunny 自定义属性值
--&gt;
&lt;!-- 多个单词组合 --&gt;
&gt;&lt;h2 data-birth-date=&quot;20230501&quot;&gt;今天是我的生日&lt;/h2&gt;
</code></pre>
<blockquote>
<blockquote>
<p>如果设置的自定义属性是多个单词组合的形式，需要用中横线-连接</p>
</blockquote>
</blockquote>
<ul>
<li>方式二： 通过 JS 的<code>dataset</code>属性来设置<blockquote>
<ul>
<li><code>.dataset.属性名=&quot;属性值&quot;</code></li>
<li>属性名中的大写，会自动用<code>-</code>分隔(驼峰命名法)</li>
</ul>
</blockquote>
</li>
</ul>
<pre><code>&gt;&lt;h2&gt;今天是我的生日&lt;/h2&gt;
&gt;&lt;script&gt;
&gt;  var h2 = document.querySelector(&quot;h2&quot;);
&gt;  h2.dataset.birthDate = &quot;20230501&quot;;
   //data-birth-date=&quot;20230501&quot;
&gt;&lt;/script&gt;
</code></pre>
<ol start="2">
<li>获取自定义属性<blockquote>
<ul>
<li>直接通过<code>对象.dataset.属性名</code>（属性名书写格式：属性去掉 <code>data-</code>之后的单词，<strong>以驼峰命名</strong>）</li>
<li>如 属性名为<code>data-ab-cd-fg</code>则访问方式：<code>对象.dataset.abCdFg</code></li>
</ul>
</blockquote>
</li>
</ol>
<pre><code>&gt;&lt;img src=&quot;images/dog.png&quot; data-animal-type=&quot;animal&quot; /&gt;
&gt;&lt;script&gt;
  var img = document.getElementsByTagName(&quot;img&quot;);
  //获取自定义属性
  var animalType = img[0].dataset.animalType;
  console.log(animalType);
&gt;&lt;/script&gt;
</code></pre>
<h3 id="四、操作元素样式"><a href="#四、操作元素样式" class="headerlink" title="四、操作元素样式"></a>四、操作元素样式</h3><blockquote>
<ul>
<li>操作元素样式的属性有style 、cssText、 className</li>
<li>同时 HTML5 提供了classList对象，classList对象身上的方法，用来操作元素的 class 属性，简直完美。</li>
</ul>
</blockquote>
<ol>
<li>style 属性<blockquote>
<ul>
<li>style 属性用来操作元素的<strong>行内样式</strong>，他只对行内样式有效</li>
<li><strong>获取</strong>行内样式的写法：<br><code>对象.style.属性名; // 属性名要采用驼峰形式书写</code></li>
<li><strong>修改或添加</strong>行内样式的写法<br><code>对象.style.属性名 = 属性值; // 属性名要采用驼峰形式书写</code></li>
</ul>
</blockquote>
</li>
</ol>
<pre><code>&gt;&lt;style&gt;
    .box &#123;
        width: 100px;
        height: 200px;
        background-color: hotpink;
        color: red;
    &#125;
&gt;&lt;/style&gt;
&gt;
&gt;&lt;div class=&quot;box&quot;&gt;&lt;/div&gt;
&gt;&lt;script&gt;
  var box = document.getElementsByClassName(&quot;box&quot;);
  box[0].style.width = &quot;200px&quot;;
  box[0].style.backgroundColor = &quot;red&quot;;
  box[0].style.borderTop = &quot;15px solid blue&quot;;
&gt;
  // 获取样式
  console.log(box[0].style.color); // 获取不到,color写在class内
  console.log(box[0].style.borderTop); //15px solid blue
&gt;&lt;/script&gt;
</code></pre>
<p><strong>注意事项：</strong></p>
<blockquote>
<ul>
<li>操作元素的 style 上的样式，这里的样式<strong>权重最高</strong>，可以覆盖外部和内嵌样式</li>
<li>如果样式写在了class类中，没写在 style 属性中，则通过<code>对象.style.属性名</code>的方式，是<strong>获取不到的</strong></li>
<li>如果元素要改变的<strong>样式量特别多</strong>，这种方式就比较麻烦。</li>
</ul>
</blockquote>
<ol start="2">
<li>cssText 属性<blockquote>
<ul>
<li><code>cssText</code>的本质就是设置 HTML 元素的 <code>style</code> 属性值</li>
<li>所以每设置一次 cssText 值，就会把之前的 style 属性中的样式<strong>全部覆盖</strong>掉</li>
</ul>
</blockquote>
</li>
</ol>
<pre><code>&gt;&lt;div
  class=&quot;box&quot;
  style=&quot;width: 100px; height: 200px; background-color: red&quot;
&gt;&lt;/div&gt;
&gt;&lt;script&gt;
  var box = document.getElementsByClassName(&quot;box&quot;)[0];
  box.style.cssText = &quot;color:blue&quot;; // 覆盖了之前的style样式中的值
&gt;&lt;/script&gt;
</code></pre>
<blockquote>
<blockquote>
<p>cssText 主要用来合并多次对 CSS 样式的修改，改为一次性处理</p>
</blockquote>
</blockquote>
<ol start="3">
<li>className 属性<blockquote>
<ul>
<li>我们在操作元素的<code>class</code>样式属性时，<strong>不能</strong>用<code>对象.属性</code> 的方法操作，因为 class 是关键字</li>
<li>我们可以通过<code>对象.className</code>的方式来操作</li>
<li>注意事项：<code>className</code>修改样式，如果是多个样式，样式之间要用<strong>空隔</strong>隔开</li>
</ul>
</blockquote>
</li>
</ol>
<pre><code>&gt;&lt;style&gt;
  .box &#123;
    width: 100px;
    height: 100px;
    background-color: skyblue;
  &#125;
  .box1 &#123;
    border: 5px dashed tomato;
  &#125;
&gt;&lt;/style&gt;
&gt;&lt;body&gt;
  &lt;div class=&quot;box&quot;&gt;&lt;/div&gt;
  &lt;script&gt;
    var box = document.getElementsByClassName(&quot;box&quot;);
    box[0].className = &quot;box box1&quot;; // box与box1之间要有空格
  &lt;/script&gt;
&gt;&lt;/body&gt;
</code></pre>
<blockquote>
<ul>
<li>className 操作 CSS 样式有一个很大的<strong>缺点</strong>，就是我每次更新 class 类名时，都要把<strong>所有的类名带上</strong>。</li>
<li>如果我只想在元素原有的基础上继续添加新的类名、或删除某个类名，能不能不动原有的类名，就能实现。答案肯定是可以的</li>
</ul>
</blockquote>
<ol start="4">
<li>操作 CSS 样式的优先方案<blockquote>
<p>style、cssText、className 三种方式操作 CSS 样式时，性能消耗由低到高的排序分别如下：</p>
<ul>
<li>className &gt; cssText &gt; style</li>
</ul>
</blockquote>
</li>
</ol>
<p><strong>原因</strong></p>
<blockquote>
<ul>
<li>通过 <code>style</code> 属性来操作 CSS 样式，会<strong>频繁的触发页面的重排和重绘（DOM 重新渲染）</strong></li>
<li>通过 style 身上的 <code>cssText</code> 属性来操作 CSS 样式，是把多次对 DOM 的操作合并为<strong>一次性处理</strong>，减少了触发重排和重绘（DOM 的重新渲染）次数</li>
<li>通过 <code>className</code> 属性，本质也是一样的，减少了对 DOM 的操作，<strong>多次操作合并为一次性处理</strong>，同时 className 中的样式，<strong>一开始就准备好了</strong>。</li>
</ul>
</blockquote>
<ol start="5">
<li>classList 对象<blockquote>
<ul>
<li><code>html5</code>为每一个元素新增了一个**<code>classList</code>对象<strong>，<code>classList</code>对象保存着</strong>控制当前元素类名**的各个方法和属性。<br><strong>classList 对象身上相关的属性和方法如下表：</strong><table>
<thead>
<tr>
<th>属性或方法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>length</td>
<td>返回类名的<strong>个数</strong></td>
</tr>
<tr>
<td>add()</td>
<td>在原有的类名基础上<strong>添加</strong>一个类名，如果这些类已经存在于元素的属性中，那么它们将被忽略。</td>
</tr>
<tr>
<td>remove()</td>
<td>在原有的类名基础上,<strong>移出</strong>某一个类名，即使删除不存在的类值也不会导致抛出异常</td>
</tr>
<tr>
<td>toggle()</td>
<td>如果<strong>有</strong>这个类名，则删除这个类名，返回 <code>false</code>，如果<strong>没有</strong>则添加上去，返回<code>true</code></td>
</tr>
<tr>
<td>item()</td>
<td>根据索引 获取类名</td>
</tr>
<tr>
<td>contains()</td>
<td>判断元素是否包含某一个类名</td>
</tr>
<tr>
<td>replace(oldClass, newClass)</td>
<td>用一个<strong>新类值替换</strong>已有的类值，替换成功返回 true,替换失败，返回 false</td>
</tr>
</tbody></table>
</li>
</ul>
</blockquote>
</li>
</ol>
<pre><code> var box = document.getElementsByClassName(&quot;box&quot;)[0];
 console.log(box.classList.length); // 3 类名个数
 box.classList.add(&quot;box3&quot;); // 追加一个类名box3
 box.classList.remove(&quot;box2&quot;); // 移除一个类名box2
 bool1 = box.classList.toggle(&quot;box1&quot;); // 有就移除box1
 console.log(bool1); //删除则返回false
 bool2 = box.classList.toggle(&quot;box1&quot;); // 没有就添加box1
 console.log(bool2); //添加则返回true
 console.log(box.classList.item(1)); // 索引为0的类名 box
 console.log(box.classList.contains(&quot;box&quot;)); // true
 console.log(box.classList.replace(&quot;box&quot;, &quot;mybox&quot;)); // 用mybox 替换box
</code></pre>
<blockquote>
<blockquote>
<p>注</p>
</blockquote>
<ul>
<li>假设现在浏览器版本过低，<strong>不支持</strong> <code>classList</code> 对象，那就需要我们<strong>手写</strong>相关方法来实现对 class 属性的操作。</li>
<li>这里我们尝试手写：<code>add</code>、<code>remove</code>、<code>toggle</code>三个方法。</li>
<li>我们期望 html 元素可以直接调用这些方法，实现对 class 类名的操作。</li>
<li>那就需要确认，我们手写的这些方法要加在<strong>哪个构造函数（类）的原型上</strong>。因此我们了解 DOM 中各个类的关系。</li>
</ul>
</blockquote>
<ol start="6">
<li>DOM 中各类的继承关系图<img src="DOM继承关系图.png"></li>
</ol>
<ul>
<li>方法：<blockquote>
<ul>
<li>查看实例的构造函数(类)：<code>实例.__proto__</code></li>
<li>查看继承关系：<ul>
<li>方法1：在控制台，一层层查看对应的<code>[[prototype]]</code></li>
<li>方法2：输入以下代码：</li>
</ul>
</li>
</ul>
</blockquote>
</li>
</ul>
<pre><code>//元素节点只有构造函数不同，后续都一样
var box = document.getElementsByClassName(&quot;box&quot;)[0];
//得到它的构造函数：HTMLDivElement
console.log(box.__proto__);
//通过一层层翻找`[[prototype]]`可知继承关系
//HTMLDivElement-&gt;HTMLElement-&gt;Element-&gt;Node-&gt;EventTarget-&gt;Object;
&gt;
var attr = document.createAttribute(&quot;id&quot;);
//属性节点：attr.__proto__;//实例-&gt;Attr(继承)-&gt;Node-&gt;EventTarget-&gt;Object
var text = document.createTextNode(&quot;文本&quot;);
//文本节点：text.__proto__;//实例-&gt;Text(继承)-&gt;CharacterData-&gt;Node-&gt;EventTarget-&gt;Object
var frag = document.createDocumentFragment();
//文档片段：frag.__proto__;//实例-&gt;DocumentFragment(继承)-&gt;Node-&gt;EventTarget-&gt;Object
var comment = document.createComment(&quot;我是一段注释&quot;);
//注释节点：comment.__proto__;//实例-&gt;Comment(继承)-&gt;CharacterData-&gt;Node-&gt;EventTarget-&gt;Object
</code></pre>
<blockquote>
<blockquote>
<p>结论：</p>
</blockquote>
<ul>
<li>我们希望 HTML 元素可以直接打点调用 <code>addClass</code> 等方法，实现对 class 属性的操作</li>
<li>所以这些方法要写在 <code>HTMLElement</code> 的原型上。</li>
</ul>
</blockquote>
<ol start="7">
<li>手写 addClass 方法<blockquote>
<p>该方法实现对元素添加对应的 class 类名，如果元素上没有对应 class 类名添加，有的话就不加</p>
<ul>
<li>className 属性：<ul>
<li><code>.className</code>，获取元素的class类名，得到的是字符串</li>
<li><code>.className=&quot;&quot;</code>修改类名，样式之间要用空隔隔开</li>
</ul>
</li>
<li><code>split()</code>方法可以使字符串以某种分隔符进行分隔，分隔后的字符串组成一个<strong>数组返回</strong></li>
<li><code>includes()</code>方法用来判断一个数组<strong>是否包含</strong>一个指定的值</li>
<li><code>join()</code>方法将一个数组的所有元素以<strong>特定的某种字符</strong>连接成一个字符串，并返回这个<strong>字符串</strong></li>
</ul>
</blockquote>
</li>
</ol>
<pre><code>&gt;&lt;div class=&quot;box box1 box2 box2&quot;&gt;&lt;/div&gt;
&gt;
&gt;&lt;script&gt;
  /**
   * addClass 方法实现对元素添加对应的class类名，如果元素上没有对应class类名就添加，有就不加
   * @param name  class类名字符串
   */
  HTMLElement.prototype.addClass = function (name) &#123;
    if (typeof name !== &quot;string&quot;) return;
    // 获取当前对象上的class类名
    var className = this.className;
    // 以空格分隔成一个数组
    var classArr = className.split(&quot; &quot;);
    // 判断传过来的类名在不在当前数组中，如果不存在，就添加
    if (!classArr.includes(name)) &#123;
      classArr.push(name); // 将类名添加到数组中
    &#125;
    var newClassName = classArr.join(&quot; &quot;); // 将数组元素以空格拼接成字符串
    this.className = newClassName;//修改类名
  &#125;;
  var box = document.querySelector(&quot;.box&quot;);
  box.addClass(&quot;box4&quot;);//谁调用this就是谁
&gt;&lt;/script&gt;
</code></pre>
<ol start="8">
<li>手写 removeClass 方法<blockquote>
<ul>
<li>该方法实现移除元素上对应的 Class 类名，如果有就移除，如果没有不做处理</li>
</ul>
</blockquote>
</li>
</ol>
<pre><code>&gt;&lt;div class=&quot;box box1 box2 box2&quot;&gt;&lt;/div&gt;
&gt;
&gt;&lt;script&gt;
  /**
   * addClass 方法实现对元素添加对应的class类名，如果元素上没有对应class类名就添加，有就不加
   * @param name  class类名字符串
   */
  HTMLElement.prototype.removeClass = function (name) &#123;
    if (typeof name !== &quot;string&quot;) return;
    // 获取当前对象上的class类名
    var className = this.className;
    // 以空格分隔成一个数组
    var classArr = className.split(&quot; &quot;);
    // 获取所查找类名的下标
    var index = classArr.indexOf(name);
    //如果找不到，则退出
    if (index === -1) return;
    //while循环删除所有 给定类名
    while (index !== -1) &#123;
      classArr.splice(index, 1);
      // 要考虑傻逼模式，就是他本来就出现了两个相同的类名
      index = classArr.indexOf(name, index); //从刚删除的下标开始查找该元素
    &#125;
    var newClassName = classArr.join(&quot; &quot;); // 将数组元素以空格拼接成字符串
    this.className = newClassName;//修改类名
  &#125;;
  var box = document.querySelector(&quot;.box&quot;);
  box.removeClass(&quot;box4&quot;);//谁调用this就是谁
&gt;&lt;/script&gt;
</code></pre>
<ol start="9">
<li>手写 toggleClass 方法<blockquote>
<ul>
<li>该方法实现自动判断是给元素添加还是删除对应的 Class 类名，如果元素存在对应 Class 类名就删除，否则就添加</li>
</ul>
</blockquote>
</li>
</ol>
<pre><code>&gt;&lt;div class=&quot;box box1 box2 box2&quot;&gt;&lt;/div&gt;
&gt;&lt;script&gt;
  /**
   * toggleClass 该该方法实现自动判断是给元素添加还是删除对应的Class类名，如果元素存在对应Class类名就删除，否则就添加
   * @param name  class类名字符串
   */
  HTMLElement.prototype.toggleClass = function (name) &#123;
    // 获取当前对象上的class类名
    var className = this.className;
    // 以空格分隔成一个数组
    var classArr = className.split(&quot; &quot;);
    // 判断传过来的类名在不在当前数组中，如果不在，就添加，存在，找到对应下标然后删掉
    var index = classArr.indexOf(name);
    if (index === -1) &#123;
      // 没有就添加
      classArr.push(name);
    &#125; else &#123;
      // 存在，就删除
      // 要考虑傻逼模式，就是他本来就出现了两个相同的类名
      var _index = index;
      while (_index !== -1) &#123;
        classArr.splice(_index, 1);
        _index = classArr.indexOf(name, _index);
      &#125;
    &#125;
    var newClassName = classArr.join(&quot; &quot;); // 将数组元素以空格拼接成字符串
    this.className = newClassName;
&gt;
    // 处理返回值
    if (index === -1) return true;
    return false;
  &#125;;
&gt;
  var box = document.querySelector(&quot;.box&quot;);
  box.toggleClass(&quot;box2&quot;);
  box.toggleClass(&quot;box1&quot;);
  box.toggleClass(&quot;box3&quot;);
&gt;&lt;/script&gt;
</code></pre>
<blockquote>
<blockquote>
<p>注：</p>
<ul>
<li>以上所有方法，都没有办法获取 <strong>class 类名</strong>或 <strong>id 中定义的 css 样式</strong>。</li>
</ul>
</blockquote>
</blockquote>
<ol start="10">
<li>getComputedStyle 方法<blockquote>
<ul>
<li><code>getComputedStyle()</code>方法，<strong>获取</strong>元素的计算样式，<strong>但不能</strong>修改样式。</li>
<li>语法：<br><code>var style = window.getComputedStyle(element, [pseudoElt]);</code></li>
<li><code>element</code>用于获取计算样式的元素</li>
<li><code>pseudoElt</code>指定一个要匹配的<strong>伪元素的字符串</strong>。对普通元素省略（或null）</li>
<li>返回的style是一个<strong>实时</strong>的<code>CSSStyleDeclaration</code> （css 样式声明）对象（它是一个 CSS 声明块，CSS 属性键值对的集合），当元素的样式更改时，它会自动更新本身。</li>
</ul>
</blockquote>
</li>
</ol>
<pre><code>&gt;&lt;style&gt;
  .box &#123;
    width: 200px;
    height: 200px;
    background-color: red;
  &#125;
  .box1 &#123;
    font-size: 20px;
    color: yellow;
    line-height: 100px;
  &#125;
&gt;&lt;/style&gt;
&gt;&lt;/head&gt;
&gt;
&gt;&lt;div class=&quot;box box1&quot; id=&quot;mybox&quot;&gt;我是css盒子&lt;/div&gt;
&gt;&lt;script&gt;
&gt;  var mybox = document.getElementById(&quot;mybox&quot;);
&gt;  var style = getComputedStyle(mybox, null); //得到CSS访问声明
&gt;  console.log(style);
&gt;  for (var i = 0; i &lt; style.length; i++) &#123;
&gt;    key = style[i];
&gt;    //CSS样式及值
&gt;    console.log(key + &quot;=&quot; + style.getPropertyValue(key));
&gt;  &#125;
&gt;&lt;/script&gt;
</code></pre>
<ol start="11">
<li>访问 CSS 属性值 3 种方式</li>
</ol>
<pre><code>// 访问方式一
// propName 属性名，正常书写
window.getComputedStyle(element, [pseudoElt]).getgetPropertyValue(propName);
&gt;
// 访问方式二
// propName 属性名 要采用驼峰命名方式
window.getComputedStyle(element, [pseudoElt]).propName;
&gt;
// 访问方式三
// propName 属性名，正常书写
window.getComputedStyle(element, [pseudoElt])[propName];
</code></pre>
<pre><code>&gt;&lt;style&gt;
  .box &#123;
    width: 200px;
    height: 200px;
    background-color: red;
  &#125;
  .box1 &#123;
    font-size: 20px;
    color: yellow;
    line-height: 100px;
  &#125;
&gt;&lt;/style&gt;
&gt;&lt;div class=&quot;box box1&quot; id=&quot;mybox&quot;&gt;我是css盒子&lt;/div&gt;
&gt;
&gt;&lt;script&gt;
  var mybox = document.getElementById(&quot;mybox&quot;);
  var style = getComputedStyle(mybox, null);
  console.log(style.height);
  console.log(style.backgroundColor);
  console.log(style.lineHeight);
&gt;
  console.log(style.getPropertyValue(&quot;height&quot;));
  console.log(style[&quot;background-color&quot;]);
  console.log(style.getPropertyValue(&quot;line-height&quot;));
&gt;&lt;/script&gt;
</code></pre>
<ol start="12">
<li>获取伪元素样式<blockquote>
<ul>
<li>语法：<br><code>var style = window.getComputedStyle(element, 伪元素字符串);</code></li>
</ul>
</blockquote>
</li>
</ol>
<pre><code>&gt;&lt;style&gt;
  #mybox &#123;
    width: 200px;
    height: 200px;
    background-color: red;
  &#125;
  #mybox::after &#123;
    content: &quot;我是伪元素内容&quot;;
    color: yellow;
  &#125;
&gt;&lt;/style&gt;
&gt;
&gt;&lt;div id=&quot;mybox&quot;&gt;&lt;/div&gt;
&gt;&lt;script&gt;
  var mybox = document.getElementById(&quot;mybox&quot;);
  var style = getComputedStyle(mybox, &quot;::after&quot;);
  console.log(style.color);
  console.log(style.content);
&gt;&lt;/script&gt;
</code></pre>
<h3 id="五、获取元素尺寸"><a href="#五、获取元素尺寸" class="headerlink" title="五、获取元素尺寸"></a>五、获取元素尺寸</h3><h4 id="偏移尺寸"><a href="#偏移尺寸" class="headerlink" title="偏移尺寸"></a>偏移尺寸</h4><blockquote>
<ul>
<li>以下 5 个属性，都与元素的偏移尺寸有关 ,并且都是<strong>只读</strong>的</li>
<li>offsetWidth</li>
<li>offsetHeight</li>
<li>offsetParent</li>
<li>offsetLeft</li>
<li>offsetTop</li>
</ul>
</blockquote>
<ol>
<li>offsetWidth 与 offsetHeight<blockquote>
<ul>
<li>以下属性为<strong>只读</strong>的，<strong>每次访问都会重新计算</strong><table>
<thead>
<tr>
<th>属性</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>offsetWidth</td>
<td>返回一个元素的布局宽度；标准盒模型下，包括：width、border、padding、滚动条宽；怪异盒模型下为：width</td>
</tr>
<tr>
<td>offsetHeight</td>
<td>返回一个元素的布局高度；标准盒模型下，包括：height、border、padding、滚动条宽；怪异盒模型下为：height</td>
</tr>
</tbody></table>
</li>
</ul>
</blockquote>
</li>
</ol>
<pre><code>&gt;&lt;style&gt;
  * &#123;
    margin: 0;
    padding: 0;
  &#125;
  .box &#123;
    width: 200px;
    height: 200px;
    padding: 30px;
    border: 10px solid red;
    margin: 20px;
  &#125;
  .box1 &#123;
    width: 100px;
    height: 100px;
    padding: 30px;
    border: 10px solid blue;
    margin: 20px;
    /* box-sizing: border-box; */
  &#125;
&gt;&lt;/style&gt;
&gt;
&gt;&lt;div class=&quot;box&quot;&gt;
&gt;  &lt;div class=&quot;box1&quot;&gt;&lt;/div&gt;
&gt;&lt;/div&gt;
&gt;
&gt;&lt;script&gt;
  var box1 = document.querySelector(&quot;.box1&quot;);
  var _width = box1.offsetWidth;
  var _height = box1.offsetHeight;
  console.log(_width); // width+padding+border=100+60+20=180
  console.log(_height); //  height+padding+border=100+60+20=180
&gt;
  // 如果box1更改为border-box，则最后输出结果为100 100
&gt;&lt;/script&gt;
</code></pre>
<ol start="2">
<li>offsetParent<blockquote>
<ul>
<li>此属性为<strong>只读</strong>属性，每次访问都会<strong>重新计算</strong></li>
<li><strong>返回</strong>离当前元素<strong>最近的定位祖先元素</strong>或最近的 <code>table,td,th,tbody</code> 元素</li>
<li>在 Webkit 中，<ul>
<li>如果当前元素为隐藏的（该元素或其祖先元素的<code>style.display</code>为”none”），该属性返回 null。</li>
<li>或者该元素的<code>style.position</code>被设为”fixed”，则该属性返回 null。</li>
</ul>
</li>
</ul>
</blockquote>
</li>
</ol>
<pre class=" language-js"><code class="language-js"><span class="token operator">></span><span class="token operator">&lt;</span>style<span class="token operator">></span>
  <span class="token punctuation">.</span>box <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>
    position<span class="token punctuation">:</span> absolute<span class="token punctuation">;</span>
  <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>
  <span class="token punctuation">.</span>box1 <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>
    <span class="token comment" spellcheck="true">/* display: none; */</span>
    position<span class="token punctuation">:</span> relative<span class="token punctuation">;</span>
  <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>
  <span class="token punctuation">.</span>box3 <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>
    <span class="token comment" spellcheck="true">/* position: fixed; */</span>
    display<span class="token punctuation">:</span> none<span class="token punctuation">;</span>
  <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>
<span class="token operator">></span><span class="token operator">&lt;</span><span class="token operator">/</span>style<span class="token operator">></span>
<span class="token operator">></span>  <span class="token operator">&lt;</span><span class="token operator">!</span><span class="token operator">--</span>绝对定位<span class="token operator">--</span><span class="token operator">></span>
<span class="token operator">></span><span class="token operator">&lt;</span>div <span class="token keyword">class</span><span class="token operator">=</span><span class="token string">"box"</span><span class="token operator">></span>
    <span class="token operator">&lt;</span><span class="token operator">!</span><span class="token operator">--</span>相对定位<span class="token operator">--</span><span class="token operator">></span>
  <span class="token operator">&lt;</span>div <span class="token keyword">class</span><span class="token operator">=</span><span class="token string">"box1"</span><span class="token operator">></span>
      <span class="token operator">&lt;</span><span class="token operator">!</span><span class="token operator">--</span>未定位<span class="token operator">--</span><span class="token operator">></span>
    <span class="token operator">&lt;</span>div <span class="token keyword">class</span><span class="token operator">=</span><span class="token string">"box2"</span><span class="token operator">></span>
      <span class="token operator">&lt;</span>div <span class="token keyword">class</span><span class="token operator">=</span><span class="token string">"box3"</span><span class="token operator">></span><span class="token operator">&lt;</span><span class="token operator">/</span>div<span class="token operator">></span>
    <span class="token operator">&lt;</span><span class="token operator">/</span>div<span class="token operator">></span>
  <span class="token operator">&lt;</span><span class="token operator">/</span>div<span class="token operator">></span>
<span class="token operator">></span><span class="token operator">&lt;</span><span class="token operator">/</span>div<span class="token operator">></span>
<span class="token operator">></span><span class="token operator">&lt;</span>script<span class="token operator">></span>
  <span class="token comment" spellcheck="true">// 获取box3元素</span>
  <span class="token keyword">var</span> box3 <span class="token operator">=</span> document<span class="token punctuation">.</span><span class="token function">querySelector</span><span class="token punctuation">(</span><span class="token string">".box3"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token comment" spellcheck="true">// 获取离box3最近的定位祖先元素</span>
  <span class="token keyword">var</span> parent <span class="token operator">=</span> box3<span class="token punctuation">.</span>offsetParent<span class="token punctuation">;</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>parent<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// null</span>
<span class="token operator">></span><span class="token operator">&lt;</span><span class="token operator">/</span>script<span class="token operator">></span>
</code></pre>
<ol start="3">
<li>offsetLeft 和 offsetTop<blockquote>
<ul>
<li>以下两属性为<strong>只读</strong>属性，每次访问都会<strong>重新计算</strong></li>
<li>本质上可以简单理解为定位元素的top&#x2F;left值，但也会受到margin的影响<table>
<thead>
<tr>
<th>属性</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>offsetLeft</td>
<td>它返回当前元素(左边框)相对于其offsetParent元素的<strong>左边框内壁</strong>的距离</td>
</tr>
<tr>
<td>offsetTop</td>
<td>它返回当前元素(上边框)相对于其offsetParent元素的<strong>上边框内壁</strong>的距离</td>
</tr>
</tbody></table>
</li>
</ul>
</blockquote>
</li>
</ol>
<pre><code>&gt;&lt;style&gt;
  * &#123;
    margin: 0;
    padding: 0;
  &#125;
  body &#123;
    padding: 100px;
  &#125;
  .box1 &#123;
    margin: 50px;
    padding: 20px;
    border: 5px solid blue;
    width: 200px;
    height: 200px;
    position: relative;
  &#125;
  .box2 &#123;
    border: 2px solid red;
    height: 150px;
  &#125;
  .box3 &#123;
    width: 100px;
    height: 100px;
    position: absolute;
    border: 10px solid skyblue;
    margin-top: 50px;
    margin-left: 30px;
    left: 20px;
    top: 50px;
  &#125;
&gt;&lt;/style&gt;
&gt;
&gt;&lt;div class=&quot;box1&quot;&gt;
  &lt;div class=&quot;box2&quot;&gt;
    &lt;div class=&quot;box3&quot;&gt;&lt;/div&gt;
  &lt;/div&gt;
&gt;&lt;/div&gt;
&gt;
&gt;&lt;script&gt;
  // 获取box3元素
  var box3 = document.querySelector(&quot;.box3&quot;);
  // 与离他最近的定位祖先元素左内边距的距离
  var _left = box3.offsetLeft; // left + margin-left = 20 + 30 = 50
  // 与离他最近的定位祖先元素上内边距的距离
  var _top = box3.offsetTop; //  top + margin-top = 50 + 50 = 100
  console.log(_left, _top);
&gt;&lt;/script&gt;
</code></pre>
<ol start="4">
<li>计算元素与页面偏移量<blockquote>
<ul>
<li>如果要计算一个元素与页面的左偏移量,则需要把</li>
<li>当前元素与他<code>offsetParent</code>的<code>offsetLeft</code></li>
<li><code>offsetParent</code>的左边框宽度</li>
<li><code>offsetParent</code>的<code>offsetParent</code>元素的<code>offsetLeft</code></li>
<li><code>offsetParent</code>的<code>offsetParent</code>元素的做边框宽度</li>
<li>一层层相加，直到根元素(body)，body的<code>offsetParent</code>是<code>null</code><blockquote>
<p>一个元素与页面的上偏移量同理可得</p>
</blockquote>
</li>
</ul>
</blockquote>
</li>
</ol>
<ul>
<li>while 循环版</li>
</ul>
<pre><code>function getElementLeft(el) &#123;
  // 获取当前元素左偏移量
  var left = el.offsetLeft;
  // 获了当前元素的offsetParent
  var parent = el.offsetParent;
  // 如果 offsetParent 存在，则一直获取,计算他的offsetLeft值，如果不存在，则终止
  while (parent) &#123;
    left += parent.offsetLeft; // 与每一轮元素的父元素与其定位父元素左边距离累加
    // 计算父元素左边框大小
    style = getComputedStyle(parent, null);
    border = parseInt(style.borderLeftWidth); // 过滤单位部分，只取数字部分
    // 把左边框累加进去
    left += border;
    parent = parent.offsetParent;
  &#125;
  // 最终返回获取的left值
  return left;
&#125;
var box1 = document.querySelector(&quot;.box1&quot;);
console.log(getLeft(box1));
</code></pre>
<ul>
<li>递归版</li>
</ul>
<pre><code>function getElementLeft(el) &#123;
  // 获取当前元素左边距
  var left = el.offsetLeft;
  // 获了当前元素的offsetParent
  var parent = el.offsetParent;
  // 如果 offsetParent 存在，则一直获取,计算他的offsetLeft值，如果不存在，则终止
  if (parent) &#123;
    // 计算父元素左边框大小
    style = getComputedStyle(parent, null);
    border = parseInt(style.borderLeftWidth); // 过滤单位部分，只取数字部分
    // 把左边框累加进去
    left += border;
    left += getElementLeft(parent);
  &#125;
  return left;
&#125;
var box1 = document.querySelector(&quot;.box1&quot;);
console.log(getLeft(box1));
</code></pre>
<ol start="5">
<li>总结<blockquote>
<ul>
<li>以下 5 个属性都与元素的<strong>偏移尺寸</strong>相关<img src="元素的偏移尺寸.png"></li>
</ul>
</blockquote>
</li>
</ol>
<blockquote>
<blockquote>
<p>重点强调</p>
<ul>
<li>以上偏移尺寸属性都是只读的，每次访问都会重新计算。因此，应该尽量减少查询它们的次数。</li>
<li>我们可以把查询的值保存在变量中，供后面使用，这样就可以避免影响性能。</li>
</ul>
</blockquote>
</blockquote>
<h4 id="案例"><a href="#案例" class="headerlink" title="案例"></a>案例</h4><ol>
<li>案例 1：求两元素中心点之间的距离<blockquote>
<ul>
<li>两个元素相对于同一个父元素定位，现在我们要求这两个元素中心点之间的距离。<img src="两元素中心点间的距离.png"></li>
</ul>
</blockquote>
</li>
</ol>
<pre><code>// 求两点之间的距离
// obj1与obj2分别表示上图中 box1与box2
function getDistance(obj1, obj2) &#123;
  var a =
    obj1.offsetLeft +
    obj1.offsetWidth / 2 -
    (obj2.offsetLeft + obj2.offsetWidth / 2);
  var b =
    obj1.offsetTop +
    obj1.offsetHeight / 2 -
    (obj2.offsetTop + obj2.offsetHeight / 2);
  return Math.sqrt(a * a + b * b);
&#125;
</code></pre>
<blockquote>
<blockquote>
<ul>
<li>开平方：<code>Math.sqrt()</code></li>
</ul>
</blockquote>
</blockquote>
<ol start="2">
<li>案例 2：找出与当前元素最近的一个元素<blockquote>
<ul>
<li>我们需要找到所有元素与当前元素的距离，然后再从中找出<strong>距离最小</strong>的那个元素(案例1)</li>
<li>我们可以新建一个数组，用来保存每个元素及每个元素与当前元素中心点的距离</li>
</ul>
</blockquote>
</li>
</ol>
<ul>
<li>数组结构如下</li>
</ul>
<pre><code>var elementArr = [
  &#123;
    element: li1, // html元素
    distance: 30, // 与当前元素的最近距离
  &#125;,
  &#123;
    element: li2,
    distance: 50,
  &#125;,
];
</code></pre>
<ul>
<li>最后找出数组中 distance 值最小的那一个对象中的 element 元素</li>
</ul>
<pre><code>// for循环遍历elementArr数组，找出数组中距离最小的那个元素，然后返回
 var minElement = elementArr[0];
 for (var j = 0; j &lt; elementArr.length; j++) &#123;
   if (elementArr[j].distance &lt; minElement.distance) &#123;
     minElement = elementArr[j];
   &#125;
 &#125;
 return minElement.element; // 返回最小的距离的那个对象
</code></pre>
<ul>
<li>代码实现：</li>
</ul>
<pre><code>&gt;&lt;body&gt;
&gt;  &lt;div class=&quot;container&quot;&gt;
&gt;    &lt;div class=&quot;box box1&quot;&gt;box1&lt;/div&gt;
&gt;    &lt;div class=&quot;box box2&quot;&gt;box2&lt;/div&gt;
&gt;    &lt;div class=&quot;box box3&quot;&gt;box3&lt;/div&gt;
&gt;    &lt;div class=&quot;box box4&quot;&gt;box4&lt;/div&gt;
&gt;  &lt;/div&gt;
&gt;
&gt; &lt;script&gt;
  //通过数组下标查询
  var conatiner = document.querySelector(&quot;.container&quot;);
  var box = document.querySelectorAll(&quot;.container .box&quot;);
&gt;
  // 找出与obj元素距离最近的元素
  function findNearest(obj) &#123;
    var elementArr = [];
    var len = box.length;
    // 遍历每个元素，计算每个元素于obj的中心位置，然后保存到数组中
    for (var i = 0; i &lt; len; i++) &#123;
      // 当前被用来比较的obj，不用存到数组中，要排除
      if (box[i] !== obj) &#123;
        // 计算两中心点距离
        var centerDistance = getDistance(box[i], obj);
        // 把这个元素和对应中心点距离保存到数组中
        var el = &#123;&#125;;
        el.element = box[i];
        el.distance = centerDistance;
        elementArr.push(el);
      &#125;
    &#125;
&gt;
  // for循环遍历elementArr数组，找出数组中距离最小的那个元素，然后返回
  var minElement = elementArr[0];
  for (var j = 0; j &lt; elementArr.length; j++) &#123;
    if (elementArr[j].distance &lt; minElement.distance) &#123;
      minElement = elementArr[j];
    &#125;
  &#125;
  return minElement.element; // 返回最小的距离的那个对象
&#125;
&gt;
  console.log(findNearest(box[2]));
&gt;
  // 计算两个元素中心点位置
  function getDistance(obj1, obj2) &#123;
    var x =
      obj1.offsetLeft +
      obj1.offsetWidth / 2 -
      (obj2.offsetLeft + obj2.offsetWidth / 2);
&gt;
  var y =
    obj1.offsetTop +
    obj1.offsetHeight / 2 -
    (obj2.offsetTop + obj2.offsetHeight / 2);
&gt;
  return Math.sqrt(x * x + y * y);
&#125;
&gt; &lt;/script&gt;
&gt;&lt;/body&gt;
</code></pre>
<blockquote>
<ul>
<li>方法2：通过类名查询——见HTML文档</li>
</ul>
</blockquote>
<pre><code>// 获取与目标元素同级的兄弟元素
var children = obj.parentNode.children;
</code></pre>
<h4 id="客户端尺寸"><a href="#客户端尺寸" class="headerlink" title="客户端尺寸"></a>客户端尺寸</h4><blockquote>
<ul>
<li>以下两个属性为元素的客户端尺寸，属性为<strong>只读的</strong>，每次访问都会<strong>重新计算</strong><table>
<thead>
<tr>
<th>属性</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>clientWidth</td>
<td>表示元素的<strong>内容区宽</strong>，在标准盒模型下，包括 <code>width + padding</code>，不包括 <code>border + margin + 滚动条</code></td>
</tr>
<tr>
<td>clientHeight</td>
<td>表示元素的<strong>内容区高</strong>，在标准盒模型下，包括 <code>height + padding</code>，不包括 <code>border + margin + 滚动条</code></td>
</tr>
</tbody></table>
</li>
</ul>
</blockquote>
<pre><code>&gt;&lt;style&gt;
  * &#123;
    margin: 0;
    padding: 0;
  &#125;
  .box &#123;
    width: 200px;
    height: 200px;
    padding: 30px;
    border: 10px solid red;
    margin: 20px;
  &#125;
&gt;&lt;/style&gt;
&gt;
&gt;&lt;div class=&quot;box&quot;&gt;
&gt;  &lt;div class=&quot;box1&quot;&gt;&lt;/div&gt;
&gt;&lt;/div&gt;
&gt;
&gt;&lt;script&gt;
  var box = document.querySelector(&quot;.box&quot;);
  var w = box.clientWidth; // width + padding = 200 + 60 = 260
  var h = box.clientHeight; // height + padding = 200 + 60 = 260
  console.log(w, h);
&gt;&lt;/script&gt;
</code></pre>
<h4 id="滚动尺寸"><a href="#滚动尺寸" class="headerlink" title="滚动尺寸"></a>滚动尺寸</h4><blockquote>
<p>滚动尺寸，提供了元素内容滚动相关的信息。有以下四个属性</p>
<ul>
<li>scrollWidth</li>
<li>scrollHeight</li>
<li>scrollLeft</li>
<li>scrollTop</li>
</ul>
</blockquote>
<ol>
<li>scrollWidth 与 scrollHeight<blockquote>
<ul>
<li>若子元素宽度大于父盒子，那<code>scrollWidth</code>就是：子元素宽度+父盒子padding</li>
<li>若子元素宽度小于父盒子，那<code>scrollWidth</code>就是父元素<code>clientWidth</code>(width+padding-滚动条宽度)</li>
</ul>
</blockquote>
</li>
</ol>
<table>
<thead>
<tr>
<th>属性</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>scrollWidth</td>
<td>元素内容宽度的一种度量，包括由于<code>overflow</code>溢出而在屏幕上不可见的内容；如果没有水平滚动条，其它大小与 <code>clientWidth</code>相同</td>
</tr>
<tr>
<td>scrollHeight</td>
<td>元素内容高度的度量，包括由于<code>overflow</code>溢出导致的视图中不可见内容；如果没有垂直滚动条，其它大小与 <code>clientHeight</code>相同</td>
</tr>
</tbody></table>
<pre><code>&gt;&lt;style&gt;
  .box &#123;
    width: 200px;
    height: 100px;
    border: 2px solid red;
    padding: 50px;
    overflow: scroll;
  &#125;
  .box1 &#123;
    width: 800px;
    height: 800px;
    &lt;!-- width: 100px;  --&gt;
    &lt;!-- height: 500px;  --&gt;
  background-color: skyblue;
  &#125;
&gt;&lt;/style&gt;
&gt;
&gt;&lt;div class=&quot;box&quot;&gt;
&gt;  &lt;div class=&quot;box1&quot;&gt;
    滚动的内容滚动的内容滚动的内容滚动的内容滚动的内容滚动的内容滚动的内容滚动的内容
&gt;  &lt;/div&gt;
&gt;&lt;/div&gt;
&gt;&lt;script&gt;
  var box = document.querySelector(&quot;.box&quot;);
  var _w = box.scrollWidth;
  var _h = box.scrollHeight;
  console.log(_w, _h); // 900 900
  &lt;!-- console.log(_w, _h); // 279 600 --&gt;
&gt;&lt;/script&gt;
</code></pre>
<ol start="2">
<li>scrollLeft 和 scrollTop<blockquote>
<ul>
<li><code>scrollLeft</code>和<code>scrollTop</code>为 <strong>可读可写</strong> 属性<table>
<thead>
<tr>
<th>属性</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>scrollLeft</td>
<td>获取或设置一个元素的内容水平滚动的距离；如果元素没有产生水平方向滚动条，那 scrollLeft &#x3D; 0；设置scrollLeft的值小于 0，scrollLeft 被设为0；如果设置了超出这个容器可滚动的值，scrollLeft 会被设为最大值</td>
</tr>
<tr>
<td>scrollTop</td>
<td>获取或设置一个元素的内容垂直滚动的距离；如果元素没有产生垂直方向滚动条，那 scrollTop &#x3D; 0；如果scrollTop的值小于 0，scrollTop 会被设为0；如果设置了超出这个容器可滚动的值，scrollTop 会被设为最大值</td>
</tr>
</tbody></table>
</li>
</ul>
</blockquote>
</li>
</ol>
<img src="scrollTop和scrollLeft.png">

<pre><code>&gt;&lt;style&gt;
  .box &#123;
    width: 200px;
    height: 100px;
    border: 2px solid red;
    padding: 50px;
    overflow: scroll;
    border: 50px solid khaki;
  &#125;
  .box1 &#123;
    width: 800px;
    height: 800px;
    background-color: skyblue;
  &#125;
&gt;&lt;/style&gt;
&gt;
&gt;&lt;div class=&quot;box&quot;&gt;
&gt;  &lt;div class=&quot;box1&quot;&gt;
    滚动的内容滚动的内容滚动的内容滚动的内容滚动的内容滚动的内容滚动的内容滚动的内容
&gt;  &lt;/div&gt;
&gt;&lt;/div&gt;
&gt;
&gt;&lt;script&gt;
  var box = document.querySelector(&quot;.box&quot;);
  box.onscroll = function () &#123;
    console.log(box.scrollTop); // 打印滚动条滚动的高度
    console.log(box.scrollLeft); // 打印滚动条滚动的宽度
  &#125;;
&gt;//修改滚动距离(根据scrollWidth/height得到滚动条宽高)
  // 滚动条，滚动到底部
  box.scrollTop = 721; // 800-100+21=721 要注意，不要多减了滚动条的高度
  // 滚动条，滚动到最右边
  box.scrollLeft = 621; // 800-200+21=621 要注意，不要多减了滚动条的宽度
&gt;&lt;/script&gt;
</code></pre>
<h4 id="确定元素尺寸"><a href="#确定元素尺寸" class="headerlink" title="确定元素尺寸"></a>确定元素尺寸</h4><blockquote>
<ul>
<li>浏览器在每个元素上都暴露了<code>getBoundingClientRect()</code>方法，返回一个 <code>DOMRect 对象</code></li>
<li>该对象提供了元素的大小及其相对于<strong>视口（可视区）</strong>的位置<blockquote>
<p>相关属性如下：</p>
</blockquote>
</li>
</ul>
</blockquote>
<table>
<thead>
<tr>
<th>属性</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>left、x</td>
<td>元素左边框相对于可视区左边的距离</td>
</tr>
<tr>
<td>top、y</td>
<td>元素上边框框相对于可视区顶部的距离</td>
</tr>
<tr>
<td>right</td>
<td>元素右边框相对于可视区左边的距离</td>
</tr>
<tr>
<td>bottom</td>
<td>元素底边框相对于可视区顶部的距离</td>
</tr>
<tr>
<td>height</td>
<td>元素的高，包括 height + padding + border</td>
</tr>
<tr>
<td>width</td>
<td>元素的宽，包括 width + padding + border</td>
</tr>
</tbody></table>
<img src="确定元素尺寸.png">

<pre><code>&gt;&lt;style&gt;
   body &#123;
    margin:0;
    height: 3000px;
  &#125;
  .box &#123;
    width: 100px;
    height: 100px;
    border: 2px solid red;
    padding: 20px;
    border: 20px solid khaki;
  &#125;
&gt;&lt;/style&gt;
&gt;
&gt;&lt;div class=&quot;box&quot;&gt;&lt;/div&gt;
&gt;
&gt;&lt;script&gt;
  var box = document.querySelector(&quot;.box&quot;);
  var domRect = box.getBoundingClientRect();
  console.log(domRect); // 打印 DOMRect对象
  // 遍历对象
  for (key in domRect) &#123;
    if (typeof domRect[key] !== &quot;function&quot;) &#123;
      // 过滤掉方法，只留下属性
      console.log(key + &quot;:&quot; + domRect[key]);
    &#125;
  &#125;
&gt;
  // 滚动浏览器窗口
  window.onscroll = function () &#123;
    var domRect = box.getBoundingClientRect();
    console.log(domRect);
  &#125;;
&gt;&lt;/script&gt;
</code></pre>
<h4 id="案例-1"><a href="#案例-1" class="headerlink" title="案例"></a>案例</h4><ol>
<li>如何判断两个元素发生了碰撞（经典面试题）<img src="碰撞检测.png"></li>
</ol>
<blockquote>
<ul>
<li>相对于浏览器的位置或相对于同一父元素</li>
</ul>
</blockquote>
<ul>
<li>用<code>getBoundingClientRect()</code>方法</li>
</ul>
<pre><code>&gt;&lt;div class=&quot;box1&quot;&gt;&lt;/div&gt;
&gt;    &lt;div class=&quot;box2&quot;&gt;&lt;/div&gt;
&gt;
&gt;&lt;script&gt;
  function isBump(obj1, obj2) &#123;
    var domRect1 = box1.getBoundingClientRect();
    var T1 = domRect1.top;
    var B1 = domRect1.bottom;
    var L1 = domRect1.left;
    var R1 = domRect1.right;
    var domRect2 = box2.getBoundingClientRect();
    var T2 = domRect2.top;
    var B2 = domRect2.bottom;
    var L2 = domRect2.left;
    var R2 = domRect2.right;
    if (L2 &gt; R1 || T1 &gt; B2 || L1 &gt; R2 || T2 &gt; B1) return false;
    return true;
  &#125;
  var box1 = document.querySelector(&quot;.box1&quot;);
  var box2 = document.querySelector(&quot;.box2&quot;);
  isBump(box1, box2);
&gt;&lt;/script&gt;
</code></pre>
<ul>
<li>用偏移尺寸</li>
</ul>
<pre><code>function isBump(obj1, obj2) &#123;
  var L1 = obj1.offsetLeft;
  var R1 = L1 + obj1.offsetWidth;
  var T1 = obj1.offsetTop;
  var B1 = T1 + obj1.offsetHeight;
  var L2 = obj2.offsetLeft;
  var R2 = L2 + obj2.offsetWidth;
  var T2 = obj2.offsetTop;
  var B2 = T2 + obj2.offsetHeight;
  if (L2 &gt; R1 || L1 &gt; R2 || T2 &gt; B1 || T1 &gt; B2) &#123;
    return false; // 未碰撞，返回false
  &#125; else &#123;
    return true; // 碰撞，返回true
  &#125;
&#125;
</code></pre>
<ol start="2">
<li>判断元素是否在可视区（经典面试题）<blockquote>
<ul>
<li>判断一个元素是不是在可视区，只有元素<strong>全在可视区</strong>，才算是在可视区内<img src="元素是否在可视区内.png"></li>
</ul>
</blockquote>
</li>
</ol>
<ul>
<li>在浏览器可视区内</li>
</ul>
<pre><code>// 判断元素是否是在可视区内，只有当元素全部在可视区内才算是在可视区内
function isElementInViewport(el) &#123;
  var rect = el.getBoundingClientRect();
  var T1 = rect.top;
  var B1 = rect.bottom;
  var L1 = rect.left;
  var R1 = rect.right;
  return (
    T1 &gt;= 0 &amp;&amp;
    B1 &lt;= document.documentElement.clientHeight &amp;&amp;
    L1 &gt;= 0 &amp;&amp;
    R1 &lt;= document.documentElement.clientWidth
  );
&#125;
&gt;
&gt; // 测试，自行在页面加一个.box的div
&gt; var box = document.querySelector(&quot;.box&quot;);
&gt; window.onscroll = function () &#123;
&gt;   console.log(isElementInViewport(box));
&gt; &#125;;
</code></pre>
<ul>
<li>在父级盒子可视区内</li>
</ul>
<pre><code>function isInViewport(el) &#123;
  var T1 = el.offsetTop;
  var B1 = T1 + el.offsetHeight;
  var L1 = el.offsetLeft;
  var R1 = L1 + el.offsetWidth;
  var PH = el.offsetParent.clientHeight;
  var PW = el.offsetParent.clientWidth;
  return T1 &gt;= 0 &amp;&amp; L1 &gt;= 0 &amp;&amp; B1 &lt;= PH &amp;&amp; R1 &lt;= PW;
&#125;
var box1 = document.querySelector(&quot;.box1&quot;);
console.log(isInViewport(box1));
</code></pre>
<h3 id="六、节点操作"><a href="#六、节点操作" class="headerlink" title="六、节点操作"></a>六、节点操作</h3><blockquote>
<p>接下来我们来学习与节点相关的操作，在开始学习 DOM 的时候，我们提到过 DOM 的节点类型有以下 7 种</p>
</blockquote>
<h4 id="节点类型"><a href="#节点类型" class="headerlink" title="节点类型"></a>节点类型</h4><table>
<thead>
<tr>
<th>节点分类</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>Document 文档节点</td>
<td>整个 DOM 树的顶层节点</td>
</tr>
<tr>
<td>DocumentType 文档类型节点</td>
<td>如 doctype 标签(<code>&lt;!DOCTYPE html&gt;)</code></td>
</tr>
<tr>
<td>Element 元素节点</td>
<td>网页的各种 HTML 标，如：<code>&lt;p&gt;</code>、<code>&lt;div&gt;</code></td>
</tr>
<tr>
<td>Attr 属性节点</td>
<td>元素的各种属性，如：<code>title=&#39;标题&#39;</code>、<code>class=&#39;box&#39;</code></td>
</tr>
<tr>
<td>Text 文本节点</td>
<td>标签之间或标签包含的文本</td>
</tr>
<tr>
<td>Comment 注释节点</td>
<td>网页中的注释</td>
</tr>
<tr>
<td>DocumentFragment 文档片段</td>
<td>文档片段，不存于 DOM 树上，是一种游离态，通常作为仓库来使用</td>
</tr>
</tbody></table>
<blockquote>
<p>如何检测节点的类型呢 ？其实每一个节点对象都有以下三个属性：</p>
<ul>
<li>nodeName 节点名</li>
<li>nodeType 节点类型</li>
<li>nodeValue 节点值<table>
<thead>
<tr>
<th>节点类型</th>
<th>nodeName</th>
<th>nodeType</th>
<th>nodeValue</th>
</tr>
</thead>
<tbody><tr>
<td>文档节点</td>
<td>#document</td>
<td>9</td>
<td>null</td>
</tr>
<tr>
<td>元素节点</td>
<td>标签名</td>
<td>1</td>
<td>null</td>
</tr>
<tr>
<td>属性节点</td>
<td>属性名</td>
<td>2</td>
<td>属性值</td>
</tr>
<tr>
<td>文本节点</td>
<td>#text</td>
<td>3</td>
<td>文本内容</td>
</tr>
</tbody></table>
</li>
</ul>
</blockquote>
<h4 id="节点关系"><a href="#节点关系" class="headerlink" title="节点关系"></a>节点关系</h4><ol>
<li>考虑所有节点<blockquote>
<ul>
<li>文本节点<code>#text</code>（即实是空白的文本）也属于节点。标签与标签之间有文本节点<br>页面节点之间存在以下关系<table>
<thead>
<tr>
<th>关系</th>
<th>考虑所有节点</th>
</tr>
</thead>
<tbody><tr>
<td>子节点</td>
<td>childNodes</td>
</tr>
<tr>
<td>父节点</td>
<td>parentNode</td>
</tr>
<tr>
<td>第一个子节点</td>
<td>firstChild</td>
</tr>
<tr>
<td>最后一个子节点</td>
<td>lastChild</td>
</tr>
<tr>
<td>前一个兄弟节点</td>
<td>previousSibling</td>
</tr>
<tr>
<td>后一个兄弟节点</td>
<td>nextSibling</td>
</tr>
</tbody></table>
</li>
</ul>
</blockquote>
</li>
</ol>
<pre><code>&gt;&lt;div class=&quot;box&quot;&gt;
&gt;  &lt;h3 class=&quot;title&quot;&gt;我是h3标签&lt;/h3&gt;
&gt;  &lt;p class=&quot;p1&quot;&gt;我是p标签&lt;/p&gt;
&gt;  &lt;div class=&quot;item&quot;&gt;我是item&lt;/div&gt;
&gt;&lt;/div&gt;
&gt;&lt;script&gt;
&gt;  var box = document.querySelector(&quot;.box&quot;);
&gt;  console.log(box.childNodes);
&gt;  console.log(box.parentNode); //body
&gt;  console.log(box.firstChild); //#text
&gt;  console.log(box.lastChild); //#text
&gt;  var p1 = document.querySelector(&quot;.p1&quot;);
&gt;  console.log(p1.previousSibling); //#text
&gt;  console.log(p1.nextSibling); //#text
&gt;&lt;/script&gt;
</code></pre>
<blockquote>
<blockquote>
<p>注意点：文本节点也属于节点</p>
</blockquote>
<ul>
<li>而我们实际开发中，我们常常希望获取的是元素类型的节点，所以文本类型的节点给我们带来了很大的干扰。</li>
</ul>
</blockquote>
<ol start="2">
<li>只考虑元素节点<blockquote>
<ul>
<li>实际上在 DOM 中还提供了一些<strong>只考虑元素节点</strong>的属性，如下表</li>
<li>我们把考虑所有节点的属性与只考虑元素节点的属性作如下<strong>对比</strong><table>
<thead>
<tr>
<th>关系</th>
<th>考虑所有节点</th>
<th>只考虑元素节点</th>
</tr>
</thead>
<tbody><tr>
<td>子节点</td>
<td>childNodes</td>
<td>children</td>
</tr>
<tr>
<td>父节点</td>
<td>parentNode</td>
<td>parentNode</td>
</tr>
<tr>
<td>第一个子节点</td>
<td>firstChild</td>
<td>fristElementChild</td>
</tr>
<tr>
<td>最后一个子节点</td>
<td>lastChild</td>
<td>lastElementChild</td>
</tr>
<tr>
<td>前一个兄弟节点</td>
<td>previousSibling</td>
<td>previousElementSibling</td>
</tr>
<tr>
<td>后一个兄弟节点</td>
<td>nextSibling</td>
<td>nextElementSibling</td>
</tr>
</tbody></table>
</li>
</ul>
</blockquote>
</li>
</ol>
<pre><code>&gt;&lt;div class=&quot;box&quot;&gt;
&gt;  &lt;h3 class=&quot;title&quot;&gt;我是h3标签&lt;/h3&gt;
&gt;  &lt;p class=&quot;p1&quot;&gt;我是p标签&lt;/p&gt;
&gt;  &lt;div class=&quot;item&quot;&gt;我是item&lt;/div&gt;
&gt;&lt;/div&gt;
&gt;&lt;script&gt;
&gt;  var box = document.querySelector(&quot;.box&quot;);
&gt;  var p1 = document.querySelector(&quot;.p1&quot;);
//只考虑元素节点
  console.log(box.children);
  console.log(box.firstElementChild); //h3
  console.log(box.lastElementChild); //item
  console.log(p1.previousElementSibling); //h3
  console.log(p1.nextElementSibling); //item
&gt;&lt;/script&gt;
</code></pre>
<ol start="3">
<li>手写 children 方法<blockquote>
<p>实现思路</p>
<ul>
<li>用<code>当前节点.childNodes</code>获取所有子节点，然后遍历所有子节点，判断节点的类型<code>nodeType 是否为 1</code></li>
<li>如果为 1，则把这个节点添加到<strong>数组</strong>中</li>
<li>最后遍历完，把数组作为返回值返回。</li>
</ul>
</blockquote>
</li>
</ol>
<pre><code>HTMLElement.prototype._children = function () &#123;
  // this 指向，谁调用_children 那this就是谁
  var nodes = this.childNodes;
  var elementArr = [];
  // 过滤节点类型，只留下元素类型节点
  for (var i = 0; i &lt; nodes.length; i++) &#123;
    if (nodes[i].nodeType === 1) &#123;
      // 是元素类型节点，保存
      elementArr.push(nodes[i]);
    &#125;
  &#125;
  return elementArr;
&#125;;
var box = document.querySelector(&quot;.box&quot;);
console.log(box._children());
</code></pre>
<ol start="4">
<li>手写 prevElementSibling 方法<blockquote>
<p>实现思路</p>
<ul>
<li><code>当前节点.previousSibling</code></li>
<li>如果返回值为<code>null</code>，说明<strong>没有</strong>上一个元素兄弟节点，直接将返回值<code>null</code>返回</li>
<li>如果返回值不为 <code>null</code>，要<strong>判断</strong>节点类型是否为元素节点，即判断<code>返回节点.nodeType === 1</code>是否成立</li>
<li>如果不成立，则继续用<code>返回的节点.previousSibling</code>，一直重复上面过程，直到<code>返回节点.nodeType === 1</code>成立或返回值为 <code>null</code>，就不再继续查找了。</li>
</ul>
</blockquote>
</li>
</ol>
<pre><code>HTMLElement.prototype._prevElementSibling = function () &#123;
  // this，谁打点调用这个方法，this是谁
  var prevElement = this.previousSibling; // 找上一个兄弟节点
  // if(!prevElement) return null;
  // 如果返回的兄弟节点不为null 且节点类型不等于1，说明当前兄弟节点不是元素类型节点，需要继续向上查找。
  //顺序不能调换，因为如果prevElement是null，调用nodeType会报错
  while (prevElement &amp;&amp; prevElement.nodeType !== 1) &#123;
    prevElement = prevElement.previousSibling;
    // if (!prevElement) return null;
  &#125;
  return prevElement; // 如果上面为null，直接返回null,如果不是，返回对应元素节点
&#125;;
</code></pre>
<h4 id="修改节点内容"><a href="#修改节点内容" class="headerlink" title="修改节点内容"></a>修改节点内容</h4><blockquote>
<ul>
<li>改变元素节点中的内容可以使用两个相关属性：</li>
<li>innerHTML：更改元素的内容，更改的内容能以<strong>HTML语法</strong>的形式显示</li>
<li>innerText：更改的内容，更改的内容只能以<strong>纯文本</strong>的形式显示</li>
</ul>
</blockquote>
<pre><code>&gt;&lt;div class=&quot;box&quot;&gt;&lt;/div&gt;
&gt;&lt;div class=&quot;box&quot;&gt;&lt;/div&gt;
&gt;
&gt;&lt;script&gt;
  var box = document.getElementsByClassName(&quot;box&quot;);
  box[0].innerHTML = &quot;&lt;h3&gt;我是h3标签&lt;/h3&gt;&quot;;
  box[1].innerText = &quot;&lt;h3&gt;我是h3标签&lt;/h3&gt;&quot;;
&gt;&lt;/script&gt;
</code></pre>
<h4 id="节点创建与移动"><a href="#节点创建与移动" class="headerlink" title="节点创建与移动"></a>节点创建与移动</h4><blockquote>
<ul>
<li>DOM 中提供了以下方法，用来创建节点，并将创建好的节点插入到页面当中</li>
</ul>
</blockquote>
<table>
<thead>
<tr>
<th>操作节点方法</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>document.createElement(‘标签名’)</td>
<td>用来创建一个指定的<strong>元素节点</strong>对象，并将创建好的对象作为返回值</td>
</tr>
<tr>
<td>document.createTextNode(‘文本内容’)</td>
<td>用来创建一个<strong>文本节点</strong>对象，并将创建好的对象作为返回值。</td>
</tr>
<tr>
<td>父节点.appendChild(‘子节点对象’)</td>
<td>用来向父节点的<strong>最后面</strong>添加一个新的子节点。</td>
</tr>
<tr>
<td>父节点.insertBefore(‘新节点’,’旧节点’)</td>
<td>将新创建的”孤儿节点”插入到页面原有的节点的<strong>前面</strong></td>
</tr>
</tbody></table>
<ol>
<li><p>document.createElement()</p>
<blockquote>
<ul>
<li><code>document.createElement()</code>方法用于创建一个指定 <code>tagName</code>的HTML元素</li>
<li>在创建元素之前，会将传入的tagName转化为<strong>小写</strong>，即生成的标签名是小写名</li>
<li>创建出来的节点是一个<strong>“孤儿节点”</strong>，他并不在 DOM 树上，而是<strong>独立存在</strong>的。</li>
<li>所以我们必须使用<code>appendChild()</code>或<code>insertBefore()</code>方法将孤儿节点<strong>插入到 DOM 树上</strong></li>
<li><code>var myDiv = document.createElement(&quot;div&quot;); //  创建一个标签名为div的元素节点</code></li>
</ul>
</blockquote>
</li>
<li><p>document.createTextNode()</p>
<blockquote>
<ul>
<li>用来创建一个文本节点对象，并将创建好的对象作为返回值</li>
<li><code>var text = document.createTextNode(data);</code><ul>
<li>text 是一个文本节点。</li>
<li>data 是一个字符串，包含了要放入文本节点的内容</li>
</ul>
</li>
</ul>
</blockquote>
</li>
<li><p>appendChild()</p>
<blockquote>
<ul>
<li>该方法将一个节点附加到指定父节点的子节点列表的末尾处</li>
<li>如果某个节点已经拥有父节点，在被传递给此方法后，它首先会被<strong>移除</strong>，再被插入到新的位置</li>
<li>这意味着，一个节点<strong>不可能</strong>同时出现在文档的不同位置<blockquote>
<p>返回值：<code>appendChild()</code>返回的是被附加的子元素</p>
</blockquote>
</li>
</ul>
</blockquote>
</li>
</ol>
<pre><code>element.appendChild(child);
&gt;
// element  将节点追节到的那个父节点
// child 要追加给父节点的节点（通通是一个元素节点）
</code></pre>
<blockquote>
<ul>
<li>代码演示：</li>
</ul>
</blockquote>
<pre><code>//获取页面元素
var ul = document.querySelector(&quot;ul&quot;);
//将div插入到ul的最后面
var div = document.createElement(&quot;div&quot;);
ul.appendChild(div);
&gt;
//将文本节点插入到ul的最后面
var pt = document.createTextNode(&quot;我是一个文本节点&quot;);
ul.appendChild(pt);
&gt;
//将文本节点插入到li中
var li = document.createElement(&quot;li&quot;);
ul.appendChild(li);
li.appendChild(pt);
</code></pre>
<ol start="4">
<li>insertBefore()<blockquote>
<ul>
<li>方法在参考节点之前插入一个拥有指定父节点的子节点</li>
<li>如果被插入节点已经有父节点，则会从当前位置移动到新插入位置<blockquote>
<p>返回值：返回被插入的子节点</p>
</blockquote>
</li>
<li><code>parentNode.insertBefore(newNode, referenceNode);</code><ul>
<li><code>parentNode</code>是<strong>参考节点</strong>的父节点<blockquote>
<p>如果<code>referenceNode</code> 为 <code>null</code> 则 <code>newNode</code> 将被插入到子节点的末尾</p>
</blockquote>
</li>
</ul>
</li>
</ul>
</blockquote>
</li>
</ol>
<blockquote>
<ul>
<li>功能一：创建新元素，插入到指定元素前</li>
</ul>
</blockquote>
<pre><code>&gt;&lt;ul&gt;
&gt;  &lt;li&gt;1&lt;/li&gt;
&gt;  &lt;li&gt;2&lt;/li&gt;
&gt;  &lt;li&gt;3&lt;/li&gt;
&gt;&lt;/ul&gt;
&gt;&lt;script&gt;
  //获取ul
  var oul = document.querySelector(&quot;ul&quot;);
  //创建li元素
  var li1 = document.createElement(&quot;li&quot;);
  // 创建文本元素
  var liText = document.createTextNode(&quot;我是新创建的li文本&quot;);
  //   将文本元素插入到li1中
  li1.appendChild(liText);
  //   将li1插入到第二个li前面
  oul.insertBefore(li1, oul.children[1]);
&gt;&lt;/script&gt;
</code></pre>
<blockquote>
<ul>
<li>功能二：移动元素</li>
</ul>
</blockquote>
<pre><code>&gt;&lt;ul&gt;
&gt;  &lt;li&gt;1&lt;/li&gt;
&gt;  &lt;li&gt;2&lt;/li&gt;
&gt;  &lt;li&gt;3&lt;/li&gt;
&gt;&lt;/ul&gt;
&gt;&lt;script&gt;
  //获取ul
  var oul = document.querySelector(&quot;ul&quot;);
  //获取li元素
  var li = document.getElementsByTagName(&quot;li&quot;);
  //将最后一个li移动到最前面
  oul.insertBefore(li[3], li[0]);
  //如果第二个参数为null，新节点将移动到父节点的最后面
  oul.insertBefore(li[1], null);
&gt;&lt;/script&gt;
</code></pre>
<ol start="5">
<li>综合代码</li>
</ol>
<pre><code>&gt;&lt;ul&gt;
&gt;  &lt;li&gt;1&lt;/li&gt;
&gt;  &lt;li&gt;2&lt;/li&gt;
&gt;  &lt;li&gt;3&lt;/li&gt;
&gt;&lt;/ul&gt;
&gt;&lt;script&gt;
  // 获取元素
  var ul = document.querySelector(&quot;ul&quot;);
  var li = document.getElementsByTagName(&quot;li&quot;);
  //创建节点
  var div = document.createElement(&quot;div&quot;);
  // 修改/新建节点内容
  div.innerHTML = &quot;&lt;h3&gt;我是idv中的h3标签&lt;/h3&gt;&quot;;
  // 插入到页面中,appendChild是移到父元素最后面
  ul.appendChild(div);
  //  移动节点：将新建元素插到li[1]前面
  ul.insertBefore(div, li[1]);
&gt;&lt;/script&gt;
</code></pre>
<h4 id="案例-2"><a href="#案例-2" class="headerlink" title="案例"></a>案例</h4><ol>
<li>请动态创建出一个 15 行 10 列的表格<blockquote>
<ul>
<li>方式1：创建table,tr,td标签</li>
</ul>
</blockquote>
</li>
</ol>
<pre><code>&gt;&lt;div class=&quot;table1&quot;&gt;&lt;/div&gt;
&gt;&lt;script&gt;
// 获取元素
function creatTable1(rows, columns, el) &#123;
  var table = document.createElement(&quot;table&quot;);
  for (var i = 1; i &lt;= rows; i++) &#123;
    // 创建行
    var tr = document.createElement(&quot;tr&quot;);
    for (var j = 1; j &lt;= columns; j++) &#123;
      // 创建列
      var td = document.createElement(&quot;td&quot;);
      // 将列插入行中
      tr.appendChild(td);
    &#125;
    // 将行插入表格中
    table.appendChild(tr);
  &#125;
  // 将表格插入到页面中
  el.appendChild(table);
&#125;
var table1 = document.querySelector(&quot;.table1&quot;);
creatTable1(15, 10, table1);
&gt;&lt;/script&gt;
</code></pre>
<blockquote>
<ul>
<li>方式2：创建ul,li,span标签</li>
</ul>
</blockquote>
<pre><code>&gt;&lt;div class=&quot;table2&quot;&gt;&lt;/div&gt;
&gt;&lt;script&gt;
// 获取元素
 function creatTable2(rows, columns, el) &#123;
   var ul = document.createElement(&quot;ul&quot;);
   for (var i = 1; i &lt;= rows; i++) &#123;
     // 创建行
     var li = document.createElement(&quot;li&quot;);
     for (var j = 1; j &lt;= columns; j++) &#123;
       // 创建列
       var span = document.createElement(&quot;span&quot;);
       // 将列插入行中
       li.appendChild(span);
     &#125;
     // 将行插入ul中
     ul.appendChild(li);
   &#125;
   // 将表格插入到页面中
   el.appendChild(ul);
 &#125;
 var table2 = document.querySelector(&quot;.table2&quot;);
 creatTable2(5, 5, table2);
&gt;&lt;/script&gt;
</code></pre>
<blockquote>
<blockquote>
<p><code>span</code>要转换为行内元素</p>
</blockquote>
</blockquote>
<ol start="2">
<li>案例 2：请制作九九乘法表<blockquote>
<ul>
<li>列数与行数一致</li>
<li>表格内插入文字：<code>innerText</code></li>
</ul>
</blockquote>
</li>
</ol>
<pre><code>&gt;&lt;div class=&quot;mytable&quot;&gt;&lt;/div&gt;
&gt;&lt;script&gt;
  // 创建表格
  var table = document.createElement(&quot;table&quot;);
  for (var i = 1; i &lt;= 9; i++) &#123;
    // 创建行
    var tr = document.createElement(&quot;tr&quot;);
    for (var j = 1; j &lt;= i; j++) &#123;
      // 创建列，输入文字
      var td = document.createElement(&quot;td&quot;);
      td.innerText = i + &quot;*&quot; + j + &quot;=&quot; + i * j;
      //   将td插入行中
      tr.appendChild(td);
    &#125;
    // 将行插入表格
    table.appendChild(tr);
  &#125;
  var mytable = document.querySelector(&quot;.mytable&quot;);
  // 将表格插入页面
  mytable.appendChild(table);
&gt;&lt;/script&gt;
</code></pre>
<ol start="3">
<li>案例 3：创建电影座位号<blockquote>
<ul>
<li>根据需求，创建几行几列的电影座位号<br>关键点：</li>
<li>座位号：用累加器</li>
<li>顺序是从下往上，所以用<code>insertBefore</code></li>
</ul>
</blockquote>
</li>
</ol>
<pre><code>&gt;&lt;div class=&quot;table&quot;&gt;&lt;/div&gt;
&gt;&lt;script&gt;
  function getSeats(rows, columns, el) &#123;
    var ul = document.createElement(&quot;ul&quot;);
    var sum = 0;
    for (var i = 1; i &lt;= rows; i++) &#123;
      // 创建行
      var li = document.createElement(&quot;li&quot;);
      for (var j = 1; j &lt;= columns; j++) &#123;
        // 创建列
        var div = document.createElement(&quot;div&quot;);
        sum++;
        div.innerText = sum;
        li.appendChild(div);
      &#125;
      ul.insertBefore(li, ul.children[0]);
    &#125;
    el.appendChild(ul);
  &#125;
  var table = document.querySelector(&quot;.table&quot;);
  getSeats(5, 5, table);
&gt;&lt;/script&gt;
</code></pre>
<h4 id="innerHTML-与-createElement-的效率问题"><a href="#innerHTML-与-createElement-的效率问题" class="headerlink" title="innerHTML 与 createElement 的效率问题"></a>innerHTML 与 createElement 的效率问题</h4><blockquote>
<ul>
<li><code>innerHTML</code>更改元素的内容，更改的内容能以 HTML 语法的形式显示</li>
<li><code>createElement</code>用于动态创建 HTML 元素，然后结合 <code>appendChild</code>将元素插入到页面中<blockquote>
<p>这两种方式都可以动态创建 HTML 元素，那一种效率更高呢 ？我们通过一个案例来分析</p>
</blockquote>
</li>
</ul>
</blockquote>
<ol>
<li>在页面动态创建 1000 个 li，插入到页面中</li>
</ol>
<pre><code>&gt;&lt;ul class=&quot;list&quot;&gt;&lt;/ul&gt;
&gt;&lt;script&gt;
  var oUl = document.querySelector(&quot;.list&quot;);
&gt;
  //innerHTML实现
  console.time(&quot;innerHTML&quot;);
  for (var i = 1; i &lt;= 1000; i++) &#123;
    oUl.innerHTML += &quot;&lt;li&gt;这是第&quot; + i + &quot;条新闻&lt;/li&gt;&quot;;
  &#125;
  console.timeEnd(&quot;innerHTML&quot;); // 238.225830078125 ms
&gt;
  // createElement实现
  console.time(&quot;createElement&quot;);
  for (var j = 1; j &lt;= 1000; j++) &#123;
    var oLi = document.createElement(&quot;li&quot;);
    oLi.innerText = &quot;这是第&quot; + j + &quot;条新闻&quot;;
    oUl.appendChild(oLi);
  &#125;
  console.timeEnd(&quot;createElement&quot;); //3.586669921875 ms
&gt;
  //innerHTML优化版
  var oUl = document.querySelector(&quot;.list&quot;);
  console.time(&quot;innerHTML&quot;);
  var str = &quot;&quot;;
  for (var i = 1; i &lt;= 1000; i++) &#123;
    str += &quot;&lt;li&gt;这是第&quot; + i + &quot;条新闻&lt;/li&gt;&quot;;
  &#125;
  oUl.innerHTML += str;
  console.timeEnd(&quot;innerHTML&quot;); // 0.52294921875 ms
&gt;&lt;/script&gt;
</code></pre>
<blockquote>
<blockquote>
<p>分析：以上代码中</p>
</blockquote>
<ul>
<li><code>innerHTML</code>的执行效率明显比<code>createElement</code>的方式要<strong>低很多</strong>，原因在于<ul>
<li>每次迭代都要设置一次 <code>innerHTML</code>，在设置 <code>innerHTML</code> 前还要先读取 <code>innerHTML</code>。而且每次读取和插入都是把之前的所有节点读取出来。</li>
<li>而 <code>createElement</code> 每次迭代，只是把新创建的元素插入到之前元素的后面。</li>
</ul>
</li>
<li>所以我们最后的优化版是通过一个字符串来拼接所有内容，然后再一次性的插入到页面中。</li>
</ul>
</blockquote>
<ol start="2">
<li><p>innerHTML、createElement 总结</p>
<table>
<thead>
<tr>
<th></th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>innerHTML</td>
<td>在操作时相对结构复杂，可读性不强，如果内容较<strong>少</strong>，可以使用，不过要注意把内容拼接成<strong>字符串</strong>，一次性插入到页面；同时，如果内容为用户输入时，要考虑<strong>安全问题</strong></td>
</tr>
<tr>
<td>createElement</td>
<td>创建元素相对复杂些，但可读性强，如果内容较<strong>多</strong>，建议使用这种方式</td>
</tr>
</tbody></table>
</li>
<li><p>innerHTML 安全问题</p>
<blockquote>
<ul>
<li>如果页面中需要提供<strong>用户输入的信息</strong>，那建议不要使用 <code>innerHTML</code>。因为有可能会造成<code>XSS攻击</code>。</li>
<li>所谓XSS攻击全称是<code>&#39;Cross Site Scripting&#39;</code>跨站脚本。</li>
<li>是指黑客往 HTML 文件中或者 DOM 中注入恶意脚本，从而在用户浏览页面时利用注入的恶意脚本对用户实施攻击的一种手段。<blockquote>
<p>2015 年喜马拉雅就被爆出了对应的<code>XSS 漏洞</code>，是因为用户在设置专辑名称时，服务器对关键字过滤不严格，可以将专辑名设置为一段 <code>Javascript</code>。</p>
</blockquote>
</li>
</ul>
</blockquote>
</li>
</ol>
<h4 id="删除节点"><a href="#删除节点" class="headerlink" title="删除节点"></a>删除节点</h4><blockquote>
<p>DOM 中删除一个子节点，<strong>返回</strong>删除的节点。</p>
<ul>
<li><code>var oldChild = node.removeChild(child);</code><ul>
<li><code>child</code> 是要移除的那个子节点。</li>
<li><code>node</code> 是<code>child</code>的父节点。</li>
<li><code>oldChild</code>保存对删除的子节点的引用。<code>oldChild === child</code><blockquote>
<p>注意：节点不能主动删除自己，必须由父节点删除它</p>
</blockquote>
</li>
</ul>
</li>
</ul>
</blockquote>
<pre><code>&gt;&lt;div class=&quot;box&quot;&gt;
&gt;  &lt;h3 class=&quot;title&quot;&gt;我是标题&lt;/h3&gt;
&gt;&lt;/div&gt;
&gt;&lt;script&gt;
  var box = document.querySelector(&quot;.box&quot;);
  var h3 = document.querySelector(&quot;.title&quot;);
&gt;
  // 删除h3标签，方法一:先找到父节点，然后删除其子节点
  // var _h3 = box.removeChild(h3);
  // console.log(_h3);
&gt;
  // 删除h3标签，方法二：通过自身调用parentNode，将自身删除
  h3.parentNode.removeChild(h3);
&gt;&lt;/script&gt;
</code></pre>
<blockquote>
<blockquote>
<p>更推荐使用<code>.parentNode</code>的方式找到父节点</p>
</blockquote>
</blockquote>
<blockquote>
<ul>
<li>删除一个元素的所有子节点</li>
</ul>
</blockquote>
<pre><code>&gt;&lt;ul class=&quot;list&quot;&gt;
&gt;  &lt;li&gt;1&lt;/li&gt;
&gt;  &lt;li&gt;2&lt;/li&gt;
&gt;  &lt;li&gt;3&lt;/li&gt;
&gt;  &lt;li&gt;4&lt;/li&gt;
&gt;  &lt;li&gt;5&lt;/li&gt;
&gt;  &lt;li&gt;6&lt;/li&gt;
&gt;  &lt;li&gt;7&lt;/li&gt;
&gt;&lt;/ul&gt;
&gt;
&gt;&lt;script&gt;
//方法1：
var oUl = document.querySelector(&quot;.list&quot;);
// 如果有第一个子元素，就将他给删除
// while (oUl.firstChild) &#123;
//   oUl.removeChild(oUl.firstChild);
// &#125;
&gt;
// 最简单的方法
oUl.innerHTML = &quot;&quot;;
&gt;&lt;/script&gt;
</code></pre>
<h4 id="节点的替换（修改）"><a href="#节点的替换（修改）" class="headerlink" title="节点的替换（修改）"></a>节点的替换（修改）</h4><blockquote>
<ul>
<li><code>replaceChild</code>方法用指定的节点替换当前节点的一个子节点，并返回被替换掉的节点</li>
<li><code>parentNode.replaceChild(newChild, oldChild);</code></li>
<li><code>newChild</code>：用来替换<code>oldChild</code>的新节点。如果该节点已经存在于 DOM 树中，则它首先会<strong>被从原始位置删除</strong>。</li>
<li><code>oldChild</code>： 被替换掉的原始节点。</li>
<li><code>parentNode</code>是<code>oldChild</code>的父节点</li>
</ul>
</blockquote>
<pre><code>&gt;&lt;ul&gt;
&gt;  &lt;li&gt;第一个li&lt;/li&gt;
&gt;  &lt;li&gt;第二个li&lt;/li&gt;
&gt;  &lt;li&gt;第三个li&lt;/li&gt;
&gt;  &lt;li&gt;第四个li&lt;/li&gt;
&gt;&lt;/ul&gt;
&gt;
&gt;&lt;script&gt;
  // 获取页面元素
  var oul = document.getElementsByTagName(&quot;ul&quot;)[0];
  //用最后一个元素替换新的元素
  var firstli = oul.children[0];
  var lastli = oul.children[3];
  oul.replaceChild(lastli, firstli);
&gt;
  // 创建新的元素来替换
  var oli = document.createElement(&quot;li&quot;);
  oli.innerHTML = &quot;&lt;p&gt;我是新创建的&lt;/p&gt;&quot;;
  oli.title = &quot;我是新创建的&quot;;
  oul.replaceChild(oli, oul.children[1]);
&gt;&lt;/script&gt;
</code></pre>
<ol start="2">
<li>案例：交换两个元素在节点中的位置（阿里面试题）</li>
</ol>
<ul>
<li>实现思路<blockquote>
<ul>
<li>假设要交换第 1 个 li和第 4 个 li</li>
<li>我们可以先创建一个新的节点 <code>newNode</code>，插入到第 1 个 li 前面，用来<strong>占位</strong>（记录第 1 个 li 的位置）</li>
<li>然后用第一个 li来<strong>替换</strong>第 4 个 li，在替换前，要先把第 4 个 li <strong>保存</strong>起来，供后面使用</li>
<li>最后用第 4 个 li来<strong>替换</strong>之前新创建的节点<code>newNode</code></li>
<li>如果传过来的节点中，有一个<strong>不存在</strong>，则返回<code>false</code> ，如果替换成功，则返回<code>true</code><blockquote>
<p>注意：<code>insertBefore</code> 和<code>replaceChild</code>的父级元素是被替换的元素</p>
</blockquote>
</li>
</ul>
</blockquote>
</li>
</ul>
<pre><code>&gt;&lt;div class=&quot;box&quot;&gt;box&lt;/div&gt;
&gt;&lt;ul class=&quot;list&quot;&gt;
&gt;  &lt;li&gt;第一个li&lt;/li&gt;
&gt;  &lt;li&gt;第二个li&lt;/li&gt;
&gt;  &lt;li&gt;第三个li&lt;/li&gt;
&gt;  &lt;li&gt;第四个li&lt;/li&gt;
&gt;&lt;/ul&gt;
&gt;
&gt;&lt;script&gt;
  function changeOfPosition(obj1, obj2) &#123;
    // 如果传过来的节点，有一个不存在，就不做任何操作
    if (!obj1 || !obj2) return false;
    // 首先创建一个新节点
    var newNode = document.createElement(&quot;div&quot;);
    // 把新创建的节点插入到 obj1的前面
    obj1.parentNode.insertBefore(newNode, obj1);
    // 用obj1替换obj2,返回obj2
    obj2.parentNode.replaceChild(obj1, obj2);
    // 用obj2替换newNode,为什么不用obj1的父级，而要用newNode
    // 在上面用obj1替换obj2了，所以obj1的父级此时变成了obj2的父级
    newNode.parentNode.replaceChild(obj2, newNode);
    return true;
  &#125;
&gt;
  var liList = document.querySelectorAll(&quot;.list li&quot;);
  var box = document.querySelector(&quot;.box&quot;);
  // 交换第1个和第3个元素位置
  changeOfPosition(box, liList[3]);
&gt;&lt;/script&gt;
</code></pre>
<h4 id="克隆节点"><a href="#克隆节点" class="headerlink" title="克隆节点"></a>克隆节点</h4><blockquote>
<ul>
<li><code>cloneNode</code>方法返回调用该方法的节点的一个<strong>副本</strong>。</li>
<li>也就是克隆节点，克隆出来的节点是 <strong>“孤儿节点”</strong>,只是存在内存中，没有插入页面</li>
<li><code>var dupNode = node.cloneNode(deep);</code></li>
<li><code>node</code>将要被克隆的节点</li>
<li><code>dupNode</code>克隆生成的副本节点</li>
<li><code>deep</code>是否采用深度克隆，可选参数<ul>
<li>如果为 true，则该节点里的所有后代节点也都会被克隆</li>
<li>如果为 false，则只克隆该节点本身(壳子)<blockquote>
<p>在早期规范中，<code>deep</code> 的默认值是 <code>true</code>，现在的新规范里，把默认值变成了 <code>false</code><br>所以考虑兼容问题，最好在克隆时把这个参数带上。</p>
</blockquote>
</li>
</ul>
</li>
</ul>
</blockquote>
<pre><code>&gt;&lt;div class=&quot;box&quot;&gt;
&gt;  &lt;ul&gt;
    &lt;li&gt;第一个li&lt;/li&gt;
    &lt;li&gt;第二个li&lt;/li&gt;
    &lt;li&gt;第三个li&lt;/li&gt;
    &lt;li&gt;第四个li&lt;/li&gt;
&gt;  &lt;/ul&gt;
&gt;&lt;/div&gt;
&gt;
&gt;&lt;script&gt;
  // 获取页面元素
  var box = document.getElementsByClassName(&quot;box&quot;);
  // var box2 = box[0].cloneNode(); // 浅克隆
  var box2 = box[0].cloneNode(false); // 浅克隆
  console.log(box2);
  var box3 = box[0].cloneNode(true); // 深克隆
  console.log(box3);
  document.body.appendChild(box2);
  document.body.appendChild(box3);
&gt;&lt;/script&gt;
</code></pre>
<blockquote>
<blockquote>
<p>温馨提示：</p>
<ul>
<li>如果克隆的节点，设置了<code>id名</code>，则克隆后要修改 id 的名字，确保 id 的<strong>唯一性</strong></li>
<li>克隆一个元素节点会拷贝它<strong>所有的属性以及属性值</strong>，当然也就包括了属性上绑定的事件（比如onclick&#x3D;”alert(1)”），但<strong>不会拷贝</strong>那些使用<code>addEventListener()</code>方法或者<code>node.onclick = fn</code>这种用<code>JavaScript</code>动态绑定的事件。</li>
</ul>
</blockquote>
</blockquote>
<h4 id="DocumentFragment"><a href="#DocumentFragment" class="headerlink" title="DocumentFragment"></a>DocumentFragment</h4><blockquote>
<ul>
<li><code>DocumentFragment</code>文档片段接口，表示一个<strong>没有父对象</strong>的最小文档对象。</li>
<li>它被作为一个<strong>轻量版</strong>的 <code>Document</code> 使用，就像标准的 <code>document</code> 一样，存储由<strong>节点（nodes）组成</strong>的文档结构。与 <code>document</code> 相比，<strong>最大的区别</strong>是它不是真实 DOM 树的一部分，它的变化<strong>不会触发</strong> DOM 树的重新渲染，且不会对<strong>性能</strong>产生影响。</li>
</ul>
</blockquote>
<blockquote>
<ul>
<li>他具有真实 DOM 的一切方法和属性，所以我们可以像操作真实 DOM 一样来操作他</li>
<li>你可以把他理解成<strong>虚拟节点对象</strong>，他的作用是充当其它要被添加到真实文档节点的<strong>仓库</strong>。而他自己永远不会被添加到真实的文档对中</li>
</ul>
</blockquote>
<pre><code>&gt;&lt;ul id=&quot;list&quot;&gt;&lt;/ul&gt;
&gt;&lt;script&gt;
  var oUl = document.getElementById(&quot;list&quot;);
  // 创建一个文档片段，此时还没有插入到真实DOM树中，其存在内存中
  var fragment = document.createDocumentFragment();
&gt;
  // for循环创建5个li，然后插入到ul中
  for (var i = 0; i &lt; 4; i++) &#123;
    var oLi = document.createElement(&quot;li&quot;);
    oLi.innerText = &quot;第&quot; + i + &quot;个li&quot;;
    // 将创建的DOM先放在文档片段中，这样就不会造成频繁的操作真实DOM
    fragment.appendChild(oLi);
  &#125;
  // 一次性将创建的5个oLi插入到真实的DOM树中
  oUl.appendChild(fragment);
&gt;&lt;/script&gt;
</code></pre>
<blockquote>
<blockquote>
<p>DocumentFragment 文档片段的主要功能：</p>
<ul>
<li>可以将频繁的 DOM 操作理改为<strong>一次性 DOM 操作</strong>，从而减少了页面的重排和重绘（减少 DOM 渲染的次数）</li>
</ul>
</blockquote>
</blockquote>

                
            </div>
            <hr/>

            

    <div class="reprint" id="reprint-statement">
        
            <div class="reprint__author">
                <span class="reprint-meta" style="font-weight: bold;">
                    <i class="fas fa-user">
                        文章作者:
                    </i>
                </span>
                <span class="reprint-info">
                    <a href="/about" rel="external nofollow noreferrer">hermia</a>
                </span>
            </div>
            <div class="reprint__type">
                <span class="reprint-meta" style="font-weight: bold;">
                    <i class="fas fa-link">
                        文章链接:
                    </i>
                </span>
                <span class="reprint-info">
                    <a href="https://hermiablog.github.io/2023/12/05/JS%E6%A0%B8%E5%BF%83%E7%9F%A5%E8%AF%86%E7%82%B9%EF%BC%88%E4%B9%9D%EF%BC%89/">https://hermiablog.github.io/2023/12/05/JS%E6%A0%B8%E5%BF%83%E7%9F%A5%E8%AF%86%E7%82%B9%EF%BC%88%E4%B9%9D%EF%BC%89/</a>
                </span>
            </div>
            <div class="reprint__notice">
                <span class="reprint-meta" style="font-weight: bold;">
                    <i class="fas fa-copyright">
                        版权声明:
                    </i>
                </span>
                <span class="reprint-info">
                    本博客所有文章除特別声明外，均采用
                    <a href="https://creativecommons.org/licenses/by/4.0/deed.zh" rel="external nofollow noreferrer" target="_blank">CC BY 4.0</a>
                    许可协议。转载请注明来源
                    <a href="/about" target="_blank">hermia</a>
                    !
                </span>
            </div>
        
    </div>

    <script async defer>
      document.addEventListener("copy", function (e) {
        let toastHTML = '<span>复制成功，请遵循本文的转载规则</span><button class="btn-flat toast-action" onclick="navToReprintStatement()" style="font-size: smaller">查看</a>';
        M.toast({html: toastHTML})
      });

      function navToReprintStatement() {
        $("html, body").animate({scrollTop: $("#reprint-statement").offset().top - 80}, 800);
      }
    </script>



            <div class="tag_share" style="display: block;">
                <div class="post-meta__tag-list" style="display: inline-block;">
                    
                        <div class="article-tag">
                            
                                <a href="/tags/JS/">
                                    <span class="chip bg-color">JS</span>
                                </a>
                            
                        </div>
                    
                </div>
                <div class="post_share" style="zoom: 80%; width: fit-content; display: inline-block; float: right; margin: -0.15rem 0;">
                    <link rel="stylesheet" type="text/css" href="/libs/share/css/share.min.css">
<div id="article-share">

    
    <div class="social-share" data-sites="qq,qzone,wechat,weibo" data-wechat-qrcode-helper="<p>微信扫一扫即可分享！</p>"></div>
    <script src="/libs/share/js/social-share.min.js"></script>
    

    

</div>

                </div>
            </div>
            
                <style>
    #reward {
        margin: 40px 0;
        text-align: center;
    }

    #reward .reward-link {
        font-size: 1.4rem;
        line-height: 38px;
    }

    #reward .btn-floating:hover {
        box-shadow: 0 6px 12px rgba(0, 0, 0, 0.2), 0 5px 15px rgba(0, 0, 0, 0.2);
    }

    #rewardModal {
        width: 320px;
        height: 350px;
    }

    #rewardModal .reward-title {
        margin: 15px auto;
        padding-bottom: 5px;
    }

    #rewardModal .modal-content {
        padding: 10px;
    }

    #rewardModal .close {
        position: absolute;
        right: 15px;
        top: 15px;
        color: rgba(0, 0, 0, 0.5);
        font-size: 1.3rem;
        line-height: 20px;
        cursor: pointer;
    }

    #rewardModal .close:hover {
        color: #ef5350;
        transform: scale(1.3);
        -moz-transform:scale(1.3);
        -webkit-transform:scale(1.3);
        -o-transform:scale(1.3);
    }

    #rewardModal .reward-tabs {
        margin: 0 auto;
        width: 210px;
    }

    .reward-tabs .tabs {
        height: 38px;
        margin: 10px auto;
        padding-left: 0;
    }

    .reward-content ul {
        padding-left: 0 !important;
    }

    .reward-tabs .tabs .tab {
        height: 38px;
        line-height: 38px;
    }

    .reward-tabs .tab a {
        color: #fff;
        background-color: #ccc;
    }

    .reward-tabs .tab a:hover {
        background-color: #ccc;
        color: #fff;
    }

    .reward-tabs .wechat-tab .active {
        color: #fff !important;
        background-color: #22AB38 !important;
    }

    .reward-tabs .alipay-tab .active {
        color: #fff !important;
        background-color: #019FE8 !important;
    }

    .reward-tabs .reward-img {
        width: 210px;
        height: 210px;
    }
</style>

<div id="reward">
    <a href="#rewardModal" class="reward-link modal-trigger btn-floating btn-medium waves-effect waves-light red">赏</a>

    <!-- Modal Structure -->
    <div id="rewardModal" class="modal">
        <div class="modal-content">
            <a class="close modal-close"><i class="fas fa-times"></i></a>
            <h4 class="reward-title">你的赏识是我前进的动力</h4>
            <div class="reward-content">
                <div class="reward-tabs">
                    <ul class="tabs row">
                        <li class="tab col s6 alipay-tab waves-effect waves-light"><a href="#alipay">支付宝</a></li>
                        <li class="tab col s6 wechat-tab waves-effect waves-light"><a href="#wechat">微 信</a></li>
                    </ul>
                    <div id="alipay">
                        <img src="/medias/reward/alipay.jpg" class="reward-img" alt="支付宝打赏二维码">
                    </div>
                    <div id="wechat">
                        <img src="/medias/reward/wechat.png" class="reward-img" alt="微信打赏二维码">
                    </div>
                </div>
            </div>
        </div>
    </div>
</div>

<script>
    $(function () {
        $('.tabs').tabs();
    });
</script>

            
        </div>
    </div>

    

    

    

    

    

    

    

    

<article id="prenext-posts" class="prev-next articles">
    <div class="row article-row">
        
        <div class="article col s12 m6" data-aos="fade-up">
            <div class="article-badge left-badge text-color">
                <i class="fas fa-chevron-left"></i>&nbsp;上一篇</div>
            <div class="card">
                <a href="/2023/12/05/JS%E6%A0%B8%E5%BF%83%E7%9F%A5%E8%AF%86%E7%82%B9%EF%BC%88%E5%8D%81%EF%BC%89/">
                    <div class="card-image">
                        
                        <img src="/medias/featureimages/20.jpg" class="responsive-img" alt="JS核心知识点（十）">
                        
                        <span class="card-title">JS核心知识点（十）</span>
                    </div>
                </a>
                <div class="card-content article-content">
                    <div class="summary block-with-text">
                        
                            JS DOM 事件，事件流，事件对象，事件委托
                        
                    </div>
                    <div class="publish-info">
                        <span class="publish-date">
                            <i class="far fa-clock fa-fw icon-date"></i>2023-12-05
                        </span>
                        <span class="publish-author">
                            
                            <i class="fas fa-bookmark fa-fw icon-category"></i>
                            
                            <a href="/categories/%E6%8A%80%E6%9C%AF/" class="post-category">
                                    技术
                                </a>
                            
                            
                        </span>
                    </div>
                </div>
                
                <div class="card-action article-tags">
                    
                    <a href="/tags/JS/">
                        <span class="chip bg-color">JS</span>
                    </a>
                    
                </div>
                
            </div>
        </div>
        
        
        <div class="article col s12 m6" data-aos="fade-up">
            <div class="article-badge right-badge text-color">
                下一篇&nbsp;<i class="fas fa-chevron-right"></i>
            </div>
            <div class="card">
                <a href="/2023/12/05/JS%E6%A0%B8%E5%BF%83%E7%9F%A5%E8%AF%86%E7%82%B9%EF%BC%88%E5%85%AB%EF%BC%89/">
                    <div class="card-image">
                        
                        <img src="/medias/featureimages/18.jpg" class="responsive-img" alt="JS核心知识点（八）">
                        
                        <span class="card-title">JS核心知识点（八）</span>
                    </div>
                </a>
                <div class="card-content article-content">
                    <div class="summary block-with-text">
                        
                            JS面向对象，原型和原型链
                        
                    </div>
                    <div class="publish-info">
                            <span class="publish-date">
                                <i class="far fa-clock fa-fw icon-date"></i>2023-12-05
                            </span>
                        <span class="publish-author">
                            
                            <i class="fas fa-bookmark fa-fw icon-category"></i>
                            
                            <a href="/categories/%E6%8A%80%E6%9C%AF/" class="post-category">
                                    技术
                                </a>
                            
                            
                        </span>
                    </div>
                </div>
                
                <div class="card-action article-tags">
                    
                    <a href="/tags/JS/">
                        <span class="chip bg-color">JS</span>
                    </a>
                    
                </div>
                
            </div>
        </div>
        
    </div>
</article>

</div>



<!-- 代码块功能依赖 -->
<script type="text/javascript" src="/libs/codeBlock/codeBlockFuction.js"></script>

<!-- 代码语言 -->

<script type="text/javascript" src="/libs/codeBlock/codeLang.js"></script>


<!-- 代码块复制 -->

<script type="text/javascript" src="/libs/codeBlock/codeCopy.js"></script>


<!-- 代码块收缩 -->

<script type="text/javascript" src="/libs/codeBlock/codeShrink.js"></script>


  </div>
  <div id="toc-aside" class="expanded col l3 hide-on-med-and-down">
    <div class="toc-widget card" style="background-color: white">
      <div class="toc-title">
        <i class="far fa-list-alt"></i>&nbsp;&nbsp;目录
      </div>
      <div id="toc-content"></div>
    </div>
  </div>
</div>

<!-- TOC 悬浮按钮. -->

<div id="floating-toc-btn" class="hide-on-med-and-down">
  <a class="btn-floating btn-large bg-color">
    <i class="fas fa-list-ul"></i>
  </a>
</div>


<script src="/libs/tocbot/tocbot.min.js"></script>
<script>
  $(function () {
      tocbot.init({
          tocSelector: '#toc-content',
          contentSelector: '#articleContent',
          headingsOffset: -($(window).height() * 0.4 - 45),
          collapseDepth: Number('0'),
          headingSelector: 'h2, h3, h4'
      });

      // modify the toc link href to support Chinese.
      let i = 0;
      let tocHeading = 'toc-heading-';
      $('#toc-content a').each(function () {
          $(this).attr('href', '#' + tocHeading + (++i));
      });

      // modify the heading title id to support Chinese.
      i = 0;
      $('#articleContent').children('h2, h3, h4').each(function () {
          $(this).attr('id', tocHeading + (++i));
      });

      // Set scroll toc fixed.
      let tocHeight = parseInt($(window).height() * 0.4 - 64);
      let $tocWidget = $('.toc-widget');
      $(window).scroll(function () {
          let scroll = $(window).scrollTop();
          /* add post toc fixed. */
          if (scroll > tocHeight) {
              $tocWidget.addClass('toc-fixed');
          } else {
              $tocWidget.removeClass('toc-fixed');
          }
      });

      
      /* 修复文章卡片 div 的宽度. */
      let fixPostCardWidth = function (srcId, targetId) {
          let srcDiv = $('#' + srcId);
          if (srcDiv.length === 0) {
              return;
          }

          let w = srcDiv.width();
          if (w >= 450) {
              w = w + 21;
          } else if (w >= 350 && w < 450) {
              w = w + 18;
          } else if (w >= 300 && w < 350) {
              w = w + 16;
          } else {
              w = w + 14;
          }
          $('#' + targetId).width(w);
      };

      // 切换TOC目录展开收缩的相关操作.
      const expandedClass = 'expanded';
      let $tocAside = $('#toc-aside');
      let $mainContent = $('#main-content');
      $('#floating-toc-btn .btn-floating').click(function () {
          if ($tocAside.hasClass(expandedClass)) {
              $tocAside.removeClass(expandedClass).hide();
              $mainContent.removeClass('l9');
          } else {
              $tocAside.addClass(expandedClass).show();
              $mainContent.addClass('l9');
          }
          fixPostCardWidth('artDetail', 'prenext-posts');
      });
      
  });
</script>

    

</main>




    <footer class="page-footer bg-color">
   <link rel="stylesheet" href="/libs/aplayer/APlayer.min.css">
<style>
    .aplayer .aplayer-lrc p {
        
        font-size: 12px;
        font-weight: 700;
        line-height: 16px !important;
    }

    .aplayer .aplayer-lrc p.aplayer-lrc-current {
        
        font-size: 15px;
        color: #a3ddf0;
        /* color: #59cde9; */
    }

    
    .aplayer.aplayer-fixed.aplayer-narrow .aplayer-body {
        left: -66px !important;
    }

    .aplayer.aplayer-fixed.aplayer-narrow .aplayer-body:hover {
        left: 0px !important;
    }

    
</style>
<div class="">
    
    <div class="row">
        <meting-js class="col l8 offset-l2 m10 offset-m1 s12"
                   server="netease"
                   type="playlist"
                   id="2450546498"
                   fixed='true'
                   autoplay='false'
                   theme='#59cde9'
                   loop='all'
                   order='random'
                   preload='auto'
                   volume='0.7'
                   list-folded='true'
        >
        </meting-js>
    </div>
</div>

<script src="/libs/aplayer/APlayer.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/meting@2/dist/Meting.min.js"></script>
 
  <div
    class="container row center-align"
    style="margin-bottom: 15px !important;"
  >
    <div class="col s12 m8 l8 copy-right">
      Copyright&nbsp;&copy; 
      <span id="year">2023</span>
      
      <span id="year">2023</span>
      <a href="/about" target="_blank"
        >hermia</a
      >
      |&nbsp;Powered by&nbsp;<a href="https://hexo.io/" target="_blank">Hexo</a>
      |&nbsp;Theme&nbsp;<a
        href="https://github.com/blinkfox/hexo-theme-matery"
        target="_blank"
        >Matery</a
      >
      <br />
           
      <span id="busuanzi_container_site_pv">
        |&nbsp;<i class="far fa-eye"></i>&nbsp;总访问量:&nbsp;<span
          id="busuanzi_value_site_pv"
          class="white-color"
        ></span
        >&nbsp;次
      </span>
       
      <span id="busuanzi_container_site_uv">
        |&nbsp;<i class="fas fa-users"></i>&nbsp;总访问人数:&nbsp;<span
          id="busuanzi_value_site_uv"
          class="white-color"
        ></span
        >&nbsp;人
      </span>
      
      <br />
      
      <span id="sitetime">载入运行时间...</span>
      <script>
        function siteTime() {
          var seconds = 1000;
          var minutes = seconds * 60;
          var hours = minutes * 60;
          var days = hours * 24;
          var years = days * 365;
          var today = new Date();
          var startYear = "2023";
          var startMonth = "11";
          var startDate = "14";
          var startHour = "0";
          var startMinute = "0";
          var startSecond = "0";
          var todayYear = today.getFullYear();
          var todayMonth = today.getMonth() + 1;
          var todayDate = today.getDate();
          var todayHour = today.getHours();
          var todayMinute = today.getMinutes();
          var todaySecond = today.getSeconds();
          var t1 = Date.UTC(
            startYear,
            startMonth,
            startDate,
            startHour,
            startMinute,
            startSecond
          );
          var t2 = Date.UTC(
            todayYear,
            todayMonth,
            todayDate,
            todayHour,
            todayMinute,
            todaySecond
          );
          var diff = t2 - t1;
          var diffYears = Math.floor(diff / years);
          var diffDays = Math.floor(diff / days - diffYears * 365);
          var diffHours = Math.floor(
            (diff - (diffYears * 365 + diffDays) * days) / hours
          );
          var diffMinutes = Math.floor(
            (diff - (diffYears * 365 + diffDays) * days - diffHours * hours) /
              minutes
          );
          var diffSeconds = Math.floor(
            (diff -
              (diffYears * 365 + diffDays) * days -
              diffHours * hours -
              diffMinutes * minutes) /
              seconds
          );
          if (startYear == todayYear) {
            document.getElementById("year").innerHTML = todayYear;
            document.getElementById("sitetime").innerHTML =
              "本站已安全运行 " +
              diffDays +
              " 天 " +
              diffHours +
              " 小时 " +
              diffMinutes +
              " 分钟 " +
              diffSeconds +
              " 秒";
          } else {
            document.getElementById("year").innerHTML =
              startYear + " - " + todayYear;
            document.getElementById("sitetime").innerHTML =
              "本站已安全运行 " +
              diffYears +
              " 年 " +
              diffDays +
              " 天 " +
              diffHours +
              " 小时 " +
              diffMinutes +
              " 分钟 " +
              diffSeconds +
              " 秒";
          }
        }
        setInterval(siteTime, 1000);
      </script>
      
      <br />
      
    </div>
    <div class="col s12 m4 l4 social-link social-statis">
      
<a
  href="https://github.com/hermiablog/hermiablog.github.io"
  class="tooltipped"
  target="_blank"
  data-tooltip="访问我的GitHub"
  data-position="top"
  data-delay="50"
>
  <i class="fab fa-github"></i>
</a>
 
<a
  href="mailto:1587837237@qq.com"
  class="tooltipped"
  target="_blank"
  data-tooltip="邮件联系我"
  data-position="top"
  data-delay="50"
>
  <i class="fas fa-envelope-open"></i>
</a>
<!-- 
   
<a
  href="tencent://AddContact/?fromId=50&fromSubId=1&subcmd=all&uin=1587837237"
  class="tooltipped"
  target="_blank"
  data-tooltip="QQ联系我: 1587837237"
  data-position="top"
  data-delay="50"
>
  <i class="fab fa-qq"></i>
</a>
    -->

    </div>
  </div>
</footer>

<div class="progress-bar"></div>


    <!-- 搜索遮罩框 -->
<div id="searchModal" class="modal">
    <div class="modal-content">
        <div class="search-header">
            <span class="title"><i class="fas fa-search"></i>&nbsp;&nbsp;搜索</span>
            <input type="search" id="searchInput" name="s" placeholder="请输入搜索的关键字"
                   class="search-input">
        </div>
        <div id="searchResult"></div>
    </div>
</div>

<script type="text/javascript">
$(function () {
    var searchFunc = function (path, search_id, content_id) {
        'use strict';
        $.ajax({
            url: path,
            dataType: "xml",
            success: function (xmlResponse) {
                // get the contents from search data
                var datas = $("entry", xmlResponse).map(function () {
                    return {
                        title: $("title", this).text(),
                        content: $("content", this).text(),
                        url: $("url", this).text()
                    };
                }).get();
                var $input = document.getElementById(search_id);
                var $resultContent = document.getElementById(content_id);
                $input.addEventListener('input', function () {
                    var str = '<ul class=\"search-result-list\">';
                    var keywords = this.value.trim().toLowerCase().split(/[\s\-]+/);
                    $resultContent.innerHTML = "";
                    if (this.value.trim().length <= 0) {
                        return;
                    }
                    // perform local searching
                    datas.forEach(function (data) {
                        var isMatch = true;
                        var data_title = data.title.trim().toLowerCase();
                        var data_content = data.content.trim().replace(/<[^>]+>/g, "").toLowerCase();
                        var data_url = data.url;
                        data_url = data_url.indexOf('/') === 0 ? data.url : '/' + data_url;
                        var index_title = -1;
                        var index_content = -1;
                        var first_occur = -1;
                        // only match artiles with not empty titles and contents
                        if (data_title !== '' && data_content !== '') {
                            keywords.forEach(function (keyword, i) {
                                index_title = data_title.indexOf(keyword);
                                index_content = data_content.indexOf(keyword);
                                if (index_title < 0 && index_content < 0) {
                                    isMatch = false;
                                } else {
                                    if (index_content < 0) {
                                        index_content = 0;
                                    }
                                    if (i === 0) {
                                        first_occur = index_content;
                                    }
                                }
                            });
                        }
                        // show search results
                        if (isMatch) {
                            str += "<li><a href='" + data_url + "' class='search-result-title'>" + data_title + "</a>";
                            var content = data.content.trim().replace(/<[^>]+>/g, "");
                            if (first_occur >= 0) {
                                // cut out 100 characters
                                var start = first_occur - 20;
                                var end = first_occur + 80;
                                if (start < 0) {
                                    start = 0;
                                }
                                if (start === 0) {
                                    end = 100;
                                }
                                if (end > content.length) {
                                    end = content.length;
                                }
                                var match_content = content.substr(start, end);
                                // highlight all keywords
                                keywords.forEach(function (keyword) {
                                    var regS = new RegExp(keyword, "gi");
                                    match_content = match_content.replace(regS, "<em class=\"search-keyword\">" + keyword + "</em>");
                                });

                                str += "<p class=\"search-result\">" + match_content + "...</p>"
                            }
                            str += "</li>";
                        }
                    });
                    str += "</ul>";
                    $resultContent.innerHTML = str;
                });
            }
        });
    };

    searchFunc('/search.xml', 'searchInput', 'searchResult');
});
</script>

    <!-- 回到顶部按钮 -->
<div id="backTop" class="top-scroll">
    <a class="btn-floating btn-large waves-effect waves-light" href="#!">
        <i class="fas fa-arrow-up"></i>
    </a>
</div>


    <script src="/libs/materialize/materialize.min.js"></script>
    <script src="/libs/masonry/masonry.pkgd.min.js"></script>
    <script src="/libs/aos/aos.js"></script>
    <script src="/libs/scrollprogress/scrollProgress.min.js"></script>
    <script src="/libs/lightGallery/js/lightgallery-all.min.js"></script>
    <script src="/js/matery.js"></script>

    <!-- Baidu Analytics -->

    <!-- Baidu Push -->

<script>
    (function () {
        var bp = document.createElement('script');
        var curProtocol = window.location.protocol.split(':')[0];
        if (curProtocol === 'https') {
            bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';
        } else {
            bp.src = 'http://push.zhanzhang.baidu.com/push.js';
        }
        var s = document.getElementsByTagName("script")[0];
        s.parentNode.insertBefore(bp, s);
    })();
</script>

    
    <script src="/libs/others/clicklove.js" async="async"></script>
    
    
    <script async src="/libs/others/busuanzi.pure.mini.js"></script>
    

    

    

	
    

    

    

    
    <script src="/libs/instantpage/instantpage.js" type="module"></script>
    

</body>

</html>
