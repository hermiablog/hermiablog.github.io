<!DOCTYPE HTML>
<html lang="zh-CN">


<head>
    <meta charset="utf-8">
    <meta name="keywords" content="JS核心知识点（十一）, 技术博客">
    <meta name="description" content="个人技术博客">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <meta name="renderer" content="webkit|ie-stand|ie-comp">
    <meta name="mobile-web-app-capable" content="yes">
    <meta name="format-detection" content="telephone=no">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <!-- Global site tag (gtag.js) - Google Analytics -->


    <title>JS核心知识点（十一） | hermia&#39;s blog</title>
    <link rel="icon" type="image/png" href="/favicon.png">

    <link rel="stylesheet" type="text/css" href="/libs/awesome/css/all.css">
    <link rel="stylesheet" type="text/css" href="/libs/materialize/materialize.min.css">
    <link rel="stylesheet" type="text/css" href="/libs/aos/aos.css">
    <link rel="stylesheet" type="text/css" href="/libs/animate/animate.min.css">
    <link rel="stylesheet" type="text/css" href="/libs/lightGallery/css/lightgallery.min.css">
    <link rel="stylesheet" type="text/css" href="/css/matery.css">
    <link rel="stylesheet" type="text/css" href="/css/my.css">

    <script src="/libs/jquery/jquery.min.js"></script>

<meta name="generator" content="Hexo 6.3.0"><link rel="stylesheet" href="/css/prism-tomorrow.css" type="text/css"></head>



   <style>
    body{
       background-image: url(https://cdn.pixabay.com/photo/2012/04/14/16/37/sky-34536_1280.png);
       background-repeat:no-repeat;
       background-size:cover;
       background-attachment:fixed;
    }
</style>



<body>
    <header class="navbar-fixed">
    <nav id="headNav" class="bg-color nav-transparent">
        <div id="navContainer" class="nav-wrapper container">
            <div class="brand-logo">
                <a href="/" class="waves-effect waves-light">
                    
                    <img src="/medias/logo.png" class="logo-img" alt="LOGO">
                    
                    <span class="logo-span">hermia&#39;s blog</span>
                </a>
            </div>
            

<a href="#" data-target="mobile-nav" class="sidenav-trigger button-collapse"><i class="fas fa-bars"></i></a>
<ul class="right nav-menu">
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/" class="waves-effect waves-light">
      
      <i class="fas fa-home" style="zoom: 0.6;"></i>
      
      <span>首页</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/tags" class="waves-effect waves-light">
      
      <i class="fas fa-tags" style="zoom: 0.6;"></i>
      
      <span>标签</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/categories" class="waves-effect waves-light">
      
      <i class="fas fa-bookmark" style="zoom: 0.6;"></i>
      
      <span>分类</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/archives" class="waves-effect waves-light">
      
      <i class="fas fa-archive" style="zoom: 0.6;"></i>
      
      <span>归档</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/about" class="waves-effect waves-light">
      
      <i class="fas fa-user-circle" style="zoom: 0.6;"></i>
      
      <span>关于</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/friends" class="waves-effect waves-light">
      
      <i class="fas fa-address-book" style="zoom: 0.6;"></i>
      
      <span>友情链接</span>
    </a>
    
  </li>
  
  <li>
    <a href="#searchModal" class="modal-trigger waves-effect waves-light">
      <i id="searchIcon" class="fas fa-search" title="搜索" style="zoom: 0.85;"></i>
    </a>
  </li>
</ul>


<div id="mobile-nav" class="side-nav sidenav">

    <div class="mobile-head bg-color">
        
        <img src="/medias/logo.png" class="logo-img circle responsive-img">
        
        <div class="logo-name">hermia&#39;s blog</div>
        <div class="logo-desc">
            
            个人技术博客
            
        </div>
    </div>

    

    <ul class="menu-list mobile-menu-list">
        
        <li class="m-nav-item">
	  
		<a href="/" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-home"></i>
			
			首页
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/tags" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-tags"></i>
			
			标签
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/categories" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-bookmark"></i>
			
			分类
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/archives" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-archive"></i>
			
			归档
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/about" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-user-circle"></i>
			
			关于
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/friends" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-address-book"></i>
			
			友情链接
		</a>
          
        </li>
        
        
    </ul>
</div>


        </div>

        
    </nav>

</header>

    



<div class="bg-cover pd-header post-cover" style="background-image: url('/medias/featureimages/21.jpg')">
    <div class="container" style="right: 0px;left: 0px;">
        <div class="row">
            <div class="col s12 m12 l12">
                <div class="brand">
                    <h1 class="description center-align post-title">JS核心知识点（十一）</h1>
                </div>
            </div>
        </div>
    </div>
</div>




<main class="post-container content">

    
    <link
  rel="stylesheet"
  href="/libs/tocbot/tocbot.css"
/>
<style>
  #articleContent h1::before,
  #articleContent h2::before,
  #articleContent h3::before,
  #articleContent h4::before,
  #articleContent h5::before,
  #articleContent h6::before {
    display: block;
    content: " ";
    height: 100px;
    margin-top: -100px;
    visibility: hidden;
  }

  #articleContent :focus {
    outline: none;
  }

  .toc-fixed {
    position: fixed;
    top: 64px;
  }

  /* .toc-widget {
        width: 345px;
        padding-left: 20px;
    } */
  .toc-widget {
    width: 345px;
    padding-left: 20px;
    background-color: rgb(255, 255, 255, 0.7);
    border-radius: 10px;
    box-shadow: 0 10px 35px 2px rgba(0, 0, 0, 0.15),
      0 5px 15px rgba(0, 0, 0, 0.07), 0 2px 5px -5px rgba(0, 0, 0, 0.1) !important;
  }

  .toc-widget .toc-title {
    padding: 35px 0 15px 17px;
    font-size: 1.5rem;
    font-weight: bold;
    line-height: 1.5rem;
  }

  .toc-widget ol {
    padding: 0;
    list-style: none;
  }

  #toc-content {
    padding-bottom: 30px;
    overflow: auto;
  }

  #toc-content ol {
    padding-left: 10px;
  }

  #toc-content ol li {
    padding-left: 10px;
  }

  #toc-content .toc-link:hover {
    color: #a3ddf0;
    font-weight: 700;
    text-decoration: underline;
  }

  #toc-content .toc-link::before {
    background-color: transparent;
    max-height: 25px;

    position: absolute;
    right: 23.5vw;
    display: block;
  }

  #toc-content .is-active-link {
    color: #a3ddf0;
  }

  #floating-toc-btn {
    position: fixed;
    right: 15px;
    bottom: 76px;
    padding-top: 15px;
    margin-bottom: 0;
    z-index: 998;
  }

  #floating-toc-btn .btn-floating {
    width: 48px;
    height: 48px;
  }

  #floating-toc-btn .btn-floating i {
    line-height: 48px;
    font-size: 1.4rem;
  }
</style>
<div class="row">
  <div id="main-content" class="col s12 m12 l9">
    <!-- 文章内容详情 -->
<div id="artDetail">
    <div class="card">
        <div class="card-content article-info">
            <div class="row tag-cate">
                <div class="col s7">
                    
                    <div class="article-tag">
                        
                            <a href="/tags/JS/">
                                <span class="chip bg-color">JS</span>
                            </a>
                        
                    </div>
                    
                </div>
                <div class="col s5 right-align">
                    
                    <div class="post-cate">
                        <i class="fas fa-bookmark fa-fw icon-category"></i>
                        
                            <a href="/categories/%E6%8A%80%E6%9C%AF/" class="post-category">
                                技术
                            </a>
                        
                    </div>
                    
                </div>
            </div>

            <div class="post-info">
                
                <div class="post-date info-break-policy">
                    <i class="far fa-calendar-minus fa-fw"></i>发布日期:&nbsp;&nbsp;
                    2023-12-07
                </div>
                

                
                <div class="post-date info-break-policy">
                    <i class="far fa-calendar-check fa-fw"></i>更新日期:&nbsp;&nbsp;
                    2023-12-18
                </div>
                

                
                <div class="info-break-policy">
                    <i class="far fa-file-word fa-fw"></i>文章字数:&nbsp;&nbsp;
                    35.9k
                </div>
                

                

                
            </div>
        </div>
        <hr class="clearfix">

        

        

        <div class="card-content article-card-content">
            <div id="articleContent">
                <span id="more"></span>
<h3 id="一、定时器与延时器"><a href="#一、定时器与延时器" class="headerlink" title="一、定时器与延时器"></a>一、定时器与延时器</h3><h4 id="setInterval-与-clearInterval"><a href="#setInterval-与-clearInterval" class="headerlink" title="setInterval() 与 clearInterval()"></a>setInterval() 与 clearInterval()</h4><blockquote>
<ul>
<li><code>setInterval()</code>方法设置一个定时器，每间隔相同的一段时间，重复调用一个函数或执行一个代码片段</li>
<li>清除定时器：<code>clearInterval()</code> 函数可以清除一个定时器</li>
</ul>
</blockquote>
<pre><code>// 基本语法
var timer = setInterval(funtion, delay, arg1, arg2, arg3);
</code></pre>
<blockquote>
<ul>
<li>function：这个参数是一个<strong>函数</strong>，每经过指定 <code>delay</code> 毫秒后执行一次。第一次调用发生在 <code>delay</code> 毫秒之后。</li>
<li>delay：表示定时器延迟的时间，<strong>以毫秒为单位</strong>，1 秒等于 1000 毫秒</li>
<li>arg1…arg3：每次定时器到指定时间，要执行 function 函数前，这些参数会被当成 function 的参数传递给 function</li>
<li>timer：表示延时器的<strong>返回值</strong>，返回值是一个<strong>正整数</strong>，表示定时器的编号，这个值可以传递给<code>clearInterval()</code>来取消该定时器</li>
</ul>
</blockquote>
<pre><code>&gt;&lt;button&gt;点击结束&lt;/button&gt;
&gt;&lt;script&gt;
  //不传参数
  var timer1 = setInterval(function () &#123;
    console.log(1);
  &#125;, 1000);
  //传参
  var timer2 = setInterval(
    function (a, b) &#123;
        console.log(a, b);
    &#125;,
    1000,
    5,
    10
  );
&gt;
  //具名函数也可以传入setInterval
  var a = 0;
  function fun() &#123;
    console.log(++a);
  &#125;
  // 具名函数当做第一个参数，注意：fun这里没有圆括号
  setInterval(fun, 1000);
&gt;
  //直接使用一段代码代替函数，类似eval,慎用
  var timer3 = setInterval(&quot;console.log(1)&quot;, 1000);
&gt;
  //取消定时器
  var button = document.querySelector(&quot;button&quot;);
  button.onclick = function () &#123;
    clearInterval(timer3);
  &#125;;
&gt;
  //注意
  var a = 0;
  var timer1 = setInterval(function () &#123;
    a++;
    console.log(a);
    if (a === 3) &#123;
      clearInterval(timer1);
    &#125;
    console.log(&quot;ss&quot;);
    console.log(&quot;aa&quot;);
  &#125;, 1000);
  //1 ss aa
  //2 ss aa
  //3 ss aa
&gt;&lt;/script&gt;
</code></pre>
<blockquote>
<blockquote>
<p>注意：</p>
</blockquote>
<ul>
<li>取消定时器<strong>不意味</strong>着马上停止所有行为(即打印出3就退出去)</li>
<li>它会把这一轮进行完(后面的”ss”、”aa”会被打印出来)</li>
<li>具名函数当做第一个参数时，注意：没有圆括号</li>
</ul>
</blockquote>
<ul>
<li>案例：计时器功能<blockquote>
<ul>
<li>开始按钮，暂停按钮</li>
<li>注意在每次点击开始后，先清除计算器，以避免定时器叠加（当我们不停点击开始按钮时，就能看到），但这不代表清零</li>
</ul>
</blockquote>
</li>
</ul>
<pre><code>&gt;&lt;button id=&quot;start&quot;&gt;开始&lt;/button&gt;
&gt;&lt;div class=&quot;time&quot;&gt;&lt;/div&gt;
&gt;&lt;button id=&quot;pause&quot;&gt;暂停&lt;/button&gt;
&gt;&lt;script&gt;
  var start = document.getElementById(&quot;start&quot;);
  var pause = document.getElementById(&quot;pause&quot;);
  var time = document.querySelector(&quot;.time&quot;);
  var timer = null; //初始化计时器
  var sum = 0;
  start.onclick = function () &#123;
    //为了防止定时器叠加，应在开始前清除计时器
    clearInterval(timer);
     timer = setInterval(function () &#123;
      time.innerText = ++sum + &quot;秒&quot;;
    &#125;, 1000);
  &#125;;
  pause.onclick = function () &#123;
    clearInterval(timer);
  &#125;;
&gt;&lt;/script&gt;
</code></pre>
<h4 id="setTimeout-与-clearTimeout"><a href="#setTimeout-与-clearTimeout" class="headerlink" title="setTimeout() 与 clearTimeout()"></a>setTimeout() 与 clearTimeout()</h4><blockquote>
<ul>
<li><code>setTimeout()</code>方法设置一个延时器，该延时器在定时器到期后执行一个函数或指定的一段代码。</li>
<li><code>clearTimeout()</code>用来取消一个延时器<blockquote>
<p>注意：当指定时间到了之后，会执行函数<strong>一次</strong>，不再重复执行</p>
</blockquote>
</li>
<li>语法</li>
</ul>
</blockquote>
<pre><code>// 设置一个定时器
var timer = setTimeout(funtion, delay, arg1, arg2, arg3);
// 清除一个定时器
cleartTimeout(timer);
</code></pre>
<blockquote>
<ul>
<li><code>delay</code> ：表示定时器延迟的时间，以毫秒为位，1 秒等于 <code>1000</code> 毫秒</li>
<li><code>function</code> 这个参数是一个函数，当延时器延迟时间<code>delay</code>到期后，就会执行这个函数</li>
<li><code>arg1...arg3</code>等：附加参数，一旦定时器到期，它们会作为参数传递给 <code>function</code> ，<code>ie</code>不支持</li>
<li><code>timer</code>：表示延时器的返回值，返回值是一个正整数，表示定时器的编号，这个值可以传递给<code>clearTimeout()</code>来取消该延时器。</li>
</ul>
</blockquote>
<h4 id="定时器中-this-问题"><a href="#定时器中-this-问题" class="headerlink" title="定时器中 this 问题"></a>定时器中 this 问题</h4><blockquote>
<ul>
<li><code>setTimout</code>和<code>setInterval</code>函数中的第一个参数是一个函数，当定时器到时间执行这个函数</li>
<li>这个函数中的<code>this</code>默认指向<code>window</code>或<code>global</code>，不管在严格模式还是非严格模式下，<code>this</code>都指向<code>window</code></li>
</ul>
</blockquote>
<pre><code>var obj = &#123;
   name: &quot;张三&quot;,
   sayHello: function () &#123;
     console.log(this); // window
     console.log(&quot;大家好，我叫&quot; + this.name);
   &#125;,
 &#125;;
&gt;
 var timer;
&gt;
 timer = setInterval(function () &#123;
   console.log(this); //window
 &#125;, 1000);
&gt;
 timer = setInterval(obj.sayHello, 1000); //this指window
 //相当于：
 timer = setInterval(function () &#123;
  console.log(this); // window
  console.log(&quot;大家好，我叫&quot; + this.name);
&#125;, 1000); //this指window
</code></pre>
<ol>
<li>修改 this 指向<blockquote>
<ul>
<li>注意：这里的方法实质上并不是真的改变了定时器的this指向，只是改变了结果</li>
</ul>
</blockquote>
</li>
</ol>
<blockquote>
<p>知识点：</p>
<ul>
<li>在之前的学习中我们知道，<code>this</code>代表的是函数的上下文对象，指向把函数当成方法调用的那个对象</li>
</ul>
</blockquote>
<ul>
<li>方法1：包装函数来实现this</li>
</ul>
<pre><code>var obj = &#123;
  name: &quot;张三&quot;,
  sayHello: function () &#123;
    console.log(this); // obj
    console.log(&quot;大家好，我叫&quot; + this.name);
  &#125;,
&#125;;
var timer = setInterval(function () &#123;
  //定时器的this仍然指向window
  obj.sayHello();//在函数内obj调用sayHello方法
&#125;, 2000);//输出结果：每个两秒打印出 大家好，我叫张三
</code></pre>
<ul>
<li>方法2：利用 bind 来实现<blockquote>
<ul>
<li>bind方法：<code>var fn2 = fn.bind(thisArg, arg1, arg2, arg3);</code></li>
<li>改变<code>this</code>指向并返回一个新函数</li>
<li><code>setInterval(obj.sayHello, 1000);</code>this指的是window</li>
<li>然而<code>.bind(obj)</code>把<code>obj.sayHello</code>方法的this改成了obj</li>
</ul>
</blockquote>
</li>
</ul>
<pre><code>var obj = &#123;
  name: &quot;张三&quot;,
  sayHello: function () &#123;
    console.log(this);
    console.log(&quot;大家好，我叫&quot; + this.name);
  &#125;,
&#125;;
&gt;
setInterval(obj.sayHello.bind(obj), 1000);
</code></pre>
<ul>
<li>方法三：在外层作用域，保存 this<blockquote>
<ul>
<li>事件函数中的this指向绑定事件的那个对象</li>
<li>实现效果：点击开始按钮，1秒后，开始按钮变颜色</li>
<li>因为不一定知道按钮元素名，所以一般会写成<code>this.style...</code>；但定时器函数的<code>this</code>指的是window，所以就会报错</li>
<li>因此，声明一个变量<code>that</code>接收事件处理函数的<code>this</code>，在定时器内调用</li>
</ul>
</blockquote>
</li>
</ul>
<pre><code>&gt;&lt;button id=&quot;start&quot;&gt;开始&lt;/button&gt;
&gt;&lt;script&gt;
  var start = document.getElementById(&quot;start&quot;);
  start.onclick = function () &#123;
    //事件处理函数的this指的是start
    var that = this;
    setInterval(function () &#123;
      console.log(that); // that指向start
      that.style.backgroundColor = &quot;red&quot;;//改变start的背景颜色
    &#125;, 1000);
  &#125;;
&gt;&lt;/script&gt;
</code></pre>
<h4 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h4><blockquote>
<p>在讲接下来的同步与异步相关内容时，会涉及到队列相关知识，所以我们先来学习下队列相关内容</p>
<ul>
<li>队是一种线性的数据结构，它的特点是先进先出（<code>First In First Out</code>,简称<code>FIFO</code>），后进后出。</li>
<li>队列的出口端叫作队头（<code>front</code>），队列的入口端叫作队尾(<code>rear</code>)</li>
<li>入队（<code>enqueue</code>）就是把新元素放入队列中，只允许在队列的<strong>队尾</strong>放入元素</li>
<li>出队（<code>dequeue</code>）就是把元素移出队列，只允许在队列的<strong>队头</strong>移出元素。<img src="队列.png"></li>
</ul>
</blockquote>
<h4 id="单线程、同步与异步"><a href="#单线程、同步与异步" class="headerlink" title="单线程、同步与异步"></a>单线程、同步与异步</h4><blockquote>
<p>生活的角度来举一个例子，帮助大家理解。</p>
<ul>
<li>比如你现在工作是查阅合同，并归档，并且这个工作只有你一个人在做，那就属与<strong>单线程执行</strong>。<blockquote>
<p>所谓单线程，站在现实角度，简单理解就是一个人干了所有活。</p>
</blockquote>
</li>
</ul>
</blockquote>
<blockquote>
<ul>
<li>至于 JS 为什么设置成单线程的，我们后面在性能优化那节课来专门讲解。</li>
</ul>
</blockquote>
<blockquote>
<p>比如，你现在的工作流程如下：</p>
<ul>
<li>第一：查阅合同是否有错误，我们简称 A 事情</li>
<li>第二：如果有错误就要提交到老板处，让老板改正 我们简称 B 事情</li>
<li>第三：老板改正好之后，我们要拿回合同，然后一起归档，简称 C 事情</li>
<li>第四：可能中间还有其它同事需要我帮助等啥的，我们简称 D 事情<blockquote>
<p>如果说你现在手上有 10 个文档，当你查阅到第 3 个文档时，发现文档有错误，那你现在该怎么办 ？</p>
</blockquote>
</li>
</ul>
</blockquote>
<ol>
<li>第一种情况：同步执行任务<blockquote>
<ul>
<li>把错误合同提交到老板处，让老板改正后，等老板改好，再拿回来，继续查况后面的合同。老板修改合同上的错误，肯定需要花很多时间，还要找律师啥，显然在老师改合同这个时间里，我们一直等着，后面的合同也不审，那太浪费时间了。<blockquote>
<p>这种情况，就是单线的同步执行任务</p>
</blockquote>
</li>
<li><strong>一次只能做一件事</strong>，而且每次要等前面的事做完了，再做后面的，否则就<strong>一直等着</strong>。而自己一直空闲着，但后面还有好多事又做不了。</li>
</ul>
</blockquote>
</li>
</ol>
<p><strong>JS 单线程同步执行任务</strong></p>
<blockquote>
<ul>
<li><code>JS</code> 是属于单线程的，也就是一次只能做一件事。做了 A 就不能做 B。如果前面的 A 任务会花费大量的时间，就会导致后面的 B 任务停止执行，直到 A 执行完才会执行 B。</li>
<li>如果排队是因为计算量大，CPU 忙不过来，倒也算了，但是很多时候 CPU 是闲着的，因为 IO 设备（输入输出设备）很慢（比如 Ajax 操作从网络读取数据，进行大量计算），不得不等着结果出来，再往下执行。<blockquote>
<p>显示如果单线执行任务，只能同步执行的话，那是非常麻烦的。</p>
</blockquote>
</li>
</ul>
</blockquote>
<ol start="2">
<li>第二种情况：同步与异步结合执行任务<blockquote>
<ul>
<li>每次把错误的合同提交到老板那里，让老板去改正，自己继续审下面的合同。等老板改好合同后，来通知我去拿合同时，我才会考虑去取回合同。</li>
<li>老板通知我拿合同时，如果手上的事没有忙完，则等我忙完了，再去老板那里拿回合同，一起归档，如果忙完了，那就直接去老板哪里取回合同。</li>
<li>如果我忙完了，老板还没有通知我，那我闲着没事也没关系。<blockquote>
<p>这种情况，就是<strong>同步与异步混合</strong>的方式来执行任务</p>
</blockquote>
</li>
</ul>
</blockquote>
</li>
</ol>
<blockquote>
<ul>
<li>从上面这件事来看，第二种情况肯定工作效率会更高，那在我们 JS 执行代码时，他也采用的是<strong>第二种机制</strong>，同步与异步结合的方式执行代码。</li>
</ul>
</blockquote>
<blockquote>
<p>为了防止主线程的不阻塞，异步方案产生</p>
<ul>
<li>所有任务可以分成两种，一种是同步任务（synchronous），另一种是异步任务（asynchronous）。<blockquote>
<p>就好比上面的 A、B、D 是同步任务，C 是异步任务</p>
</blockquote>
</li>
<li>同步任务指的是： 在主线程上排队执行的任务，只有前一个任务执行完毕，才能执行后一个任务；</li>
<li>异步任务指的是： 不进入主线程、而进入**”任务队列”<strong>（task queue）的任务，</strong>只有”任务队列”通知主线程**，某个异步任务可以执行了，该任务才会进入主线程执行</li>
<li>JS 中代码分为同步代码和异步代码。大部分代码是同步的，只有少许代码是异步的</li>
</ul>
</blockquote>
<ol start="3">
<li><p>JS 执行中遇到异步任务如何处理</p>
<blockquote>
<ul>
<li>JS 代码在执行代码时，也是一样的，首先会将所有同步代码执行完了，再去执行异步的代码。</li>
<li>如果在执行过程中碰到了异步的代码，那 JS 就会先把他暂时放到一个<strong>任务队列</strong>中等着，<strong>等同步的代码全部执行完了</strong>再执行任务队列中的异步代码。</li>
<li>执行顺序按<strong>先插入队列的先拿出来执行</strong>。<img src="JS代码执行流程（简化版）.png"></li>
</ul>
</blockquote>
</li>
<li><p>setInterval 和 setTimeout 是两个异步语句</p>
<blockquote>
<ul>
<li>我们来分析下，下面这段代码的执行结果</li>
</ul>
</blockquote>
</li>
</ol>
<pre><code>console.log(1);
console.log(2);
setTimeout(function () &#123;
    console.log(&quot;定时器1000&quot;);
&#125;, 1000);
console.log(3);
&gt;
setTimeout(function () &#123;
    console.log(&quot;定时器0&quot;);
&#125;, 0);
console.log(4);
......
&gt;
// 最后执行结果  1，2，3，4 定时器0  定时器1000
</code></pre>
<blockquote>
<ul>
<li>代码从上往下执行时，碰到<code>setInterval()</code>和<code>setTimeout()</code>异步任务时，浏览器会把这个任务放在<code>Event Table</code>，</li>
<li>等到<strong>定时器计时一到</strong>，会把对应回调函数加入到<code>Event Queue</code><strong>事件队列</strong>中，<strong>等</strong>其它的同步代码执行完了，再去执行他们。<blockquote>
<p>定时器的计时不是由 JS 主线程来负责的。</p>
</blockquote>
</li>
<li>这里就会造成定时器并不能完全按预期的延迟时间来执行代码。因为有可能定时器的等待时间是<code>100ms</code>，而<strong>同步代码</strong>执行的时间要 <code>200ms</code>，这样就会造成定时器要在 <code>200ms</code> 后才会第一次被执行。</li>
</ul>
</blockquote>
<blockquote>
<blockquote>
<p>总结</p>
</blockquote>
<ul>
<li>单线程： 一个人干了所有活，而且每次只能做一件事，JS 就是单线程的。<br><strong>同步</strong></li>
<li>同步就是一件一件事情来，只有等前面的事情做完了，才会做后面的事情，如果前面的事情耗时很长，也要一直等着完成才做后面。</li>
<li>同步会阻塞后续代码的执行<br><strong>异步</strong></li>
<li>异步是相同同步而言的，如果在做的过程中遇到异步的任务，就把他先放在一边，等同步的事情做完了，再去做异步的任务</li>
<li>异步不会阻塞后续代码的执行</li>
<li>异步任务一般都是非常耗时的，而且会受到外部影响。</li>
</ul>
</blockquote>
<ol start="5">
<li>异步的应用场景<blockquote>
<ul>
<li>异步任务都是基于 <code>callback</code> 回调函数的形式来处理的，即需要异步处理的代码放在 <code>callbacak</code> 回调函数中</li>
<li>遇到异步任务，就会把对应的 <code>callback</code> 函数，添加到<strong>任务队列</strong>中，等同步执行完，定时器时间一到，再到任务队列中取出对应的回调函数放入事件队列中，开始执行。</li>
</ul>
</blockquote>
</li>
</ol>
<blockquote>
<p>常见的异步任务有</p>
<ul>
<li>网络请求，如：ajax，图片加载</li>
<li>定时任务，如：setInterval() 和 setTimeout()</li>
</ul>
</blockquote>
<blockquote>
<p>图片加载案例</p>
<ul>
<li>load 事件，表示图片加载成功后要触发的事件</li>
<li>error 事件，表示图片加载失败后要触发的事件</li>
</ul>
</blockquote>
<pre><code>console.log(&quot;同步代码1&quot;);
var img = document.createElement(&quot;img&quot;); // 同步代码
img.src = &quot;https://www.arryblog.com/logo.png&quot;; // 同步代码
img.onload = function () &#123;
  console.log(&quot;图片加载成功&quot;);
  document.body.appendChild(img);
&#125;; // 异步回调
img.onerror = function () &#123;
  console.log(&quot;图片加载失败&quot;);
&#125;; // 异步回调
console.log(&quot;同步代码2&quot;);
//同步代码1 同步代码2 图片加载成功
</code></pre>
<h4 id="定时器实现动画"><a href="#定时器实现动画" class="headerlink" title="定时器实现动画"></a>定时器实现动画</h4><blockquote>
<ul>
<li>动画的本质，就是在更改 CSS 样式</li>
<li>比如，制作一个变色的小球，就是在一定的时间内改变 div 的背景颜色</li>
<li>比如，实现一个长方形，从左边移动到右边，本质就是在不停的更改 div 的 left 值（前提 div 是一个定位元素）<blockquote>
<p>我们利用定时器，在一定的时间内，更改元素身上的 CSS 属性，就能实现简单的动画效果</p>
</blockquote>
</li>
</ul>
</blockquote>
<ol>
<li>案例 1：实现变色小球<blockquote>
<ul>
<li>开一个定时器，间隔一定的时间，就更改下元素的背景颜色</li>
</ul>
</blockquote>
</li>
</ol>
<pre><code>var ball = document.querySelector(&quot;.ball&quot;);
var arrColor = [
  &quot;lightblue&quot;,
  &quot;lightcoral&quot;,
  &quot;lightgray&quot;,
  &quot;lightseagreen&quot;,
  &quot;lightpink&quot;,
  &quot;skyblue&quot;,
];
var len = arrColor.length;
setInterval(function () &#123;
  var index = (Math.random() * len) &gt;&gt; 0;
  ball.style.backgroundColor = arrColor[index];
&#125;, 500);
</code></pre>
<ol start="2">
<li>案例 2：匀速运动 - 向右<blockquote>
<p>当点击开始按扭时，希望小球从左边运动到右边的某个位置，然后停下来，在整个过程中小球运动要到达目的地，可以是</p>
<ul>
<li>匀速运动</li>
<li>减速运动</li>
<li>限定时间（规定多长时间运动到目的）</li>
</ul>
</blockquote>
</li>
</ol>
<ul>
<li>我们来先看第一种：匀速运动 - 向右运动<blockquote>
<ul>
<li>匀速运动，即小球每次移动的距离是一样的，我们把每一次移动距离称为<strong>步长</strong>（step）</li>
<li>我们可以开启一个定时器，让小球每次从当前位置向右移动规定的步长</li>
<li>当小球到达目的时，<strong>暂停</strong>动画（即关闭定时器）</li>
<li>因为在小球每次到达目地的时，如果一直按开始按扭，会开启很多个定时器，小球的运动速度会<strong>越来越快</strong></li>
<li>所以每次在开启一个新的定时器前，要<strong>关闭之前的定时器</strong></li>
</ul>
</blockquote>
</li>
</ul>
<pre><code>&gt;&lt;style&gt;
.ball &#123;
    position: absolute;
    left: 0;
    top: 100px;
    width: 100px;
    height: 100px;
    background-color: skyblue;
    border-radius: 50%;
  &#125;
&gt;&lt;/style&gt;
&gt;
&gt;&lt;button class=&quot;start&quot;&gt;开始&lt;/button&gt;
&gt;&lt;div class=&quot;ball&quot;&gt;&lt;/div&gt;
&gt;&lt;script&gt;
  var start = document.querySelector(&quot;.start&quot;);
  var ball = document.querySelector(&quot;.ball&quot;);
  var timer = null; //记录定时器
  // 点击按扭，球开始运动
  start.onclick = function () &#123;
    move(ball, 10, 500, 100);
  &#125;;
  /*
  move:封装运动动画
  el:运动的元素
  step:小球每次运动的步长
  target:目的地距离
  delay:表示定时器的执行时间，默认值是20ms
  */
  function move(el, step, target, delay = 20) &#123;
    // 每次开启新定时器前，把之前的定时器关闭
    clearInterval(el.timer);
    // 定时器隔一定时间，让小球向右移动一定距离
    el.timer = setInterval(function () &#123;
      //将定时器绑定到元素身上
      // 如果移动距离超过了目标位置，则让他运动到目标位置
      var location = el.offsetLeft + step;
      if (location &gt;= target) &#123;
        location = target;
        clearInterval(el.timer);//清除下一次的定时器
      &#125;
      el.style.left = location + &quot;px&quot;;
    &#125;, delay);
  &#125;
&gt;&lt;/script&gt;
</code></pre>
<blockquote>
<blockquote>
<p>以上方法，小球只能向右运动。如果想让小球在水平向左或向右运动，我们需要修改代码</p>
</blockquote>
</blockquote>
<ol start="3">
<li>案例 3：匀速水平——向左&#x2F;向右<blockquote>
<p>小球沿水平（向左或向右）运动的条件：判断小球的位置与目标点的距离</p>
<ul>
<li>如果小球位置 &lt; 目标点位置，则 step 为正数</li>
<li>如果小球位置 &gt; 目标点位置，则 step 为负数<br>所以小球运动到目标点<strong>停止的条件</strong>就变成了：</li>
<li>当前位置 &gt;&#x3D; 目标位置 &amp;&amp; step 为正数时，停止</li>
<li>或 当前位置 &lt;&#x3D; 目标位置 &amp;&amp; step 为负数时，停止</li>
</ul>
</blockquote>
</li>
</ol>
<ul>
<li>封装函数</li>
</ul>
<pre><code>&gt;/**
&gt; * move 运动函数 指定元素以规定的步长匀速运动到目的
&gt; * @param el 需要运动的元素
&gt; * @param step 每次运动的步长（移动的距离）
&gt; * @param target 运动到的目的点
&gt; * @param delay 定时器每次间隔时长，如果没有传就启用默认值20
&gt; */
function move(el, step, target, delay = 20) &#123;
  // 判断目标位置与当前元素位置
  if (el.offsetLeft &gt; target) step = -step;
  clearInterval(el.timer);
  // 定时器隔一定时间，让小球向右移动一定距离
  el.timer = setInterval(function () &#123;
    // 如果移动距离超过了目标位置，则让他运动到目标位置
    var currentLocation = el.offsetLeft + step;
    // 小球停止运动的条件
    if (
      (currentLocation &gt;= target &amp;&amp; step &gt; 0) ||
      (currentLocation &lt;= target &amp;&amp; step &lt; 0)
    ) &#123;
      currentLocation = target;
      clearInterval(el.timer);//清除下一次的定时器
    &#125;
    el.style.left = currentLocation + &quot;px&quot;;
  &#125;, delay);
&#125;
</code></pre>
<ol start="4">
<li>案例 4：匀速水平——往返运动<blockquote>
<ul>
<li>使用回调函数</li>
</ul>
</blockquote>
</li>
</ol>
<pre><code>&gt;&lt;button class=&quot;btn&quot;&gt;先向左后向右&lt;/button&gt;
&gt;   &lt;div class=&quot;ball&quot;&gt;&lt;/div&gt;
&gt;   &lt;script&gt;
 var btn = document.querySelector(&quot;.btn&quot;);
 var ball = document.querySelector(&quot;.ball&quot;);
 var timer = null; //记录定时器
 // 点击按扭，球开始运动
 btn.onclick = function () &#123;
  //用实参传入回调函数
   move(ball, 10, 500, 50, function () &#123;
     move(ball, 10, 0, 50);
   &#125;);
 &#125;;//先左后右
 btn.onclick = function () &#123;
   move(ball, 10, 500, 50, function () &#123;
     move(ball, 10, 0, 50, function () &#123;
       move(ball, 10, 500, 50);
     &#125;);
   &#125;);
 &#125;;//先左后右再左
&gt;
 function move(el, step, target, delay = 20, callback) &#123;
   // 判断目标位置与当前元素位置
   if (el.offsetLeft &gt; target) step = -step;
   clearInterval(el.timer);
   // 定时器隔一定时间，让小球向右移动一定距离
   el.timer = setInterval(function () &#123;
     // 如果移动距离超过了目标位置，则让他运动到目标位置
     var currentLocation = el.offsetLeft + step;
     // 小球停止运动的条件
     if (
       (currentLocation &gt;= target &amp;&amp; step &gt; 0) ||
       (currentLocation &lt;= target &amp;&amp; step &lt; 0)
     ) &#123;
       currentLocation = target;
       clearInterval(el.timer);//清除下一次的定时器
       //这里清理定时器，表示到头了
       //判断传入类型，如果是函数，则调用，不是则什么也不做
       typeof callback === &quot;function&quot; ? callback() : callback;
       //callback instanceof Function()?callback():callback;//所有的函数都是Function的实例
     &#125;
     el.style.left = currentLocation + &quot;px&quot;;
   &#125;, delay);
 &#125;
&gt;&lt;/script&gt;
</code></pre>
<ol start="5">
<li>案例 5：减速运动 - 向右<blockquote>
<ul>
<li>所谓减速运动，我们可以理解为，让一个元素从左边运动到右边，其运动的速度越来越小，到最后停止运动。</li>
<li>比如小球从左边运动到右边，其步长变化类似于： step &#x3D; 10，step &#x3D; 9、step &#x3D; 7 … step &#x3D; 1 最后到达终点，然后停止运动。<blockquote>
<p>这里的难点在于，整个过程中速度的变化如何消减，从而还要实现在速度消减到最小的时候小球运动到了目地的。这里有一个简单计算每一次小球运动步长的<strong>公式</strong></p>
</blockquote>
</li>
</ul>
</blockquote>
</li>
</ol>
<pre><code>// n 是一个大于1的数，如果等于1，直接到达目地的，所以n尽可能设置大些
step = (目地的 - 当前位置) / n;
</code></pre>
<blockquote>
<ul>
<li>注意：向右减速运动时，步长是递减的，一定要<strong>向上取整</strong><code>Math.ceil</code>才能刚好停在目的地；</li>
<li>因为最后的几个步长一定是小数，只有向上取整，使它等于1，每次的步长为1，才会逐步到达目的地</li>
</ul>
</blockquote>
<ul>
<li>小球从最左边做减速运动运动到 500px 的位置</li>
</ul>
<pre><code>&gt;&lt;button id=&quot;start&quot;&gt;开始&lt;/button&gt;
&gt;&lt;div class=&quot;ball&quot;&gt;&lt;/div&gt;
&gt;&lt;script&gt;
  var start = document.getElementById(&quot;start&quot;);
  var ball = document.querySelector(&quot;.ball&quot;);
  var timer = null; //初始化定时器
&gt;
  start.onclick = function () &#123;
    move(ball, 500, 50);
  &#125;;
  //向右减速运动
  function move(el, target, delay = 20) &#123;
    // 每次开启一个新定时器前，先清除原来的
    clearInterval(el.timer);
    el.timer = setInterval(function () &#123;
      // 计算每次运动的步长  小数向上取正
      var step = Math.ceil((target - el.offsetLeft) / 10);
      // 到达目标位置，停下（即清除定时器）
      if (el.offset === target) &#123;
        clearInterval(el.timer);
      &#125;
      // 让小球运动起来
      el.style.left = el.offsetLeft + step + &quot;px&quot;;
    &#125;, delay);
  &#125;
&gt;&lt;/script&gt;
</code></pre>
<ol start="6">
<li>案例 6：减速运动 - 水平(向左&#x2F;向右&#x2F;往返)<blockquote>
<p>要让小球沿水平（向左或向右）运动，那就要判断小球的位置与目标点的距离</p>
<ul>
<li>如果小球位置 &lt; 目标点位置，则 step 为正数，向上取整，才能准确到达目的地</li>
<li>如果小球位置 &gt; 目标点位置，则 step 为负数，向下取整，才能准确到达目的地</li>
</ul>
</blockquote>
</li>
</ol>
<blockquote>
<ul>
<li>向左&#x2F;向右时，就把函数绑在相应的<code>onclick</code>上,改变left的初始值</li>
<li>往返时，就使用回调函数</li>
</ul>
</blockquote>
<pre><code>&gt;&lt;style&gt;
 .ball &#123;
   position: absolute;
   /* left: 0; */
   left: 500px;
   top: 50px;
   width: 100px;
   height: 100px;
   background-color: skyblue;
   border-radius: 50%;
 &#125;
&gt;&lt;/style&gt;
&gt;
&gt;&lt;button id=&quot;left&quot;&gt;向左&lt;/button&gt;
&gt;&lt;button id=&quot;right&quot;&gt;向右&lt;/button&gt;
&gt;&lt;button id=&quot;side&quot;&gt;往返&lt;/button&gt;
&gt;&lt;div class=&quot;ball&quot;&gt;&lt;/div&gt;
&gt;&lt;script&gt;
  var left = document.getElementById(&quot;left&quot;);
  var right = document.getElementById(&quot;right&quot;);
  var side = document.getElementById(&quot;side&quot;);
  var ball = document.querySelector(&quot;.ball&quot;);
  var timer = null; //初始化定时器
&gt;
  //向左减速运动
  left.onclick = function () &#123;
    move(ball, 500, 50);
  &#125;;
  //向右减速运动
  right.onclick = function () &#123;
    move(ball, 0, 50);
  &#125;;
  //往返运动
  side.onclick = function () &#123;
    move2(ball, 500, 50, function () &#123;
      move2(ball, 0, 50, function () &#123;
        move2(ball, 500, 50);
      &#125;);
    &#125;);
  &#125;;
&gt;
//向左或向右运动
  function move(el, target, delay = 20) &#123;
    // 每次开启一个新定时器前，先清除原来的
    clearInterval(el.timer);
    el.timer = setInterval(function () &#123;
      // 计算每次运动的步长  小数向上取正
      var step = (target - el.offsetLeft) / 10;
      // 如果step大于0，则向上取正  如果step小于0，则向下取正
      step = step &gt; 0 ? Math.ceil(step) : Math.floor(step);
      // 到达目标位置，停下（即清除定时器）
      if (el.offsetLeft === target) &#123;
        clearInterval(el.timer);
      &#125;
      // 让小球运动起来
      el.style.left = el.offsetLeft + step + &quot;px&quot;;
    &#125;, delay);
  &#125;
&gt;
//往返运动
  function move2(el, target, delay = 20, callback) &#123;
    // 每次开启一个新定时器前，先清除原来的
    clearInterval(el.timer);
    el.timer = setInterval(function () &#123;
      // 计算每次运动的步长  小数向上取正
      var step = (target - el.offsetLeft) / 10;
      // 如果step大于0，则向上取正  如果step小于0，则向下取正
      step = step &gt; 0 ? Math.ceil(step) : Math.floor(step);
      // 到达目标位置，停下（即清除定时器）
      if (el.offsetLeft === target) &#123;
        clearInterval(el.timer);
      &#125;
      // 让小球运动起来
      el.style.left = el.offsetLeft + step + &quot;px&quot;;
      //等赋完上一轮的值之后再来调回调函数
      if (el.offsetLeft === target) &#123;
            callback instanceof Function ? callback() : callback;
          &#125; &#125;, delay);
  &#125;
&gt;&lt;/script&gt;
</code></pre>
<ol start="7">
<li>案例 7：多属性减速运动<blockquote>
<p>我们希望小球按我们指定的属性来发生变化，如果同时指定多个属性呢 ？</p>
</blockquote>
</li>
</ol>
<ul>
<li>难点一：多个属性如何指定，传值问题。<blockquote>
<ul>
<li>我们把 <code>target</code> 目标参数改成一个<strong>对象</strong>，用对象的形式来指定变化的属性值，如下：</li>
</ul>
</blockquote>
</li>
</ul>
<pre><code>target = &#123; left: 200, top: 300, width: 300, height: 400 &#125;;
</code></pre>
<ul>
<li>难点二：如何控制每个属性的变化<blockquote>
<ul>
<li>可以利用<code>for..in</code>循环遍历出<code>target</code>中的每个<strong>属性名</strong>和对应的<strong>属性值</strong>(目标值)</li>
<li>然后利用<code>getComputedStyle()</code>方法，获取元素<strong>当前对应属性值</strong>，与目标值对比，来控制属性变化</li>
</ul>
</blockquote>
</li>
</ul>
<pre><code>// for ...in 遍历target，获取对应属性名和属性值
for(var key in target)&#123; ....&#125;
&gt;
// 获取元素对应属性值
var attrValue = getStyle(el, key);
function getStyle(el, attr) &#123;
    return getComputedStyle(el, null)[attr] || 0;//0是默认值
&#125;
//相当于 var attrValue = getComputedStyle(el)[key];
</code></pre>
<ul>
<li>难点三：何时暂停定时器<blockquote>
<ul>
<li>多个属性发生变化，只有当<strong>所有属性</strong>变化值都达到目标时，才会能暂停定时器。</li>
<li>判断方法：我们设置一个<code>flag</code>属性用来记录是否所有属性都达到了目标值，只要有一个没有达到<code>flag = false</code>,只有所有值都达到目标值时，<code>flag = true</code></li>
</ul>
</blockquote>
</li>
</ul>
<pre><code>if (flag) &#123;
  clearInterval(el.timer);
&#125;
</code></pre>
<ul>
<li>把 opacity 透明度属性融入进去<blockquote>
<ul>
<li>我们把<code>透明度的属性值 * 100</code>再处理，然后保存结果时，再<code>除以 100</code></li>
<li>如果用户传过来的对应属性<code>left，top，width，height，opacity</code>值，带有小数，我们在比较时<strong>用整数来比较</strong>。<blockquote>
<p>注：传入的 opacity 只能是 1 到 100 之间的整数</p>
</blockquote>
</li>
</ul>
</blockquote>
</li>
</ul>
<pre><code>&gt;/**
&gt; * move 多属性运动动画
&gt; * el 运动的元素
&gt; * target 多个属性的目标值 target=&#123;width:&#39;300px&#39;,height:&#39;400px&#39;&#125;
&gt; * callback 回调函数  动画结束后执行
&gt; * delay 定时器的执行间隔时间
&gt; */
function move(el, target = &#123;&#125;, callback, delay = 20) &#123;
  // 开定时器之前，要清定时器
  clearInterval(el.timer);
  el.timer = setInterval(function () &#123;
    var flag = true; //假设所有的属性都到达目标值
    // 多属性动画
    // 通过for...in遍历 target对象，取得每个key和(value)
    // 通过key得到当前改变的属性，及属性的当前值
    // 通过value得到当前改变的属性的目标值
    for (var key in target) &#123;
     // 要对传过来的key做一个判断，判断是不是一个opacity
     var attrValue = getComputedStyle(el)[key]; // 当前值   1
     if (key.toLowerCase() === &quot;opacity&quot;) &#123;
       // 将值 1 或 0.4等 转换成 100或 40
       attrValue = attrValue * 100;
     &#125; else &#123;
       attrValue = parseInt(attrValue); // 当前值   1
     &#125;
&gt;
     var targetValue = parseInt(target[key]); // 目标值   30
&gt;
     // 计算运动的步长step(速度 speed)
     var step = (targetValue - attrValue) / 10;
     step = step &gt; 0 ? Math.ceil(step) : Math.floor(step);
&gt;
     // 只要有一个属性没有到达目标值，那就把flag设置为false
     var currentDistance = attrValue + step;
     if (currentDistance !== targetValue) &#123;
       flag = false;
     &#125;
     // 赋值
     if (key.toLowerCase() === &quot;opacity&quot;) &#123;
       el.style[key] = currentDistance / 100;
     &#125; else &#123;
       el.style[key] = currentDistance + &quot;px&quot;;
     &#125;
   &#125;
&gt;
   // 清定时器,只有flage=true时
   if (flag) &#123;
     clearInterval(el.timer);
     // 执行回调
     callback instanceof Function ? callback() : callback;
   &#125;
 &#125;, delay);
&#125;
</code></pre>
<ol start="8">
<li>案例 8：单个属性限定时间动画<blockquote>
<ul>
<li>限定步长的动画，是没有办法精准的把控好时间的，其运动的距离也长，耗时越长</li>
<li>如果我们要限定时间，在规定的时间内完成动画，那需要如何实现呢 ？<img src="限定时间动画.png"></li>
</ul>
</blockquote>
</li>
</ol>
<blockquote>
<ul>
<li>计算<strong>当前位置</strong>以控制<code>left</code>的距离</li>
<li><code>duration</code>&#x3D;走完全程所需要的时间（s）</li>
<li><code>begin</code>&#x3D;开始位置&#x3D;<code>el.offsetLeft</code></li>
<li><code>change</code>&#x3D;总距离&#x3D;target(目标位置)-begin(开始位置)</li>
<li>速度&#x3D;总距离&#x2F;总时间&#x3D;<code>change/duration</code></li>
<li><code>time</code>(已经走了多久)：定时器次数*延迟时间</li>
<li><code>currentDistance</code>(当前位置)&#x3D;left&#x3D;<code>起始位置+所用时间*速度</code>&#x3D;begin+T*C&#x2F;D</li>
<li>改善：将毫秒调整为秒<code>duration = parseFloat(duration) * 1000</code>,<code>parseFloat</code>过滤字符串</li>
<li>加入回调函数</li>
</ul>
</blockquote>
<ul>
<li>限定时间动画函数</li>
</ul>
<pre><code>&gt;&lt;div class=&quot;ball&quot;&gt;&lt;/div&gt;
&gt;&lt;script&gt;
  var ball = document.querySelector(&quot;.ball&quot;);
&gt;    
  function move(el, target, duration, callback) &#123;
    var begin = el.offsetLeft;
    var change = target - begin;
    //将毫秒调整为秒
    duration = parseFloat(duration) * 1000;
    var time = 0;
    //开启定时器时，首先清理上一个定时器
    clearInterval(el.timer);
    el.timer = setInterval(function () &#123;
      time += 20;
      var currentDistance = begin + (time * change) / duration;
      //超过规定时间，就把位置拉到目标距离，清理定时器
      if (time &gt;= duration) &#123;
        currentDistance = target;
        clearInterval(el.timer);
      &#125;
      el.style.left = currentDistance + &quot;px&quot;;
      //到头之后使用回调函数
      if (time &gt;= duration) &#123;
        callback instanceof Function ? callback() : callback;
      &#125;
    &#125;, 20);
  &#125;
  document.documentElement.onclick = function () &#123;
    move(ball, 500, &quot;1s&quot;, function () &#123;
      move(ball, 10, &quot;0.5s&quot;);
    &#125;);
  &#125;;
&gt;&lt;/script&gt;
</code></pre>
<ol>
<li>案例9：多个属性，同一限定时间动画<blockquote>
<ul>
<li>在上一个案例的基础上，再融合多个属性</li>
</ul>
</blockquote>
</li>
</ol>
<pre><code>&gt;&lt;div class=&quot;ball&quot;&gt;&lt;/div&gt;
&gt;&lt;script&gt;
  var ball = document.querySelector(&quot;.ball&quot;);
&gt;
  document.documentElement.onclick = function () &#123;
    move(ball, (target = &#123; top: &quot;50px&quot;, left: &quot;500px&quot; &#125;), &quot;1s&quot;);
  &#125;;
&gt;
  //回调函数
  document.documentElement.onclick = function () &#123;
    move(
      ball,
      (target = &#123; top: &quot;50px&quot;, left: &quot;500px&quot; &#125;),
      &quot;1s&quot;,
      function () &#123;
        move(ball, (target = &#123; top: &quot;10px&quot;, left: &quot;10px&quot; &#125;), &quot;1s&quot;);
      &#125;
    );
  &#125;;
&gt;
  //限定时间动画
  function move(el, target = &#123;&#125;, duration, callback) &#123;
    var time = 0;
    //将毫秒调整为秒
    duration = parseFloat(duration) * 1000;
    //开启定时器时，首先清理上一个定时器
    clearInterval(el.timer);
&gt;
    el.timer = setInterval(function () &#123;
      time += 20;
      for (var key in target) &#123;
        var begin = parseFloat(getComputedStyle(el)[key]);
        var targerValue = parseFloat(target[key]);
        var change = targerValue - begin;
        var currentDistance = begin + (time * change) / duration;
       //超过规定时间，就把位置拉到目标距离，清理定时器
        if (time &gt;= duration) &#123;
          currentDistance = targerValue;
          clearInterval(el.timer);
        &#125;
        el.style[key] = currentDistance + &quot;px&quot;;
       //到头之后使用回调函数
        if (time &gt;= duration) &#123;
          callback instanceof Function ? callback() : callback;
        &#125;
      &#125;
&gt;
   &#125;, 20);
 &#125;
&gt;&lt;/script&gt;
</code></pre>
<ol>
<li>案例10：多个属性，不同限定时间动画</li>
</ol>
<p><strong>几大核心问题：</strong></p>
<ul>
<li>多属性运动，target 保存数据的结构定义成如下，用户按这个格式来传数据</li>
</ul>
<pre><code>var target = [
  &#123;
    width: &quot;200px&quot;,
    duration: &quot;2s&quot;,
  &#125;,
  &#123;
    left: &quot;600px&quot;,
    duration: &quot;5s&quot;,
  &#125;,
  &#123;
    top: &quot;200px&quot;,
    duration: &quot;1s&quot;,
  &#125;,
];
</code></pre>
<ul>
<li>对上面结构的数据做转换，转成适合编程的如下结构数据</li>
</ul>
<pre><code>&gt;/**
&gt; * attr 运动的属性
&gt; * target 运动的目标值
&gt; * D ：duration 动画（某个属性）运动的总时间
&gt; * B ：Begin 动画（当前属性）的开始位置
&gt; * C : Change 需要改变的总距离  target -B
&gt; */
var target = [
  &#123; attr: &quot;width&quot;, D: 2000, target: 200, B: 100, C: 100 &#125;,
  &#123; attr: &quot;left&quot;, D: 5000, target: 600, B: 10, C: 590 &#125;,
  &#123; attr: &quot;top&quot;, D: 1000, target: 200, B: 10, C: 190 &#125;,
];
</code></pre>
<blockquote>
<p><strong>难点</strong></p>
<ul>
<li>怎样先得到每个对象的第一个键值对，再得到每个对象的第二个键值对</li>
<li><code>for in</code>不能保证按书写顺序遍历数组&#x2F;对象，怎么处理</li>
</ul>
</blockquote>
<blockquote>
<ul>
<li>方式一：未考虑<code>for in</code> 的遍历顺序</li>
<li><code>n=0</code>使得到的是每个对象的第一个键值</li>
<li><code>n=1</code>使得到的是每个对象的第二个键值</li>
</ul>
</blockquote>
<pre><code>function convertDataStruct(el, target) &#123;
  var result = [];
  for (var i = 0; i &lt; target.length; i++) &#123;
    var n = 0; //记录进入对象的次数
    var obj = &#123;&#125;;
    for (var key in target[i]) &#123;
      if (n === 0) &#123;
        obj.attr = key;
        obj.target = parseInt(target[i][key]);
        obj.B = parseInt(getComputedStyle(el)[key]);
        obj.C = obj.target - obj.B;
      &#125; else &#123;
        //把秒转成毫秒
        obj.D = parseFloat(target[i][key]) * 1000;
      &#125;
      n++;
    &#125;
    result.push(obj);
  &#125;
  return result;
&#125;
</code></pre>
<blockquote>
<ul>
<li>优化版</li>
<li>用<code>indexOf</code>在attrArr数组中查找元素</li>
<li>找到了的就是每个对象的第一个键值</li>
<li>没找到的就是每个对象的第二个键值</li>
</ul>
</blockquote>
<pre><code>var attrArr = [&quot;width&quot;, &quot;left&quot;, &quot;top&quot;, &quot;height&quot;];
function convertDataStruct(el, target) &#123;
  var result = [];
  for (var i = 0; i &lt; target.length; i++) &#123;
    var obj = &#123;&#125;;
    for (var key in target[i]) &#123;
      var index = attrArr.indexOf(key);
      if (index !== -1) &#123;
        obj.attr = key;
        obj.target = parseInt(target[i][key]);
        obj.B = parseInt(getComputedStyle(el)[key]);
        obj.C = obj.target - obj.B;
      &#125; else &#123;
        obj.D = Math.abs(parseFloat(target[i][key]) * 1000);
      &#125;
    &#125;
    result.push(obj);
  &#125;
  return result;
&#125;
</code></pre>
<ul>
<li>何时清除定时器<blockquote>
<ul>
<li>累计时间 &gt; 多个属性中<strong>最大运动时间</strong>时，清定时器</li>
</ul>
</blockquote>
</li>
<li>那如何获取多个属性中，运动时间最长的那个时间？<blockquote>
<ul>
<li>如果没有输入运动时间？设默认值</li>
<li>如果输入的运动时间为负？用<code>Math.abs()</code></li>
<li>可以用for循环，也可以用<code>forEach</code></li>
</ul>
</blockquote>
</li>
</ul>
<pre><code>function getTime(target) &#123;
  var MaxTime = parseFloat(target[0].duration) * 1000;
  //如果没有设置duration，则时间为0，有就等于它的绝对值
  MaxTime = MaxTime ? Math.abs(MaxTime) : 0;
&gt; 
  //方法1：for 循环
  // for (var i = 0; i &lt; target.length; i++) &#123;
  //   var time = parseFloat(target[i].duration) * 1000;
  //   //如果某项没设置duration，就为0
  //   time = time ? Math.abs(time) : 0;
  //   if (MaxTime &lt; time) MaxTime = time;
  // &#125;
&gt;
  //方法2：forEach
  target.forEach(function (value) &#123;
    var time = parseFloat(value.duration) * 1000;
    //如果某项没设置duration，就为0
    time = time ? Math.abs(time) : 0;
    if (MaxTime &lt; time) MaxTime = time;
  &#125;);
  return MaxTime;
&#125;
</code></pre>
<ul>
<li><p>当累计时间大于属性运动时间</p>
<blockquote>
<ul>
<li>如果累计时间 &gt; 属性运动时间，则属性值 &#x3D; 目标值，将当前运动距离强制设为目标值，但<strong>不清</strong>定时器</li>
</ul>
</blockquote>
</li>
<li><p>什么时候执行回调函数</p>
<blockquote>
<ul>
<li>清定时器，表示动画结束，可以执行回调</li>
</ul>
</blockquote>
</li>
<li><p>加入<code>opacity</code>属性</p>
<blockquote>
<ul>
<li>数据转换时，把透明度的属性值 * 100</li>
<li>定时器中改变属性值的公式，不用再加”px”,直接<code>除100</code></li>
</ul>
</blockquote>
</li>
<li><p>完整代码：</p>
</li>
</ul>
<pre><code>&gt;&lt;div class=&quot;ball&quot;&gt;&lt;/div&gt;
&gt;&lt;script&gt;
  var ball = document.querySelector(&quot;.ball&quot;);
  var target = [
    &#123;
      width: &quot;150px&quot;,
      duration: &quot;2s&quot;,
    &#125;,
    &#123;
      height: &quot;150px&quot;,
      duration: &quot;2s&quot;,
    &#125;,
    &#123;
      left: &quot;400px&quot;,
      duration: &quot;3s&quot;,
    &#125;,
    &#123;
      top: &quot;100px&quot;,
      duration: &quot;1s&quot;,
    &#125;,
    &#123;
      opacity: &quot;0.3&quot;,
      duration: &quot;1s&quot;,
    &#125;,
  ];
  document.documentElement.onclick = function () &#123;
    move(ball, target);
  &#125;;
  function move(el, target, callback) &#123;
    clearInterval(el.timer); //清理定时器
    var time = 0;
    //获得属性中运动时间最长的时间，默认值200
    var MaxTime = getTime(target) || 200;
&gt;
  //转换数据
  var target = convertDataStruct(ball, target);
  //启动定时器
  el.timer = setInterval(function () &#123;
    time += 20;
    //遍历目标数组
    for (var i = 0; i &lt; target.length; i++) &#123;
      var duration = target[i].D || 200;
      var targetDistance = target[i].target;
      var begin = target[i].B;
      var change = target[i].C;
&gt;
      var currentDistance = begin + (time * change) / duration;
      //超过目标距离时
      if (time &gt;= duration) &#123;
        currentDistance = targetDistance;
      &#125;
      if (target[i].attr === &quot;opacity&quot;) &#123;
        el.style[target[i].attr] = currentDistance / 100;
      &#125; else &#123;
        el.style[target[i].attr] = currentDistance + &quot;px&quot;;
      &#125;
    &#125;
    //如果最长时间结束，清理定时器，执行回调函数
    if (time &gt; MaxTime) &#123;
      clearInterval(el.timer);
      callback instanceof Function ? callback() : callback;
    &#125;
  &#125;, 20);
&#125;
&gt;
  //得到最长完成时间
  function getTime(target) &#123;
    var MaxTime = parseFloat(target[0].duration) * 1000;
    //如果没有设置duration，则时间为0，有就等于它的绝对值
    MaxTime = MaxTime ? Math.abs(MaxTime) : 0;
    //for 循环
    // for (var i = 0; i &lt; target.length; i++) &#123;
    //   var time = parseFloat(target[i].duration) * 1000;
    //   //如果某项没设置duration，就为0
    //   time = time ? Math.abs(time) : 0;
    //   if (MaxTime &lt; time) MaxTime = time;
    // &#125;
&gt;
    //forEach
    target.forEach(function (value) &#123;
      var time = parseFloat(value.duration) * 1000;
      //如果某项没设置duration，就为0
      time = time ? Math.abs(time) : 0;
      if (MaxTime &lt; time) MaxTime = time;
    &#125;);
    return MaxTime;
  &#125;
  //getTime(target)
&gt;
  //数据结构转换函数：
  //   var target = [
  //     &#123; attr: &quot;width&quot;, D: 2000, target: 200, B: 100, C: 100 &#125;,
  //     &#123; attr: &quot;left&quot;, D: 5000, target: 600, B: 10, C: 590 &#125;,
  //     &#123; attr: &quot;top&quot;, D: 1000, target: 200, B: 10, C: 190 &#125;,
  //   ];
&gt;
  //基础版
  function convertDataStruct(el, target) &#123;
    var result = [];
    for (var i = 0; i &lt; target.length; i++) &#123;
      var n = 0; //记录进入对象的次数
      var obj = &#123;&#125;;
      for (var key in target[i]) &#123;
        if (n === 0) &#123;
          if (key === &quot;opacity&quot;) &#123;
            obj.attr = key;
            obj.target = target[i][key] * 100;
            obj.B = getComputedStyle(el)[key] * 100;
            obj.C = obj.target - obj.B;
          &#125; else &#123;
            obj.attr = key;
            obj.target = parseInt(target[i][key]);
            obj.B = parseInt(getComputedStyle(el)[key]);
            obj.C = obj.target - obj.B;
          &#125;
        &#125; else &#123;
          //把秒转成毫秒
          obj.D = parseFloat(target[i][key]) * 1000;
        &#125;
        n++;
      &#125;
      result.push(obj);
    &#125;
    return result;
  &#125;
&gt;
  //优化版
  var attrArr = [&quot;width&quot;, &quot;left&quot;, &quot;top&quot;, &quot;height&quot;];
  function convertDataStruct(el, target) &#123;
    var result = [];
    for (var i = 0; i &lt; target.length; i++) &#123;
      var obj = &#123;&#125;;
      for (var key in target[i]) &#123;
        var index = attrArr.indexOf(key);
        if (index !== -1) &#123;
          if (key === &quot;opacity&quot;) &#123;
            obj.attr = key;
            obj.target = target[i][key] * 100;
            obj.B = getComputedStyle(el)[key] * 100;
            obj.C = obj.target - obj.B;
          &#125; else &#123;
            obj.attr = key;
            obj.target = parseInt(target[i][key]);
            obj.B = parseInt(getComputedStyle(el)[key]);
            obj.C = obj.target - obj.B;
          &#125;
        &#125; else &#123;
          obj.D = Math.abs(parseFloat(target[i][key]) * 1000);
        &#125;
      &#125;
      result.push(obj);
    &#125;
    return result;
  &#125;
&gt;&lt;/script&gt;
</code></pre>
<ul>
<li>封装成一个函数，放在js文件里<blockquote>
<ul>
<li>怎样暴露在全局里：<code>window.move=move</code></li>
<li>为了使变量不污染全局，做成一个立即执行函数，形成闭包<code>(function()&#123;&#125;)()</code></li>
</ul>
</blockquote>
</li>
</ul>
<ol start="11">
<li>常见的动画运动公式：<blockquote>
<ul>
<li>把以下代码放入一个JS文件中调用</li>
</ul>
</blockquote>
</li>
</ol>
<ul>
<li>使用方法<blockquote>
<ul>
<li>拿上个案例来说，将公式<code>currentDistance = begin + (time * change) / duration;</code>换成<code>currentDistance = Tween.Cubic.easeIn(time, begin, change, duration);</code></li>
<li>打点调用方法，以<code>Tween</code>开头</li>
<li>只需要提供<code>time, begin, change, duration</code>这四个变量</li>
</ul>
</blockquote>
</li>
</ul>
<pre><code>// 运动方式
var Tween = &#123;
  // 匀速运动公式
  Linear: function (t, b, c, d) &#123;
    return (t / d) * c + b;
  &#125;,
  // 指数衰减的反弹缓动
  Bounce: &#123;
    easeIn: function (t, b, c, d) &#123;
      return c - Tween.Bounce.easeOut(d - t, 0, c, d) + b;
    &#125;,
    easeOut: function (t, b, c, d) &#123;
      if ((t /= d) &lt; 1 / 2.75) &#123;
        return c * (7.5625 * t * t) + b;
      &#125; else if (t &lt; 2 / 2.75) &#123;
        return c * (7.5625 * (t -= 1.5 / 2.75) * t + 0.75) + b;
      &#125; else if (t &lt; 2.5 / 2.75) &#123;
        return c * (7.5625 * (t -= 2.25 / 2.75) * t + 0.9375) + b;
      &#125; else &#123;
        return c * (7.5625 * (t -= 2.625 / 2.75) * t + 0.984375) + b;
      &#125;
    &#125;,
    easeInOut: function (t, b, c, d) &#123;
      if (t &lt; d / 2) &#123;
        return Tween.Bounce.easeIn(t * 2, 0, c, d) * 0.5 + b;
      &#125;
      return Tween.Bounce.easeOut(t * 2 - d, 0, c, d) * 0.5 + c * 0.5 + b;
    &#125;,
  &#125;,
  // 二次方的缓动
  Quad: &#123;
    easeIn: function (t, b, c, d) &#123;
      return c * (t /= d) * t + b;
    &#125;,
    easeOut: function (t, b, c, d) &#123;
      return -c * (t /= d) * (t - 2) + b;
    &#125;,
    easeInOut: function (t, b, c, d) &#123;
      if ((t /= d / 2) &lt; 1) &#123;
        return (c / 2) * t * t + b;
      &#125;
      return (-c / 2) * (--t * (t - 2) - 1) + b;
    &#125;,
  &#125;,
  // 三次方的缓动
  Cubic: &#123;
    easeIn: function (t, b, c, d) &#123;
      return c * (t /= d) * t * t + b;
    &#125;,
    easeOut: function (t, b, c, d) &#123;
      return c * ((t = t / d - 1) * t * t + 1) + b;
    &#125;,
    easeInOut: function (t, b, c, d) &#123;
      if ((t /= d / 2) &lt; 1) &#123;
        return (c / 2) * t * t * t + b;
      &#125;
      return (c / 2) * ((t -= 2) * t * t + 2) + b;
    &#125;,
  &#125;,
  // 四次方的缓动
  Quart: &#123;
    easeIn: function (t, b, c, d) &#123;
      return c * (t /= d) * t * t * t + b;
    &#125;,
    easeOut: function (t, b, c, d) &#123;
      return -c * ((t = t / d - 1) * t * t * t - 1) + b;
    &#125;,
    easeInOut: function (t, b, c, d) &#123;
      if ((t /= d / 2) &lt; 1) &#123;
        return (c / 2) * t * t * t * t + b;
      &#125;
      return (-c / 2) * ((t -= 2) * t * t * t - 2) + b;
    &#125;,
  &#125;,
  // 五次方的缓动
  Quint: &#123;
    easeIn: function (t, b, c, d) &#123;
      return c * (t /= d) * t * t * t * t + b;
    &#125;,
    easeOut: function (t, b, c, d) &#123;
      return c * ((t = t / d - 1) * t * t * t * t + 1) + b;
    &#125;,
    easeInOut: function (t, b, c, d) &#123;
      if ((t /= d / 2) &lt; 1) &#123;
        return (c / 2) * t * t * t * t * t + b;
      &#125;
      return (c / 2) * ((t -= 2) * t * t * t * t + 2) + b;
    &#125;,
  &#125;,
  // 正弦曲线的缓动
  Sine: &#123;
    easeIn: function (t, b, c, d) &#123;
      return -c * Math.cos((t / d) * (Math.PI / 2)) + c + b;
    &#125;,
    easeOut: function (t, b, c, d) &#123;
      return c * Math.sin((t / d) * (Math.PI / 2)) + b;
    &#125;,
    easeInOut: function (t, b, c, d) &#123;
      return (-c / 2) * (Math.cos((Math.PI * t) / d) - 1) + b;
    &#125;,
  &#125;,
  // 指数曲线的缓动
  Expo: &#123;
    easeIn: function (t, b, c, d) &#123;
      return t == 0 ? b : c * Math.pow(2, 10 * (t / d - 1)) + b;
    &#125;,
    easeOut: function (t, b, c, d) &#123;
      return t == d ? b + c : c * (-Math.pow(2, (-10 * t) / d) + 1) + b;
    &#125;,
    easeInOut: function (t, b, c, d) &#123;
      if (t == 0) return b;
      if (t == d) return b + c;
      if ((t /= d / 2) &lt; 1) return (c / 2) * Math.pow(2, 10 * (t - 1)) + b;
      return (c / 2) * (-Math.pow(2, -10 * --t) + 2) + b;
    &#125;,
  &#125;,
  // 圆形曲线的缓动
  Circ: &#123;
    easeIn: function (t, b, c, d) &#123;
      return -c * (Math.sqrt(1 - (t /= d) * t) - 1) + b;
    &#125;,
    easeOut: function (t, b, c, d) &#123;
      return c * Math.sqrt(1 - (t = t / d - 1) * t) + b;
    &#125;,
    easeInOut: function (t, b, c, d) &#123;
      if ((t /= d / 2) &lt; 1) &#123;
        return (-c / 2) * (Math.sqrt(1 - t * t) - 1) + b;
      &#125;
      return (c / 2) * (Math.sqrt(1 - (t -= 2) * t) + 1) + b;
    &#125;,
  &#125;,
&#125;;
</code></pre>
<h4 id="带左右按扭的自动切换轮播效果"><a href="#带左右按扭的自动切换轮播效果" class="headerlink" title="带左右按扭的自动切换轮播效果"></a>带左右按扭的自动切换轮播效果</h4><ul>
<li>思路</li>
</ul>
<ol>
<li>首先布局</li>
<li>实现自动轮播<blockquote>
<ul>
<li>自动移动：定时器</li>
<li>匀速移动：引用上面的<code>move</code>动画</li>
<li>播完最后一个无缝衔接到第一个<ul>
<li>把第一个克隆到最后</li>
<li>给<code>move</code>函数设置一个回调函数</li>
</ul>
</li>
</ul>
</blockquote>
</li>
</ol>
<pre><code>  //克隆第一个li到最后
  var liLast = liList[0].cloneNode(true);
  wrap.appendChild(liLast);
&gt;
  move(wrap, [&#123; left: targetDistance + &quot;px&quot; &#125;], function () &#123;
    if (currentIndex &gt;= len) &#123;
      wrap.style.left = &quot;0px&quot;;
      currentIndex = 0;
    &#125;
  &#125;);
</code></pre>
<blockquote>
<ul>
<li>当播到最后一个时，分页器显示第一个按钮<ul>
<li>在定时器内分情况</li>
</ul>
</li>
</ul>
</blockquote>
<pre><code>if (currentIndex &gt;= len) &#123;
  //分页器变化
  currentSpan.classList.remove(&quot;active&quot;);
  spans[0].classList.add(&quot;active&quot;);
  currentSpan = spans[0];
&#125; else &#123;
  //分页器变化
  currentSpan.classList.remove(&quot;active&quot;);
  spans[currentIndex].classList.add(&quot;active&quot;);
  currentSpan = spans[currentIndex];
&#125;
</code></pre>
<ol start="3">
<li>分页器的处理<blockquote>
<ul>
<li>鼠标移到分页器上，停止自动播放，鼠标移开，继续自动播放<ul>
<li>用for循环，给每个span添加<code>onmouseover</code>和<code>onmouseout</code>事件</li>
<li>给每个span添加下标</li>
</ul>
</li>
<li>鼠标点击到哪个span，该span变色，并播放对应的图片<ul>
<li>给<code>button</code>添加事件，用事件委托的方式</li>
<li>点击哪个span，就给它加上<code>active</code>样式</li>
<li>根据<code>span</code>的下标，得到相应图片的下标，移动<code>left</code></li>
</ul>
</li>
</ul>
</blockquote>
</li>
</ol>
<pre><code>for (var i = 0; i &lt; len; i++) &#123;
  spans[i].index = i; //给span加下标
  // 给span添加事件，鼠标放在分页器上就停止自动播放
  spans[i].onmouseover = function () &#123;
    clearInterval(timer);
  &#125;;
  //给span添加事件，鼠标移开就继续播放
  spans[i].onmouseout = function () &#123;
    autoplay();
  &#125;;
&#125;
&gt;
//点击哪个span就播放相应的图片
button.onclick = function (e) &#123;
  var target = e.target;
  var targetTag = target.tagName.toLowerCase();
  if (targetTag !== &quot;span&quot;) return;
  //如果点的是span,对应的span变色·
  currentIndex = target.index;
  currentSpan.classList.remove(&quot;active&quot;);
  spans[currentIndex].classList.add(&quot;active&quot;);
  currentSpan = spans[currentIndex];
  //改变left,跳转到对应的图片
  var currentDistance = -currentIndex * liWidth;
  move(wrap, [&#123; left: currentDistance + &quot;px&quot; &#125;]);
&#125;;
</code></pre>
<ol start="4">
<li>处理左右按钮<blockquote>
<ul>
<li>鼠标移动到按钮上时，停止自动轮播；移开时，继续播放<ul>
<li>和分页器是一样的处理方式</li>
</ul>
</li>
<li>点击按钮，切换到上一张和下一张<blockquote>
<p>向上切换和向下切换有区别</p>
</blockquote>
</li>
<li>向下切换：<ul>
<li><code>currentIndex++</code></li>
<li>再改变分页器和图片容器的<code>left</code>(写成一个向下切换的函数)</li>
</ul>
</li>
<li>向上切换：<ul>
<li><code>currentindex--</code></li>
<li>当下标为0时，拉回到克隆的最后一张，<code>currentIdex=len</code></li>
<li>改变图片容器的<code>left</code></li>
</ul>
</li>
</ul>
</blockquote>
</li>
</ol>
<pre><code>//处理向下按钮
 next.onmouseover = function () &#123;
   clearInterval(timer);
 &#125;;
 next.onmouseout = function () &#123;
   autoplay();
 &#125;;
 next.onclick = function () &#123;
   currentIndex++;
   toNext();
 &#125;;
 //处理向上按钮
 prev.onmouseover = function () &#123;
   clearInterval(timer);
 &#125;;
 prev.onmouseout = function () &#123;
   autoplay();
 &#125;;
 prev.onclick = function () &#123;
   currentIndex--;
   if (currentIndex &lt; 0) &#123;
     //播到第一张时，拉回最后一张
     wrap.style.left = -liWidth * len + &quot;px&quot;;
     currentIndex = len - 1;
   &#125;
   currentSpan.classList.remove(&quot;active&quot;);
   spans[currentIndex].classList.add(&quot;active&quot;);
   currentSpan = spans[currentIndex];
   var currentDistance = -currentIndex * liWidth;
   move(wrap, [&#123; left: currentDistance + &quot;px&quot; &#125;]);
 &#125;;
</code></pre>
<ul>
<li><code>toNext()</code>函数<blockquote>
<ul>
<li>和自动轮播效果的代码是一样的，所以把它摘出来</li>
</ul>
</blockquote>
</li>
</ul>
<pre><code>//向下播放函数
 function toNext() &#123;
   if (currentIndex &gt;= len) &#123;
     //分页器变化
     currentSpan.classList.remove(&quot;active&quot;);
     spans[0].classList.add(&quot;active&quot;);
     currentSpan = spans[0];
   &#125; else &#123;
     //分页器变化
     currentSpan.classList.remove(&quot;active&quot;);
     spans[currentIndex].classList.add(&quot;active&quot;);
     currentSpan = spans[currentIndex];
   &#125;
&gt;
  var targetDistance = -currentIndex * 990; //获取移动距离
   // wrap.style.left = targetDistance + &quot;px&quot;;
  move(wrap, [&#123; left: targetDistance + &quot;px&quot; &#125;], function () &#123;
    if (currentIndex &gt;= len) &#123;
      wrap.style.left = &quot;0px&quot;;
      currentIndex = 0;
    &#125;
  &#125;);
&#125;
</code></pre>
<ol start="5">
<li>优化<blockquote>
<ul>
<li>当上一个动画没结束时，点击无效<ul>
<li>声明一个<code>flag</code>，<code>flag=false</code>时表示动画结束了</li>
<li>什么时候动画结束？执行回调函数时</li>
</ul>
</li>
<li>给点击事件加<code> if (flag) return; flag = true;</code>，</li>
<li>加上回调函数</li>
</ul>
</blockquote>
</li>
</ol>
<pre><code>function () &#123;
  flag = false;
&#125;
</code></pre>
<ul>
<li>布局代码</li>
</ul>
<pre><code>&gt;&lt;style&gt;
  body,
  ul,
  li &#123;
    margin: 0;
    padding: 0;
  &#125;
  li &#123;
    list-style: none;
  &#125;
  .container &#123;
    position: relative;
    width: 990px;
    height: 460px;
    overflow: hidden;
    margin: 50px;
  &#125;
  .container .wrap &#123;
    position: absolute;
    left: 0;
    top: 0;
    width: 10000px;
    height: 460px;
  &#125;
  .container .wrap li &#123;
    float: left;
    width: 990px;
    height: 460px;
  &#125;
&gt;
   /* 分页器 */
  .buttons &#123;
    position: absolute;
    bottom: 20px;
    left: 0;
    width: 100%;
    height: 20px;
    text-align: center;
    font-size: 0;
  &#125;
  .buttons span &#123;
    display: inline-block;
    width: 15px;
    height: 15px;
    border-radius: 50%;
    background-color: #fff;
    margin: 0 3px;
      cursor: pointer;
    &#125;
    .buttons span.active &#123;
      background-color: orange;
    &#125;
&gt;
  /* 左右按钮 */
  .container .prev,
  .container .next &#123;
    position: absolute;
    top: 50%;
    transform: translateY(-50%);
    width: 41px;
    height: 70px;
    cursor: pointer;
    background-image: url(../src/images/icon-slides.png);
  &#125;
  .container .prev &#123;
    left: 0;
    background-position: -83px 0;
  &#125;
  .prev:hover &#123;
    background-position: 0;
  &#125;
  .container .next &#123;
    right: 0;
    background-position: -123px 0;
  &#125;
  .next:hover &#123;
    background-position: -41px 0;
  &#125;
&gt;&lt;/style&gt;
</code></pre>
<ul>
<li>JS代码<blockquote>
<ul>
<li>引用了<code>move.js</code>（前面封装的多属性限时动画）</li>
</ul>
</blockquote>
</li>
</ul>
<pre><code>&gt;&lt;div class=&quot;container&quot;&gt;
&gt;  &lt;!-- 轮播图 --&gt;
&gt;  &lt;ul class=&quot;wrap&quot;&gt;
&gt;    &lt;li&gt;&lt;img src=&quot;../src/images/1.jpg&quot; alt=&quot;&quot; /&gt;&lt;/li&gt;
&gt;    &lt;li&gt;&lt;img src=&quot;../src/images/2.jpg&quot; alt=&quot;&quot; /&gt;&lt;/li&gt;
&gt;    &lt;li&gt;&lt;img src=&quot;../src/images/3.jpg&quot; alt=&quot;&quot; /&gt;&lt;/li&gt;
&gt;    &lt;li&gt;&lt;img src=&quot;../src/images/4.jpg&quot; alt=&quot;&quot; /&gt;&lt;/li&gt;
&gt;  &lt;/ul&gt;
&gt;  &lt;!-- 分页器 --&gt;
&gt;  &lt;div class=&quot;buttons&quot;&gt;
&gt;    &lt;span class=&quot;active&quot;&gt;&lt;/span&gt;
&gt;    &lt;span&gt;&lt;/span&gt;
&gt;    &lt;span&gt;&lt;/span&gt;
&gt;    &lt;span&gt;&lt;/span&gt;
&gt;  &lt;/div&gt;
&gt;  &lt;!-- 左右按钮 --&gt;
&gt;  &lt;div class=&quot;prev&quot;&gt;&lt;/div&gt;
&gt;  &lt;div class=&quot;next&quot;&gt;&lt;/div&gt;
&gt;&lt;/div&gt;
&gt;&lt;script src=&quot;./move.js&quot;&gt;&lt;/script&gt;
&gt;&lt;script&gt;
  //获取元素
  var wrap = document.querySelector(&quot;.wrap&quot;);
  var liList = document.querySelectorAll(&quot;.wrap li&quot;);
  var button = document.querySelector(&quot;.buttons&quot;);
  var spans = document.querySelectorAll(&quot;.buttons span&quot;);
  var prev = document.querySelector(&quot;.prev&quot;);
  var next = document.querySelector(&quot;.next&quot;);
  var flag = false; // 表示当前没有元素在切换
  //克隆第一个li到最后
  var liLast = liList[0].cloneNode(true);
  wrap.appendChild(liLast);
  var liWidth = liList[0].offsetWidth;
  var len = liList.length;
  var currentIndex = 0; //记录轮播图下标
  var currentSpan = spans[0]; //记录当前分页器下标
  var timer = null; //定义定时器
  autoplay();
  //自动播放效果
  function autoplay() &#123;
    clearInterval(timer);
    timer = setInterval(function () &#123;
      currentIndex++;
      toNext();
    &#125;, 2000);
  &#125;
&gt;
  for (var i = 0; i &lt; len; i++) &#123;
    spans[i].index = i; //给span加下标
    // 给span添加事件，鼠标放在分页器上就停止自动播放
    spans[i].onmouseover = function () &#123;
      clearInterval(timer);
    &#125;;
    //给span添加事件，鼠标移开就继续播放
    spans[i].onmouseout = function () &#123;
      autoplay();
    &#125;;
  &#125;
  //点击哪个span就播放相应的图片
  button.onclick = function (e) &#123;
    var target = e.target;
    var targetTag = target.tagName.toLowerCase();
    if (flag) return;
     flag = true;
     if (targetTag !== &quot;span&quot;) return;
     //如果点的是span,对应的span变色·
     currentIndex = target.index;
     currentSpan.classList.remove(&quot;active&quot;);
     spans[currentIndex].classList.add(&quot;active&quot;);
     currentSpan = spans[currentIndex];
     //改变left,跳转到对应的图片
     var currentDistance = -currentIndex * liWidth;
     move(wrap, [&#123; left: currentDistance + &quot;px&quot; &#125;], function () &#123;
       flag = false;
     &#125;);
   &#125;;
&gt;
  //处理向下按钮
  next.onmouseover = function () &#123;
    clearInterval(timer);
  &#125;;
  next.onmouseout = function () &#123;
    autoplay();
  &#125;;
  next.onclick = function () &#123;
    if (flag) return;
    flag = true;
    currentIndex++;
    toNext();
  &#125;;
  //处理向上按钮
  prev.onmouseover = function () &#123;
    clearInterval(timer);
  &#125;;
  prev.onmouseout = function () &#123;
    autoplay();
  &#125;;
  prev.onclick = function () &#123;
    if (flag) return;
    flag = true;
    currentIndex--;
    if (currentIndex &lt; 0) &#123;
      //播到第一张时，拉回最后一张
      wrap.style.left = -liWidth * len + &quot;px&quot;;
      currentIndex = len - 1;
    &#125;
    currentSpan.classList.remove(&quot;active&quot;);
    spans[currentIndex].classList.add(&quot;active&quot;);
    currentSpan = spans[currentIndex];
    var currentDistance = -currentIndex * liWidth;
    move(wrap, [&#123; left: currentDistance + &quot;px&quot; &#125;], function () &#123;
      flag = false;
    &#125;);
  &#125;;
&gt;
  //向下播放函数
  function toNext() &#123;
    if (currentIndex &gt;= len) &#123;
      //分页器变化
      currentSpan.classList.remove(&quot;active&quot;);
      spans[0].classList.add(&quot;active&quot;);
      currentSpan = spans[0];
    &#125; else &#123;
      //分页器变化
      currentSpan.classList.remove(&quot;active&quot;);
      spans[currentIndex].classList.add(&quot;active&quot;);
      currentSpan = spans[currentIndex];
    &#125;
     var targetDistance = -currentIndex * 990; //获取移动距离
     // wrap.style.left = targetDistance + &quot;px&quot;;
    move(wrap, [&#123; left: targetDistance + &quot;px&quot; &#125;], function () &#123;
      flag = false;
      if (currentIndex &gt;= len) &#123;
        wrap.style.left = &quot;0px&quot;;
        currentIndex = 0;
      &#125;
    &#125;);
  &#125;
&gt;&lt;/script&gt;
</code></pre>
<h3 id="二、定时器延迟执行与丢帧问题"><a href="#二、定时器延迟执行与丢帧问题" class="headerlink" title="二、定时器延迟执行与丢帧问题"></a>二、定时器延迟执行与丢帧问题</h3><blockquote>
<ul>
<li>要了解定时器为什么会延迟执行和存在丢帧问题，就需要先了解下面几个问题</li>
</ul>
</blockquote>
<ol>
<li>屏幕刷新频率<blockquote>
<ul>
<li>屏幕刷新频率即图像在屏幕上更新的速度，也即屏幕上的图像<strong>每秒钟</strong>出现的次数，它的单位是赫兹（Hz）。</li>
<li>对于一般笔记本电脑，这个频率大概是 60Hz，可以在桌面上 <code>右键 —显示设置 — 高级显示设置 — 刷新频率</code>中查看和设置<blockquote>
<p>这个值的设定受屏幕分辨率、屏幕尺寸和显卡的影响，原则上设置成让眼睛看着舒适的值都行。</p>
</blockquote>
</li>
</ul>
</blockquote>
</li>
</ol>
<ul>
<li>常见的显示器有两种<blockquote>
<p>即 CRT 和 LCD， CRT 就是传统显示器，LCD 就是我们常说的液晶显示器。</p>
<ul>
<li>CRT 是一种使用<code>阴极射线管</code>的显示器，屏幕上的图形图像是由一个个因<code>电子束</code>击打而发光的<code>荧光点</code>组成，由于显像管内荧光粉受到电子束击打后发光的时间很短，所以电子束必须不断击打荧光粉使其持续发光，电子束每秒击打荧光粉的次数就是屏幕刷新频率。</li>
</ul>
</blockquote>
</li>
</ul>
<blockquote>
<ul>
<li>而对于 LCD 来说，则不存在刷新频率的问题，它根本就<strong>不需要刷新</strong>，因为 LCD 中每个像素都在持续不断地发光，直到不发光的电压改变并被送到控制器中，所以 LCD 不会有电子束击打荧光粉而引起的闪烁现象。</li>
</ul>
</blockquote>
<blockquote>
<ul>
<li>因此，当你对着电脑屏幕什么也不做的情况下，显示器也会以每秒 60 次的频率正在不断的更新屏幕上的图像。为什么你感觉不到这个变化？</li>
<li>那是因为人的眼睛有<code>视觉停留效应</code>，即前一副画面留在大脑的印象还没消失，紧接着后一副画面就跟上来了，这中间只间隔了 <code>16.7ms(1000/60 ≈ 16.7)</code>。</li>
<li>所以会让你误以为屏幕上的图像是静止不动的，而屏幕给你的这种感觉是对的，试想一下，如果刷新频率变成 1 次&#x2F;秒，屏幕上的图像就会出现严重的闪烁，这样就很容易引起眼睛疲劳、酸痛和头晕目眩等症状。</li>
</ul>
</blockquote>
<ol start="2">
<li><p>动画实现原理</p>
<blockquote>
<p>根据上面的原理我们知道，你眼前所看到图像正在以每秒60次的频率刷新，由于刷新频率很高，因此你感觉不到它在刷新，而动画本质就是要让人眼看到图像被刷新而引起变化的视觉效果，这个变化要以连贯的、平滑的方式进行过渡。<br>那怎么样才能做到这种效果呢 ?</p>
<ul>
<li>刷新频率为<code>60Hz</code>的屏幕每<code>16.7ms</code>刷新一次，我们在屏幕每次刷新前，将图像的位置向左移动一个像素，即1px，这样一来，屏幕每次刷出来的图像位置都比前一个要差 1px，因此你会看到图像在移动，由于我们人眼的视觉停留效应，当前位置的图像停留在大脑的印象还没消失，紧接着图像又被移到了下一个位置。</li>
<li>因此你才会看到图像在流畅的移动，这就是视觉效果上形成的动画。</li>
</ul>
</blockquote>
</li>
<li><p>setInterval 实现动画原理</p>
<blockquote>
<ul>
<li>setInterval 其实就是通过设置一个间隔时间来不断的改变图像的位置等属性，从而达到动画效果的。</li>
</ul>
</blockquote>
</li>
</ol>
<pre><code>setInterval(f, 20); // 每隔10ms 执行下回调函数 f
</code></pre>
<ul>
<li>setInterval 执行会出现延迟问题<blockquote>
<ul>
<li>setInterval的执行时间并不是确定的。在 Javascript 中， setInterval 任务被放进了<strong>异步队列</strong>中，只有当<strong>主线程</strong>上的任务执行完以后，才会去检查该队列里的任务是否需要开始执行，因此， setInterval 的实际执行时间一般要比其设定的时间<strong>晚</strong>一些。</li>
<li>setInterval的<strong>第二个参数的延时</strong>只能保证何时会把回调函数添加到任务队列，<strong>不能保证</strong>添加到任务队就会立即执行。能不能执行要看主线程是否空闲，同时前面是否还有任务在等待</li>
</ul>
</blockquote>
</li>
</ul>
<ol start="4">
<li>setTimeout 实现动画原理<blockquote>
<ul>
<li>setTimeout 是通过间隔一定时间执行动画<strong>回调函数</strong>，在回调函数执行完成后，再重新开一个 setTimeout 定时器执行下一次回调，重复上面过程。</li>
</ul>
</blockquote>
</li>
</ol>
<pre><code>function f() &#123;
  /* 要执行的动画代码 */
  // ....
  setTimeout(f, 20);
&#125;
setTimeout(f, 20);
</code></pre>
<blockquote>
<blockquote>
<p>注：</p>
</blockquote>
<ul>
<li><code>setTimeout</code>每次是在上一个动画执行完成后，再间隔相同时间，把定时器加入到<strong>任务队列</strong>等待执行。和 setInterval 一样都会存在延时问题。</li>
<li><strong>浏览器的计时</strong>也会存在不精准的问题，具体内容可参考官方教程</li>
</ul>
</blockquote>
<ol start="5">
<li>动画动画卡顿、抖动现象<blockquote>
<ul>
<li><code>setInterval</code> 和 <code>setTimeout</code> 会出现<strong>执行时间延时</strong>问题</li>
<li>再加上<code>刷新频率</code>受屏幕分辨率和屏幕尺寸的影响，因此不同设备的屏幕刷频率可能会不同</li>
<li>而 <code>setInterval</code>只能设置一个固定的时间间隔，这个时间不一定和屏幕的刷新时间相同。<br>以上两种情况都会导致<code>动画的执行步调</code>和<code>屏幕的刷新步调</code>不一致，从而引起<strong>丢帧现象</strong>，造成动画卡顿、抖动。</li>
</ul>
</blockquote>
</li>
</ol>
<ul>
<li><p>那为什么步调不一致就会引起丢帧呢？</p>
<blockquote>
<ul>
<li>首先要明白，<code>setInterval</code> 和 <code>setTimeout</code> 的执行只是在<strong>内存中对图像属性进行改变</strong>，这个变化必须要等到屏幕下次<strong>刷新时</strong>才会被更新到屏幕上。</li>
<li>如果两者的步调不一致，就可能会导致中间某一帧的操作被跨越过去，而直接更新下一帧的图像</li>
</ul>
</blockquote>
</li>
<li><p>案例分析</p>
<blockquote>
<p>假设屏幕每隔 <code>16.7ms</code> 刷新一次，而 setInterval 每隔 <code>10ms</code> 设置图像向左移动 <code>1px</code>， 就会出现如下<br><strong>绘制过程</strong></p>
<ul>
<li>1、第<code>0ms</code>屏幕未刷新，等待中，<code>setInterval</code>也未执行，等待中；</li>
<li>2、第<code>10ms</code>屏幕未刷新，等待中，<code>setInterval</code>开始执行并设置图像属性<code>left = 1px</code>;</li>
<li>3、第<code>16.7ms</code>屏幕开始刷新，屏幕上的图像向左移动了 <code>1px</code>，<code>setInterval</code> 未执行，继续等待中；</li>
<li>4、第<code>20ms</code>屏幕未刷新，等待中，<code>setInterval</code>开始执行并设置图像属性 <code>left = 2px;</code></li>
<li>5、 第<code>30ms</code>屏幕未刷新，等待中，<code>setInterval</code>开始执行并设置图像属性<code>left = 3px;</code></li>
<li>6、第<code>33.4ms</code>屏幕开始刷新，屏幕上的图像向左移动了 <code>3px</code>，<code>setInterval</code>未执行，继续等待中；</li>
</ul>
</blockquote>
</li>
</ul>
<blockquote>
<blockquote>
<p>注：</p>
<ul>
<li>从上面的绘制过程中可以看出，屏幕<strong>没有更新</strong><code>left = 2px</code>的那一帧画面</li>
<li>图像直接从1px的位置跳到了3px的的位置</li>
<li>这就是丢帧现象，这种现象就会引起动画卡顿</li>
</ul>
</blockquote>
</blockquote>
<ol start="6">
<li>总结：定时器执行动画卡顿、抖动原理<blockquote>
<ul>
<li><code>定时器的执行时间</code>并不是一定会按预期时间执行，所以会造成<strong>动画延迟执行</strong>。</li>
<li>定时器的<code>执行频率</code>和屏幕的<code>刷新频率</code>不一样，会造成<strong>丢帧现象，引起动画卡顿</strong>。</li>
<li>当然还有<strong>各个浏览器的计时器精度</strong>也程很大差异，不能精确到 1 毫秒内<br>比如：</li>
<li>Chrome 的计时器精度为 4 毫秒</li>
<li>Firefox 和 Safari 计时器精度约为 10 毫秒<blockquote>
<p>为了解决上面定时器存在的问题，出现了一个新的方法 <code>requestAnimationFrame</code></p>
</blockquote>
</li>
</ul>
</blockquote>
</li>
</ol>
<h3 id="三、requestAnimationFrame"><a href="#三、requestAnimationFrame" class="headerlink" title="三、requestAnimationFrame"></a>三、requestAnimationFrame</h3><blockquote>
<p>我们都知道：浏览器是知道<code>CSS3</code>的<code>transition</code> 和 &#96;animation动画什么时候开始，并据此计算出正确的时间间隔，到时间就去刷新用户界面。</p>
<ul>
<li>但是对于 JS 动画，浏览器并不知道动画什么时候开始，如果我们能<strong>让浏览器知道动画什么时候开始，然后开始刷新屏幕</strong>。</li>
<li>这样不就出现丢帧问题了吗？</li>
</ul>
</blockquote>
<blockquote>
<p><code>requestAnimationFrame</code>方法就可以解决这个问题</p>
<ul>
<li><code>requestAnimationFrame</code>最大的优势是由系统(浏览器)来决定回调函数的<strong>执行时机</strong></li>
<li>具体一点讲，如果屏幕刷新率是60Hz，那么回调函数就每<code>16.7ms</code>被执行一次</li>
<li>如果刷新率是<code>75Hz</code>，那么这个时间间隔就变成了<code>1000/75 = 13.3ms</code></li>
<li>换句话说就是，<code>requestAnimationFrame</code>的步伐跟着系统的刷新步伐走</li>
<li>它能保证回调函数在屏幕<strong>每一次的刷新间隔中</strong>只被执行一次，这样就不会引起丢帧现象，也不会导致动画出现卡顿的问题。</li>
</ul>
</blockquote>
<ol>
<li>requestAnimationFrame 用法<blockquote>
<ul>
<li><code>window.requestAnimationFrame()</code>告诉浏览器——你希望执行一个动画，并且要求浏览器在<strong>下次重绘之前</strong>调用指定的回调函数更新动画。</li>
<li>该方法需要传入一个回调函数作为参数，该回调函数会在浏览器下一次重绘之前执行</li>
<li><code>window.requestAnimationFrame()</code>的返回值是它的ID</li>
</ul>
</blockquote>
</li>
</ol>
<pre><code>var timer = window.requestAnimationFrame(callback);
// callback 下一次重绘之前更新动画帧所调用的函数
// timer 一个整数，表示请求ID 是回调列表中唯一的标识
</code></pre>
<blockquote>
<blockquote>
<p>requestAnimationFrame 方法只会执行一次</p>
</blockquote>
</blockquote>
<ol start="2">
<li>requestAnimationFrame 实现动画原理</li>
</ol>
<pre><code>window.requestAnimationFrame(f);
function f() &#123;
  /* 动画执行代码 */
  if (条件为真) &#123;
    window.requestAnimationFrame(f);
  &#125;
&#125;
</code></pre>
<ol start="3">
<li>cancelAnimationFrame<blockquote>
<p><code>cancelAnimationFrame</code>方法用来<strong>取消</strong><code>requestAnimationFrame</code>方法添加的的任务。</p>
</blockquote>
</li>
</ol>
<pre><code>var requestId = requestAnimationFrame(fn); // 第一次执行
cancelAnimationFrame(requestId);
function fn() &#123;
  console.log(&quot;我不会出来&quot;);
&#125;
</code></pre>
<ol start="4">
<li><p>requestAnimationFrame 注意事项</p>
<blockquote>
<ul>
<li>为了提高性能和电池寿命，因此在大多数浏览器里，当<code>requestAnimationFrame()</code>运行在<strong>后台标签页</strong>或者隐藏的<code>&lt;iframe&gt;</code>里时，<code>requestAnimationFrame()</code>会被<strong>暂停调用</strong>以提升性能和电池寿命。</li>
</ul>
</blockquote>
</li>
<li><p>requestAnimationFrame 方法实现动画</p>
</li>
</ol>
<pre><code>&gt;&lt;style&gt;
  .box &#123;
    width: 100px;
    height: 100px;
    background-color: red;
    position: absolute;
    left: 0;
  &#125;
&gt;&lt;/style&gt;
&gt;
&gt;&lt;div class=&quot;box&quot;&gt;&lt;/div&gt;
&gt;&lt;script&gt;
  var box = document.querySelector(&quot;.box&quot;);
  requestAnimationFrame(fn); // 第一次执行
  function fn() &#123;
    var left = box.offsetLeft + 3;
    if (left &gt; 600) left = 600;
    box.style.left = left + &quot;px&quot;;
    if (left &lt; 600) &#123;
      requestAnimationFrame(fn); // 没有有达到目标，再次执行
    &#125;
  &#125;
&gt;&lt;/script&gt;
</code></pre>
<ol start="6">
<li>优雅降级 - 处理兼容问题<blockquote>
<ul>
<li>目前所有浏览器都支持<code>requestAnimationFrame</code>这个不带前缀的方法，但考虑有些浏览器的旧版本，还需要添加前缀，所以需要处理下兼容问题。</li>
</ul>
</blockquote>
</li>
</ol>
<pre><code>window.requestAnimFrame = (function () &#123;
  return (
    window.requestAnimationFrame ||
    window.webkitRequestAnimationFrame ||
    window.mozRequestAnimationFrame ||
    window.oRequestAnimationFrame ||
    window.msRequestAnimationFrame ||
    function (callback) &#123;
      window.setTimeout(callback, 1000 / 60);
    &#125;
  );
&#125;)();
</code></pre>
<h3 id="四、函数节流-经典面试题"><a href="#四、函数节流-经典面试题" class="headerlink" title="四、函数节流(经典面试题)"></a>四、函数节流(经典面试题)</h3><blockquote>
<p><strong>什么是函数节流：</strong></p>
<ul>
<li>不管事件触发有多频繁，都会保证在规定时间内执行一次真正的事件处理函数<br><strong>函数节流原理：</strong></li>
<li>通过判断是否到达一定时间，如果<code>时间 &gt;= 规定时间周期</code>，才会触发函数<br><strong>函数节流优点：</strong></li>
<li>降低函数执行的频率，从而达到节省计算资源，减少性能消耗</li>
</ul>
</blockquote>
<h4 id="优化JS结合CSS3的transition实现动画"><a href="#优化JS结合CSS3的transition实现动画" class="headerlink" title="优化JS结合CSS3的transition实现动画"></a>优化JS结合CSS3的transition实现动画</h4><blockquote>
<ul>
<li>如果用户<strong>频繁的点击</strong>开始动画按扭，那方块就会在未达到终点状态之间来回切换</li>
<li>如果我们希望在动画没有到达终点状态之前，不管用户点击多少次，都不会执行再执行新的动画。</li>
<li>只有动画到达终点状态后，用户再次点击，才会再执行新的动画</li>
</ul>
</blockquote>
<ol>
<li>基础版</li>
</ol>
<ul>
<li>设置一个锁，上锁后：在动画完成之前，用户点击无效<blockquote>
<ul>
<li>定义一个变量<code>lock</code>与定时器配合，变量 <code>lock</code> 相当于一把锁，定时器用来记录时间。</li>
<li>刚开始变量<code>lock = false</code>，表示锁是打开的，可以执行事件处理函数中代码，在执行时立即设置<code>lock = true</code></li>
<li><code>lock = true</code>，相当于当前锁是关上的，不管事件触发多少次，都不会做任何操作</li>
<li>等到定时器时间一到，在定时器中设置<code>lock = false</code>，相当把锁打开，下一次事件触发，则又恢复正常。</li>
<li>重复上面过程，就可以达到<strong>节流</strong>效果，相当于事件处理函数在1000ms内只会执行一次</li>
</ul>
</blockquote>
</li>
</ul>
<pre><code> var button = document.querySelector(&quot;.button&quot;);
 var box = document.querySelector(&quot;.box&quot;);
 var flag = false; //true表示样式还没加上去，还在原地
 var lock = false; //表示未锁上
 button.onclick = function () &#123;
   if (lock) return; //锁上时，不能进
   lock=true;//动画开始后就上锁
&gt;
 //如果flag=true,则移除样式
 if (flag) &#123;
   box.classList.remove(&quot;active&quot;);
   flag = false;
 &#125; else &#123;
   //如果flag=false,则添加样式
   box.classList.add(&quot;active&quot;);
   flag = true;
 &#125;
&gt;
  timer = setTimeout(function () &#123;
    lock=false; //动画结束后，开锁
  &#125;, 1000);
&#125;;
</code></pre>
<ol start="2">
<li>第一次优化<blockquote>
<ul>
<li>我们把上面的<code>lock</code>变量消除掉，直接用 <code>timer</code>变量来代替。</li>
<li>代码中，两处<code>lock = false</code>的地方，用<code>timer = null;</code>替换, 表示当前锁是开的, 可以执行事件处理函数</li>
<li>把<code>if(lock)</code>换成 <code>if(timer)</code> ，如果timer有值，表示当前锁是关着的，不能再次执行事件处理函数</li>
<li>去掉用来保存定时器返回值 <code>timer</code>变量前面的<code>var</code>，因为<code>timer</code>在上面改成全局中声明</li>
</ul>
</blockquote>
</li>
</ol>
<pre><code> var button = document.querySelector(&quot;.button&quot;);
 var box = document.querySelector(&quot;.box&quot;);
 var flag = false; //true表示样式还没加上去，还在原地
 var timer = null; //定时器不存在时，表示未锁上
 button.onclick = function () &#123;
   if (timer) return; //锁上时，不能进
&gt;
 //如果flag=true,则移除样式
 if (flag) &#123;
   box.classList.remove(&quot;active&quot;);
   flag = false;
 &#125; else &#123;
   //如果flag=false,则添加样式
   box.classList.add(&quot;active&quot;);
   flag = true;
 &#125;
&gt;
  //动画开始后，定时器启动，即上锁
  timer = setTimeout(function () &#123;
    timer = null; //动画结束后，开锁
  &#125;, 1000);
&#125;;
</code></pre>
<ol start="3">
<li>第二次优化：封装节流函数<blockquote>
<ul>
<li><code>move</code>为真正的事件处理函数</li>
<li><code>throttle</code>是用来处理节流的函数</li>
<li><code>timer</code>这个变量不能放在全局作用域下,要<strong>改写</strong>到<code>throttle</code>函数内部才算是完美的。</li>
<li><strong>定时器的时间</strong>不能固定，可以改写成参数，让用户自己来决定</li>
<li><strong>事件处理函数</strong>也不能固定死，可以改写成参数，让用户自己来决定</li>
</ul>
</blockquote>
</li>
</ol>
<pre><code> var button = document.querySelector(&quot;.button&quot;);
 var box = document.querySelector(&quot;.box&quot;);
 var flag = false; //true表示样式还没加上去，还在原地
 button.onclick = throttle(move, 1000);
 //相当于：
 button.onclick =function () &#123;
  if (timer) return; //锁上时，不能进
  fn(); //调用函数，使其运动
  //动画开始后，定时器启动，即上锁
  timer = setTimeout(function () &#123;
    timer = null; //动画结束后，开锁
  &#125;, delay);
&#125;;
&gt;
&gt;/**
&gt; * throttle 节流函数
&gt; * fn 事件处理函数
&gt; * delay 延迟时间
&gt; */
 function throttle(fn, delay = 50) &#123;
   var timer = null; //定时器不存在时，表示未锁上
   return function () &#123;
     if (timer) return; //锁上时，不能进
     fn(); //调用函数，使其运动
     //动画开始后，定时器启动，即上锁
     timer = setTimeout(function () &#123;
       timer = null; //动画结束后，开锁
     &#125;, delay);
   &#125;;
 &#125;
 //点击事件，需要处理的代码
 function move() &#123;
   //如果flag=true,则移除样式
   if (flag) &#123;
     box.classList.remove(&quot;active&quot;);
     flag = false;
   &#125; else &#123;
     //如果flag=false,则添加样式
     box.classList.add(&quot;active&quot;);
     flag = true;
   &#125;
 &#125;
</code></pre>
<ol start="4">
<li>第三次优化<blockquote>
<ul>
<li>以上事件处理函数<code>move</code>中的<code>this</code>和事件对象<code>e</code>是有问题的</li>
<li><code>onclick</code>原本调用的应该是<code>move</code>函数，但封装后，<code>fn()</code>直接调用，内部 <code>this</code> 肯定指向的是 <code>window</code>，同时事件对象 <code>e</code> 被丢失了</li>
</ul>
<blockquote>
<p>还有一个问题，就是<code>fn()</code>事件处理函数的<strong>位置问题</strong>，他是写在定时器前面，还是后面，还是定时器里面呢？</p>
</blockquote>
<ul>
<li>如果 fn() 写在定时器后面，相对来说没有什么问题，只是定时器会先计时，再执行fn()</li>
<li>如果fn()写在定时器前面，那会先执行事件处理函数，再定时器计时，那<strong>最终每次间隔时间比预期的长些</strong>，如果fn()执行时间较长，会达不到节流效果。</li>
<li>如果fn()写在定时器里面，那要等到计时器到达时间后才开始执行fn()，这样就会造成<strong>第一次fn()函数要在计时器到达到才执行</strong>。（针对<strong>高频事件</strong>，<code>delay</code> 的时间特别小，这个影响可以忽略不计，但如果 <code>delay</code> 的时间特别长，那这个影响就很明显了，后面用案例演示）</li>
<li>而我们所说的节流操作主要针对的就是<strong>高频时间</strong>，即 <code>delay</code>的时间特别小，所以面试中，各大网站上流行的面试题答案都是基于这个版本的。<blockquote>
<p>因此，<code>fn.apply(self, args);</code>写在定时器里面，只适合高频时间；如果是低频，就把<code>fn.apply(self, args);</code>写在定时器后面</p>
</blockquote>
</li>
</ul>
</blockquote>
</li>
</ol>
<pre><code>function throttle(fn, delay = 50) &#123;
  var timer = null; //定时器不存在时，表示未锁上
  return function () &#123;
    if (timer) return; //锁上时，不能进
    //动画开始后，定时器启动，即上锁
    var self = this;//将调用事件处理函数的this传过去
    var args = arguments;//将事件对象e传过去
    timer = setTimeout(function () &#123;
      fn.apply(self, args); //只适合高频函数，调用函数，使其运动
      timer = null; //动画结束后，开锁
    &#125;, delay);
  &#125;;
&#125;
 //点击事件，需要处理的代码
 function move() &#123;
   //如果flag=true,则移除样式
   if (flag) &#123;
     box.classList.remove(&quot;active&quot;);
     flag = false;
   &#125; else &#123;
     //如果flag=false,则添加样式
     box.classList.add(&quot;active&quot;);
     flag = true;
   &#125;
 &#125;
</code></pre>
<blockquote>
<ul>
<li>根据前面的优化，我们可以得到封装好的节流函数</li>
</ul>
</blockquote>
<h4 id="ES5-版本-节流函数"><a href="#ES5-版本-节流函数" class="headerlink" title="ES5 版本 - 节流函数"></a>ES5 版本 - 节流函数</h4><blockquote>
<ul>
<li><code>ES5</code>版本的定时器中的回调函数，它的this指向的是<code>window</code>，<code>arguments</code>也指的是回调函数的</li>
<li>所以要用变量把它们存起来再传过去</li>
</ul>
</blockquote>
<pre><code>&gt;/**
&gt; * throttle 节流函数
&gt; * fn 事件处理函数
&gt; * delay 执行事件处理函数的间隔时间
&gt; */
function throttle(fn, delay = 20) &#123;
  var timer = null; // null表示当前锁是打开的，没有锁，可以执行事件处理函数中的代码
&gt;
  return function () &#123;
    if (timer) return;
    var self = this; // 保存this 绑定事件的对象
    var args = arguments; // 保存arguments 主要用来获取事件对象 e
    // 定时器计时，用来开锁
    timer = setTimeout(function () &#123;
      fn.apply(self, args); // 事件处理函数
      timer = null; // 开锁
    &#125;, delay);
    //fn.apply(self, args); // 事件处理函数
  &#125;;
&#125;
</code></pre>
<h4 id="ES6-版本-节流函数"><a href="#ES6-版本-节流函数" class="headerlink" title="ES6 版本 - 节流函数"></a>ES6 版本 - 节流函数</h4><blockquote>
<ul>
<li><code>ES6</code>版本的节流函数用的是箭头函数的<code>setTimeout</code>，这个版本的定时器没有相应的<code>this</code>和<code>arguments</code></li>
<li>因此不需要用变量把它们存起来再传过去</li>
</ul>
</blockquote>
<pre><code>&gt;/**
&gt; * throttle 节流函数
&gt; * fn 事件处理函数
&gt; * delay 执行事件处理函数的间隔时间
&gt; */
function throttle(fn, delay = 20) &#123;
  var timer = null; // null表示当前锁是打开的，没有锁，可以执行事件处理函数中的代码
&gt;
  return function () &#123;
    if (timer) return;
    // 定时器计时，用来开锁
    timer = setTimeout(() =&gt; &#123;
      fn.apply(this, arguments); // 箭头函数没有自己的this和arguments
      timer = null; // 开锁
    &#125;, delay);
  &#125;;
&#125;
</code></pre>
<h4 id="节流函数的应用场景："><a href="#节流函数的应用场景：" class="headerlink" title="节流函数的应用场景："></a>节流函数的应用场景：</h4><blockquote>
<ul>
<li>当一个事件触发的时间特别短时，就会频繁的触发事件处理函数，我们需要通过节流函数来限止执行的频率。</li>
<li>比如：<code>mousemove</code>、<code>mousedown</code>、<code>keydown</code>、<code>scroll</code>等事件，他们的触发时间特别短。我们可以通过节流函数来限止，在一定时间内只能执行一次</li>
</ul>
</blockquote>
<ol>
<li>案例1：对<code>mousemove</code>事件处理函数执行节流操作——高频<blockquote>
<ul>
<li>接下来我们对<code>mousemove</code>事件处理函数执行节流操作，限止其在1000ms内只能执行一次</li>
<li>即<code>mousemove</code>事件频繁触发，那事件处理函数也只会每间隔1000ms才会执行一次</li>
</ul>
</blockquote>
</li>
</ol>
<blockquote>
<p><strong>节流实现原理</strong></p>
<ul>
<li>用定时器作为锁，如果定时器在运行，表示当前锁是关着的，不能再次执行事件处理函数</li>
</ul>
</blockquote>
<ul>
<li>用前面封装好的节流函数，来对<code>mousemove</code>事件处理函数执行节流操作</li>
</ul>
<pre><code>&gt;&lt;script src=&quot;./throttle.js&quot;&gt;&lt;/script&gt;
&gt;&lt;script&gt;
  // document.onmousemove = fn;//未节流
  document.onmousemove = throttle(fn, 1000);
  var i = 0;
  function fn() &#123;
    console.log(i++);
  &#125;
&gt;&lt;/script&gt;
</code></pre>
<ol start="2">
<li>案例2：规定时间内只能操作一次——低频<blockquote>
<ul>
<li>这个案例主要是用来演示上面提到事件处理函数放在<strong>定时器里面与外面</strong>的区别</li>
<li>我们希望点击发送按扭，就执行一次回调函数，然后间隔<code>1s </code>后，再次点击发送按扭才会再次执行回调函数。如果下一次点击时间离上一次点击时间<code>&lt; 1s</code>，就啥也不做。</li>
</ul>
</blockquote>
</li>
</ol>
<pre><code>&gt;&lt;button class=&quot;send&quot;&gt;发送&lt;/button&gt;
&gt;&lt;script&gt;
  var send = document.querySelector(&quot;.send&quot;);
  send.onclick = throttle(fn, 1000);
&gt;
  function fn() &#123;
    console.log(&quot;111&quot;);
  &#125;
&gt;
  function throttle(fn, delay = 50) &#123;
    var timer = null; //null表示锁是打开的
    return function () &#123;
      if (timer) return; //如果定时器还存在，就不能进
      var self = this;
      var args = arguments;
      timer = setTimeout(function () &#123;
        timer = null;
      &#125;, delay);
      fn(this, args);
    &#125;;
  &#125;
&gt;&lt;/script&gt;
</code></pre>
<h3 id="五、CSS3动画效果开发"><a href="#五、CSS3动画效果开发" class="headerlink" title="五、CSS3动画效果开发"></a>五、CSS3动画效果开发</h3><blockquote>
<ul>
<li>在前面我们已经学习了如何利用<strong>纯JS</strong>来实现动画效果，如果实现相对较简单的动画JS肯定是没什么问题，但如果遇到相对复杂的动画，用 JS 实现起来还是很麻烦的。</li>
<li>我们知道，<code>CSS3</code>的<code>transition</code>可以实现过渡动画，<code>animation</code>可以实现相对复杂的动画。而且<code>CSS3</code>动画是<strong>浏览器原生支持</strong>的，相对而言性能比 JS 实现会更好。</li>
</ul>
</blockquote>
<h4 id="过渡事件"><a href="#过渡事件" class="headerlink" title="过渡事件"></a>过渡事件</h4><table>
<thead>
<tr>
<th>事件</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td><code>transitionstart</code></td>
<td>该事件在 CSS 过渡<strong>实际开始时</strong>触发</td>
</tr>
<tr>
<td><code>transitionend</code></td>
<td>该事件在 CSS <strong>完成过渡后</strong>触发。</td>
</tr>
<tr>
<td><code>transitioncancel</code></td>
<td>该事件在 CSS 过渡动画<strong>取消时</strong>触发</td>
</tr>
<tr>
<td><code>transitionrun</code></td>
<td>该事件会在<strong>创建过渡动画前</strong>触发，即在 <code>transitionstart</code>前触发</td>
</tr>
</tbody></table>
<pre><code>&gt;&lt;style&gt;
  .box &#123;
    width: 100px;
    height: 100px;
    background-color: red;
    transition: width 1s ease;
  &#125;
  .box:hover &#123;
    width: 300px;
  &#125;
&gt;&lt;/style&gt;
&gt;
&gt;&lt;div class=&quot;box&quot;&gt;&lt;/div&gt;
&gt;&lt;script&gt;
  var box = document.querySelector(&quot;.box&quot;);
  box.addEventListener(&quot;transitionend&quot;, fn, false);
  function fn() &#123;
    // alert(&quot;动画结束&quot;);
    this.style.width = &quot;300px&quot;; // 动画结束后，停在目标点
  &#125;
&gt;&lt;/script&gt;
</code></pre>
<h4 id="动画事件"><a href="#动画事件" class="headerlink" title="动画事件"></a>动画事件</h4><blockquote>
<p>以下是常见的 CSS3 动画事件</p>
<table>
<thead>
<tr>
<th>事件</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>animationend</td>
<td>该事件在 CSS 动画结束播放时触发</td>
</tr>
<tr>
<td>animationiteration</td>
<td>该事件在 CSS 动画重复播放时触发</td>
</tr>
<tr>
<td>animationstart</td>
<td>该事件在 CSS 动画开始播放时触发</td>
</tr>
<tr>
<td>animationcancel</td>
<td>该事件在 CSS 动画意外中止时触发</td>
</tr>
</tbody></table>
</blockquote>
<blockquote>
<ul>
<li><code>animationiteration</code>的触发次数是<code>重复数-1</code>，因为第一次播放动画不算</li>
</ul>
</blockquote>
<pre><code>&gt;&lt;style&gt;
  .box &#123;
    width: 100px;
    height: 100px;
    background-color: skyblue;
    /* 动画名  动画时间  速度  延时  执行次数 */
    animation: move 2s ease 2s 3;
  &#125;
  @keyframes move &#123;
    0% &#123;
      width: 100px;
      height: 100px;
    &#125;
    50% &#123;
      width: 300px;
      height: 100px;
    &#125;
    100% &#123;
      width: 300px;
      height: 300px;
    &#125;
  &#125;
&gt;&lt;/style&gt;
&gt;
&gt;&lt;div class=&quot;box&quot;&gt;&lt;/div&gt;
&gt;&lt;script&gt;
  var box = document.querySelector(&quot;.box&quot;);
  box.addEventListener(&quot;animationstart&quot;, fn1, false);
  box.addEventListener(&quot;animationend&quot;, fn2, false);
  box.addEventListener(&quot;animationiteration&quot;, fn3, false);
  function fn1() &#123;
    console.log(&quot;动画开始前执行&quot;);
  &#125;
  function fn2() &#123;
    console.log(&quot;动画开始结束时执行&quot;);
  &#125;
  function fn3() &#123;
    console.log(&quot;动画重复执行时执行&quot;);
  &#125;
&gt;&lt;/script&gt;
</code></pre>
<h4 id="案例1：JS-结合-CSS3-的-transition-实现动画"><a href="#案例1：JS-结合-CSS3-的-transition-实现动画" class="headerlink" title="案例1：JS 结合 CSS3 的 transition 实现动画"></a>案例1：JS 结合 CSS3 的 transition 实现动画</h4><blockquote>
<p>我们希望利用 JS 与 CSS3 来实现以下动画效果，我们来看下<br><strong>实现的思路</strong></p>
<ul>
<li>整个运动过程中，方块的位置、宽、高、透明度都发生了变化</li>
<li>我们可以给方块添加 <code>transition</code> 过渡属性，让其支持过渡动画</li>
<li>然后在点击开始动画按扭时，动态添加相应的样式，那方块就会按下面效果动起来。</li>
</ul>
</blockquote>
<ol>
<li>基础版</li>
</ol>
<pre><code>&gt;&lt;style&gt;
  .box &#123;
    position: absolute;
    left: 50px;
    top: 50px;
    width: 100px;
    height: 100px;
    background-color: skyblue;
    opacity: 1;
    transition: all 1s ease;
  &#125;
  .active &#123;
    left: 300px;
    top: 300px;
    width: 200px;
    height: 200px;
    opacity: 0.3;
  &#125;
&gt;&lt;/style&gt;
&gt;&lt;button class=&quot;button&quot;&gt;开始动画&lt;/button&gt;
&gt;&lt;div class=&quot;box&quot;&gt;&lt;/div&gt;
&gt;&lt;script&gt;
  var button = document.querySelector(&quot;.button&quot;);
  var box = document.querySelector(&quot;.box&quot;);
  var flag = false; //true表示样式还没加上去，还在原地
  button.onclick = function () &#123;
    //如果flag=true,则移除样式
    if (flag) &#123;
      box.classList.remove(&quot;active&quot;);
      flag = false;
    &#125; else &#123;
      //如果flag=false,则添加样式
      box.classList.add(&quot;active&quot;);
      flag = true;
    &#125;
  &#125;;
&gt;&lt;/script&gt;
</code></pre>
<ol start="2">
<li>动画的优化<blockquote>
<ul>
<li>如果用户<strong>频繁的点击</strong>开始动画按扭，那方块就会在未达到终点状态之间来回切换</li>
<li>如果我们希望在动画没有到达终点状态之前，不管用户点击多少次，都不会执行再执行新的动画。</li>
<li>只有动画到达终点状态后，用户再次点击，才会再执行新的动画</li>
</ul>
</blockquote>
</li>
</ol>
<ul>
<li>解决方案一：节流函数<blockquote>
<ul>
<li>利用前面封装好的节流函数</li>
</ul>
</blockquote>
</li>
</ul>
<pre><code>function throttle(fn, delay = 50) &#123;
  var timer = null; //定时器不存在时，表示未锁上
  return function () &#123;
    if (timer) return; //锁上时，不能进
    //动画开始后，定时器启动，即上锁
    var self = this;//将调用事件处理函数的this传过去
    var args = arguments;//将事件对象e传过去
    timer = setTimeout(function () &#123;
      fn.apply(self, args); //只适合高频函数，调用函数，使其运动
      timer = null; //动画结束后，开锁
    &#125;, delay);
  &#125;;
&#125;
 //点击事件，需要处理的代码
 function move() &#123;
   //如果flag=true,则移除样式
   if (flag) &#123;
     box.classList.remove(&quot;active&quot;);
     flag = false;
   &#125; else &#123;
     //如果flag=false,则添加样式
     box.classList.add(&quot;active&quot;);
     flag = true;
   &#125;
 &#125;
</code></pre>
<ul>
<li>解决方案二：过渡事件<blockquote>
<ul>
<li>给<code>box</code>加<code>transitionend</code>事件，在过渡动画完成后，才能打开锁</li>
</ul>
</blockquote>
</li>
</ul>
<pre><code>&gt;&lt;script&gt;
  var button = document.querySelector(&quot;.button&quot;);
  var box = document.querySelector(&quot;.box&quot;);
  var flag = false; //true表示样式还没加上去，还在原地
  var lock = false; //false表示未上锁
  button.onclick = function () &#123;
    //如果上锁了就不能进
    if (lock) return;
    //进来之后上锁
    lock = true;
    //如果flag=true,则移除样式
    if (flag) &#123;
      box.classList.remove(&quot;active&quot;);
      flag = false;
    &#125; else &#123;
      //如果flag=false,则添加样式
      box.classList.add(&quot;active&quot;);
      flag = true;
    &#125;
  &#125;;
  box.addEventListener(
    &quot;transitionend&quot;,
    function () &#123;
      lock = false;
    &#125;,
    false
  );
&gt;&lt;/script&gt;
</code></pre>
<h4 id="案例2：二级伸缩菜单——低频"><a href="#案例2：二级伸缩菜单——低频" class="headerlink" title="案例2：二级伸缩菜单——低频"></a>案例2：二级伸缩菜单——低频</h4><ol>
<li><p>思路</p>
<blockquote>
<ul>
<li>使用事件委托</li>
<li>点击标题，拿到它后面的<code>ul</code><ul>
<li><code>var nextSibling = target.nextElementSibling;</code></li>
</ul>
</li>
<li>展开、收缩菜单<ul>
<li>定义一个变量<code>flag</code>来更新状态</li>
<li>改变<code>ul</code>的高度</li>
</ul>
</li>
<li>动态获取每个ul的高度<ul>
<li>先拿到<code>ul</code>的子元素，得到子元素的<code>length</code></li>
<li>再拿到第一个子元素的高度</li>
<li>总高度&#x3D;个数*单个高度；</li>
</ul>
</li>
</ul>
</blockquote>
</li>
<li><p>为了防止用户重复点击，造成抖动，所以要进行优化</p>
</li>
</ol>
<ul>
<li>CSS代码</li>
</ul>
<pre><code>&gt;&lt;style&gt;
  body,
  html,
  ul,
  li &#123;
    margin: 0;
    padding: 0;
  &#125;
  li &#123;
    list-style: none;
  &#125;
  a &#123;
    color: #000;
    text-decoration: none;
  &#125;
  .menu &#123;
    width: 200px;
    margin: 50px;
  &#125;
  .menu .title &#123;
    width: 100%;
    height: 30px;
    font-size: 20px;
    background-color: skyblue;
    color: #fff;
    cursor: pointer;
    text-indent: 1em;
    user-select: none;
  &#125;
  .menu ul &#123;
    height: 0;
    overflow: hidden;
  &#125;
  .menu ul li a &#123;
    text-indent: 2em;
    display: inline-block;
    width: 100%;
    height: 25px;
    border-bottom: 1px solid #ddd;
  &#125;
&gt;&lt;/style&gt;
&gt;
&gt;&lt;div class=&quot;menu&quot;&gt;
&gt;  &lt;div class=&quot;title&quot;&gt;菜单一&lt;/div&gt;
&gt;  &lt;ul&gt;
&gt;    &lt;li&gt;&lt;a href=&quot;&quot;&gt;首页&lt;/a&gt;&lt;/li&gt;
&gt;    &lt;li&gt;&lt;a href=&quot;&quot;&gt;免费公开课&lt;/a&gt;&lt;/li&gt;
&gt;    &lt;li&gt;&lt;a href=&quot;&quot;&gt;web前端&lt;/a&gt;&lt;/li&gt;
&gt;    &lt;li&gt;&lt;a href=&quot;&quot;&gt;JAVA&lt;/a&gt;&lt;/li&gt;
&gt;    &lt;li&gt;&lt;a href=&quot;&quot;&gt;大数据&lt;/a&gt;&lt;/li&gt;
&gt;  &lt;/ul&gt;
&gt;  &lt;div class=&quot;title&quot;&gt;菜单二&lt;/div&gt;
&gt;  &lt;ul&gt;
&gt;    &lt;li&gt;&lt;a href=&quot;&quot;&gt;免费公开课&lt;/a&gt;&lt;/li&gt;
&gt;    &lt;li&gt;&lt;a href=&quot;&quot;&gt;JAVA&lt;/a&gt;&lt;/li&gt;
&gt;    &lt;li&gt;&lt;a href=&quot;&quot;&gt;大数据&lt;/a&gt;&lt;/li&gt;
&gt;  &lt;/ul&gt;
&gt;  &lt;div class=&quot;title&quot;&gt;菜单三&lt;/div&gt;
&gt;  &lt;ul&gt;
&gt;    &lt;li&gt;&lt;a href=&quot;&quot;&gt;免费公开课&lt;/a&gt;&lt;/li&gt;
&gt;    &lt;li&gt;&lt;a href=&quot;&quot;&gt;web前端&lt;/a&gt;&lt;/li&gt;
&gt;    &lt;li&gt;&lt;a href=&quot;&quot;&gt;大数据&lt;/a&gt;&lt;/li&gt;
&gt;  &lt;/ul&gt;
&gt;&lt;/div&gt;
</code></pre>
<ul>
<li>JS代码——优化方案1：节流函数</li>
</ul>
<pre><code>&gt;&lt;script src=&quot;./throttle2.js&quot;&gt;&lt;/script&gt;
&gt;&lt;script&gt;
  //获取元素
  var menu = document.querySelector(&quot;.menu&quot;);
  //节流操作(把fn写在定时器后面)
  menu.onclick = throttle(fn, 300);
  //事件委托
  function fn(e) &#123;
    var target = e.target;
    var targetName = target.className;
    if (targetName !== &quot;title&quot;) return;
    //获取菜单的后一个HTML元素
    var nextSibling = target.nextElementSibling;
    //获取菜单的后一个HTML元素的子元素
    var children = nextSibling.children;
    //获取高度
    var height = children.length * children[0].offsetHeight;
    //动态改变ul的值
    if (target.flag) &#123;
      //如果flag=true,则收缩
      nextSibling.style.height = &quot;0px&quot;;
      target.flag = false; //更新状态
    &#125; else &#123;
      //如果flag=false,则展开
      nextSibling.style.height = height + &quot;px&quot;;
      target.flag = true; //更新状态
    &#125;
  &#125;
&gt;&lt;/script&gt;
</code></pre>
<ul>
<li>JS代码——优化方案2：过渡事件<blockquote>
<ul>
<li>给<code>ul</code>的CSS代码加上<code>transition</code>动画</li>
<li>声明一个变量，作为过渡动画的锁，只有动画完成了才能再一次进入</li>
<li>利用for循环，给每个ul加上<code>transitionend</code>事件，当动画结束时，开锁</li>
</ul>
</blockquote>
</li>
</ul>
<pre><code>.menu ul &#123;
  height: 0;
  overflow: hidden;
  transition: height 1s ease;
&#125;
&gt;&lt;script&gt;
 //获取元素
 var menu = document.querySelector(&quot;.menu&quot;);
 var oUL = document.querySelectorAll(&quot;.menu ul&quot;);
&gt;
 var lock = false; //false表示未上锁
&gt;
 menu.onclick = fn;
 //事件委托
 function fn(e) &#123;
   if (lock) return; //上锁了就不能进
   lock = true;
   var target = e.target;
   var targetName = target.className;
   if (targetName !== &quot;title&quot;) return;
   //获取菜单的后一个HTML元素
   var nextSibling = target.nextElementSibling;
   //获取菜单的后一个HTML元素的子元素
   var children = nextSibling.children;
   //获取高度
   var height = children.length * children[0].offsetHeight;
   //动态改变ul的值
   if (target.flag) &#123;
     //如果flag=true,则收缩
     nextSibling.style.height = &quot;0px&quot;;
     target.flag = false; //更新状态
   &#125; else &#123;
     //如果flag=false,则展开
     nextSibling.style.height = height + &quot;px&quot;;
     target.flag = true; //更新状态
   &#125;
 &#125;
 // 每个ul身上添加transitionend事件，当动画结束触发了transitionend事件时，开锁
 for (var i = 0; i &lt; oUL.length; i++) &#123;
   oUL[i].addEventListener(
     &quot;transitionend&quot;,
     function () &#123;
       lock = false; //开锁
     &#125;,
     false
   );
 &#125;
&gt;&lt;/script&gt;
</code></pre>
<h4 id="案例3：JS-结合-CSS3-实现转盘抽奖"><a href="#案例3：JS-结合-CSS3-实现转盘抽奖" class="headerlink" title="案例3：JS 结合 CSS3 实现转盘抽奖"></a>案例3：JS 结合 CSS3 实现转盘抽奖</h4><blockquote>
<p>涉及知识点</p>
<ul>
<li>抽奖盘布局</li>
<li>抽奖概率计算原理</li>
<li>transitionend 事件</li>
<li>css3 实现缓动动画</li>
<li>节流锁应用</li>
<li>其它：权重数组、数组 sort 方法排序、switch 用法、数组的 splice 方法</li>
</ul>
</blockquote>
<ol>
<li>CSS布局</li>
</ol>
<pre><code>&gt;&lt;style&gt;
  /* 初始化 */
  body,
  html &#123;
    margin: 0;
    padding: 0;
    height: 100%;
  &#125;
  /* 使转盘在中间 */
  body &#123;
    display: flex;
    align-items: center;
    justify-content: center;
  &#125;
  .luck-draw &#123;
    display: flex;
    align-items: center;
    justify-content: center;
    width: 300px;
    height: 300px;
    background-color: tomato;
    border-radius: 50%;
  &#125;
  /* 最终是使luck-panel转动 */
  .luck-draw .luck-panel &#123;
    width: 280px;
    height: 280px;
    border-radius: 50%;
    overflow: hidden;
    transform: rotate(-67.5deg);
    transition: transform 1s cubic-bezier(0.15, 0.79, 0.64, 0.97);
  &#125;
  /* 左边转盘 */
  .panel-left &#123;
    position: relative;
    float: left;
    width: 50%;
    height: 100%;
  &#125;
  .panel-left .prize-item &#123;
    position: absolute;
    top: 0;
    left: 0;
    transform-origin: right center;
  &#125;
  .panel-left .prize-item:nth-child(1) &#123;
    width: 100%;
    height: 100%;
    background-color: pink;
  &#125;
  .panel-left .prize-item:nth-child(2) &#123;
    width: 100%;
    height: 100%;
    background-color: rgb(155, 185, 215);
    transform: rotate(-45deg);
  &#125;
  .panel-left .prize-item:nth-child(3) &#123;
    width: 100%;
    height: 100%;
    background-color: rgb(181, 228, 179);
    transform: rotate(-90deg);
  &#125;
  .panel-left .prize-item:nth-child(4) &#123;
    width: 100%;
    height: 100%;
    background-color: rgb(197, 169, 228);
    transform: rotate(-135deg);
  &#125;
  /* 调整文字 */
  .panel-left .prize-item span &#123;
    position: absolute;
    top: 20px;
    right: 10px;
    transform: rotate(-24deg);
    user-select: none;
  &#125;
  /* 右边转盘 */
  .panel-right &#123;
    position: relative;
    float: left;
    width: 50%;
    height: 100%;
    overflow: hidden;
  &#125;
  .panel-right .prize-item &#123;
    position: absolute;
    top: 0;
    right: 0;
    transform-origin: left center;
  &#125;
  .panel-right .prize-item:nth-child(1) &#123;
    width: 100%;
    height: 100%;
    background-color: rgb(241, 233, 166);
  &#125;
  .panel-right .prize-item:nth-child(2) &#123;
    width: 100%;
    height: 100%;
    background-color: rgb(234, 148, 211);
    transform: rotate(-45deg);
  &#125;
  .panel-right .prize-item:nth-child(3) &#123;
    width: 100%;
    height: 100%;
    background-color: rgb(232, 119, 88);
    transform: rotate(-90deg);
  &#125;
  .panel-right .prize-item:nth-child(4) &#123;
    width: 100%;
    height: 100%;
    background-color: #fff;
    transform: rotate(-135deg);
  &#125;
  .panel-right .prize-item span &#123;
    position: absolute;
    bottom: 20px;
    left: 8px;
    transform: rotate(155deg);
    user-select: none;
  &#125;
  /* 抽奖按钮 */
  .luck-draw .luck-button &#123;
    position: absolute;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
    width: 50px;
    height: 50px;
    color: #fff;
    line-height: 50px;
    border-radius: 50%;
    text-align: center;
    background-color: tomato;
    user-select: none;
    cursor: pointer;
  &#125;
  .luck-button:after &#123;
    content: &quot;&quot;;
    position: absolute;
    top: -18px;
    left: 50%;
    transform: translateX(-50%);
    display: block;
    border: 8px solid transparent;
    border-bottom: 15px solid tomato;
  &#125;
&gt;&lt;/style&gt;
&gt;&lt;/head&gt;
&gt;&lt;body&gt;
&gt; &lt;div class=&quot;luck-draw&quot;&gt;
&gt;   &lt;div class=&quot;luck-panel&quot;&gt;
&gt;     &lt;div class=&quot;panel-left&quot;&gt;
&gt;       &lt;div class=&quot;prize-item&quot;&gt;&lt;span&gt;&lt;/span&gt;&lt;/div&gt;
&gt;       &lt;div class=&quot;prize-item&quot;&gt;&lt;span&gt;&lt;/span&gt;&lt;/div&gt;
&gt;       &lt;div class=&quot;prize-item&quot;&gt;&lt;span&gt;&lt;/span&gt;&lt;/div&gt;
&gt;       &lt;div class=&quot;prize-item&quot;&gt;&lt;span&gt;&lt;/span&gt;&lt;/div&gt;
&gt;     &lt;/div&gt;
&gt;     &lt;div class=&quot;panel-right&quot;&gt;
&gt;       &lt;div class=&quot;prize-item&quot;&gt;&lt;span&gt;&lt;/span&gt;&lt;/div&gt;
&gt;       &lt;div class=&quot;prize-item&quot;&gt;&lt;span&gt;&lt;/span&gt;&lt;/div&gt;
&gt;       &lt;div class=&quot;prize-item&quot;&gt;&lt;span&gt;&lt;/span&gt;&lt;/div&gt;
&gt;       &lt;div class=&quot;prize-item&quot;&gt;&lt;span&gt;&lt;/span&gt;&lt;/div&gt;
&gt;     &lt;/div&gt;
&gt;   &lt;/div&gt;
&gt;   &lt;div class=&quot;luck-button&quot;&gt;抽奖&lt;/div&gt;
&gt; &lt;/div&gt;
</code></pre>
<ol start="2">
<li>JavaScript 实现思路</li>
</ol>
<ul>
<li>第一步<blockquote>
<ul>
<li>动态添加抽奖礼品数据到页面，抽奖礼品保存在以下数组中</li>
</ul>
</blockquote>
</li>
</ul>
<pre><code>var prizes = [
  &quot;手机一部&quot;,
  &quot;电饭煲一台&quot;,
  &quot;保温杯一个&quot;,
  &quot;免单50元&quot;,
  &quot;免单100元&quot;,
  &quot;10元红包&quot;,
  &quot;10个积分&quot;,
  &quot;未中奖喽!&quot;,
];
</code></pre>
<ul>
<li>第二步<blockquote>
<ul>
<li>随机抽奖，需要通过随机函数，生成 <code>0-1</code> 之间的随机数，<code>* 数组长度</code>，通过这个随机数来确定对应的中奖奖品的下标</li>
</ul>
</blockquote>
</li>
</ul>
<pre><code>var prizesLength = prizes.length;
var _index = (Math.random() * prizesLength) &gt;&gt; 0;
</code></pre>
<ul>
<li><p>第三步</p>
<blockquote>
<ul>
<li>根据抽中的奖项，来确定转盘旋转的角度，计算公式如下</li>
<li><code>var deg = _index * 45 + 22.5;</code></li>
<li>抽奖按钮的指针要正对奖项中间，就必须转<code>22.5deg</code></li>
<li>每个奖项占45°</li>
</ul>
</blockquote>
</li>
<li><p>第四步</p>
<blockquote>
<ul>
<li>我们希望每次抽奖，转盘能在现有角度上<strong>再旋转 5 圈</strong>，然后到达指定角度</li>
</ul>
</blockquote>
</li>
</ul>
<pre><code>var sum = 0; // 相当于累加器
sum += 1800;
deg = sum + deg;
luckpanel.style.transform = &quot;rotate(&quot; + deg + &quot;deg)&quot;;
</code></pre>
<ul>
<li>第五步<blockquote>
<p>控制抽奖概率</p>
<ul>
<li>设置权重数组，然后随机生成 0-99 之间的整数，把生成的数插入到权重数组中</li>
<li>然后将该数组按照升序排序：<code>.sort(function(a,b)&#123;return a-b&#125;)</code></li>
<li>查询随机数在权重数组中的下标<code>indexOf()</code>，根据对应的下标来决定中的是哪个奖项</li>
<li>最后把随机从权重数组中删除<code>.splice(_index,1)</code>，不能破坏了权重数组</li>
<li>删除前面设置的随机函数</li>
</ul>
</blockquote>
</li>
</ul>
<pre><code>// 权重数组
var weight = [1, 3, 7, 12, 19, 30, 40, 100];
// 随机生成 0-99 之间的整数。
var random = (Math.random() * 100) &gt;&gt; 0;
// 把生成的随机数添加到数组中
weight.push(random);
// 对数组进行升序排序
weight.sort(function (a, b) &#123;
  return a - b;
&#125;);
// 找到随机生成的数，在数组中的下标
var _index = weight.indexOf(random);
// 删除随机生成的数，不能影到我的权重数组
weight.splice(_index, 1);
</code></pre>
<ul>
<li>第六步<blockquote>
<ul>
<li>防止用户频繁点击按扭。在上一次抽奖没有结束前，不能再次抽奖</li>
<li>声明一个变量<code>lock</code>作为锁</li>
<li>在动画结束后，利用过渡事件开锁</li>
</ul>
</blockquote>
</li>
</ul>
<pre><code>var lock = false; // 开锁 目前没有抽奖
// 点击抽奖
drawButton.onclick = function () &#123;
  if (lock) return;
  lock = true; // 关锁 正在抽奖

  // ....
&#125;;
&gt;
// 动画结束后 开锁
luckpanel.addEventListener(
  &quot;transitionend&quot;,
  function () &#123;
    lock = false;
    //   alert(&quot;恭喜你中了&quot; + drawText);
  &#125;,
  false
);
</code></pre>
<ul>
<li>JS完整代码</li>
</ul>
<pre><code>&gt;&lt;script&gt;
 var prizes = [
   &quot;手机一部&quot;,
   &quot;电饭煲一台&quot;,
   &quot;保温杯一个&quot;,
   &quot;免单50元&quot;,
   &quot;免单100元&quot;,
   &quot;10元红包&quot;,
   &quot;10个积分&quot;,
   &quot;未中奖哦!&quot;,
 ];
 var prizesLength = prizes.length;
 //动态添加抽奖礼品数据到页面
 var spans = document.querySelectorAll(&quot;.luck-panel .prize-item span&quot;);
 var spansLength = spans.length;
 for (var i = 0; i &lt; spansLength; i++) &#123;
   spans[i].innerText = prizes[i];
 &#125;
 //点击按钮，随机转动转盘
 var luckPanel = document.querySelector(&quot;.luck-panel&quot;);
 var luckButton = document.querySelector(&quot;.luck-button&quot;);
 var sum = 0;
 var lock = false; //false表示未上锁
 luckButton.onclick = function () &#123;
   if (lock) return; //如果lock=true,就不能进
   lock = true;
   // 权重数组
   var weight = [1, 3, 7, 12, 19, 30, 40, 100];
   //生成随机数
   // var _index = (Math.random() * prizesLength) &gt;&gt; 0;
   var random = (Math.random() * 100) &gt;&gt; 0;
   //将随机数插入权重数组
   weight.push(random);
   //将权重数组按升序排列
   weight.sort(function (a, b) &#123;
     return a - b;
   &#125;);
   //获取该随机数的下标
   var _index = weight.indexOf(random);
   // 删除随机生成的数，不能影到我的权重数组
   weight.splice(_index, 1);
   sum += 1800;
   //获取对应的文字
   var prizesText = prizes[_index];
   //转动转盘
   var deg = sum + _index * 45 + 22.5;
   luckPanel.style.transform = &quot;rotate(&quot; + deg + &quot;deg)&quot;;
   //开锁
   luckPanel.addEventListener(
     &quot;transitionend&quot;,
     function () &#123;
       lock = false;
       // alert(prizesText);
     &#125;,
     false
   );
 &#125;;
&gt;&lt;/script&gt;
</code></pre>
<h4 id="案例：红包雨效果"><a href="#案例：红包雨效果" class="headerlink" title="案例：红包雨效果"></a>案例：红包雨效果</h4><ol>
<li>CSS布局</li>
</ol>
<ul>
<li><p>实现思路</p>
<blockquote>
<ul>
<li>页面背景设置黑色，同时设置超出部分显示隐藏(为了不出现滚动条)</li>
<li>创建一个小红包（因为每个红包旋转角度不一样，则红包旋转的角度用 JS 来设置）</li>
<li>布局红包中奖后的显示效果，包括关闭按扭，红包金额</li>
<li>黑色半透明遮罩层 (刚开始是隐藏的)</li>
</ul>
</blockquote>
</li>
<li><p>代码实现</p>
</li>
</ul>
<pre><code>&gt;&lt;style&gt;
 html,
 body &#123;
   margin: 0;
   padding: 0;
   width: 100%;
   height: 100%;
 &#125;
 body &#123;
   background-color: #000;
   overflow: hidden;
 &#125;
 .red-packet &#123;
   position: absolute;
   /* top: -168px; 用JS控制，用户可指定*/
   width: 120px;
   height: 168px;
   background-image: url(../src/红包雨图片素材/redPacket.png);
   background-size: cover;
   cursor: pointer;
 &#125;
 /* 匀速下落动画 */
 .animation-drop &#123;
   /* 不同的红包效果不一样，为了方便用JS操作，分开写 */
   animation-name: drop; /* 动画名字 */
   /*animation-duration: 5s;  动画运动时间 用JS操作，每个红包不一样 */
   animation-timing-function: ease; /* 运动的速度 */
   animation-fill-mode: forwards; /* 运动结束后的状态 */
 &#125;
 @keyframes drop &#123;
   0% &#123;
     opacity: 0;
   &#125;
   50% &#123;
     opacity: 1;
   &#125;
   100% &#123;
     opacity: 1;
     top: 1000px;
   &#125;
 &#125;
 .show-prize &#123;
   position: fixed;
   top: 50%;
   left: 50%;
   width: 400px;
   height: 579px;
   background-image: url(../src/红包雨图片素材/redPacket2.png);
   background-size: cover;
   transform: translate(-50%, -50%);
   z-index: 3;
   display: none;
 &#125;
 /* 中奖金额 */
 .show-prize .money &#123;
   position: absolute;
   bottom: 130px;
   left: 50%;
   transform: translate(-50%, -50%);
   color: #fff;
   font-size: 35px;
   user-select: none;
 &#125;
 /* 关闭按钮 */
 .show-prize .close &#123;
   position: absolute;
   top: 15px;
   right: -15px;
   width: 30px;
   height: 30px;
   line-height: 30px;
   text-align: center;
   background-color: #fff;
   border-radius: 50%;
   cursor: pointer;
 &#125;
  /* 黑色遮罩层 */
  .mask &#123;
    position: absolute;
    width: 100%;
    height: 100%;
    background-color: rgba(0, 0, 0, 0.6);
    display: none;
  &#125;
&gt;&lt;/style&gt;
&gt;&lt;div id=&quot;J_redPacket&quot;&gt;
&gt;   &lt;div class=&quot;red-packet animation-drop&quot;&gt;&lt;/div&gt;
&gt;   &lt;div class=&quot;show-prize&quot;&gt;
&gt;     &lt;div class=&quot;money&quot;&gt;2.88元&lt;/div&gt;
&gt;     &lt;div class=&quot;close&quot;&gt;X&lt;/div&gt;
&gt;   &lt;/div&gt;
&gt;   &lt;div class=&quot;mask&quot;&gt;&lt;/div&gt;
&gt; &lt;/div&gt;
</code></pre>
<ol start="2">
<li>JS代码实现思路</li>
</ol>
<ul>
<li>创建一个红包类这个红包类有以下属性和方法<table>
<thead>
<tr>
<th>属性</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>width</td>
<td>红包宽 ，如果不传，用默认值 120</td>
</tr>
<tr>
<td>height</td>
<td>红包高，如果不传，用默认值 168</td>
</tr>
<tr>
<td>x</td>
<td>水平方向坐标 （随机生成） （最大值不能大于浏览器宽 - 元素宽）</td>
</tr>
<tr>
<td>y</td>
<td>垂直方向坐标 (随机生成) （最开始元素在浏览器外面，即 top&#x3D;- 元素自身高）</td>
</tr>
<tr>
<td>money</td>
<td>红包金额大小（钱）</td>
</tr>
<tr>
<td>rotate</td>
<td>旋转的角度 （-45deg 到 45deg ）之间</td>
</tr>
<tr>
<td>duration</td>
<td>运动时间 3-7s 秒之间</td>
</tr>
<tr>
<td>dom</td>
<td>红包的 dom 结构</td>
</tr>
</tbody></table>
</li>
</ul>
<table>
<thead>
<tr>
<th>实例方法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>init</td>
<td>用于在页面初始化一个红包</td>
</tr>
<tr>
<td>drop</td>
<td>让红包运动起来,从上往下掉落</td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th>静态方法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>showRedPacket</td>
<td>显示红包中奖状态</td>
</tr>
<tr>
<td>hideRedPacket</td>
<td>隐藏红包中奖状态</td>
</tr>
<tr>
<td>sendRedPacket</td>
<td>用来发放红包</td>
</tr>
</tbody></table>
<ul>
<li><p>红包类</p>
<blockquote>
<ul>
<li>红包的宽高、坐标、旋转角度、金额都可以由用户传入</li>
<li>金额、宽、高都不能小于0</li>
<li>如果没传：<ul>
<li>X坐标：左右都要空出一段距离，不能让红包落在屏幕以外：<code>[30, 浏览器的宽度 - 红包的宽度];</code></li>
<li>Y坐标：默认值为 <code>-元素高度</code></li>
<li>旋转角度：随机生成 <code>[-45 ,45] </code>之间整数</li>
<li>运动时间，随机生成 <code>[3，7]</code>之间随机整数</li>
</ul>
</li>
<li>随机生成<code>[a,b]</code>之间的整数<ul>
<li><code>Math.random() * (b + 1 - a) + a;</code></li>
</ul>
</li>
</ul>
</blockquote>
</li>
<li><p>给红包类添加<code>init</code>方法</p>
<blockquote>
<ul>
<li>将创建好的红包对象，添加到body里，在页面中呈现出来</li>
<li>先给构造函数添加<code>init</code>方法，要加到它的<code>prototype</code>里，只要调用这个方法，就能将新创建的对象添加到页面</li>
<li>创建<code>div</code>元素，这个元素就是<code>new</code>出来的新对象的<code>dom</code></li>
<li>将新对象的宽、高、金额、坐标赋给<code>div</code></li>
<li>给<code>div</code>添加样式：把之前定义好的CSS样式加上去<code>.className=&quot;&quot;</code></li>
<li>将<code>div</code>上树，添加到页面中<blockquote>
<p><code>this</code>是构造函数创建的对象，<code>this.dom</code>是根据对象的属性创建出来的节点元素</p>
</blockquote>
</li>
</ul>
</blockquote>
</li>
<li><p>给红包类添加<code>drop</code>方法</p>
<blockquote>
<ul>
<li>调用<code>drop</code>方法，红包就可以运动</li>
<li>先给构造函数添加<code>init</code>方法，要加到它的<code>prototype</code>里，只要调用这个方法，就能让新创建的dom元素运动起来</li>
<li>给<code>dom</code>加上”animation-drop”动画</li>
<li>添加运动时间</li>
<li>同时运动结束后，会将自己的 dom 元素从页面删除<ul>
<li>运动结束，也就是动画结束，给dom添加<strong>动画事件</strong></li>
<li>然后用<code>父节点.removedChild(子节点)</code>删除元素</li>
</ul>
</li>
</ul>
</blockquote>
</li>
<li><p>在页面中创建 100 个 0-5 之间的随机数，作为红包的金额</p>
<blockquote>
<ul>
<li>把所生成的100个随机数塞到数组里</li>
<li><code>var random = Number((Math.random() * 5).toFixed(2));</code></li>
<li><code>.toFixed(2)</code>表示保留后两位小数</li>
</ul>
</blockquote>
</li>
<li><p>给红包类定义一个静态方法，用来实现发红包效果</p>
<blockquote>
<ul>
<li>传入一个包含红包金额的数组</li>
<li>设置一个定时器，每过<code>100ms</code>就<code>new</code>一个对象，并调用<code>drop</code>运动；这个过程也就是发出红包</li>
<li>用<code>.pop()</code>把红包金额传入，既能传入金额，也可以马上删除该金额</li>
<li>当数组的长度为0时，红包就发完了，此时消除定时器</li>
</ul>
</blockquote>
</li>
<li><p>给红包类定义两个静态方法，用来显示和隐藏打开红包的效果</p>
<blockquote>
<ul>
<li>打开红包效果要把<strong>new出来的实例</strong>传进去，因为只有实例身上才有<code>.money</code>这个属性</li>
<li>显示和隐藏就是将改变遮罩层和红包的<code>display</code></li>
</ul>
</blockquote>
</li>
<li><p>添加事件委托，把红包的点击事件委托给他的父元素来操作</p>
<blockquote>
<ul>
<li>当红包被点击后，就调用显示红包的静态方法</li>
<li>要注意！显示红包的静态方法需要传入<strong>所点击的实例</strong>，所以，在初始化时，把<code>this</code>保存在<code>dom</code>身上</li>
<li>给父元素添加委托事件后，可以拿到被点击的子元素，也就是<code>dom</code>，是不能直接拿到实例对象的</li>
</ul>
</blockquote>
</li>
<li><p>给关闭按钮添加点击事件</p>
<blockquote>
<ul>
<li>当关闭按钮被点击后，调用隐藏红包的静态效果</li>
</ul>
</blockquote>
</li>
<li><p>注意：如果不想让事件委托放在全局里</p>
<blockquote>
<ul>
<li>可以放在红包类里面</li>
<li><strong>但是</strong>，放在红包类里面，之后每次new一个实例，都会执行一次</li>
<li>然而我们只需要给父元素和关闭按钮添加一次委托时间</li>
<li>因此，我们给红包类添加静态方法</li>
</ul>
</blockquote>
</li>
<li><p>为了使代码不发生冲突，把所有代码放入一个立即执行函数中</p>
</li>
</ul>
<pre><code>&gt;&lt;script&gt;
(function () &#123;
 var redPacketParent = document.getElementById(&quot;J_redPacket&quot;);
 var domShowPrize = redPacketParent.querySelector(&quot;.show-prize&quot;);
 var domMoney = redPacketParent.querySelector(&quot;.money&quot;);
 var domClose = redPacketParent.querySelector(&quot;.close&quot;);
&gt; /**
&gt;  * RedPacket 红包类
&gt;  * width 红包宽
&gt;  * height 红包高
&gt;  * @param x 红包x坐标
&gt;  * @param y 红包 y 坐标
&gt;  * @param money 红包金额
&gt;  */
 function RedPacket(money = 0, x, y, rotate, width = 120, height = 168) &#123;
   // 构造函数的this指的是调用函数new创建出来的新对象
   //金额、宽、高都不能小于0
   this.money = money &lt;= 0 ? 0 : money;
   this.width = width &lt;= 0 ? 0 : width;
   this.height = height &lt;= 0 ? 0 : height;
&gt;
   //立即执行函数的this指向的是window，所以需要把外面的this传进去
   this.x = (function (that) &#123;
     if (x === 0) return 0; //如果传进来的x为0，则返回0
     if (x) return x; //只有传进来的x不等于false(undefined等)，就返回x
     //x默认值[30, 浏览器的宽度 - 红包的宽度];
     var MaxLeft = document.documentElement.clientWidth - that.width;
     return (Math.random() * (MaxLeft - 30 + 1) + 30) &gt;&gt; 0;
   &#125;)(this);
&gt;
   //处理y：默认值为 -height
   this.y = (function (that) &#123;
     if (y === 0) return 0; //如果传进来的x为0，则返回0
     if (y) return y; //只有传进来的x不等于false(undefined等)，就返回x
     return -that.height;
   &#125;)(this);
   //处理旋转角度：随机生成 `[-45 ,45] `之间整数
   this.rotate = (function (that) &#123;
     if (rotate === 0) return 0;
     if (rotate) return rotate;
     return (Math.random() * (90 + 1) - 45) &gt;&gt; 0;
   &#125;)(this);
&gt;
   //处理运动时间：随机生成 `[3，7]`之间随机整数
   this.duration = (Math.random() * (4 + 1) + 3) &gt;&gt; 0;
   this.init(); //初始化
   if (!RedPacket.flag) &#123;
     //没有加上委托事件才能进来
     RedPacket.flag = true;
     //事件委托
     redPacketParent.onclick = function (e) &#123;
       var target = e.target;
       var bool = target.classList.contains(&quot;red-packet&quot;);
       //如果点的不是红包，就返回
       if (!bool) return;
       RedPacket.showRedPacket(target.that);
     &#125;;
     domClose.onclick = function () &#123;
       RedPacket.closeRedPacket();
     &#125;;
   &#125;
 &#125;
 RedPacket.flag = false; //false表示没有添加委托事件
&gt;
 //初始化红包，创建元素节点
 RedPacket.prototype.init = function () &#123;
   //这里的this是指调用init方法的新对象
   this.dom = document.createElement(&quot;div&quot;);
   this.dom.className = &quot;red-packet&quot;;
   this.dom.style.width = this.width + &quot;px&quot;;
   this.dom.style.height = this.height + &quot;px&quot;;
   this.dom.style.left = this.x + &quot;px&quot;;
   this.dom.style.top = this.y + &quot;px&quot;;
   this.dom.style.transform = &quot;rotate(&quot; + this.rotate + &quot;deg)&quot;;
   //把this保存他对应dom的that属性上，供后面使用
   this.dom.that = this;
   this.dom.parent = redPacketParent; // 可保存，可不保存，看后续需求
   //上树
   this.dom.parent.appendChild(this.dom);
 &#125;;
&gt;
 //让红包动起来
 RedPacket.prototype.drop = function () &#123;
   this.dom.classList.add(&quot;animation-drop&quot;);
   this.dom.style.animationDuration = this.duration + &quot;s&quot;;
   this.dom.addEventListener(
     &quot;animationend&quot;,
     function () &#123;
       //这里的this指的是外面的this.dom
       this.parentNode.removeChild(this);
     &#125;,
     false
   );
 &#125;;
&gt;
 //定义一个静态方法，实现发红包效果
 RedPacket.sendRedPacket = function (date) &#123;
   //如果传入的不是数组
   if (!Array.isArray(date))
     throw new Error(&quot;date不是一个数组,请输入一个数组&quot;);
   var timer = setInterval(function () &#123;
     var redPacket = new RedPacket(moneyArr.pop());
     redPacket.drop();
     if (moneyArr.length === 0) &#123;
       clearInterval(timer);
     &#125;
   &#125;, 100);
 &#125;;
&gt;
 //定义两个静态方法，显示和隐藏打开红包的效果
 RedPacket.showRedPacket = function (that) &#123;
   domShowPrize.style.display = &quot;block&quot;;
   domClose.style.display = &quot;block&quot;;
   domMoney.innerText = that.money;
 &#125;;
 RedPacket.closeRedPacket = function () &#123;
   domShowPrize.style.display = &quot;none&quot;;
   domClose.style.display = &quot;none&quot;;
 &#125;;
&gt;
  // 页面中创建100个 0-5之间的随机数，作为红包的金额
  var moneyArr = [];
  for (var i = 0; i &lt; 100; i++) &#123;
    var random = Number((Math.random() * 5).toFixed(2));
    moneyArr.push(random);
  &#125;
  RedPacket.sendRedPacket(moneyArr); //发放红包
&#125;)();
&gt;&lt;/script&gt;
</code></pre>
<h3 id="六、JS-实现拖拽动画"><a href="#六、JS-实现拖拽动画" class="headerlink" title="六、JS 实现拖拽动画"></a>六、JS 实现拖拽动画</h3><h4 id="案例-1：拖拽动画"><a href="#案例-1：拖拽动画" class="headerlink" title="案例 1：拖拽动画"></a>案例 1：拖拽动画</h4><blockquote>
<ul>
<li>要求拖拽的小方块只能在父元素的区域内移动</li>
</ul>
</blockquote>
<ol>
<li><p>涉及知识点：</p>
<blockquote>
<ul>
<li>事件对象（鼠标位置、阻止默认行为）</li>
<li>鼠标事件：<code>onmousedown</code>、<code>onmousemove</code>、<code>onmouseup</code></li>
<li>鼠标位置：<ul>
<li><code>clientX</code>：鼠标指针相对于浏览器的水平坐标</li>
<li><code>clientY</code>：鼠标指针相对于浏览器的垂直坐标</li>
</ul>
</li>
<li><code>e.preventDefault()</code>方法用来阻止事件产生的 “默认动作”</li>
<li>获取元素尺寸：<ul>
<li><code>offsetLeft</code>：它返回当前元素(左边框)相对于其 <code>offsetParent</code>元素的左边框<strong>内壁</strong>的距离</li>
<li><code>offsetTop</code>：它返回当前元素(左边框)相对于其 <code>offsetParent</code>元素的左边框<strong>内壁</strong>的距离</li>
<li><code>offsetWidth</code>：返回一个元素的布局宽度；标准盒模型下，包括：<code>width</code>、<code>border</code>、<code>padding</code>、滚动条宽</li>
<li><code>offsetHeight</code>：返回一个元素的布局宽度；标准盒模型下，包括：<code>height</code>、<code>border</code>、<code>padding</code>、滚动条宽</li>
<li><code>offsetParent</code>：返回离当前元素最近的<strong>定位祖先元素</strong>或最近的 table,td,th,tody 元素</li>
</ul>
</li>
</ul>
</blockquote>
</li>
<li><p>拖拽动画实现原理</p>
<img src="拖拽动画.png"></li>
</ol>
<blockquote>
<ul>
<li>在<strong>鼠标按下</strong>时,即<code>onmousedown</code>事件<ul>
<li>记录鼠标按下时<strong>与浏览器可视区</strong>左边和上边距离，即<code>e.clientX</code>和<code>e.clientY</code></li>
<li>同时记录<strong>被拖拽元素与定义父元素</strong>左边和上边的距离，即<code>drag.offsetLeft</code>和<code>drag.offsetTop</code></li>
</ul>
</li>
<li>在鼠标<strong>移动</strong>时，即<code>onmousemove</code>事件<ul>
<li>记录鼠标此时<strong>与浏览器可视区</strong>左边和上边距离，即<code>e.clientX</code>和<code>e.clientY</code></li>
<li>用<strong>当前的</strong><code>e.clientX</code> - <strong>鼠标按下时</strong><code>e.clientX</code>，得到鼠标在<strong>水平移动的距离</strong>，然后用这个距离<strong>加上</strong>移动前元素的<code>offsetLeft</code>，就得到了此时被拖拽元素的 <code>left</code>值。同得理得 <code>top</code> 值</li>
</ul>
</li>
<li>还要添加<code>onmouseup</code>事件，在鼠标抬起时，要<strong>解绑</strong> <code>onmousemove</code>和<code>onmouseup</code>事件<blockquote>
<p>以上步骤实现了元素可以自由的被拖拽，但是并不能控制元素只能在定位父元素容器中移动</p>
</blockquote>
</li>
</ul>
</blockquote>
<ol>
<li>优化</li>
</ol>
<ul>
<li><p>控制被拖拽元素移动时<strong>不能超出父容器</strong>，</p>
<blockquote>
<ul>
<li>我们只需要控制被拖拽元素的 <code>left</code> 和 <code>top</code> 值的大小</li>
<li>如果 <code>left &lt; 0</code>，表示超出了父容器左边界，此时设置 <code>left=0</code>，强行拉回</li>
<li>如果 <code>left &gt; 父容器宽 - 元素宽</code> ，表示超出了父容器右边界，此时设置 <code>left = 父容器宽 - 元素</code>宽 ,强行拉回</li>
<li>如果 <code>top &lt; 0</code>，表示超出了父容器上边界，此时设置 <code>top = 0</code>，强行拉回</li>
<li>如果 <code>top &gt; 父容器高 - 元素高</code> ，表示超出了父容器下边界，此时设置 <code>top = 父容器宽 - 元素宽</code> ,强行拉回<blockquote>
<p>以上步骤，实现了控制元素只能在父容器中移动</p>
</blockquote>
</li>
</ul>
</blockquote>
</li>
<li><p>兼容性处理：如果被拖拽的元素是一个图片，或元素中有文字，被拖拽时就会出现卡顿</p>
<blockquote>
<ul>
<li>处理办法，就是禁止掉鼠标按下时,图片和被选中的文字默认的拖拽行为。</li>
</ul>
</blockquote>
</li>
</ul>
<blockquote>
<blockquote>
<p>注意：</p>
</blockquote>
<ul>
<li>被拖拽的元素一定是定位元素</li>
<li>如果定位父元素是<code>body</code>，那么要给<code>body</code>设置高度</li>
<li><code>onmousedown</code>事件处理函数绑定的是拖拽的元素；但里面的<code>onmousemove</code>和<code>onmouseup</code>绑定的是<code>document</code></li>
</ul>
</blockquote>
<ul>
<li>完整代码</li>
</ul>
<pre><code>&gt;&lt;style&gt;
  html,
  body &#123;
    margin: 0;
    padding: 0;
  &#125;
  .container &#123;
    position: relative;
    width: 500px;
    height: 500px;
    background-color: #ddd;
    border: 10px solid #000;
    margin: 50px;
  &#125;
  .drag &#123;
    position: absolute;
    left: 100px;
    top: 100px;
    width: 50px;
    height: 50px;
    background-color: tomato;
    cursor: move;
    user-select: none;
  &#125;
&gt;&lt;/style&gt;
&gt;&lt;div class=&quot;container&quot;&gt;
&gt;  &lt;div class=&quot;drag&quot;&gt;我是一段文字&lt;/div&gt;
&gt;&lt;/div&gt;
&gt;&lt;script&gt;
 var container = document.querySelector(&quot;.container&quot;);
 var drag = document.querySelector(&quot;.drag&quot;);
&gt;
 drag.onmousedown = function (e) &#123;
   e.preventDefault(); //取消事件的默认行为
   //获取鼠标按下时，与浏览器左边的距离
   var beforeClientX = e.clientX;
   var beforeClientY = e.clientY;
   //获取初始位置的offsetleft和offsetTop
   var beforeLeft = drag.offsetLeft;
   var beforeTop = drag.offsetTop;
&gt;
 //获取元素的宽高
 var dragWidth = this.offsetWidth;
 var dragHeight = this.offsetHeight;
&gt;
 //获取定位父容器的宽高
 var parentWidth = this.offsetParent.clientWidth;
 var parentHeight = this.offsetParent.clientHeight;
&gt;
 //计算元素能移动的最大范围
 var maxLeft = parentWidth - dragWidth;
 var maxTop = parentHeight - dragHeight;
&gt;
 //当鼠标按下后移动时
 document.onmousemove = function (e) &#123;
  //获取鼠标移动后 与浏览器的距离
  var afterClientX = e.clientX;
  var afterClientY = e.clientY;
&gt;
  //获取移动的距离
  var distanceX = afterClientX - beforeClientX;
  var distanceY = afterClientY - beforeClientY;
&gt;
  //获取移动后的left、top值
  var _left = distanceX + beforeLeft;
  var _top = distanceY + beforeTop;
&gt;
  //限制元素移动的范围
  _left = _left &lt; 0 ? 0 : _left;
  _left = _left &gt; maxLeft ? maxLeft : _left;
  _top = _top &lt; 0 ? 0 : _top;
  _top = _top &gt; maxTop ? maxTop : _top;
&gt;
  //改变drag的位置
  drag.style.left = _left + &quot;px&quot;;
  drag.style.top = _top + &quot;px&quot;;
 &#125;;
  //鼠标松开时，移除事件监听
 document.onmouseup = function () &#123;
   document.onmousemove = null;
   document.onmouseup = null;
  &#125;;
&#125;;
&gt;&lt;/script&gt;
</code></pre>
<ol start="4">
<li>封装——方法1<blockquote>
<ul>
<li>功能：需要拖拽那个元素，那个元素就调用 drag 方法<ul>
<li>打点调用，就是在原型上添加方法</li>
<li>所有元素都是<code>HTMLElement</code>这个类构造出来的，所以把方法写在它的原型上</li>
</ul>
</li>
<li><code>drag</code>方法中有两个参数 <code>dragmove</code> 和 <code>dragend</code>，分别为两个<strong>回调函数</strong></li>
<li><code>dragmove</code>：<strong>拖拽过程中</strong>需要处理的事情写在 <code>dragmove</code> 函数</li>
<li><code>dragend</code>：<strong>拖拽结束后</strong>，需要处理的事情写在 <code>dragend</code> 函数中</li>
</ul>
</blockquote>
</li>
</ol>
<blockquote>
<blockquote>
<p><strong>注意：</strong></p>
</blockquote>
<ul>
<li>元素调用这个方法时，<code>this</code>指的就是该元素</li>
<li>但是，在该方法里的<code>mousemove</code>事件处理函数，绑定的是document，因此它的<code>this</code>是<code>document</code></li>
<li><code>mousemove</code>事件处理函数，要调整元素的位置,所以要把它的<code>this</code>替换为拖拽的元素</li>
<li>因此在事件处理函数外面用 <code>var that = this</code> 保存被拖拽元素，然后传进去。</li>
<li>要在方法代码后面调用</li>
</ul>
</blockquote>
<pre><code>&gt;/**
&gt; *	drag 拖拽方法
&gt; * @param dragmove：拖拽过程中需要处理的事情写在dragmove函数
&gt; * @param dragend：拖拽结束后，需要处理的事情写在dragend函数中
&gt; */
HTMLElement.prototype.drag = function (dragmove, dragend) &#123;
  // 当鼠标在元素身上按下去时
  this.onmousedown = function (e) &#123;
    var e = e || window.event;
    // 取消事件的默认行为
    e.preventDefault();
    // 鼠标按下时，与浏览器左边的距离和上面的距离
    var _clientX = e.clientX;
    var _clientY = e.clientY;
&gt;
    // 获鼠标按下时，元素与定位父元素左边和上边的距离
    var _offsetTop = this.offsetTop;
    var _offsetLeft = this.offsetLeft;
&gt;
    // 获取父容器的宽,用来计算元素最大left
    var dragWidth = this.offsetWidth;
    var dragHeight = this.offsetHeight;
&gt;
    // 获取元素的定位父容器的宽
    var parentWidth = this.offsetParent.clientWidth;
    var parentHeight = this.offsetParent.clientHeight;
&gt;
    // 计算元素能移动的最大left值和最大top值
    var maxLeft = parentWidth - dragWidth;
    var maxTop = parentHeight - dragHeight;
    var that = this;
    // 当鼠标移动时
    document.onmousemove = throttle(fn);//节流函数
    function fn(e) &#123;
      // 鼠标移动时，与浏览器可视区左边的距离
      var _moveClientX = e.clientX;
      var _moveClientY = e.clientY;
&gt;
      // 计算鼠标移动的距离
      var _x = _moveClientX - _clientX;
      var _y = _moveClientY - _clientY;
&gt;
      // 元素的left和top值
      var left = _x + _offsetLeft;
      var top = _y + _offsetTop;
&gt;
      // 限定left只能在 0-maxLeft之间
      left = left &lt; 0 ? 0 : left;
      left = left &gt; maxLeft ? maxLeft : left;
&gt;
      top = top &lt; 0 ? 0 : top;
      top = top &gt; maxTop ? maxTop : top;
&gt;
      // 计算元素当前的位置
      that.style.left = left + &quot;px&quot;;
      that.style.top = top + &quot;px&quot;;
&gt;
      // 移动过程中要处理的事情，调用以下回调函数
      dragmove instanceof Function ? dragmove() : dragmove;
    &#125;;
&gt;
    // 当鼠标弹起来时，要对事件解绑
    document.onmouseup = function () &#123;
      document.onmousemove = null;
      // 拖拽动画结束后，调用以下回调函数
      dragend instanceof Function ? dragend() : dragend;
      document.onmouseup = null;
    &#125;;
  &#125;;
&#125;;
</code></pre>
<ul>
<li>使用：</li>
</ul>
<pre><code>&gt;&lt;style&gt;
  body,
  html &#123;
    margin: 0;
    padding: 0;
    height: 100%;
  &#125;
  .box &#123;
    position: absolute;
    width: 100px;
    height: 100px;
    background-color: khaki;
    cursor: move;
  &#125;
&gt;&lt;/style&gt;
&gt;
&gt;&lt;div class=&quot;box&quot;&gt;1111&lt;/div&gt;
&gt;&lt;script&gt;
  var box = document.querySelector(&quot;.box&quot;);
  box.drag(
    function () &#123;
      console.log(&quot;我在动&quot;);
    &#125;,
    function () &#123;
      console.log(&quot;我运动完了&quot;);
    &#125;
  );
&gt;&lt;/script&gt;
&gt;&lt;script src=&quot;./throttle2.js&quot;&gt;&lt;/script&gt;
</code></pre>
<ol start="5">
<li>封装 drag 方法2<blockquote>
<ul>
<li>功能：被按下的元素和被拖拽的元素<strong>不是同一个元素</strong>，当在 A 元素上按下时，可拖拖拽 B 元素</li>
<li>给<code>HTMLElement.prototype</code>添加方法，打点调用</li>
<li><code>drag</code> 方法中有 3 个参数 <code>dragElement</code>,<code>dragmove</code> 和 <code>dragend</code></li>
<li><code>dragElement</code>：表示要拖拽的元素</li>
<li><code>dragmove</code>：拖拽过程中需要处理的事情写在 dragmove 函数</li>
<li><code>dragend</code>：拖拽结束后，需要处理的事情写在 dragend 函数中</li>
<li>注意：AB元素都要为定位元素</li>
</ul>
</blockquote>
</li>
</ol>
<pre><code>&gt;/**
&gt; * 调用drag方法的元素，为鼠标按下的元素
&gt; * @param dragElement 为被拖拽的元素
&gt; * @param dragmove：拖拽过程中需要处理的事情写在dragmove函数
&gt; * @param dragend：拖拽结束后，需要处理的事情写在dragend函数
&gt; */
 HTMLElement.prototype.drag = function (dragElement, dragmove, dragend) &#123;
   // 当鼠标在元素身上按下去时
   this.onmousedown = function (e) &#123;
     e.preventDefault(); //取消事件的默认行为
     //获取鼠标按下时，与浏览器左边的距离
     var beforeClientX = e.clientX;
     var beforeClientY = e.clientY;
     //获取初始位置的offsetleft和offsetTop
     var beforeLeft = dragElement.offsetLeft;
     var beforeTop = dragElement.offsetTop;
&gt;
     //获取元素的宽高
     var dragWidth = dragElement.offsetWidth;
     var dragHeight = dragElement.offsetHeight;
&gt;
     //获取定位父容器的宽高
     var parentWidth = dragElement.offsetParent.clientWidth;
     var parentHeight = dragElement.offsetParent.clientHeight;
&gt;
     //计算元素能移动的最大范围
     var maxLeft = parentWidth - dragWidth;
     var maxTop = parentHeight - dragHeight;
&gt;
     //当鼠标按下后移动时
     //给onmousemove做节流
     document.onmousemove = throttle(fn);
     function fn(e) &#123;
       //获取鼠标移动后 与浏览器的距离
       var afterClientX = e.clientX;
       var afterClientY = e.clientY;
&gt;
     //获取移动的距离
     var distanceX = afterClientX - beforeClientX;
     var distanceY = afterClientY - beforeClientY;
&gt;
     //获取移动后的left、top值
     var _left = distanceX + beforeLeft;
     var _top = distanceY + beforeTop;
&gt;
     //限制元素移动的范围
     _left = _left &lt; 0 ? 0 : _left;
     _left = _left &gt; maxLeft ? maxLeft : _left;
&gt;
     _top = _top &lt; 0 ? 0 : _top;
     _top = _top &gt; maxTop ? maxTop : _top;
&gt;
     //改变drag的位置
     dragElement.style.left = _left + &quot;px&quot;;
     dragElement.style.top = _top + &quot;px&quot;;
&gt;
     dragmove instanceof Function ? dragmove() : dragmove;
     &#125;
     document.onmouseup = function () &#123;
            document.onmousemove = null;
&gt;
     dragend instanceof Function ? dragend() : dragend;
     document.onmouseup = null;
   &#125;;
  &#125;;
&#125;;
</code></pre>
<ul>
<li>使用</li>
</ul>
<pre><code>&gt;&lt;style&gt;
  html,
  body &#123;
    margin: 0;
    padding: 0;
  &#125;
  .container &#123;
    position: relative;
    width: 500px;
    height: 500px;
    background-color: #ddd;
    border: 10px solid #000;
    margin: 50px;
  &#125;
  .drag &#123;
    position: absolute;
    left: 100px;
    top: 100px;
    width: 100px;
    height: 100px;
    background-color: tomato;
    cursor: move;
    user-select: none;
  &#125;
  .drag .title &#123;
    width: 100%;
    height: 30px;
    background-color: khaki;
  &#125;
&gt;&lt;/style&gt;
&gt;
&gt;&lt;div class=&quot;container&quot;&gt;
&gt;  &lt;div class=&quot;drag&quot;&gt;
&gt;    &lt;div class=&quot;title&quot;&gt;登录&lt;/div&gt;
&gt;    我是一段文字
&gt;  &lt;/div&gt;
&gt;&lt;/div&gt;
&gt;&lt;script&gt;
  var container = document.querySelector(&quot;.container&quot;);
  var drag = document.querySelector(&quot;.drag&quot;);
  var title = document.querySelector(&quot;.title&quot;);
  title.drag(
    drag,
    function () &#123;
      console.log(&quot;我在动哦&quot;);
    &#125;,
    function () &#123;
      console.log(&quot;我停下来了&quot;);
    &#125;
  );
&gt;&lt;/script&gt;
&gt;&lt;script src=&quot;./throttle2.js&quot;&gt;&lt;/script&gt;
</code></pre>
<blockquote>
<blockquote>
<p>优化：</p>
</blockquote>
<ul>
<li>还可以给<code>onmousemove</code>做节流，这两个封装方法都可以</li>
<li>可以把事件监听的方式<code>on</code>换成<code>addEventListener</code></li>
</ul>
</blockquote>
<h4 id="案例-2：拖拽交换两元素位置"><a href="#案例-2：拖拽交换两元素位置" class="headerlink" title="案例 2：拖拽交换两元素位置"></a>案例 2：拖拽交换两元素位置</h4><blockquote>
<p>涉及知识点</p>
<ul>
<li>利用 JS 实现布局转换</li>
<li><code>onmousedown</code>、<code>onmousemove</code>、<code>onmouseup</code>事件</li>
<li>事件对象</li>
<li>自定义属性的使用</li>
<li>布局转换：浮动布局转定位</li>
<li>拖拽动画实现原理、如何检测两个元素<strong>碰撞</strong>，如果找到多个碰撞元素中离自己<strong>最近</strong>的一个</li>
<li>如何<strong>交换</strong>两个元素的位置</li>
</ul>
</blockquote>
<ol>
<li>先利用纯CSS来实现两行4列的布局</li>
</ol>
<pre><code>&gt;&lt;style&gt;
 html,
 body &#123;
   margin: 0;
   padding: 0;
   width: 100%;
   height: 100%;
   overflow: hidden;
 &#125;
 ul,
 li &#123;
   margin: 0;
   padding: 0;
   list-style: none;
 &#125;
 .container &#123;
   position: relative; /*li是相对于ul定位的*/
   width: 880px;
   height: 240px;
   margin: 20px;
 &#125;
 .container li &#123;
   float: left;
   width: 200px;
   height: 100px;
   line-height: 100px;
   font-size: 30px;
   text-align: center;
   margin: 10px;
   background-color: skyblue;
   user-select: none;
 &#125;
&gt;&lt;/style&gt;
&gt;
&gt;&lt;ul class=&quot;container&quot;&gt;
&gt;  &lt;li&gt;1&lt;/li&gt;
&gt;  &lt;li&gt;2&lt;/li&gt;
&gt;  &lt;li&gt;3&lt;/li&gt;
&gt;  &lt;li&gt;4&lt;/li&gt;
&gt;  &lt;li&gt;5&lt;/li&gt;
&gt;  &lt;li&gt;6&lt;/li&gt;
&gt;  &lt;li&gt;7&lt;/li&gt;
&gt;  &lt;li&gt;8&lt;/li&gt;
&gt;&lt;/ul&gt;
</code></pre>
<blockquote>
<blockquote>
<p>注意</p>
</blockquote>
<ul>
<li><code>body</code>的宽高一定要设置为100%</li>
<li>父容器<code>container</code>要设置相对定位，因为li的是相对于ul进行绝对定位的;</li>
</ul>
</blockquote>
<ol start="2">
<li>布局转换<blockquote>
<p>元素需要拖动，那肯定要设置为绝对定位元素，我们可以利用 JS 来实现布局转换。同时将每个版块的颜色设置为不同</p>
</blockquote>
</li>
</ol>
<blockquote>
<ul>
<li>通过 JS 获取页面中 li 元素，利用for循环把每个元素相对其定位的父元素left值和top值保存到一个对象中，然后添加进数组</li>
<li><code>offsetLeft</code>和<code>offsetTop</code>的值是相对于离他最近的定位祖先元素的</li>
<li>遍历所有 li 元素，把每个元素的都转换为<strong>定位元素</strong>，同时把之前保存到数组中的对应的 left 值和 top 值添加到对应元素身上</li>
<li>再准备一个 bgColor 数组，用来保存每个 li 元素的背景颜色，同时把每个元素的背景颜色更改为对应颜色</li>
</ul>
</blockquote>
<blockquote>
<blockquote>
<p>注意</p>
</blockquote>
<ul>
<li>第一次for循环保存的left值和top值是包含li的<code>margin</code>值的</li>
<li>因此，我们要在第二次for循环时，把li的<code>margin</code>值设置为<code>0</code></li>
</ul>
</blockquote>
<pre><code>&gt;&lt;script&gt;
 var oUL = document.querySelector(&quot;.container&quot;);
 var liList = document.querySelectorAll(&quot;.container li&quot;);
 var len = liList.length;
 var coordinate = []; //用来保存li的定位值
 //用for循环得到li的left、top值
 for (var i = 0; i &lt; len; i++) &#123;
   var obj = &#123;&#125;;
   obj.left = liList[i].offsetLeft;
   obj.top = liList[i].offsetTop;
   coordinate.push(obj);
 &#125;
 //颜色数组
 var bgColor = [
   &quot;pink&quot;,
   &quot;skyblue&quot;,
   &quot;turquoise&quot;,
   &quot;khaki&quot;,
   &quot;salmon&quot;,
   &quot;thistle&quot;,
   &quot;orange&quot;,
   &quot;red&quot;,
 ];
 //布局转换、更改颜色及其他样式
 for (var j = 0; j &lt; len; j++) &#123;
   liList[j].style.position = &quot;absolute&quot;;
   liList[j].style.left = coordinate[j].left + &quot;px&quot;;
   liList[j].style.top = coordinate[j].top + &quot;px&quot;;
   liList[j].style.margin = &quot;0px&quot;;
   liList[j].style.backgroundColor = bgColor[j];
   //把li的left和top值保存在它身上，不用重复获取
   liList[j].left = coordinate[j].left;
   liList[j].top = coordinate[j].top;
   liList[j].style.zIndex = 4; //给所有li设置统一的z-index值
 &#125; 
&gt;&lt;/script&gt;
</code></pre>
<ol start="3">
<li>JS 实现：拖拽效果<blockquote>
<p>利用<strong>事件委托</strong>来处理，所以 li 子元素的 <code>mousedown</code>事件需要处理的事情，全交由父元素来处理</p>
<ul>
<li>在<code>li</code>上按下，可以拖拽<code>li</code></li>
<li>同时在元素没有发生碰撞时，松开鼠标，元素回到原位置<ul>
<li>在第二个for循环里，把<code>li</code>的<code>left</code>、<code>top</code>值保存在它身上</li>
</ul>
</li>
<li>被按下拖拽的元素，会在所有元素的最上面，所以他的 <code>z-index</code>要最大<ul>
<li>在第二个for循环里，给<code>li</code>设置统一的<code>z-index</code>值</li>
</ul>
</li>
</ul>
</blockquote>
</li>
</ol>
<pre><code>oUL.onmousedown = function (e) &#123;
  var target = e.target;
  var tagName = target.tagName.toLowerCase();
  if (tagName !== &quot;li&quot;) return;
&gt;
  //获取鼠标与浏览器的距离
  var _clientX = e.clientX;
  var _clientY = e.clientY;
  //获取li的offsetLeft
  var _left = target.left;
  var _top = target.top;
&gt;
  //当元素运动时
  document.onmousemove = function (e) &#123;
    var clientX = e.clientX;
    var clientY = e.clientY;
&gt;
  //获取移动距离
  var distanceX = clientX - _clientX + _left;
  var distanceY = clientY - _clientY + _top;
  //修改li的位置
  target.style.left = distanceX + &quot;px&quot;;
  target.style.top = distanceY + &quot;px&quot;;
  target.style.zIndex = 20; //提高层级
&#125;;
&gt;
  //当鼠标松开时，li回到原位,时间解绑
  document.onmouseup = function () &#123;
    //如果没有和其他元素碰撞，就回到原位
    target.style.left = target.left + &quot;px&quot;;
    target.style.top = target.top + &quot;px&quot;;
    target.style.zIndex = 4;//鼠标松开后，层级恢复
    document.onmousemove = null;
    document.onmouseup = null;
  &#125;;
&#125;;
</code></pre>
<ol start="4">
<li>JS 实现：碰撞检测，同时找出碰撞元素中离自己最近的元素<blockquote>
<ul>
<li>判断当前拖拽的元素与其它兄弟碰上是否碰上<ul>
<li>写一个for循环&#x2F;forEach将每个元素与当前拖拽的元素比较 </li>
<li>使用之前写过的函数<code>isBump(obj1, obj2)</code>，撞上了就返回true</li>
</ul>
</li>
<li>如果碰上，就把碰上的元素添加到数组中去</li>
<li>比较数组中，哪个元素离自己最近<ul>
<li>使用之前写过的函数<code>findNearest(obj)</code>，返回的是离自己最近的元素</li>
</ul>
</li>
<li>给离自己最近的元素加上外轮廓，并提高他的层级</li>
</ul>
</blockquote>
</li>
</ol>
<pre><code>var prevBumpElement = null; // 记录前一个与自己碰撞的元素
var nearElement = null; // 当前碰上的元素
&gt;
document.onmousemove = function (e) &#123;
  // 前面代码略
  //  .....
  // 如何判断两个元素是否碰上
  var bumpElement = []; //保存离自己最近的元素
  //将其他每个元素与当前元素比较距离
  for (var i = 0; i &lt; len; i++) &#123;
    if (liList[i] !== target) &#123;
      if (isBump(target, liList[i])) &#123;
        bumpElement.push(liList[i]);
      &#125;
    &#125;
  &#125;
&gt;
  //找出数组中离自己最近的元素
  nearElement = findNearest(target, bumpElement);
  // 如果前一个碰上的元素存在，就把样式消掉
  if (prevnearElement) &#123;
    prevnearElement.style.outline = &quot;none&quot;;
    prevnearElement.style.zIndex = 4; //提高最近元素的层级
  &#125;
  // 如果有碰上的元素，就把碰上的最近的那个元素添加如下样式
  if (nearElement) &#123;
    nearElement.style.outline = &quot;10px solid pink&quot;;
    nearElement.style.zIndex = 10; //提高最近元素的层级
    prevnearElement = nearElement;
  &#125;
&#125;;
</code></pre>
<ol start="5">
<li>JS 实现：在碰上时，松开鼠标，交换两元素位置<blockquote>
<p>如何判断当前鼠标是在碰撞元素上松开的呢 ？<br>如果<strong>鼠标松开</strong>时，<strong>存在</strong>离自己最近的碰上元素，那就是就是碰上时松开鼠标的</p>
<ul>
<li>碰上时，交换两元素位置，同时交换位置时，实现动画效果</li>
<li>交换位置时，要把碰上元素的<code>outline</code>去掉，同时<code>nearElement = null</code></li>
</ul>
</blockquote>
</li>
</ol>
<pre><code> //当鼠标松开时，li回到原位,事件解绑，层级降低
 document.onmouseup = function () &#123;
   if (nearElement) &#123;
     //碰上了就要交换两个元素的位置
     //交换left、top值
     var left = target.left;
     var top = target.top;
     target.left = nearElement.left;
     target.top = nearElement.top;
     nearElement.left = left;
     nearElement.top = top;
     //交换位置
     target.style.left = target.left + &quot;px&quot;;
     target.style.top = target.top + &quot;px&quot;;
     nearElement.style.left = nearElement.left + &quot;px&quot;;
     nearElement.style.top = nearElement.top + &quot;px&quot;;
     nearElement.style.outline = &quot;none&quot;;
   &#125; else &#123;
     //如果没有和其他元素碰撞，就回到原位
     target.style.left = target.left + &quot;px&quot;;
     target.style.top = target.top + &quot;px&quot;;
     target.style.zIndex = 4; //松开后层级恢复
   &#125;
   document.onmousemove = null;
   document.onmouseup = null;
 &#125;;
</code></pre>
<ol start="6">
<li>给交换的两个元素添加动画<blockquote>
<ul>
<li>交换位置的时候加上动画</li>
<li>交换后，清除掉<code>nearElement</code>的值</li>
<li>动画结束后，去掉动画样式<ul>
<li>给每个li添加<code>transitionend</code></li>
</ul>
</li>
</ul>
</blockquote>
</li>
</ol>
<pre><code> .move &#123;
    transition: all 0.5s ease;
  &#125;
 &gt;
&#123;
  //交换位置
  target.classList.add(&quot;move&quot;);
  nearElement.classList.add(&quot;move&quot;);
&gt;
  target.style.left = target.left + &quot;px&quot;;
  target.style.top = target.top + &quot;px&quot;;
  nearElement.style.left = nearElement.left + &quot;px&quot;;
  nearElement.style.top = nearElement.top + &quot;px&quot;;
  nearElement.style.outline = &quot;none&quot;;
  nearElement = null; //清除
&#125;
&gt;
  //给所有li添加transitionend
  for (var k = 0; k &lt; len; k++) &#123;
    liList[k].addEventListener(
      &quot;transitionend&quot;,
      function () &#123;
        this.classList.remove(&quot;move&quot;);
        target.style.zIndex = 4; //交换后后层级恢复
      &#125;,
      false
    );
  &#125;
</code></pre>
<h3 id="七、综合应用实践案例"><a href="#七、综合应用实践案例" class="headerlink" title="七、综合应用实践案例"></a>七、综合应用实践案例</h3><h4 id="案例-3：键盘控制元素运动"><a href="#案例-3：键盘控制元素运动" class="headerlink" title="案例 3：键盘控制元素运动"></a>案例 3：键盘控制元素运动</h4><blockquote>
<p>涉及知识点</p>
<ul>
<li>定时器 <code>setInterval()</code></li>
<li><code>onkeydown</code>、<code>onkeyup</code> 事件</li>
<li>事件对象：<ul>
<li><code>e.altkey</code>：表示事件触发时<code>alt</code>键是否按下，返回的是布尔值</li>
<li><code>key</code>：返回用户按下的物理按键的值。</li>
</ul>
</li>
</ul>
</blockquote>
<ul>
<li>动画执行原理<blockquote>
<ul>
<li>页面中有一个元素，当我按键盘上的不同方向键时，他可以<strong>向不同的方向移动</strong></li>
<li>如果同时按下<code>Alt</code>键和方向键，则会<strong>加速</strong>向某个方向移动</li>
<li>因为 <code>keydown</code> 有卡顿现象：<strong>第一次</strong>事件处理函数的调用时间与<strong>第二次</strong>的事件处理函数调用的时间间隔相对来说比较长</li>
<li>所以<code>keydown</code>事件主要用来判断元素的<strong>运动方向</strong>，元素的<strong>运动行为</strong>通过&#x3D;&#x3D;定时器&#x3D;&#x3D;来实现。</li>
</ul>
</blockquote>
</li>
</ul>
<blockquote>
<blockquote>
<p>注意</p>
</blockquote>
<ul>
<li>按下键盘后，调用定时器使元素运动；按住键盘时会不断调用定时器，因此要上锁，每按下一次，只能调用一次定时器；并在松开键盘后清除定时器、开锁</li>
<li>加速运动时，我们要使用两个键盘值，一个控制速度，一个控制方向；但定时器只能调用一次</li>
<li>所以把<code>keyName</code>声明在全局对象里，onkeydown<code>事件调用</code>keyMove&#96;事件时，不传入key值，让定时器去全局对象里找</li>
</ul>
</blockquote>
<ul>
<li>代码实现</li>
</ul>
<pre><code>&gt;&lt;style&gt;
  html,
  body &#123;
    margin: 0;
    padding: 0;
  &#125;
  .box &#123;
    position: absolute;
    top: 50px;
    left: 100px;
    width: 100px;
    height: 100px;
    background-color: pink;
  &#125;
&gt;&lt;/style&gt;
&gt;
&gt;&lt;div class=&quot;box&quot;&gt;&lt;/div&gt;
&gt;&lt;script&gt;
  var box = document.querySelector(&quot;.box&quot;);
  var keyName; //因为switch要访问到，必须是全局变量
  var speed;
  var timer = null;
  var lock = false; //锁
  // 当键盘按下时，需要做的事情
  document.onkeydown = function (e) &#123;
    keyName = e.key;
    var altKey = e.altKey;
    speed = altKey ? 50 : 5;
    //每按下一个键，就会不断触发定时器，所以给他上锁
    if (!lock) &#123;
      //进来后就上锁
      lock = true;
      keyMove(); //不能传入key值，因为只能调用一次，第二个值传不进去
    &#125;
  &#125;;
// 根据方向，来移动元素
function keyMove() &#123;
  timer = setInterval(function () &#123;
    switch (keyName) &#123;
      case &quot;ArrowLeft&quot;:
        box.style.left = box.offsetLeft - speed + &quot;px&quot;;
        break;
      case &quot;ArrowRight&quot;:
        box.style.left = box.offsetLeft + speed + &quot;px&quot;;
        break;
      case &quot;ArrowUp&quot;:
        box.style.top = box.offsetTop - speed + &quot;px&quot;;
        break;
      case &quot;ArrowDown&quot;:
        box.style.top = box.offsetTop + speed + &quot;px&quot;;
        break;
    &#125;
  &#125;, 50);
&#125;
  //键盘抬起后，就开锁,并清理定时器
  document.onkeyup = function () &#123;
    lock = false;
    clearInterval(timer);
  &#125;;
&gt;&lt;/script&gt;
</code></pre>
<h4 id="案例-4：表单全选和取消"><a href="#案例-4：表单全选和取消" class="headerlink" title="案例 4：表单全选和取消"></a>案例 4：表单全选和取消</h4><blockquote>
<p>涉及知识点</p>
<ul>
<li><code>display:table</code>布局</li>
<li>自定义属性灵活使用</li>
<li>事件委拖</li>
<li>判断元素身上是否包含某个 class 类</li>
</ul>
</blockquote>
<ol>
<li><code>display:table</code>布局<blockquote>
<p><code>display: table;</code>系列几乎是和<code>table</code>系的元素相对应的，请看下表：</p>
</blockquote>
</li>
</ol>
<table>
<thead>
<tr>
<th>属性</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>table</td>
<td>（类似 <table>）此元素会作为块级表格来显示，表格前后带有换行符。</td>
</tr>
<tr>
<td>table-row</td>
<td>（类似 <tr>）此元素会作为一个表格行显示。</td>
</tr>
<tr>
<td>table-cell</td>
<td>（类似 <td> 和 <th>）此元素会作为一个表格单元格显示。</td>
</tr>
<tr>
<td>inline-table</td>
<td>（类似 <table>）此元素会作为内联表格来显示，表格前后没有换行符。</td>
</tr>
<tr>
<td>table-row-group</td>
<td>（类似 <tbody>）此元素会作为一个或多个行的分组来显示。</td>
</tr>
<tr>
<td>table-header-group</td>
<td>（类似 <thead>）此元素会作为一个或多个行的分组来显示。</td>
</tr>
<tr>
<td>table-footer-group</td>
<td>（类似 <tfoot>）此元素会作为一个或多个行的分组来显示。</td>
</tr>
<tr>
<td>table-column-group</td>
<td>（类似 <colgroup>）此元素会作为一个或多个列的分组来显示。</td>
</tr>
<tr>
<td>table-column</td>
<td>（类似 <col>）此元素会作为一个单元格列显示。</td>
</tr>
<tr>
<td>table-caption</td>
<td>（类似 <caption>）此元素会作为一个表格标题显示。</td>
</tr>
</tbody></table>
<ol start="2">
<li>CSS布局实现</li>
</ol>
<pre><code>&gt;&lt;style&gt;
 .table &#123;
   display: table;
   width: 500px;
   border: 1px solid #666;
   border-collapse: collapse; /* 合并单元格边框线 */
 &#125;
 .tr &#123;
   display: table-row;
 &#125;
 .tr .th,
 .tr .td &#123;
   display: table-cell;
   height: 35px;
   border: 1px solid #666;
   text-align: center;
   vertical-align: middle;
 &#125;
 .tr .th &#123;
   background-color: #ddd;
   font-weight: bolder;
 &#125;
 .check &#123;
   width: 22px;
   height: 22px;
   outline: 1px solid #333;
   margin: 0 auto;
 &#125;
 /* 被选中状态 */
 .selected &#123;
   width: 22px;
   height: 22px;
   background: url(../src/表单全选和登录验证提示素材/seleted.png) no-repeat;
   background-size: cover;
   outline: none;
 &#125;
&gt;&lt;/style&gt;
&gt;
&gt;&lt;div class=&quot;table&quot; id=&quot;J_table&quot;&gt;
&gt;  &lt;div class=&quot;tr&quot;&gt;
&gt;    &lt;div class=&quot;th&quot;&gt;&lt;div class=&quot;check&quot; id=&quot;J_selected&quot;&gt;&lt;/div&gt;&lt;/div&gt;
&gt;    &lt;div class=&quot;th&quot;&gt;序号&lt;/div&gt;
&gt;    &lt;div class=&quot;th&quot;&gt;编号&lt;/div&gt;
&gt;    &lt;div class=&quot;th&quot;&gt;班级名称&lt;/div&gt;
&gt;    &lt;div class=&quot;th&quot;&gt;班主任&lt;/div&gt;
&gt;    &lt;div class=&quot;th&quot;&gt;操作&lt;/div&gt;
&gt;  &lt;/div&gt;
&gt;  &lt;div class=&quot;tr&quot;&gt;
&gt;    &lt;div class=&quot;td&quot;&gt;&lt;div class=&quot;check check-item&quot;&gt;&lt;/div&gt;&lt;/div&gt;
&gt;    &lt;div class=&quot;td&quot;&gt;001&lt;/div&gt;
&gt;    &lt;div class=&quot;td&quot;&gt;202201001&lt;/div&gt;
&gt;    &lt;div class=&quot;td&quot;&gt;初一（103班）&lt;/div&gt;
&gt;    &lt;div class=&quot;td&quot;&gt;王老师&lt;/div&gt;
&gt;    &lt;div class=&quot;td&quot;&gt;&lt;button class=&quot;del&quot;&gt;删除&lt;/button&gt;&lt;/div&gt;
&gt;  &lt;/div&gt;
&gt;  &lt;div class=&quot;tr&quot;&gt;
&gt;    &lt;div class=&quot;td&quot;&gt;&lt;div class=&quot;check check-item&quot;&gt;&lt;/div&gt;&lt;/div&gt;
&gt;    &lt;div class=&quot;td&quot;&gt;002&lt;/div&gt;
&gt;    &lt;div class=&quot;td&quot;&gt;202201002&lt;/div&gt;
&gt;    &lt;div class=&quot;td&quot;&gt;初一（104班）&lt;/div&gt;
&gt;    &lt;div class=&quot;td&quot;&gt;贺老师&lt;/div&gt;
&gt;    &lt;div class=&quot;td&quot;&gt;&lt;button class=&quot;del&quot;&gt;删除&lt;/button&gt;&lt;/div&gt;
&gt;  &lt;/div&gt;
&gt;  &lt;div class=&quot;tr&quot;&gt;
&gt;    &lt;div class=&quot;td&quot;&gt;&lt;div class=&quot;check check-item&quot;&gt;&lt;/div&gt;&lt;/div&gt;
&gt;    &lt;div class=&quot;td&quot;&gt;003&lt;/div&gt;
&gt;    &lt;div class=&quot;td&quot;&gt;202201001&lt;/div&gt;
&gt;    &lt;div class=&quot;td&quot;&gt;初二（105班）&lt;/div&gt;
&gt;    &lt;div class=&quot;td&quot;&gt;雷老师&lt;/div&gt;
&gt;    &lt;div class=&quot;td&quot;&gt;&lt;button class=&quot;del&quot;&gt;删除&lt;/button&gt;&lt;/div&gt;
&gt;  &lt;/div&gt;
&gt;  &lt;div class=&quot;tr&quot;&gt;
&gt;    &lt;div class=&quot;td&quot;&gt;&lt;div class=&quot;check check-item&quot;&gt;&lt;/div&gt;&lt;/div&gt;
&gt;    &lt;div class=&quot;td&quot;&gt;004&lt;/div&gt;
&gt;    &lt;div class=&quot;td&quot;&gt;202201001&lt;/div&gt;
&gt;    &lt;div class=&quot;td&quot;&gt;初二（106班）&lt;/div&gt;
&gt;    &lt;div class=&quot;td&quot;&gt;张老师&lt;/div&gt;
&gt;    &lt;div class=&quot;td&quot;&gt;&lt;button class=&quot;del&quot;&gt;删除&lt;/button&gt;&lt;/div&gt;
&gt;  &lt;/div&gt;
&gt;&lt;/div&gt;
</code></pre>
<ol start="3">
<li>JS实现思路</li>
</ol>
<blockquote>
<p><strong>第一步：处理全选按扭点击后要实现的功能</strong></p>
<ul>
<li>点击全选按钮，为所有复选框做相应的全选或取消操作</li>
<li>通过<code>classList.toggle</code>方法，来实现元素点击时，在选中和未选中状态之间来回切换</li>
<li>如果<code>classList.toggle</code>方法的返回值为<code>true</code>，表示当前是全选状态，为<code>false</code>表示未全选状态。</li>
<li>利用for循环给复选框增加或删除样式</li>
</ul>
</blockquote>
<pre><code> var selectAllButton = document.getElementById(&quot;J_selected&quot;);
 var selectButtons = document.querySelectorAll(&quot;.table .tr .check-item&quot;);
 var len = selectButtons.length;
 selectAllButton.onclick = function () &#123;
   var bool1 = this.classList.toggle(&quot;selected&quot;);
   //如果bool1=true，则所有复选框都要被选中
   if (bool1) &#123;
     for (var i = 0; i &lt; len; i++) &#123;
       selectButtons[i].classList.add(&quot;selected&quot;);
     &#125;
   &#125; else &#123;
     for (var i = 0; i &lt; len; i++) &#123;
       selectButtons[i].classList.remove(&quot;selected&quot;);
     &#125;
   &#125;
 &#125;;
</code></pre>
<blockquote>
<p>第二步：利用事件委托，处理每个子元素点击要实现的功能</p>
<ul>
<li>同样通过<code>classList.toggle</code>来实现子元素在选中和未选中状态之间切换。</li>
<li>然后根据<code>toggle</code>方法的返回值，来决定当前全选按扭的状态。</li>
<li>用for循环来判断是否所有复选框都被选中</li>
</ul>
</blockquote>
<pre><code>var table = document.getElementById(&quot;J_table&quot;);
var flag = true; //假设是全选状态
//利用事件委托，处理子元素
table.onclick = function (e) &#123;
  var target = e.target;
  var bool2 = target.classList.contains(&quot;check-item&quot;);
  if (!bool2) return;
  //如果点击的是复选框，就处理以下事情
  var bool3 = target.classList.toggle(&quot;selected&quot;);
  //如果是true，判断是否所有复选框都被选中
  if (bool3) &#123;
    for (var j = 0; j &lt; len; j++) &#123;
      //判断所有复选框是不是都选中了
      flag = selectButtons[j].classList.contains(&quot;selected&quot;);
      if (!flag) &#123;
        //只要有一个未选中，则全选框无样式，退出循环
        selectAllButton.classList.remove(&quot;selected&quot;);
        break;
      &#125;
    &#125;
    if (flag) &#123;
      //flag=true,表示全选
      selectAllButton.classList.add(&quot;selected&quot;);
    &#125;
  &#125; else &#123;
    //只要有一个为false,全选框就不会有样式
    selectAllButton.classList.remove(&quot;selected&quot;);
  &#125;
&#125;;
</code></pre>
<ul>
<li>完整代码</li>
</ul>
<pre><code>
</code></pre>
<ul>
<li>优化<blockquote>
<ul>
<li>记录被选中复选框的个数，如果个数与复选框数量相等，则全选框要被选中(用这个方法，替代for循环)</li>
</ul>
</blockquote>
</li>
</ul>
<pre><code>&gt;&lt;script&gt;
  var table = document.getElementById(&quot;J_table&quot;);
  var selectAllButton = document.getElementById(&quot;J_selected&quot;);
  var selectButtons = document.querySelectorAll(&quot;.table .tr .check-item&quot;);
  var len = selectButtons.length;
  selectAllButton.selectedNum = 0; //记录被选中的复选框个数
  //处理全选按钮
  selectAllButton.onclick = function () &#123;
    var bool1 = this.classList.toggle(&quot;selected&quot;);
    //如果bool1=true，则所有复选框都要被选中
    if (bool1) &#123;
      for (var i = 0; i &lt; len; i++) &#123;
        selectButtons[i].classList.add(&quot;selected&quot;);
        this.selectedNum = len; // 保存当前选中的子元素个数
      &#125;
    &#125; else &#123;
      for (var i = 0; i &lt; len; i++) &#123;
        selectButtons[i].classList.remove(&quot;selected&quot;);
        this.selectedNum = 0; // 保存当前选中的子元素个数
      &#125;
    &#125;
  &#125;;
&gt;
  //利用事件委托，处理子元素
  table.onclick = function (e) &#123;
    var target = e.target;
    var bool2 = target.classList.contains(&quot;check-item&quot;);
    if (!bool2) return;
    //如果点击的是复选框，就处理以下事情
    var bool3 = target.classList.toggle(&quot;selected&quot;);
    if (bool3) &#123;
      //如果复选框被选中，个数+1
      selectAllButton.selectedNum++;
      //如果全部选中，全选框加样式
      if (selectAllButton.selectedNum === len) &#123;
        selectAllButton.classList.add(&quot;selected&quot;);
      &#125;
    &#125; else &#123;
      //只要有一个复选框没被选中，全选框就无样式
      selectAllButton.selectedNum--;
      selectAllButton.classList.remove(&quot;selected&quot;);
    &#125;
  &#125;;
&gt;&lt;/script&gt;
</code></pre>
<h4 id="案例-5：表单验证提示效果"><a href="#案例-5：表单验证提示效果" class="headerlink" title="案例 5：表单验证提示效果"></a>案例 5：表单验证提示效果</h4><ol>
<li>CSS布局</li>
</ol>
<pre><code>&gt;&lt;style&gt;
 html,
 body &#123;
   padding: 0;
   margin: 0;
   height: 100%;
 &#125;
 body &#123;
   display: flex;
   align-items: center;
   justify-content: center;
   background-color: #000;
 &#125;
 .login &#123;
   width: 300px;
   padding: 40px;
   background-color: #fff;
   border-radius: 10px;
 &#125;
 .login .login-row &#123;
   position: relative;
   margin: 20px 0;
 &#125;
 /* 去掉input的外轮廓效果 */
 input &#123;
   outline: none;
 &#125;
 .login-row input,
 .login-row button &#123;
   box-sizing: border-box;
   width: 100%;
   height: 50px;
   background-color: #f9f9f9;
   border: none;
   padding-left: 20px;
 &#125;
 button.submit &#123;
   font-size: 20px;
   background-color: tomato;
   color: #fff;
 &#125;
 /* JS 操作获取焦点后的样式 */
 .login-row input.focus1 &#123;
   background-color: #fcf2f3;
 &#125;
 .login-row input.focus2 &#123;
   border: 1px solid tomato;
 &#125;      
 /* 输入框文字 */
 .login-row .lable-tip &#123;
   position: absolute;
   top: 0;
   left: 20px;
   line-height: 50px;
   color: rgba(0, 0, 0, 0.4);
 &#125;
 /* 动态添加的缩放效果 */
 .login-row .lable-min &#123;
   line-height: 30px;
   font-size: 13px;
 &#125;
 /* 输入提示 */
 .login-row .input-tip &#123;
   color: tomato;
   font-size: 14px;
 &#125;
 /* 聚焦后提示变化 */
 .hide &#123;
   display: none;
 &#125;
 /* 密码隐藏与显示 */
 .icon-eye &#123;
   position: absolute;
   top: 15px;
   right: 20px;
   width: 30px;
   height: 20px;
   background: url(../src/表单全选和登录验证提示素材/eye-close.png)
     no-repeat center;
   cursor: pointer;
 &#125;
 .login-row .icon-show &#123;
   background-image: url(../src/表单全选和登录验证提示素材/eye.png);
 &#125;
&gt;&lt;/style&gt;
&gt;
&gt;&lt;div class=&quot;login&quot; id=&quot;J_login&quot;&gt;
&gt;  &lt;div class=&quot;login-row&quot;&gt;
&gt;    &lt;input type=&quot;text&quot; class=&quot;user-name&quot; id=&quot;user-name&quot; /&gt;
&gt;    &lt;label for=&quot;user-name&quot; class=&quot;lable-tip&quot;&gt;邮箱/手机号码&lt;/label&gt;
&gt;    &lt;div class=&quot;input-tip&quot;&gt;请输入账户名&lt;/div&gt;
&gt;  &lt;/div&gt;
&gt;  &lt;div class=&quot;login-row&quot;&gt;
&gt;    &lt;input type=&quot;password&quot; class=&quot;user-pwd&quot; id=&quot;user-pwd&quot; /&gt;
&gt;    &lt;label for=&quot;user-pwd&quot; class=&quot;lable-tip&quot;&gt;密码&lt;/label&gt;
&gt;    &lt;div class=&quot;input-tip&quot;&gt;请输入登录密码&lt;/div&gt;
&gt;    &lt;div class=&quot;icon-eye&quot;&gt;&lt;/div&gt;
&gt;  &lt;/div&gt;
&gt;  &lt;div class=&quot;login-row&quot;&gt;
&gt;    &lt;button type=&quot;submit&quot; class=&quot;submit&quot;&gt;登录&lt;/button&gt;
&gt;  &lt;/div&gt;
&gt;&lt;/div&gt;
</code></pre>
<ol start="2">
<li>JS 实现思路<blockquote>
<p>第一步：处理文本框获取到焦点&#x2F;失去焦点时要实现的功能<br><strong>获取焦点时</strong></p>
<ul>
<li>不管输入框中有无内容，文字是缩小的，有红色边框线</li>
<li>如果有内容，无错误提示(需隐藏),无粉色背景(需去掉)</li>
<li>如果没有内容，有输入提示(需加上)，有粉色背景(需加上)</li>
</ul>
</blockquote>
</li>
</ol>
<blockquote>
<p><strong>失去焦点时</strong></p>
<ul>
<li>不管输入框中有无内容，无红色边框线(需去掉)</li>
<li>如果有内容，缩小文字(获取焦点时已加)，无输入提示(获取焦点时已设置)，无粉色背景(获取焦点时已去掉)</li>
<li>如果没有内容，文字正常大小(需恢复)，有粉色背景(获取焦点时已加)，有提示文字(获取焦点时已加)</li>
</ul>
</blockquote>
<blockquote>
<blockquote>
<p>在输入时，有可能输入内容后又删除了，但<code>onfocus</code>只会在获取焦点时触发一次</p>
</blockquote>
<ul>
<li>所以要开一个计时器来<strong>定期检查输入内容是否为空</strong>，这里采用 <code>requestAnimationFrame</code> 来处理。</li>
<li>当失去焦点时，就不再调用 <code>requestAnimationFrame</code>，所以我们可以定义一把锁，当获取焦点时开锁，可以一直重复调用 <code>requestAnimationFrame</code>，失去焦点时关锁，不再调用<blockquote>
<p>注意回调函数<code>requestAnimationFrame(fn)</code>，是在下次刷新前执行；获取焦点的时候，不断调用，失去焦点后，在下一次刷新前，还会调用一次</p>
</blockquote>
</li>
</ul>
</blockquote>
<blockquote>
<ul>
<li>获取输入框中的值：<code>.value</code></li>
<li>处理输入框中的空格：<code>.trim()</code></li>
</ul>
</blockquote>
<blockquote>
<p>第二步：处理点击密码框中的小眼睛，闭上与打开要实现的功能</p>
<ul>
<li>如果小眼睛关闭状态，点击后打开，然后设置密码输入框<code>type = &#39;text&#39;</code></li>
<li>如果小眼睛打开状态，点击后关闭，然后设置密码输入框<code>type = &#39;password&#39;</code></li>
</ul>
</blockquote>
<pre><code>&gt;&lt;script&gt;
 var inputs = document.querySelectorAll(&quot;#J_login .login-row input&quot;);
 var eye = document.querySelector(&quot;.icon-eye&quot;);
 var pwd = document.querySelector(&quot;.user-pwd&quot;);
 var lock = false; // false表示锁是开的
 //由于onfocus和blur都不支持事件冒泡，所以不能用事件委托
 for (var i = 0; i &lt; inputs.length; i++) &#123;
   inputs[i].addEventListener(&quot;focus&quot;, focusFn, false);
   inputs[i].addEventListener(&quot;blur&quot;, blurFn, false);
 &#125;
&gt;
 //获取焦点时
 function focusFn() &#123;
   window.requestAnimationFrame(fn);
   lock = false; //一旦获取焦点就开锁，启动定时器
   //开启定时器
   var that = this; //this是调用focus的输入框
   var nextEle = this.nextElementSibling;
   //无论是否有内容：
   //1. 文字缩小
   nextEle.classList.add(&quot;lable-min&quot;);
   //2. 加边框
   this.classList.add(&quot;focus2&quot;);
   function fn() &#123;
     var value = that.value.trim();
     if (value) &#123;
       //如果有内容
       //同时隐藏输入提示
       nextEle.nextElementSibling.classList.add(&quot;hide&quot;);
       that.classList.remove(&quot;focus1&quot;);
     &#125; else &#123;
       //如果没有内容：显示输入提示
       nextEle.nextElementSibling.classList.remove(&quot;hide&quot;);
       that.classList.add(&quot;focus1&quot;);
     &#125;
     if (!lock) &#123;
       //如果锁是开着的，就不断调用定时器
       window.requestAnimationFrame(fn);
     &#125;
   &#125;
 &#125;
&gt;
 //失去焦点时
 function blurFn() &#123;
   lock = true; //失去焦点就关锁，清除定时器
   var nextEle = this.nextElementSibling;
   //无论是否有内容，去掉红色边框线
   this.classList.remove(&quot;focus2&quot;);
   var value = this.value.trim();
   if (!value) &#123;
     //如果没有内容
     //1.文字正常
     nextEle.classList.remove(&quot;lable-min&quot;);
     //2.粉色背景
     // this.classList.add(&quot;focus1&quot;);
   &#125;
 &#125;
&gt;
 //密码眼睛
 eye.onclick = function () &#123;
   var bool = eye.classList.toggle(&quot;icon-show&quot;);
   if (bool) &#123;
     pwd.type = &quot;text&quot;;
   &#125; else &#123;
     pwd.type = &quot;password&quot;;
   &#125;
 &#125;;
&gt;&lt;/script&gt;
</code></pre>
<h4 id="案例-6：放大镜效果"><a href="#案例-6：放大镜效果" class="headerlink" title="案例 6：放大镜效果"></a>案例 6：放大镜效果</h4><blockquote>
<p>涉及知识点</p>
<ul>
<li>选项卡效果、事件代理</li>
<li>onmouseover、onmousemove 事件</li>
<li>事件对象：e.pageX、e.pageY</li>
<li>元素偏移尺寸：offsetLeft、offsetTop</li>
<li>操作图片的 src 属性，完成图片替换</li>
<li>元素的显示与隐藏、事件冒泡机制</li>
</ul>
</blockquote>
<ol>
<li>CSS布局</li>
</ol>
<pre><code>&gt;&lt;style&gt;
 /* 初始化 */
 body,
 html,
 ul,
 li &#123;
   margin: 0;
   padding: 0;
 &#125;
 li &#123;
   list-style: none;
 &#125;
 .magnify &#123;
   position: relative;
   width: 350px;
   padding: 20px;
   border: 1px solid #ddd;
   margin: 50px;
 &#125;
&gt;
 /* 大图 */
 .magnify .main &#123;
   position: relative;
   width: 100%;
   height: 350px;
 &#125;
 .magnify .main img &#123;
   width: 350px;
   height: 350px;
 &#125;
 .magnify .mask &#123;
   position: absolute;
   top: 0;
   left: 0;
   width: 150px;
   height: 150px;
   background-color: rgba(232, 216, 94, 0.5);
   cursor: move;
 &#125;
&gt;
 /* 小图 */
 .magnify .small-img &#123;
   width: 100%;
   height: 85px;
   display: flex;
   align-items: flex-end;
   justify-content: space-between;
 &#125;
 .magnify .small-img li &#123;
   width: 75px;
   height: 75px;
 &#125;
 .magnify .small-img li img &#123;
   width: 100%;
   height: 100%;
   cursor: pointer;
 &#125;
 .active &#123;
   outline: 3px solid red;
  &#125;
&gt;
 /* 大图预览 */
 .magnify .big-img &#123;
   position: absolute;
   top: 0;
   left: 400px;
   width: 450px;
   height: 475px;
   overflow: hidden;
   /* display: none; */
 &#125;
 .magnify .big-img img &#123;
   position: absolute;
   top: 0;
   left: 0;
 &#125;
&gt;&lt;/style&gt;
&gt;&lt;div class=&quot;magnify&quot;&gt;
&gt;  &lt;!-- 主图 --&gt;
&gt;  &lt;div class=&quot;main&quot; id=&quot;J_main-img-wrap&quot;&gt;
&gt;    &lt;img src=&quot;../src/放大镜图片素材/big1.jpg&quot; alt=&quot;&quot; /&gt;
&gt;    &lt;div class=&quot;mask&quot;&gt;&lt;/div&gt;
&gt;  &lt;/div&gt;
&gt;  &lt;!-- 小图 --&gt;
&gt;  &lt;ul class=&quot;small-img&quot; id=&quot;J_small-img-wrap&quot;&gt;
&gt;    &lt;li&gt;
&gt;      &lt;img
&gt;        src=&quot;../src/放大镜图片素材/small1.jpg&quot;
&gt;        data-src=&quot;../src/放大镜图片素材/big1.jpg&quot;
&gt;      /&gt;
&gt;    &lt;/li&gt;
&gt;    &lt;li&gt;
&gt;      &lt;img
&gt;        src=&quot;../src/放大镜图片素材/small2.jpg&quot;
&gt;        data-src=&quot;../src/放大镜图片素材/big2.jpg&quot;
&gt;      /&gt;
&gt;    &lt;/li&gt;
&gt;    &lt;li&gt;
&gt;      &lt;img
&gt;        src=&quot;../src/放大镜图片素材/small3.jpg&quot;
&gt;        data-src=&quot;../src/放大镜图片素材/big3.jpg&quot;
&gt;      /&gt;
&gt;    &lt;/li&gt;
&gt;    &lt;li&gt;
&gt;      &lt;img
&gt;        src=&quot;../src/放大镜图片素材/small4.jpg&quot;
&gt;        data-src=&quot;../src/放大镜图片素材/big4.jpg&quot;
&gt;      /&gt;
&gt;    &lt;/li&gt;
&gt;  &lt;/ul&gt;
&gt;  &lt;!-- 大图预览 --&gt;
&gt;  &lt;div class=&quot;big-img&quot; id=&quot;J_big-img-wrap&quot;&gt;
&gt;    &lt;img src=&quot;../src/放大镜图片素材/big1.jpg&quot; alt=&quot;&quot; id=&quot;J_big-img&quot; /&gt;
&gt;  &lt;/div&gt;
&gt;&lt;/div&gt;
</code></pre>
<ol start="2">
<li>JS 实现思路</li>
</ol>
<ul>
<li>第一步：处理点击小图要实现的效果<blockquote>
<ul>
<li>利用事件委托，点击小图后要处理的事情委托给他的们的祖先元素 ul 来处理。</li>
<li>给小图加边框</li>
<li>更换主图和预览大图<ul>
<li>小图设置自定义属性，绑定相应大图的地址</li>
</ul>
</li>
</ul>
</blockquote>
</li>
</ul>
<pre><code> //事件委托：点击小图，切换大图
 smallImgWrap.onclick = function (e) &#123;
   var target = e.target;
   var tagName = target.tagName.toLowerCase();
&gt;
   if (tagName !== &quot;img&quot;) return;
   //清除前一个选择元素样式
   prevSmallImg.classList.remove(&quot;active&quot;);
   //给当前点击的图片添加边框;
   target.classList.add(&quot;active&quot;);
   //把当前点击的图片更换为前一个激活的图片
   prevSmallImg = target;
   //更换主图
   mainImg.src = target.dataset.src;
   //更换大图
   bigImg.src = target.dataset.src;
 &#125;;
</code></pre>
<ul>
<li>第二步：当鼠标滑动到主图容器和离开主图容器要实现的效果<blockquote>
<ul>
<li>鼠标滑动到主图容器，要显示透明滑块，同时显示大图容器</li>
<li>鼠标离开主图容器，要隐藏透明滑块，同时隐藏大图容器</li>
</ul>
</blockquote>
</li>
</ul>
<pre><code> //当鼠标滑动到主图容器
 mainImgWrap.onmouseover = function () &#123;
   mask.style.display = &quot;block&quot;;
   bigImgWrap.style.display = &quot;block&quot;;
 &#125;;
 //当鼠标离开主图容器
 mainImgWrap.onmouseout = function () &#123;
   mask.style.display = &quot;none&quot;;
   bigImgWrap.style.display = &quot;none&quot;;
 &#125;;
</code></pre>
<ul>
<li><p>第三步：实现滑块跟随之鼠标移动，并且块的中心位置为鼠标当前所在位置</p>
<blockquote>
<ul>
<li>设置滑块相对主图容器的 left 和 top 值</li>
<li><code>left 值 = 鼠标与浏览器左边距离 - 主图与浏览器左边距离 - 滑块宽度的一半</code></li>
<li><code>top 值 = 鼠标与浏览器上边距离 - 主图与浏览器上边距离 - 滑块高度的一半</code><ul>
<li>与浏览器的距离考虑滚动条的存在，使用<code>.pageX</code></li>
<li>主图与浏览器的距离：由于<code>main-wrap</code>与·浏览器还隔着父容器<code>magnify</code>,所以不能直接用<code>offsetLeft</code>；需要调用之前写过的函数</li>
<li>滑块宽高用<code>.offsetWidth</code>来获取<blockquote>
<p>减去宽&#x2F;高的一半，就可以使滑块的中心位置为鼠标当前所在位置</p>
</blockquote>
</li>
</ul>
</li>
</ul>
</blockquote>
</li>
<li><p>第四步：限止滑块的滑块区域</p>
<blockquote>
<ul>
<li>滑块能滑动的最小水平距离 &#x3D; 0 ，最大水平距离 &#x3D; 主图容器宽 - 滑块宽</li>
<li>滑块能滑动的最小垂直距离 &#x3D; 0 ，最大垂距离 &#x3D; 主图容器高 - 滑块高</li>
</ul>
</blockquote>
</li>
</ul>
<pre><code> //实现滑块跟随着鼠标移动
 mainImgWrap.onmousemove = function (e) &#123;
   //1. 获取鼠标与页面的距离
   var pageX = e.pageX;
   var pageY = e.pageY;
   //2.获取主图容器与浏览器的距离
   var mainLeft = getPosition(this).left;
   var mainTop = getPosition(this).top;
   //3.获取滑块宽高
   var maskWidth = mask.offsetWidth;
   var maskHeight = mask.offsetHeight;
&gt;
   //4. 计算滑块的left 和 top值 (鼠标在滑块中心)
   var left = pageX - mainLeft - maskWidth / 2;
   var top = pageY - mainTop - maskHeight / 2;
&gt;
   //5. 限制滑块距离
   var maxLeft = this.clientWidth - maskWidth;
   var maxTop = this.clientHeight - maskHeight;
&gt;
   left = left &lt; 0 ? 0 : left; //当left&lt;0
   left = left &gt; maxLeft ? maxLeft : left;
   top = top &lt; 0 ? 0 : top; //当top&lt;0
   top = top &gt; maxTop ? maxTop : top;
&gt;
   // 设置滑块的left和top值。
   mask.style.left = left + &quot;px&quot;;
   mask.style.top = top + &quot;px&quot;;
 &#125;;
&gt;
 // 获取当前元素与浏览器的left和top值
 function getPosition(el) &#123;
   // 获取当前元素左偏移量
   var left = el.offsetLeft;
   var top = el.offsetTop;
   // 获了当前元素的offsetParent
   var parent = el.offsetParent;
   // 如果 offsetParent 存在，则一直获取,计算他的offsetLeft值，如果不存在，则终止
   while (parent) &#123;
     left += parent.offsetLeft; // 与每一轮元素的父元素与其定位父元素左边距离累加
     top += parent.offsetTop;
     // 计算父元素左边框大小
     style = getComputedStyle(parent, null);
     borderLeft = parseInt(style.borderLeftWidth); // 过滤单位部分，只取数字部分
     borderTop = parseInt(style.borderTopWidth);
     // 把左边框累加进去
     left += borderLeft;
     top += borderTop;
     parent = parent.offsetParent;
   &#125;
   // 最终返回获取的left值
   return &#123; left: left, top: top &#125;;
 &#125;
</code></pre>
<ul>
<li>第五步：处理大图预览的对应移动的位置<blockquote>
<ul>
<li>通过以下公式，来求大图对应移动的 left 和 top 值</li>
<li>滑块滑动的距离 &#x2F; 滑块能滑动的最大距 &#x3D; 大图移动的距离 &#x2F; 大图能移动的最大距离</li>
<li>大图移动的距离&#x3D;（滑块滑动的距离 &#x2F; 滑块能移动的最大距离） * 大图能移动的最大距离</li>
</ul>
</blockquote>
</li>
</ul>
<pre><code> //处理大图预览的对应移动的位置
 // 1.大图最大滑动水平距离 即 left最大值
 var bigMaxLeft = bigImg.clientWidth - bigImgWrap.clientWidth;
 // 大图最大滑动垂直距离，即top最大值
 var bigMaxTop = bigImg.clientHeight - bigImgWrap.clientHeight;
 //2. 计算大图的位置
 var bigLeft = (left / maxLeft) * bigMaxLeft;
 var bigTop = (top / maxTop) * bigMaxTop;
&gt;
 // 设置大图的left和top值(负数)
 bigImg.style.left = -bigLeft + &quot;px&quot;;
 bigImg.style.top = -bigTop + &quot;px&quot;;
</code></pre>
<ol start="3">
<li><p>性能优化</p>
<blockquote>
<ul>
<li><code>onmousemove</code>做节流操作；引用节流函数</li>
<li>将<code>onmousemove</code>里面能一次性获取的放在外面，提前获取到；减少重排重绘，节省性能</li>
</ul>
</blockquote>
</li>
<li><p>完整代码</p>
</li>
</ol>
<pre><code>&gt;&lt;script&gt;
 var mainImgWrap = document.getElementById(&quot;J_main-img-wrap&quot;);
 var smallImgWrap = document.getElementById(&quot;J_small-img-wrap&quot;);
 var bigImgWrap = document.getElementById(&quot;J_big-img-wrap&quot;);
&gt;
 var smallImgs = document.querySelectorAll(&quot;#J_small-img-wrap img&quot;);
 var mainImg = document.querySelector(&quot;#J_main-img-wrap img&quot;);
 var bigImg = document.querySelector(&quot;#J_big-img-wrap img&quot;);
&gt;
 var mask = document.querySelector(&quot;#J_main-img-wrap .mask&quot;);
 var prevSmallImg = smallImgs[0];
&gt;
 //事件委托：点击小图，切换大图
 smallImgWrap.onclick = function (e) &#123;
   var target = e.target;
   var tagName = target.tagName.toLowerCase();
&gt;
   if (tagName !== &quot;img&quot;) return;
   //清除前一个选择元素样式
   prevSmallImg.classList.remove(&quot;active&quot;);
   //给当前点击的图片添加边框;
   target.classList.add(&quot;active&quot;);
   //把当前点击的图片更换为前一个激活的图片
   prevSmallImg = target;
   //更换主图
   mainImg.src = target.dataset.src;
   //更换大图
   bigImg.src = target.dataset.src;
 &#125;;
 var maskWidth;
 var maskHeight;
 var bigMaxLeft;
 var bigMaxTop;
&gt;
 //当鼠标滑动到主图容器
 mainImgWrap.onmouseover = function () &#123;
   mask.style.display = &quot;block&quot;;
   bigImgWrap.style.display = &quot;block&quot;;
&gt;
   //3.获取滑块宽高
   maskWidth = mask.offsetWidth;
   maskHeight = mask.offsetHeight;
&gt;
   // 1.大图最大滑动水平距离 即 left最大值
   bigMaxLeft = bigImg.clientWidth - bigImgWrap.clientWidth;
   // 大图最大滑动垂直距离，即top最大值
   bigMaxTop = bigImg.clientHeight - bigImgWrap.clientHeight;
&#125;; 
 //当鼠标离开主图容器
 mainImgWrap.onmouseout = function () &#123;
   mask.style.display = &quot;none&quot;;
   bigImgWrap.style.display = &quot;none&quot;;
 &#125;;
&gt;
 //2.获取主图容器与浏览器的距离
 var mainLeft = getPosition(mainImgWrap).left;
 var mainTop = getPosition(mainImgWrap).top;
&gt;
 //获取主图容器的宽高
 var mainImgWrapWidth = mainImgWrap.clientWidth;
 var mainImgWrapHeight = mainImgWrap.clientHeight;
&gt;
 //实现滑块跟随着鼠标移动
 mainImgWrap.onmousemove = throttle(fn, 100);
 function fn(e) &#123;
   //1. 获取鼠标与页面的距离
   var pageX = e.pageX;
   var pageY = e.pageY;
&gt;
   //4. 计算滑块的left 和 top值 (鼠标在滑块中心)
   var left = pageX - mainLeft - maskWidth / 2;
   var top = pageY - mainTop - maskHeight / 2;
&gt;
   //5. 限制滑块距离
   var maxLeft = mainImgWrapWidth - maskWidth;
   var maxTop = mainImgWrapHeight - maskHeight;
&gt;
   left = left &lt; 0 ? 0 : left; //当left&lt;0
   left = left &gt; maxLeft ? maxLeft : left;
   top = top &lt; 0 ? 0 : top; //当top&lt;0
   top = top &gt; maxTop ? maxTop : top;
&gt;
   // 设置滑块的left和top值。
   mask.style.left = left + &quot;px&quot;;
   mask.style.top = top + &quot;px&quot;;
&gt;
   //处理大图预览的对应移动的位置
   //2. 计算大图的位置
   var bigLeft = (left / maxLeft) * bigMaxLeft;
   var bigTop = (top / maxTop) * bigMaxTop;
&gt;
   // 设置大图的left和top值(负数)
   bigImg.style.left = -bigLeft + &quot;px&quot;;
   bigImg.style.top = -bigTop + &quot;px&quot;;
 &#125;
&gt;
 // 获取当前元素与浏览器的left和top值
 function getPosition(el) &#123;
   // 获取当前元素左偏移量
   var left = el.offsetLeft;
   var top = el.offsetTop;
   // 获了当前元素的offsetParent
   var parent = el.offsetParent;
   // 如果 offsetParent 存在，则一直获取,计算他的offsetLeft值，如果不存在，则终止
   while (parent) &#123;
     left += parent.offsetLeft; // 与每一轮元素的父元素与其定位父元素左边距离累加
     top += parent.offsetTop;
     // 计算父元素左边框大小
     style = getComputedStyle(parent, null);
     borderLeft = parseInt(style.borderLeftWidth); // 过滤单位部分，只取数字部分
     borderTop = parseInt(style.borderTopWidth);
     // 把左边框累加进去
     left += borderLeft;
     top += borderTop;
     parent = parent.offsetParent;
   &#125;
  // 最终返回获取的left值
  return &#123; left: left, top: top &#125;;
&#125;
&gt;
 // 节流操作
 function throttle(fn, delay = 20) &#123;
   var timer = null; // null表示当前锁是打开的，没有锁，可以执行事件处理函数中的代码
   return function () &#123;
     if (timer) return;
     var self = this; // 保存this 绑定事件的对象
     var args = arguments; // 保存arguments 主要用来获取事件对象 e
     // 定时器计时，用来开锁
     timer = setTimeout(function () &#123;
       fn.apply(self, args); // 事件处理函数
       timer = null; // 开锁
     &#125;, delay);
   &#125;;
 &#125;
&gt;&lt;/script&gt;
</code></pre>
<h3 id="八、手写防抖函数（经典面试题）"><a href="#八、手写防抖函数（经典面试题）" class="headerlink" title="八、手写防抖函数（经典面试题）"></a>八、手写防抖函数（经典面试题）</h3><ol>
<li>什么是防抖 ？<blockquote>
<ul>
<li>是指只有在间隔时间达到规定时间后才会执行一次真正的事件处理函数</li>
<li>如果在规定时间内再次触发事件，则会重新计时。<br>接下来我们通过一个经典的<strong>防抖案例：搜索查询</strong>来作为切入点展开讲解。</li>
</ul>
</blockquote>
</li>
</ol>
<blockquote>
<p>搜索查询 - <strong>功能需求</strong></p>
<ul>
<li>当我们在表单中输入内容时，希望在抬起键盘间隔<code>500ms</code>毫秒之后，获取输入框中输入的内容，然后再在事件处理函数中向后台发送请求，请求查询。</li>
</ul>
</blockquote>
<ol start="2">
<li>搜索查询 - 未实现防抖前效果<blockquote>
<ul>
<li>我们想要在键盘抬起后，获取输入框中的内容，然后再发送请求，请求查询</li>
<li>我们可以通过 <code>keyup</code> 事件来处理，但是当我们抬起键盘的那一刻就会触发 <code>keup</code> 事件</li>
<li>也就意味着我<strong>每次</strong>输一个字，就会触发一次 <code>keyup</code> 事件</li>
</ul>
</blockquote>
</li>
</ol>
<pre><code>&gt;&lt;body&gt;
&gt; 搜索查询：&lt;input type=&quot;text&quot; /&gt;
&gt; &lt;script&gt;
   var search = document.querySelector(&quot;input&quot;);
   search.onkeyup = function () &#123;
     console.log(this.value);
     // 获取输入框内容，向后台发请求查询
     // ....发送请求代码省略
   &#125;;
&gt; &lt;/script&gt;
&gt;&lt;/body&gt;
</code></pre>
<blockquote>
<p>以上写法存在问题</p>
<ul>
<li>以上效果肯定不是我们想要的，因为事件处理函数的<strong>执行频率太高了</strong>。<br><strong>期望效果</strong></li>
<li>我们希望的是在我们抬起键盘<code>500ms</code>后，才真正的执行一次事件处理函数中的代码。</li>
<li>如果在<code>500ms</code>以内，再次输入内容，则会<strong>重新计时</strong>，不会执行事件处理函数中的代码。</li>
</ul>
</blockquote>
<ol start="3">
<li>搜索查询 - 实现防抖后效果<br><strong>实现逻辑</strong><blockquote>
<ul>
<li>我们可以通过一个<strong>定时器</strong>来计时， 然后在定时器到达指定时间后，就执行事件处理函数中代码，向后台发送请求，请求查询</li>
<li>如果在定时器没有达到指定时间内，再次触发keyup事件，就把<strong>上一次的定时器清除掉</strong>，重新再开一个定时器<strong>重新计时</strong></li>
</ul>
</blockquote>
</li>
</ol>
<ul>
<li>版本1：</li>
</ul>
<pre><code>&gt;搜索查询：&lt;input type=&quot;text&quot; /&gt;
&gt;&lt;script&gt;
  var search = document.querySelector(&quot;input&quot;);
  var timer = null;
  search.onkeyup = function () &#123;
    clearTimeout(timer);
    self = this; //this=search传给定时器
    timer = setTimeout(function () &#123;
      //定时器里的this是window
      console.log(self.value);
      // 获取输入框内容，向后台发请求查询
      // ....发送请求代码省略
    &#125;, 2000);
  &#125;;
&gt;&lt;/script&gt;
</code></pre>
<ul>
<li>版本二</li>
</ul>
<pre><code>&gt;搜索查询：&lt;input type=&quot;text&quot; /&gt;
&gt;&lt;script&gt;
  var search = document.querySelector(&quot;input&quot;);
  var timer = null;
  search.onkeyup = function () &#123;
    if (timer) clearTimeout(timer);
    self = this; //this=search传给定时器
    timer = setTimeout(function () &#123;
      //定时器里的this是window
      console.log(self.value);
      // 获取输入框内容，向后台发请求查询
      // ....发送请求代码省略
      timer = null; // 这里很多人有争议，要不要置空
    &#125;, 2000);
  &#125;;
&gt;&lt;/script&gt;
</code></pre>
<ol start="4">
<li>抽离防抖相关代码，封装成防抖函数<blockquote>
<ul>
<li>将事件触发真正要执行的代码抽离出来放在函数<code>eventFn</code>中</li>
<li>封装防抖函数<code>debounce</code></li>
<li>事件处理函数<code>eventFn</code>不能写死，要让用户自己定义，所以通过参数传进去</li>
<li>定时器的延迟时间也不能写死，通过参数传入</li>
</ul>
</blockquote>
</li>
</ol>
<pre><code>&gt;&lt;script&gt;
  var search = document.querySelector(&quot;input&quot;);
  search.onkeyup = debounce(eventFn, 1000)  
  function debounce(fn, delay = 500) &#123;
    var timer = null;
    return function () &#123;
      if (timer) clearTimeout(timer);
      var self = this; 
      timer = setTimeout(function () &#123;
        fn();
        // 获取输入框内容，向后台发请求查询
        // ....发送请求代码省略
        timer = null; // 这里很多人有争议，要不要置空
      &#125;, delay);
    &#125;;
  &#125;
  function eventFn() &#123;
    console.log(self.value);
  &#125;
&gt;&lt;/script&gt;
</code></pre>
<ul>
<li>进一步优化<blockquote>
<ul>
<li><code>denounce</code> 函数内调用的 <code>fn</code> 事件处理函数中的 <code>this</code> 和 事件对象 <code>e</code> 是有问题的</li>
<li><code>fn()</code>直接调用，内部 <code>this</code> 肯定指向的是 window，同时事件对象 e 被丢失了</li>
<li>所以我们要修改<code>fn()</code>时，内部的 <code>this </code>指向，同时把事件对象 <code>e</code> 传递进去。</li>
</ul>
</blockquote>
</li>
</ul>
<ol start="5">
<li>ES5 版本 - 防抖函数</li>
</ol>
<pre><code> &gt;搜索查询：&lt;input type=&quot;text&quot; /&gt;
 &gt;&lt;script&gt;
   var search = document.querySelector(&quot;input&quot;);
   search.onkeyup = debounce(eventFn, 1000);
&gt;
 function debounce(fn, delay = 500) &#123;
   var timer = null;
   return function () &#123;
     if (timer) clearTimeout(timer);
     var self = this;
     var args = arguments;
     timer = setTimeout(function () &#123;
       fn.apply(self, args); //fn()直接调用，内部 this 肯定指向的是 window
       // 获取输入框内容，向后台发请求查询
       // ....发送请求代码省略
       timer = null; // 这里很多人有争议，要不要置空
     &#125;, delay);
   &#125;;
 &#125;
 function eventFn() &#123;
   console.log(this.value);
 &#125;
&gt;&lt;/script&gt;
</code></pre>
<ol start="6">
<li>ES6 版本 - 防抖函数</li>
</ol>
<pre><code>&gt;/**
&gt; * debounce 防抖函数
&gt; * @param fn 事件处理函数
&gt; * @param delay 延迟时间
&gt; */
function debounce(fn, delay = 200) &#123;
  var timer = null;
  // 以下是每次需要执行的代码
  return function () &#123;
    if (timer) clearTimeout(timer);
    // 开启定时器
    timer = setTimeout(() =&gt; &#123;
      fn.apply(this, arguments);
      timer = null; // 这里很多人有争议，要不要置空
    &#125;, delay);
  &#125;;
&#125;
</code></pre>
<ol start="7">
<li>区分防抖与节流<blockquote>
<p><strong>不同点</strong></p>
<ul>
<li>节流：不管事件触发有多频繁，都会保证在规定时间内执行一次真正的事件处理函数</li>
<li>防抖：只有在间隔时间达到规定时间后才会执行一次真正的事件处理函数，如果在规定时间内再次触发事件，则会重新计时。<br><strong>相同点</strong></li>
<li>都可以通过使用 <code>setTimeout</code> 来实现</li>
<li>都是降低真正的事件处理函数的执行频率，达到节省计算资 源，减少性能的消耗<br><strong>节流应用场景</strong></li>
<li>搜索框输入查询、手机号、邮箱验证输入检测。</li>
<li><code>resize</code>事件，只需在窗口调整完后，计算窗口大小，防止重复渲染<br><strong>防抖应用场景</strong></li>
<li><code>scroll</code>滚动事件，判断是否滚动到页面底部，自动加载更多内容</li>
<li><code>mousemove</code>事件，当拖拽页面元素，或鼠标跟随效果</li>
<li>防止高频点击提交，防止表单重复提交</li>
</ul>
</blockquote>
</li>
</ol>

                
            </div>
            <hr/>

            

    <div class="reprint" id="reprint-statement">
        
            <div class="reprint__author">
                <span class="reprint-meta" style="font-weight: bold;">
                    <i class="fas fa-user">
                        文章作者:
                    </i>
                </span>
                <span class="reprint-info">
                    <a href="/about" rel="external nofollow noreferrer">hermia</a>
                </span>
            </div>
            <div class="reprint__type">
                <span class="reprint-meta" style="font-weight: bold;">
                    <i class="fas fa-link">
                        文章链接:
                    </i>
                </span>
                <span class="reprint-info">
                    <a href="https://hermiablog.com/2023/12/07/JS%E6%A0%B8%E5%BF%83%E7%9F%A5%E8%AF%86%E7%82%B9%EF%BC%88%E5%8D%81%E4%B8%80%EF%BC%89/">https://hermiablog.com/2023/12/07/JS%E6%A0%B8%E5%BF%83%E7%9F%A5%E8%AF%86%E7%82%B9%EF%BC%88%E5%8D%81%E4%B8%80%EF%BC%89/</a>
                </span>
            </div>
            <div class="reprint__notice">
                <span class="reprint-meta" style="font-weight: bold;">
                    <i class="fas fa-copyright">
                        版权声明:
                    </i>
                </span>
                <span class="reprint-info">
                    本博客所有文章除特別声明外，均采用
                    <a href="https://creativecommons.org/licenses/by/4.0/deed.zh" rel="external nofollow noreferrer" target="_blank">CC BY 4.0</a>
                    许可协议。转载请注明来源
                    <a href="/about" target="_blank">hermia</a>
                    !
                </span>
            </div>
        
    </div>

    <script async defer>
      document.addEventListener("copy", function (e) {
        let toastHTML = '<span>复制成功，请遵循本文的转载规则</span><button class="btn-flat toast-action" onclick="navToReprintStatement()" style="font-size: smaller">查看</a>';
        M.toast({html: toastHTML})
      });

      function navToReprintStatement() {
        $("html, body").animate({scrollTop: $("#reprint-statement").offset().top - 80}, 800);
      }
    </script>



            <div class="tag_share" style="display: block;">
                <div class="post-meta__tag-list" style="display: inline-block;">
                    
                        <div class="article-tag">
                            
                                <a href="/tags/JS/">
                                    <span class="chip bg-color">JS</span>
                                </a>
                            
                        </div>
                    
                </div>
                <div class="post_share" style="zoom: 80%; width: fit-content; display: inline-block; float: right; margin: -0.15rem 0;">
                    <link rel="stylesheet" type="text/css" href="/libs/share/css/share.min.css">
<div id="article-share">

    
    <div class="social-share" data-sites="qq,qzone,wechat,weibo" data-wechat-qrcode-helper="<p>微信扫一扫即可分享！</p>"></div>
    <script src="/libs/share/js/social-share.min.js"></script>
    

    

</div>

                </div>
            </div>
            
                <style>
    #reward {
        margin: 40px 0;
        text-align: center;
    }

    #reward .reward-link {
        font-size: 1.4rem;
        line-height: 38px;
    }

    #reward .btn-floating:hover {
        box-shadow: 0 6px 12px rgba(0, 0, 0, 0.2), 0 5px 15px rgba(0, 0, 0, 0.2);
    }

    #rewardModal {
        width: 320px;
        height: 350px;
    }

    #rewardModal .reward-title {
        margin: 15px auto;
        padding-bottom: 5px;
    }

    #rewardModal .modal-content {
        padding: 10px;
    }

    #rewardModal .close {
        position: absolute;
        right: 15px;
        top: 15px;
        color: rgba(0, 0, 0, 0.5);
        font-size: 1.3rem;
        line-height: 20px;
        cursor: pointer;
    }

    #rewardModal .close:hover {
        color: #ef5350;
        transform: scale(1.3);
        -moz-transform:scale(1.3);
        -webkit-transform:scale(1.3);
        -o-transform:scale(1.3);
    }

    #rewardModal .reward-tabs {
        margin: 0 auto;
        width: 210px;
    }

    .reward-tabs .tabs {
        height: 38px;
        margin: 10px auto;
        padding-left: 0;
    }

    .reward-content ul {
        padding-left: 0 !important;
    }

    .reward-tabs .tabs .tab {
        height: 38px;
        line-height: 38px;
    }

    .reward-tabs .tab a {
        color: #fff;
        background-color: #ccc;
    }

    .reward-tabs .tab a:hover {
        background-color: #ccc;
        color: #fff;
    }

    .reward-tabs .wechat-tab .active {
        color: #fff !important;
        background-color: #22AB38 !important;
    }

    .reward-tabs .alipay-tab .active {
        color: #fff !important;
        background-color: #019FE8 !important;
    }

    .reward-tabs .reward-img {
        width: 210px;
        height: 210px;
    }
</style>

<div id="reward">
    <a href="#rewardModal" class="reward-link modal-trigger btn-floating btn-medium waves-effect waves-light red">赏</a>

    <!-- Modal Structure -->
    <div id="rewardModal" class="modal">
        <div class="modal-content">
            <a class="close modal-close"><i class="fas fa-times"></i></a>
            <h4 class="reward-title">你的赏识是我前进的动力</h4>
            <div class="reward-content">
                <div class="reward-tabs">
                    <ul class="tabs row">
                        <li class="tab col s6 alipay-tab waves-effect waves-light"><a href="#alipay">支付宝</a></li>
                        <li class="tab col s6 wechat-tab waves-effect waves-light"><a href="#wechat">微 信</a></li>
                    </ul>
                    <div id="alipay">
                        <img src="/medias/reward/alipay.jpg" class="reward-img" alt="支付宝打赏二维码">
                    </div>
                    <div id="wechat">
                        <img src="/medias/reward/wechat.png" class="reward-img" alt="微信打赏二维码">
                    </div>
                </div>
            </div>
        </div>
    </div>
</div>

<script>
    $(function () {
        $('.tabs').tabs();
    });
</script>

            
        </div>
    </div>

    

    

    

    

    

    

    

    

<article id="prenext-posts" class="prev-next articles">
    <div class="row article-row">
        
        <div class="article col s12 m6" data-aos="fade-up">
            <div class="article-badge left-badge text-color">
                <i class="fas fa-chevron-left"></i>&nbsp;上一篇</div>
            <div class="card">
                <a href="/2023/12/07/JS%E6%A0%B8%E5%BF%83%E7%9F%A5%E8%AF%86%E7%82%B9%EF%BC%88%E5%8D%81%E4%BA%8C%EF%BC%89/">
                    <div class="card-image">
                        
                        <img src="/medias/featureimages/22.jpg" class="responsive-img" alt="JS核心知识点（十二）">
                        
                        <span class="card-title">JS核心知识点（十二）</span>
                    </div>
                </a>
                <div class="card-content article-content">
                    <div class="summary block-with-text">
                        
                            JavaScript 鼠标事件 和 HTML5 拖拽事件的综合应用
                        
                    </div>
                    <div class="publish-info">
                        <span class="publish-date">
                            <i class="far fa-clock fa-fw icon-date"></i>2023-12-07
                        </span>
                        <span class="publish-author">
                            
                            <i class="fas fa-bookmark fa-fw icon-category"></i>
                            
                            <a href="/categories/%E6%8A%80%E6%9C%AF/" class="post-category">
                                    技术
                                </a>
                            
                            
                        </span>
                    </div>
                </div>
                
                <div class="card-action article-tags">
                    
                    <a href="/tags/JS/">
                        <span class="chip bg-color">JS</span>
                    </a>
                    
                </div>
                
            </div>
        </div>
        
        
        <div class="article col s12 m6" data-aos="fade-up">
            <div class="article-badge right-badge text-color">
                下一篇&nbsp;<i class="fas fa-chevron-right"></i>
            </div>
            <div class="card">
                <a href="/2023/12/05/JS%E6%A0%B8%E5%BF%83%E7%9F%A5%E8%AF%86%E7%82%B9%EF%BC%88%E5%8D%81%EF%BC%89/">
                    <div class="card-image">
                        
                        <img src="/medias/featureimages/20.jpg" class="responsive-img" alt="JS核心知识点（十）">
                        
                        <span class="card-title">JS核心知识点（十）</span>
                    </div>
                </a>
                <div class="card-content article-content">
                    <div class="summary block-with-text">
                        
                            JS DOM 事件，事件流，事件对象，事件委托
                        
                    </div>
                    <div class="publish-info">
                            <span class="publish-date">
                                <i class="far fa-clock fa-fw icon-date"></i>2023-12-05
                            </span>
                        <span class="publish-author">
                            
                            <i class="fas fa-bookmark fa-fw icon-category"></i>
                            
                            <a href="/categories/%E6%8A%80%E6%9C%AF/" class="post-category">
                                    技术
                                </a>
                            
                            
                        </span>
                    </div>
                </div>
                
                <div class="card-action article-tags">
                    
                    <a href="/tags/JS/">
                        <span class="chip bg-color">JS</span>
                    </a>
                    
                </div>
                
            </div>
        </div>
        
    </div>
</article>

</div>



<!-- 代码块功能依赖 -->
<script type="text/javascript" src="/libs/codeBlock/codeBlockFuction.js"></script>

<!-- 代码语言 -->

<script type="text/javascript" src="/libs/codeBlock/codeLang.js"></script>


<!-- 代码块复制 -->

<script type="text/javascript" src="/libs/codeBlock/codeCopy.js"></script>


<!-- 代码块收缩 -->

<script type="text/javascript" src="/libs/codeBlock/codeShrink.js"></script>


  </div>
  <div id="toc-aside" class="expanded col l3 hide-on-med-and-down">
    <div class="toc-widget card" style="background-color: white">
      <div class="toc-title">
        <i class="far fa-list-alt"></i>&nbsp;&nbsp;目录
      </div>
      <div id="toc-content"></div>
    </div>
  </div>
</div>

<!-- TOC 悬浮按钮. -->

<div id="floating-toc-btn" class="hide-on-med-and-down">
  <a class="btn-floating btn-large bg-color">
    <i class="fas fa-list-ul"></i>
  </a>
</div>


<script src="/libs/tocbot/tocbot.min.js"></script>
<script>
  $(function () {
      tocbot.init({
          tocSelector: '#toc-content',
          contentSelector: '#articleContent',
          headingsOffset: -($(window).height() * 0.4 - 45),
          collapseDepth: Number('0'),
          headingSelector: 'h2, h3, h4'
      });

      // modify the toc link href to support Chinese.
      let i = 0;
      let tocHeading = 'toc-heading-';
      $('#toc-content a').each(function () {
          $(this).attr('href', '#' + tocHeading + (++i));
      });

      // modify the heading title id to support Chinese.
      i = 0;
      $('#articleContent').children('h2, h3, h4').each(function () {
          $(this).attr('id', tocHeading + (++i));
      });

      // Set scroll toc fixed.
      let tocHeight = parseInt($(window).height() * 0.4 - 64);
      let $tocWidget = $('.toc-widget');
      $(window).scroll(function () {
          let scroll = $(window).scrollTop();
          /* add post toc fixed. */
          if (scroll > tocHeight) {
              $tocWidget.addClass('toc-fixed');
          } else {
              $tocWidget.removeClass('toc-fixed');
          }
      });

      
      /* 修复文章卡片 div 的宽度. */
      let fixPostCardWidth = function (srcId, targetId) {
          let srcDiv = $('#' + srcId);
          if (srcDiv.length === 0) {
              return;
          }

          let w = srcDiv.width();
          if (w >= 450) {
              w = w + 21;
          } else if (w >= 350 && w < 450) {
              w = w + 18;
          } else if (w >= 300 && w < 350) {
              w = w + 16;
          } else {
              w = w + 14;
          }
          $('#' + targetId).width(w);
      };

      // 切换TOC目录展开收缩的相关操作.
      const expandedClass = 'expanded';
      let $tocAside = $('#toc-aside');
      let $mainContent = $('#main-content');
      $('#floating-toc-btn .btn-floating').click(function () {
          if ($tocAside.hasClass(expandedClass)) {
              $tocAside.removeClass(expandedClass).hide();
              $mainContent.removeClass('l9');
          } else {
              $tocAside.addClass(expandedClass).show();
              $mainContent.addClass('l9');
          }
          fixPostCardWidth('artDetail', 'prenext-posts');
      });
      
  });
</script>

    

</main>




    <footer class="page-footer bg-color">
   <link rel="stylesheet" href="/libs/aplayer/APlayer.min.css">
<style>
    .aplayer .aplayer-lrc p {
        
        font-size: 12px;
        font-weight: 700;
        line-height: 16px !important;
    }

    .aplayer .aplayer-lrc p.aplayer-lrc-current {
        
        font-size: 15px;
        color: #a3ddf0;
        /* color: #59cde9; */
    }

    
    .aplayer.aplayer-fixed.aplayer-narrow .aplayer-body {
        left: -66px !important;
    }

    .aplayer.aplayer-fixed.aplayer-narrow .aplayer-body:hover {
        left: 0px !important;
    }

    
</style>
<div class="">
    
    <div class="row">
        <meting-js class="col l8 offset-l2 m10 offset-m1 s12"
                   server="netease"
                   type="playlist"
                   id="2450546498"
                   fixed='true'
                   autoplay='false'
                   theme='#59cde9'
                   loop='all'
                   order='random'
                   preload='auto'
                   volume='0.7'
                   list-folded='true'
        >
        </meting-js>
    </div>
</div>

<script src="/libs/aplayer/APlayer.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/meting@2/dist/Meting.min.js"></script>
 
  <div
    class="container row center-align"
    style="margin-bottom: 15px !important;"
  >
    <div class="col s12 m8 l8 copy-right">
      Copyright&nbsp;&copy; 
      <span id="year"
        >2023-2024</span
      >
      
      <span id="year">2023</span>
      <a href="/about" target="_blank"
        >hermia</a
      >
      |&nbsp;Powered by&nbsp;<a href="https://hexo.io/" target="_blank">Hexo</a>
      |&nbsp;Theme&nbsp;<a
        href="https://github.com/blinkfox/hexo-theme-matery"
        target="_blank"
        >Matery</a
      >
      <br />
           
      <span id="busuanzi_container_site_pv">
        |&nbsp;<i class="far fa-eye"></i>&nbsp;总访问量:&nbsp;<span
          id="busuanzi_value_site_pv"
          class="white-color"
        ></span
        >&nbsp;次
      </span>
       
      <span id="busuanzi_container_site_uv">
        |&nbsp;<i class="fas fa-users"></i>&nbsp;总访问人数:&nbsp;<span
          id="busuanzi_value_site_uv"
          class="white-color"
        ></span
        >&nbsp;人
      </span>
      
      <br />
      
      <span id="sitetime">载入运行时间...</span>
      <script>
        function siteTime() {
          var seconds = 1000;
          var minutes = seconds * 60;
          var hours = minutes * 60;
          var days = hours * 24;
          var years = days * 365;
          var today = new Date();
          var startYear = "2023";
          var startMonth = "11";
          var startDate = "14";
          var startHour = "0";
          var startMinute = "0";
          var startSecond = "0";
          var todayYear = today.getFullYear();
          var todayMonth = today.getMonth() + 1;
          var todayDate = today.getDate();
          var todayHour = today.getHours();
          var todayMinute = today.getMinutes();
          var todaySecond = today.getSeconds();
          var t1 = Date.UTC(
            startYear,
            startMonth,
            startDate,
            startHour,
            startMinute,
            startSecond
          );
          var t2 = Date.UTC(
            todayYear,
            todayMonth,
            todayDate,
            todayHour,
            todayMinute,
            todaySecond
          );
          var diff = t2 - t1;
          var diffYears = Math.floor(diff / years);
          var diffDays = Math.floor(diff / days - diffYears * 365);
          var diffHours = Math.floor(
            (diff - (diffYears * 365 + diffDays) * days) / hours
          );
          var diffMinutes = Math.floor(
            (diff - (diffYears * 365 + diffDays) * days - diffHours * hours) /
              minutes
          );
          var diffSeconds = Math.floor(
            (diff -
              (diffYears * 365 + diffDays) * days -
              diffHours * hours -
              diffMinutes * minutes) /
              seconds
          );
          if (startYear == todayYear) {
            document.getElementById("year").innerHTML = todayYear;
            document.getElementById("sitetime").innerHTML =
              "本站已安全运行 " +
              diffDays +
              " 天 " +
              diffHours +
              " 小时 " +
              diffMinutes +
              " 分钟 " +
              diffSeconds +
              " 秒";
          } else {
            document.getElementById("year").innerHTML =
              startYear + " - " + todayYear;
            document.getElementById("sitetime").innerHTML =
              "本站已安全运行 " +
              diffYears +
              " 年 " +
              diffDays +
              " 天 " +
              diffHours +
              " 小时 " +
              diffMinutes +
              " 分钟 " +
              diffSeconds +
              " 秒";
          }
        }
        setInterval(siteTime, 1000);
      </script>
      
      <br />
      
    </div>
    <div class="col s12 m4 l4 social-link social-statis">
      
<a
  href="https://github.com/hermiablog/hermiablog.github.io"
  class="tooltipped"
  target="_blank"
  data-tooltip="访问我的GitHub"
  data-position="top"
  data-delay="50"
>
  <i class="fab fa-github"></i>
</a>
 
<a
  href="mailto:1587837237@qq.com"
  class="tooltipped"
  target="_blank"
  data-tooltip="邮件联系我"
  data-position="top"
  data-delay="50"
>
  <i class="fas fa-envelope-open"></i>
</a>
<!-- 
   
<a
  href="tencent://AddContact/?fromId=50&fromSubId=1&subcmd=all&uin=1587837237"
  class="tooltipped"
  target="_blank"
  data-tooltip="QQ联系我: 1587837237"
  data-position="top"
  data-delay="50"
>
  <i class="fab fa-qq"></i>
</a>
    -->

    </div>
  </div>
</footer>

<div class="progress-bar"></div>


    <!-- 搜索遮罩框 -->
<div id="searchModal" class="modal">
    <div class="modal-content">
        <div class="search-header">
            <span class="title"><i class="fas fa-search"></i>&nbsp;&nbsp;搜索</span>
            <input type="search" id="searchInput" name="s" placeholder="请输入搜索的关键字"
                   class="search-input">
        </div>
        <div id="searchResult"></div>
    </div>
</div>

<script type="text/javascript">
$(function () {
    var searchFunc = function (path, search_id, content_id) {
        'use strict';
        $.ajax({
            url: path,
            dataType: "xml",
            success: function (xmlResponse) {
                // get the contents from search data
                var datas = $("entry", xmlResponse).map(function () {
                    return {
                        title: $("title", this).text(),
                        content: $("content", this).text(),
                        url: $("url", this).text()
                    };
                }).get();
                var $input = document.getElementById(search_id);
                var $resultContent = document.getElementById(content_id);
                $input.addEventListener('input', function () {
                    var str = '<ul class=\"search-result-list\">';
                    var keywords = this.value.trim().toLowerCase().split(/[\s\-]+/);
                    $resultContent.innerHTML = "";
                    if (this.value.trim().length <= 0) {
                        return;
                    }
                    // perform local searching
                    datas.forEach(function (data) {
                        var isMatch = true;
                        var data_title = data.title.trim().toLowerCase();
                        var data_content = data.content.trim().replace(/<[^>]+>/g, "").toLowerCase();
                        var data_url = data.url;
                        data_url = data_url.indexOf('/') === 0 ? data.url : '/' + data_url;
                        var index_title = -1;
                        var index_content = -1;
                        var first_occur = -1;
                        // only match artiles with not empty titles and contents
                        if (data_title !== '' && data_content !== '') {
                            keywords.forEach(function (keyword, i) {
                                index_title = data_title.indexOf(keyword);
                                index_content = data_content.indexOf(keyword);
                                if (index_title < 0 && index_content < 0) {
                                    isMatch = false;
                                } else {
                                    if (index_content < 0) {
                                        index_content = 0;
                                    }
                                    if (i === 0) {
                                        first_occur = index_content;
                                    }
                                }
                            });
                        }
                        // show search results
                        if (isMatch) {
                            str += "<li><a href='" + data_url + "' class='search-result-title'>" + data_title + "</a>";
                            var content = data.content.trim().replace(/<[^>]+>/g, "");
                            if (first_occur >= 0) {
                                // cut out 100 characters
                                var start = first_occur - 20;
                                var end = first_occur + 80;
                                if (start < 0) {
                                    start = 0;
                                }
                                if (start === 0) {
                                    end = 100;
                                }
                                if (end > content.length) {
                                    end = content.length;
                                }
                                var match_content = content.substr(start, end);
                                // highlight all keywords
                                keywords.forEach(function (keyword) {
                                    var regS = new RegExp(keyword, "gi");
                                    match_content = match_content.replace(regS, "<em class=\"search-keyword\">" + keyword + "</em>");
                                });

                                str += "<p class=\"search-result\">" + match_content + "...</p>"
                            }
                            str += "</li>";
                        }
                    });
                    str += "</ul>";
                    $resultContent.innerHTML = str;
                });
            }
        });
    };

    searchFunc('/search.xml', 'searchInput', 'searchResult');
});
</script>

    <!-- 回到顶部按钮 -->
<div id="backTop" class="top-scroll">
    <a class="btn-floating btn-large waves-effect waves-light" href="#!">
        <i class="fas fa-arrow-up"></i>
    </a>
</div>


    <script src="/libs/materialize/materialize.min.js"></script>
    <script src="/libs/masonry/masonry.pkgd.min.js"></script>
    <script src="/libs/aos/aos.js"></script>
    <script src="/libs/scrollprogress/scrollProgress.min.js"></script>
    <script src="/libs/lightGallery/js/lightgallery-all.min.js"></script>
    <script src="/js/matery.js"></script>

    <!-- Baidu Analytics -->

    <!-- Baidu Push -->

<script>
    (function () {
        var bp = document.createElement('script');
        var curProtocol = window.location.protocol.split(':')[0];
        if (curProtocol === 'https') {
            bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';
        } else {
            bp.src = 'http://push.zhanzhang.baidu.com/push.js';
        }
        var s = document.getElementsByTagName("script")[0];
        s.parentNode.insertBefore(bp, s);
    })();
</script>

    
    <script src="/libs/others/clicklove.js" async="async"></script>
    
    
    <script async src="/libs/others/busuanzi.pure.mini.js"></script>
    

    

    

	
    

    

    

    
    <script src="/libs/instantpage/instantpage.js" type="module"></script>
    

</body>

</html>
