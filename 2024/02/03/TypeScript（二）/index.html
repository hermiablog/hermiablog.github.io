<!DOCTYPE HTML>
<html lang="zh-CN">


<head>
    <meta charset="utf-8">
    <meta name="keywords" content="TypeScript（二）, 技术博客">
    <meta name="description" content="个人技术博客">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <meta name="renderer" content="webkit|ie-stand|ie-comp">
    <meta name="mobile-web-app-capable" content="yes">
    <meta name="format-detection" content="telephone=no">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <!-- Global site tag (gtag.js) - Google Analytics -->


    <title>TypeScript（二） | hermia&#39;s blog</title>
    <link rel="icon" type="image/png" href="/favicon.png">

    <link rel="stylesheet" type="text/css" href="/libs/awesome/css/all.css">
    <link rel="stylesheet" type="text/css" href="/libs/materialize/materialize.min.css">
    <link rel="stylesheet" type="text/css" href="/libs/aos/aos.css">
    <link rel="stylesheet" type="text/css" href="/libs/animate/animate.min.css">
    <link rel="stylesheet" type="text/css" href="/libs/lightGallery/css/lightgallery.min.css">
    <link rel="stylesheet" type="text/css" href="/css/matery.css">
    <link rel="stylesheet" type="text/css" href="/css/my.css">

    <script src="/libs/jquery/jquery.min.js"></script>

<meta name="generator" content="Hexo 6.3.0"><link rel="stylesheet" href="/css/prism-tomorrow.css" type="text/css"></head>



   <style>
    body{
       background-image: url(https://cdn.pixabay.com/photo/2012/04/14/16/37/sky-34536_1280.png);
       background-repeat:no-repeat;
       background-size:cover;
       background-attachment:fixed;
    }
</style>



<body>
    <header class="navbar-fixed">
    <nav id="headNav" class="bg-color nav-transparent">
        <div id="navContainer" class="nav-wrapper container">
            <div class="brand-logo">
                <a href="/" class="waves-effect waves-light">
                    
                    <img src="/medias/logo.png" class="logo-img" alt="LOGO">
                    
                    <span class="logo-span">hermia&#39;s blog</span>
                </a>
            </div>
            

<a href="#" data-target="mobile-nav" class="sidenav-trigger button-collapse"><i class="fas fa-bars"></i></a>
<ul class="right nav-menu">
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/" class="waves-effect waves-light">
      
      <i class="fas fa-home" style="zoom: 0.6;"></i>
      
      <span>首页</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/tags" class="waves-effect waves-light">
      
      <i class="fas fa-tags" style="zoom: 0.6;"></i>
      
      <span>标签</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/categories" class="waves-effect waves-light">
      
      <i class="fas fa-bookmark" style="zoom: 0.6;"></i>
      
      <span>分类</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/archives" class="waves-effect waves-light">
      
      <i class="fas fa-archive" style="zoom: 0.6;"></i>
      
      <span>归档</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/about" class="waves-effect waves-light">
      
      <i class="fas fa-user-circle" style="zoom: 0.6;"></i>
      
      <span>关于</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/friends" class="waves-effect waves-light">
      
      <i class="fas fa-address-book" style="zoom: 0.6;"></i>
      
      <span>友情链接</span>
    </a>
    
  </li>
  
  <li>
    <a href="#searchModal" class="modal-trigger waves-effect waves-light">
      <i id="searchIcon" class="fas fa-search" title="搜索" style="zoom: 0.85;"></i>
    </a>
  </li>
</ul>


<div id="mobile-nav" class="side-nav sidenav">

    <div class="mobile-head bg-color">
        
        <img src="/medias/logo.png" class="logo-img circle responsive-img">
        
        <div class="logo-name">hermia&#39;s blog</div>
        <div class="logo-desc">
            
            个人技术博客
            
        </div>
    </div>

    

    <ul class="menu-list mobile-menu-list">
        
        <li class="m-nav-item">
	  
		<a href="/" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-home"></i>
			
			首页
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/tags" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-tags"></i>
			
			标签
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/categories" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-bookmark"></i>
			
			分类
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/archives" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-archive"></i>
			
			归档
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/about" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-user-circle"></i>
			
			关于
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/friends" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-address-book"></i>
			
			友情链接
		</a>
          
        </li>
        
        
    </ul>
</div>


        </div>

        
    </nav>

</header>

    



<div class="bg-cover pd-header post-cover" style="background-image: url('/medias/featureimages/52.png')">
    <div class="container" style="right: 0px;left: 0px;">
        <div class="row">
            <div class="col s12 m12 l12">
                <div class="brand">
                    <h1 class="description center-align post-title">TypeScript（二）</h1>
                </div>
            </div>
        </div>
    </div>
</div>




<main class="post-container content">

    
    <link
  rel="stylesheet"
  href="/libs/tocbot/tocbot.css"
/>
<style>
  #articleContent h1::before,
  #articleContent h2::before,
  #articleContent h3::before,
  #articleContent h4::before,
  #articleContent h5::before,
  #articleContent h6::before {
    display: block;
    content: " ";
    height: 100px;
    margin-top: -100px;
    visibility: hidden;
  }

  #articleContent :focus {
    outline: none;
  }

  .toc-fixed {
    position: fixed;
    top: 64px;
  }

  /* .toc-widget {
        width: 345px;
        padding-left: 20px;
    } */
  .toc-widget {
    width: 345px;
    padding-left: 20px;
    background-color: rgb(255, 255, 255, 0.7);
    border-radius: 10px;
    box-shadow: 0 10px 35px 2px rgba(0, 0, 0, 0.15),
      0 5px 15px rgba(0, 0, 0, 0.07), 0 2px 5px -5px rgba(0, 0, 0, 0.1) !important;
  }

  .toc-widget .toc-title {
    padding: 35px 0 15px 17px;
    font-size: 1.5rem;
    font-weight: bold;
    line-height: 1.5rem;
  }

  .toc-widget ol {
    padding: 0;
    list-style: none;
  }

  #toc-content {
    padding-bottom: 30px;
    overflow: auto;
  }

  #toc-content ol {
    padding-left: 10px;
  }

  #toc-content ol li {
    padding-left: 10px;
  }

  #toc-content .toc-link:hover {
    color: #a3ddf0;
    font-weight: 700;
    text-decoration: underline;
  }

  #toc-content .toc-link::before {
    background-color: transparent;
    max-height: 25px;

    position: absolute;
    right: 23.5vw;
    display: block;
  }

  #toc-content .is-active-link {
    color: #a3ddf0;
  }

  #floating-toc-btn {
    position: fixed;
    right: 15px;
    bottom: 76px;
    padding-top: 15px;
    margin-bottom: 0;
    z-index: 998;
  }

  #floating-toc-btn .btn-floating {
    width: 48px;
    height: 48px;
  }

  #floating-toc-btn .btn-floating i {
    line-height: 48px;
    font-size: 1.4rem;
  }
</style>
<div class="row">
  <div id="main-content" class="col s12 m12 l9">
    <!-- 文章内容详情 -->
<div id="artDetail">
    <div class="card">
        <div class="card-content article-info">
            <div class="row tag-cate">
                <div class="col s7">
                    
                    <div class="article-tag">
                        
                            <a href="/tags/TypesSript/">
                                <span class="chip bg-color">TypesSript</span>
                            </a>
                        
                    </div>
                    
                </div>
                <div class="col s5 right-align">
                    
                    <div class="post-cate">
                        <i class="fas fa-bookmark fa-fw icon-category"></i>
                        
                            <a href="/categories/%E6%8A%80%E6%9C%AF/" class="post-category">
                                技术
                            </a>
                        
                    </div>
                    
                </div>
            </div>

            <div class="post-info">
                
                <div class="post-date info-break-policy">
                    <i class="far fa-calendar-minus fa-fw"></i>发布日期:&nbsp;&nbsp;
                    2024-02-03
                </div>
                

                
                <div class="post-date info-break-policy">
                    <i class="far fa-calendar-check fa-fw"></i>更新日期:&nbsp;&nbsp;
                    2024-02-07
                </div>
                

                
                <div class="info-break-policy">
                    <i class="far fa-file-word fa-fw"></i>文章字数:&nbsp;&nbsp;
                    13.8k
                </div>
                

                

                
            </div>
        </div>
        <hr class="clearfix">

        

        

        <div class="card-content article-card-content">
            <div id="articleContent">
                <span id="more"></span>
<h3 id="一、函数类型"><a href="#一、函数类型" class="headerlink" title="一、函数类型"></a>一、函数类型</h3><h4 id="函数类型声明"><a href="#函数类型声明" class="headerlink" title="函数类型声明"></a>函数类型声明</h4><blockquote>
<p>函数的类型声明，需要在声明函数时，给出参数的类型和返回值的类型。</p>
</blockquote>
<pre><code>function foo(str: string): void &#123;
  console.log(&quot;hi &quot; + str);
&#125;

// 函数 foo() 在声明时，需要给出参数 str 的类型（string），以及返回值的类型（void），后者写在参数列表的圆括号后面
</code></pre>
<ul>
<li>void 类型表示没有返回值（后边会详细讲解）</li>
<li>如果不指定参数类型，TypeScript 就会推断参数类型，如果缺乏足够信息，就会推断该参数的类型为<code>any</code></li>
</ul>
<blockquote>
<p>返回值的类型通常可以不写，因为 TypeScript 自己会推断出来。</p>
</blockquote>
<pre><code>function foo(str: string) &#123;
  console.log(&quot;hi &quot; + str);
&#125;
</code></pre>
<ul>
<li>由于没有 <code>return</code> 语句，TypeScript 会推断出函数<code>foo()</code> 没有返回值</li>
<li>不过，有时候出于文档目的，或者为了防止不小心改掉返回值，还是会写返回值的类型。</li>
</ul>
<ol>
<li>变量被赋值一个函数<blockquote>
<p>如果变量被赋值为一个函数，变量的类型有两种写法</p>
</blockquote>
</li>
</ol>
<pre><code>// 写法一
const hello = function (txt:string) &#123;
  console.log(&#39;hello &#39; + txt);
&#125;

// 写法二
const hello:
  (txt:string) =&gt; void
= function (txt) &#123;
  console.log(&#39;hello &#39; + txt);
&#125;;
</code></pre>
<ul>
<li>变量<code>hello</code>被赋值为一个函数，它的类型有两种写法：</li>
<li>写法一：是通过等号右边的函数类型，推断出变量<code>hello</code>的类型；</li>
<li>写法二：是使用箭头函数的形式，为变量<code>hello</code>指定类型，参数的类型写在箭头左侧，返回值的类型写在箭头右侧</li>
</ul>
<blockquote>
<p>写法二的两个注意事项：</p>
</blockquote>
<ul>
<li>①、函数的参数要放在圆括号里面，不放会报错</li>
<li>②、类型里面的参数名（本例是<code>txt</code>）是必须的。有的语言的函数类型可以不写参数名（比如 C 语言），但是 TypeScript 不行。如果写成<code>(string) =&gt; void</code>，TypeScript 会理解成函数有一个名叫 string 的参数，并且这个string参数的类型是any。</li>
<li>函数类型没写参数名，导致 TypeScript 认为参数类型都是any。</li>
</ul>
<pre><code>type Func = (string, number) =&gt; number; // 报错
// (string: any, number: any) =&gt; number;
</code></pre>
<ol start="2">
<li>参数名与实际参数名<blockquote>
<p>函数类型里面的参数名与实际参数名，可以不一致。</p>
</blockquote>
</li>
</ol>
<pre><code>let foo: (a: number) =&gt; number;

foo = function (b: number) &#123;
  return b;
&#125;;
</code></pre>
<ul>
<li>函数类型里面的参数名为 a，实际的函数定义里面，参数名为 b，两者并不相同（但并没有问题）。</li>
</ul>
<ol start="3">
<li>type 命令定义函数别名<blockquote>
<p>如果函数的类型定义很冗长，或者多个函数使用同一种类型，写法二用起来就很麻烦。</p>
<ul>
<li>因此，往往用type命令为函数类型定义一个别名，便于指定给其他变量。</li>
</ul>
</blockquote>
</li>
</ol>
<pre><code>type Func = (str: string) =&gt; void;

const foo: Func = function (str) &#123;
  console.log(&quot;hi &quot; + str);
&#125;;

foo(&quot;code&quot;); // hi code
</code></pre>
<ul>
<li>type 命令为函数类型定义了一个别名 Func，后面使用就很方便，变量可以指定为这个类型</li>
</ul>
<ol start="4">
<li>函数参数注意事项<blockquote>
<p>函数的实际参数个数，可以少于类型指定的参数个数，但是不能多于，即 TypeScript 允许省略参数</p>
</blockquote>
</li>
</ol>
<pre><code>// func 的类型只能接受两个参数
let func: (a: number, b: number) =&gt; number;

// 赋值一个参数
func = (a: number) =&gt; a; // 正确
// 赋值三个参数（多余原定的参数）
func = (a: number, b: number, c: number) =&gt; a + b + c; // 报错
</code></pre>
<ul>
<li>以上特性的原因是，JavaScript 函数在声明时往往有多余的参数，实际使用时可以只传入一部分参数。</li>
<li>比如，数组的forEach()方法的参数是一个函数，该函数默认有三个参数(item, index, array) &#x3D;&gt; void，实际上往往只使用第一个参数(item) &#x3D;&gt; void。</li>
<li>因此，TypeScript 允许函数传入的参数不足</li>
</ul>
<blockquote>
<p>声明参数更多的函数，不能赋值给参数少的函数，反之可以</p>
</blockquote>
<pre><code>let a = (x: number) =&gt; 0;
let b = (y: number, z: string) =&gt; 0;

b = a; // 正确
a = b; // 报错
</code></pre>
<ul>
<li>函数 a 只有一个参数，函数 b 有两个参数，a 可以赋值给 b，反过来就不行</li>
</ul>
<ol start="5">
<li>总结声明函数类型的方法</li>
</ol>
<ul>
<li>类型和函数同时声明 (三种方法)</li>
<li>先声明类型再定义函数（两种方法）</li>
</ul>
<pre><code>// 类型和函数同时声明 (三种方法)：
// 方法1 只声明函数
function foo1(x:number,y:number):number&#123;
    return x+y
&#125;
console.log(foo1(2,3))//5
// 实参少于形参
function foo2(x:number,y:number):number&#123;
    return x
&#125;
console.log(foo2(2,3))//2

// 方法2 变量被赋值为一个函数
const foo3=function(x:number,y:number):number&#123;
    return x+y
&#125;
//const foo3=(x:number,y:number):number=&gt;&#123;
//    return x+y
//&#125;
console.log(foo3(2,3))//5
// 实参少于形参
const foo4=function(x:number,y:number):number&#123;
    return x
&#125;
console.log(foo4(2,3))//2

// 方法3 变量被赋值为一个函数
const foo5:(x:number,y:number)=&gt;number=function(x,y)&#123;
    return x+y
&#125;
console.log(foo5(2,3))//5
// 实参少于形参
const foo6:(x:number,y:number)=&gt;number=function(x,y)&#123;
    return x
&#125;
console.log(foo6(2,3))//2

// 先声明类型再定义函数（两种方法）
// 方法1：
// 1-声明类型 注意 这里类型声明不能使用const 因为不赋初始值
let foo7:(x:number,y:number)=&gt;number;
// 1-2 对象写法
// let foo7:&#123;(x:number,y:number):number;&#125;
// 1-3 Interface写法：先使用interface定义接口 再将接口作为函数的类型 注意参数名要一致
// interface fn &#123;(x:number,y:number):number;&#125;
// const foo7:fn=(x,y)=&gt;x+y //实现函数

// 2-实现函数 箭头函数
foo7=(a,b)=&gt;a+b
// foo7=function(a:number,b:number)&#123;
//     return a+b
// &#125;
// 使用函数
console.log(foo7(1,2))//3

//实参少于形参的情况：
let foo8:(x:number,y:number)=&gt;number;
// 2-实现函数
foo8=(a,b)=&gt;a
// foo8=function(a:number,b:number)&#123;
//     return a+b
// &#125;
// 3-使用函数
console.log(foo8(1,2))//1

// 方法2 用type取别名
// 声明类型 并取别名
type NumF=(x:number,y:number)=&gt;number
// 实现函数
const foo9:NumF=function(a,b)&#123;
    return a+b
&#125;
// 使用函数
console.log(foo9(2,1))//3

//实参少于形参的情况：
// 实现函数
const foo10:NumF=function(a,b)&#123;
    return a
&#125;
// 使用函数
console.log(foo10(2,1))//2
</code></pre>
<h4 id="使用-typeof-运算符"><a href="#使用-typeof-运算符" class="headerlink" title="使用 typeof 运算符"></a>使用 typeof 运算符</h4><blockquote>
<p>如果一个变量要套用另一个函数类型，有一个小技巧，就是使用<code>typeof</code>运算符。</p>
</blockquote>
<pre><code>function add(x: number, y: number) &#123;
  return x + y;
&#125;

const myAdd: typeof add = function (x, y) &#123;
  return x + y;
&#125;;
</code></pre>
<ul>
<li>函数<code>myAdd()</code>的类型与函数<code>add()</code>是一样的，那么类型声明就可以定义成<code>typeof add</code></li>
<li>因为函数名 add 本身不是类型，而是一个值，所以要用<code>typeof</code> 运算符返回它的类型</li>
<li>这是一个很有用的技巧，任何需要类型的地方，都可以使用<code>typeof</code>运算符从一个值获取类型。</li>
</ul>
<h4 id="函数类型的对象写法"><a href="#函数类型的对象写法" class="headerlink" title="函数类型的对象写法"></a>函数类型的对象写法</h4><blockquote>
<p>如下，变量add的类型就写成了一个对象</p>
</blockquote>
<pre><code>let add: &#123;
  (x: number, y: number): number;
&#125;;

add = function (x, y) &#123;
  return x + y;
&#125;;
</code></pre>
<ol>
<li>函数类型的对象语法</li>
</ol>
<pre><code>&#123;
  (参数列表): 返回值
&#125;
</code></pre>
<ul>
<li>这种写法的函数参数与返回值之间，间隔符是冒号 <code>:</code> ，而不是正常写法的箭头 <code>=&gt;</code></li>
<li>因为这里采用的是对象类型的写法，对象的属性名与属性值之间使用的是冒号</li>
</ul>
<blockquote>
<p>这种写法平时很少用，但是非常合适用在一个场合：函数本身存在属性。</p>
<ul>
<li>函数本身存在属性时，使用对象写法</li>
</ul>
</blockquote>
<pre><code>//普通写法
function foo(x: number) &#123;
  console.log(x);
&#125;
foo.version = &quot;1.0&quot;;

// 使用函数类型的对象语法
let f: &#123;
  (x: number): void;
  version: string;
&#125; = foo;
</code></pre>
<ul>
<li>函数 foo() 本身还有一个属性<code>version</code></li>
<li>这时，foo 完全就是一个对象，类型就要使用对象的写法</li>
</ul>
<h4 id="函数类型的-Interface-写法"><a href="#函数类型的-Interface-写法" class="headerlink" title="函数类型的 Interface 写法"></a>函数类型的 Interface 写法</h4><blockquote>
<p>函数类型也可以使用 <code>Interface</code> 来声明</p>
</blockquote>
<pre><code>interface fn &#123;
  (a: number, b: number): number;
&#125;

var add: fn = (a, b) =&gt; a + b;
</code></pre>
<ul>
<li><code>interface</code>命令定义了接口 fn，这个接口的类型就是一个用对象表示的函数</li>
<li>类似于先用<code>interface</code>取别名，该别名就是<code>add</code>函数的类型</li>
<li>注意类型参数和函数定义的参数 名字要一样</li>
</ul>
<h4 id="Function-类型"><a href="#Function-类型" class="headerlink" title="Function 类型"></a>Function 类型</h4><blockquote>
<p>TypeScript 提供 Function 类型表示函数，任何函数都属于这个类型</p>
</blockquote>
<pre><code>function foo(f: Function) &#123;
  return f(1, 2, 3);
&#125;
</code></pre>
<ul>
<li>参数 f 的类型就是 Function，代表这是一个函数</li>
</ul>
<blockquote>
<p>注：</p>
</blockquote>
<ul>
<li><code>Function</code>类型的值都可以直接执行</li>
<li><code>Function</code>类型的函数可以接受<strong>任意数量的参数</strong>，每个参数的类型都是<code>any</code>，返回值的类型也是<code>any</code>，代表没有任何约束</li>
<li>所以，不建议使用这个类型，给出函数详细的类型声明会更好</li>
</ul>
<h4 id="箭头函数"><a href="#箭头函数" class="headerlink" title="箭头函数"></a>箭头函数</h4><blockquote>
<p>箭头函数是普通函数的一种简化写法，它的类型写法与普通函数类似</p>
</blockquote>
<pre><code>const repeat = (str: string, num: number): string =&gt; str.repeat(num);
</code></pre>
<ul>
<li>变量 repeat 被赋值为一个箭头函数，类型声明写在箭头函数的定义里面</li>
<li>其中，参数的类型写在参数名后面，返回值类型写在参数列表的圆括号后面</li>
</ul>
<blockquote>
<p>注意，类型写在箭头函数的定义里面，与使用箭头函数表示函数类型，写法有所不同。</p>
</blockquote>
<pre><code>function foo(fn: (a: string) =&gt; void): void &#123;
  fn(&quot;code&quot;);
&#125;
</code></pre>
<ul>
<li>函数 foo() 的参数 fn 是一个函数，类型就用箭头函数表示</li>
<li>这时，fn 的返回值类型要写在箭头右侧，而不是写在参数列表的圆括号后面</li>
</ul>
<h4 id="综合应用"><a href="#综合应用" class="headerlink" title="综合应用"></a>综合应用</h4><pre><code>type Person = &#123; username: string &#125;;

const people = [&quot;code&quot;, &quot;abc&quot;, &quot;hermia&quot;].map(
  (username): Person =&gt; (&#123; username &#125;)
);
console.log(people)
// [ &#123; username: &#39;code&#39; &#125;, &#123; username: &#39;abc&#39; &#125;, &#123; username: &#39;hermia&#39; &#125; ]
</code></pre>
<ul>
<li><code>Person</code>是一个类型别名，代表一个对象，该对象有属性 <code>username</code></li>
<li>变量 <code>people</code> 是数组的 <code>map()</code> 方法的返回值</li>
</ul>
<blockquote>
<p>注：</p>
</blockquote>
<ul>
<li><code>map()</code>方法的参数是一个箭头函数<code>(username): Person =&gt; (&#123;username&#125;)</code>，该箭头函数的参数<code>username</code>的类型省略了。</li>
<li>因为可以从map()的类型定义推断出来，箭头函数的返回值类型为Person。相应地，变量people的类型是<code>Person[]</code>。</li>
<li>至于箭头后面的<code>(&#123;username&#125;)</code>，表示返回一个对象，该对象有一个属性<code>username</code>，它的属性值为变量username的值。这里的圆括号是必须的，否则<code>(username): Person =&gt; &#123;username&#125;</code>的大括号表示函数体，即函数体内有一行语句username，同时由于没有return语句，这个函数不会返回任何值。</li>
</ul>
<blockquote>
<p>注意，以下两种写法都是不对的 ！</p>
</blockquote>
<pre><code>// 错误
(username: Person) =&gt; (&#123; username &#125;);

// 错误
username: (Person) =&gt; (&#123; username &#125;);
</code></pre>
<ul>
<li>第一种写法表示，箭头函数的参数 username 的类型是 Person，同时没写函数返回值的类型，让 TypeScript 自己去推断</li>
<li>第二种写法中，函数参数缺少圆括号</li>
</ul>
<h4 id="可选参数"><a href="#可选参数" class="headerlink" title="可选参数"></a>可选参数</h4><blockquote>
<p>如果函数的某个参数可以省略，则在参数名后面<strong>加问号</strong>表示。</p>
</blockquote>
<pre><code>function foo(a?: number) &#123;
  console.log(a);
&#125;

foo(); // undefined
foo(123); // 123
</code></pre>
<ul>
<li>参数 a 后面有问号，表示该参数可以省略</li>
<li>参数名带有问号，表示该参数的类型实际上是<code>原始类型|undefined</code>，它有可能为<code>undefined</code>。比如，上例的a虽然类型声明为<code>number</code>，但是实际上是<code>number|undefined</code>。</li>
</ul>
<pre><code>function foo(a?: number) &#123;
  return a;
&#125;

foo(undefined); // 正确

console.log(foo(undefined)); // undefined
</code></pre>
<ul>
<li>参数 a 是可选的，等同于说 a 可以赋值为 <code>undefined</code></li>
</ul>
<blockquote>
<p>但是，反过来就不成立，类型显式设为<code>undefined</code>的参数，就不能省略</p>
</blockquote>
<pre><code>function foo(a: number | undefined) &#123;
  return a;
&#125;

foo(); // 报错
</code></pre>
<ul>
<li>参数 a 的类型是<code>number|undefined</code>，表示要么传入一个数值，要么传入<code>undefined</code>，如果省略这个参数，就会报错</li>
</ul>
<blockquote>
<p>函数的可选参数只能在参数列表的<strong>尾部</strong>，跟在必选参数的后面</p>
</blockquote>
<pre><code>let foo: (a?: number, b: number) =&gt; number; // 报错
// let foo: (a: number, b?: number) =&gt; number; // 正确
</code></pre>
<blockquote>
<p>如果前部参数有可能为空，这时只能显式注明该参数类型可能为<code>undefined</code></p>
</blockquote>
<pre><code>let foo: (a: number | undefined, b: number) =&gt; number;
</code></pre>
<ul>
<li>参数 a 有可能为空，就只能显式注明类型包括 <code>undefined</code>，传参时也要显式传入 <code>undefined</code></li>
</ul>
<blockquote>
<p>函数体内部用到可选参数时，需要判断该参数是否为<code>undefined</code></p>
</blockquote>
<pre><code>let foo: (a: number, b?: number) =&gt; number;

foo = function (x, y) &#123;
  if (y === undefined) &#123;
    return x;
  &#125;
  return x + y;
&#125;;
</code></pre>
<ul>
<li>由于函数的第二个参数为可选参数，所以函数体内部需要判断一下，该参数是否为空。</li>
</ul>
<h4 id="参数默认值"><a href="#参数默认值" class="headerlink" title="参数默认值"></a>参数默认值</h4><blockquote>
<p>TypeScript 函数的参数默认值写法，与 JavaScript 一致。</p>
</blockquote>
<ul>
<li>给参数设置默认值，就代表该参数是可选的；不传入参数时就使用默认值</li>
</ul>
<pre><code>function foo(a: number = 0, b: number = 0): [number, number] &#123;
  return [a, b];
&#125;

foo(); // [0, 0]
</code></pre>
<ul>
<li>参数 a 和 b 的默认值都是0，调用 <code>foo()</code> 时，这两个参数都是可以省略的</li>
<li>这里其实可以省略 a 和 b 的类型声明，因为可以从默认值推断出来</li>
</ul>
<blockquote>
<p>省略 a 和 b 的类型声明，可以从默认值推断类型。如下</p>
</blockquote>
<pre><code>function foo(a = 0, b = 0) &#123;
  return [a, b];
&#125;

console.log(foo()); // [ 0, 0 ]
</code></pre>
<blockquote>
<p>可选参数与默认值</p>
</blockquote>
<ul>
<li>可选参数与默认值不能同时使用</li>
</ul>
<pre><code>// 报错
function foo(a?: number = 0) &#123;
  // ...
&#125;
</code></pre>
<ul>
<li>a 是可选参数，还设置了默认值，结果就报错了</li>
</ul>
<blockquote>
<p>传入 undefined</p>
</blockquote>
<ul>
<li>设有默认值的参数，如果传入<code>undefined</code>，也会触发默认值</li>
</ul>
<pre><code>function foo(a = 123) &#123;
  return a;
&#125;

foo(undefined); // 123
</code></pre>
<blockquote>
<p>具有默认值的参数如果不位于参数列表的末尾，调用时不能省略，如果要触发默认值，必须显式传入<code>undefined</code></p>
</blockquote>
<pre><code>function add(a: number = 0, b: number) &#123;
  return a + b;
&#125;

add(1); // 报错
add(undefined, 1); // 正确
</code></pre>
<h4 id="参数解构"><a href="#参数解构" class="headerlink" title="参数解构"></a>参数解构</h4><blockquote>
<p>函数参数如果存在变量解构，类型写法如下</p>
</blockquote>
<pre><code>function foo([x, y]: [number, number]) &#123;
  // ...
&#125;

function sum(&#123; a, b, c &#125;: &#123; a: number; b: number; c: number &#125;) &#123;
  console.log(a + b + c);
&#125;
</code></pre>
<blockquote>
<p>参数解构可以结合类型别名（type 命令）一起使用，代码会看起来简洁一些</p>
</blockquote>
<pre><code>type ABC = &#123; a: number; b: number; c: number &#125;;

function sum(&#123; a, b, c &#125;: ABC) &#123;
  console.log(a + b + c);
&#125;
</code></pre>
<h4 id="rest-剩余参数"><a href="#rest-剩余参数" class="headerlink" title="rest 剩余参数"></a>rest 剩余参数</h4><blockquote>
<p>rest 参数表示函数剩余的所有参数，它可以是数组（剩余参数类型相同），也可能是元组（剩余参数类型不同）。</p>
</blockquote>
<pre><code>// rest 参数为数组
function count(...nums: number[]) &#123;
  // ...
&#125;

// rest 参数为元组
function foo(...args: [boolean, number]) &#123;
  // ...
&#125;
</code></pre>
<ul>
<li>注意，元组需要声明每一个剩余参数的类型。如果元组里面的参数是可选的，则要使用可选参数。</li>
</ul>
<pre><code>function foo(...args: [boolean, string?]) &#123;&#125;
</code></pre>
<blockquote>
<p>观察以下 rest 剩余参数案例</p>
</blockquote>
<pre><code>function foo(a: number, ...b: number[]) &#123;
  return b.map((x) =&gt; a * x);
&#125;
</code></pre>
<ul>
<li>参数 b 就是 rest 类型，它的类型是一个数组</li>
</ul>
<blockquote>
<p>rest 剩余参数甚至可以嵌套</p>
</blockquote>
<pre><code>function foo(...args: [boolean, ...string[]]) &#123;
  // ...
&#125;
</code></pre>
<blockquote>
<p>rest 剩余参数可以与变量解构结合使用</p>
</blockquote>
<pre><code>function foo(...[str, num]: [string, number]): string &#123;
  return str.repeat(num);
&#125;

// 等同于
function foo(str: string, num: number): string &#123;
  return str.repeat(num);
&#125;
</code></pre>
<h4 id="readonly-只读参数"><a href="#readonly-只读参数" class="headerlink" title="readonly 只读参数"></a>readonly 只读参数</h4><blockquote>
<p>如果函数内部不能修改某个参数，可以在函数定义时，在参数类型前面加上<code>readonly</code>关键字，表示这是只读参数。</p>
</blockquote>
<pre><code>function count(arr: readonly number[]) &#123;
  // ...
  arr[0] = 0; // 报错
&#125;
</code></pre>
<ul>
<li>参数 arr 的类型是<code>readonly number[]</code>，表示为只读参数</li>
<li>如果函数体内部修改这个数组，就会报错</li>
</ul>
<h4 id="void-类型"><a href="#void-类型" class="headerlink" title="void 类型"></a>void 类型</h4><blockquote>
<p>void 类型表示函数没有返回值</p>
</blockquote>
<pre><code>function foo(): void &#123;
  console.log(&quot;code&quot;);
&#125;
</code></pre>
<ul>
<li>函数 foo 没有返回值，类型就要写成 <code>void</code></li>
</ul>
<blockquote>
<p>如果返回其他值，就会报错</p>
</blockquote>
<pre><code>function foo(): void &#123;
  return 123; // 报错
&#125;
</code></pre>
<blockquote>
<p>void 类型允许返回undefined或null</p>
</blockquote>
<pre><code>function foo(): void &#123;
  return undefined; // 正确
&#125;

function foo1(): void &#123;
  return null; // 正确
&#125;
</code></pre>
<blockquote>
<p>如果打开了<code>strictNullChecks</code>编译选项，那么 void 类型只允许返回<code>undefined</code>。如果返回null，就会报错。这是因为 JavaScript 规定，如果函数没有返回值，就等同于返回undefined</p>
</blockquote>
<pre><code>// 打开编译选项 strictNullChecks

function foo(): void &#123;
  return undefined; // 正确
&#125;

function foo1(): void &#123;
  return null; // 报错
&#125;
</code></pre>
<ol>
<li>注意事项<blockquote>
<p>需要特别注意的是，如果变量、对象方法、函数参数的类型是<code>void</code>类型的函数，那么并不代表不能赋值为有返回值的函数。</p>
<ul>
<li>恰恰相反，该变量、对象方法和函数参数可以接受返回<strong>任意值</strong>的函数，这时并不会报错。</li>
</ul>
</blockquote>
</li>
</ol>
<pre><code>type voidFunc = () =&gt; void;

const foo: voidFunc = () =&gt; &#123;
  return 123;
&#125;;
</code></pre>
<ul>
<li>变量 foo 的类型是 voidFunc，是一个没有返回值的函数类型</li>
<li>但是实际上，foo 的值是一个有返回值的函数（返回123），编译时不会报错</li>
<li>这是因为，这时 TypeScript 认为，这里的 void 类型只是表示<strong>该函数的返回值没有利用价值</strong>，或者说不应该使用该函数的返回值。<strong>只要不用到这里的返回值，就不会报错</strong></li>
</ul>
<blockquote>
<p>这样设计是有现实意义的。举例来说，数组方法<code>Array.prototype.forEach(fn)</code>的参数fn是一个函数，而且这个函数应该没有返回值，即返回值类型是<code>void</code></p>
<ul>
<li>但是，实际应用中，很多时候传入的函数是有返回值，但是它的返回值不重要，或者不产生作用。</li>
</ul>
</blockquote>
<pre><code>const src = [1, 2, 3];
const ret = [];

src.forEach((el) =&gt; ret.push(el));
</code></pre>
<ul>
<li><code>push()</code>有返回值，表示新插入的元素在数组里面的位置</li>
<li>但是，对于<code>forEach()</code>方法来说，这个返回值是没有作用的，根本用不到，所以 TypeScript 不会报错</li>
</ul>
<blockquote>
<p>如果后面使用了这个函数的返回值，就违反了约定，则会报错</p>
</blockquote>
<pre><code>type voidFunc = () =&gt; void;

const foo: voidFunc = () =&gt; &#123;
  return 123;
&#125;;

foo() * 2; // 报错
</code></pre>
<ul>
<li>最后一行报错了，因为根据类型声明，foo() 没有返回值，但是却用到了它的返回值，因此报错了</li>
</ul>
<blockquote>
<p>注意，这种情况仅限于变量、对象方法和函数参数，<strong>函数字面量</strong>如果声明了<strong>返回值</strong>是 <code>void</code> 类型，还是不能有返回值。</p>
</blockquote>
<pre><code>function foo(): void &#123;
  return true; // 报错
&#125;

const fn = function (): void &#123;
  return true; // 报错
&#125;;
</code></pre>
<ul>
<li>函数字面量声明了返回 void 类型，这时只要有返回值（除了undefined和null）就会报错</li>
</ul>
<blockquote>
<p>除了函数，其他变量声明为void类型没有多大意义，因为这时只能赋值为<code>undefined</code>或者<code>null</code>(假定没有打开<code>strictNullChecks</code>)</p>
</blockquote>
<pre><code>let foo: void = undefined;

// 没有打开 strictNullChecks 的情况下
let bar: void = null;
</code></pre>
<h4 id="never-类型"><a href="#never-类型" class="headerlink" title="never 类型"></a>never 类型</h4><blockquote>
<p><code>never</code>类型表示肯定不会出现的值。</p>
<ul>
<li>它用在函数的返回值，就表示某个函数肯定不会返回值，即函数不会正常执行结束</li>
<li>主要有以下两种情况</li>
</ul>
</blockquote>
<ol>
<li>抛出错误的函数</li>
</ol>
<pre><code>function fail(msg: string): never &#123;
  throw new Error(msg);
&#125;
</code></pre>
<ul>
<li>函数<code>fail()</code>会抛错，不会正常退出，所以返回值类型是 never</li>
</ul>
<blockquote>
<p>注意，<strong>只有抛出错误</strong>，才是 <code>never</code> 类型。如果显式用<code>return</code>语句返回一个<code>Error</code>对象，返回值就不是 <code>never</code> 类型。</p>
</blockquote>
<pre><code>function fail(): Error &#123;
  return new Error(&quot;Something failed&quot;);
&#125;
</code></pre>
<ul>
<li>函数 <code>fail()</code> 返回一个 Error 对象，所以返回值类型是 Error</li>
</ul>
<ol start="2">
<li>无限执行的函数</li>
</ol>
<pre><code>const foo = function (): never &#123;
  while (true) &#123;
    console.log(&quot;code&quot;);
  &#125;
&#125;;
</code></pre>
<ul>
<li>函数 foo() 会永远执行，不会返回，所以返回值类型是 never</li>
</ul>
<ol start="3">
<li>never 类型注意事项<blockquote>
<p>注意，<code>never</code>类型不同于<code>void</code>类型</p>
<ul>
<li>前者表示函数没有执行结束，不可能有返回值；</li>
<li>后者表示函数正常执行结束，但是不返回值，或者说返回<code>undefined</code></li>
</ul>
</blockquote>
</li>
</ol>
<pre><code>// 报错
function foo1(): never &#123;
  console.log(&quot;code&quot;);
&#125;

// 正确
function foo2(): void &#123;
  console.log(&quot;code&quot;);
&#125;
</code></pre>
<ul>
<li>函数 <code>foo2()</code> 虽然没有 return 语句，但实际上是省略了<code>return undefined</code>这行语句，真实的返回值是<code>undefined</code></li>
<li>所以，它的返回值类型要写成 <code>void</code>，而不是 <code>never</code>，写成 <code>never</code> 会报错</li>
</ul>
<blockquote>
<p>如果一个函数抛出了异常或者陷入了死循环，那么该函数无法正常返回一个值，因此该函数的返回值类型就是<code>never</code></p>
<ul>
<li>如果程序中调用了一个返回值类型为<code>never</code>的函数，那么就意味着程序会在该函数的调用位置终止，永远不会继续执行后续的代码。</li>
</ul>
</blockquote>
<pre><code>function neverReturns(): never &#123;
  throw new Error();
&#125;

function foo(x: string | undefined) &#123;
  if (x === undefined) &#123;
    neverReturns();
  &#125;

  x; // 推断为 string
&#125;
</code></pre>
<ul>
<li>函数 foo() 的参数 x 的类型为<code>string|undefined</code></li>
<li>但是，x 类型为<code>undefined</code>时，调用了<code>neverReturns()</code></li>
<li>这个函数不会返回(没有<code>return</code>)，而<code>never</code>表示某个函数肯定不会返回值，因此TS可以推断出，判断语句后面的那个 x，类型一定是<code>string</code>，<code>string</code>的子集里有<code>never</code></li>
</ul>
<blockquote>
<p>一个函数如果某些条件下有正常返回值，另一些条件下抛错，这时它的返回值类型可以省略<code>never</code></p>
</blockquote>
<pre><code>function foo(): number &#123;
  if (Math.random() &gt; 0.6) &#123;
    return 123;
  &#125;

  throw new Error(&quot;报错了！&quot;);
&#125;

const result = foo();
</code></pre>
<ul>
<li>函数 foo() 的返回值其实是<code>number|never</code>，但是一般都写成 <code>number</code>，包括最后一行的变量 <code>result</code> 的类型，也是被推断为 <code>number</code></li>
</ul>
<blockquote>
<p>注：</p>
</blockquote>
<ul>
<li>原因是前面提到过，<code>never</code>是<code>TypeScript</code>的唯一一个底层类型，所有其他类型都包括了<code>never</code></li>
<li>从集合论的角度看，<code>number|never</code>等同于<code>number</code>。这也提示我们，函数的返回值无论是什么类型，都可能包含了抛出错误的情况</li>
</ul>
<h4 id="局部类型"><a href="#局部类型" class="headerlink" title="局部类型"></a>局部类型</h4><blockquote>
<p>函数内部允许声明其他类型，该类型只在函数内部有效，称为 局部类型</p>
</blockquote>
<pre><code>function foo(txt: string) &#123;
  type message = string;
  let newTxt: message = &quot;hi &quot; + txt;
  return newTxt;
&#125;

const newTxt: message = foo(&quot;code&quot;); // 报错
</code></pre>
<ul>
<li>类型 <code>message</code> 是在函数 <code>foo()</code> 内部定义的，只能在函数内部使用。在函数外部使用，就会报错。</li>
</ul>
<h4 id="高阶函数"><a href="#高阶函数" class="headerlink" title="高阶函数"></a>高阶函数</h4><blockquote>
<p>一个函数的返回值还是一个函数，那么前一个函数就称为高阶函数（higher-order function）</p>
<ul>
<li>下面就是一个例子，箭头函数返回的还是一个箭头函数</li>
</ul>
</blockquote>
<pre><code>(val: number) =&gt; (nums: number) =&gt; val * nums;
</code></pre>
<h4 id="函数重载"><a href="#函数重载" class="headerlink" title="函数重载"></a>函数重载</h4><blockquote>
<p>有些函数可以接受不同类型或不同个数的参数，并且根据参数的不同，会有不同的函数行为。</p>
<p>这种根据参数类型不同，执行不同逻辑的行为，称为 函数重载（function overload）。</p>
</blockquote>
<pre><code>foo(&quot;code&quot;); // &#39;gnidoci&#39;
foo([1, 2, 3]); // [3, 2, 1]
</code></pre>
<ul>
<li>函数 foo() 可以将参数颠倒输出。参数可以是字符串，也可以是数组</li>
<li>这意味着，该函数内部有处理字符串和数组的两套逻辑，根据参数类型的不同，分别执行对应的逻辑。这就叫 “函数重载”。</li>
</ul>
<blockquote>
<p>TypeScript 对于 “函数重载” 的类型声明方法是，逐一定义每一种情况的类型</p>
</blockquote>
<pre><code>function foo(str: string): string;
function foo(arr: any[]): any[];
</code></pre>
<ul>
<li>分别对函数 foo() 的两种参数情况，给予了类型声明</li>
<li>但是，到这里还没有结束，后面还必须对函数 foo() 给予完整的类型声明</li>
<li>以下代码中，前两行类型声明列举了重载的各种情况。第三行是函数本身的类型声明，它必须与前面已有的重载声明兼容</li>
</ul>
<pre><code>function foo(str: string): string;
function foo(arr: any[]): any[];
function foo(stringOrArray: string | any[]): string | any[] &#123;
  if (typeof stringOrArray === &quot;string&quot;)
    return stringOrArray.split(&quot;&quot;).reverse().join(&quot;&quot;);
  else return stringOrArray.slice().reverse();
&#125;
</code></pre>
<blockquote>
<p>有一些编程语言允许不同的函数参数，对应不同的函数实现。但是，JavaScript 函数只能有一个实现，必须在这个实现当中，处理不同的参数。</p>
</blockquote>
<ul>
<li>因此，函数体内部就需要判断参数的类型及个数，并根据判断结果执行不同的操作。</li>
</ul>
<pre><code>function add(x: number, y: number): number;
function add(x: any[], y: any[]): any[];
function add(x: number | any[], y: number | any[]): number | any[] &#123;
  if (typeof x === &quot;number&quot; &amp;&amp; typeof y === &quot;number&quot;) &#123;
    return x + y;
  &#125; else if (Array.isArray(x) &amp;&amp; Array.isArray(y)) &#123;
    return [...x, ...y];
  &#125;

  throw new Error(&quot;参数错误 ！&quot;);
&#125;
</code></pre>
<ul>
<li>函数 add() 内部使用 if 代码块，分别处理参数的两种情况</li>
</ul>
<blockquote>
<p>注：</p>
</blockquote>
<ul>
<li>重载的各个类型描述与函数的具体实现之间，不能有其他代码，否则报错。</li>
<li>另外，虽然函数的具体实现里面，有完整的类型声明。但是，函数实际调用的类型，以前面的类型声明为准。</li>
<li>比如，上例的函数实现，参数类型和返回值类型都是<code>number|any[]</code>，但不意味着参数类型为number时返回值类型为any[]。</li>
</ul>
<ol>
<li>函数重载的冲突问题 与 排序<blockquote>
<p>函数重载的每个类型声明之间，以及类型声明与函数实现的类型之间，不能有冲突。</p>
</blockquote>
</li>
</ol>
<pre><code>// 报错
function foo(a: boolean): void;
function foo(a: string): void;
function foo(a: number | string) &#123;
  console.log(a);
&#125;
</code></pre>
<ul>
<li>函数重载的类型声明与函数实现是冲突的，导致报错。</li>
</ul>
<blockquote>
<p>重载声明的排序很重要，因为 TypeScript 是按照顺序进行检查的，一旦发现符合某个类型声明，就不再往下检查了，所以类型<strong>最宽的</strong>声明应该放在最后面，防止覆盖其他类型声明。</p>
</blockquote>
<pre><code>function foo(a: any): number;
function foo(a: string): 0 | 1;
function foo(a: any): any &#123;
  // ...
&#125;

const x: 0 | 1 = foo(&quot;code&quot;); // 报错
</code></pre>
<ul>
<li>第一行类型声明<code>a:any</code>范围最宽，导致函数 foo() 的调用都会匹配这行声明，无法匹配第二行类型声明</li>
<li>当x匹配到<code>any</code>后，那它的返回值类型就必须是<code>number</code>；但<code>code</code>是字符串，所以报错</li>
<li>以上函数重载的正确顺序是，第二行类型声明放到第一行的位置</li>
</ul>
<pre><code>function foo(a: string): 0 | 1;
function foo(a: any): number;
function foo(a: any): any &#123;
  // ...
&#125;

const x: 0 | 1 = foo(&quot;code&quot;); // 正确
</code></pre>
<ol start="2">
<li>对象方法使用重载<blockquote>
<p>对象的方法也可以使用重载</p>
</blockquote>
</li>
</ol>
<pre><code>class StringBuilder &#123;
  // 私有属性（ES6 语法）
  #data = &quot;&quot;;

  add(num: number): this;
  add(bool: boolean): this;
  add(str: string): this;
  add(value: any): this &#123;
    this.#data += String(value);
    return this;
  &#125;

  toString() &#123;
    return this.#data;
  &#125;
&#125;
</code></pre>
<ul>
<li><code>add()</code>也使用了函数重载</li>
</ul>
<blockquote>
<p>函数重载也可以用来精确描述函数参数与返回值之间的对应关系。</p>
</blockquote>
<pre><code>function createElement(tag: &quot;a&quot;): HTMLAnchorElement;
function createElement(tag: &quot;canvas&quot;): HTMLCanvasElement;
function createElement(tag: &quot;table&quot;): HTMLTableElement;
function createElement(tag: string): HTMLElement &#123;
  return document.createElement(tag);
&#125;

const a = createElement(&quot;a&quot;);
const canvas = createElement(&quot;canvas&quot;);
const table = createElement(&quot;table&quot;);
// 传入没有对应的参数，就会报错
const p = createElement(&quot;p&quot;); // 报错
</code></pre>
<ul>
<li>函数重载精确描述了参数 tag 的三个值，所对应的不同的函数返回值。</li>
</ul>
<blockquote>
<p>以上代码中函数重载，也可以用对象表示。</p>
</blockquote>
<pre><code>type CreateElement = &#123;
  (tag: &quot;a&quot;): HTMLAnchorElement;
  (tag: &quot;canvas&quot;): HTMLCanvasElement;
  (tag: &quot;table&quot;): HTMLTableElement;
  (tag: string): HTMLElement;
&#125;;
</code></pre>
<ol start="3">
<li>函数重载最佳实践<blockquote>
<p>由于重载是一种比较复杂的类型声明方法，为了降低复杂性，一般来说，如果可以的话，应该 <strong>优先</strong> 使用联合类型替代函数重载。</p>
</blockquote>
</li>
</ol>
<pre><code>// 写法一
function len(s: string): number;
function len(arr: any[]): number;
function len(x: any): number &#123;
  return x.length;
&#125;

// 写法二：使用联合类型
function len(x: any[] | string): number &#123;
  return x.length;
&#125;
</code></pre>
<ul>
<li>写法二使用联合类型，要比写法一的函数重载简单很多</li>
</ul>
<h4 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h4><blockquote>
<p>JavaScript 语言使用构造函数，生成对象的实例。</p>
<ul>
<li>构造函数的最大特点，就是必须使用<code>new</code>命令调用。</li>
</ul>
</blockquote>
<pre><code>const date = new Date();
</code></pre>
<ul>
<li>Date() 就是一个构造函数，使用 new 命令调用，返回 Date 对象的实例。</li>
</ul>
<blockquote>
<p>构造函数的类型写法，就是在参数列表前面加上new命令。</p>
</blockquote>
<pre><code>class Animal &#123;
  numLegs: number = 4;
&#125;

type AnimalConstructor = new () =&gt; Animal;

function create(c: AnimalConstructor): Animal &#123;
  return new c();
&#125;

const a = create(Animal);
</code></pre>
<ul>
<li>类型<code>AnimalConstructor</code>就是一个构造函数，而函数 <code>create()</code> 需要传入一个构造函数</li>
<li>在 JavaScript 中，类（class）本质上是构造函数，所以 <code>Animal</code> 这个类可以传入<code>create()</code></li>
</ul>
<blockquote>
<p>构造函数还有另一种类型写法，就是采用对象形式。</p>
</blockquote>
<pre><code>type Foo = &#123;
  new (str: string): object;
&#125;;
</code></pre>
<ul>
<li>类型 Foo 就是一个构造函数。类型写成一个可执行对象的形式，并且在参数列表前面要加上 new 命令</li>
</ul>
<blockquote>
<p>某些函数既是构造函数，又可以当作普通函数使用，比如<code>Date()</code>。这时，类型声明可以写成下面这样。</p>
</blockquote>
<pre><code>type Foo = &#123;
  new (str: string): object;
  (num?: number): number;
&#125;;
</code></pre>
<ul>
<li>Foo 既可以当作普通函数执行，也可以当作构造函数使用</li>
</ul>
<h3 id="二、symbol-类型"><a href="#二、symbol-类型" class="headerlink" title="二、symbol 类型"></a>二、symbol 类型</h3><h4 id="unique-symbol"><a href="#unique-symbol" class="headerlink" title="unique symbol"></a>unique symbol</h4><blockquote>
<p><code>symbol</code>类型包含所有的 Symbol 值，但是无法表示某一个具体的 Symbol 值。</p>
</blockquote>
<ul>
<li>比如，5是一个具体的数值，就用5这个字面量来表示，这也是它的值类型。但是，Symbol 值不存在字面量，必须通过变量来引用，所以写不出只包含单个 Symbol 值的那种值类型。</li>
</ul>
<blockquote>
<p>为了解决这个问题，TypeScript 设计了symbol的一个子类型<code>unique symbol</code>，它表示<strong>单个的、某个具体的</strong> Symbol 值。</p>
</blockquote>
<ul>
<li>因为unique symbol表示单个值，所以这个类型的变量是不能修改值的，只能用<code>const</code>命令声明，不能用<code>let</code>声明。</li>
</ul>
<pre><code>// 正确
const a: unique symbol = Symbol();

// 报错
let b: unique symbol = Symbol();
</code></pre>
<ul>
<li>let 命令声明的变量，不能是 unique symbol 类型，会报错</li>
</ul>
<blockquote>
<p>const命令为变量赋值 Symbol 值时，变量类型默认就是<code>unique symbol</code>，所以类型可以省略不写。</p>
</blockquote>
<pre><code>const a: unique symbol = Symbol();
// 等同于
const a = Symbol();
</code></pre>
<blockquote>
<p>每个声明为<code>unique symbol</code>类型的变量，它们的值都是不一样的，<strong>其实属于两个值类型</strong></p>
</blockquote>
<pre><code>const a: unique symbol = Symbol();
const b: unique symbol = Symbol();

a === b; // 报错
</code></pre>
<ul>
<li>变量 a 和 变量 b 的类型虽然都是 unique symbol，但其实是两个值类型</li>
<li>不同类型的值肯定是不相等的，所以最后一行就报错了</li>
</ul>
<blockquote>
<p>由于 Symbol 类似于字符串，可以参考下面的例子来理解。</p>
</blockquote>
<pre><code>const a: &quot;hi&quot; = &quot;hi&quot;;
const b: &quot;code&quot; = &quot;code&quot;;

a === b; // 报错
</code></pre>
<ul>
<li>变量 a 和 b 都是字符串，但是属于不同的值类型，不能使用严格相等运算符进行比较</li>
</ul>
<blockquote>
<p>由于变量a和b是两个类型，就不能把一个赋值给另一个</p>
</blockquote>
<pre><code>const a: unique symbol = Symbol();
const b: unique symbol = a; // 报错
</code></pre>
<ul>
<li>变量 a 和 变量 b 的类型都是 unique symbol</li>
<li>但是其实类型不同，所以把 a 赋值给 b 会报错</li>
</ul>
<blockquote>
<p>以上代码中，变量b的类型，如果要写成与变量a<strong>同一个</strong><code>unique symbol</code>值类型，只能写成类型为<code>typeof a</code></p>
</blockquote>
<pre><code>const a: unique symbol = Symbol();
const b: typeof a = a; // 正确
</code></pre>
<blockquote>
<p>相同参数的<code>Symbol.for()</code>方法会返回相同的 Symbol 值</p>
<ul>
<li>TypeScript 目前无法识别这种情况，所以可能出现多个 <code>unique symbol</code>类型的变量，等于同一个 <code>Symbol</code> 值的情况。</li>
</ul>
</blockquote>
<pre><code>const a: unique symbol = Symbol.for(&quot;foo&quot;);
const b: unique symbol = Symbol.for(&quot;foo&quot;);
</code></pre>
<ul>
<li>变量 a 和 b 是两个不同的值类型，但是它们的值其实是相等的</li>
</ul>
<ol>
<li>unique symbol 注意事项<blockquote>
<p><code>unique symbol</code> 类型是 symbol 类型的子类型，所以可以将前者赋值给后者，但是反过来就不行。</p>
</blockquote>
</li>
</ol>
<pre><code>const a: unique symbol = Symbol();

const b: symbol = a; // 正确

const c: unique symbol = b; // 报错
</code></pre>
<ul>
<li><code>unique symbol</code>类型（变量a）赋值给 symbol 类型（变量b）是可以的</li>
<li>但是 symbol 类型（变量b）赋值给 unique symbol 类型（变量c）会报错</li>
</ul>
<ol start="2">
<li>unique symbol 的作用<blockquote>
<p><code>unique symbol</code>类型的一个作用，就是用作属性名，这可以保证不会跟其他属性名冲突。</p>
<ul>
<li>如果要把某一个特定的 Symbol 值当作属性名，那么它的类型<strong>只能</strong>是<code>unique symbol</code>，不能是 symbol。</li>
</ul>
</blockquote>
</li>
</ol>
<pre><code>const a: unique symbol = Symbol();
const b: symbol = Symbol();

interface Foo &#123;
  [a]: string; // 正确
  [b]: string; // 报错
&#125;
</code></pre>
<ul>
<li>变量 b 当作属性名，但是 b 的类型是 symbol，不是固定不变的值，导致报错。</li>
</ul>
<blockquote>
<p><code>unique symbol</code>类型也可以用作类（class）的属性值，但只能赋值给类的<code>readonly static</code>属性。</p>
</blockquote>
<pre><code>class C &#123;
  static readonly foo: unique symbol = Symbol();
&#125;
</code></pre>
<ul>
<li>静态只读属性 foo 的类型就是 unique symbol</li>
<li>注意，这时 static 和 readonly 两个限定符缺一不可，这是为了保证这个属性是固定不变的</li>
</ul>
<h4 id="类型推断"><a href="#类型推断" class="headerlink" title="类型推断"></a>类型推断</h4><blockquote>
<p>如果变量声明时没有给出类型，TypeScript 会推断某个 Symbol 值变量的类型。</p>
</blockquote>
<ul>
<li>let命令声明的变量，推断类型为 symbol</li>
</ul>
<pre><code>// 类型为 symbol
let a = Symbol();
</code></pre>
<ul>
<li>const命令声明的变量，推断类型为 unique symbol</li>
</ul>
<pre><code>// 类型为 unique symbol
const a = Symbol();
</code></pre>
<ul>
<li>但是，const命令声明的变量，如果赋值为另一个 symbol 类型的变量，则推断类型为 symbol</li>
</ul>
<pre><code>let a = Symbol();

// 类型为 symbol
const b = a;
</code></pre>
<ul>
<li>let命令声明的变量，如果赋值为另一个 unique symbol 类型的变量，则推断类型还是 symbol</li>
</ul>
<pre><code>const a = Symbol();

// 类型为 symbol
let b = a;
</code></pre>
<h3 id="三、对象类型"><a href="#三、对象类型" class="headerlink" title="三、对象类型"></a>三、对象类型</h3><h4 id="对象类型的声明"><a href="#对象类型的声明" class="headerlink" title="对象类型的声明"></a>对象类型的声明</h4><blockquote>
<p>对象类型的最简单声明方法，就是使用大括号表示对象，在大括号内部声明每个属性和方法的类型。</p>
</blockquote>
<pre><code>const obj: &#123;
  a: number;
  b: number;
&#125; = &#123; a: 1, b: 2 &#125;;
</code></pre>
<ul>
<li>对象 obj 的类型就写在变量名后面，使用大括号描述，内部声明每个属性的属性名和类型</li>
</ul>
<blockquote>
<p>属性的类型可以用分号结尾，也可以用逗号结尾。</p>
</blockquote>
<pre><code>// 属性类型以分号结尾
type Obj = &#123;
  a: number;
  b: number;
&#125;;

// 属性类型以逗号结尾
type Obj = &#123;
  a: number;
  b: number;
&#125;;
</code></pre>
<ul>
<li>最后一个属性后面，可以写分号或逗号，也可以不写</li>
</ul>
<ol>
<li>对象类型赋值<blockquote>
<p>一旦声明了类型，对象赋值时，就不能缺少指定的属性，也不能有多余的属性。</p>
</blockquote>
</li>
</ol>
<pre><code>type Obj = &#123;
  a: number;
  b: number;
&#125;;

const o1: Obj = &#123; a: 1 &#125;; // 报错
const o2: Obj = &#123; a: 1, b: 1, c: 1 &#125;; // 报错
</code></pre>
<ul>
<li>变量 o1 缺少了属性 b，变量 o2 多出了属性 c，都会报错</li>
<li>注意与函数类型区分：函数类型的实参个数可以少于类型指定的参数个数</li>
</ul>
<ol start="2">
<li>对象属性读写<blockquote>
<p>使用对象打点属性的方法读写</p>
<ul>
<li>读写不存在的属性会报错</li>
</ul>
</blockquote>
</li>
</ol>
<pre><code>const obj: &#123;
  a: number;
  b: number;
&#125; = &#123; a: 1, b: 1 &#125;;

console.log(obj.a)//1

console.log(obj.c); // 报错
obj.c = 1; // 报错
</code></pre>
<ul>
<li>读写不存在的属性 c 都会报错</li>
</ul>
<ol start="3">
<li>对象属性删除 与 修改<blockquote>
<p>同样，也不能删除类型声明中存在的属性，修改属性值是可以的。</p>
</blockquote>
</li>
</ol>
<pre><code>const users = &#123;
  username: &quot;code&quot;,
&#125;;

delete users.username; // 报错
users.username = &quot;abc&quot;; // 正确

// 删除类型声明中存在的属性 username 会报错，但是可以修改它的值
</code></pre>
<ol start="4">
<li>对象的方法<blockquote>
<p>对象的方法使用函数类型描述</p>
</blockquote>
</li>
</ol>
<pre><code>const obj: &#123;
  a: number;
  b: number;
  add(a: number, b: number): number;
  // 或者写成
  // add: (a: number, b: number) =&gt; number;
&#125; = &#123;
  a: 1,
  b: 2,
  add(a, b) &#123;
    return a + b;
  &#125;,
&#125;;
</code></pre>
<ul>
<li>对象 obj 有一个方法<code>add()</code>，需要定义它的参数类型和返回值类型。</li>
</ul>
<ol start="5">
<li>读取属性的类型<blockquote>
<p>对象类型可以使用方括号读取属性的类型。</p>
</blockquote>
</li>
</ol>
<pre><code>//type 取别名
type User = &#123;
  username: string;
  age: number;
&#125;;
type Name = User[&quot;username&quot;]; // string
</code></pre>
<ul>
<li>对象类型 User 使用方括号，读取了属性 username 的类型（string）</li>
</ul>
<ol start="6">
<li>interface 命令定义对象类型的接口<blockquote>
<p>除了type命令可以为对象类型声明一个别名，TypeScript 还提供了<code>interface</code>命令，可以把对象类型提炼为一个接口。</p>
</blockquote>
</li>
</ol>
<pre><code>// 写法一 type 命令 的用法
type Obj = &#123;
  a: number;
  b: number;
&#125;;

const obj: Obj = &#123; a: 1, b: 2 &#125;;

// 写法二 interface 命令的用法
interface Obj &#123;
  a: number;
  b: number;
&#125;

const obj: Obj = &#123; a: 1, b: 2 &#125;;
</code></pre>
<ol start="7">
<li>对象类型注意事项<blockquote>
<p>TypeScript 不区分对象自身的属性和继承的属性，一律视为对象的属性。</p>
</blockquote>
</li>
</ol>
<pre><code>interface Inter &#123;
  toString(): string; // 继承的属性
  prop: number; // 自身的属性
&#125;

const obj: Inter = &#123;
  // 正确
  prop: 123,
&#125;;
</code></pre>
<ul>
<li>obj 只写了 prop 属性，但是不报错</li>
<li>因为它可以继承原型上面的<code>toString()</code>方法</li>
</ul>
<h4 id="可选属性"><a href="#可选属性" class="headerlink" title="可选属性"></a>可选属性</h4><blockquote>
<p>如果某个属性是可选的（即可以忽略），需要在属性名后面加一个问号</p>
</blockquote>
<pre><code>const obj: &#123;
  a: number;
  b?: number;
&#125; = &#123; a: 1 &#125;;
</code></pre>
<ul>
<li>属性 b 是可选的</li>
</ul>
<blockquote>
<p>可选属性等同于允许赋值为<code>undefined</code>，下面两种写法是等效的</p>
</blockquote>
<pre><code>type User = &#123;
  firstName: string;
  lastName?: string;
&#125;;

// 等同于
type User = &#123;
  firstName: string;
  lastName?: string | undefined;
&#125;;
</code></pre>
<ul>
<li>类型 User 的可选属性 lastName 可以是字符串，也可以是 undefined，即可选属性可以赋值为 undefined</li>
</ul>
<blockquote>
<p>将可选属性赋值为 undefined</p>
</blockquote>
<pre><code>const obj: &#123;
  a: number;
  b?: number;
&#125; = &#123; a: 1, b: undefined &#125;;
</code></pre>
<ul>
<li>可选属性 b 赋值为 undefined，不会报错</li>
</ul>
<blockquote>
<p>同样，读取一个没有赋值的可选属性时，返回undefined</p>
</blockquote>
<pre><code>type Obj = &#123;
  a: string;
  b?: string;
&#125;;

const obj: Obj = &#123; a: &quot;code&quot; &#125;;
console.log(obj.b); //undefined
</code></pre>
<ol>
<li>可选属性注意事项<blockquote>
<p>读取可选属性之前，必须检查一下是否为undefined</p>
</blockquote>
</li>
</ol>
<pre><code>const user: &#123;
  firstName: string;
  lastName?: string;
&#125; = &#123; firstName: &quot;Foo&quot; &#125;;

if (user.lastName !== undefined) &#123;
  console.log(`hello $&#123;user.firstName&#125; $&#123;user.lastName&#125;`);
&#125;
</code></pre>
<ul>
<li>lastName是可选属性，需要判断是否为undefined以后，才能使用</li>
</ul>
<blockquote>
<p>建议使用下面的写法。</p>
</blockquote>
<pre><code>const user: &#123;
  firstName: string;
  lastName?: string;
&#125; = &#123; firstName: &quot;Foo&quot; &#125;;

// 写法一  使用三元运算符 ?:
let firstName = user.firstName === undefined ? &quot;Foo&quot; : user.firstName;
let lastName = user.lastName === undefined ? &quot;Bar&quot; : user.lastName;

// 写法二 使用 Null 判断运算符 ??
let firstName = user.firstName ?? &quot;Foo&quot;;
let lastName = user.lastName ?? &quot;Bar&quot;;
</code></pre>
<ul>
<li>写法二与写法一的作用完全相同</li>
</ul>
<blockquote>
<p>TypeScript 提供编译设置<code>ExactOptionalPropertyTypes</code>，只要同时打开这个设置和<code>strictNullChecks</code>，可选属性就不能设为<code>undefined</code></p>
<ul>
<li>在 <code>tsconfig.json </code>中打开以下两个配置</li>
</ul>
</blockquote>
<pre><code>&#123;
  &quot;compilerOptions&quot;: &#123;
    &quot;exactOptionalPropertyTypes&quot;: true,
    &quot;strictNullChecks&quot;: true
  &#125;
&#125;
</code></pre>
<ul>
<li>打开了这两个设置以后，可选属性就不能设为undefined了</li>
</ul>
<blockquote>
<p>可选属性与允许设为<code>undefined</code>的必选属性是不等价的</p>
<ul>
<li>可选属性赋值时可以省略</li>
<li>如果显式设置类型可以为<code>undefined</code>，就不能省略该属性</li>
</ul>
</blockquote>
<pre><code>type A = &#123; a: number; b?: number &#125;;
type B = &#123; a: number; b: number | undefined &#125;;

const ObjA: A = &#123; a: 1 &#125;; // 正确
const ObjB: B = &#123; a: 1 &#125;; // 报错
</code></pre>
<ul>
<li>如果是允许设为 undefined 的必选属性，一旦省略就会报错，必须显式写成<code>&#123; a: 1, b: undefined &#125;</code></li>
</ul>
<h4 id="只读属性"><a href="#只读属性" class="headerlink" title="只读属性"></a>只读属性</h4><blockquote>
<p>属性名前面加上<code>readonly</code>关键字，表示这个属性是只读属性，不能修改。</p>
</blockquote>
<pre><code>interface User &#123;
  readonly username: string;
&#125;

// username 属性是只读属性，不能修改它的值
</code></pre>
<blockquote>
<p>只读属性的值不能修改</p>
</blockquote>
<pre><code>const person: &#123;
  readonly age: number;
&#125; = &#123; age: 20 &#125;;

person.age = 21; // 报错
</code></pre>
<blockquote>
<p>只读属性只能在对象初始化期间赋值，此后就不能修改该属性。</p>
</blockquote>
<pre><code>type Point = &#123;
  readonly a: number;
  readonly b: number;
&#125;;

const p: Point = &#123; a: 0, b: 0 &#125;;

p.a = 123; // 报错
</code></pre>
<ul>
<li>类型 Point 的属性 a 和 b 都带有修饰符 readonly</li>
<li>表示这两个属性只能在初始化期间赋值，后面再修改就会报错</li>
</ul>
<ol>
<li>只读属性注意事项<blockquote>
<p>如果属性值是一个<strong>对象</strong>，readonly修饰符并不禁止修改该对象的属性，只是禁止完全替换掉该对象</p>
</blockquote>
</li>
</ol>
<pre><code>interface User &#123;
  readonly student: &#123;
    username: string;
    age: number;
  &#125;;
&#125;

const u: User = &#123;
  student: &#123;
    username: &quot;code&quot;,
    age: 18,
  &#125;,
&#125;;

u.student.age = 20; // 正确

u.student = &#123;
  username: &quot;allen&quot;,
  age: 19,
&#125;; // 报错
</code></pre>
<ul>
<li><code>u.student</code>是只读属性，它的值是一个对象</li>
<li>修改这个对象的 age 属性是可以的，但是整个替换掉 u.student 属性会报错</li>
</ul>
<blockquote>
<p>另一个需要注意的地方是，如果一个对象有两个引用，即两个变量对应同一个对象，其中一个变量是<strong>可写</strong>的，另一个变量是<strong>只读</strong>的，那么从可写变量修改属性，<strong>会影响到只读变量</strong></p>
</blockquote>
<pre><code>interface Person &#123;
  username: string;
  age: number;
&#125;

interface ReadonlyPerson &#123;
  readonly username: string;
  readonly age: number;
&#125;

let p: Person = &#123;
  username: &quot;code&quot;,
  age: 18,
&#125;;

let r: ReadonlyPerson = p;

p.age += 1;
r.age; // 19
</code></pre>
<ul>
<li>变量 p 和 r 指向同一个对象，其中 p 是可写的，r 是只读的</li>
<li>那么，对 p 的属性修改，会影响到 r</li>
</ul>
<blockquote>
<p>注：</p>
</blockquote>
<ul>
<li>如果希望属性值是只读的，除了声明时加上<code>readonly</code>关键字，还有一种方法，就是在赋值时，在对象后面加上只读断言<code>as const</code></li>
</ul>
<ol start="2">
<li>只读断言<blockquote>
<p>如果希望属性值是只读的，除了声明时加上<code>readonly</code>关键字，还有一种方法，就是在赋值时，在对象后面加上只读断言<code>as const</code></p>
</blockquote>
</li>
</ol>
<pre><code>const user = &#123;
  username: &quot;code&quot;,
&#125; as const;

user.username = &quot;abc&quot;; // 报错
</code></pre>
<blockquote>
<p>注意，上面的<code>as const</code>属于 TypeScript 的类型推断，如果变量明确地声明了类型，那么 TypeScript 会<strong>以声明的类型为准</strong></p>
</blockquote>
<pre><code>const user: &#123; username: string &#125; = &#123;
  username: &quot;code&quot;,
&#125; as const;

user.username = &quot;abc&quot;; // 正确
</code></pre>
<ul>
<li>根据变量 user 的类型声明，username 不是只读属性，但是赋值时又使用只读断言as const</li>
<li>这时会以声明的类型为准，因此 username 属性可以修改</li>
</ul>
<h4 id="属性名的索引类型"><a href="#属性名的索引类型" class="headerlink" title="属性名的索引类型"></a>属性名的索引类型</h4><blockquote>
<p>如果对象的属性非常多，一个个声明类型就很麻烦，而且有些时候，无法事前知道对象会有多少属性，比如外部 API 返回的对象。</p>
<p>这时 TypeScript 允许采用属性名表达式的写法来描述类型，称为 “属性名的索引类型”。</p>
</blockquote>
<ol>
<li>属性名的字符串索引<blockquote>
<p>索引类型里面，最常见的就是属性名的字符串索引。</p>
</blockquote>
</li>
</ol>
<pre><code>type Obj = &#123;
  [property: string]: string;
&#125;;

const obj: Obj = &#123;
  foo: &quot;a&quot;,
  bar: &quot;b&quot;,
  baz: &quot;c&quot;,
&#125;;
</code></pre>
<ul>
<li>类型 Obj 的属性名类型就采用了表达式形式，写在方括号里面</li>
<li><code>[property: string]</code> 的 <code>property</code> 表示属性名，这个是可以随便起的，它的类型是 string，即属性名类型为 string</li>
<li>也就是说，不管这个对象有多少属性，只要属性名为字符串，且属性值也是字符串，就符合这个类型声明</li>
</ul>
<blockquote>
<p>JavaScript 对象的属性名（即上例的<code>property</code>）的类型有三种可能，除了上例的string，还有<code>number</code>和<code>symbol</code></p>
</blockquote>
<pre><code>type T1 = &#123;
  [property: number]: string;
&#125;;

type T2 = &#123;
  [property: symbol]: string;
&#125;;
</code></pre>
<ul>
<li>对象属性名的类型分别为 number 和 symbol</li>
</ul>
<ol start="2">
<li>属性名的数值索引</li>
</ol>
<pre><code>type Arr = &#123;
  [n: number]: number;
&#125;;

const a: Arr = [1, 2, 3];

// 或者
const a: Arr = &#123;
  0: 1,
  1: 2,
  2: 3,
&#125;;
</code></pre>
<ul>
<li>对象类型 Arr 的属性名是<code>[n:number]</code>，就表示它的属性名都是数值，比如 0、1、2</li>
</ul>
<ol start="3">
<li>同时有多种类型的属性名索引<blockquote>
<p>对象可以同时有多种类型的属性名索引，比如同时有数值索引和字符串索引，但不同类型的属性名对应的属性值类型必须一样</p>
</blockquote>
</li>
</ol>
<blockquote>
<p>在 JavaScript 语言内部，所有属性名都会自动转为字符串类型</p>
<ul>
<li>但在赋值时，还是会根据索引类型区分，如果声明的是数值索引，赋值时就不能使用字符串类型</li>
</ul>
</blockquote>
<pre><code>type Obj = &#123;
  123:string; 
  // foo: boolean; // 报错
  [property: string]: string;
  [n: number]: string;
&#125;;
const abc:Obj=&#123;
  123:&quot;111&quot;,
  name:&quot;222&quot;,
  2:&quot;333&quot;
&#125;
for(let key in abc)&#123;
  console.log(key)
  console.log(typeof key)
&#125;
//2 string
//123 string
//name string
</code></pre>
<ul>
<li>其实属性名的索引类型都会自动转成字符串类型</li>
<li>类型 Obj 可以同时有多种类型的属性名索引，但不同类型的属性名对应的属性值类型必须一样，也就是只有同样为 string，才不会报错</li>
</ul>
<blockquote>
<p>同样地，可以既声明属性名索引，也声明具体的单个属性名。属性名的类型可以不同，但是对应的值类型必须相同，否则会报错</p>
<ul>
<li>如果有冲突，以属性名索引声明的属性值类型为准，单个声明的属性会报错</li>
</ul>
</blockquote>
<pre><code>type Obj = &#123;
  foo: boolean; // 报错
  123: number; // 报错
  // [a: string]: string;
&#125;;
</code></pre>
<ul>
<li>属性名不同，但是前两个的属性值类型与属性名索引所声明的值类型冲突，所以报错</li>
</ul>
<ol>
<li>属性的索引类型注意事项<blockquote>
<p>属性的索引类型写法，建议谨慎使用，因为属性名的声明太宽泛，约束太少。</p>
</blockquote>
</li>
</ol>
<p>另外，属性名的<strong>数值索引</strong>不宜用来声明数组，因为采用这种方式声明数组，就不能使用各种数组方法以及<code>length</code>属性，因为类型里面没有定义这些东西</p>
<pre><code>type Arr = &#123;
  [a: number]: number;
&#125;;

const arr: Arr = [1, 2, 3];
arr.length; // 报错
</code></pre>
<ul>
<li>读取 <code>arr.length</code> 属性会报错，因为类型 Arr 没有这个属性</li>
</ul>
<h4 id="解构赋值"><a href="#解构赋值" class="headerlink" title="解构赋值"></a>解构赋值</h4><blockquote>
<p>解构赋值用于直接从对象中提取属性。</p>
</blockquote>
<pre><code>// 从对象 student 提取了三个属性，并声明属性名的同名变量
const &#123; id, username, age &#125; = student;
</code></pre>
<blockquote>
<p>解构赋值的类型写法，跟为对象声明类型是一样的。</p>
</blockquote>
<pre><code>const &#123;
  //声明变量
  id,
  username,
  age,
&#125;: &#123;
  //声明变量类型
  id: string;
  username: string;
  age: number;
&#125; = student;
</code></pre>
<blockquote>
<p>注意，目前没法为解构变量指定类型，因为对象解构里面的冒号，JavaScript 指定了其他用途。</p>
</blockquote>
<pre><code>//给a b属性指定变量名
let &#123; a: foo, b: bar &#125; = obj;

// 等同于
let foo = obj.a;
let bar = obj.b;
</code></pre>
<ul>
<li>冒号不是表示属性 a 和 b 的类型，而是为这两个属性指定新的变量名</li>
</ul>
<blockquote>
<p>如果要为 a 和 b 指定类型，不得不写成下面这样</p>
</blockquote>
<pre><code>//给a b属性指定变量 同时声明类型
let &#123; a: foo, b: bar &#125;: &#123; a: string; b: number &#125; = obj;
</code></pre>
<blockquote>
<p>以上的方式要注意，在 TypeScript 中很容易混淆</p>
</blockquote>
<pre><code>//将属性 shape 的值赋值给变量 Shape
function position(&#123; shape: Shape, xPos: number = 23.5, yPos: number = 56.2 &#125;) &#123;
  let s = shape; // 报错
  let x = xPos; // 报错
&#125;
</code></pre>
<ul>
<li>函数 <code>position()</code> 的参数是一个对象解构，里面的冒号很像是为变量指定类型，其实是为对应的属性指定新的变量名</li>
<li>所以，TypeScript 就会解读成，函数体内不存在变量 shape，而是属性 shape 的值被赋值给了变量 Shape</li>
</ul>
<h4 id="结构类型原则"><a href="#结构类型原则" class="headerlink" title="结构类型原则"></a>结构类型原则</h4><blockquote>
<p>只要对象 B 满足 对象 A 的结构特征，TypeScript 就认为对象 B 兼容对象 A 的类型，这称为“结构类型”原则（structural typing）</p>
</blockquote>
<pre><code>type A = &#123;
  a: number;
&#125;;

type B = &#123;
  a: number;
  b: number;
&#125;;
</code></pre>
<ul>
<li>对象 A 只有一个属性 a，类型为 number</li>
<li>对象 B 满足这个特征，因此兼容对象 A，只要可以使用 A 的地方，就可以使用 B</li>
</ul>
<blockquote>
<p>以下代码中，A和B并不是同一个类型</p>
</blockquote>
<pre><code>const B = &#123;
  a: 1,
  b: 2,
&#125;;

const A: &#123; a: number &#125; = B; // 正确
</code></pre>
<ul>
<li>A 和 B 并不是同一个类型，但是 B 可以赋值给 A，因为 B 满足 A 的结构特征。</li>
</ul>
<ol>
<li>结构类型原则注意事项<blockquote>
<p>根据“结构类型”原则，TypeScript 检查某个值是否符合指定类型时，并不是检查这个值的类型名（即“名义类型”），而是检查<strong>这个值的结构</strong>是否符合要求（即“结构类型”）。</p>
</blockquote>
</li>
</ol>
<p>TypeScript 之所以这样设计，是为了符合 JavaScript 的行为。JavaScript 并不关心对象是否严格相似，只要某个对象具有所要求的属性，就可以正确运行。</p>
<blockquote>
<p>如果类型 B 可以赋值给类型 A</p>
<ul>
<li>TypeScript 就认为 B 是 A 的子类型（subtyping），A 是 B 的父类型。</li>
<li>子类型满足父类型的所有结构特征，同时还具有自己的特征</li>
<li>凡是可以使用父类型的地方，都可以使用子类型，即子类型兼容父类型</li>
</ul>
</blockquote>
<pre><code>type Obj = &#123;
  a: number;
  b: number;
&#125;;

function getSum(obj: Obj) &#123;
  let sum = 0;
  for (const n of Object.keys(obj)) &#123;
    const res = obj[n]; // 报错
    // Math.abs() 返回一个数的绝对值
    sum += Math.abs(res);
  &#125;
  return sum;
&#125;
</code></pre>
<ul>
<li>函数 getSum() 要求传入参数的类型是 Obj，但是实际上所有与 Obj 兼容的对象都可以传入</li>
<li>这会导致 const res &#x3D; obj[n] 这一行报错</li>
<li>原因是 obj[n] 取出的属性值不一定是数值（number），使得变量 res 的类型被推断为 any</li>
</ul>
<blockquote>
<p>如果项目设置为不允许变量类型推断为<code>any</code>，代码就会报错。写成下面这样，就不会报错</p>
</blockquote>
<pre><code>type Obj = &#123;
  a: number;
  b: number;
&#125;;

function getSum(obj: Obj) &#123;
  return Math.abs(obj.a) + Math.abs(obj.b);
&#125;
</code></pre>
<ul>
<li>此时就不会报错，因为函数体内部只使用了属性 a 和 b，这两个属性有明确的类型声明，保证 <code>obj.a</code> 和 <code>obj.b</code> 肯定是数值</li>
<li>虽然与 Obj 兼容的任何对象都可以传入函数<code>getSum()</code>，但是只要不使用其他属性，就不会有类型报错</li>
</ul>
<h4 id="严格字面量检查"><a href="#严格字面量检查" class="headerlink" title="严格字面量检查"></a>严格字面量检查</h4><blockquote>
<p>如果对象使用字面量表示，会触发 TypeScript 的严格字面量检查（strict object literal checking）。</p>
</blockquote>
<blockquote>
<p>如果字面量的结构跟类型定义的不一样（比如多出了未定义的属性），就会报错。</p>
</blockquote>
<pre><code>const num: &#123;
  a: number;
  b: number;
&#125; = &#123;
  a: 1,
  b: 2,
  c: 3, // 报错
&#125;;
</code></pre>
<ul>
<li>等号右边是一个对象的字面量，这时会触发严格字面量检查</li>
<li>只要有类型声明中不存在的属性（如：属性 c），就会导致报错</li>
</ul>
<blockquote>
<p>如果等号右边不是字面量，而是一个变量，根据结构类型原则，是不会报错的。</p>
</blockquote>
<pre><code>const num = &#123;
  a: 1,
  b: 2,
  c: 3,
&#125;;

const n: &#123;
  a: number;
  b: number;
&#125; = num; // 正确
</code></pre>
<ul>
<li>等号右边是一个变量，就不会触发严格字面量检查，从而不报错</li>
</ul>
<ol>
<li>严格检查的目的<blockquote>
<p>TypeScript 对字面量进行严格检查的目的，主要是防止拼写错误。一般来说，字面量大多数来自手写，容易出现拼写错误，或者误用 API。</p>
</blockquote>
</li>
</ol>
<pre><code>type User = &#123;
  username: string;
  age?: number;
&#125;;

const obj: User = &#123;
  username: &quot;code&quot;,
  agem: 18, // 报错
&#125;;
</code></pre>
<ul>
<li>属性 age 拼写错了，成了 agem</li>
<li>如果没有严格字面量规则，就不会报错，因为 age 是可选属性，根据结构类型原则，任何对象只要有 username 属性，都认为符合 User 类型</li>
</ul>
<ol start="2">
<li>规避严格字面量检查<blockquote>
<p>规避严格字面量检查，可以使用中间变量。</p>
</blockquote>
</li>
</ol>
<pre><code>type User = &#123;
  username: string;
  age?: number;
&#125;;

// 中间变量
let user = &#123;
  username: &quot;code&quot;,
  // 故意将 age 写成 agem，也不会报错
  agem: 18,
&#125;;

const obj: User = user;
</code></pre>
<ul>
<li>创建了一个中间变量 user，就不会触发严格字面量规则</li>
<li>因为这时变量 obj 的赋值，不属于直接字面量赋值</li>
</ul>
<blockquote>
<p>如果你确认字面量没有错误，也可以使用类型断言规避严格字面量检查。</p>
</blockquote>
<pre><code>type User = &#123;
  username: string;
  age?: number;
&#125;;

const obj: User = &#123;
  username: &quot;code&quot;,
  agem: 18, // 正确
&#125; as User; // 添加类型断言
</code></pre>
<ul>
<li>使用类型断言<code>as User</code>，告诉编译器，字面量符合 User 类型，就能规避这条规则</li>
</ul>
<ol start="3">
<li>严格字面量检查 - 注意事项<blockquote>
<p>如果允许字面量有多余属性，可以像下面这样在类型里面定义一个通用属性</p>
</blockquote>
</li>
</ol>
<pre><code>let a: &#123;
  foo: number;
  [a: string]: any;
&#125;;

a = &#123; foo: 1, bar: 2 &#125;;
</code></pre>
<ul>
<li>变量 a 的类型声明里面，有一个属性的字符串索引（<code>[a: string]</code>），导致任何字符串属性名都是合法的</li>
</ul>
<blockquote>
<p>由于严格字面量检查，字面量对象传入函数必须很小心，不能有多余的属性。</p>
</blockquote>
<pre><code>interface Count &#123;
  a: number;
  b: number;
&#125;

function computeCount(count: Count) &#123;
  //
&#125;

computeCount(&#123; a: 1, b: 2, c: 3 &#125;); // 报错
computeCount(&#123; a: 1, b: 2 &#125;); // 正确
</code></pre>
<ul>
<li>对象字面量传入函数 <code>computeCount()</code> 时，不能有多余的属性，否则就通不过严格字面量检查</li>
</ul>
<blockquote>
<p>编译器选项<code>suppressExcessPropertyErrors</code>，可以关闭多余属性检查。下面是它在 <code>tsconfig.json</code> 文件里面的写法</p>
</blockquote>
<pre><code>&#123;
  &quot;compilerOptions&quot;: &#123;
    &quot;suppressExcessPropertyErrors&quot;: true
  &#125;
&#125;
</code></pre>
<h4 id="最小可选属性规则"><a href="#最小可选属性规则" class="headerlink" title="最小可选属性规则"></a>最小可选属性规则</h4><blockquote>
<p>根据“结构类型”原则，如果一个对象的所有属性都是可选的，那么其他对象跟它都是结构类似的。</p>
</blockquote>
<pre><code>type Count = &#123;
  a?: number;
  b?: number;
  c?: number;
&#125;;
</code></pre>
<ul>
<li>类型 Count 的所有属性都是可选的</li>
<li>所以它可以是一个空对象，也就意味着任意对象都满足 Count 的结构</li>
</ul>
<blockquote>
<p>为了避免这种情况，TypeScript 2.4 引入了一个“最小可选属性规则”，也称为“弱类型检测”（weak type detection）</p>
</blockquote>
<pre><code>type Count = &#123;
  a?: number;
  b?: number;
  c?: number;
&#125;;

const opts = &#123; d: 123 &#125;;

const obj: Count = opts; // 报错
</code></pre>
<ul>
<li>对象 <code>opts</code> 与 类型 <code>Count</code> 没有共同属性，赋值给该类型的变量就会报错</li>
<li>报错原因是，如果某个类型的所有属性都是可选的，那么该类型的对象必须<strong>至少存在一个可选属性</strong>，不能所有可选属性都不存在。这就叫做 “最小可选属性规则” 。</li>
</ul>
<blockquote>
<p>如果想规避这条规则，要么在类型里面增加一条索引属性（<code>[propName: string]: someType</code>），要么使用类型断言</p>
</blockquote>
<h4 id="空对象"><a href="#空对象" class="headerlink" title="空对象"></a>空对象</h4><blockquote>
<p>空对象是 TypeScript 的一种特殊值，也是一种特殊类型。</p>
</blockquote>
<pre><code>const obj = &#123;&#125;;
obj.prop = 123; // 报错
</code></pre>
<ul>
<li>变量 obj 的值是一个空对象，然后对 <code>obj.prop</code> 赋值就会报错</li>
</ul>
<blockquote>
<p>原因是这时 TypeScript 会推断变量obj的类型为空对象，实际执行的是下面的代码。</p>
</blockquote>
<pre><code>const obj: &#123;&#125; = &#123;&#125;;
</code></pre>
<ul>
<li>空对象没有自定义属性，所以对自定义属性赋值就会报错。</li>
<li>空对象只能使用继承的属性，即继承自原型对象 <code>Object.prototype</code> 的属性</li>
</ul>
<pre><code>obj.toString(); // 正确
// toString() 方法是一个继承自原型对象的方法，TypeScript 允许在空对象上使用
</code></pre>
<ul>
<li>以上代码中，这种写法其实在 JavaScript 很常见：先声明一个空对象，然后向空对象添加属性。</li>
<li>但是，TypeScript <strong>不允许动态添加属性</strong>，所以对象不能分步生成，必须生成时一次性声明所有属性。</li>
</ul>
<pre><code>// 错误
const obj = &#123;&#125;;
obj.a = 1;
obj.b = 2;

// 正确
const obj = &#123;
  a: 1,
  b: 2,
&#125;;
</code></pre>
<ol>
<li>空对象注意事项<blockquote>
<p>如果确实需要分步声明，一个比较好的方法是，使用扩展运算符（<code>...</code>）合成一个新对象。</p>
</blockquote>
</li>
</ol>
<pre><code>const obj0 = &#123;&#125;;
const obj1 = &#123; a: 1 &#125;;
const obj2 = &#123; b: 2 &#125;;

const obj = &#123;
  ...obj0,
  ...obj1,
  ...obj2,
&#125;;
</code></pre>
<ul>
<li>对象 obj 是三个部分合成的，这样既可以分步声明，也符合 TypeScript 静态声明的要求</li>
</ul>
<blockquote>
<p>空对象作为类型，其实是Object类型的简写形式。</p>
</blockquote>
<pre><code>let a: &#123;&#125;;
// 等同于
// let a: Object;

a = &#123;&#125;;
a = &#123; x: 1 &#125;;
a = &quot;icoding&quot;;
a = 2;
</code></pre>
<ul>
<li>各种类型的值（除了null 和 undefined）都可以赋值给空对象类型，跟 Object 类型的行为是一样的</li>
</ul>
<blockquote>
<p>因为Object可以接受各种类型的值，而空对象是Object类型的简写，所以它不会有严格字面量检查，赋值时总是允许多余的属性，只是不能读取这些属性</p>
</blockquote>
<pre><code>interface Empty &#123;&#125;
const e: Empty = &#123; a: 1, b: 2 &#125;; // 正确
e.a; // 报错
</code></pre>
<ul>
<li>变量 e 的类型是空对象，视同 Object 类型，不会有严格字面量检查，但是读取多余的属性会报错</li>
</ul>
<blockquote>
<p>如果想强制使用没有任何属性的对象，可以采用下面的写法。</p>
</blockquote>
<pre><code>interface NoProperties &#123;
  [key: string]: never;
&#125;

// 报错
const a: NoProperties = &#123; prop: 123 &#125;;
</code></pre>
<ul>
<li>[key: string]: never 表示字符串属性名是不存在的</li>
<li>因此其他对象进行赋值时就会报错</li>
</ul>

                
            </div>
            <hr/>

            

    <div class="reprint" id="reprint-statement">
        
            <div class="reprint__author">
                <span class="reprint-meta" style="font-weight: bold;">
                    <i class="fas fa-user">
                        文章作者:
                    </i>
                </span>
                <span class="reprint-info">
                    <a href="/about" rel="external nofollow noreferrer">hermia</a>
                </span>
            </div>
            <div class="reprint__type">
                <span class="reprint-meta" style="font-weight: bold;">
                    <i class="fas fa-link">
                        文章链接:
                    </i>
                </span>
                <span class="reprint-info">
                    <a href="https://hermiablog.com/2024/02/03/TypeScript%EF%BC%88%E4%BA%8C%EF%BC%89/">https://hermiablog.com/2024/02/03/TypeScript%EF%BC%88%E4%BA%8C%EF%BC%89/</a>
                </span>
            </div>
            <div class="reprint__notice">
                <span class="reprint-meta" style="font-weight: bold;">
                    <i class="fas fa-copyright">
                        版权声明:
                    </i>
                </span>
                <span class="reprint-info">
                    本博客所有文章除特別声明外，均采用
                    <a href="https://creativecommons.org/licenses/by/4.0/deed.zh" rel="external nofollow noreferrer" target="_blank">CC BY 4.0</a>
                    许可协议。转载请注明来源
                    <a href="/about" target="_blank">hermia</a>
                    !
                </span>
            </div>
        
    </div>

    <script async defer>
      document.addEventListener("copy", function (e) {
        let toastHTML = '<span>复制成功，请遵循本文的转载规则</span><button class="btn-flat toast-action" onclick="navToReprintStatement()" style="font-size: smaller">查看</a>';
        M.toast({html: toastHTML})
      });

      function navToReprintStatement() {
        $("html, body").animate({scrollTop: $("#reprint-statement").offset().top - 80}, 800);
      }
    </script>



            <div class="tag_share" style="display: block;">
                <div class="post-meta__tag-list" style="display: inline-block;">
                    
                        <div class="article-tag">
                            
                                <a href="/tags/TypesSript/">
                                    <span class="chip bg-color">TypesSript</span>
                                </a>
                            
                        </div>
                    
                </div>
                <div class="post_share" style="zoom: 80%; width: fit-content; display: inline-block; float: right; margin: -0.15rem 0;">
                    <link rel="stylesheet" type="text/css" href="/libs/share/css/share.min.css">
<div id="article-share">

    
    <div class="social-share" data-sites="qq,qzone,wechat,weibo" data-wechat-qrcode-helper="<p>微信扫一扫即可分享！</p>"></div>
    <script src="/libs/share/js/social-share.min.js"></script>
    

    

</div>

                </div>
            </div>
            
                <style>
    #reward {
        margin: 40px 0;
        text-align: center;
    }

    #reward .reward-link {
        font-size: 1.4rem;
        line-height: 38px;
    }

    #reward .btn-floating:hover {
        box-shadow: 0 6px 12px rgba(0, 0, 0, 0.2), 0 5px 15px rgba(0, 0, 0, 0.2);
    }

    #rewardModal {
        width: 320px;
        height: 350px;
    }

    #rewardModal .reward-title {
        margin: 15px auto;
        padding-bottom: 5px;
    }

    #rewardModal .modal-content {
        padding: 10px;
    }

    #rewardModal .close {
        position: absolute;
        right: 15px;
        top: 15px;
        color: rgba(0, 0, 0, 0.5);
        font-size: 1.3rem;
        line-height: 20px;
        cursor: pointer;
    }

    #rewardModal .close:hover {
        color: #ef5350;
        transform: scale(1.3);
        -moz-transform:scale(1.3);
        -webkit-transform:scale(1.3);
        -o-transform:scale(1.3);
    }

    #rewardModal .reward-tabs {
        margin: 0 auto;
        width: 210px;
    }

    .reward-tabs .tabs {
        height: 38px;
        margin: 10px auto;
        padding-left: 0;
    }

    .reward-content ul {
        padding-left: 0 !important;
    }

    .reward-tabs .tabs .tab {
        height: 38px;
        line-height: 38px;
    }

    .reward-tabs .tab a {
        color: #fff;
        background-color: #ccc;
    }

    .reward-tabs .tab a:hover {
        background-color: #ccc;
        color: #fff;
    }

    .reward-tabs .wechat-tab .active {
        color: #fff !important;
        background-color: #22AB38 !important;
    }

    .reward-tabs .alipay-tab .active {
        color: #fff !important;
        background-color: #019FE8 !important;
    }

    .reward-tabs .reward-img {
        width: 210px;
        height: 210px;
    }
</style>

<div id="reward">
    <a href="#rewardModal" class="reward-link modal-trigger btn-floating btn-medium waves-effect waves-light red">赏</a>

    <!-- Modal Structure -->
    <div id="rewardModal" class="modal">
        <div class="modal-content">
            <a class="close modal-close"><i class="fas fa-times"></i></a>
            <h4 class="reward-title">你的赏识是我前进的动力</h4>
            <div class="reward-content">
                <div class="reward-tabs">
                    <ul class="tabs row">
                        <li class="tab col s6 alipay-tab waves-effect waves-light"><a href="#alipay">支付宝</a></li>
                        <li class="tab col s6 wechat-tab waves-effect waves-light"><a href="#wechat">微 信</a></li>
                    </ul>
                    <div id="alipay">
                        <img src="/medias/reward/alipay.jpg" class="reward-img" alt="支付宝打赏二维码">
                    </div>
                    <div id="wechat">
                        <img src="/medias/reward/wechat.png" class="reward-img" alt="微信打赏二维码">
                    </div>
                </div>
            </div>
        </div>
    </div>
</div>

<script>
    $(function () {
        $('.tabs').tabs();
    });
</script>

            
        </div>
    </div>

    

    

    

    

    

    

    

    

<article id="prenext-posts" class="prev-next articles">
    <div class="row article-row">
        
        <div class="article col s12 m6" data-aos="fade-up">
            <div class="article-badge left-badge text-color">
                <i class="fas fa-chevron-left"></i>&nbsp;上一篇</div>
            <div class="card">
                <a href="/2024/02/04/TypeScript%EF%BC%88%E4%B8%89%EF%BC%89/">
                    <div class="card-image">
                        
                        <img src="/medias/featureimages/53.jpg" class="responsive-img" alt="TypeScript（三）">
                        
                        <span class="card-title">TypeScript（三）</span>
                    </div>
                </a>
                <div class="card-content article-content">
                    <div class="summary block-with-text">
                        
                            Enum枚举类型、interface类型
                        
                    </div>
                    <div class="publish-info">
                        <span class="publish-date">
                            <i class="far fa-clock fa-fw icon-date"></i>2024-02-04
                        </span>
                        <span class="publish-author">
                            
                            <i class="fas fa-bookmark fa-fw icon-category"></i>
                            
                            <a href="/categories/%E6%8A%80%E6%9C%AF/" class="post-category">
                                    技术
                                </a>
                            
                            
                        </span>
                    </div>
                </div>
                
                <div class="card-action article-tags">
                    
                    <a href="/tags/TypesSript/">
                        <span class="chip bg-color">TypesSript</span>
                    </a>
                    
                </div>
                
            </div>
        </div>
        
        
        <div class="article col s12 m6" data-aos="fade-up">
            <div class="article-badge right-badge text-color">
                下一篇&nbsp;<i class="fas fa-chevron-right"></i>
            </div>
            <div class="card">
                <a href="/2024/02/01/TypeScript%EF%BC%88%E4%B8%80%EF%BC%89/">
                    <div class="card-image">
                        
                        <img src="/medias/featureimages/51.jpg" class="responsive-img" alt="TypeScript（一）">
                        
                        <span class="card-title">TypeScript（一）</span>
                    </div>
                </a>
                <div class="card-content article-content">
                    <div class="summary block-with-text">
                        
                            TS概述、基础类型、数组、元组、any、unknown、never
                        
                    </div>
                    <div class="publish-info">
                            <span class="publish-date">
                                <i class="far fa-clock fa-fw icon-date"></i>2024-02-01
                            </span>
                        <span class="publish-author">
                            
                            <i class="fas fa-bookmark fa-fw icon-category"></i>
                            
                            <a href="/categories/%E6%8A%80%E6%9C%AF/" class="post-category">
                                    技术
                                </a>
                            
                            
                        </span>
                    </div>
                </div>
                
                <div class="card-action article-tags">
                    
                    <a href="/tags/TypesSript/">
                        <span class="chip bg-color">TypesSript</span>
                    </a>
                    
                </div>
                
            </div>
        </div>
        
    </div>
</article>

</div>



<!-- 代码块功能依赖 -->
<script type="text/javascript" src="/libs/codeBlock/codeBlockFuction.js"></script>

<!-- 代码语言 -->

<script type="text/javascript" src="/libs/codeBlock/codeLang.js"></script>


<!-- 代码块复制 -->

<script type="text/javascript" src="/libs/codeBlock/codeCopy.js"></script>


<!-- 代码块收缩 -->

<script type="text/javascript" src="/libs/codeBlock/codeShrink.js"></script>


  </div>
  <div id="toc-aside" class="expanded col l3 hide-on-med-and-down">
    <div class="toc-widget card" style="background-color: white">
      <div class="toc-title">
        <i class="far fa-list-alt"></i>&nbsp;&nbsp;目录
      </div>
      <div id="toc-content"></div>
    </div>
  </div>
</div>

<!-- TOC 悬浮按钮. -->

<div id="floating-toc-btn" class="hide-on-med-and-down">
  <a class="btn-floating btn-large bg-color">
    <i class="fas fa-list-ul"></i>
  </a>
</div>


<script src="/libs/tocbot/tocbot.min.js"></script>
<script>
  $(function () {
      tocbot.init({
          tocSelector: '#toc-content',
          contentSelector: '#articleContent',
          headingsOffset: -($(window).height() * 0.4 - 45),
          collapseDepth: Number('0'),
          headingSelector: 'h2, h3, h4'
      });

      // modify the toc link href to support Chinese.
      let i = 0;
      let tocHeading = 'toc-heading-';
      $('#toc-content a').each(function () {
          $(this).attr('href', '#' + tocHeading + (++i));
      });

      // modify the heading title id to support Chinese.
      i = 0;
      $('#articleContent').children('h2, h3, h4').each(function () {
          $(this).attr('id', tocHeading + (++i));
      });

      // Set scroll toc fixed.
      let tocHeight = parseInt($(window).height() * 0.4 - 64);
      let $tocWidget = $('.toc-widget');
      $(window).scroll(function () {
          let scroll = $(window).scrollTop();
          /* add post toc fixed. */
          if (scroll > tocHeight) {
              $tocWidget.addClass('toc-fixed');
          } else {
              $tocWidget.removeClass('toc-fixed');
          }
      });

      
      /* 修复文章卡片 div 的宽度. */
      let fixPostCardWidth = function (srcId, targetId) {
          let srcDiv = $('#' + srcId);
          if (srcDiv.length === 0) {
              return;
          }

          let w = srcDiv.width();
          if (w >= 450) {
              w = w + 21;
          } else if (w >= 350 && w < 450) {
              w = w + 18;
          } else if (w >= 300 && w < 350) {
              w = w + 16;
          } else {
              w = w + 14;
          }
          $('#' + targetId).width(w);
      };

      // 切换TOC目录展开收缩的相关操作.
      const expandedClass = 'expanded';
      let $tocAside = $('#toc-aside');
      let $mainContent = $('#main-content');
      $('#floating-toc-btn .btn-floating').click(function () {
          if ($tocAside.hasClass(expandedClass)) {
              $tocAside.removeClass(expandedClass).hide();
              $mainContent.removeClass('l9');
          } else {
              $tocAside.addClass(expandedClass).show();
              $mainContent.addClass('l9');
          }
          fixPostCardWidth('artDetail', 'prenext-posts');
      });
      
  });
</script>

    

</main>




    <footer class="page-footer bg-color">
   <link rel="stylesheet" href="/libs/aplayer/APlayer.min.css">
<style>
    .aplayer .aplayer-lrc p {
        
        font-size: 12px;
        font-weight: 700;
        line-height: 16px !important;
    }

    .aplayer .aplayer-lrc p.aplayer-lrc-current {
        
        font-size: 15px;
        color: #a3ddf0;
        /* color: #59cde9; */
    }

    
    .aplayer.aplayer-fixed.aplayer-narrow .aplayer-body {
        left: -66px !important;
    }

    .aplayer.aplayer-fixed.aplayer-narrow .aplayer-body:hover {
        left: 0px !important;
    }

    
</style>
<div class="">
    
    <div class="row">
        <meting-js class="col l8 offset-l2 m10 offset-m1 s12"
                   server="netease"
                   type="playlist"
                   id="2450546498"
                   fixed='true'
                   autoplay='false'
                   theme='#59cde9'
                   loop='all'
                   order='random'
                   preload='auto'
                   volume='0.7'
                   list-folded='true'
        >
        </meting-js>
    </div>
</div>

<script src="/libs/aplayer/APlayer.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/meting@2/dist/Meting.min.js"></script>
 
  <div
    class="container row center-align"
    style="margin-bottom: 15px !important;"
  >
    <div class="col s12 m8 l8 copy-right">
      Copyright&nbsp;&copy; 
      <span id="year"
        >2023-2024</span
      >
      
      <span id="year">2023</span>
      <a href="/about" target="_blank"
        >hermia</a
      >
      |&nbsp;Powered by&nbsp;<a href="https://hexo.io/" target="_blank">Hexo</a>
      |&nbsp;Theme&nbsp;<a
        href="https://github.com/blinkfox/hexo-theme-matery"
        target="_blank"
        >Matery</a
      >
      <br />
           
      <span id="busuanzi_container_site_pv">
        |&nbsp;<i class="far fa-eye"></i>&nbsp;总访问量:&nbsp;<span
          id="busuanzi_value_site_pv"
          class="white-color"
        ></span
        >&nbsp;次
      </span>
       
      <span id="busuanzi_container_site_uv">
        |&nbsp;<i class="fas fa-users"></i>&nbsp;总访问人数:&nbsp;<span
          id="busuanzi_value_site_uv"
          class="white-color"
        ></span
        >&nbsp;人
      </span>
      
      <br />
      
      <span id="sitetime">载入运行时间...</span>
      <script>
        function siteTime() {
          var seconds = 1000;
          var minutes = seconds * 60;
          var hours = minutes * 60;
          var days = hours * 24;
          var years = days * 365;
          var today = new Date();
          var startYear = "2023";
          var startMonth = "11";
          var startDate = "14";
          var startHour = "0";
          var startMinute = "0";
          var startSecond = "0";
          var todayYear = today.getFullYear();
          var todayMonth = today.getMonth() + 1;
          var todayDate = today.getDate();
          var todayHour = today.getHours();
          var todayMinute = today.getMinutes();
          var todaySecond = today.getSeconds();
          var t1 = Date.UTC(
            startYear,
            startMonth,
            startDate,
            startHour,
            startMinute,
            startSecond
          );
          var t2 = Date.UTC(
            todayYear,
            todayMonth,
            todayDate,
            todayHour,
            todayMinute,
            todaySecond
          );
          var diff = t2 - t1;
          var diffYears = Math.floor(diff / years);
          var diffDays = Math.floor(diff / days - diffYears * 365);
          var diffHours = Math.floor(
            (diff - (diffYears * 365 + diffDays) * days) / hours
          );
          var diffMinutes = Math.floor(
            (diff - (diffYears * 365 + diffDays) * days - diffHours * hours) /
              minutes
          );
          var diffSeconds = Math.floor(
            (diff -
              (diffYears * 365 + diffDays) * days -
              diffHours * hours -
              diffMinutes * minutes) /
              seconds
          );
          if (startYear == todayYear) {
            document.getElementById("year").innerHTML = todayYear;
            document.getElementById("sitetime").innerHTML =
              "本站已安全运行 " +
              diffDays +
              " 天 " +
              diffHours +
              " 小时 " +
              diffMinutes +
              " 分钟 " +
              diffSeconds +
              " 秒";
          } else {
            document.getElementById("year").innerHTML =
              startYear + " - " + todayYear;
            document.getElementById("sitetime").innerHTML =
              "本站已安全运行 " +
              diffYears +
              " 年 " +
              diffDays +
              " 天 " +
              diffHours +
              " 小时 " +
              diffMinutes +
              " 分钟 " +
              diffSeconds +
              " 秒";
          }
        }
        setInterval(siteTime, 1000);
      </script>
      
      <br />
      
    </div>
    <div class="col s12 m4 l4 social-link social-statis">
      
<a
  href="https://github.com/hermiablog/hermiablog.github.io"
  class="tooltipped"
  target="_blank"
  data-tooltip="访问我的GitHub"
  data-position="top"
  data-delay="50"
>
  <i class="fab fa-github"></i>
</a>
 
<a
  href="mailto:1587837237@qq.com"
  class="tooltipped"
  target="_blank"
  data-tooltip="邮件联系我"
  data-position="top"
  data-delay="50"
>
  <i class="fas fa-envelope-open"></i>
</a>
<!-- 
   
<a
  href="tencent://AddContact/?fromId=50&fromSubId=1&subcmd=all&uin=1587837237"
  class="tooltipped"
  target="_blank"
  data-tooltip="QQ联系我: 1587837237"
  data-position="top"
  data-delay="50"
>
  <i class="fab fa-qq"></i>
</a>
    -->

    </div>
  </div>
</footer>

<div class="progress-bar"></div>


    <!-- 搜索遮罩框 -->
<div id="searchModal" class="modal">
    <div class="modal-content">
        <div class="search-header">
            <span class="title"><i class="fas fa-search"></i>&nbsp;&nbsp;搜索</span>
            <input type="search" id="searchInput" name="s" placeholder="请输入搜索的关键字"
                   class="search-input">
        </div>
        <div id="searchResult"></div>
    </div>
</div>

<script type="text/javascript">
$(function () {
    var searchFunc = function (path, search_id, content_id) {
        'use strict';
        $.ajax({
            url: path,
            dataType: "xml",
            success: function (xmlResponse) {
                // get the contents from search data
                var datas = $("entry", xmlResponse).map(function () {
                    return {
                        title: $("title", this).text(),
                        content: $("content", this).text(),
                        url: $("url", this).text()
                    };
                }).get();
                var $input = document.getElementById(search_id);
                var $resultContent = document.getElementById(content_id);
                $input.addEventListener('input', function () {
                    var str = '<ul class=\"search-result-list\">';
                    var keywords = this.value.trim().toLowerCase().split(/[\s\-]+/);
                    $resultContent.innerHTML = "";
                    if (this.value.trim().length <= 0) {
                        return;
                    }
                    // perform local searching
                    datas.forEach(function (data) {
                        var isMatch = true;
                        var data_title = data.title.trim().toLowerCase();
                        var data_content = data.content.trim().replace(/<[^>]+>/g, "").toLowerCase();
                        var data_url = data.url;
                        data_url = data_url.indexOf('/') === 0 ? data.url : '/' + data_url;
                        var index_title = -1;
                        var index_content = -1;
                        var first_occur = -1;
                        // only match artiles with not empty titles and contents
                        if (data_title !== '' && data_content !== '') {
                            keywords.forEach(function (keyword, i) {
                                index_title = data_title.indexOf(keyword);
                                index_content = data_content.indexOf(keyword);
                                if (index_title < 0 && index_content < 0) {
                                    isMatch = false;
                                } else {
                                    if (index_content < 0) {
                                        index_content = 0;
                                    }
                                    if (i === 0) {
                                        first_occur = index_content;
                                    }
                                }
                            });
                        }
                        // show search results
                        if (isMatch) {
                            str += "<li><a href='" + data_url + "' class='search-result-title'>" + data_title + "</a>";
                            var content = data.content.trim().replace(/<[^>]+>/g, "");
                            if (first_occur >= 0) {
                                // cut out 100 characters
                                var start = first_occur - 20;
                                var end = first_occur + 80;
                                if (start < 0) {
                                    start = 0;
                                }
                                if (start === 0) {
                                    end = 100;
                                }
                                if (end > content.length) {
                                    end = content.length;
                                }
                                var match_content = content.substr(start, end);
                                // highlight all keywords
                                keywords.forEach(function (keyword) {
                                    var regS = new RegExp(keyword, "gi");
                                    match_content = match_content.replace(regS, "<em class=\"search-keyword\">" + keyword + "</em>");
                                });

                                str += "<p class=\"search-result\">" + match_content + "...</p>"
                            }
                            str += "</li>";
                        }
                    });
                    str += "</ul>";
                    $resultContent.innerHTML = str;
                });
            }
        });
    };

    searchFunc('/search.xml', 'searchInput', 'searchResult');
});
</script>

    <!-- 回到顶部按钮 -->
<div id="backTop" class="top-scroll">
    <a class="btn-floating btn-large waves-effect waves-light" href="#!">
        <i class="fas fa-arrow-up"></i>
    </a>
</div>


    <script src="/libs/materialize/materialize.min.js"></script>
    <script src="/libs/masonry/masonry.pkgd.min.js"></script>
    <script src="/libs/aos/aos.js"></script>
    <script src="/libs/scrollprogress/scrollProgress.min.js"></script>
    <script src="/libs/lightGallery/js/lightgallery-all.min.js"></script>
    <script src="/js/matery.js"></script>

    <!-- Baidu Analytics -->

    <!-- Baidu Push -->

<script>
    (function () {
        var bp = document.createElement('script');
        var curProtocol = window.location.protocol.split(':')[0];
        if (curProtocol === 'https') {
            bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';
        } else {
            bp.src = 'http://push.zhanzhang.baidu.com/push.js';
        }
        var s = document.getElementsByTagName("script")[0];
        s.parentNode.insertBefore(bp, s);
    })();
</script>

    
    <script src="/libs/others/clicklove.js" async="async"></script>
    
    
    <script async src="/libs/others/busuanzi.pure.mini.js"></script>
    

    

    

	
    

    

    

    
    <script src="/libs/instantpage/instantpage.js" type="module"></script>
    

</body>

</html>
