<!DOCTYPE HTML>
<html lang="zh-CN">


<head>
    <meta charset="utf-8">
    <meta name="keywords" content="TypeScript（五）, 技术博客">
    <meta name="description" content="个人技术博客">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <meta name="renderer" content="webkit|ie-stand|ie-comp">
    <meta name="mobile-web-app-capable" content="yes">
    <meta name="format-detection" content="telephone=no">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <!-- Global site tag (gtag.js) - Google Analytics -->


    <title>TypeScript（五） | hermia&#39;s blog</title>
    <link rel="icon" type="image/png" href="/favicon.png">

    <link rel="stylesheet" type="text/css" href="/libs/awesome/css/all.css">
    <link rel="stylesheet" type="text/css" href="/libs/materialize/materialize.min.css">
    <link rel="stylesheet" type="text/css" href="/libs/aos/aos.css">
    <link rel="stylesheet" type="text/css" href="/libs/animate/animate.min.css">
    <link rel="stylesheet" type="text/css" href="/libs/lightGallery/css/lightgallery.min.css">
    <link rel="stylesheet" type="text/css" href="/css/matery.css">
    <link rel="stylesheet" type="text/css" href="/css/my.css">

    <script src="/libs/jquery/jquery.min.js"></script>

<meta name="generator" content="Hexo 6.3.0"><link rel="stylesheet" href="/css/prism-tomorrow.css" type="text/css"></head>



   <style>
    body{
       background-image: url(https://cdn.pixabay.com/photo/2012/04/14/16/37/sky-34536_1280.png);
       background-repeat:no-repeat;
       background-size:cover;
       background-attachment:fixed;
    }
</style>



<body>
    <header class="navbar-fixed">
    <nav id="headNav" class="bg-color nav-transparent">
        <div id="navContainer" class="nav-wrapper container">
            <div class="brand-logo">
                <a href="/" class="waves-effect waves-light">
                    
                    <img src="/medias/logo.png" class="logo-img" alt="LOGO">
                    
                    <span class="logo-span">hermia&#39;s blog</span>
                </a>
            </div>
            

<a href="#" data-target="mobile-nav" class="sidenav-trigger button-collapse"><i class="fas fa-bars"></i></a>
<ul class="right nav-menu">
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/" class="waves-effect waves-light">
      
      <i class="fas fa-home" style="zoom: 0.6;"></i>
      
      <span>首页</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/tags" class="waves-effect waves-light">
      
      <i class="fas fa-tags" style="zoom: 0.6;"></i>
      
      <span>标签</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/categories" class="waves-effect waves-light">
      
      <i class="fas fa-bookmark" style="zoom: 0.6;"></i>
      
      <span>分类</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/archives" class="waves-effect waves-light">
      
      <i class="fas fa-archive" style="zoom: 0.6;"></i>
      
      <span>归档</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/about" class="waves-effect waves-light">
      
      <i class="fas fa-user-circle" style="zoom: 0.6;"></i>
      
      <span>关于</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/friends" class="waves-effect waves-light">
      
      <i class="fas fa-address-book" style="zoom: 0.6;"></i>
      
      <span>友情链接</span>
    </a>
    
  </li>
  
  <li>
    <a href="#searchModal" class="modal-trigger waves-effect waves-light">
      <i id="searchIcon" class="fas fa-search" title="搜索" style="zoom: 0.85;"></i>
    </a>
  </li>
</ul>


<div id="mobile-nav" class="side-nav sidenav">

    <div class="mobile-head bg-color">
        
        <img src="/medias/logo.png" class="logo-img circle responsive-img">
        
        <div class="logo-name">hermia&#39;s blog</div>
        <div class="logo-desc">
            
            个人技术博客
            
        </div>
    </div>

    

    <ul class="menu-list mobile-menu-list">
        
        <li class="m-nav-item">
	  
		<a href="/" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-home"></i>
			
			首页
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/tags" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-tags"></i>
			
			标签
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/categories" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-bookmark"></i>
			
			分类
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/archives" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-archive"></i>
			
			归档
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/about" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-user-circle"></i>
			
			关于
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/friends" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-address-book"></i>
			
			友情链接
		</a>
          
        </li>
        
        
    </ul>
</div>


        </div>

        
    </nav>

</header>

    



<div class="bg-cover pd-header post-cover" style="background-image: url('/medias/featureimages/55.jpg')">
    <div class="container" style="right: 0px;left: 0px;">
        <div class="row">
            <div class="col s12 m12 l12">
                <div class="brand">
                    <h1 class="description center-align post-title">TypeScript（五）</h1>
                </div>
            </div>
        </div>
    </div>
</div>




<main class="post-container content">

    
    <link
  rel="stylesheet"
  href="/libs/tocbot/tocbot.css"
/>
<style>
  #articleContent h1::before,
  #articleContent h2::before,
  #articleContent h3::before,
  #articleContent h4::before,
  #articleContent h5::before,
  #articleContent h6::before {
    display: block;
    content: " ";
    height: 100px;
    margin-top: -100px;
    visibility: hidden;
  }

  #articleContent :focus {
    outline: none;
  }

  .toc-fixed {
    position: fixed;
    top: 64px;
  }

  /* .toc-widget {
        width: 345px;
        padding-left: 20px;
    } */
  .toc-widget {
    width: 345px;
    padding-left: 20px;
    background-color: rgb(255, 255, 255, 0.7);
    border-radius: 10px;
    box-shadow: 0 10px 35px 2px rgba(0, 0, 0, 0.15),
      0 5px 15px rgba(0, 0, 0, 0.07), 0 2px 5px -5px rgba(0, 0, 0, 0.1) !important;
  }

  .toc-widget .toc-title {
    padding: 35px 0 15px 17px;
    font-size: 1.5rem;
    font-weight: bold;
    line-height: 1.5rem;
  }

  .toc-widget ol {
    padding: 0;
    list-style: none;
  }

  #toc-content {
    padding-bottom: 30px;
    overflow: auto;
  }

  #toc-content ol {
    padding-left: 10px;
  }

  #toc-content ol li {
    padding-left: 10px;
  }

  #toc-content .toc-link:hover {
    color: #a3ddf0;
    font-weight: 700;
    text-decoration: underline;
  }

  #toc-content .toc-link::before {
    background-color: transparent;
    max-height: 25px;

    position: absolute;
    right: 23.5vw;
    display: block;
  }

  #toc-content .is-active-link {
    color: #a3ddf0;
  }

  #floating-toc-btn {
    position: fixed;
    right: 15px;
    bottom: 76px;
    padding-top: 15px;
    margin-bottom: 0;
    z-index: 998;
  }

  #floating-toc-btn .btn-floating {
    width: 48px;
    height: 48px;
  }

  #floating-toc-btn .btn-floating i {
    line-height: 48px;
    font-size: 1.4rem;
  }
</style>
<div class="row">
  <div id="main-content" class="col s12 m12 l9">
    <!-- 文章内容详情 -->
<div id="artDetail">
    <div class="card">
        <div class="card-content article-info">
            <div class="row tag-cate">
                <div class="col s7">
                    
                    <div class="article-tag">
                        
                            <a href="/tags/TypesSript/">
                                <span class="chip bg-color">TypesSript</span>
                            </a>
                        
                    </div>
                    
                </div>
                <div class="col s5 right-align">
                    
                    <div class="post-cate">
                        <i class="fas fa-bookmark fa-fw icon-category"></i>
                        
                            <a href="/categories/%E6%8A%80%E6%9C%AF/" class="post-category">
                                技术
                            </a>
                        
                    </div>
                    
                </div>
            </div>

            <div class="post-info">
                
                <div class="post-date info-break-policy">
                    <i class="far fa-calendar-minus fa-fw"></i>发布日期:&nbsp;&nbsp;
                    2024-02-06
                </div>
                

                
                <div class="post-date info-break-policy">
                    <i class="far fa-calendar-check fa-fw"></i>更新日期:&nbsp;&nbsp;
                    2024-02-07
                </div>
                

                
                <div class="info-break-policy">
                    <i class="far fa-file-word fa-fw"></i>文章字数:&nbsp;&nbsp;
                    23.5k
                </div>
                

                

                
            </div>
        </div>
        <hr class="clearfix">

        

        

        <div class="card-content article-card-content">
            <div id="articleContent">
                <span id="more"></span>
<h3 id="泛型"><a href="#泛型" class="headerlink" title="泛型"></a>泛型</h3><blockquote>
<p>很多时候，我们希望一个函数 或 一个类可以支持多种数据类型 且 有很大的灵活性，就需要用到泛型。</p>
</blockquote>
<h4 id="泛型的概念"><a href="#泛型的概念" class="headerlink" title="泛型的概念"></a>泛型的概念</h4><blockquote>
<p>举例：声明一个打印函数</p>
</blockquote>
<pre><code>// 定义一个打印函数
function log(value: string): string &#123;
  console.log(value);
  return value;
&#125;
</code></pre>
<ul>
<li>以上是一个打印函数，它接收一个字符串，将该字符串打印出来，最终直接返回该字符串。</li>
</ul>
<blockquote>
<p>接下来，我们希望该函数接收一个字符串数组，应如何实现 ？</p>
</blockquote>
<ul>
<li>通过前面的学习，我们可能会想到使用 函数重载 的方式来实现</li>
</ul>
<pre><code>// 函数重载

// 定义接收字符串变量的函数
function log(value: string): string;
// 定义接收字符串数组的函数
function log(value: string[]): string[];
// 最后，在一个比较宽泛的版本中将其实现，参数类型为 any
function log(value: any) &#123;
  console.log(value);
  return value;
&#125;
</code></pre>
<ul>
<li>还可以使用其它类型，联合类型 来实现。它会比函数重载更简便一些</li>
</ul>
<pre><code>// 联合类型
function log(value: string | string[]): string | string[] &#123;
  console.log(value);
  return value;
&#125;
</code></pre>
<ul>
<li>现在需要更进一步，希望这个函数可以接收任何类型的参数，我们从前面的函数重载中已经得到了答案，即 使用 any 类型。</li>
</ul>
<pre><code>// any 类型
function log(value: any) &#123;
  console.log(value);
  return value;
&#125;
</code></pre>
<ul>
<li>此时，使用 any 类型的函数似乎已经满足了我们所有的需求。</li>
<li>但产生了另外一个问题，any 类型丢失了一些信息，即 类型之间的约束关系，它忽略了输入参数的类型 和 函数返回值的类型必须是一致的。</li>
<li>当一个调用者看到这个 log 函数时，他完全无法获知这种约束关系，这时就需要用到泛型了。</li>
</ul>
<h4 id="为什么使用泛型"><a href="#为什么使用泛型" class="headerlink" title="为什么使用泛型"></a>为什么使用泛型</h4><blockquote>
<p>有些时候，函数返回值的类型与参数类型是相关的。</p>
</blockquote>
<pre><code>function foo(arr) &#123;
  return arr[0];
&#125;
</code></pre>
<ul>
<li>函数 foo() 总是返回参数数组的第一个成员</li>
<li>参数数组是什么类型，返回值就是什么类型</li>
</ul>
<blockquote>
<p>以上这个函数的类型声明只能写成下面这样</p>
</blockquote>
<pre><code>function f(arr: any[]): any &#123;
  return arr[0];
&#125;
</code></pre>
<ul>
<li>以上的类型声明，就反映不出参数与返回值之间的类型关系</li>
</ul>
<blockquote>
<p>为了解决这个问题，TypeScript 就引入了“泛型”（generics）。泛型的特点就是带有“类型参数”（type parameter）。</p>
</blockquote>
<pre><code>function foo&lt;T&gt;(arr: T[]): T &#123;
  return arr[0];
&#125;
</code></pre>
<ul>
<li>函数<code>foo()</code>的函数名后面尖括号的部分<code>&lt;T&gt;</code>，就是类型参数，参数要放在一对尖括号（<code>&lt;&gt;</code>）里面</li>
<li>本例只有一个类型参数<code>T</code>，可以将其理解为类型声明需要的变量，需要在调用时传入具体的参数类型</li>
</ul>
<blockquote>
<p>以上的函数<code>foo()</code>的参数类型是<code>T[]</code>，返回值类型是T，就清楚地表示了两者之间的关系。</p>
<ul>
<li>比如，输入的参数类型是<code>number[]</code>，那么 T 的值就是<code>number</code>，因此返回值类型也是<code>number</code></li>
<li>函数调用时，需要提供类型参数。</li>
</ul>
</blockquote>
<pre><code>foo&lt;number&gt;([1, 2, 3]);
</code></pre>
<ul>
<li>调用函数<code>foo()</code>时，需要在函数名后面使用尖括号，给出类型参数T的值，本例是<code>&lt;number&gt;</code></li>
</ul>
<blockquote>
<p>不过为了方便，函数调用时，往往省略不写类型参数的值，让 TypeScript 自己推断。</p>
</blockquote>
<pre><code>foo([1, 2, 3]);
</code></pre>
<ul>
<li>TypeScript 会从实际参数 [1, 2, 3]，推断出类型参数 T 的值为 number</li>
</ul>
<ol>
<li>泛型的复杂场景<blockquote>
<p>有些复杂的使用场景，TypeScript 可能推断不出类型参数的值，这时就必须显式给出了。</p>
</blockquote>
</li>
</ol>
<pre><code>function foo&lt;T&gt;(arr1: T[], arr2: T[]): T[] &#123;
  return arr1.concat(arr2);
&#125;
</code></pre>
<ul>
<li>以上代码中，两个参数arr1、arr2和返回值都是同一个类型</li>
<li>如果不给出类型参数的值，下面的调用会报错。</li>
</ul>
<pre><code>function foo&lt;T&gt;(arr1: T[], arr2: T[]): T[] &#123;
  return arr1.concat(arr2);
&#125;

foo([1, 2], [&quot;a&quot;, &quot;b&quot;]); // 报错
</code></pre>
<blockquote>
<p>以上代码中会报错，TypeScript 认为两个参数不是同一个类型。但是，如果类型参数是一个联合类型，就不会报错。</p>
</blockquote>
<pre><code>function foo&lt;T&gt;(arr1: T[], arr2: T[]): T[] &#123;
  return arr1.concat(arr2);
&#125;

foo&lt;number | string&gt;([1, 2], [&quot;a&quot;, &quot;b&quot;]); // 正确
</code></pre>
<ul>
<li>类型参数是一个联合类型，使得两个参数都符合类型参数，就不报错了</li>
<li>这种情况下，类型参数是不能省略不写的</li>
</ul>
<blockquote>
<p>注：</p>
</blockquote>
<ul>
<li>类型参数的名字，可以随便取，但是必须为合法的标识符。习惯上，类型参数的第一个字符往往采用大写字母。一般会使用T（type 的第一个字母）作为类型参数的名字。</li>
<li>如果有多个类型参数，则使用 T 后面的 U、V 等字母命名，各个参数之间使用逗号（“,”）分隔。</li>
</ul>
<ol start="2">
<li>多个类型参数应用</li>
</ol>
<pre><code>function foo&lt;T, U&gt;(arr: T[], f: (arg: T) =&gt; U): U[] &#123;
  return arr.map(f);
&#125;

// 用法实例
foo&lt;string, number&gt;([&quot;1&quot;, &quot;2&quot;, &quot;3&quot;], (n) =&gt; parseInt(n)); // 返回 [1, 2, 3]
</code></pre>
<ul>
<li>将数组的实例方法 foo() 改写成全局函数，它有两个类型参数 T 和 U</li>
<li>含义是，原始数组的类型为 T[]，对该数组的每个成员执行一个处理函数 f，将类型 T 转成类型 U，那么就会得到一个类型为 U[] 的数组</li>
</ul>
<blockquote>
<p>总之，泛型可以理解成一段类型逻辑，需要类型参数来表达。有了类型参数以后，可以在输入类型与输出类型之间，建立一一对应关系。</p>
</blockquote>
<h4 id="泛型的写法"><a href="#泛型的写法" class="headerlink" title="泛型的写法"></a>泛型的写法</h4><blockquote>
<p>泛型主要用在四个场合：函数、接口、类和别名。</p>
</blockquote>
<ol>
<li>函数的泛型写法<blockquote>
<p>前面有提到，<code>function</code>关键字定义的泛型函数，类型参数放在尖括号中，写在函数名后面。</p>
</blockquote>
</li>
</ol>
<pre><code>function foo&lt;T&gt;(arg: T): T &#123;
  return arg;
&#125;
</code></pre>
<blockquote>
<p>对于变量形式定义的函数，泛型有下面两种写法</p>
</blockquote>
<pre><code>// 写法一
let bar1: &lt;T&gt;(arg: T) =&gt; T = foo;

// 写法二
let bar2: &#123; &lt;T&gt;(arg: T): T &#125; = foo;
</code></pre>
<ol start="2">
<li>接口的泛型写法<blockquote>
<p>interface 也可以采用泛型的写法</p>
</blockquote>
</li>
</ol>
<pre><code>interface Box&lt;Type&gt; &#123;
  contents: Type;
&#125;

let box: Box&lt;string&gt;;
</code></pre>
<ul>
<li>使用泛型接口时，需要给出类型参数的值（本例是string）</li>
</ul>
<blockquote>
<p>泛型接口方式一：先定义了一个泛型接口，然后将这个接口用于一个类</p>
</blockquote>
<pre><code>interface Count&lt;T&gt; &#123;
  countTo(value: T): number;
&#125;

class Nums implements Count&lt;Nums&gt; &#123;
  countTo(value: Nums): number &#123;
    // ...
    return 123;
  &#125;
&#125;
</code></pre>
<blockquote>
<p>泛型接口还有第二种写法</p>
</blockquote>
<pre><code>interface Fn &#123;
  &lt;Type&gt;(arg: Type): Type;
&#125;

function foo&lt;Type&gt;(arg: Type): Type &#123;
  return arg;
&#125;

let myFoo: Fn = foo;
</code></pre>
<ul>
<li>Fn 的类型参数 Type 的具体类型，需要函数 foo 在使用时提供</li>
<li>所以，最后一行的赋值语句不需要给出 Type 的具体类型</li>
</ul>
<blockquote>
<p>注：</p>
</blockquote>
<ul>
<li>此外，第二种写法还有一个差异之处。那就是它的类型参数定义在某个方法之中，其他属性和方法不能使用该类型参数。</li>
<li>前面的第一种写法，类型参数定义在整个接口，接口内部的所有属性和方法都可以使用该类型参数。</li>
</ul>
<ol start="3">
<li>类的泛型写法<blockquote>
<p>泛型类的类型参数写在类名后面</p>
</blockquote>
</li>
</ol>
<pre><code>class User&lt;K, V&gt; &#123;
  key: K;
  value: V;
&#125;
</code></pre>
<blockquote>
<p>继承泛型类</p>
</blockquote>
<pre><code>class User&lt;T&gt; &#123;
  value: T;
&#125;

class Allen extends User&lt;any&gt; &#123;&#125;
</code></pre>
<ul>
<li>类 User 有一个类型参数 T，使用时必须给出 T 的类型，所以类 Allen 继承时要写成 <code>User&lt;any&gt;</code></li>
</ul>
<blockquote>
<p>泛型也可以用在类表达式</p>
</blockquote>
<pre><code>const Container = class&lt;T&gt; &#123;
  constructor(private readonly data: T) &#123;&#125;
&#125;;

const a = new Container&lt;boolean&gt;(true);
const b = new Container&lt;number&gt;(0);
</code></pre>
<ul>
<li>新建实例时，需要同时给出类型参数 T 和 类参数 data 的值</li>
</ul>
<blockquote>
<p>实践应用</p>
</blockquote>
<pre><code>class Count&lt;NumType&gt; &#123;
  value!: NumType;
  add!: (x: NumType, y: NumType) =&gt; NumType;
&#125;

let foo = new Count&lt;number&gt;();

foo.value = 0;
foo.add = function (x, y) &#123;
  return x + y;
&#125;;
</code></pre>
<ul>
<li>先新建类 Count 的实例 foo，然后再定义实例的 value 属性和 add() 方法</li>
<li>类的定义中，属性和方法后面的感叹号是非空断言，告诉 TypeScript 它们都是非空的，后面会赋值。</li>
</ul>
<blockquote>
<p>JavaScript 的类本质上是一个构造函数，因此也可以把泛型类写成构造函数。</p>
</blockquote>
<pre><code>type MyClass&lt;T&gt; = new (...args: any[]) =&gt; T;

// 或者
interface MyClass&lt;T&gt; &#123;
  new (...args: any[]): T;
&#125;

// 用法实例
function createInstance&lt;T&gt;(AnyClass: MyClass&lt;T&gt;, ...args: any[]): T &#123;
  return new AnyClass(...args);
&#125;
</code></pre>
<ul>
<li>函数<code>createInstance()</code>的第一个参数 <code>AnyClass</code> 是构造函数（也可以是一个类），它的类型是 <code>MyClass&lt;T&gt;</code>，这里的 T 是<code>createInstance()</code>的类型参数，在该函数调用时再指定具体类型。</li>
</ul>
<blockquote>
<p>注：</p>
</blockquote>
<ul>
<li>泛型类描述的是类的实例，不包括静态属性和静态方法，因为这两者定义在类的本身。</li>
<li>因此，它们不能引用类型参数。</li>
</ul>
<pre><code>class Count&lt;T&gt; &#123;
  static data: T; // 报错
  constructor(public value: T) &#123;&#125;
&#125;
</code></pre>
<ul>
<li>静态属性 data 引用了类型参数 T，这是不可以的</li>
<li>因为类型参数只能用于实例属性和实例方法，所以报错了</li>
</ul>
<h4 id="类型别名的泛型写法"><a href="#类型别名的泛型写法" class="headerlink" title="类型别名的泛型写法"></a>类型别名的泛型写法</h4><blockquote>
<p>type 命令定义的类型别名，也可以使用泛型。</p>
</blockquote>
<pre><code>type Nullable&lt;T&gt; = T | undefined | null;
</code></pre>
<ul>
<li><code>Nullable&lt;T&gt;</code>是一个泛型，只要传入一个类型，就可以得到这个类型与 undefined 和 null 的一个联合类型</li>
</ul>
<blockquote>
<p>应用案例</p>
</blockquote>
<pre><code>type Container&lt;T&gt; = &#123; value: T &#125;;

const a: Container&lt;number&gt; = &#123; value: 0 &#125;;
const b: Container&lt;string&gt; = &#123; value: &quot;b&quot; &#125;;
</code></pre>
<ul>
<li>定义树形结构</li>
</ul>
<pre><code>type Tree&lt;T&gt; = &#123;
  value: T;
  left: Tree&lt;T&gt; | null;
  right: Tree&lt;T&gt; | null;
&#125;;
</code></pre>
<ul>
<li>类型别名 Tree 内部递归引用了 Tree 自身</li>
</ul>
<h4 id="类型参数的默认值"><a href="#类型参数的默认值" class="headerlink" title="类型参数的默认值"></a>类型参数的默认值</h4><blockquote>
<p>类型参数可以设置默认值。使用时，如果没有给出类型参数的值，就会使用默认值。</p>
</blockquote>
<pre><code>function getFirst&lt;T = string&gt;(arr: T[]): T &#123;
  return arr[0];
&#125;
</code></pre>
<ul>
<li><code>T = string</code> 表示类型参数的默认值是 string</li>
<li>调用 <code>getFirst()</code> 时，如果不给出T的值，TypeScript 就认为 T 等于 string</li>
</ul>
<blockquote>
<p>但是，因为 TypeScript 会从实际参数推断出T的值，从而覆盖掉默认值，所以下面的代码不会报错。</p>
</blockquote>
<pre><code>getFirst([1, 2, 3]); // 正确

// 实际参数是 [1, 2, 3]，TypeScript 推断 T 等于 number，从而覆盖掉默认值 string
</code></pre>
<blockquote>
<p>类型参数的默认值，往往用在类中。</p>
</blockquote>
<pre><code>class Count&lt;T = string&gt; &#123;
  list: T[] = [];

  add(t: T) &#123;
    this.list.push(t);
  &#125;
&#125;
</code></pre>
<ul>
<li>以上代码中，类Count有一个类型参数T，默认值为string。这意味着，属性list默认是一个字符串数组，方法add()的默认参数是一个字符串。</li>
</ul>
<pre><code>class Count&lt;T = string&gt; &#123;
  list: T[] = [];

  add(t: T) &#123;
    this.list.push(t);
  &#125;
&#125;

// 新建实例 c
const c = new Count();

c.add(4); // 报错
c.add(&quot;hello&quot;); // 正确
</code></pre>
<ul>
<li>以上代码中，新建 Count 的实例 c 时，没有给出类型参数 T 的值，所以 T 就等于 string。因此，向 add()方法传入一个数值会报错，传入字符串就不会。</li>
</ul>
<pre><code>class Count&lt;T = string&gt; &#123;
  list: T[] = [];

  add(t: T) &#123;
    this.list.push(t);
  &#125;
&#125;

const c = new Count&lt;number&gt;();

c.add(5); // 正确
c.add(&quot;icoding&quot;); // 报错

// 新建实例 c 时，给出了类型参数 T 的值是 number
// 因此 add() 方法传入数值不会报错，传入字符串会报错
</code></pre>
<blockquote>
<p>一旦类型参数有默认值，就表示它是可选参数。如果有多个类型参数，可选参数必须在必选参数之后。</p>
</blockquote>
<pre><code>&lt;T = boolean, U&gt; // 错误

&lt;T, U = boolean&gt; // 正确
</code></pre>
<ul>
<li>依次有两个类型参数 T 和 U</li>
<li>如果 T 是可选参数，U 不是，就会报错</li>
</ul>
<h4 id="数组的泛型表示"><a href="#数组的泛型表示" class="headerlink" title="数组的泛型表示"></a>数组的泛型表示</h4><blockquote>
<p>在学习数组的章节中，数组类型有一种表示方法是<code>Array&lt;T&gt;</code></p>
<ul>
<li>这就是泛型的写法，Array是 TypeScript 原生的一个类型接口，T是它的类型参数。声明数组时，需要提供T的值。</li>
</ul>
</blockquote>
<pre><code>let arr: Array&lt;number&gt; = [1, 2, 3];

// Array&lt;number&gt; 就是一个泛型，类型参数的值是 number，表示该数组的全部成员都是数值
</code></pre>
<ul>
<li>同样的，如果数组成员都是字符串，那么类型就写成<code>Array&lt;string&gt;</code></li>
</ul>
<blockquote>
<p>事实上，在 TypeScript 内部，数组类型的另一种写法<code>number[]</code>、<code>string[]</code>，只是<code>Array&lt;number&gt;</code>、<code>Array&lt;string</code>&gt;的简写形式。<br>在 TypeScript 内部，<code>Array</code>是一个泛型接口，类型定义基本是下面的样子。</p>
</blockquote>
<pre><code>interface Array&lt;Type&gt; &#123;
  length: number;

  pop(): Type | undefined;

  push(...items: Type[]): number;

  // ...
&#125;
</code></pre>
<ul>
<li><code>push()</code> 方法的参数 <code>item</code> 的类型是 <code>Type[]</code>，跟 <code>Array()</code> 的参数类型 <code>Type</code> 保持一致，表示只能添加同类型的成员</li>
<li>调用 <code>push()</code> 的时候，TypeScript 就会检查两者是否一致</li>
</ul>
<blockquote>
<p>其他的 TypeScript 内部数据结构，比如Map、Set和Promise，其实也是泛型接口，完整的写法是<code>Map&lt;K, V&gt;</code>、<code>Set&lt;T&gt;</code>和<code>Promise&lt;T&gt;</code>。<br>TypeScript 默认还提供一个<code>ReadonlyArray&lt;T&gt;</code>接口，表示只读数组。</p>
</blockquote>
<pre><code>function foo(values: ReadonlyArray&lt;string&gt;) &#123;
  values.push(&quot;icoding&quot;); // 报错
&#125;
</code></pre>
<ul>
<li>参数 values 的类型是 <code>ReadonlyArray&lt;string&gt;</code>，表示不能修改这个数组，所以函数体内部新增数组成员就会报错</li>
<li>因此，如果不希望函数内部改动参数数组，就可以将该参数数组声明为 <code>ReadonlyArray&lt;T&gt;</code> 类型</li>
</ul>
<h4 id="类型参数的约束条件"><a href="#类型参数的约束条件" class="headerlink" title="类型参数的约束条件"></a>类型参数的约束条件</h4><blockquote>
<p>很多类型参数并不是无限制的，对于传入的类型存在约束条件</p>
</blockquote>
<pre><code>function foo&lt;Type&gt;(a: Type, b: Type) &#123;
  if (a.length &gt;= b.length) &#123;
    return a;
  &#125;
  return b;
&#125;
</code></pre>
<ul>
<li>类型参数 Type 有一个隐藏的约束条件：它必须存在<code>length</code>属性</li>
<li>如果不满足这个条件，就会报错</li>
</ul>
<blockquote>
<p>TypeScript 提供了一种语法，允许在类型参数上面写明约束条件，如果不满足条件，编译时就会报错。这样也可以有良好的语义，对类型参数进行说明。</p>
</blockquote>
<pre><code>function foo&lt;T extends &#123; length: number &#125;&gt;(a: T, b: T) &#123;
  if (a.length &gt;= b.length) &#123;
    return a;
  &#125;
  return b;
&#125;
</code></pre>
<ul>
<li><code>T extends &#123; length: number &#125;</code>就是约束条件，表示类型参数 T 必须满足<code>&#123; length: number &#125;</code> ，否则就会报错</li>
</ul>
<pre><code>foo([1, 2], [1, 2, 3]); // 正确
foo(&quot;ibc&quot;, &quot;icoding&quot;); // 正确
foo(1, 2); // 报错

// 只要传入的参数类型不满足约束条件，就会报错
</code></pre>
<blockquote>
<p>类型参数的约束条件采用下面的形式。</p>
</blockquote>
<pre><code>&lt;TypeParameter extends ConstraintType&gt;

// TypeParameter 表示类型参数
// extends 是关键字，这是必须的
// ConstraintType 表示类型参数要满足的条件，即类型参数应该是 ConstraintType 的子类型
</code></pre>
<blockquote>
<p>类型参数可以同时设置约束条件和默认值，前提是默认值必须满足约束条件。</p>
</blockquote>
<pre><code>type Fn&lt;A extends string, B extends string = &quot;world&quot;&gt; = [A, B];

type Result = Fn&lt;&quot;hello&quot;&gt;; // [&quot;hello&quot;, &quot;world&quot;]
</code></pre>
<ul>
<li>类型参数 A 和 B 都有约束条件，并且 B 还有默认值</li>
<li>所以，调用 Fn 的时候，可以只给出 A 的值，不给出 B 的值</li>
</ul>
<blockquote>
<p>另外，上例也可以看出，泛型本质上是一个类型函数，通过输入参数，获得结果，两者是一一对应关系。<br>如果有多个类型参数，一个类型参数的约束条件，可以引用其他参数。</p>
</blockquote>
<pre><code>&lt;T, U extends T&gt;
// 或者
&lt;T extends U, U&gt;
</code></pre>
<ul>
<li>U 的约束条件引用 T，或者 T 的约束条件引用 U，都是正确的</li>
</ul>
<blockquote>
<p>但是，约束条件不能引用类型参数自身。</p>
</blockquote>
<pre><code>&lt;T extends T&gt;               // 报错
&lt;T extends U, U extends T&gt;  // 报错
</code></pre>
<ul>
<li>T 的约束条件不能是 T 自身</li>
<li>同理，多个类型参数也不能互相约束（即 T 的约束条件是 U、U 的约束条件是 T）</li>
<li>因为互相约束就意味着约束条件就是类型参数自身</li>
</ul>
<h4 id="泛型使用注意事项"><a href="#泛型使用注意事项" class="headerlink" title="泛型使用注意事项"></a>泛型使用注意事项</h4><blockquote>
<p>在实际开发中，泛型的使用过程中的注意事项，中共有 4 项。</p>
</blockquote>
<ol>
<li>尽量少用泛型<blockquote>
<p>泛型虽然灵活，但是会加大代码的复杂性，使其变得难读难写。</p>
</blockquote>
</li>
</ol>
<ul>
<li>一般来说，只要使用了泛型，类型声明通常都不太易读，容易写得很复杂。因此，可以不用泛型就不要用。</li>
</ul>
<ol start="2">
<li>类型参数越少越好<blockquote>
<p>多一个类型参数，多一道替换步骤，加大复杂性。因此，类型参数越少越好。</p>
</blockquote>
</li>
</ol>
<pre><code>function filter&lt;T, Fn extends (arg: T) =&gt; boolean&gt;(arr: T[], func: Fn): T[] &#123;
  return arr.filter(func);
&#125;
</code></pre>
<ul>
<li>以上代码中，有两个类型参数，但是第二个类型参数 Fn 是不必要的，完全可以直接写在函数参数的类型声明里面。</li>
</ul>
<pre><code>function filter&lt;T&gt;(arr: T[], func: (arg: T) =&gt; boolean): T[] &#123;
  return arr.filter(func);
&#125;

// 类型参数简化成了一个，效果与前一个示例是一样的
</code></pre>
<ol start="3">
<li>类型参数需要出现两次<blockquote>
<p>如果类型参数在定义后只出现一次，那么很可能是不必要的。</p>
</blockquote>
</li>
</ol>
<pre><code>function foo&lt;Str extends string&gt;(s: Str) &#123;
  console.log(&quot;Hello, &quot; + s);
&#125;
</code></pre>
<p>以上代码中，类型参数Str只在函数声明中出现一次（除了它的定义部分），这往往表明这个类型参数是不必要。</p>
<pre><code>function foo(s: string) &#123;
  console.log(&quot;Hello, &quot; + s);
&#125;
</code></pre>
<ul>
<li>把前面的类型参数省略了，效果与前一个示例是一样的</li>
<li>也就是说，只有当类型参数用到两次或两次以上，才是泛型的适用场合。</li>
</ul>
<ol start="4">
<li>泛型可以嵌套<blockquote>
<p>类型参数可以是另一个泛型</p>
</blockquote>
</li>
</ol>
<pre><code>type OrNull&lt;Type&gt; = Type | null;

type OneOrMany&lt;Type&gt; = Type | Type[];

type OneOrManyOrNull&lt;Type&gt; = OrNull&lt;OneOrMany&lt;Type&gt;&gt;;
</code></pre>
<ul>
<li>最后一行的泛型 <code>OrNull</code> 的类型参数，就是另一个泛型 <code>OneOrMany</code></li>
</ul>
<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><blockquote>
<p>泛型对前端开发来说，是一个比较新的概念，刚开始接触会有些难以理解。</p>
</blockquote>
<ul>
<li>我们可以换个角度思考就会变得简单：将泛型变量与函数参数等同对待，它只不过是另一个维度的参数，是代表类型而不是代表值的参数。</li>
<li>泛型在后边的高级类型中有广泛的应用，现阶段先作为基础了解即可。</li>
</ul>
<h4 id="泛型的好处"><a href="#泛型的好处" class="headerlink" title="泛型的好处"></a>泛型的好处</h4><ul>
<li>函数和类可以轻松地支持多种类型，增强程序的扩展性</li>
<li>不必写多条函数重载，也不必写冗长的联合类型声明，增强代码可读性</li>
<li>灵活控制类型之间的约束</li>
<li>有了泛型，类型就像穿上了变色龙的外衣，可以很友好的融入各种环境，这样代码的灵活性就大大增强了。</li>
</ul>
<blockquote>
<p>截止目前，TS 的基础知识就已经介绍完了，接下来我们就要开始学习 TS 的类型检查机制，高级类型，相关配置及应用等</p>
</blockquote>
<h3 id="类型断言"><a href="#类型断言" class="headerlink" title="类型断言"></a>类型断言</h3><blockquote>
<p>对于没有类型声明的值，TypeScript 会进行类型推断，很多时候得到的结果，未必是开发者想要的。</p>
</blockquote>
<pre><code>type T = &quot;a&quot; | &quot;b&quot; | &quot;c&quot;;
let foo = &quot;a&quot;;

let bar: T = foo; // 报错
</code></pre>
<ul>
<li>最后一行报错，原因是 TypeScript 推断变量 foo 的类型是 string，而变量 bar 的类型是 ‘a’|’b’|’c’，前者是后者的父类型</li>
<li>父类型不能赋值给子类型，所以就报错了</li>
</ul>
<blockquote>
<p>TypeScript 提供了“类型断言”这样一种手段，允许开发者在代码中“断言”某个值的类型，告诉编译器此处的值是什么类型。TypeScript 一旦发现存在类型断言，就不再对该值进行类型推断，而是直接采用断言给出的类型。</p>
</blockquote>
<ul>
<li>这种做法的实质是，允许开发者在某个位置“绕过”编译器的类型推断，让本来通不过类型检查的代码能够通过，避免编译器报错。这样虽然削弱了 TypeScript 类型系统的严格性，但是为开发者带来了方便，毕竟开发者比编译器更了解自己的代码。</li>
<li>以上代码，解决方法就是进行类型断言，在赋值时断言变量foo的类型。</li>
</ul>
<pre><code>type T = &quot;a&quot; | &quot;b&quot; | &quot;c&quot;;

let foo = &quot;a&quot;;
let bar: T = foo as T; // 正确
</code></pre>
<ul>
<li>最后一行的 <code>foo as T</code> 表示告诉编译器，变量 foo 的类型断言为 T</li>
<li>所以这一行不再需要类型推断了，编译器直接把 foo 的类型当作 T ，就不会报错了</li>
<li>总之，类型断言并不是真的改变一个值的类型，而是提示编译器，应该如何处理这个值。</li>
</ul>
<h4 id="类型断言的语法"><a href="#类型断言的语法" class="headerlink" title="类型断言的语法"></a>类型断言的语法</h4><blockquote>
<p>类型断言有两种语法</p>
</blockquote>
<pre><code>// 语法一：&lt;类型&gt;值
&lt;Type&gt;value;

// 语法二：值 as 类型
value as Type;
</code></pre>
<ul>
<li>以上两种语法是等价的，value 表示值，Type 表示类型</li>
</ul>
<blockquote>
<p>早期只有语法一，后来因为 TypeScript 开始支持 React 的 JSX 语法（尖括号表示 HTML 元素），为了避免两者冲突，就引入了语法二</p>
<ul>
<li>目前，推荐使用语法二</li>
</ul>
</blockquote>
<pre><code>// 语法一
let bar: T = &lt;T&gt;foo;

// 语法二
let bar: T = foo as T;
</code></pre>
<ul>
<li>以上代码是两种类型断言的语法，其中的语法一因为跟 JSX 语法冲突，使用时必须关闭 TypeScript 的 React 支持，否则会无法识别</li>
<li>由于这个原因，现在一般都使用语法二</li>
</ul>
<blockquote>
<p>对象类型有严格字面量检查，如果存在额外的属性会报错。</p>
</blockquote>
<pre><code>// 报错
const p: &#123; x: number &#125; = &#123; x: 0, y: 0 &#125;;
</code></pre>
<ul>
<li>以上代码中，等号右侧是一个对象字面量，多出了属性y，导致报错。<blockquote>
<p>解决方法就是使用类型断言，可以用两种不同的断言</p>
</blockquote>
</li>
</ul>
<pre><code>// 正确
const p1: &#123; x: number &#125; = &#123; x: 0, y: 0 &#125; as &#123; x: number &#125;;

// 正确
const p2: &#123; x: number &#125; = &#123; x: 0, y: 0 &#125; as &#123; x: number; y: number &#125;;
</code></pre>
<ul>
<li>两种类型断言都是正确的</li>
<li>第一种断言将类型改成与等号左边一致</li>
<li>第二种断言使得等号右边的类型是左边类型的子类型，子类型可以赋值给父类型，同时因为存在类型断言，就没有严格字面量检查了，所以不报错</li>
</ul>
<blockquote>
<p>在网页中的具体实践</p>
</blockquote>
<pre><code>const username = document.getElementById(&quot;username&quot;);

if (username) &#123;
  (username as HTMLInputElement).value; // 正确
&#125;
</code></pre>
<ul>
<li>变量<code>username</code>的类型是<code>HTMLElement | null</code>，排除了null的情况以后，HTMLElement 类型是没有value属性的</li>
<li>如果<code>username</code>是一个输入框，那么就可以通过类型断言，将它的类型改成 HTMLInputElement，就可以读取 value 属性。</li>
</ul>
<blockquote>
<p>注：以上代码中的类型断言的圆括号是必需的，否则<code>username</code>会被断言成<code>HTMLInputElement.value</code>，从而报错。</p>
</blockquote>
<ol>
<li>类型断言 - 注意事项<blockquote>
<p>类型断言不应滥用，因为它改变了 TypeScript 的类型检查，很可能埋下错误的隐患。</p>
</blockquote>
</li>
</ol>
<pre><code>const data: object = &#123;
  a: 1,
  b: 2,
  c: 3,
&#125;;

data.length; // 报错

(data as Array&lt;string&gt;).length; // 正确
</code></pre>
<ul>
<li>变量 data 是一个对象，没有 length 属性</li>
<li>但是通过类型断言，可以将它的类型断言为数组，这样使用length属性就能通过类型检查</li>
<li>但是，编译后的代码在运行时依然会报错，所以类型断言可以让错误的代码通过编译</li>
</ul>
<ol start="2">
<li>类型断言的作用<blockquote>
<p>类型断言的一大用处是，指定 <code>unknown</code> 类型的变量的具体类型。</p>
</blockquote>
</li>
</ol>
<pre><code>const value: unknown = &quot;Hello World&quot;;

const s1: string = value; // 报错
const s2: string = value as string; // 正确
</code></pre>
<ul>
<li>unknown 类型的变量 value 不能直接赋值给其他类型的变量，但是可以将它断言为其他类型，这样就可以赋值给别的变量了</li>
</ul>
<blockquote>
<p>另外，类型断言也适合指定联合类型的值的具体类型。</p>
</blockquote>
<pre><code>const s1: number | string = &quot;hello&quot;;
const s2: number = s1 as number;
</code></pre>
<ul>
<li>变量 s1 是联合类型，可以断言其为联合类型里面的一种具体类型，再将其赋值给变量 s2</li>
</ul>
<h4 id="类型断言的条件"><a href="#类型断言的条件" class="headerlink" title="类型断言的条件"></a>类型断言的条件</h4><blockquote>
<p>类型断言并不意味着，可以把某个值断言为任意类型。</p>
</blockquote>
<pre><code>const n = 1;
const m: string = n as string; // 报错

// 变量 n 是数值，无法把它断言成字符串，TypeScript 会报错
</code></pre>
<blockquote>
<p>类型断言的使用前提是，值的实际类型与断言的类型必须满足一个条件。</p>
</blockquote>
<pre><code>expr as T;
</code></pre>
<ul>
<li>expr 是实际的值，T 是类型断言，它们必须满足：expr 是 T 的子类型，或者 T 是 expr 的子类型</li>
</ul>
<blockquote>
<p>也就是说，类型断言要求实际的类型与断言的类型兼容，实际类型可以断言为一个更加宽泛的类型（父类型），也可以断言为一个更加精确的类型（子类型），但不能断言为一个完全无关的类型。</p>
</blockquote>
<blockquote>
<p>但是，如果真的要断言成一个完全无关的类型，也是可以做到的。那就是<strong>连续进行两次类型断言</strong></p>
<ul>
<li>先断言成 <code>unknown</code> 类型或 <code>any</code> 类型</li>
<li>然后再断言为目标类型。因为<code>any</code>类型和<code>unknown</code>类型是所有其他类型的父类型，所以可以作为两种完全无关的类型的中介。</li>
</ul>
</blockquote>
<pre><code>// 或者写成 &lt;T&gt;&lt;unknown&gt;expr
expr as unknown as T;

// expr 连续进行了两次类型断言
// 第一次断言为 unknown 类型
// 第二次断言为 T 类型
// 这样的话，expr 就可以断言成任意类型 T，而不报错
</code></pre>
<ul>
<li>改写前面的案例</li>
</ul>
<pre><code>const n = 1;
const m: string = n as unknown as string; // 正确
</code></pre>
<ul>
<li>通过两次类型断言，变量 n 的类型就从数值，变成了完全无关的字符串，从而赋值时不会报错</li>
</ul>
<h4 id="as-const-断言"><a href="#as-const-断言" class="headerlink" title="as const 断言"></a>as const 断言</h4><blockquote>
<p>如果没有声明变量类型，<code>let</code> 命令声明的变量，会被类型推断为 TypeScript 内置的基本类型之一。<code>const</code>命令声明的变量，则被推断为值类型常量。</p>
</blockquote>
<pre><code>// 类型推断为基本类型 string
let s1 = &quot;JavaScript&quot;;

// 类型推断为字符串 “JavaScript”
const s2 = &quot;JavaScript&quot;;
</code></pre>
<ul>
<li>变量 s1 的类型被推断为 string</li>
<li>变量 s2 的类型推断为值类型 JavaScript。后者是前者的子类型，相当于 const 命令有更强的限定作用，可以缩小变量的类型范围。</li>
</ul>
<blockquote>
<p>有些时候，let 变量会出现一些意想不到的报错，变更成 const 变量就能消除报错。</p>
</blockquote>
<pre><code>let s = &quot;JavaScript&quot;;

type Lang = &quot;JavaScript&quot; | &quot;TypeScript&quot; | &quot;Python&quot;;

function setLang(language: Lang) &#123;
  //
&#125;

setLang(s); // 报错
</code></pre>
<ul>
<li>最后一行报错，原因是函数 setLang() 的参数 language 类型是 Lang，这是一个联合类型</li>
<li>但是，传入的字符串 s 的类型被推断为 string，属于 Lang 的父类型</li>
<li>父类型不能替代子类型，导致报错。</li>
</ul>
<blockquote>
<p>一种解决方法就是把 let 命令改成 const 命令</p>
</blockquote>
<pre><code>// let s = &quot;JavaScript&quot;;

// 将 let 命令改成 const 命令
const s = &quot;JavaScript&quot;;

type Lang = &quot;JavaScript&quot; | &quot;TypeScript&quot; | &quot;Python&quot;;

function setLang(language: Lang) &#123;
  //
&#125;

setLang(s); // 正确
</code></pre>
<ul>
<li>变量 s 的类型就是值类型 JavaScript，它是联合类型 Lang 的子类型，传入函数 <code>setLang()</code> 就不会报错</li>
</ul>
<blockquote>
<p>另一种解决方法是使用类型断言。TypeScript 提供了一种特殊的类型断言<code>as const</code>，用于告诉编译器，推断类型时，可以将这个值推断为常量，即把 let 变量断言为 const 变量，从而把内置的基本类型变更为值类型。</p>
</blockquote>
<pre><code>let s = &quot;JavaScript&quot; as const;
setLang(s); // 正确
</code></pre>
<ul>
<li>变量 s 虽然是用 let 命令声明的，但是使用了 as const 断言以后，就等同于是用  const 命令声明的，变量 s 的类型会被推断为值类型 JavaScript。</li>
</ul>
<blockquote>
<p>使用了<code>as const</code>断言以后，let 变量就不能再改变值了</p>
</blockquote>
<pre><code>let s = &quot;JavaScript&quot; as const;
s = &quot;Python&quot;; // 报错

// let 命令声明的变量 s，使用 as const 断言以后，就不能改变值了，否则报错。
</code></pre>
<ol>
<li>as const 断言 - 注意事项<blockquote>
<p>注意，<code>as const</code>断言只能用于字面量，不能用于变量。</p>
</blockquote>
</li>
</ol>
<pre><code>// 定义变量 s
let s = &quot;JavaScript&quot;;

type Lang = &quot;JavaScript&quot; | &quot;TypeScript&quot; | &quot;Python&quot;;

function setLang(language: Lang) &#123;
  //
&#125;

// 调用函数
setLang(s as const); // 报错
</code></pre>
<ul>
<li>以上代码中，as const断言用于变量s，就报错了。下面的写法可以更清晰地看出这一点</li>
</ul>
<pre><code>let s1 = &quot;JavaScript&quot;;
let s2 = s1 as const; // 报错
</code></pre>
<blockquote>
<p>另外，<code>as const</code>也不能用于表达式。</p>
</blockquote>
<pre><code>let s = (&quot;Java&quot; + &quot;Script&quot;) as const; // 报错

// 以上代码中，as const 用于表达式，导致报错
</code></pre>
<blockquote>
<p>as const也可以写成前置的形式。</p>
</blockquote>
<pre><code>// 后置形式
expr as const

// 前置形式
&lt;const&gt;expr
</code></pre>
<blockquote>
<p>as const断言可以用于整个对象，也可以用于对象的单个属性，这时它的类型缩小效果是不一样的。</p>
</blockquote>
<pre><code>const v1 = &#123;
  x: 1,
  y: 2,
&#125;; // 类型是 &#123; x: number; y: number; &#125;

const v2 = &#123;
  x: 1 as const,
  y: 2,
&#125;; // 类型是 &#123; x: 1; y: number; &#125;

const v3 = &#123;
  x: 1,
  y: 2,
&#125; as const; // 类型是 &#123; readonly x: 1; readonly y: 2; &#125;
</code></pre>
<ul>
<li>第二种写法是对属性 x 缩小类型，第三种写法是对整个对象缩小类型</li>
<li>总之，as const会将字面量的类型断言为不可变类型，缩小成 TypeScript 允许的最小类型。</li>
</ul>
<ol start="2">
<li>数组字面量使用断言</li>
</ol>
<pre><code>// a1 的类型推断为 number[]
const a1 = [1, 2, 3];

// a2 的类型推断为 readonly [1, 2, 3]
const a2 = [1, 2, 3] as const;
</code></pre>
<ul>
<li>数组字面量使用 as const 断言后，类型推断就变成了只读元组</li>
</ul>
<blockquote>
<p>由于as const会将数组变成只读元组，所以很适合用于函数的 rest 参数。</p>
</blockquote>
<pre><code>function add(x: number, y: number) &#123;
  return x + y;
&#125;

const nums = [1, 2];
const total = add(...nums); // 报错
</code></pre>
<ul>
<li>变量 nums 的类型推断为 number[]，导致使用扩展运算符 … 传入函数 add() 会报错，因为 add() 只能接受两个参数，而 …nums 并不能保证参数的个数</li>
</ul>
<blockquote>
<p>事实上，对于固定参数个数的函数，如果传入的参数包含扩展运算符，那么扩展运算符只能用于元组。只有当函数定义使用了 rest 参数，扩展运算符才能用于数组。</p>
<ul>
<li>解决方法就是使用as const断言，将数组变成元组。</li>
</ul>
</blockquote>
<pre><code>const nums = [1, 2] as const;
const total = add(...nums); // 正确
</code></pre>
<ul>
<li>使用 as const 断言后，变量 nums 的类型会被推断为 readonly [1, 2]，使用扩展运算符展开后，正好符合函数 add() 的参数类型</li>
</ul>
<blockquote>
<p>Enum 成员也可以使用as const断言</p>
</blockquote>
<pre><code>enum Foo &#123;
  X,
  Y,
&#125;
let e1 = Foo.X; // Foo
let e2 = Foo.X as const; // Foo.X
</code></pre>
<ul>
<li>如果不使用 as const 断言，变量 e1 的类型被推断为整个 Enum 类型；</li>
<li>使用了 as const 断言以后，变量 e2 的类型被推断为 Enum 的某个成员，这意味着它不能变更为其他成员</li>
</ul>
<h4 id="非空断言"><a href="#非空断言" class="headerlink" title="非空断言"></a>非空断言</h4><blockquote>
<p>对于那些可能为空的变量（即可能等于<code>undefined</code>或<code>null</code>），TypeScript 提供了非空断言，保证这些变量不会为空，写法是在变量名后面加上感叹号<code>!</code></p>
</blockquote>
<pre><code>function f(x?: number | null) &#123;
  validateNumber(x); // 自定义函数，确保 x 是数值
  console.log(x!.toFixed());
&#125;

function validateNumber(e?: number | null) &#123;
  if (typeof e !== &quot;number&quot;) throw new Error(&quot;Not a number&quot;);
&#125;
</code></pre>
<ul>
<li>函数 f() 的参数 x 的类型是<code>number|null</code>，即可能为空</li>
<li>如果为空，就不存在 <code>x.toFixed()</code> 方法，这样写会报错</li>
<li>但是，开发者可以确认，经过 <code>validateNumber()</code> 的前置检验，变量 x 肯定不会为空，这时就可以使用非空断言，为函数体内部的变量 x 加上后缀!，<code>x!.toFixed()</code> 编译就不会报错了</li>
</ul>
<blockquote>
<p>非空断言在实际编程中很有用，有时可以省去一些额外的判断。</p>
</blockquote>
<pre><code>const root = document.getElementById(&quot;root&quot;);

// 报错
root.addEventListener(&quot;click&quot;, (e) =&gt; &#123;
  /* ... */
&#125;);
</code></pre>
<ul>
<li>以上代码中，<code>getElementById()</code>有可能返回空值<code>null</code>，即变量<code>root</code>可能为空，这时对它调用<code>addEventListener()</code>方法就会报错，通不过编译。</li>
<li>但是，开发者如果可以确认<code>root</code>元素肯定会在网页中存在，这时就可以使用非空断言。</li>
</ul>
<pre><code>const root = document.getElementById(&quot;root&quot;)!;
</code></pre>
<ul>
<li>getElementById() 方法加上后缀!，表示这个方法肯定返回非空结果</li>
</ul>
<blockquote>
<p>不过，非空断言会造成安全隐患，只有在确定一个表达式的值不为空时才能使用。比较保险的做法还是手动检查一下是否为空。</p>
</blockquote>
<pre><code>const root = document.getElementById(&quot;root&quot;);

if (root === null) &#123;
  throw new Error(&quot;找不到DOM元素 #root&quot;);
&#125;

root.addEventListener(&quot;click&quot;, (e) =&gt; &#123;
  /* ... */
&#125;);
</code></pre>
<ul>
<li>如果 root 为空会抛错，比非空断言更保险一点</li>
</ul>
<blockquote>
<p>非空断言还可以用于赋值断言。TypeScript 有一个编译设置，要求类的属性必须初始化（即有初始值），如果不对属性赋值就会报错。</p>
</blockquote>
<pre><code>class Point &#123;
  x: number; // 报错
  y: number; // 报错

  constructor(x: number, y: number) &#123;
    // ...
  &#125;
&#125;
</code></pre>
<ul>
<li>属性 x 和 y 会报错，因为 TypeScript 认为它们没有初始化</li>
<li>这时就可以使用非空断言，表示这两个属性肯定会有值，这样就不会报错了。</li>
</ul>
<pre><code>class Point &#123;
  x!: number; // 正确
  y!: number; // 正确

  constructor(x: number, y: number) &#123;
    // ...
  &#125;
&#125;
</code></pre>
<blockquote>
<p>非空断言只有在打开编译选项<code>strictNullChecks</code>时才有意义。如果不打开这个选项，编译器就不会检查某个变量是否可能为<code>undefined</code>或<code>null</code>。</p>
</blockquote>
<h4 id="断言函数"><a href="#断言函数" class="headerlink" title="断言函数"></a>断言函数</h4><blockquote>
<p>断言函数是一种特殊函数，用于保证函数参数符合某种类型。如果函数参数达不到要求，就会抛出错误，中断程序执行；如果达到要求，就不进行任何操作，让代码按照正常流程运行。</p>
</blockquote>
<pre><code>function isString(value: unknown): void &#123;
  if (typeof value !== &quot;string&quot;) throw new Error(&quot;不是字符串&quot;);
&#125;
</code></pre>
<ul>
<li>函数<code>isString()</code>就是一个断言函数，用来保证参数<code>value</code>是一个字符串，否则就会抛出错误，中断程序的执行</li>
</ul>
<ol>
<li>断言函数的用法</li>
</ol>
<pre><code>function toUpper(x: string | number) &#123;
  isString(x);
  return x.toUpperCase();
&#125;
</code></pre>
<ul>
<li>函数<code>toUpper()</code>的参数 x，可能是字符串，也可能是数值。</li>
<li>但是，函数体的最后一行调用<code>toUpperCase()</code>方法，必须保证 x 是字符串，否则报错。</li>
<li>所以，这一行前面调用断言函数 isString()，调用以后 TypeScript 就能确定，变量 x 一定是字符串，不是数值，也就不报错了。</li>
</ul>
<blockquote>
<p>传统的断言函数<code>isString()</code>的写法有一个缺点，它的参数类型是<code>unknown</code>，返回值类型是<code>void</code>（即没有返回值）。单单从这样的类型声明，很难看出<code>isString()</code>是一个断言函数。</p>
<ul>
<li>为了更清晰地表达断言函数，TypeScript 3.7 引入了新的类型写法。</li>
</ul>
</blockquote>
<pre><code>function isString(value: unknown): asserts value is string &#123;
  if (typeof value !== &quot;string&quot;) throw new Error(&quot;不是字符串类型 ！&quot;);
&#125;
</code></pre>
<ul>
<li>函数<code>isString()</code>的返回值类型写成 <code>asserts value is string</code>，其中 <code>asserts</code> 和 <code>is</code> 都是关键词，<code>value</code> 是函数的参数名，<code>string</code> 是函数参数的预期类型</li>
<li>它的意思是，该函数用来断言参数 value 的类型是 string，如果达不到要求，程序就会在这里中断</li>
</ul>
<blockquote>
<p>注：</p>
</blockquote>
<ul>
<li>使用了断言函数的新写法以后，TypeScript 就会自动识别，只要执行了该函数，对应的变量都为断言的类型。</li>
</ul>
<ol start="2">
<li>断言函数 - 注意事项<blockquote>
<p>函数返回值的断言写法，只是用来更清晰地表达函数意图，真正的检查是需要开发者自己部署的。</p>
<ul>
<li>而且，如果内部的检查与断言不一致，TypeScript 也不会报错。</li>
</ul>
</blockquote>
</li>
</ol>
<pre><code>function isString(value: unknown): asserts value is string &#123;
  if (typeof value !== &quot;number&quot;) throw new Error(&quot;不是数字类型 !&quot;);
&#125;
</code></pre>
<ul>
<li>函数的断言是参数 value 类型为字符串，但是实际上，内部检查的却是它是否为数值，如果不是就抛错</li>
<li>这段代码能够正常通过编译，表示 TypeScript 并不会检查断言与实际的类型检查是否一致</li>
</ul>
<blockquote>
<p>另外，断言函数的<code>asserts</code>语句等同于<code>void</code>类型，所以如果返回除了<code>undefined</code>和<code>null</code>以外的值，都会报错。</p>
</blockquote>
<pre><code>function isString(value: unknown): asserts value is string &#123;
  if (typeof value !== &quot;string&quot;) throw new Error(&quot;不是字符串类型 ！&quot;);
  return true; // 报错
&#125;
</code></pre>
<ul>
<li>断言函数返回了true，导致报错</li>
</ul>
<ol start="3">
<li>断言函数的实践应用</li>
</ol>
<pre><code>// 访问级别
type AccessLevel = &quot;r&quot; | &quot;w&quot; | &quot;rw&quot;;

// 定义 允许读取访问权限函数
function allowsReadAccess(level: AccessLevel): asserts level is &quot;r&quot; | &quot;rw&quot; &#123;
  if (!level.includes(&quot;r&quot;)) throw new Error(&quot;不允许读取 !&quot;);
&#125;
</code></pre>
<ul>
<li>函数<code>allowsReadAccess()</code>用来断言参数 <code>level</code> 一定等于 r 或 rw</li>
</ul>
<blockquote>
<p>如果要断言参数非空，可以使用工具类型<code>NonNullable&lt;T&gt;</code></p>
</blockquote>
<pre><code>function foo&lt;T&gt;(value: T): asserts value is NonNullable&lt;T&gt; &#123;
  if (value === undefined || value === null) &#123;
    throw new Error(`$&#123;value&#125; is not defined`);
  &#125;
&#125;
</code></pre>
<ul>
<li>工具类型 <code>NonNullable&lt;T&gt;</code> 对应类型 <code>T</code> 去除空类型后的剩余类型</li>
</ul>
<blockquote>
<p>如果要将断言函数用于函数表达式，可以采用下面的写法。</p>
</blockquote>
<pre><code>// 写法一
const assertIsNumber = (value: unknown): asserts value is number =&gt; &#123;
  if (typeof value !== &quot;number&quot;) throw Error(&quot;不是 number 类型&quot;);
&#125;;

// 写法二
type AssertIsNumber = (value: unknown) =&gt; asserts value is number;

const assertIsNumber: AssertIsNumber = (value) =&gt; &#123;
  if (typeof value !== &quot;number&quot;) throw Error(&quot;不是 number 类型&quot;);
&#125;;
</code></pre>
<blockquote>
<p>注意，断言函数与类型保护函数（type guard）是两种不同的函数。它们的区别是，断言函数不返回值，而类型保护函数总是返回一个布尔值。</p>
</blockquote>
<pre><code>function isString(value: unknown): value is string &#123;
  return typeof value === &quot;string&quot;;
&#125;
</code></pre>
<ul>
<li>以上就是一个类型保护函数 <code>isString()</code></li>
<li>作用是检查参数 value 是否为字符串。如果是的，返回 true，否则返回 false。</li>
<li>该函数的返回值类型是 <code>value is string</code>，其中的 is 是一个类型运算符，如果左侧的值符合右侧的类型，则返回 true，否则返回 false</li>
</ul>
<blockquote>
<p>如果要断言某个参数保证为真（即不等于false、undefined和null），TypeScript 提供了断言函数的一种简写形式。</p>
</blockquote>
<pre><code>function assert(x: unknown): asserts x &#123;
  // ...
&#125;
</code></pre>
<ul>
<li>函数 assert() 的断言部分，<code>asserts x</code> 省略了谓语和宾语，表示参数 x 保证为真（true）</li>
</ul>
<blockquote>
<p>同样的，参数为真的实际检查需要开发者自己实现。</p>
</blockquote>
<pre><code>function assert(x: unknown): asserts x &#123;
  if (!x) &#123;
    throw new Error(`$&#123;x&#125; 应该是一个真实的值.`);
  &#125;
&#125;
</code></pre>
<blockquote>
<p>这种断言函数的简写形式，通常用来检查某个操作是否成功。</p>
</blockquote>
<pre><code>type Person = &#123;
  username: string;
  email?: string;
&#125;;

function loadPerson(): Person | null &#123;
  return null;
&#125;

let person = loadPerson();

// 定义一个断言函数
function assert(state: unknown, message: string): asserts state &#123;
  if (!state) throw new Error(message);
&#125;

// Error: Person is not defined
assert(person, &quot;Person is not defined&quot;);
console.log(person.username);

// 只有 loadPerson() 返回结果为真（即操作成功），assert() 才不会报错。
</code></pre>
<h2 id="TS-的类型检查机制"><a href="#TS-的类型检查机制" class="headerlink" title="TS 的类型检查机制"></a>TS 的类型检查机制</h2><blockquote>
<p>TypeScript 编译器在做类型检查时，所秉承的一些原则，以及表现出的一些行为。即：TS 的类型检查机制<br>作用： 辅助开发，提高开发效率</p>
<ul>
<li>从以下几个方面来学习</li>
</ul>
</blockquote>
<ul>
<li>类型推断</li>
<li>类型兼容性</li>
<li>类型保护</li>
</ul>
<h3 id="一、类型推断"><a href="#一、类型推断" class="headerlink" title="一、类型推断"></a>一、类型推断</h3><ul>
<li>TS的类型推断并不是万能的,有时候会出现与预期不符的情况</li>
<li>这时,TS提供了覆盖TS的推断的方法,就是类型断言</li>
</ul>
<h4 id="类型推断"><a href="#类型推断" class="headerlink" title="类型推断"></a>类型推断</h4><blockquote>
<p>不需要指定变量的类型（函数的返回值类型），TypeScript 可以根据某些规则自动地为其推断出一个类型。</p>
</blockquote>
<ul>
<li>基础类型推断</li>
<li>最佳通用类型推断</li>
<li>上下文类型推断</li>
</ul>
<ol>
<li>基础类型推断<blockquote>
<p>基础类型推断也是 TS 中比较常见的类型推断，通常发生在以下场景中</p>
</blockquote>
</li>
</ol>
<ul>
<li>初始化变量时</li>
<li>设置函数默认参数时</li>
<li>在确定函数返回值时</li>
</ul>
<blockquote>
<p>初始化变量时</p>
</blockquote>
<pre><code>// 初始化变量时，声明一个变量 a
// 如果不指定它的变量类型，TS 会自动推断为 any 类型
let a;

// 如果给变量 a 赋值为 1，就会推断为 number 类型
let a = 1;

// 给变量 b 赋值为 空数组，b 就会被推断为以 any 类型为元素的 数组类型
let b = [];

// 给 b 赋值为 [1, 2]，就会被推断为 number 类型的数组
let b = [1, 2];
</code></pre>
<blockquote>
<p>设置函数默认参数时</p>
</blockquote>
<pre><code>// 定义一个函数 c ，为它指定一个默认的参数 x，值为 1，x 被推断为 number 类型
let c = (x = 1) =&gt; &#123;&#125;;
</code></pre>
<blockquote>
<p>在确定函数返回值时</p>
</blockquote>
<pre><code>// 将该函数返回 x + 1 ，c 的返回值类型就会被 推断为 number 类型
let c = (x = 1) =&gt; x + 1;
</code></pre>
<ol start="2">
<li>最佳通用类型推断<blockquote>
<p>当需要从多个类型中推断出一个类型时，TS就会尽可能的推断出一个兼容当前所有类型的通用类型，这个就是最佳通用类型推断</p>
</blockquote>
</li>
</ol>
<pre><code>// 给数组增加一个 null，null 和 number 类型是不兼容的
// 因此，d 就会被推断为 null 和 number 的联合类型
let d = [1, null];
</code></pre>
<ul>
<li>如果在 <code>tsconfig.json </code>配置文件中关闭 <code>&quot;strictNullChecks&quot;: false</code></li>
</ul>
<pre><code>&#123;
  &quot;compilerOptions&quot;: &#123;
    &quot;strictNullChecks&quot;: false
  &#125;
&#125;
</code></pre>
<ul>
<li>此时，以上 null 和 number 就兼容了，d 就会被推断为 number 类型的数组</li>
</ul>
<pre><code>// 修改完配置文件后，d 就会被推断为 number 类型的数组
let d = [1, null];
</code></pre>
<ul>
<li>以上的类型推断都是从右向左的推断，也就是根据表达式右侧的值来推断表达式左侧的变量的类型</li>
</ul>
<ol start="3">
<li>上下文类型推断<blockquote>
<p>上下文类型的推断是从左到右的，它通常会发生在一个事件处理中</p>
</blockquote>
</li>
</ol>
<pre><code>// 给 window 绑定一个 onkeydown 事件，这时就会发生上下文的类型推断
window.onkeydown = (event) =&gt; &#123;
  // 打印输出 event 键盘事件有哪些属性
  // event.button 会报错：类型“KeyboardEvent”上不存在属性“button”，因为 button 不是键盘事件的属性，而是鼠标事件的属性
  console.log(event.button);
&#125;;
</code></pre>
<ul>
<li>TS 会根据左侧的事件绑定，来推断出右侧的事件类型，会被推断为<code>KeyboardEvent</code>类型（鼠标划上 event 即可看到）</li>
</ul>
<h4 id="类型断言-1"><a href="#类型断言-1" class="headerlink" title="类型断言"></a>类型断言</h4><blockquote>
<p>有时候，TS 的类型推断可能不符合你的预期，而且你完全有自信比 TS 更了解你的代码。</p>
</blockquote>
<ul>
<li>这时 TS 就提供了一种方法，允许你覆盖它的推断，即：类型断言</li>
</ul>
<pre><code>// 定义一个空对象
let foo = &#123;&#125;;
// 给对象指定 bar 属性，此时会报错：类型“&#123;&#125;”上不存在属性“bar”
foo.bar = 1;
</code></pre>
<ul>
<li>如何解决以上的报错问题呢 ？</li>
</ul>
<pre><code>// 定义一个接口
interface Foo &#123;
  // 给接口定义一个 bar 属性
  bar: number;
&#125;

// 利用 类型断言将 foo 指定为一个 Foo 接口类型，这时就不会报错了（类型断言就发挥作用了）
let foo = &#123;&#125; as Foo;
foo.bar = 1;
</code></pre>
<ul>
<li>同时，也要注意类型断言不能乱用</li>
</ul>
<pre><code>interface Foo &#123;
  bar: number;
&#125;

let foo = &#123;&#125; as Foo
// 比如：去掉赋值语句 foo.bar = 1
// foo 对象并没有按照接口的严格规定给其赋值为一个 bar 属性 也不会没有报错

// 因此在声明时，就指定类型
let foo: Foo = &#123;
  // TS 要求必须添加接口中的属性
  bar: 1,
&#125;;
</code></pre>
<ul>
<li>类型断言，可以增加代码的灵活性，再改造一些旧代码时会非常有效。</li>
<li>但使用类型断言要注意避免滥用，需要对上下文环境有充分的预判，没有任何根据的类型断言，会给我们的代码带来安全隐患。</li>
</ul>
<h4 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h4><ul>
<li>TS 的类型推断可以为我们提供重要的辅助信息，应该深加利用</li>
<li>我们也可以检查下之前写的代码，观察哪里部分可以使用类型推断进行优化。</li>
</ul>
<h3 id="二、类型的兼容性"><a href="#二、类型的兼容性" class="headerlink" title="二、类型的兼容性"></a>二、类型的兼容性</h3><blockquote>
<p>当一个类型 Y 可以被赋值给另一个类型 X 时，我们就可以说类型 X 兼容类型 Y</p>
</blockquote>
<ul>
<li>其中，X 被叫做 目标类型，Y 被叫做 源类型</li>
</ul>
<blockquote>
<p>X 兼容 Y ：X（目标类型）&#x3D; Y（源类型）</p>
</blockquote>
<pre><code>// X 兼容 Y ：X（目标类型）= Y（源类型）

// 定义一个字符串变量 s
let s: string = &quot;ibc&quot;;
// 当 tsconfig.json 配置文件中为 &quot;strictNullChecks&quot;: false 时
// 字符串变量是可以被赋值为 null 的，此时我们可以说字符型是可以兼容 null 类型的
// 即：null 是字符型的子类型
s = null;
</code></pre>
<ul>
<li>之所以，我们要讨论类型兼容性问题，是因为 TS 允许我们把一些类型不同的变量相互赋值。</li>
<li>虽然在某种程度上讲会产生不可靠的行为，但却增加了语言的灵活性，而类型兼容性的例子会广泛存在于 接口、函数 和 类中。</li>
</ul>
<h4 id="接口兼容性"><a href="#接口兼容性" class="headerlink" title="接口兼容性"></a>接口兼容性</h4><blockquote>
<p>下面我们来观察两个接口是如何兼容的</p>
</blockquote>
<pre><code>// 定义接口 X ，其中有两个属性
interface X &#123;
  a: any;
  b: any;
&#125;
// 定义接口 Y ，其中有三个属性
interface Y &#123;
  a: any;
  b: any;
  c: any;
&#125;

// 定义变量 x 和 y 分别符合以上接口类型
let x: X = &#123; a: 1, b: 2 &#125;;
let y: Y = &#123; a: 1, b: 2, c: 3 &#125;;

// 思考 x 和 y 可以相互赋值吗

// y 是可以被赋值给 x
x = y;
// x 不能被赋值为 y（会报错）
y = x;
</code></pre>
<ul>
<li>只要 Y 接口具备 X 接口的所有属性（即：a 和 b），即使有 额外的属性 c ，y 仍然可以被认为是 X 类型。即 X 类型可以兼容 Y 类型</li>
</ul>
<blockquote>
<p>这里再次体现了 TS 的类型检查原则，即：鸭式辨型法</p>
<ul>
<li>“一只鸟，看起来像鸭子，游起来像鸭子，叫起来像鸭子，那么这只鸟就可以被认为是鸭子”。</li>
<li>总结：语言类型必须具备目标类型的必要属性，就可以进行赋值。</li>
</ul>
</blockquote>
<blockquote>
<p>总结</p>
<ul>
<li>对于接口来说：X 兼容 Y</li>
</ul>
</blockquote>
<ul>
<li>X（目标类型）&#x3D; Y（源类型）</li>
<li>目标类型的成员数《 源类型的成员数</li>
<li>一句口诀：接口之间相互兼容时，成员少的兼容成员多的</li>
</ul>
<h4 id="函数兼容性"><a href="#函数兼容性" class="headerlink" title="函数兼容性"></a>函数兼容性</h4><blockquote>
<p>函数之间兼容的条件有以下三个</p>
</blockquote>
<ul>
<li>参数个数</li>
<li>参数类型</li>
<li>返回值类型</li>
</ul>
<blockquote>
<p>需要判断两个函数是不是兼容，通常会发生在两个函数相互赋值的情况下</p>
<ul>
<li>当函数作为参数时</li>
</ul>
</blockquote>
<pre><code>// 函数兼容性

// 定义函数类型 Handler，有两个参数 a 和 b
type Handler = (a: number, b: number) =&gt; void;

// 定义一个高阶函数，该函数以 Handler 类型为参数，并直接返回
function hof(handler: Handler) &#123;
  return handler;
&#125;
</code></pre>
<ul>
<li>当我们给以上高阶函数传入一个参数时，就会判断该参数是否 和 Handler 类型兼容，Handler 为目标类型，传入的参数为 源类型</li>
</ul>
<blockquote>
<p>如果要目标函数 兼容 源函数，它们需要同时满足三个条件（如下）</p>
</blockquote>
<ol>
<li>参数个数</li>
</ol>
<ul>
<li>目标函数为固定参数：要求目标函数的参数个数一定要多余源函数的参数个数</li>
</ul>
<pre><code>// 函数兼容性

// 定义函数类型 Handler，有两个参数 a 和 b
type Handler = (a: number, b: number) =&gt; void;

// 定义一个高阶函数，该函数以 Handler 类型为参数，并直接返回
function hof(handler: Handler) &#123;
  return handler;
&#125;

// 1、参数个数（要求目标函数的参数个数一定要多余源函数的参数个数）

// 定义一个只有一个参数的函数
let handler1 = (a: number) =&gt; &#123;&#125;;
// 将 handler1 作为参数传递给 hof 高阶函数，没问题（因为它只有一个参数）
hof(handler1);

// 定义一个有 3个 参数的函数
let handler2 = (a: number, b: number, c: number) =&gt; &#123;&#125;;
// 将 handler2 作为参数传递给 hof 高阶函数（会报错，因为它的参数是三个，而目标函数只有两个参数）
hof(handler2);
</code></pre>
<ul>
<li>以上情况都是具有固定参数的函数，如果函数中含有可变参数（可选参数）或剩余参数时，会遵循其它的原则</li>
</ul>
<blockquote>
<p>可选参数 和 剩余参数</p>
</blockquote>
<pre><code>// 定义函数 a ，为固定参数
let a = (p1: number, p2: number) =&gt; &#123;&#125;;
// 定义函数 b，为可选参数
let b = (p1?: number, p2?: number) =&gt; &#123;&#125;;
// 定义函数 c，为剩余参数
let c = (...args: number[]) =&gt; &#123;&#125;;
</code></pre>
<ul>
<li>原则一：固定参数是可以兼容可选参数 和 剩余参数的</li>
</ul>
<pre><code>a = b;
a = c;
</code></pre>
<ul>
<li>原则二：可选参数是不兼容固定参数 和 剩余参数的，（通过关闭<code>tsconfig.json</code>中<code>&quot;strictFunctionTypes&quot;: false</code>选项即可实现兼容）</li>
</ul>
<pre><code>b = c;
b = a;
</code></pre>
<ul>
<li>原则三：剩余参数可兼容 固定参数 和 可选参数</li>
</ul>
<pre><code>c = a;
c = b;
</code></pre>
<ul>
<li>以上是函数之间兼容必须要满足的第一个条件，即参数个数的要求。</li>
</ul>
<ol start="2">
<li>参数类型<blockquote>
<p>函数兼容性的第二个条件：参数类型，要求必须匹配</p>
</blockquote>
</li>
</ol>
<blockquote>
<p>基本类型：参数类型必须兼容</p>
</blockquote>
<pre><code>// 定义函数类型 Handler，有两个参数 a 和 b
type Handler = (a: number, b: number) =&gt; void;

// 定义一个高阶函数，该函数以 Handler 类型为参数，并直接返回
function hof(handler: Handler) &#123;
  return handler;
&#125;

// 参数类型
// 定义一个只有一个参数的函数
let handler3 = (a: string) =&gt; &#123;&#125;;
// 将 handler3 作为参数传递给 hof 高阶函数（会报错：因为它的类型是不兼容的）
hof(handler3);
</code></pre>
<blockquote>
<p>对象类型</p>
</blockquote>
<pre><code>// 定义接口 Point3D 有3个属性
interface Point3D &#123;
  x: number;
  y: number;
  z: number;
&#125;

// 定义接口 Point2D 有2个属性
interface Point2D &#123;
  x: number;
  y: number;
&#125;

// 定义两个函数 p3d 和 p2d，它们的参数是上边定义的接口类型
// 以下函数的 参数个数是相同的，参数的类型都是 对象
let p3d = (point: Point3D) =&gt; &#123;&#125;;
let p2d = (point: Point2D) =&gt; &#123;&#125;;

// 它们之间的兼容性如何 ？

// p3d 兼容 p2d
p3d = p2d;

// p2d 不兼容 p3d（观察两个函数的参数，它们都是对象：p3d 中有3个成员，p2d 中有2个成员）
p2d = p3d;
</code></pre>
<ul>
<li>即：成员个数多的 兼容 成员个数少的（与之前接口之间兼容性的结论正好相反）两个接口之间兼容要求成员少的 兼容 成员多的</li>
</ul>
<blockquote>
<p>如果一定要 p2d 兼容 p3d 也是可以做到的，将 <code>tsconfig.json</code>中配置设为<code>false</code>，这样两个函数就可以兼容了</p>
</blockquote>
<pre><code>&#123;
  &quot;compilerOptions&quot;: &#123;
    &quot;strictFunctionTypes&quot;: false
  &#125;
&#125;
</code></pre>
<blockquote>
<p>以上这种函数的参数之间可以相互赋值的情况，叫做 函数参数双向协变</p>
</blockquote>
<ul>
<li>它允许我们把一个精确的类型，赋值给一个不那么精确的类型，这样做很方便。我们就不需要把一个不精确的类型断言成一个精确的类型了。</li>
</ul>
<ol start="3">
<li>返回值类型<blockquote>
<p>TS 要求目标返回值类型 必须 与原函数的返回值类型相同 或 为其子类型</p>
</blockquote>
</li>
</ol>
<pre><code>// 定义函数 f，它的返回值是一个对象，其中有一个字段 username
let f = () =&gt; (&#123; username: &quot;ibc&quot; &#125;);
// 定义函数 g，它的返回值有两个字段
let g = () =&gt; (&#123; username: &quot;ibc&quot;, location: &quot;Beijing&quot; &#125;);

// f 就可以兼容 g
f = g;
// g 是不兼容 f 的（因为 f 的返回值类型是 g 返回值类型的 子类型）
g = f;
</code></pre>
<ul>
<li>同样这里也是成员少的会兼容成员多的，与 鸭式辨型法 是一致的</li>
</ul>
<blockquote>
<p>函数重载<br>函数重载分为两个部分</p>
<ul>
<li>第一部分：函数重载的列表。如：在列表中定义了两个函数，overload</li>
<li>第二部分：函数的实现。<br>这里，列表中的函数就是 <strong>目标函数</strong>，而具体的实现就是 <strong>源函数</strong>。程序在运行时编译器会查找重载的列表，然后使用第一个匹配的定义来执行下面的函数。</li>
<li>所以，在重载列表中目标函数的参数要多于源函数的参数，而且返回值类型也要符合相应的要求。</li>
</ul>
</blockquote>
<pre><code>function overload(a: number, b: number): number;
function overload(a: string, b: string): string;
function overload(a: any, b: any): any &#123;&#125;
// 在具体实现时，增加一个参数 c ，这样就是不兼容的（因为实现的参数的个数 多于 目标函数的个数了）
function overload(a: any, b: any, c: any): any &#123;&#125;

// 去掉返回值，它也是不兼容的（返回值类型不兼容）
// function overload(a: any, b: any) &#123;&#125;
</code></pre>
<p>以上是两个函数之间要兼容，所必须要满足的三个条件</p>
<h4 id="枚举类型兼容性"><a href="#枚举类型兼容性" class="headerlink" title="枚举类型兼容性"></a>枚举类型兼容性</h4><blockquote>
<p>枚举类型 和 数值类型 是可以完全互相兼容的</p>
</blockquote>
<pre><code>// 枚举兼容性
enum Fruit &#123;
  Apple,
  Banana,
&#125;
enum Color &#123;
  Red,
  Yellow,
&#125;

// 枚举类型 和 数值类型 是可以完全互相兼容的

// 定义变量 fruit 它的类型是 一个枚举类型，可以给它赋值任意的数字
let fruit: Fruit.Apple = 2;
// 定义变量 no 它的类型是 一个数值类型，它可以被赋值一个枚举类型
let no: number = Fruit.Apple;
</code></pre>
<ul>
<li>因此，我们可以看到枚举 和 数值类型是可以相互兼容的<br>枚举 和 number 之间是可以兼容的，枚举之间是不兼容的</li>
</ul>
<pre><code>// 枚举兼容性
enum Fruit &#123;
  Apple,
  Banana,
&#125;
enum Color &#123;
  Red,
  Yellow,
&#125;

let color: Color.Red = Fruit.Apple;//报错
</code></pre>
<ul>
<li>枚举之间是完全不兼容的（如下：Color 和 Fruit 是完全不兼容的）</li>
</ul>
<h4 id="类的兼容性"><a href="#类的兼容性" class="headerlink" title="类的兼容性"></a>类的兼容性</h4><blockquote>
<p>类的兼容性 与 接口比较相似，它们也是只比较结构</p>
<p>注意：在比较两个类是否兼容时，静态成员 和 构造函数是不参与比较的。如果两个类具备两个相同的<strong>实例成员</strong>，它们的实例就可以完全相互兼容</p>
</blockquote>
<pre><code>// 定义两个类 A 和 B
class A &#123;
  constructor(a: number, b: number) &#123;&#125;
  id: number = 1;
&#125;

class B &#123;
  static s = 1;
  constructor(a: number) &#123;&#125;
  id: number = 2;
&#125;

// 分别创建了两个实例 aa 和 bb
let aa = new A(1, 3);
let bb = new B(1);

aa = bb;
bb = aa;
</code></pre>
<ul>
<li>这两个实例是完全兼容的，因为它们都具有两个实例 id</li>
<li>而构造函数 和 静态成员是不作为比较的</li>
</ul>
<blockquote>
<p>如果类 A 和 B 含有私有成员呢 ？</p>
</blockquote>
<pre><code>// 定义两个类 A 和 B
class A &#123;
  constructor(a: number, b: number) &#123;&#125;
  id: number = 1;
  // 添加一个私有成员
  private username: string = &quot;&quot;;
&#125;

class B &#123;
  static s = 1;
  constructor(a: number) &#123;&#125;
  id: number = 2;
  // 添加一个私有成员
  private username: string = &quot;&quot;;
&#125;

// 分别创建了两个实例 aa 和 bb
let aa = new A(1, 3);
let bb = new B(1);

// 以上 A 和 B 类中含有私有成员，这两个类就不兼容了（会报错）
aa = bb;
bb = aa;
</code></pre>
<ul>
<li>如果类中含有私有成员，这两个类就不兼容了</li>
</ul>
<blockquote>
<p>如果类中含有私有成员，那么只有父类和子类之间是可以相互兼容的</p>
</blockquote>
<pre><code>定义一个 A 的子类

// 定义两个类 A 和 B
class A &#123;
  constructor(a: number, b: number) &#123;&#125;
  id: number = 1;
  // 添加一个私有成员
  private username: string = &quot;&quot;;
&#125;

class B &#123;
  static s = 1;
  constructor(a: number) &#123;&#125;
  id: number = 2;
  // 添加一个私有成员
  private username: string = &quot;&quot;;
&#125;

// 分别创建了两个实例 aa 和 bb
let aa = new A(1, 3);
let bb = new B(1);

// aa = bb
// bb = aa

// 如果类中含有私有成员，这两个类就不兼容了
// 此时，只有父类和子类之间是可以相互兼容的

// 定义一个 A 的子类 C
class C extends A &#123;&#125;
// 创建 C 的实例
let cc = new C(1, 2);

// 父类 和 子类的实例是可以完全相互兼容的
aa = cc;
cc = aa;
</code></pre>
<h4 id="泛型的兼容性"><a href="#泛型的兼容性" class="headerlink" title="泛型的兼容性"></a>泛型的兼容性</h4><pre><code>// 泛型兼容性

// 定义一个泛型接口 Empty ，该接口没有任何的成员
interface Empty&lt;T&gt; &#123;&#125;

// 定义 obj1 和 obj2 两个变量，该变量都是 Empty 接口类型（其中传入的参数类型不同）
let obj1: Empty&lt;number&gt; = &#123;&#125;;
let obj2: Empty&lt;string&gt; = &#123;&#125;;

obj1 = obj2;
</code></pre>
<ul>
<li>这两个变量是相互兼容的，因为 Empty 接口中没有任何的成员<blockquote>
<p>给 Empty 泛型接口中，添加成员</p>
</blockquote>
</li>
</ul>
<pre><code>// 给泛型接口 Empty 中添加一个成员
interface Empty&lt;T&gt; &#123;
  value: T;
&#125;

let obj1: Empty&lt;number&gt; = &#123;&#125;;
let obj2: Empty&lt;string&gt; = &#123;&#125;;

// 这是两个变量就不兼容了（会报错）
obj1 = obj2;
</code></pre>
<ul>
<li>也就是说只有类型参数 T 有成员时，才会影响泛型的兼容性</li>
</ul>
<h4 id="泛型函数"><a href="#泛型函数" class="headerlink" title="泛型函数"></a>泛型函数</h4><pre><code>// 以下定了两个完全相同的泛型函数
let log1 = &lt;T&gt;(x: T): T =&gt; &#123;
  console.log(&quot;x&quot;);
  return x;
&#125;;
let log2 = &lt;U&gt;(y: U): U =&gt; &#123;
  console.log(&quot;y&quot;);
  return y;
&#125;;

// log1 和 log2 是完全兼容的
log1 = log2;
</code></pre>
<ul>
<li>即：如果两个泛型函数的定义相同，但没有指定类型参数，那么它们之间也是可以相互兼容的</li>
</ul>
<blockquote>
<p>TS 允许我们在类型兼容的变种之间相互赋值，这个特性增加了语言的灵活性。</p>
</blockquote>
<h4 id="总结-2"><a href="#总结-2" class="headerlink" title="总结"></a>总结</h4><blockquote>
<p>关于类型兼容性的部分学习了很多规则，我们总结了几句比较好记的几条兼容性口诀：</p>
</blockquote>
<ul>
<li>当一个类型 Y 可以被赋值给另一个类型 X 时(X&#x3D;Y)，我们就可以说类型 X 兼容类型 Y</li>
<li>其中，X 被叫做 目标类型，Y 被叫做 源类型</li>
<li>口诀：<ul>
<li>结构之间兼容：成员少的兼容成员多的</li>
<li>函数之间兼容：参数多的兼容参数少的</li>
</ul>
</li>
</ul>
<h3 id="三、TS的类型保护机制"><a href="#三、TS的类型保护机制" class="headerlink" title="三、TS的类型保护机制"></a>三、TS的类型保护机制</h3><blockquote>
<p>我们先来观察如下代码</p>
</blockquote>
<pre><code>enum Type &#123;
  Strong,
  week,
&#125;

// 定义 Java 类
class Java &#123;
  helloJava() &#123;
    console.log(&quot;Hello Java&quot;);
  &#125;
&#125;

// 定义 JavaScript 类
class JavaScript &#123;
  helloJavaScript() &#123;
    console.log(&quot;Hello JavaScript&quot;);
  &#125;
&#125;

// 定义一个函数
function getLanguage(type: Type) &#123;
  // 判断该类型是 强类型 则返回 Java 类的实例，否则 返回 JavaScript 类的实例
  let lang = type === Type.Strong ? new Java() : new JavaScript();
  // 增加一个功能，即：创建实例后，运行该实例打印的方式
  // 以下提示报错（lang 是 Java 和 JavaScript 的联合类型）此时 TS 是不能判断它具体是哪一种类型的
  // 需要添加 类型断言，就不会报错了
  // if(lang.helloJava)&#123;
  //     lang.helloJava()
  // &#125; else &#123;
  //     lang.helloJavaScript()
  // &#125;
  if ((lang as Java).helloJava) &#123;
    (lang as Java).helloJava();
  &#125; else &#123;
    (lang as JavaScript).helloJavaScript();
  &#125;

  return lang;
&#125;

getLanguage(Type.Strong);
</code></pre>
<ul>
<li>由于不知道程序在运行时，到底会传入什么样的参数，所以就必须要在每一处都加上类型断言。显然这不是一种理想的方案，代码的可读性很差</li>
<li>而类型保护机制就是用来解决这个问题的，它可以提前对类型做出预判。</li>
</ul>
<h4 id="什么是类型保护"><a href="#什么是类型保护" class="headerlink" title="什么是类型保护"></a>什么是类型保护</h4><ul>
<li>TypeScript 能够在特定的区块中保证变量属于某种确定的类型。</li>
<li>可以在此区块中放心地引用此类型的属性，或者调用此类型的方法。<ul>
<li>接下来我们就来使用 4 种创建特殊区块的方法</li>
</ul>
</li>
</ul>
<ol>
<li>instanceof 方法<blockquote>
<p>该类型保护的方法用来判断一个实例是不是属于某个类</p>
</blockquote>
</li>
</ol>
<pre><code>enum Type &#123;
  Strong,
  week,
&#125;

// 定义 Java 类
class Java &#123;
  helloJava() &#123;
    console.log(&quot;Hello Java&quot;);
  &#125;
&#125;

// 定义 JavaScript 类
class JavaScript &#123;
  helloJavaScript() &#123;
    console.log(&quot;Hello JavaScript&quot;);
  &#125;
&#125;

// 定义一个函数
function getLanguage(type: Type) &#123;
  // 判断该类型是 强类型 则返回 Java 类的实例，否则 返回 JavaScript 类的实例
  let lang = type === Type.Strong ? new Java() : new JavaScript();

  // instanceof 方法用来判断一个实例是不是属于某个类

  // 如果 lang 属于 Java 类
  if (lang instanceof Java) &#123;
    // TS 就能保证 lang 一定是 Java 类的实例，相应的方法也会自动提示出来
    lang.helloJava();
  &#125; else &#123;
    // 在 else 区块中，TS 就会判断 lang 对象一定是 JavaScript 的实例，相应的方法也会直接提示出来
    lang.helloJavaScript();
  &#125;

  // 这样的代码就比之前使用 类型断言简洁多了

  return lang;
&#125;

getLanguage(Type.Strong);
</code></pre>
<ol start="2">
<li>in 方法<blockquote>
<p>in 关键字可以判断一个属性是不是属于某个对象</p>
<ul>
<li>我们在以上代码 Java 和 JavaScript 类中，分别加入属性</li>
</ul>
</blockquote>
</li>
</ol>
<pre><code>enum Type &#123;
  Strong,
  week,
&#125;

// 定义 Java 类
class Java &#123;
  helloJava() &#123;
    console.log(&quot;Hello Java&quot;);
  &#125;
  // 新增属性
  java: any;
&#125;

// 定义 JavaScript 类
class JavaScript &#123;
  helloJavaScript() &#123;
    console.log(&quot;Hello JavaScript&quot;);
  &#125;
  // 新增属性
  javascript: any;
&#125;

// 定义一个函数
function getLanguage(type: Type) &#123;
  // 判断该类型是 强类型 则返回 Java 类的实例，否则 返回 JavaScript 类的实例
  let lang = type === Type.Strong ? new Java() : new JavaScript();

  // in 方法可以判断一个属性是不是属于某个对象

  // 通过以上新增的两个属性来创建类型保护区块（if 和 else 两个区块）
  if (&quot;java&quot; in lang) &#123;
    // 在第一个区块中，TS 会判断该对象一定是 Java 类的实例
    lang.helloJava();
  &#125; else &#123;
    // 在第一个区块中，TS 会判断该对象一定是 JavaScript 类的实例
    lang.helloJavaScript();
  &#125;

  return lang;
&#125;

getLanguage(Type.Strong);
</code></pre>
<ol start="3">
<li>typeof 方法<blockquote>
<p>typeof 方法 ，判断一个变量的类型（多用于基本类型）</p>
<ul>
<li>给<code>getLanguage</code>函数增加一个参数<code>x</code>为联合类型</li>
</ul>
</blockquote>
</li>
</ol>
<pre><code>enum Type &#123;
  Strong,
  week,
&#125;

// 定义 Java 类
class Java &#123;
  helloJava() &#123;
    console.log(&quot;Hello Java&quot;);
  &#125;
  // 新增属性
  java: any;
&#125;

// 定义 JavaScript 类
class JavaScript &#123;
  helloJavaScript() &#123;
    console.log(&quot;Hello JavaScript&quot;);
  &#125;
  // 新增属性
  javascript: any;
&#125;

// 给函数增加一个参数 x
function getLanguage(type: Type, x: string | number) &#123;
  // 判断该类型是 强类型 则返回 Java 类的实例，否则 返回 JavaScript 类的实例
  let lang = type === Type.Strong ? new Java() : new JavaScript();

  // typeof 方法 ，用来判断一个基本的类型

  // 用 typeof 来判断 x 的类型
  if (typeof x === &quot;string&quot;) &#123;
    // 该区块中 x 的类型就一定是 string 类型，x 就可以拥有 string的一些属性，如下
    x.length;
  &#125; else &#123;
    // 该区块中 x 的类型就一定是 number 类型，x 就拥有了 number 的一些方法
    x.toFixed(2);
  &#125;

  return lang;
&#125;

// getLanguage(Type.Strong)
</code></pre>
<ol start="4">
<li>类型保护函数<blockquote>
<p>该函数需要自定义，通过创建类型保护函数来判断对象的类型</p>
</blockquote>
</li>
</ol>
<pre><code>enum Type &#123;
  Strong,
  week,
&#125;

// 定义 Java 类
class Java &#123;
  helloJava() &#123;
    console.log(&quot;Hello Java&quot;);
  &#125;
  // 新增属性
  java: any;
&#125;

// 定义 JavaScript 类
class JavaScript &#123;
  helloJavaScript() &#123;
    console.log(&quot;Hello JavaScript&quot;);
  &#125;
  // 新增属性
  javascript: any;
&#125;

// 自定义创建类型保护函数来判断对象的类型

// 该函数的返回值是一种特殊的返回值，叫做 &quot;类型谓词&quot;
function isJava(lang: Java | JavaScript): lang is Java &#123;
  return (lang as Java).helloJava !== undefined;
&#125;

// 给函数增加一个参数 x
function getLanguage(type: Type, x: string | number) &#123;
  // 判断该类型是 强类型 则返回 Java 类的实例，否则 返回 JavaScript 类的实例
  let lang = type === Type.Strong ? new Java() : new JavaScript();

  // 使用自定义类型保护函数来判断
  if (isJava(lang)) &#123;
    // 该类型保护区块，TS 会判断该对象一定是 Java 类的实例
    lang.helloJava();
  &#125; else &#123;
    lang.helloJavaScript();
  &#125;

  return lang;
&#125;

// getLanguage(Type.Strong)
</code></pre>
<h4 id="总结-3"><a href="#总结-3" class="headerlink" title="总结"></a>总结</h4><blockquote>
<p>我们学习了 TS 的类型保护机制，分别是</p>
</blockquote>
<ul>
<li>instanceof：判断一个实例是否属于某个类；</li>
<li>in：判断一个属性是否属于某个对象；</li>
<li>typeof：判断一个变量的类型（多用于基本类型）；</li>
<li>类型保护函数：某些判断可能不是一条语句能够搞定的，需要更多复杂的逻辑，适合封装到一个函数内。</li>
</ul>
<h2 id="TS的高级类型"><a href="#TS的高级类型" class="headerlink" title="TS的高级类型"></a>TS的高级类型</h2><blockquote>
<p>所谓 “高级类型”，即：TS 为了保证语言的灵活性所引入的一些语言特性。这些特性将有助于我们应对复杂多变的开发场景。</p>
</blockquote>
<h4 id="交叉类型"><a href="#交叉类型" class="headerlink" title="交叉类型"></a>交叉类型</h4><blockquote>
<p>交叉类型即：将多个类型合并为一个类型（使用 <code>&amp;</code> 符号连接），新的类型将具有所有类型的特性。</p>
<ul>
<li>因此，交叉类型特别适合对象混入的场景</li>
</ul>
</blockquote>
<pre><code>// 定义一个 DogInterface 接口 ，具有 run() 方法
interface DogInterface &#123;
  run(): void;
&#125;

// 定义一个 CatInterface 接口，具有 jump() 方法
interface CatInterface &#123;
  jump(): void;
&#125;

// 定义变量 pet 的类型是 以上两个接口的交叉类型（交叉类型用 &amp; 符来链接）
let pet: DogInterface &amp; CatInterface = &#123;
  // 该变量同时具备以上两个接口的所有方法
  run() &#123;&#125;,
  jump() &#123;&#125;,
&#125;;
</code></pre>
<ul>
<li>从名称上看，交叉类型给人感觉是取类型的交集，但实际上是取所有类型的<strong>并集</strong>。</li>
</ul>
<h4 id="联合类型"><a href="#联合类型" class="headerlink" title="联合类型"></a>联合类型</h4><blockquote>
<p>在前面的学习中，多少接触过一些。这里我们正式明确它的概念</p>
<ul>
<li>所谓联合类型：声明的类型并不确定，可以为多个类型中的一个。</li>
</ul>
</blockquote>
<pre><code>// 声明变量 a，它的类型是 number 和 string 的联合类型
// 它的取值既可以是数字类型 1 也可以是字符串类型 &#39;a&#39;
let a: number | string = 1;
// let a: number | string = &#39;a&#39;
</code></pre>
<ol>
<li>字面量联合类型<blockquote>
<p>有时候我们不仅要限定一个变量的类型，而且还需要限定变量的取值在某一个特定的范围内</p>
</blockquote>
</li>
</ol>
<pre><code>// 定义一个变量 b，它的类型是一个字符串类型的字面量联合类型
// 即：b 的取值只能是 &#39;b&#39;，&#39;a&#39;，&#39;c&#39; 中的一种
let b: &quot;a&quot; | &quot;b&quot; | &quot;c&quot;;

// 数字类型的字面量联合类型，它的取值限定为只能是 1，2，3
let c: 1 | 2 | 3;
</code></pre>
<ol start="2">
<li>对象的联合类型</li>
</ol>
<pre><code>// 定义一个 DogInterface 接口 ，具有 run() 方法
interface DogInterface &#123;
  run(): void;
&#125;

// 定义一个 CatInterface 接口，具有 jump() 方法
interface CatInterface &#123;
  jump(): void;
&#125;

// 对象的联合类型

// 创建 Dog 类型，实现了 DogInterface 接口
class Dog implements DogInterface &#123;
  // 实现了 run 和 eat 方法
  run() &#123;&#125;
  eat() &#123;&#125;
&#125;

// 创建 Cat 类型，实现了 CatInterface 接口
class Cat implements CatInterface &#123;
  jump() &#123;&#125;
  eat() &#123;&#125;
&#125;

enum Master &#123;
  Boy,
  Girl,
&#125;

// 定义一个函数
function getPet(master: Master) &#123;
  // 判断参数类型，如果是 Boy 即返回 Dog 的实例，否则返回 Cat 的实例
  let pet = master === Master.Boy ? new Dog() : new Cat();
  // 调用实例的方式，首先看下 pet 的类型被推断为 Dog 和 Cat 的联合类型
  // 如果一个对象是联合类型，在类型未确定的情况下，它就只能访问所有类型的共有成员，Dog 和 Cat的共有成员 就是 eat 方法
  // 如果想要访问其中的 run 方法，是不能访问的，同样 jump 也不能访问
  pet.eat();

  return pet;
&#125;
</code></pre>
<ul>
<li>以上代码中，有趣的事情再次发生了，从名称上看联合类型给人的感觉是 取所有类型的并集，而实际上在对象的联合类型情况下，<strong>却只能访问所有类成员的交集</strong>。</li>
</ul>
<ol start="3">
<li>可区分的联合类型<blockquote>
<p>可区分的联合类型该模式本质上是结合了联合类型 和 字面量类型的一种 <strong>类型保护方法</strong></p>
<ul>
<li>它的核心思想是：一个类型如果是<strong>多个类型的联合类型</strong> 并且 <strong>每个类型之间有一个公共的属性</strong>，那么我们就可以凭借这个公共属性创建不同的类型保护区块。</li>
</ul>
</blockquote>
</li>
</ol>
<pre><code>// 声明两个接口 Square 和 Rectangle，它们有一个共同的属性 kind 用来表示它们的类型

// 声明接口 Square
interface Square &#123;
  kind: &quot;square&quot;;
  size: number;
&#125;

// 声明接口 Rectangle
interface Rectangle &#123;
  kind: &quot;rectangle&quot;;
  width: number;
  height: number;
&#125;

// 使用类型别名声明了一种 Square 和 Rectangle 的联合类型 Shape
type Shape = Square | Rectangle;

// area 函数，用来计算不同类型的面积
function area(s: Shape) &#123;
  // 通过两个接口共用的属性 kind，就可以创建不同的类型保护区块
  switch (s.kind) &#123;
    case &quot;square&quot;:
      // 该区块在可访问 Square 的属性
      return s.size * s.size;
    case &quot;rectangle&quot;:
      // 该区块在可访问 Rectangle 的属性
      return s.height * s.width;
  &#125;
&#125;
</code></pre>
<ul>
<li>该模式的核心：即利用两种类型的共有属性来创建不同的类型保护区块</li>
<li>以上代码不升级是没有问题的，但如果我们想加一种新的 Shape 就有可能存在一种新的隐患</li>
</ul>
<blockquote>
<p>如果我们给以上代码添加一种新的 Shape（形状）类型</p>
</blockquote>
<pre><code>interface Square &#123;
  kind: &quot;square&quot;;
  size: number;
&#125;

interface Rectangle &#123;
  kind: &quot;rectangle&quot;;
  width: number;
  height: number;
&#125;

// 添加一种新的 Shape（形状）类型
interface Circle &#123;
  kind: &quot;circle&quot;;
  // 半径
  r: number;
&#125;

// 在联合类型中添加 Circle 类型
type Shape = Square | Rectangle | Circle;

function area(s: Shape) &#123;
  switch (s.kind) &#123;
    case &quot;square&quot;:
      return s.size * s.size;
    case &quot;rectangle&quot;:
      return s.height * s.width;
  &#125;
&#125;

// 打印面积
console.log(area(&#123; kind: &quot;circle&quot;, r: 1 &#125;)); // undefined
</code></pre>
<ul>
<li><code>ts-node 文件名</code>命令行运行以上代码，打印结果为 <code>undefined</code>，如何运用 TS 来约束这种模式呢（即：给出对应的错误提示）。</li>
</ul>
<blockquote>
<p>有两种方法，如下</p>
</blockquote>
<ul>
<li>方法一： 为 area 函数指定明确的返回值类型</li>
</ul>
<pre><code>interface Square &#123;
  kind: &quot;square&quot;;
  size: number;
&#125;

interface Rectangle &#123;
  kind: &quot;rectangle&quot;;
  width: number;
  height: number;
&#125;

interface Circle &#123;
  kind: &quot;circle&quot;;
  r: number;
&#125;

type Shape = Square | Rectangle | Circle;

// 为 area 函数指定明确的返回值类型
// 如果指定为 number 类型（number处会报错），此时 TS 就会判断 所有的 switch 分支是不是包含了所有的情况
function area(s: Shape): number &#123;
  switch (kind) &#123;
    case &quot;square&quot;:
      return s.size * s.size;
    case &quot;rectangle&quot;:
      return s.height * s.width;
  &#125;
&#125;

console.log(area(&#123; kind: &quot;circle&quot;, r: 1 &#125;));
</code></pre>
<ul>
<li>方法二： 利用 never 类型</li>
</ul>
<pre><code>interface Square &#123;
  kind: &quot;square&quot;;
  size: number;
&#125;

interface Rectangle &#123;
  kind: &quot;rectangle&quot;;
  width: number;
  height: number;
&#125;

interface Circle &#123;
  kind: &quot;circle&quot;;
  r: number;
&#125;

type Shape = Square | Rectangle | Circle;

function area(s: Shape) &#123;
  switch (s.kind) &#123;
    case &quot;square&quot;:
      return s.size * s.size;
    case &quot;rectangle&quot;:
      return s.height * s.width;
    // 补上 circle 分支
    case &quot;circle&quot;:
      return Math.PI * s.r ** 2;
    default:
      // 函数的参数是 area 的参数 s，此时 s 处会报错
      // 该函数的作用是 检查 s 是不是 never 类型，如果 s 是 never 类型就说明前面的所有分支都被覆盖了，以下分支永远不会走到
      // 如果 s 不是 never 类型，说明前面的分支有遗漏，那么再补上分支
      return ((e: never) =&gt; &#123;
        throw new Error(e);
      &#125;)(s);
  &#125;
&#125;

// 打印面积（可正常输出了）
console.log(area(&#123; kind: &quot;circle&quot;, r: 1 &#125;)); // 3.141592653589793
</code></pre>
<ol start="4">
<li>总结<blockquote>
<p>我们以上学习了 TS 的高级类型交叉类型 和 联合类型</p>
</blockquote>
</li>
</ol>
<ul>
<li>交叉类型比较适合做对象的混入</li>
<li>联合类型可以使类型具有一定的不确定性，可以增强代码的灵活性</li>
</ul>
<h4 id="索引类型"><a href="#索引类型" class="headerlink" title="索引类型"></a>索引类型</h4><blockquote>
<p>在 JS 中我们经常会遇到以下的场景：从对象中获取一些属性的值，然后建立一个集合</p>
</blockquote>
<pre><code>let obj = &#123;
  a: 1,
  b: 2,
  c: 3,
&#125;;

// 需求：我们想抽取它的一些值，形成一个数组

/**
 * 实现一个函数
 * @param obj 对象
 * @param keys 字符串数组
 * @returns 数组
 */
 function getValues(obj: any, keys: string[]) &#123;
    // 遍历 keys 数组，调用它的 map 方法
    return keys.map((key) =&gt; obj[key]);
 &#125;

// 先抽取它的属性 a 和 b
console.log(getValues(obj, [&quot;a&quot;, &quot;b&quot;])); // [ 1, 2 ]
// 再抽取 obj 中没有的属性 e 和 f
console.log(getValues(obj, [&quot;e&quot;, &quot;f&quot;])); // [ undefined, undefined ]
</code></pre>
<ul>
<li>在以上抽取 obj 中没有的属性 e 和 f 时，TS 编译器并没有报错。如何使用 TS 对这种模式进行类型约束呢 ？ 这里就会用到索引类型</li>
</ul>
<ol>
<li>索引类型的查询操作符 - keyof T<blockquote>
<p><code>keyof T</code> 表示类型 <code>T</code> 的所有公共属性的字面量的联合类型</p>
</blockquote>
</li>
</ol>
<pre><code>// keyof T

// 定义一个接口，有属性 a 和 b
interface Obj &#123;
  a: number;
  b: string;
&#125;

// 定义一个变量，它的类型为 keyof Obj
// key 的类型就变成了 a 和 b 的联合类型 let key: &quot;a&quot; | &quot;b&quot;
let key: keyof Obj;
</code></pre>
<ol start="2">
<li>索引访问操作符<blockquote>
<p>索引访问操作符的语法：<code>T[K]</code> ，它的含义表示对象 T 的属性 <code>K</code> 所代表的类型</p>
</blockquote>
</li>
</ol>
<pre><code>// T[K]（索引访问操作符）它的含义表示对象 T 的属性 K 所代表的类型

// 定义一个变量 value，它的类型就是一个索引访问操作符
// 这里指定 Obj 属性 a 所代表的类型，即：value 的类型就是 number
let value: Obj[&quot;a&quot;];
</code></pre>
<ol start="3">
<li>泛型约束<blockquote>
<p><code>T extends U</code>表示泛型变量可以通过继承某个类型获得某些属性</p>
<ul>
<li>清楚了 索引类型的查询操作符 <code>keyof T</code>，索引访问操作符 <code>T[K]</code> ，泛型约束<code>T extends U </code>这三个概念，我们就来改造以上的 getValues() 函数</li>
</ul>
</blockquote>
</li>
</ol>
<pre><code>let obj = &#123;
  a: 1,
  b: 2,
  c: 3,
&#125;;

// 改造前
// function getValues(obj: any, keys: string[])&#123;
//    return keys.map(key =&gt; obj[key])
//&#125;

// 改造成泛型函数
function getValues&lt;T, K extends keyof T&gt;(obj: T, keys: K[]): T[K][] &#123;
  return keys.map((key) =&gt; obj[key]);
&#125;

console.log(getValues(obj, [&quot;a&quot;, &quot;b&quot;])); // [ 1, 2 ]
// 如果指定了一个不在 obj 里的属性，编译器就会报错，由此可以看到索引类型可以实现对对象属性的查询和访问，然后在配合泛型约束就能够使我们建立对象、对象属性 以及 属性值之间的约束关系
console.log(getValues(obj, [&quot;e&quot;, &quot;f&quot;]));
</code></pre>
<blockquote>
<p>改造成泛型函数，需要做一些约束</p>
<ul>
<li>keys 其中的元素一定是 obj 的属性</li>
</ul>
</blockquote>
<ul>
<li>先给 getValues 定义一个泛型变量 T，用它来约束 obj</li>
<li>然后，再给 getValues 定义一个泛型变量 K，用它来约束 keys 数组</li>
<li>将<code>getValues&lt;T, K&gt;</code>其中的 K 增加类型约束：<code>K extends keyof T</code>，让它来继承 obj 所有属性的联合类型</li>
<li>函数的返回值首先它是一个数组，数组的元素的类型就是属性 K 对应的类型：<code>T[K][]</code></li>
<li>这样我们就通过一个索引类型把一个 getValues 函数改造完毕了，这是 TS 的类型检查就发挥作用了</li>
</ul>
<h4 id="映射类型"><a href="#映射类型" class="headerlink" title="映射类型"></a>映射类型</h4><blockquote>
<p>通过映射类型我们可以从一个旧的类型生成一个新的类型</p>
</blockquote>
<ol>
<li>Readonly 只读 - 映射类型<blockquote>
<p>比如：把一个类型中的所有属性变为只读</p>
</blockquote>
</li>
</ol>
<pre><code>// 定义一个 Obj 接口
interface Obj &#123;
  a: string;
  b: number;
  c: boolean;
&#125;

// 需求：将接口的所有属性变为 只读

// 定义一个类型别名
// 该类型别名是 TS 一个内置的泛型接口，接口的名称是 Readonly
// 该接口传入的类型是我们指定的 Obj，当鼠标划在 ReadonlyObj 上可以看到
// 这样新生成的类型 和 旧的类型，可以看到它们的成员是完全相同的，且每一个成员的属性都变成了只读
type ReadonlyObj = Readonly&lt;Obj&gt;;
</code></pre>
<ul>
<li><p><code>Readonly</code>是 TS 一个内置的泛型接口 </p>
<img src="readonly映射类型.png">
</li>
<li><p>它是如何实现的呢 ？按住 Ctrl 键，点击 Readonly 查看 TS 源码的实现方法，直接跳转至 TS 内置的类库中，该类库的位置在 <code>\node_modules\typescript\lib</code> 目录下，这里预定义了很多 TS 内置的类库。</p>
<img src="readonly源码.png"></li>
</ul>
<blockquote>
<p>观察 Readonly 的实现</p>
</blockquote>
<ul>
<li>Readonly 是一个泛型接口，而且是一个可索引类型的泛型接口</li>
<li>它的索引签名是 <code>P in keyof T</code> 其中 <code>keyof T</code> 是一个索引类型的查询操作符，它表示类型 T 所有属性的联合类型</li>
<li><code>P in</code> 相当于执行了一次 <code>for in</code> 操作，它会把变量 P 依次的绑定到 T 的所有的属性上</li>
<li>索引签名的返回值就是一个索引访问操作符了，即<code>T[P]</code>，这里代表属性 P 所指定的类型</li>
<li>最后再加上 readonly 就把所有的属性变成了只读<ul>
<li>以上就是 Readonly 的实现原理了，TS 还预置了很多的 映射类型</li>
</ul>
</li>
</ul>
<ol start="2">
<li>Partial 可选 - 映射类型<blockquote>
<p>把一个接口的所有属性变为可选的</p>
</blockquote>
</li>
</ol>
<pre><code>// 定义一个 Obj 接口
interface Obj &#123;
  a: string;
  b: number;
  c: boolean;
&#125;

// 需求：把一个接口的所有属性变为可选的

// 给类型别名 PartialObj 指定一个 TS 内置的映射类型叫 Partial，参数为 Obj
// 鼠标划在 PartialObj 上可以看到新的类型已经把所有属性 变成了可选
type PartialObj = Partial&lt;Obj&gt;;
</code></pre>
<img src="partial映射类型.png">

<ul>
<li>我们可以看到新的类型已经把所有的属性变成了可选，按住 Ctrl 键，点击 Partial 查看 TS 源码的实现方法</li>
<li>与以上只读的实现几乎是一致的，只不过把属性变成了可选<img src="partial源码.png"></li>
</ul>
<ol start="3">
<li>Pick 挑选- 映射类型<blockquote>
<p>Pick 映射类型可以抽取 Obj 的一些子集</p>
</blockquote>
</li>
</ol>
<pre><code>// 定义一个 Obj 接口
interface Obj &#123;
  a: string;
  b: number;
  c: boolean;
&#125;

// 抽取 Obj 的一些子集

// Pick 接收两个参数：第一个是 Obj，第二是我们要抽取的一些属性的 key ，我们指定为 a 和 b
type PickObj = Pick&lt;Obj, &quot;a&quot; | &quot;b&quot;&gt;;
</code></pre>
<ul>
<li><p>以上 a 和 b 就会被单独的抽取出来，形成一个新的类型</p>
<img src="pick映射类型.png">
</li>
<li><p>按住 Ctrl 键，点击 Pick 查看 TS 源码的实现方法 和 原理</p>
<img src="pick源码.png">
</li>
<li><p>Pick 有两个参数，第一个参数是 T ，它代表我们要抽取的一个对象</p>
</li>
<li><p>第二个参数是 K，它有一个约束即：K 一定要来自 T 所有属性字面量的联合类型，新的类型的属性一定要从 K 中选取</p>
</li>
</ul>
<blockquote>
<p>以上 Readonly、Partial、Pick 三种类型官方将它们称为 同态，即：它们只会作用为 Obj 属性，而不会引入新的属性。</p>
</blockquote>
<ol start="4">
<li>Record - 映射类型<blockquote>
<p>Record 会创建新的属性</p>
</blockquote>
</li>
</ol>
<pre><code>// 定义一个 Obj 接口
interface Obj &#123;
  a: string;
  b: number;
  c: boolean;
&#125;

// Record  会创建新的属性
// Record 接收两个参数，第一参数是 预定义的新的属性 x 和 y ，该属性不来自 Obj
// 第二个参数是 一个已知的类型
type RecordObj = Record&lt;&quot;x&quot; | &quot;y&quot;, Obj&gt;;
</code></pre>
<img src="record映射类型.png">

<ul>
<li>鼠标划在 <code>RecordObj</code> 上可以看到，新的类型会有一些属性，这些属性有 Record 的第一参数所指定，这些属性的类型就是一个 已知的类型</li>
</ul>
<blockquote>
<p>这种类型就是一个 非同态的类型 ，映射类型本质上一种预先定义的泛型接口，通常还会结合索引类型获取对象的属性 和 属性值，从而将一个对象映射成我们想要的结构。</p>
</blockquote>
<ol start="5">
<li>总结<blockquote>
<p>以上我们学习 TS 的映射类型，TS 预设了很多的映射类型，我们感兴趣可以去它的类库中来学习</p>
</blockquote>
</li>
</ol>
<h4 id="条件类型"><a href="#条件类型" class="headerlink" title="条件类型"></a>条件类型</h4><blockquote>
<p>条件类型是一种由条件表达式所决定的类型</p>
<ul>
<li>条件表达式的语法</li>
</ul>
</blockquote>
<pre><code>T extends U ? X : Y
</code></pre>
<blockquote>
<p>具体含义：</p>
</blockquote>
<ul>
<li>如果类型 T 可以被赋值给 类型 U ，结果类型为 X 类型，否则就是 Y 类型</li>
<li>条件类型使类型具有了不唯一性，同样也增加了语言的灵活性</li>
</ul>
<pre><code>// 条件表达式的语法 T extends U ? X : Y

// 定义一个类型别名 TypeName，它是一种条件类型
// 而且是一种条件类型的嵌套，它会依次判断 T 的类型，然后返回不同的字符串
type TypeName&lt;T&gt; = T extends string
  ? &quot;string&quot;
  : T extends number
  ? &quot;number&quot;
  : T extends boolean
  ? &quot;boolean&quot;
  : T extends undefined
  ? &quot;undefined&quot;
  : T extends Function
  ? &quot;function&quot;
  : &quot;object&quot;;

// 定义一个类型 T1，它是条件类型传入一个参数 string
// T1 的类型（鼠标划上去可看出）根据上面的逻辑，它就是一个字面量类型 string
type T1 = TypeName&lt;string&gt;;
// T2 的类型是一个字面量类型，值是 Object
type T2 = TypeName&lt;string[]&gt;;
</code></pre>
<ol>
<li>分布式条件类型<blockquote>
<p>分布式条件类型的含义：如果 <code>T extends U ? X : Y </code>中类型 T 是一个<strong>联合类型</strong>的情况下，如：</p>
</blockquote>
</li>
</ol>
<ul>
<li><code>(A | B) extends U ? X : Y</code> ，即：T 是一个类型 A 和 类型 B 的联合类型，这时的结果类型会变成多个条件类型的联合类型，它可以进行如下拆解</li>
<li><code>(A extends U ? X : Y) | (B extends U ? X : Y)</code></li>
</ul>
<pre><code>type TypeName&lt;T&gt; = T extends string
  ? &quot;string&quot;
  : T extends number
  ? &quot;number&quot;
  : T extends boolean
  ? &quot;boolean&quot;
  : T extends undefined
  ? &quot;undefined&quot;
  : T extends Function
  ? &quot;function&quot;
  : &quot;object&quot;;

// 定义一个类型 T3 ，它的类型为 分布式的条件类型
// 此时，T3 的类型就会被推断为 string 和 object 的字面量联合类型
type T3 = TypeName&lt;string | string[]&gt;;
</code></pre>
<blockquote>
<p>利用这个特性，可以帮助我们去实现一些类型的过滤</p>
</blockquote>
<pre><code>// 定义一个新的类型 Diff ，它又两个参数 一个是 T，一个是 U
// 具体实现：如果 T 可以被赋值给 U，结果类型就是 never 类型，否则就是 T 类型
type Diff&lt;T, U&gt; = T extends U ? never : T;

// 定义一个类型 T4
// Diff 的第一个参数传入abc的联合类型 &quot;a&quot; | &quot;b&quot; | &quot;c&quot; ，第二个参数 &quot;a&quot; | &quot;e&quot;
// T4 的类型就变成了 b 和 c 的联合类型，其中就过滤掉了第二个参数中已经含有的类型 a
type T4 = Diff&lt;&quot;a&quot; | &quot;b&quot; | &quot;c&quot;, &quot;a&quot; | &quot;e&quot;&gt;;
</code></pre>
<blockquote>
<p>我们按照上边的拆解逻辑详细的解释</p>
</blockquote>
<ul>
<li>Diff 会被拆解为如下的样子</li>
</ul>
<pre><code>// Diff 会被拆解为多个条件类型的联合类型
// Diff&lt;&quot;a&quot;, &quot;a&quot; | &quot;e&quot;&gt; | Diff&lt;&quot;b&quot;, &quot;a&quot; | &quot;e&quot;&gt; | Diff&lt;&quot;c&quot;, &quot;a&quot; | &quot;e&quot;&gt;

// 判断 a 是不是可以被赋值给 字面量联合类型（&quot;a&quot; | &quot;e&quot;），答案是可以的，所以它就会返回为 never
// b 和 c 是不可以被赋值给字面量联合类型（&quot;a&quot; | &quot;e&quot;） 因此，依然返回 b 和 c

// 因此，最终返回如下

// never | &quot;b&quot; | &quot;c&quot;

// 最后，never 和 b，c 的联合类型就是 &quot;b&quot; | &quot;c&quot;
</code></pre>
<ul>
<li>通过分析，我们就可以看出 Diff 的作用即可从类型 T 中过滤掉可以赋值给类型 U 的类型</li>
</ul>
<blockquote>
<p>还可以基于 Diff 类型再做扩展，从类型中除去一些我们不需要的类型。如：undefined 和 null</p>
</blockquote>
<pre><code>type Diff&lt;T, U&gt; = T extends U ? never : T;

// 定义一个类型 NotNull，接收一个参数 T
// 然后，利用 Diff 从 T 中过滤掉 undefined 和 null
type NotNull&lt;T&gt; = Diff&lt;T, undefined | null&gt;;

// 定义一个 T5，NotNull 中传入一个联合类型
// 通过 NotNull 类型就可以过滤掉 undefined 和 null，T5 的类型就变为了 string 和 number（鼠标划上 T5 就能看到）
type T5 = NotNull&lt;string | number | undefined | null&gt;;
</code></pre>
<blockquote>
<p>实际上，我们上边实现的两个类型，官方已经为我们实现了，即：一些内置的类型</p>
</blockquote>
<ul>
<li>Diff 的内置类型是 <code>Exclude&lt;T, U&gt;</code>，从类型 T 中过滤掉可以赋值给类型 U 的类型，它的实现和我们上边的实现是一致的</li>
<li>NotNull 的内置类型是<code>NonNullable&lt;T&gt;</code><ul>
<li>在实际使用时，直接调用 <code>Exclude&lt;T, U&gt;</code> 和 <code>NonNullable&lt;T&gt;</code> 这两个内置的类型即可</li>
</ul>
</li>
<li>此外，官方还预制了一些条件类型，如：<code>Extract&lt;T, U&gt;</code> ，该类型与 <code>Exclude&lt;T, U&gt;</code> 相反</li>
</ul>
<blockquote>
<p><code>Extract&lt;T, U&gt;</code> 可以从类型 T 中抽取出可以赋值给 U 的类型</p>
</blockquote>
<pre><code>// Extract 中有两个参数，第一个是 &quot;a&quot; | &quot;b&quot; | &quot;c&quot;，第二个参数是 &quot;a&quot; | &quot;e&quot;
// 这样 T6 的类型就会变成 a，因为它抽取了在 U 中含有的类型 a
type T6 = Extract&lt;&quot;a&quot; | &quot;b&quot; | &quot;c&quot;, &quot;a&quot; | &quot;e&quot;
                 // &gt;
</code></pre>
<ol start="2">
<li>ReturnType<blockquote>
<p><code>ReturnType&lt;T&gt;</code> 可以获取函数返回值的类型</p>
</blockquote>
</li>
</ol>
<pre><code>// 定义一个类型 T7，ReturnType 的参数是一个函数，返回 string
// 此时 T7 的类型就是 string（鼠标划上去即可看到）
type T7 = ReturnType&lt;() =&gt; string&gt;;
</code></pre>
<ul>
<li>按住 Ctrl 键，点击 ReturnType 查看 TS 源码的实现方法<img src="returnType源码.png"></li>
</ul>
<blockquote>
<p>源码实现解读</p>
</blockquote>
<ul>
<li><code>ReturnType</code>要求参数 T 可以被赋值为一个函数，这个函数可以有任意的参数</li>
<li>返回值类型也是任意的（any）</li>
<li>由于返回值类型是不确定的，因此使用了一个 infer 关键字（它的作用表示待推断 或 延迟推断）需要根据实际的情况来确定</li>
<li>如果实际的情况是返回 R 结果类型就是 R ，否则返回值类型就是 any<ul>
<li>以上就是 ReturnType 的实现原理 和 作用</li>
<li>当然 TS 的条件类型还有很多，感兴趣还可以通过 TS 的官方类库查阅 和 学习。</li>
</ul>
</li>
</ul>
<h3 id="五、TS核心基础知识总结"><a href="#五、TS核心基础知识总结" class="headerlink" title="五、TS核心基础知识总结"></a>五、TS核心基础知识总结</h3><h4 id="类型基础"><a href="#类型基础" class="headerlink" title="类型基础"></a>类型基础</h4><table>
<thead>
<tr>
<th>语言类型</th>
<th>描述</th>
<th>举例</th>
</tr>
</thead>
<tbody><tr>
<td>强类型语言</td>
<td>不能改变变量的数据类型，除非进行强制类型转换</td>
<td>Java、C#、Python、C&#x2F;C++</td>
</tr>
<tr>
<td>弱类型语言</td>
<td>能够改变变量的数据类型</td>
<td>JavaScript、PHP</td>
</tr>
<tr>
<td>静态类型语言</td>
<td>在编译阶段确定变量的类型</td>
<td>Java、C#、C&#x2F;C++</td>
</tr>
<tr>
<td>动态类型语言</td>
<td>在执行阶段确定变量的类型</td>
<td>JavaScript、PHP、Python</td>
</tr>
</tbody></table>
<h4 id="基本类型"><a href="#基本类型" class="headerlink" title="基本类型"></a>基本类型</h4><table>
<thead>
<tr>
<th>类型</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>number</td>
<td>数字</td>
</tr>
<tr>
<td>string</td>
<td>字符串</td>
</tr>
<tr>
<td>boolean</td>
<td>布尔</td>
</tr>
<tr>
<td>Array</td>
<td>数组，type[] 、Array<type></td>
</tr>
<tr>
<td>Tuple</td>
<td>元组，限定元素个数与类型的数组</td>
</tr>
<tr>
<td>function</td>
<td>函数</td>
</tr>
<tr>
<td>object</td>
<td>对象</td>
</tr>
<tr>
<td>symbol</td>
<td>符号，独一无二的值</td>
</tr>
<tr>
<td>void</td>
<td>没有类型</td>
</tr>
<tr>
<td>any</td>
<td>任意类型</td>
</tr>
<tr>
<td>undefined</td>
<td>未定义</td>
</tr>
<tr>
<td>null</td>
<td>没有值</td>
</tr>
<tr>
<td>never</td>
<td>永远不存在的值（抛异常、死循环）</td>
</tr>
</tbody></table>
<h4 id="枚举类型"><a href="#枚举类型" class="headerlink" title="枚举类型"></a>枚举类型</h4><table>
<thead>
<tr>
<th>类型</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>数字枚举</td>
<td>枚举成员值默认从 0 递增</td>
</tr>
<tr>
<td>字符串枚举</td>
<td>不支持反向映射</td>
</tr>
<tr>
<td>异构枚举</td>
<td>数字枚举 和 字符串枚举 混用，就构成了 异构枚举（这种情况容易引起混淆。因此不建议使用）</td>
</tr>
<tr>
<td>枚举成员</td>
<td>拥有只读属性 ①、const member（在编译阶段被计算出结果），无初始值、对常量成员的引用、常量表达式 ②、computed member（表达式保留到程序的执行阶段），非常量表达式</td>
</tr>
<tr>
<td>常量枚举</td>
<td>编译后被移除;成员只能为 const member</td>
</tr>
<tr>
<td>枚举 &#x2F; 枚举成员作为类型</td>
<td>①、无初始值 ②、枚举成员均为数字 ③、枚举成员均为字符串</td>
</tr>
</tbody></table>
<h4 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h4><table>
<thead>
<tr>
<th>接口类型</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>对象类型接口</td>
<td>检查原则：鸭式辨型法；绕过对象字面量检查（将对象字面量赋值给变量、使用类型断言、使用字符串索引签名）；对象的属性（可选属性、只读属性）</td>
</tr>
<tr>
<td>可索引类型接口</td>
<td>数字索引（相当于数组）<code>[index: number]</code>；字符串索引 <code>[x: string]</code>；以上两种混用时，数字索引签名的返回值必须是字符串索引签名返回值的子类型</td>
</tr>
<tr>
<td>函数类型接口</td>
<td><code>interface A &#123; (arg: type): type &#125;</code></td>
</tr>
<tr>
<td>混合类型接口</td>
<td><code>interface B &#123; (arg: type): type;prop: type; method(arg: type): type; &#125;</code></td>
</tr>
<tr>
<td>类类型接口</td>
<td>类必须实现接口中的所有属性；接口只能约束类的公有成员，不能约束私有成员、受保护成员、静态成员和构造函数</td>
</tr>
<tr>
<td>接口继承接口</td>
<td>抽离可重用的接口；将多个接口整合成一个接口</td>
</tr>
<tr>
<td>接口继承类</td>
<td>抽象出类的公有成员、私有成员和受保护成员</td>
</tr>
</tbody></table>
<h4 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h4><table>
<thead>
<tr>
<th>分类</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>定义函数</td>
<td>定义方式（function、变量定义、类型别名、接口定义）注：定义函数类型，无函数体；类型要求：参数类型必须声明，返回值类型 ─ 般无需声明</td>
</tr>
<tr>
<td>函数参数</td>
<td>①、参数个数：实参和形参必须 — — 对应 ②、可选参数：必选参数不能位于可选参数后 ③、默认参数：在必选参数前，默认参数不可省略；在必选参数后，默认参数可以省略④、剩余参数</td>
</tr>
<tr>
<td>函数重载</td>
<td>静态类型语言：函数的名称相同，参数的个数或类型不同；TypeScript：预先定义一组名称相同，类型不同的函数声明，并在一个类型最宽松的版本中实现</td>
</tr>
</tbody></table>
<h4 id="类"><a href="#类" class="headerlink" title="类"></a>类</h4><table>
<thead>
<tr>
<th>选项</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>基本实现</td>
<td>①、类中定义的属性都是实例属性，类中定义的方法都是原型方法 ②、实例属性必须有初始值，或在构造函数中被赋值，或为可选成员</td>
</tr>
<tr>
<td>继承</td>
<td>子类的构造函数中必须包含 super 调用</td>
</tr>
<tr>
<td>成员修饰符</td>
<td>①、public：对所有人可见，所有成员默认为 public ②、private：只能在被定义的类中访问，不能通过实例或子类访问（private constructor：不能被实例化，不能被继承） ③、protected：只能在被定义的类和子类中访问，不能通过实例访问（protected constructor：只能被实例化，不能被继承） ④、readonly：必须有初始值，或在构造函数中被赋值 ⑤、static：只能由类名调用，不能通过实例访问，可继承</td>
</tr>
<tr>
<td>构造函数参数中的修饰符</td>
<td>将参数变为实例属性</td>
</tr>
<tr>
<td>抽象类</td>
<td>不能被实例化，只能被继承 ①、抽象方法包含具体实现：子类直接复用 ②、抽象方法不包含具体实现：子类必须实现；多态： 多个子类对父抽象类的方法有不同实现，实现运行时绑定</td>
</tr>
<tr>
<td>this 类型</td>
<td>实现实例方法的链式调用；在继承时，具有多态性，保持父子类之间接口调用的连贯性</td>
</tr>
</tbody></table>
<h4 id="泛型-1"><a href="#泛型-1" class="headerlink" title="泛型"></a>泛型</h4><table>
<thead>
<tr>
<th>类型</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>支持多种类型的方法</td>
<td>①、函数重载 ②、联合类型 ③、any 类型：丢失类型约束 ④、泛型：不预先确定的类型，使用时才确定</td>
</tr>
<tr>
<td>泛型函数</td>
<td>定义：<code>function generic&lt;T&gt;(arg: T): T</code>；调用：<code>generic&lt;type&gt;(arg) 、generic(arg)</code>; 泛型函数类型：<code>type Generic = &lt;T&gt;(arg: T) =&gt; T</code></td>
</tr>
<tr>
<td>泛型接口</td>
<td>定义：<code>interface Generic&lt;T&gt; &#123; (arg: T): T &#125;</code>； 实现：<code>let generic: Generic&lt;type&gt;</code>（必须指定类型）</td>
</tr>
<tr>
<td>泛型类</td>
<td>定义：<code>class Generic&lt;T&gt;&#123; method(value: T) &#125;</code>；泛型不能应用于类的静态成员。实例化：<code>let generic = new Generic&lt;type&gt;()</code>；<code>let generic = new Generic()</code>，T 可为任意类型</td>
</tr>
<tr>
<td>泛型约束</td>
<td><code>T extends U (T 必须具有 U 的属性)</code></td>
</tr>
</tbody></table>
<h4 id="类型检查机制"><a href="#类型检查机制" class="headerlink" title="类型检查机制"></a>类型检查机制</h4><table>
<thead>
<tr>
<th>分类</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>类型推断</td>
<td>含义：根据某些规则自动地为变量推断出类型。①、基础类型推断：初始化变量、设置函数默认参数、确定函数返回值 ②、最佳通用类型推断：推断出一个可以兼容当前所有类型的通用类型 ③、上下文推断：根据事件绑定推断出事件类型</td>
</tr>
<tr>
<td>类型断言</td>
<td>含义：用自己声明的类型覆盖类型推断。方式：表达式 <code>as type</code>， <code>&lt;type&gt;</code> 表达式；弊端：没有按照接口的约定赋值，不会报错</td>
</tr>
<tr>
<td>类型兼容性</td>
<td>含义：如果 X(目标类型) &#x3D; Y(源类型)，则 X 兼容 Y。接口兼容性、函数兼容性、枚举兼容性、类兼容性、泛型兼容性：（见下表）</td>
</tr>
<tr>
<td>类型保护</td>
<td>含义：在特定的区块中保证变量属于某种确定的类型创建区块的方法：①、instanceof ②、typeof ③、in ④、类型保护函数，特殊的返回值：arg is type （类型谓词）</td>
</tr>
</tbody></table>
<blockquote>
<p>类型兼容性</p>
<table>
<thead>
<tr>
<th>兼容性分类</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>接口兼容性</td>
<td>成员少的兼容成员多的（鸭式辨型法）</td>
</tr>
<tr>
<td>函数兼容性</td>
<td>①、参数个数：目标函数多于源函数；可选参数和剩余参数，遵循原则：固定参数兼容可选参数和剩余参数、可选参数不兼容固定参数和剩余参数（严格模式）、剩余参数兼容固定参数和可选参数； ②、参数类型：必须匹配；参数对象：严格模式：成员多的兼容成员少的；非严格模式：相互兼容（函数参数双向协变） ③、返回值类型：目标函数必须与源函数相同，或为其子类型</td>
</tr>
<tr>
<td>枚举兼容性</td>
<td>枚举类型和数字类型相互兼容；枚举类型之间不兼容</td>
</tr>
<tr>
<td>类兼容性</td>
<td>静态成员和构造函数不在比较范围。两个类具有相同的实例成员，它们的实例相互兼容。类中包含私有成员或受保护成员，只有父类和子类的实例相互兼容</td>
</tr>
<tr>
<td>泛型兼容性</td>
<td>泛型接口：只有类型参数 T 被接口成员使用时，才会影响兼容性。泛型函数：定义相同，没有指定类型参数时就兼容</td>
</tr>
</tbody></table>
</blockquote>
<h4 id="高级类型"><a href="#高级类型" class="headerlink" title="高级类型"></a>高级类型</h4><table>
<thead>
<tr>
<th>类型</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>交叉类型（类型并集）</td>
<td>含义：将多个类型合并为一个类型，新的类型将具有所有类型的特性；应用场景：混入</td>
</tr>
<tr>
<td>联合类型（类型交集）</td>
<td>含义：类型并不确定，可能为多个类型中的一个；应用场景：多类型支持；可区分的联合类型：结合联合类型和字面量类型的类型保护方法</td>
</tr>
<tr>
<td>字面量类型</td>
<td>字符串字面量；数字字面量；应用场景：限定变量取值范围</td>
</tr>
<tr>
<td>索引类型</td>
<td>要点：①、keyof T（索引查询操作符）：类型 T 公共属性名的字面量联合类型 ②、T[K]（索引访问操作符）：对象 T 的属性 K 所代表的类型 ③、泛型约束；应用场景： 从一个对象中选取某些属性的值</td>
</tr>
<tr>
<td>映射类型</td>
<td>含义： 从旧类型创建出新类型。应用场景：<code>Readonly&lt;T&gt;</code>：将 T 的所有属性变为只读；<code>Partial&lt;T&gt;</code>：将 T 的所有属性变为可选；<code>Pick&lt;T, K&gt;</code>：选取以 K 为属性的对象 T 的子集；<code>Record&lt;K, T&gt;</code>：创新属性为 K 的新对象，属性值的类型为 T。同态： 只作用于 T 的属性</td>
</tr>
<tr>
<td>条件类型</td>
<td>含义：T extends U ? X : Y （如果类型 T 可以赋值给类型 U，那么结果类型就是 X，否则就是 Y）。应用场景：①、<code>Exclude&lt;T, U&gt;</code>：从 T 中过滤掉可以赋值给 U 的类型 ②、<code>Extract&lt;T, U&gt;</code>：从 T 中抽取出可以赋值给 U 的类型 ③、<code>NonNullable&lt;T&gt;</code>：从 T 中除去 undefined 和 null ④、<code>ReturnType&lt;T&gt;</code>：获取函数的返回值类型</td>
</tr>
</tbody></table>

                
            </div>
            <hr/>

            

    <div class="reprint" id="reprint-statement">
        
            <div class="reprint__author">
                <span class="reprint-meta" style="font-weight: bold;">
                    <i class="fas fa-user">
                        文章作者:
                    </i>
                </span>
                <span class="reprint-info">
                    <a href="/about" rel="external nofollow noreferrer">hermia</a>
                </span>
            </div>
            <div class="reprint__type">
                <span class="reprint-meta" style="font-weight: bold;">
                    <i class="fas fa-link">
                        文章链接:
                    </i>
                </span>
                <span class="reprint-info">
                    <a href="https://hermiablog.com/2024/02/06/TypeScript%EF%BC%88%E4%BA%94%EF%BC%89/">https://hermiablog.com/2024/02/06/TypeScript%EF%BC%88%E4%BA%94%EF%BC%89/</a>
                </span>
            </div>
            <div class="reprint__notice">
                <span class="reprint-meta" style="font-weight: bold;">
                    <i class="fas fa-copyright">
                        版权声明:
                    </i>
                </span>
                <span class="reprint-info">
                    本博客所有文章除特別声明外，均采用
                    <a href="https://creativecommons.org/licenses/by/4.0/deed.zh" rel="external nofollow noreferrer" target="_blank">CC BY 4.0</a>
                    许可协议。转载请注明来源
                    <a href="/about" target="_blank">hermia</a>
                    !
                </span>
            </div>
        
    </div>

    <script async defer>
      document.addEventListener("copy", function (e) {
        let toastHTML = '<span>复制成功，请遵循本文的转载规则</span><button class="btn-flat toast-action" onclick="navToReprintStatement()" style="font-size: smaller">查看</a>';
        M.toast({html: toastHTML})
      });

      function navToReprintStatement() {
        $("html, body").animate({scrollTop: $("#reprint-statement").offset().top - 80}, 800);
      }
    </script>



            <div class="tag_share" style="display: block;">
                <div class="post-meta__tag-list" style="display: inline-block;">
                    
                        <div class="article-tag">
                            
                                <a href="/tags/TypesSript/">
                                    <span class="chip bg-color">TypesSript</span>
                                </a>
                            
                        </div>
                    
                </div>
                <div class="post_share" style="zoom: 80%; width: fit-content; display: inline-block; float: right; margin: -0.15rem 0;">
                    <link rel="stylesheet" type="text/css" href="/libs/share/css/share.min.css">
<div id="article-share">

    
    <div class="social-share" data-sites="qq,qzone,wechat,weibo" data-wechat-qrcode-helper="<p>微信扫一扫即可分享！</p>"></div>
    <script src="/libs/share/js/social-share.min.js"></script>
    

    

</div>

                </div>
            </div>
            
                <style>
    #reward {
        margin: 40px 0;
        text-align: center;
    }

    #reward .reward-link {
        font-size: 1.4rem;
        line-height: 38px;
    }

    #reward .btn-floating:hover {
        box-shadow: 0 6px 12px rgba(0, 0, 0, 0.2), 0 5px 15px rgba(0, 0, 0, 0.2);
    }

    #rewardModal {
        width: 320px;
        height: 350px;
    }

    #rewardModal .reward-title {
        margin: 15px auto;
        padding-bottom: 5px;
    }

    #rewardModal .modal-content {
        padding: 10px;
    }

    #rewardModal .close {
        position: absolute;
        right: 15px;
        top: 15px;
        color: rgba(0, 0, 0, 0.5);
        font-size: 1.3rem;
        line-height: 20px;
        cursor: pointer;
    }

    #rewardModal .close:hover {
        color: #ef5350;
        transform: scale(1.3);
        -moz-transform:scale(1.3);
        -webkit-transform:scale(1.3);
        -o-transform:scale(1.3);
    }

    #rewardModal .reward-tabs {
        margin: 0 auto;
        width: 210px;
    }

    .reward-tabs .tabs {
        height: 38px;
        margin: 10px auto;
        padding-left: 0;
    }

    .reward-content ul {
        padding-left: 0 !important;
    }

    .reward-tabs .tabs .tab {
        height: 38px;
        line-height: 38px;
    }

    .reward-tabs .tab a {
        color: #fff;
        background-color: #ccc;
    }

    .reward-tabs .tab a:hover {
        background-color: #ccc;
        color: #fff;
    }

    .reward-tabs .wechat-tab .active {
        color: #fff !important;
        background-color: #22AB38 !important;
    }

    .reward-tabs .alipay-tab .active {
        color: #fff !important;
        background-color: #019FE8 !important;
    }

    .reward-tabs .reward-img {
        width: 210px;
        height: 210px;
    }
</style>

<div id="reward">
    <a href="#rewardModal" class="reward-link modal-trigger btn-floating btn-medium waves-effect waves-light red">赏</a>

    <!-- Modal Structure -->
    <div id="rewardModal" class="modal">
        <div class="modal-content">
            <a class="close modal-close"><i class="fas fa-times"></i></a>
            <h4 class="reward-title">你的赏识是我前进的动力</h4>
            <div class="reward-content">
                <div class="reward-tabs">
                    <ul class="tabs row">
                        <li class="tab col s6 alipay-tab waves-effect waves-light"><a href="#alipay">支付宝</a></li>
                        <li class="tab col s6 wechat-tab waves-effect waves-light"><a href="#wechat">微 信</a></li>
                    </ul>
                    <div id="alipay">
                        <img src="/medias/reward/alipay.jpg" class="reward-img" alt="支付宝打赏二维码">
                    </div>
                    <div id="wechat">
                        <img src="/medias/reward/wechat.png" class="reward-img" alt="微信打赏二维码">
                    </div>
                </div>
            </div>
        </div>
    </div>
</div>

<script>
    $(function () {
        $('.tabs').tabs();
    });
</script>

            
        </div>
    </div>

    

    

    

    

    

    

    

    

<article id="prenext-posts" class="prev-next articles">
    <div class="row article-row">
        
        <div class="article col s12 m6" data-aos="fade-up">
            <div class="article-badge left-badge text-color">
                <i class="fas fa-chevron-left"></i>&nbsp;上一篇</div>
            <div class="card">
                <a href="/2024/02/07/TypeScript%EF%BC%88%E5%85%AD%EF%BC%89/">
                    <div class="card-image">
                        
                        <img src="/medias/featureimages/57.jpg" class="responsive-img" alt="TypeScript（六）">
                        
                        <span class="card-title">TypeScript（六）</span>
                    </div>
                </a>
                <div class="card-content article-content">
                    <div class="summary block-with-text">
                        
                            模块、命名空间、关键字、类型声明文件、类型运算符、类型映射、类型工具
                        
                    </div>
                    <div class="publish-info">
                        <span class="publish-date">
                            <i class="far fa-clock fa-fw icon-date"></i>2024-02-07
                        </span>
                        <span class="publish-author">
                            
                            <i class="fas fa-bookmark fa-fw icon-category"></i>
                            
                            <a href="/categories/%E6%8A%80%E6%9C%AF/" class="post-category">
                                    技术
                                </a>
                            
                            
                        </span>
                    </div>
                </div>
                
                <div class="card-action article-tags">
                    
                    <a href="/tags/TypesSript/">
                        <span class="chip bg-color">TypesSript</span>
                    </a>
                    
                </div>
                
            </div>
        </div>
        
        
        <div class="article col s12 m6" data-aos="fade-up">
            <div class="article-badge right-badge text-color">
                下一篇&nbsp;<i class="fas fa-chevron-right"></i>
            </div>
            <div class="card">
                <a href="/2024/02/06/TypeScript%EF%BC%88%E5%9B%9B%EF%BC%89/">
                    <div class="card-image">
                        
                        <img src="/medias/featureimages/54.jpg" class="responsive-img" alt="TypesSript（四）">
                        
                        <span class="card-title">TypesSript（四）</span>
                    </div>
                </a>
                <div class="card-content article-content">
                    <div class="summary block-with-text">
                        
                            class类型
                        
                    </div>
                    <div class="publish-info">
                            <span class="publish-date">
                                <i class="far fa-clock fa-fw icon-date"></i>2024-02-06
                            </span>
                        <span class="publish-author">
                            
                            <i class="fas fa-bookmark fa-fw icon-category"></i>
                            
                            <a href="/categories/%E6%8A%80%E6%9C%AF/" class="post-category">
                                    技术
                                </a>
                            
                            
                        </span>
                    </div>
                </div>
                
                <div class="card-action article-tags">
                    
                    <a href="/tags/TypesSript/">
                        <span class="chip bg-color">TypesSript</span>
                    </a>
                    
                </div>
                
            </div>
        </div>
        
    </div>
</article>

</div>



<!-- 代码块功能依赖 -->
<script type="text/javascript" src="/libs/codeBlock/codeBlockFuction.js"></script>

<!-- 代码语言 -->

<script type="text/javascript" src="/libs/codeBlock/codeLang.js"></script>


<!-- 代码块复制 -->

<script type="text/javascript" src="/libs/codeBlock/codeCopy.js"></script>


<!-- 代码块收缩 -->

<script type="text/javascript" src="/libs/codeBlock/codeShrink.js"></script>


  </div>
  <div id="toc-aside" class="expanded col l3 hide-on-med-and-down">
    <div class="toc-widget card" style="background-color: white">
      <div class="toc-title">
        <i class="far fa-list-alt"></i>&nbsp;&nbsp;目录
      </div>
      <div id="toc-content"></div>
    </div>
  </div>
</div>

<!-- TOC 悬浮按钮. -->

<div id="floating-toc-btn" class="hide-on-med-and-down">
  <a class="btn-floating btn-large bg-color">
    <i class="fas fa-list-ul"></i>
  </a>
</div>


<script src="/libs/tocbot/tocbot.min.js"></script>
<script>
  $(function () {
      tocbot.init({
          tocSelector: '#toc-content',
          contentSelector: '#articleContent',
          headingsOffset: -($(window).height() * 0.4 - 45),
          collapseDepth: Number('0'),
          headingSelector: 'h2, h3, h4'
      });

      // modify the toc link href to support Chinese.
      let i = 0;
      let tocHeading = 'toc-heading-';
      $('#toc-content a').each(function () {
          $(this).attr('href', '#' + tocHeading + (++i));
      });

      // modify the heading title id to support Chinese.
      i = 0;
      $('#articleContent').children('h2, h3, h4').each(function () {
          $(this).attr('id', tocHeading + (++i));
      });

      // Set scroll toc fixed.
      let tocHeight = parseInt($(window).height() * 0.4 - 64);
      let $tocWidget = $('.toc-widget');
      $(window).scroll(function () {
          let scroll = $(window).scrollTop();
          /* add post toc fixed. */
          if (scroll > tocHeight) {
              $tocWidget.addClass('toc-fixed');
          } else {
              $tocWidget.removeClass('toc-fixed');
          }
      });

      
      /* 修复文章卡片 div 的宽度. */
      let fixPostCardWidth = function (srcId, targetId) {
          let srcDiv = $('#' + srcId);
          if (srcDiv.length === 0) {
              return;
          }

          let w = srcDiv.width();
          if (w >= 450) {
              w = w + 21;
          } else if (w >= 350 && w < 450) {
              w = w + 18;
          } else if (w >= 300 && w < 350) {
              w = w + 16;
          } else {
              w = w + 14;
          }
          $('#' + targetId).width(w);
      };

      // 切换TOC目录展开收缩的相关操作.
      const expandedClass = 'expanded';
      let $tocAside = $('#toc-aside');
      let $mainContent = $('#main-content');
      $('#floating-toc-btn .btn-floating').click(function () {
          if ($tocAside.hasClass(expandedClass)) {
              $tocAside.removeClass(expandedClass).hide();
              $mainContent.removeClass('l9');
          } else {
              $tocAside.addClass(expandedClass).show();
              $mainContent.addClass('l9');
          }
          fixPostCardWidth('artDetail', 'prenext-posts');
      });
      
  });
</script>

    

</main>




    <footer class="page-footer bg-color">
   <link rel="stylesheet" href="/libs/aplayer/APlayer.min.css">
<style>
    .aplayer .aplayer-lrc p {
        
        font-size: 12px;
        font-weight: 700;
        line-height: 16px !important;
    }

    .aplayer .aplayer-lrc p.aplayer-lrc-current {
        
        font-size: 15px;
        color: #a3ddf0;
        /* color: #59cde9; */
    }

    
    .aplayer.aplayer-fixed.aplayer-narrow .aplayer-body {
        left: -66px !important;
    }

    .aplayer.aplayer-fixed.aplayer-narrow .aplayer-body:hover {
        left: 0px !important;
    }

    
</style>
<div class="">
    
    <div class="row">
        <meting-js class="col l8 offset-l2 m10 offset-m1 s12"
                   server="netease"
                   type="playlist"
                   id="2450546498"
                   fixed='true'
                   autoplay='false'
                   theme='#59cde9'
                   loop='all'
                   order='random'
                   preload='auto'
                   volume='0.7'
                   list-folded='true'
        >
        </meting-js>
    </div>
</div>

<script src="/libs/aplayer/APlayer.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/meting@2/dist/Meting.min.js"></script>
 
  <div
    class="container row center-align"
    style="margin-bottom: 15px !important;"
  >
    <div class="col s12 m8 l8 copy-right">
      Copyright&nbsp;&copy; 
      <span id="year"
        >2023-2024</span
      >
      
      <span id="year">2023</span>
      <a href="/about" target="_blank"
        >hermia</a
      >
      |&nbsp;Powered by&nbsp;<a href="https://hexo.io/" target="_blank">Hexo</a>
      |&nbsp;Theme&nbsp;<a
        href="https://github.com/blinkfox/hexo-theme-matery"
        target="_blank"
        >Matery</a
      >
      <br />
           
      <span id="busuanzi_container_site_pv">
        |&nbsp;<i class="far fa-eye"></i>&nbsp;总访问量:&nbsp;<span
          id="busuanzi_value_site_pv"
          class="white-color"
        ></span
        >&nbsp;次
      </span>
       
      <span id="busuanzi_container_site_uv">
        |&nbsp;<i class="fas fa-users"></i>&nbsp;总访问人数:&nbsp;<span
          id="busuanzi_value_site_uv"
          class="white-color"
        ></span
        >&nbsp;人
      </span>
      
      <br />
      
      <span id="sitetime">载入运行时间...</span>
      <script>
        function siteTime() {
          var seconds = 1000;
          var minutes = seconds * 60;
          var hours = minutes * 60;
          var days = hours * 24;
          var years = days * 365;
          var today = new Date();
          var startYear = "2023";
          var startMonth = "11";
          var startDate = "14";
          var startHour = "0";
          var startMinute = "0";
          var startSecond = "0";
          var todayYear = today.getFullYear();
          var todayMonth = today.getMonth() + 1;
          var todayDate = today.getDate();
          var todayHour = today.getHours();
          var todayMinute = today.getMinutes();
          var todaySecond = today.getSeconds();
          var t1 = Date.UTC(
            startYear,
            startMonth,
            startDate,
            startHour,
            startMinute,
            startSecond
          );
          var t2 = Date.UTC(
            todayYear,
            todayMonth,
            todayDate,
            todayHour,
            todayMinute,
            todaySecond
          );
          var diff = t2 - t1;
          var diffYears = Math.floor(diff / years);
          var diffDays = Math.floor(diff / days - diffYears * 365);
          var diffHours = Math.floor(
            (diff - (diffYears * 365 + diffDays) * days) / hours
          );
          var diffMinutes = Math.floor(
            (diff - (diffYears * 365 + diffDays) * days - diffHours * hours) /
              minutes
          );
          var diffSeconds = Math.floor(
            (diff -
              (diffYears * 365 + diffDays) * days -
              diffHours * hours -
              diffMinutes * minutes) /
              seconds
          );
          if (startYear == todayYear) {
            document.getElementById("year").innerHTML = todayYear;
            document.getElementById("sitetime").innerHTML =
              "本站已安全运行 " +
              diffDays +
              " 天 " +
              diffHours +
              " 小时 " +
              diffMinutes +
              " 分钟 " +
              diffSeconds +
              " 秒";
          } else {
            document.getElementById("year").innerHTML =
              startYear + " - " + todayYear;
            document.getElementById("sitetime").innerHTML =
              "本站已安全运行 " +
              diffYears +
              " 年 " +
              diffDays +
              " 天 " +
              diffHours +
              " 小时 " +
              diffMinutes +
              " 分钟 " +
              diffSeconds +
              " 秒";
          }
        }
        setInterval(siteTime, 1000);
      </script>
      
      <br />
      
    </div>
    <div class="col s12 m4 l4 social-link social-statis">
      
<a
  href="https://github.com/hermiablog/hermiablog.github.io"
  class="tooltipped"
  target="_blank"
  data-tooltip="访问我的GitHub"
  data-position="top"
  data-delay="50"
>
  <i class="fab fa-github"></i>
</a>
 
<a
  href="mailto:1587837237@qq.com"
  class="tooltipped"
  target="_blank"
  data-tooltip="邮件联系我"
  data-position="top"
  data-delay="50"
>
  <i class="fas fa-envelope-open"></i>
</a>
<!-- 
   
<a
  href="tencent://AddContact/?fromId=50&fromSubId=1&subcmd=all&uin=1587837237"
  class="tooltipped"
  target="_blank"
  data-tooltip="QQ联系我: 1587837237"
  data-position="top"
  data-delay="50"
>
  <i class="fab fa-qq"></i>
</a>
    -->

    </div>
  </div>
</footer>

<div class="progress-bar"></div>


    <!-- 搜索遮罩框 -->
<div id="searchModal" class="modal">
    <div class="modal-content">
        <div class="search-header">
            <span class="title"><i class="fas fa-search"></i>&nbsp;&nbsp;搜索</span>
            <input type="search" id="searchInput" name="s" placeholder="请输入搜索的关键字"
                   class="search-input">
        </div>
        <div id="searchResult"></div>
    </div>
</div>

<script type="text/javascript">
$(function () {
    var searchFunc = function (path, search_id, content_id) {
        'use strict';
        $.ajax({
            url: path,
            dataType: "xml",
            success: function (xmlResponse) {
                // get the contents from search data
                var datas = $("entry", xmlResponse).map(function () {
                    return {
                        title: $("title", this).text(),
                        content: $("content", this).text(),
                        url: $("url", this).text()
                    };
                }).get();
                var $input = document.getElementById(search_id);
                var $resultContent = document.getElementById(content_id);
                $input.addEventListener('input', function () {
                    var str = '<ul class=\"search-result-list\">';
                    var keywords = this.value.trim().toLowerCase().split(/[\s\-]+/);
                    $resultContent.innerHTML = "";
                    if (this.value.trim().length <= 0) {
                        return;
                    }
                    // perform local searching
                    datas.forEach(function (data) {
                        var isMatch = true;
                        var data_title = data.title.trim().toLowerCase();
                        var data_content = data.content.trim().replace(/<[^>]+>/g, "").toLowerCase();
                        var data_url = data.url;
                        data_url = data_url.indexOf('/') === 0 ? data.url : '/' + data_url;
                        var index_title = -1;
                        var index_content = -1;
                        var first_occur = -1;
                        // only match artiles with not empty titles and contents
                        if (data_title !== '' && data_content !== '') {
                            keywords.forEach(function (keyword, i) {
                                index_title = data_title.indexOf(keyword);
                                index_content = data_content.indexOf(keyword);
                                if (index_title < 0 && index_content < 0) {
                                    isMatch = false;
                                } else {
                                    if (index_content < 0) {
                                        index_content = 0;
                                    }
                                    if (i === 0) {
                                        first_occur = index_content;
                                    }
                                }
                            });
                        }
                        // show search results
                        if (isMatch) {
                            str += "<li><a href='" + data_url + "' class='search-result-title'>" + data_title + "</a>";
                            var content = data.content.trim().replace(/<[^>]+>/g, "");
                            if (first_occur >= 0) {
                                // cut out 100 characters
                                var start = first_occur - 20;
                                var end = first_occur + 80;
                                if (start < 0) {
                                    start = 0;
                                }
                                if (start === 0) {
                                    end = 100;
                                }
                                if (end > content.length) {
                                    end = content.length;
                                }
                                var match_content = content.substr(start, end);
                                // highlight all keywords
                                keywords.forEach(function (keyword) {
                                    var regS = new RegExp(keyword, "gi");
                                    match_content = match_content.replace(regS, "<em class=\"search-keyword\">" + keyword + "</em>");
                                });

                                str += "<p class=\"search-result\">" + match_content + "...</p>"
                            }
                            str += "</li>";
                        }
                    });
                    str += "</ul>";
                    $resultContent.innerHTML = str;
                });
            }
        });
    };

    searchFunc('/search.xml', 'searchInput', 'searchResult');
});
</script>

    <!-- 回到顶部按钮 -->
<div id="backTop" class="top-scroll">
    <a class="btn-floating btn-large waves-effect waves-light" href="#!">
        <i class="fas fa-arrow-up"></i>
    </a>
</div>


    <script src="/libs/materialize/materialize.min.js"></script>
    <script src="/libs/masonry/masonry.pkgd.min.js"></script>
    <script src="/libs/aos/aos.js"></script>
    <script src="/libs/scrollprogress/scrollProgress.min.js"></script>
    <script src="/libs/lightGallery/js/lightgallery-all.min.js"></script>
    <script src="/js/matery.js"></script>

    <!-- Baidu Analytics -->

    <!-- Baidu Push -->

<script>
    (function () {
        var bp = document.createElement('script');
        var curProtocol = window.location.protocol.split(':')[0];
        if (curProtocol === 'https') {
            bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';
        } else {
            bp.src = 'http://push.zhanzhang.baidu.com/push.js';
        }
        var s = document.getElementsByTagName("script")[0];
        s.parentNode.insertBefore(bp, s);
    })();
</script>

    
    <script src="/libs/others/clicklove.js" async="async"></script>
    
    
    <script async src="/libs/others/busuanzi.pure.mini.js"></script>
    

    

    

	
    

    

    

    
    <script src="/libs/instantpage/instantpage.js" type="module"></script>
    

</body>

</html>
