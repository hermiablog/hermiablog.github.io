<!DOCTYPE HTML>
<html lang="zh-CN">


<head>
    <meta charset="utf-8">
    <meta name="keywords" content="网络（一）, 技术博客">
    <meta name="description" content="个人技术博客">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <meta name="renderer" content="webkit|ie-stand|ie-comp">
    <meta name="mobile-web-app-capable" content="yes">
    <meta name="format-detection" content="telephone=no">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <!-- Global site tag (gtag.js) - Google Analytics -->


    <title>网络（一） | hermia&#39;s blog</title>
    <link rel="icon" type="image/png" href="/favicon.png">

    <link rel="stylesheet" type="text/css" href="/libs/awesome/css/all.css">
    <link rel="stylesheet" type="text/css" href="/libs/materialize/materialize.min.css">
    <link rel="stylesheet" type="text/css" href="/libs/aos/aos.css">
    <link rel="stylesheet" type="text/css" href="/libs/animate/animate.min.css">
    <link rel="stylesheet" type="text/css" href="/libs/lightGallery/css/lightgallery.min.css">
    <link rel="stylesheet" type="text/css" href="/css/matery.css">
    <link rel="stylesheet" type="text/css" href="/css/my.css">

    <script src="/libs/jquery/jquery.min.js"></script>

<meta name="generator" content="Hexo 6.3.0"><link rel="stylesheet" href="/css/prism-tomorrow.css" type="text/css"></head>



   <style>
    body{
       background-image: url(https://cdn.pixabay.com/photo/2012/04/14/16/37/sky-34536_1280.png);
       background-repeat:no-repeat;
       background-size:cover;
       background-attachment:fixed;
    }
</style>



<body>
    <header class="navbar-fixed">
    <nav id="headNav" class="bg-color nav-transparent">
        <div id="navContainer" class="nav-wrapper container">
            <div class="brand-logo">
                <a href="/" class="waves-effect waves-light">
                    
                    <img src="/medias/logo.png" class="logo-img" alt="LOGO">
                    
                    <span class="logo-span">hermia&#39;s blog</span>
                </a>
            </div>
            

<a href="#" data-target="mobile-nav" class="sidenav-trigger button-collapse"><i class="fas fa-bars"></i></a>
<ul class="right nav-menu">
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/" class="waves-effect waves-light">
      
      <i class="fas fa-home" style="zoom: 0.6;"></i>
      
      <span>首页</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/tags" class="waves-effect waves-light">
      
      <i class="fas fa-tags" style="zoom: 0.6;"></i>
      
      <span>标签</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/categories" class="waves-effect waves-light">
      
      <i class="fas fa-bookmark" style="zoom: 0.6;"></i>
      
      <span>分类</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/archives" class="waves-effect waves-light">
      
      <i class="fas fa-archive" style="zoom: 0.6;"></i>
      
      <span>归档</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/about" class="waves-effect waves-light">
      
      <i class="fas fa-user-circle" style="zoom: 0.6;"></i>
      
      <span>关于</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/friends" class="waves-effect waves-light">
      
      <i class="fas fa-address-book" style="zoom: 0.6;"></i>
      
      <span>友情链接</span>
    </a>
    
  </li>
  
  <li>
    <a href="#searchModal" class="modal-trigger waves-effect waves-light">
      <i id="searchIcon" class="fas fa-search" title="搜索" style="zoom: 0.85;"></i>
    </a>
  </li>
</ul>


<div id="mobile-nav" class="side-nav sidenav">

    <div class="mobile-head bg-color">
        
        <img src="/medias/logo.png" class="logo-img circle responsive-img">
        
        <div class="logo-name">hermia&#39;s blog</div>
        <div class="logo-desc">
            
            个人技术博客
            
        </div>
    </div>

    

    <ul class="menu-list mobile-menu-list">
        
        <li class="m-nav-item">
	  
		<a href="/" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-home"></i>
			
			首页
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/tags" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-tags"></i>
			
			标签
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/categories" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-bookmark"></i>
			
			分类
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/archives" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-archive"></i>
			
			归档
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/about" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-user-circle"></i>
			
			关于
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/friends" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-address-book"></i>
			
			友情链接
		</a>
          
        </li>
        
        
    </ul>
</div>


        </div>

        
    </nav>

</header>

    



<div class="bg-cover pd-header post-cover" style="background-image: url('/medias/featureimages/39.jpg')">
    <div class="container" style="right: 0px;left: 0px;">
        <div class="row">
            <div class="col s12 m12 l12">
                <div class="brand">
                    <h1 class="description center-align post-title">网络（一）</h1>
                </div>
            </div>
        </div>
    </div>
</div>




<main class="post-container content">

    
    <link
  rel="stylesheet"
  href="/libs/tocbot/tocbot.css"
/>
<style>
  #articleContent h1::before,
  #articleContent h2::before,
  #articleContent h3::before,
  #articleContent h4::before,
  #articleContent h5::before,
  #articleContent h6::before {
    display: block;
    content: " ";
    height: 100px;
    margin-top: -100px;
    visibility: hidden;
  }

  #articleContent :focus {
    outline: none;
  }

  .toc-fixed {
    position: fixed;
    top: 64px;
  }

  /* .toc-widget {
        width: 345px;
        padding-left: 20px;
    } */
  .toc-widget {
    width: 345px;
    padding-left: 20px;
    background-color: rgb(255, 255, 255, 0.7);
    border-radius: 10px;
    box-shadow: 0 10px 35px 2px rgba(0, 0, 0, 0.15),
      0 5px 15px rgba(0, 0, 0, 0.07), 0 2px 5px -5px rgba(0, 0, 0, 0.1) !important;
  }

  .toc-widget .toc-title {
    padding: 35px 0 15px 17px;
    font-size: 1.5rem;
    font-weight: bold;
    line-height: 1.5rem;
  }

  .toc-widget ol {
    padding: 0;
    list-style: none;
  }

  #toc-content {
    padding-bottom: 30px;
    overflow: auto;
  }

  #toc-content ol {
    padding-left: 10px;
  }

  #toc-content ol li {
    padding-left: 10px;
  }

  #toc-content .toc-link:hover {
    color: #a3ddf0;
    font-weight: 700;
    text-decoration: underline;
  }

  #toc-content .toc-link::before {
    background-color: transparent;
    max-height: 25px;

    position: absolute;
    right: 23.5vw;
    display: block;
  }

  #toc-content .is-active-link {
    color: #a3ddf0;
  }

  #floating-toc-btn {
    position: fixed;
    right: 15px;
    bottom: 76px;
    padding-top: 15px;
    margin-bottom: 0;
    z-index: 998;
  }

  #floating-toc-btn .btn-floating {
    width: 48px;
    height: 48px;
  }

  #floating-toc-btn .btn-floating i {
    line-height: 48px;
    font-size: 1.4rem;
  }
</style>
<div class="row">
  <div id="main-content" class="col s12 m12 l9">
    <!-- 文章内容详情 -->
<div id="artDetail">
    <div class="card">
        <div class="card-content article-info">
            <div class="row tag-cate">
                <div class="col s7">
                    
                    <div class="article-tag">
                        
                            <a href="/tags/%E7%BD%91%E7%BB%9C/">
                                <span class="chip bg-color">网络</span>
                            </a>
                        
                    </div>
                    
                </div>
                <div class="col s5 right-align">
                    
                    <div class="post-cate">
                        <i class="fas fa-bookmark fa-fw icon-category"></i>
                        
                            <a href="/categories/%E6%8A%80%E6%9C%AF/" class="post-category">
                                技术
                            </a>
                        
                    </div>
                    
                </div>
            </div>

            <div class="post-info">
                
                <div class="post-date info-break-policy">
                    <i class="far fa-calendar-minus fa-fw"></i>发布日期:&nbsp;&nbsp;
                    2024-01-18
                </div>
                

                
                <div class="post-date info-break-policy">
                    <i class="far fa-calendar-check fa-fw"></i>更新日期:&nbsp;&nbsp;
                    2024-01-20
                </div>
                

                
                <div class="info-break-policy">
                    <i class="far fa-file-word fa-fw"></i>文章字数:&nbsp;&nbsp;
                    15k
                </div>
                

                

                
            </div>
        </div>
        <hr class="clearfix">

        

        

        <div class="card-content article-card-content">
            <div id="articleContent">
                <span id="more"></span>
<h2 id="前后端数据交互、HTTP-协议"><a href="#前后端数据交互、HTTP-协议" class="headerlink" title="前后端数据交互、HTTP 协议"></a>前后端数据交互、HTTP 协议</h2><h3 id="一、前后端通信"><a href="#一、前后端通信" class="headerlink" title="一、前后端通信"></a>一、前后端通信</h3><ol>
<li><p>前后端通信是什么 ？</p>
<blockquote>
<ul>
<li>前后端通信指：前端和后端数据交互的过程。即 <strong>浏览器和服务器</strong>之间数据交互的过程。<br><strong>为什么需要前后端通信</strong></li>
<li>因为，不论前端还是后端，它们彼此都离不开对方。有时前端需要后端发送过来的数据，有时后端也需要前端发送来的数据。所以，前后端通信就是前端和后端各取所需的一个过程。</li>
</ul>
</blockquote>
</li>
<li><p>后端向前端发送数据</p>
<blockquote>
<p>如：访问一个网页</p>
<ul>
<li>打开任意在线网页后，如：<a target="_blank" rel="noopener" href="https://www.icodingedu.com/">https://www.icodingedu.com/</a></li>
<li>在浏览器中按 “F12” 或 右键 检查元素，打开浏览器的开发者工具</li>
<li>将面板切换至 “Network” -&gt; 刷新网页，注意观察发生了什么</li>
</ul>
</blockquote>
</li>
</ol>
<blockquote>
<p>在<strong>刷新网页</strong>的过程中，浏览器和服务器之间就完成了一次通信，也就是完成一次数据之间的交互。</p>
<ul>
<li>这里主要是后端向前端发送的数据，包括：HTML 文件、CSS、JS、图片 等，我们只要能够看到的都是后端发送过来的。因为浏览器要想展示一个网页给到用户查看，就需要当前网页相关的文件，而这些文件本身就保存在服务器中的。</li>
<li>当我们通过网址访问网页的时候，这时浏览器和服务器就会展开通信，浏览器向服务器请求网页相关文件，服务器就会将浏览器请求的东西发送给它，然后就会通过这些文件进行渲染和展示网页了。<blockquote>
<p>这就是典型的 <strong>后端向前端发送数据</strong> 的应用</p>
</blockquote>
</li>
</ul>
</blockquote>
<ol start="3">
<li>前端向后端发送数据<blockquote>
<p>典型应用场景，用户登录注册、站内搜索、表单提交等</p>
</blockquote>
</li>
</ol>
<ul>
<li>用户登录，前端向后端发送数据<blockquote>
<ul>
<li>用户输入用户名、密码，点击 “登录” 后，数据就会被发送到后端；</li>
<li>后端收到数据后，就会判断用户名、密码是否正确，然后将判断结果告诉前端；</li>
<li>前端拿到返回的结果后，就可以进一步操作了，比如：跳转到登录前的页面。</li>
</ul>
</blockquote>
</li>
</ul>
<ol start="4">
<li>前后端通信的过程<blockquote>
<p>首先我们需要明白，地球不是围绕着某一个人转的。同理 服务器也不是围绕着某一个浏览器来转的，它可以服务相当多的浏览器。</p>
<p>也就是说浏览器和服务器通信时，<strong>一般情况下都是浏览器主动联系服务器</strong>。如：一般都是你主动打电话给 110 报警，没见过 110 主动打电话给你来接警的，是一个道理。</p>
<ul>
<li>所以，在服务器和浏览器之前通信的时候，是有一个主动和被动的关系。如下图所示</li>
<li>需要通信时，浏览器就会<strong>主动发送一个请求</strong>给到服务器，如果有数据也会在请求中把数据携带上</li>
<li>服务器在接收到请求后，会<strong>按照请求给出响应</strong>（即：回应浏览器的请求），如果服务端有数据也会在随着响应一起发送到浏览器端</li>
</ul>
</blockquote>
</li>
</ol>
<ul>
<li>前后端通信是在 “请求 - 响应” 中完成的<img src="前后端通信过程.png"></li>
</ul>
<ol start="5">
<li>基础概念的理解<blockquote>
<ul>
<li>前端：浏览器端</li>
<li>客户端：只要能和服务器通信的就叫客户端<blockquote>
<p>如：命令行工具（客户端），输入 <code>curl https://www.icodingedu.com/</code>；包括我们日常，安装的很多 桌面端软件，基本都属于 客户端</p>
</blockquote>
</li>
<li>后端：服务器端</li>
</ul>
</blockquote>
</li>
</ol>
<h3 id="二、前后端的通信方式"><a href="#二、前后端的通信方式" class="headerlink" title="二、前后端的通信方式"></a>二、前后端的通信方式</h3><ol>
<li><p>使用浏览器访问网页</p>
<blockquote>
<ul>
<li>在浏览器地址栏输入网址，按下回车</li>
<li>在打开网页的过程中，浏览器和服务器之间就完成了一次通信</li>
</ul>
</blockquote>
</li>
<li><p>解析 HTML 标签</p>
</li>
</ol>
<ul>
<li><p>浏览器在解析 <code>HTML</code> 标签的时候，遇到一些特殊的标签，<strong>会再次</strong>向服务器发送请求。</p>
<blockquote>
<p>如下标签：</p>
<ul>
<li><code>&lt;link&gt;</code> 标签</li>
<li><code>&lt;img&gt;</code> 标签</li>
<li><code>&lt;script&gt; &lt;/script&gt;</code> 标签 ，如 ：使用 JSONP 跨域，就会用到 script 标签</li>
<li><code>&lt;iframe&gt;</code> 标签</li>
</ul>
</blockquote>
</li>
<li><p>还有一些标签，浏览器解析的时候，不会向服务器发送请求，<strong>但用户可以使用它们向服务器发送请求</strong>。如下</p>
<blockquote>
<ul>
<li><code>&lt;a href=&quot;https://www.icodingedu.com/&quot;&gt;&lt;/a&gt;</code> 标签，点击 a 标签时，就会向 艾编程的服务器发送请求</li>
<li><code>&lt;form&gt;</code>标签，<code>form</code>表单提交时，就会向服务器发送请求</li>
</ul>
</blockquote>
</li>
</ul>
<ol start="3">
<li>Ajax 和 Fetch<blockquote>
<p>这个我们在后边的课程中会详细讲解，它们也是前后端的通信方式之一，先做了解即可。</p>
<ul>
<li>与 Ajax 类似，Fetch 也是前后端通信的一种方式。Fetch 要比 Ajax 年轻一些</li>
<li>Fetch 是 Ajax（XMLHttpRequest）的一种替代方案，它是基于 Promise 的</li>
</ul>
</blockquote>
</li>
</ol>
<p><strong>Fetch 缺点</strong></p>
<blockquote>
<ul>
<li>Fetch 的兼容性没有 Ajax 好</li>
<li>Fetch 原生没有提供 abort 终止请求方式、timeout 请求超时方式，如果需要用到这些时，需要自己来实现。<br>目前我们先做了解即可 ！</li>
</ul>
</blockquote>
<h3 id="三、HTTP-协议"><a href="#三、HTTP-协议" class="headerlink" title="三、HTTP 协议"></a>三、HTTP 协议</h3><ol>
<li><p>HTTP 是什么 ？</p>
<blockquote>
<p><code>HTTP</code> 全称：<code>Hyper Text Transfer Protocol</code><strong>超文本传输协议</strong>（HTTP 是这几个英文单词的首字母）</p>
<blockquote>
<p>我们之前有学习过的<code>HTML</code>是 <strong>超文本标记语言</strong></p>
</blockquote>
<ul>
<li><strong>超文本：</strong> 原先一个个单一的文本，通过超链接将其联系起来。由原先的单一的文本变成了可无限延伸、扩展的超级文本，立体文本。</li>
<li><strong>传输协议：</strong> 传输，如将请求传输过去、响应传输回来 等。协议即在传输的过程中需要遵守的规范<blockquote>
<p>我们网页中的 HTML、JS、CSS、图片、字体、音频、视频 等等文件，都是通过 HTTP （超文本传输协议）在服务器和浏览器之间传输</p>
</blockquote>
</li>
<li>每一次前后端通信，前端需要主动向后端发出请求，后端接收到前端的请求后，可以给出响应</li>
<li>因此，HTTP 是一个<strong>请求、响应协议</strong></li>
</ul>
</blockquote>
</li>
<li><p>HTTP 请求响应的过程</p>
<blockquote>
<p>在浏览器的地址栏中输入网址，回车一下后，发生了什么 ？</p>
<ul>
<li>HTTP 请求响应的简单过程：<img src="http请求响应的简单过程.png"></li>
</ul>
</blockquote>
</li>
</ol>
<blockquote>
<blockquote>
<p>同时，也可以打开浏览器的控制台 “Network” 也可实时查看到整个过程。</p>
</blockquote>
</blockquote>
<ul>
<li><strong>概括说：</strong><blockquote>
<p>浏览器向服务器发送了 HTTP 请求，服务器端又向浏览器发送了 HTTP 响应，总体就这一个过程。详细描述如下：</p>
<ul>
<li><p>当我们在浏览器中访问网页时，浏览器<strong>先到自己的缓存中查询</strong>，如有缓存就不必向服务器发送请求，直接从缓存中读取。</p>
</li>
<li><p>但，有时候即便浏览器找到了缓存，它还需要<strong>考虑是否过期</strong>，这时就需要向服务器发送一个请求来询问缓存是否过期，服务器发送响应是否能用。这个过程就会涉及到浏览器和服务器之间的通信。具体是如何通讯的呢 ？</p>
</li>
<li><p>在浏览器地址栏：输入网址<code>https://www.arryblog.com/</code> 是无法直接找到 服务器在哪里的。因为服务器是有一个<strong>位置信息（即：IP 地址）</strong>浏览器会先在内部通过网址查询对应的 IP，找到了 IP ，直接使用 IP（类似于门牌号） 和服务器建立链接 ，这个链接叫** TCP 连接**</p>
</li>
<li><p>HTTP 是建立在 TCP 连接基础之上的，连接建立之后，就相当于 浏览器和服务器之间就开通了一条通路（上图蓝色部分），浏览器的请求和服务器的响应都在这个通路中完成。</p>
<blockquote>
<p>如果在浏览器中能查到网址对应的 IP，说明之前有访问过，浏览器内部会保存一份。</p>
</blockquote>
</li>
<li><p>如果之前没有访问过，浏览器也就没有记录过，本地就查不到，这时就需要到 <strong>DNS 域名解析服务器</strong>中去查询 <code>IP</code> （这个远程服务器会比较慢），查到之后会先在浏览器中存储一份，下次再访问时，就会在浏览器中查到对应的 IP 了，这样速度就会非常快。</p>
</li>
<li><p>这也是为什么，第一次打开一个网站时，会非常慢。第二次打开时就会快很多。</p>
</li>
<li><p>其中原因之一，就是我们再次访问网站时，就不用再次去 DNS 域名解析服务器中去查询 IP 了。而是直接用本地浏览器中的</p>
</li>
</ul>
</blockquote>
</li>
</ul>
<ol start="3">
<li>HTTP 报文<blockquote>
<p>HTTP 报文是什么 ？</p>
<ul>
<li>浏览器向服务器发送请求时，请求本身就是信息，叫<strong>请求报文</strong></li>
<li>服务器向浏览器发送响应时，传输的信息，叫<strong>响应报文</strong><blockquote>
<p>因此，我们讲的 HTTP 报文就是：请求报文 和 响应报文<br><img src="http报文.png"></p>
</blockquote>
</li>
</ul>
</blockquote>
</li>
</ol>
<ul>
<li>HTTP 报文格式<blockquote>
<ul>
<li>请求：请求头（起始行 + 首部），请求体</li>
<li>响应：响应头（起始行 + 首部），响应体<br><strong>注：</strong></li>
<li><code>GET</code> 请求，没有请求体，数据通过请求头携带</li>
<li><code>POST</code> 请求，有请求体，数据通过请求体携带；它既有请求头也有请求体，都可以携带数据，但在实际开发中，一般使用请求体携带数据</li>
</ul>
</blockquote>
</li>
</ul>
<blockquote>
<ul>
<li>在浏览器中访问网页，点开 ”Network“ 查看<img src="http报文格式.png"></li>
</ul>
</blockquote>
<h3 id="四、HTTP-方法"><a href="#四、HTTP-方法" class="headerlink" title="四、HTTP 方法"></a>四、HTTP 方法</h3><blockquote>
<ul>
<li><a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Methods">官方文档</a></li>
</ul>
</blockquote>
<ol>
<li><p>常用的 HTTP 方法</p>
<blockquote>
<p>浏览器发送请求时采用的方法<strong>和响应无关</strong></p>
<ul>
<li>常见的方法有：GET、POST、PUT、DELETE，用来定义对于资源采取什么样的操作的，有各自的语义</li>
</ul>
</blockquote>
</li>
<li><p>HTTP 方法的语义</p>
<blockquote>
<p>常用的这 4 种方法，行业中一般称之为”CRUD”增删改查，我们在实际开发中要清楚后端在说什么 ！</p>
<ul>
<li><code>CRUD</code>：增加<code>create</code>、查询<code>read/retrieve</code>、修改<code>update</code>、删除<code>delete</code></li>
</ul>
</blockquote>
</li>
</ol>
<table>
<thead>
<tr>
<th>HTTP 方法</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>GET</td>
<td>获取数据：获取资源（文件），多用于获取或查询数据 等</td>
</tr>
<tr>
<td>POST</td>
<td>创建数据：多用于增加数据、注册 等</td>
</tr>
<tr>
<td>PUT</td>
<td>更新数据：多用于 修改信息，修改密码 等</td>
</tr>
<tr>
<td>DELETE</td>
<td>删除数据：多用于删除数据，删除商品信息 … 等</td>
</tr>
</tbody></table>
<blockquote>
<ul>
<li>这些方法虽然有各自的语义，但并不是强制性的</li>
</ul>
</blockquote>
<ol start="3">
<li>RESTful 接口设计<blockquote>
<p><code>RESTful</code>是一种接口设计风格，充分利用<code>HTTP</code>方法的语义</p>
<ul>
<li>如：我们需要对用户信息，进行增删改查，如何设计接口</li>
</ul>
</blockquote>
</li>
</ol>
<ul>
<li>常规方式<table>
<thead>
<tr>
<th>需求</th>
<th>HTTP 方法</th>
<th>接口地址</th>
</tr>
</thead>
<tbody><tr>
<td>根据 ID 获取个人信息</td>
<td>GET</td>
<td><a target="_blank" rel="noopener" href="https://icoding.com/api/getUser?id=1">https://icoding.com/api/getUser?id=1</a></td>
</tr>
<tr>
<td>注册新用户</td>
<td>POST</td>
<td><a target="_blank" rel="noopener" href="https://icoding.com/api/addUser">https://icoding.com/api/addUser</a></td>
</tr>
<tr>
<td>修改用户信息</td>
<td>POST</td>
<td><a target="_blank" rel="noopener" href="https://icoding.com/api/modifyUser">https://icoding.com/api/modifyUser</a></td>
</tr>
<tr>
<td>删除一个用户信息</td>
<td>POST</td>
<td><a target="_blank" rel="noopener" href="https://icoding.com/api/deleteUser">https://icoding.com/api/deleteUser</a></td>
</tr>
</tbody></table>
</li>
</ul>
<p><strong>注：</strong></p>
<blockquote>
<ul>
<li>以上方式正常使用没有问题，但会显得非常麻烦，需要通过名称来进行区分具体的功能</li>
</ul>
</blockquote>
<ul>
<li>使用 <code>RESTful</code> 接口设计风格<blockquote>
<ul>
<li>充分利用 <code>HTTP</code> 方法的语义。如下<table>
<thead>
<tr>
<th>需求</th>
<th><code>HTTP</code> 方法</th>
<th><code>RESTful</code> 风格接口地址</th>
</tr>
</thead>
<tbody><tr>
<td>根据 ID 获取个人信息</td>
<td>GET</td>
<td><a target="_blank" rel="noopener" href="https://icoding.com/api/user?id=1">https://icoding.com/api/user?id=1</a></td>
</tr>
<tr>
<td>注册新用户</td>
<td>POST</td>
<td><a target="_blank" rel="noopener" href="https://icoding.com/api/user">https://icoding.com/api/user</a></td>
</tr>
<tr>
<td>修改用户信息</td>
<td>PUT</td>
<td><a target="_blank" rel="noopener" href="https://icoding.com/api/user">https://icoding.com/api/user</a></td>
</tr>
<tr>
<td>删除一个用户信息</td>
<td>DELETE</td>
<td><a target="_blank" rel="noopener" href="https://icoding.com/api/user">https://icoding.com/api/user</a></td>
</tr>
</tbody></table>
</li>
</ul>
</blockquote>
</li>
</ul>
<p><strong>注：</strong></p>
<blockquote>
<ul>
<li>我们在实际开发中 <code>RESTful</code> 接口设计风格会非常常见，大部分时间是由后端开发人员主导，前端开发会参与，讨论，必要时会提出意见和建议。</li>
</ul>
</blockquote>
<ol start="4">
<li>GET 和 POST 方法的对比</li>
</ol>
<ul>
<li>语义不同<table>
<thead>
<tr>
<th>HTTP方法</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>GET</td>
<td>获取数据</td>
</tr>
<tr>
<td>POST</td>
<td>创建数据</td>
</tr>
</tbody></table>
</li>
<li>发送数据不同<table>
<thead>
<tr>
<th>HTTP 方法</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>GET</td>
<td>通过地址在请求头中携带数据；能携带的数据量和地址的长度有关系，一般最多就<strong>几 K</strong></td>
</tr>
<tr>
<td>POST</td>
<td>既可以通过地址在请求头中携带数据（一般实际开发中不会这么做），也可以通过请求体携带数据；能携带的数据量理论上是<strong>无限的</strong></td>
</tr>
<tr>
<td>结论</td>
<td>携带少量数据，可以使用 GET 请求，大量的数据可以使用 POST 请求</td>
</tr>
</tbody></table>
</li>
<li>缓存不同<table>
<thead>
<tr>
<th>HTTP 方法</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>GET</td>
<td>可以被缓存；因为，GET 请求连同它请求的数据都会被浏览器缓存；如：我们访问过的网站，就会被浏览器记住（输入前几个字母就会自动补全）</td>
</tr>
<tr>
<td>POST</td>
<td>不会被缓存；因为 POST 请求的数据一般不通过地址来发送请求，而是通过请求体来发送，所以不会被缓存</td>
</tr>
</tbody></table>
</li>
<li>安全性<blockquote>
<p>GET 和 POST <strong>本质上都不安全</strong>，但为什么很多人说 POST 会比 GET 更安全呢 ？</p>
<ul>
<li>因为 GET 是在浏览器的地址栏中<strong>明文显示</strong>传输的（也可以在历史记录找到对应的信息，如果是密码的话），而 POST 是通过请求体发送的，我们看不到。</li>
</ul>
</blockquote>
</li>
</ul>
<p><strong>注：</strong></p>
<blockquote>
<ul>
<li>发送密码或其他敏感信息时不要使用 GET，主要是避免直接<strong>被他人窥屏或通过历史记录</strong>找到你的密码，从这个点来说 POST 确实会比 GET 安全一点。</li>
</ul>
</blockquote>
<ol start="5">
<li>HTTP 状态码<blockquote>
<ul>
<li>完整 HTTP 响应状态码，详细可查看<a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Status">官方文档</a>解读</li>
</ul>
</blockquote>
</li>
</ol>
<p><strong>HTTP 状态码是什么 ？</strong></p>
<blockquote>
<ul>
<li>HTTP 状态码是定义服务器对请求的处理结果，是服务器返回的。</li>
<li>HTTP 状态码的语义（常见状态码）</li>
</ul>
</blockquote>
<ul>
<li><p>100 ~ 199 状态码</p>
<blockquote>
<p>表示消息：代表请求已被接受，需要继续处理。</p>
<ul>
<li>如：使用 <code>websocket</code> 会经常看到</li>
<li>我们经常使用的 <code>Live Server</code> 插件保存代码会自动刷新页面，就是使用 <code>websocket</code> 来实现的<img src="liver-Server状态码.png"></li>
</ul>
</blockquote>
</li>
<li><p>200 ~ 299 状态码</p>
<blockquote>
<p>表示成功响应</p>
</blockquote>
</li>
<li><p>300 ~ 399 状态码</p>
<blockquote>
<p>表示重定向</p>
<ul>
<li>如：输入 <code>https://arryblog.com</code> 跳转至 <code>https://www.arryblog.com</code> 发生了 <strong>301 永久重定向</strong></li>
<li>重定向的位置一般都会被浏览器缓存，下次输入会自动跳转，除非我们手动把浏览器缓存清空，否则会默认跳转过去。<img src="301重定向状态码.png"></li>
</ul>
</blockquote>
</li>
</ul>
<blockquote>
<p><strong>我们常见的企业级 301 跳转解决方案</strong></p>
<ul>
<li>http：no-www 跳转到 www</li>
<li>http：www 跳转到 no-www</li>
<li>https：no-www 跳转到 www</li>
<li>https：www 跳转到 no-www<br>包括一些废弃的网址或更新后的地址，防止用户访问和搜索引擎爬虫爬取时，会报错。造成不好的用户体验 和 不利于 SEO 搜索引擎优化等，我们就会经常使用 301 永久重定向来处理。</li>
</ul>
</blockquote>
<blockquote>
<p><strong>注：</strong></p>
<ul>
<li>301 是永久重定向，需要谨慎使用，一旦设置 301 跳转的地址，就会被用户端的浏览器缓存了，我们是没有办法控制用户的浏览器来清空他的浏览器缓存，如果一旦服务端发生了新的修改，可能会跳转错误。</li>
<li>除非，我们本身就需要强制跳转的，如上边提到的 企业级 301 跳转解决方案，其他的慎用。</li>
<li><code>302</code> 临时性的缓存，每一次都会向服务器发送一次请求，确认下会往哪里跳转。</li>
<li><code>304</code> 表示没有修改，如：我们本地浏览器中有一份缓存，但还不敢用，怕它过期了，因此浏览器就会向服务器发送一次请求，确认是否过期。如果服务器返回的是 <code>304</code> 表示没有过期，即可直接使用，就不用再发送新的响应。表示还是使用本地的缓存，没有被修改。</li>
</ul>
</blockquote>
<ul>
<li><p>400 ~ 499 状态码</p>
<blockquote>
<p>表示客户端错误响应，一般会发生在<strong>前端</strong></p>
<ul>
<li>常见的 404 Not Found 找不到请求的资源</li>
</ul>
</blockquote>
</li>
<li><p>500 ~ 599 状态码</p>
<blockquote>
<p>表示服务端错误响应</p>
<ul>
<li>调用接口时，经常会遇到的错误 <code>500 Internal Server Error</code> 服务器遇到了不知道如何处理的情况。当我们看到 <code>500 ~ 599</code> 之间状态码 一般都是<strong>服务端的错误</strong>，这是就需要跟后端的同同事沟通下，找到具体的问题所在</li>
</ul>
</blockquote>
</li>
</ul>
<h3 id="五、测试题"><a href="#五、测试题" class="headerlink" title="五、测试题"></a>五、测试题</h3><blockquote>
<p>关于 GET 请求 和 POST 请求，描述正确的是 ？(多选)</p>
<ul>
<li>A、POST 请求主要通过请求体携带数据，不能通过请求头携带</li>
<li>B、GET 请求，可以在通过代码 <code>xhr.send(&#39;sex=female&#39;)</code>，成功的发送数据</li>
<li>C、POST 请求可以通过<code>xhr.send(username=$&#123;encodeURIComponent(&#39;icoding)&#125;);</code>的形式发送数据。</li>
<li>D、GET 请求不能通过请求体携带数据，但是可以通过请求头携带数据</li>
</ul>
</blockquote>
<blockquote>
<p>正确答案：C D<br>答案解析：该题考察 GET 请求与 POST 请求的区别<br><strong>POST 请求</strong></p>
<ul>
<li>POST 请求，既可以通过请求体携带数据、又可以通过请求头携带数据，A 说法错误。</li>
<li>POST 请求可以通过<code>xhr.send(username=$&#123;encodeURIComponent(&#39;icoding&#39;)&#125;);</code>的形式发送数据，C 说法正确。</li>
</ul>
<p><strong>GET 请求</strong></p>
<ul>
<li>GET 请求不能通过请求体携带数据，但是可以通过请求头携带数据，D 选项描述正确。</li>
<li><code>send</code> 方法发送的数据，<strong>是通过请求体携带的</strong>，因此在 <code>get 请求中，书写</code>xhr.send(‘sex&#x3D;female’)&#96;这句代码，无法成功发送数据，B 说法错误。</li>
</ul>
</blockquote>
<h2 id="本地存储"><a href="#本地存储" class="headerlink" title="本地存储"></a>本地存储</h2><h3 id="一、Cookie-简介"><a href="#一、Cookie-简介" class="headerlink" title="一、Cookie 简介"></a>一、<code>Cookie</code> 简介</h3><ol>
<li><code>Cookie</code> 是什么<blockquote>
<p><code>Cookie</code> 的全称是 <code>HTTP Cookie</code> ，简称 <code>Cookie</code></p>
<ul>
<li>它是<strong>浏览器存储数据</strong>的一种方式，因为存储在用户本地，而不是存储在服务器上，属于本地存储，一般会自动随着浏览器每次请求发送到服务器端。</li>
</ul>
</blockquote>
</li>
</ol>
<blockquote>
<p>在 <code>MDN</code> 官网上的定义如下：</p>
<ul>
<li><code>HTTP Cookie</code>（也叫<code>Web Cookie</code>或浏览器<code>Cookie</code>）是<strong>服务器发送到用户浏览器并保存在本地的一小块数据</strong>。浏览器会存储 cookie 并在下次向同一服务器再发起请求时携带并发送到服务器上。通常，它用于告知服务端两个请求是否来自同一浏览器——如保持用户的登录状态。Cookie 使基于<strong>无状态</strong>的 HTTP 协议记录稳定的状态信息成为了可能。<blockquote>
<p><code>MDN</code>官网上的定义更多是站在<strong>后端</strong>的角度来理解 <code>Cookie</code>，当我们在课程最后讲解后端是如何创建 Cookie 时再来理解。</p>
</blockquote>
</li>
</ul>
</blockquote>
<ol start="2">
<li>在浏览器中操作 Cookie<blockquote>
<p>找到浏览器开发者工具中，打开 <code>Application</code></p>
</blockquote>
</li>
</ol>
<ul>
<li><p>手动添加浏览器的 <code>Cookie</code> 信息</p>
<img src="在浏览器操作cookie-1.png">
</li>
<li><p>观察</p>
<blockquote>
<p>添加完成浏览器本地的 Cookie 后，再次刷新当前网页，这时就会向服务器端发送请求。</p>
<ul>
<li>观察 Cookie 是否会随着请求一起发送到服务器端 ，查看开发者工具中的 <code>“Network”</code><img src="在浏览器操作cookie-2.png"></li>
</ul>
</blockquote>
</li>
</ul>
<blockquote>
<p><strong>注：</strong></p>
<ul>
<li>以上我们可以看到，<strong>在请求头中</strong>有一个字段 Cookie 后边就是我们之前添加的值。</li>
<li>当看到请求头中携带的 Cookie 时，说明它确实发送给了服务器端。</li>
</ul>
</blockquote>
<ul>
<li>获取 Cookie <blockquote>
<ul>
<li>在控制台输入：<code>document.cookie;</code></li>
<li>即 获取到的就是 “名值对” 的形式<img src="在浏览器操作cookie-3.png"></li>
</ul>
</blockquote>
</li>
</ul>
<ol start="3">
<li>Cookie 的主要作用<blockquote>
<p>Cookie 主要用于以下三个方面：</p>
<ul>
<li>会话状态管理<ul>
<li>如用户登录状态、购物车、游戏分数或其它需要记录的信息</li>
</ul>
</li>
<li>个性化设置<ul>
<li>如用户自定义设置、主题和其他设置</li>
</ul>
</li>
<li>浏览器行为跟踪<ul>
<li>如跟踪分析用户行为等</li>
</ul>
</li>
</ul>
</blockquote>
</li>
</ol>
<h3 id="二、Cookie-的基本用法"><a href="#二、Cookie-的基本用法" class="headerlink" title="二、Cookie 的基本用法"></a>二、Cookie 的基本用法</h3><blockquote>
<p>这里我们主要学习浏览器端利用 <code>JS</code> 来操作 Cookie</p>
<ul>
<li>即<code>JavaScript</code>写入<code>Cookie</code>和读取<code>Cookie</code></li>
</ul>
</blockquote>
<ol>
<li>写入 Cookie</li>
</ol>
<ul>
<li>写入 Cookie 语法</li>
</ul>
<pre><code>document.cookie = &quot;键=值&quot;;
</code></pre>
<ul>
<li>在浏览器中写入Cookie</li>
</ul>
<pre><code>//写入Cookie
ducument.cookie = &quot;username=icoding&quot;;
document.cookie = &quot;sex=male&quot;;
document.cookie = &quot;age=18&quot;;
</code></pre>
<blockquote>
<ul>
<li>注意：设置多个<code>Cookie</code>时，只能通过多次调用<code>document.cookie = &#39;键=值” </code>的方式逐个添加，无法批量添加</li>
</ul>
</blockquote>
<ol start="2">
<li>读取 Cookie<blockquote>
<p>读取 Cookie 的值是一个<strong>由名值对构成的字符串</strong>，每个名值对之间由<code>; </code>（一个分号 + 一个空格）隔开</p>
</blockquote>
</li>
</ol>
<pre><code>// 读取 Cookie
console.log(document.cookie); // username=icoding; sex=male; age=18
</code></pre>
<blockquote>
<ul>
<li>以上<code>document.cookie</code>读取出来的是<strong>全部的 <code>Cookie</code></strong> ，不能通过特定的名称来读取特定的值，只能一次性全部读取出来。</li>
</ul>
</blockquote>
<blockquote>
<p>那么，如何根据具体的名称来读取具体的值呢 ？</p>
<ul>
<li>原生的 Cookie 是没有这样方法的，需要我们自己去封装（后边会深入讲解）</li>
</ul>
</blockquote>
<h3 id="三、Cookie-的属性"><a href="#三、Cookie-的属性" class="headerlink" title="三、Cookie 的属性"></a>三、Cookie 的属性</h3><ol>
<li><code>Cookie</code> 的名称 <code>Name</code> 和 值 <code>Value</code><blockquote>
<p><code>Name</code> 和 <code>Value</code> 是最重要的两个属性，创建 <code>Cookie</code> 时<strong>必须填写</strong>，其他属性可以使用默认值</p>
<p><strong><code>Cookie</code> 的名称或值如果包含非英文字母</strong></p>
<ul>
<li>写入时需要使用<code>encodeURIComponent()</code>编码</li>
<li>读取时使用<code>decodeURIComponent()</code>解码<blockquote>
<p>一般名称使用英文字母，不要用中文。值可以用中文，但一定需要编码</p>
</blockquote>
</li>
</ul>
</blockquote>
</li>
</ol>
<pre><code>// 名称和值 都是 英文
document.cookie = &quot;username=icoding&quot;;
// 名称为英文，值为中文
document.cookie = `username=$&#123;encodeURIComponent(&quot;艾编程&quot;)&#125;`;
// 名称和值 都是 中文
document.cookie = `$&#123;encodeURIComponent(&quot;用户名&quot;)&#125;=$&#123;encodeURIComponent(
  &quot;艾编程&quot;
)&#125;`;
&gt;
// 读取Cookie，并解码
const cookie = decodeURIComponent(document.cookie);
console.log(cookie); // 用户名=艾编程; username=艾编程
</code></pre>
<blockquote>
<blockquote>
<p>之所以使用<code> encodeURIComponent()</code> 方法进行编码，因为 <code>cookie</code> 在前端存储时有中文没问题。一旦传递到后端就可能获取不到值了。</p>
</blockquote>
</blockquote>
<ol start="2">
<li><code>expires</code> 和 <code>max-age</code> 属性<blockquote>
<ul>
<li>expires 和 max-age属性都可以设置 Cookie 的<strong>失效期</strong>，Cookie 的失效（到期）时间可以理解为 Cookie 生命的倒计时。</li>
<li>如果 Cookie <strong>没有设置</strong>失效时间，这样的 Cookie 称为：“会话 Cookie”，只要关闭浏览器，Cookie 就会被浏览器清除（<strong>注意是关闭浏览器，不是单个标签页</strong>）。</li>
<li>如果设置了对应的失效时间，只有到时间后，才会被浏览器清除。</li>
</ul>
</blockquote>
</li>
</ol>
<ul>
<li>不设置失效时间的会话<code>Cookie</code><blockquote>
<ul>
<li>会话<code>cookie</code>的属性值是<code>Session</code></li>
<li>只要关闭浏览器，<code>Cookie</code>消失</li>
</ul>
</blockquote>
</li>
</ul>
<pre><code>document.cookie = &quot;username=icoding&quot;;
</code></pre>
<ul>
<li>如果 Cookie 需要长时间存储，可以设置<code>expires</code>或<code>max-age</code> 属性<table>
<thead>
<tr>
<th>属性</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>expires</td>
<td>设置具体的过期时间，值为<code>Date</code>类型</td>
</tr>
<tr>
<td>max-age</td>
<td>值为数字，表示当前时间<code>+</code>多少秒后过期，单位是秒</td>
</tr>
</tbody></table>
</li>
</ul>
<blockquote>
<ul>
<li>使用<code>expires</code>需要<code>new Date()</code></li>
<li>键值对之间要间隔<code>;+空格</code></li>
<li>此时属性值就是到期时间</li>
</ul>
</blockquote>
<pre><code>// expires 过期时间   值为 Date 类型
document.cookie = `username=icoding; expires=$&#123;new Date(&quot;2023-3-22 00:00:00&quot;)&#125;`;
// max-age 表示多少秒后过期，20秒
document.cookie = `password=12345; max-age=20`;
// 需要cookie存储一个月，按 30天计算，如下
document.cookie = `age=33; max-age=$&#123;30 * 24 * 3600&#125;`;
</code></pre>
<img src="设置到期时间.png">

<ol start="3">
<li>删除 Cookie<blockquote>
<ul>
<li>如果要删除一个 Cookie，我们只需要设置他的失效期，让他马上失效就好。</li>
<li>如果 <code>max-age</code> 的值是<code>0</code>或负数，则 Cookie 就会失效，从浏览器中被删除</li>
<li>如果 <code>expires</code> 的时间小于当前时间，则 Cookie 就会失效，从浏览器中被删除</li>
</ul>
</blockquote>
</li>
</ol>
<pre><code>// expires 过期时间   值为 Date 类型
document.cookie = `username=icoding; expires=$&#123;new Date(&quot;2023-3-22 00:00:00&quot;)&#125;`;
// 2023-2-22 小于当前时间，当前时间 2023-2-23
document.cookie = `username=icoding; expires=$&#123;new Date(&quot;2023-2-22 00:00:00&quot;)&#125;`;
&gt;
//  max-age属性，需要cookie存储一1天
document.cookie = `age=33; max-age=$&#123;24 * 3600 * 30&#125;`;
// max-age=-1或0  表示删除cookie
document.cookie = &quot;age=33;max-age=-1&quot;;
</code></pre>
<ol start="4">
<li><code>Domain</code> 属性<blockquote>
<p>Domain 属性指定了哪些域名可以访问该 Cookie。如果 Domain 省略未写，其默认为当前域名</p>
<ul>
<li>通过 JS 添加 domain 属性，其 domain 值只能是<strong>当前域或父域</strong></li>
<li>使用 JS 也只能<strong>读写当前域 或 父域</strong>的 Cookie ，无法读写其他域的 Cookie</li>
</ul>
<p><strong>当前域和父域的解读</strong></p>
<ul>
<li>当我们访问小米的 <code>PC</code> 端网站 <code>www.mi.com</code> 或 移动端 <code>m.mi.com</code> 网站时</li>
<li>当前域：<code>www.mi.com</code>和 <code>m.mi.com</code> 表示当前访问的域名，为当前域</li>
<li>父域：<code>.mi.com</code> 也就是上面<strong>两个域名共有的域</strong>，称为两者的父域<blockquote>
<p>注意：</p>
</blockquote>
</li>
<li>在子域添加<code>domain</code>为子域的cookie，另一个子域不能访问到该cookie</li>
<li>在子域添加<code>domain</code>为父域的cookie，另一个子域可以访问到该cookie</li>
</ul>
</blockquote>
</li>
</ol>
<pre><code>//在子域 www.mi.com，添加以下cookie，另一个子域m.mi.com不能访问到该cookie
document.cookie=`username=12345; domain=&quot;www.mi.com&quot;`
&gt;
//在子域www.mi.com，添加以下cookie，子域m.mi.com可以访问到该cookie
document.cookie=`sex=888; domain=&quot;.mi.com&quot;`
</code></pre>
<blockquote>
<ul>
<li>所以，把<code>domain</code>属性设置为父域，可以实现跨域</li>
</ul>
</blockquote>
<ol start="5">
<li>Path 路径<blockquote>
<p><code>Path</code>属性指定了一个<code>URL</code>路径，限定了访问<code>Cookie</code>的范围（同一域名下）<br>如果 <code>path</code> 省略未写，其值默认为当前路径（当前文件所在文件夹路径）</p>
<ul>
<li>使用 JS 只能读写<strong>当前路径</strong>和<strong>上级路径</strong>的<code>Cookie</code>，无法读写下级路径的<code>Cookie</code></li>
<li>同时在当前路径中，<code>path</code>只能设置当前或上级路径，不能设置成下级路径</li>
</ul>
</blockquote>
</li>
</ol>
<ul>
<li>创建以下文件目录结构<img src="path目录结构.png"></li>
</ul>
<pre><code>// docs/doc.html
document.cookie = `doc=&#39;doc123&#39;; max-age=$&#123;24 * 3600&#125;; path=/docs`;
// 上面代码等同于下面代码
// document.cookie = `doc=&#39;doc123&#39;; max-age=$&#123;24 * 3600&#125;;`;
console.log(document.cookie); // doc=&#39;doc123&#39;
&gt;
// docs/web/web.html
document.cookie = `web=&#39;web123&#39;; max-age=$&#123;24 * 3600&#125;; path=/docs/web `;
console.log(document.cookie); // web=&#39;web123&#39;; doc=&#39;doc123&#39;
&gt;
// docs/web/http/http.html
document.cookie = `http=&#39;http123&#39;;max-age=$&#123;24 * 3600&#125;; path=/docs/web/http `;
console.log(document.cookie); // http=&#39;http123&#39;; web=&#39;web123&#39;; doc=&#39;doc123&#39;
</code></pre>
<blockquote>
<p><strong>注：</strong></p>
<ul>
<li><code>/</code>表示<code>http://www.xxx.com/</code>以下目录都可以访问这个 Cookie，但以上都不行</li>
<li><code>/docs</code>表示<code>http://ww.xxx.com/docs</code>以下目录都可以访问这个 Cookie，但以上都不行</li>
<li><code>/docs/web</code>表示<code>http://ww.xxx.com/docs/web</code>以下目录都可以访问这个 Cookie，但以上都不行</li>
</ul>
</blockquote>
<blockquote>
<ul>
<li>在当前路径中，path 只能设置当前或上级路径，不能设置成下级路径</li>
</ul>
</blockquote>
<pre><code>// 以下代码属于 /docs/doc.html页面
&gt;
// 错误写法 因为path不能指向当前路径的下级路径
document.cookie = `doc=&#39;doc123&#39;; path=/doc/web`;
&gt;
// 正确写法
document.cookie = `doc=&#39;doc1&#39;; path=/docs`;
document.cookie = `doc=&#39;doc123&#39;; path=/`;
</code></pre>
<ol start="6">
<li>判断是否为同一 Cookie<blockquote>
<p>通过上面的学习，我们知道，只有当<code>Name、Domain、Path</code> 这<strong>三个字段都相同时</strong>，才是同一个<code>Cookie</code></p>
</blockquote>
</li>
</ol>
<pre><code>// 以下为相同Cookie
document.cookie = `doc=&#39;doc1&#39;; path=/docs`;
document.cookie = &quot;doc=abc&quot;; // 其path默认值为 /docs
&gt;
// 以下都为不同Cookie
document.cookie = `doc=&#39;doc123&#39;; path=/docs`;
document.cookie = `doc=&#39;doc123&#39;; path=/`;
</code></pre>
<blockquote>
<ul>
<li>在<code>docs</code>目录里，<code>/</code>和<code>/docs</code>不同</li>
</ul>
</blockquote>
<ol start="7">
<li>HttpOnly 属性<blockquote>
<ul>
<li>设置了<code>HttpOnly</code>属性的<code>Cookie</code><strong>不能通过</strong><code>JS</code> 去访问，禁止 JS 访问也是为了安全性考虑。</li>
<li>HttpOnly 属性不能通过 JS 来设置，<strong>只能通过服务端</strong>来设置。如果我们想要看到效果，可以手动在浏览器的控制台勾选。<img src="httponly.png"></li>
</ul>
</blockquote>
</li>
</ol>
<blockquote>
<ul>
<li>在当前页面的控制台操作<code>document.cookie</code>时，只能获取到<code>doc = doc123</code> ，说明<code>HttpOnly</code>属性<strong>选中时</strong>，<code>JS</code>是无法读取当前<code>Cookie</code></li>
</ul>
</blockquote>
<ol start="8">
<li><p>Secure 安全标志</p>
<blockquote>
<ul>
<li>标记为<code>Secure</code>的<code>Cookie</code>只能通过被<code>HTTPS</code>协议加密过的请求发送给服务端。它<strong>永远不会使用不安全</strong>的 <code>HTTP</code> 发送（本地主机除外）</li>
</ul>
</blockquote>
</li>
<li><p>什么样的 Cookie 才能发送到服务器端</p>
<blockquote>
<ul>
<li><code>Domain、Path、Secure</code>都要满足条件，还不能过期的 <code>Cookie</code>才能随着请求发送到服务器端</li>
</ul>
</blockquote>
</li>
</ol>
<h3 id="四、Cookie-的封装"><a href="#四、Cookie-的封装" class="headerlink" title="四、Cookie 的封装"></a>四、Cookie 的封装</h3><blockquote>
<p>前边几节中我们学习了通过<code>JS</code>来写入、读取、删除 Cookie，我们在使用的过程中也发现了 Cookie 原生提供的方式都不好用。因此，我们现在开始对 Cookie 进行封装，让 Cookie 在实际开发中使用起来更方便。</p>
<ul>
<li>需要封装<strong>写入</strong> Cookie，<strong>读取</strong>Cookie，<strong>删除</strong> Cookie 这三个功能。会用到我们前面学习过的 ES6 Module 模块的方式进行导入和导出。</li>
</ul>
</blockquote>
<ol>
<li>封装 cookie<blockquote>
<p>新建<code>cookie.js</code>文件，封装成一个模块 ，创建一个 <code>Cookie</code>类，添加三个静态方法，将<code>Cookie</code>类做为接口导出</p>
<ul>
<li>set 方法，设置 cookie</li>
<li>get 方法，通过 cookie 的 name 获取 value 值</li>
<li>remove 方法，通过 cookie 的 name 删除对应的 cookie</li>
</ul>
</blockquote>
</li>
</ol>
<ul>
<li>模块文件<code>cookie.js</code></li>
</ul>
<pre><code>class Cookie &#123;
  // set方法，用来添加Cookie
  // name 和 value 是必传项
  // &#123;&#125; 对象中的属性是非必传项，这是对象字面量的新增简洁表示法
  // &#123; maxAge, domain, path, secure &#125; = &#123;&#125; 设置默认值，在没有传值的情况下给 &#123;&#125; 对象
  static set(name, value, &#123; maxAge, domain, path, secure &#125; = &#123;&#125;) &#123;
    // 对传过来的name和value编码
    let cookieText = `$&#123;encodeURIComponent(name)&#125;=$&#123;encodeURIComponent(value)&#125;`;
    // 设置失效时间
    if (typeof maxAge === &quot;number&quot;) &#123;
      cookieText += `; max-age=$&#123;maxAge&#125;`;
    &#125;
    // 设置访问域
    if (domain) &#123;
      cookieText += `; domain=$&#123;domain&#125;`;
    &#125;
    // 设置路径
    if (path) &#123;
      cookieText += `; path=$&#123;path&#125;`;
    &#125;
    // 设置安全标志
    if (secure) &#123;
      cookieText += `; secure=$&#123;secure&#125;`;
    &#125;
    document.cookie = cookieText;
  &#125;
  // get方法，用来获取Cookie
  // 原来通过 document.cookie 获取的 Cookie 值是：
  // &quot;username=icoding; age=20; sex=male&quot;
  // 对于以上有规律的字符串可以使用 split(&quot;; &quot;) 分割拆分成一个数组，分割后如下
  // 得到一个数组 [&#39;username=icoding&#39;, &#39;age=20&#39;, &#39;sex=male&#39;]
  static get(name) &#123;
    // 将获到的name解码
    name = encodeURIComponent(name);
    // 将读取到的cookie信息字符串，通过&quot;; &quot;分割成一个数组
    let cookies = document.cookie.split(&quot;; &quot;);
    // 利用for...of来遍历数组
    for (let item of cookies) &#123;
      const [cookieName, cookieValue] = item.split(&quot;=&quot;);
      if (cookieName === name) &#123;
        // 解码
        return decodeURIComponent(cookieValue);
      &#125;
    &#125;
    // 如果最后没有找到
    return;
  &#125;
  // remove方法，用来删除Cookie
  // 根据 name，domain 和 path 删除 Cookie
  // name 必传参数
  // domain 和 path 可选项
  static remove(name, &#123; domain, path &#125; = &#123;&#125;) &#123;
    this.set(name, &quot;&quot;, &#123; domain, path, maxAge: -1 &#125;);
  &#125;
&#125;
// 默认导出
export default Cookie;
</code></pre>
<ul>
<li>新建一个 <code>cookie.html</code> 文件，导入封装好的 <code>cookie</code> 模块，调用对应的方法</li>
</ul>
<pre><code>&gt;&lt;script type=&quot;module&quot;&gt;
  // 导入 Cookie 模块
  import Cookie from &quot;../Cookie.js&quot;;
  // 设置Cookie
  Cookie.set(&quot;username&quot;, &quot;清心&quot;, &#123; maxAge: 10 &#125;);
  Cookie.set(&quot;age&quot;, 33, &#123; path: &quot;/&quot; &#125;);
  Cookie.set(&quot;sex&quot;, &quot;女&quot;, &#123; secure: &quot;secure&quot; &#125;);
&gt;
  // 获取Cookie
  console.log(Cookie.get(&quot;username&quot;));
  console.log(Cookie.get(&quot;age&quot;));
  console.log(Cookie.get(&quot;sex&quot;));
&gt;
  // 删除Cookie
  Cookie.remove(&quot;age&quot;, &#123; path: &quot;/&quot; &#125;);
  Cookie.remove(&quot;sex&quot;);
&gt;&lt;/script&gt;
</code></pre>
<h3 id="五、Cookie-的注意事项"><a href="#五、Cookie-的注意事项" class="headerlink" title="五、Cookie 的注意事项"></a>五、Cookie 的注意事项</h3><blockquote>
<p>在实际开发中需要注意，前后端都可以写入和获取 <code>Cookie</code> ，<code>Cookie</code> 有数量限制，<code>Cookie</code> 有大小限制。</p>
</blockquote>
<ol>
<li>Cookie 有数量限制<blockquote>
<p>每个域名下的 Cookie <strong>数量有限</strong>，具体有多少无法确定，得看浏览器，每个都会不一样</p>
<ul>
<li>以下数据也只是<strong>参考</strong>，不能作为实际数据来用，因为浏览器在更新，相关限制也会出现变动<table>
<thead>
<tr>
<th>Cookie 限制</th>
<th>Edge</th>
<th>Opera</th>
<th>Firefox</th>
<th>Safari</th>
<th>Chrome</th>
</tr>
</thead>
<tbody><tr>
<td>Cookie 个数（每个域）</td>
<td>50 个</td>
<td>180 个</td>
<td>150 个</td>
<td>没有个数限制</td>
<td>没有个数限制</td>
</tr>
<tr>
<td>Cookie 总大小（字节数）</td>
<td>4095</td>
<td>4096</td>
<td>4097</td>
<td>4097</td>
<td>4097</td>
</tr>
</tbody></table>
</li>
</ul>
</blockquote>
</li>
</ol>
<blockquote>
<p><strong>注：</strong></p>
<ul>
<li>浏览器 Cookie 的数量限制只跟 <strong>每个域名下</strong> Cookie 数量有关系</li>
<li>当超过单个域名限制之后，再设置 Cookie ，浏览器就会清除以前设置的 Cookie<blockquote>
<p>因此，在实际开发中不要过多的设置 Cookie ，要考虑它的数量限制，防止发生无法预期的后果</p>
</blockquote>
</li>
</ul>
</blockquote>
<ol start="2">
<li><p>Cookie 有大小限制</p>
<blockquote>
<p>Cookie 的存储容量很小，最多只有 <code>4KB</code> 左右（具体在以上表格中），这里对容量的限制不是针对一个 Cookie，是<strong>针对一个域名下的所有</strong> <code>Cookie</code> 而言</p>
<p>在实际开发中一般是遇不到超出 Cookie 的数量和大小限制的，我们正常也不会设置那么多的 Cookie。</p>
<ul>
<li>如果真的设置了很多 Cookie，就需要考虑下 Cookie 的限制了。</li>
</ul>
</blockquote>
</li>
<li><p>前后端都可以写入 和 获取 Cookie</p>
<blockquote>
<ul>
<li>不仅仅前端可以创建 Cookie，随着请求发送到服务器端</li>
<li>后端同样可以创建 Cookie ，通过响应发送到前端来，之后的请求总会携带 Cookie 发送到后端</li>
<li>到底 Cookie 是从前端来创建还是后端来创建，就需要根据具体的业务需求来了</li>
</ul>
</blockquote>
</li>
</ol>
<h3 id="六、服务端创建-Cookie"><a href="#六、服务端创建-Cookie" class="headerlink" title="六、服务端创建 Cookie"></a>六、服务端创建 Cookie</h3><blockquote>
<p>我们通过图解和代码来帮助大家理解服务端创建 Cookie 的过程。服务端是后台开发人员需要掌握的，我们这个阶段只需要先了解就好，因为需要操作服务器。</p>
<ul>
<li>所以我们需要简单学习下 node，用来搭建一个简单的 HTTP 服务器。</li>
</ul>
</blockquote>
<ol>
<li>什么是 <code>Node.js</code><blockquote>
<ul>
<li><code>Node.js</code>是一个基于 Chrome V8 引擎的 JavaScript 运行时环境。</li>
<li><code>Node.js</code>为 JavaScript 提供了在服务端运行的环境，使得 JavaScript 也能开发服务端的程序，前后端统一语言，统一模型的梦想得以实现</li>
</ul>
<p>Node.js 2009 年诞生，2015 到 2016 左右在中国就火起来了，Node 火了之后带来了连锁反应。</p>
<p>2016 年前后，以 webpack 为代表的 Node.js 工作流工具 使前端开发的开发形式产生了翻天覆地的变化。并且，随着<code>Vue / React</code>的诞生，使前端开发进入了框架时代。</p>
<ul>
<li>在今天，可以说前端开发 “上天入地，无所不能”：PC 端 web 开发、移动 web 开发、APP 开发、小程序开发、服务端开发等等都能搞定。</li>
</ul>
</blockquote>
</li>
</ol>
<blockquote>
<p>我们日常听到 <code>Node.js</code> 时，要<strong>注意区分</strong>他到底说的是 <strong>平台</strong> 还是 <strong><code>Node.js</code>语言</strong>，因此我们讲 Node.js 有两个层面的含义：</p>
<ul>
<li><code>Node.js</code>是个平台或工具，即在 Node.js 平台上安装模块或包，类似于前端在浏览器上安装插件一样</li>
<li><code>Node.js</code>语言 &#x3D; 后端 JavaScript &#x3D; ECMAScript + IO + File + … 等服务端的操作</li>
</ul>
<p>我们前端常说的<code>Node</code>更多是指如何在<code>Node.js</code>平台上安装模块或包，类似前端在浏览器上安装插件一样。</p>
<p>因此，大家在日常开发中会用到在<code>Node.js</code>平台上安装模块或包， 这只是使用了<code>Node.js</code>平台，并不代表你就懂<code>Node.js</code> 语言了（<code>Node.js</code>语言本质上它就类似<code>PHP、Python、Perl、Ruby</code>等服务端语言，包括<code>Java</code>这些服务端的语言能干的<code>Node.js</code>都能干，非常强大 ），这个一定要搞清楚，务必盲目的自信，避免闹笑话。</p>
<ul>
<li>但本节课的案例中为了帮助大家更好的理解 Cookie 的前后交互，会简单涉及<code>Node.js</code>语言相关内容，大家不要深究，只做了解即可。</li>
</ul>
</blockquote>
<ol start="2">
<li><p>node 的安装</p>
<blockquote>
<ul>
<li>Node.js<a target="_blank" rel="noopener" href="https://nodejs.org/en/download/">官方下载地址</a></li>
<li>选择最新稳定版，根据自己的操作系统选择对应的下载地址</li>
<li>下载完成后，直接下一步，默认安装即可</li>
</ul>
</blockquote>
</li>
<li><p>检测是否安装成功及版本号</p>
<blockquote>
<p>在 window 的 cmd 命令窗口，输入 <code>node -v</code></p>
<ul>
<li>如果需要切到<code>D</code>盘，输入<code>D:</code></li>
<li>安装 node 时，会自动安装 npm , npm 是 node.js 的包管理器</li>
</ul>
</blockquote>
</li>
</ol>
<pre><code>&gt;检测 node 是否安装及版本，正常显示版本号说明已经安装相应的版本
node -v
&gt;
&gt;检测 npm 是否安装及版本，正常显示版本号说明已经安装相应的版本
npm -v
</code></pre>
<ol>
<li>node 搭建服务器<blockquote>
<p>创建 <code>server.js</code> 文件</p>
<ul>
<li>文件内容如下</li>
</ul>
</blockquote>
</li>
</ol>
<pre><code>// 加载Node.js自带的http模块，http模块主要用来创建HTTP服务器
const http = require(&quot;http&quot;);
// 创建HTTP服务器  回调函数中的request用来接受请求数据，response用来处理响应数据
http
  .createServer(function (request, response) &#123;
    // 设置响应头，解决中文乱码问题
    response.writeHead(200, &#123;
      // 返回内容的类型和编码
      &quot;Content-type&quot;: &quot;text/plain;charset=utf-8&quot;,
    &#125;);
    // response.write方法向前端返回数据，该方法可调用多次,多次调用的数据会被拼接到一起返回
    response.write(&quot;hello&quot;);
    response.write(&quot;world&quot;);
    // 必须调用response.end方法结束请求，否则前端会一直处于等待状态，
    // response.end方法也可以用来向前端返回数据
    response.end(&quot;发送完，结束&quot;);
  &#125;)
  .listen(8886); // 指定HTTP服务器监听的端口号 四位数字
&gt;
console.log(&quot;Server running at http://127.0.0.1:8886&quot;);
</code></pre>
<p><strong>运行流程</strong></p>
<blockquote>
<ul>
<li>执行程序，在 VSCode 的终端命令中运行<code>node server.js</code>命令来执行程序，程序启动成功后，在地址栏中输入<code>http://127.0.0.1:8886</code> 回车，就可以看到返回的内容。</li>
<li>返回上级目录，在 VSCode 的终端命令中运行<code>cd ../</code>回车</li>
<li>切换到下级目录，在 VSCode 的终端命令中运行<code>cd 目录名</code>回车 如：<code>cd Desktop/test</code></li>
<li>终止程序执行，使用快捷键<code> ctrl + C</code></li>
</ul>
</blockquote>
<p><strong>常见的返回数据类型（MIME 类型）</strong></p>
<blockquote>
<p><code>MIME</code>类型就是设定某种扩展名的文件用一种应用程序来打开的方式类型，当该扩展名文件被访问的时候，浏览器会自动使用指定应用程序来打开</p>
<ul>
<li>多用于指定一些客户端自定义的文件名，以及一些媒体文件打开方式。</li>
<li>普通文本： <code>text/plain</code></li>
<li>JS 代码：<code>application/javascript</code></li>
<li>HTML 代码： <code>text/html</code></li>
<li>JSON 类型：<code>application/json</code></li>
<li>图片类型：<code>image/gif 、image/jpeg、image/png</code></li>
<li>设置编码的格式：<code>charset = utf-8</code></li>
</ul>
</blockquote>
<ol start="5">
<li>服务端 Cookie 的创建过程<blockquote>
<p>服务端在响应头中设置<code>Set-Cookie</code>选项，然后发送到浏览器（客户端），浏览器对应的数据存储<code>Cookie</code>中，并在下次向同一服务器再发起请求时携带并发送到服务器上。<br><img src="cookie在服务器端的响应过程.png"></p>
</blockquote>
</li>
</ol>
<ul>
<li>创建过程解析<blockquote>
<ul>
<li>当前端（浏览器端）<strong>第一次发送</strong> HTTP 请求时，服务端收到 HTTP 请求后，服务端可以在响应头里面添加一个或多个 <code>Set-Cookie</code> 选项。</li>
<li><strong>浏览器收到响应后</strong>会将接受的<code>Set-Cookie</code>中的数据保存在浏览器的<code>Cookie</code>中。</li>
<li>当下一次前端（浏览器端）<strong>再次</strong>向服务端发送 HTTP 请求时，会将其放在 HTTP 请求头的<code>Cookie</code>中，发送到服务端。服务端收到这个数据后，会拿这个数据来做校验….</li>
</ul>
</blockquote>
</li>
</ul>
<ol start="6">
<li>代码演示 Cookie 创建过程</li>
</ol>
<pre><code>//加载Node.js自带的http模块，http模块主要用来创建HTTP服务器
const http = require(&quot;http&quot;);
//http.createServer()方法创建服务器
//函数通过 request, response 参数来接收和响应数据。
http.createServer(function(request,response)&#123;
    //获取请求端发来的数据
    const cookie=request.headers.cookie;
    // console.info(cookie);
    //设置响应头，解决中文乱码问题
    response.writeHead(200,&#123;
        //返回内容的类型和编码
        &quot;Content-type&quot;:&quot;text/plain;charset=utf-8&quot;,
        &quot;Set-Cookie&quot;:[&quot;username=hermia&quot;],
    &#125;);
    //响应体内容：
    //response.write方法向前端返回数据
    //该方法可多次调用，多次调用的数据会被拼接到一起返回
    if(cookie)&#123;
        response.write(&quot;收到你的cookie了&quot;);
&gt;
    &#125;else&#123;
        response.write(&quot;你的身份不合格&quot;);
    &#125;
    //必须调用response.end方法结束请求，否则前端一直会处于等待状态，response.end方法也可以用来向前端发送数据
    response.end();
&#125;).listen(8888);//指定HTTP服务器监听的端口号，四位数
console.log(&quot;Server running at http://127.0.0.1:8888&quot;);
</code></pre>
<p><strong>运行流程</strong></p>
<blockquote>
<ul>
<li>先<strong>安装</strong> node，然后在一个文件夹中打开 VSCode，在 VSCode 中创建<code>server.js</code>文件，文件内容如上面代码。</li>
<li>然后<strong>在终端执行</strong><code>node server.js</code>命令运行程序，程序启动成功后，<strong>在浏览器地址栏</strong>输入：<code>http://127.0.0.1:8888/</code>就可以向服务端发起 <code>Http</code> 请求，同时服务端响应内容”你的身份不合格”。</li>
<li><strong>第一次</strong>向<code>http://127.0.0.1:8888/</code>发起请求时，请求头中并没有<code>Cookie</code> 信息，<strong>服务端接收请求后</strong>，在响应头中设置了<code>Set-Cookie</code>，所以响应头信息中有<code>Set-Cookie: username = hermia</code>信息。这时候浏览器会把响应头<code>Set-Cookie</code>中的信息，保存在浏览器的 <code>Cookie</code> 中。</li>
<li><strong>第二次</strong>向<code>http://127.0.0.1:8888/</code>发送请求时，请求头中携带了<code>Set-Cookie: username = hermia</code>信息，同时服务端读取到请求头中的<code>Cookie</code>，并在服务端的终端打印”收到你的cookie了”</li>
<li>在当前页面中，打开控制台，选择<code>Network</code>面板，然后刷新浏览器，然后按下图操作，就能看到整个过程。</li>
</ul>
</blockquote>
<h3 id="七、Cookie-在实际开发中的实际应用"><a href="#七、Cookie-在实际开发中的实际应用" class="headerlink" title="七、Cookie 在实际开发中的实际应用"></a>七、Cookie 在实际开发中的实际应用</h3><ul>
<li>Cookie 实现中英文网站语言切换<blockquote>
<ul>
<li>当用户第一次访问网站时，默认显示的是中文网站</li>
<li>如果点击了页面的英文切换按扭，则切换到英文网站。下次打开网站后显示的就是英文版的。</li>
</ul>
</blockquote>
</li>
</ul>
<ol>
<li><p>实现原理</p>
<blockquote>
<ul>
<li>第一次发送请求，服务端会判断请求头中是否有对应的 <code>Cookie</code>，如果没有，则默认发送的中文版的网站</li>
<li>点击页面中英文按扭，在 Cookie 中添加<code>language=en; max-age=$&#123;365*24*3600&#125;&quot;</code>，然后利用<code>window.location=&#39;/&#39;</code>重新向后端发送一次请求。</li>
<li>点击页面中中文按扭，在 Cookie 中添加<code>language=cn; max-age=$&#123;365*24*3600&#125;&quot;</code>，然后利用<code>window.location=&#39;/&#39;</code>重新向后端发送一次请求</li>
<li>服务器接收请求头中的 Cookie，判断 cookie 值，如是为en,则发送英文网站，否则发送中文。随后的每次请求，请求头中都会携带 Cookie，服务端都会根据请求头中的 Cookie 来判断是发送中文网站还是英文网站</li>
</ul>
</blockquote>
</li>
<li><p>代码实现步骤</p>
<blockquote>
<p>创建两个 HTML 页面</p>
<ul>
<li><code>en.html</code>表示英文网站</li>
<li><code>cn.html</code>表示中文网站<br>在页面中添加对应的中英文切换按扭，点击对应的按扭，就创建对应的 Cookie 存入到浏览器中，然后利用<code>window.location = &#39;/&#39;</code>重新向后端发送一次请求，后端会根据这一次请求，响应对应的内容</li>
</ul>
</blockquote>
</li>
</ol>
<ul>
<li><code>cn.html</code>页面</li>
</ul>
<pre><code>&gt;&lt;body&gt;
&gt;  &lt;button id=&quot;cn&quot;&gt;中文&lt;/button&gt;
&gt;  &lt;button id=&quot;en&quot;&gt;英文&lt;/button&gt;
&gt;  中国欢迎你！
&gt;  &lt;script&gt;
&gt;    const cn = document.getElementById(&quot;cn&quot;);
&gt;    const en = document.getElementById(&quot;en&quot;);
&gt;    cn.addEventListener(&quot;click&quot;, () =&gt; &#123;
&gt;      //创建Cookie
&gt;      document.cookie = `language=cn; max-age=$&#123;365 * 24 * 3600&#125;`;
&gt;      window.location = &quot;/&quot;;
&gt;    &#125;);
&gt;
&gt;    en.addEventListener(&quot;click&quot;, () =&gt; &#123;
&gt;      //创建Cookie
&gt;      document.cookie = `language=en; max-age=$&#123;365 * 24 * 3600&#125;`;
&gt;      window.location = &quot;/&quot;;
&gt;    &#125;);
&gt;  &lt;/script&gt;
&gt;&lt;/body&gt;
</code></pre>
<ul>
<li><code>en.html</code>页面</li>
</ul>
<pre><code>&gt;&lt;body&gt;
&gt;  &lt;button id=&quot;cn&quot;&gt;中文&lt;/button&gt;
&gt;  &lt;button id=&quot;en&quot;&gt;English&lt;/button&gt;
&gt;  Welcome to China!
&gt;  &lt;script&gt;
&gt;    const cn = document.getElementById(&quot;cn&quot;);
&gt;    const en = document.getElementById(&quot;en&quot;);
&gt;    cn.addEventListener(&quot;click&quot;, () =&gt; &#123;
&gt;      //创建Cookie
&gt;      document.cookie = `language=cn; max-age=$&#123;365 * 24 * 3600&#125;`;
&gt;      window.location = &quot;/&quot;;
&gt;    &#125;);
&gt;
&gt;    en.addEventListener(&quot;click&quot;, () =&gt; &#123;
&gt;      //创建Cookie
&gt;      document.cookie = `language=en; max-age=$&#123;365 * 24 * 3600&#125;`;
&gt;      window.location = &quot;/&quot;;
&gt;    &#125;);
&gt;  &lt;/script&gt;
&gt;&lt;/body&gt;
</code></pre>
<ul>
<li>用 <code>node</code> 创建服务器，具体代码如下</li>
</ul>
<pre><code>// http模块，主要用来搭建 HTTP 服务器
const http = require(&quot;http&quot;);
// 文件操作模块
const fs = require(&quot;fs&quot;);
&gt;
// 创建服务器
http
  .createServer((request, response) =&gt; &#123;
    // 获取请求体中的cookie
    const cookie = request.headers.cookie;
    const language = cookie ? cookie.split(&quot;=&quot;)[1] : &quot;cn&quot;;
    let html = &quot;&quot;; // 保存响应体内容
    // 根据Cookie的内容，来决定发送的内容
    if (language === &quot;en&quot;) &#123;
      html = fs.readFileSync(&quot;./en.html&quot;);
    &#125; else &#123;
      html = fs.readFileSync(&quot;./cn.html&quot;);
    &#125;
&gt;
    // 设置响应头信息 200 表示状态响应成功，
    // Content-Type 响应主体的内容类型为html文件，编码格式utf-8
    response.writeHead(200, &#123;
      &quot;Content-Type&quot;: &quot;text/html;charset=utf-8&quot;,
    &#125;);
    // 发送响应体内容
    response.end(html);
  &#125;)
  .listen(1128); // 监听端口
&gt;
console.log(&quot;Server running at http://127.0.0.1:1128/&quot;);
</code></pre>
<ol start="3">
<li>升级版<blockquote>
<p>在上面的版本中，我们没有办法在<code>cn.html</code>和<code>en.html</code>页面使用模块化加载 <code>Cookie.js</code> 来操作 Cookie，本质是因为<code>http://127.0.0.1:8889/Cookie</code> 请求失败，<strong>后端并没有针对这个请求做相关的响应</strong>（也就是返回 <code>Cookie.js</code> 文件）。</p>
<ul>
<li>所以我们需要根据用户的请求路径来响应不同的内容</li>
</ul>
</blockquote>
</li>
</ol>
<ul>
<li><code>cn.html</code>页面</li>
</ul>
<pre><code>&gt;&lt;button id=&quot;cn&quot;&gt;中文&lt;/button&gt;
&gt;&lt;button id=&quot;en&quot;&gt;英文&lt;/button&gt;
&gt;我爱你
&gt;
&gt;&lt;script type=&quot;module&quot;&gt;
&gt;  // 模块化导入JS
&gt;  import Cookie from &quot;./Cookie&quot;;
&gt;  const cn = document.getElementById(&quot;cn&quot;);
&gt;  const en = document.getElementById(&quot;en&quot;);
&gt;  cn.addEventListener(&quot;click&quot;, () =&gt; &#123;
&gt;    //创建Cookie
&gt;    Cookie.set(&quot;language&quot;, &quot;cn&quot;, &#123; maxAge: 365 * 24 * 3600 &#125;);
&gt;    // 重新加载页面
&gt;    window.location = &quot;/&quot;;
&gt;  &#125;);
&gt;
&gt;  en.addEventListener(&quot;click&quot;, () =&gt; &#123;
&gt;    //创建Cookie
&gt;    Cookie.set(&quot;language&quot;, &quot;en&quot;, &#123; maxAge: 365 * 24 * 3600 &#125;);
&gt;    window.location = &quot;/&quot;;
&gt;  &#125;);
&gt;&lt;/script&gt;
</code></pre>
<ul>
<li><code>en.html</code>页面</li>
</ul>
<pre><code>&gt;&lt;button id=&quot;cn&quot;&gt;中文&lt;/button&gt;
&gt;&lt;button id=&quot;en&quot;&gt;English&lt;/button&gt;
&gt;I love you
&gt;
&gt;&lt;script type=&quot;module&quot;&gt;
&gt;  // 模块化导入JS
&gt;  import Cookie from &quot;./Cookie&quot;;
&gt;  const cn = document.getElementById(&quot;cn&quot;);
&gt;  const en = document.getElementById(&quot;en&quot;);
&gt;  cn.addEventListener(&quot;click&quot;, () =&gt; &#123;
&gt;    //创建Cookie
&gt;    Cookie.set(&quot;language&quot;, &quot;cn&quot;, &#123; maxAge: 365 * 24 * 3600 &#125;);
&gt;    // 重新加载页面
&gt;    window.location = &quot;/&quot;;
&gt;  &#125;);
&gt;
&gt;  en.addEventListener(&quot;click&quot;, () =&gt; &#123;
&gt;    //创建Cookie
&gt;    Cookie.set(&quot;language&quot;, &quot;en&quot;, &#123; maxAge: 365 * 24 * 3600 &#125;);
&gt;    // 重新加载页面
&gt;    window.location = &quot;/&quot;;
&gt;  &#125;);
&gt;&lt;/script&gt;
</code></pre>
<ul>
<li><code>server.js</code>页面</li>
</ul>
<pre><code>// http模块，主要用来搭建 HTTP 服务器
const http = require(&quot;http&quot;);
// 文件操作模块
const fs = require(&quot;fs&quot;);
&gt;
// 创建服务器
http
  .createServer((request, response) =&gt; &#123;
    // 请求根目录
    if (request.url === &quot;/&quot;) &#123;
      // 获取请求体中的cookie
      const cookie = request.headers.cookie;
      const language = cookie ? cookie.split(&quot;=&quot;)[1] : &quot;cn&quot;;
      let html = &quot;&quot;; // 保存响应内容体
      if (language === &quot;en&quot;) &#123;
        html = fs.readFileSync(&quot;./en.html&quot;);
      &#125; else &#123;
        html = fs.readFileSync(&quot;./cn.html&quot;);
      &#125;
&gt;
      // 设置响应头信息 200 表示状态响应成功，
      // Content-Type 响应主体的内容类型为html文件，编码格式utf-8
      response.writeHead(200, &#123;
        &quot;Content-Type&quot;: &quot;text/html;charset=utf-8&quot;,
      &#125;);
      // 发送响应体内容
      response.end(html);
&gt;
      //----------------------------------------------------------------
      // 请求 /Cookie目录
    &#125; else if (request.url === &quot;/Cookie&quot;) &#123;
      // 读取JS文件
      const js = fs.readFileSync(&quot;./Cookie.js&quot;);
      // 设置响应头
      response.writeHead(200, &#123;
        &quot;Content-Type&quot;: &quot;application/javascript;charset=utf-8&quot;,
      &#125;);
      // 发送响应体内容
      response.end(js);
    &#125;
  &#125;)
  .listen(8889); // 监听端口
&gt;
console.log(&quot;Server running at http://127.0.0.1:8889/&quot;);
</code></pre>
<h3 id="八、LocalStorage-简介"><a href="#八、LocalStorage-简介" class="headerlink" title="八、LocalStorage 简介"></a>八、<code>LocalStorage</code> 简介</h3><ol>
<li><p><code>localStorage</code>是什么</p>
<blockquote>
<p>有一些数据确实是需要存储在本地，但它却不需要发送到服务器端，所以它并不适合放在 Cookie 中。那么，<code>localStorage</code>就是一个不错的选择。</p>
<p><code>localStorage</code>也是一种浏览器存储数据的方式（本地存储），它<strong>只存储在本地，不会发送到服务器端</strong>（不会像 Cookie 那样发送到服务器端）。</p>
<p>这样一来</p>
<ul>
<li>对于那些你既想存储在用户本地，又不想发送到服务器端的数据，就可以存储在<code>localStorage</code>中</li>
<li>而那些既希望它存储在本地，又希望它能随着请求发送到服务器端的数据就可以存储在 <code>Cookie</code> 中</li>
</ul>
</blockquote>
</li>
<li><p>在浏览器中操作<code>localStorage</code></p>
<blockquote>
<p><code>localStorage</code>也是按<strong>域名</strong>来存储的，在浏览器可直接查看。</p>
<ul>
<li><code>Local Storage</code>中的数据是以键值对的形式存储的</li>
<li>如下<img src="localstorage.png"></li>
</ul>
</blockquote>
</li>
</ol>
<h3 id="九、LocalStorage-的基本用法"><a href="#九、LocalStorage-的基本用法" class="headerlink" title="九、LocalStorage 的基本用法"></a>九、LocalStorage 的基本用法</h3><blockquote>
<p>我们可以通过<code>window.localStorage</code>对象来操作浏览器中的 <code>Local Storage</code>数据。</p>
</blockquote>
<ol>
<li><code>localStorage</code><strong>对象</strong><blockquote>
<p>通过<code>window.localStorage</code>对象可以获取浏览器 <code>Local Storage</code>中所有的项的数据</p>
</blockquote>
</li>
</ol>
<pre><code>// 获取本地所有 Local Storage
console.log(localStorage);
&gt;
// 控制台输出结果： Storage &#123;font-size: &#39;12px&#39;, color: &#39;#666&#39;, background-color: &#39;skyblue&#39;, length: 3&#125;
</code></pre>
<blockquote>
<ul>
<li><code>localStorage</code>对象的 <code>length</code> 属性表示存在的 key 和 value 键值对有多少项。</li>
</ul>
</blockquote>
<pre><code>console.log(localStorage.length); // 3
</code></pre>
<ol start="2">
<li>localStorage 对象的方法<blockquote>
<ul>
<li>其中<code>window.localStorage</code>对象身上提供了以下方法来操作数据。</li>
</ul>
</blockquote>
</li>
</ol>
<table>
<thead>
<tr>
<th>方法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>setItem(key,value)</td>
<td>为本地的 Local Storage 添加一个数据项。</td>
</tr>
<tr>
<td>getItem(key)</td>
<td>根据对应的键名，获取对应的键值</td>
</tr>
<tr>
<td>removeItem(key)</td>
<td>根据键名，移除指定项</td>
</tr>
<tr>
<td>clear()</td>
<td>移除所有的 Local Storage 项</td>
</tr>
</tbody></table>
<ul>
<li>setItem(key,value)<blockquote>
<ul>
<li>setItem(key,value) 为本地的 Local Storage <strong>添加</strong>一个数据项。</li>
</ul>
</blockquote>
</li>
</ul>
<pre><code>localStorage.setItem(&quot;font-size&quot;, &quot;12px&quot;);
localStorage.setItem(&quot;color&quot;, &quot;#666&quot;);
localStorage.setItem(&quot;background-color&quot;, &quot;skyblue&quot;);
</code></pre>
<ul>
<li>getItem(key)<blockquote>
<ul>
<li>getItem(key)根据对应的键名，获取对应的键值，获取不存在的会返回<code>null</code></li>
</ul>
</blockquote>
</li>
</ul>
<pre><code>localStorage.getItem(&quot;font-size&quot;); // &quot;12px&quot;
localStorage.getItem(&quot;color&quot;); // &quot;#666&quot;
localStorage.getItem(&quot;background-color&quot;); // &quot;skyblue&quot;
</code></pre>
<ul>
<li>removeItem(key)<blockquote>
<ul>
<li>removeItem(key)方法根据键名 key，移除指定项，如果删除不存在的 key，<strong>不会报错</strong>。这个方法没有返回值或返回<code>undefined</code></li>
</ul>
</blockquote>
</li>
</ul>
<pre><code>// 移除（删除）不存在的 key，不报错
localStorage.removeItem(&quot;username&quot;);
// 移除存在的指定项
localStorage.removeItem(&quot;font-size&quot;);
localStorage.removeItem(&quot;color&quot;);
</code></pre>
<ul>
<li>clear()<blockquote>
<ul>
<li>clear()方法用来<strong>移除所有的</strong><code>localStorage</code>数据项</li>
</ul>
</blockquote>
</li>
</ul>
<pre><code>// 移除所有
localStorage.clear();
&gt;
// 打印输入 localStorage
console.log(localStorage); // Storage &#123;length: 0&#125;
</code></pre>
<h3 id="十、localStorage-的注意事项"><a href="#十、localStorage-的注意事项" class="headerlink" title="十、localStorage 的注意事项"></a>十、localStorage 的注意事项</h3><ol>
<li>localStorage 的存储期限<blockquote>
<p>localStorage 是<strong>持久化</strong>的本地存储，除非手动清除（如 <strong>通过 JS 删除</strong>或<strong>清除浏览器缓存</strong>）否则，数据永远不会过期的。</p>
</blockquote>
</li>
</ol>
<ul>
<li>与 localStorage 对应的是 sessionStorage<blockquote>
<ul>
<li>sessionStorage 当前<strong>会话结束（如：关闭浏览器）</strong>的时候，sessionStorage 中的数据会被清空</li>
<li>操作 sessionStorage 的方法和操作 localStorage 的方法一模一样</li>
</ul>
</blockquote>
</li>
</ul>
<pre><code>// 添加项
sessionStorage.setItem(&quot;font-size&quot;, &quot;12px&quot;);
sessionStorage.setItem(&quot;color&quot;, &quot;#666&quot;);
sessionStorage.setItem(&quot;background-color&quot;, &quot;skyblue&quot;);
&gt;
// 打印sessionStorage
console.log(sessionStorage);
&gt;
// 获取指定项
console.log(sessionStorage.getItem(&quot;font-size&quot;));
&gt;
// 移除指定项
sessionStorage.removeItem(&quot;font-size&quot;);
sessionStorage.removeItem(&quot;color&quot;);
&gt;
// 移除所有项
sessionStorage.clear();
</code></pre>
<ul>
<li>localStorage 和 sessionStorage 什么时候用 ？<blockquote>
<ul>
<li>如需要<strong>永久化</strong>的存储一个数据，可保存在 <code>localStorage</code> 中</li>
<li>需要<strong>会话结束</strong>（关闭浏览器）就消失，可保存在 <code>sessionStorage</code> 中</li>
</ul>
</blockquote>
</li>
</ul>
<ol start="2">
<li><p>不同域名下能否共用 localStorage</p>
<blockquote>
<p>localStorage 是<strong>按域名</strong>来存储的，即<strong>同一个域名下的所有页面</strong>都可以访问该域名下的 <code>localStorage</code></p>
<p>但不同的域名下是<strong>不能共用</strong> localStorage 的</p>
<ul>
<li>我们自己域名下的 localStorage 别的域名是无法访问的，别的域名下的 localStorage 我们自己的域名也是不能访问的。</li>
</ul>
</blockquote>
</li>
<li><p>localStorage 的大小限制</p>
<blockquote>
<p>单个域名下的localStorage 总大小有限制（不超过<code>5MB</code>），但<strong>没有单个大小的限制</strong>。而 Cookie 是单个大小的限制，也跟浏览器有关系，不同浏览器大小限制不同。</p>
<ul>
<li>正常情况下是不会存满的，使用中不要超过限制即可，超过了会造成数据丢失。</li>
</ul>
</blockquote>
</li>
<li><p>localStorage 键和值的类型</p>
<blockquote>
<ul>
<li>localStorage 存储的键和值<strong>只能是字符串类型</strong></li>
<li>不是字符串类型，也会先转化成字符串类型再存进去（localStorage 会自动转的，不需要手动转换）</li>
</ul>
</blockquote>
</li>
</ol>
<pre><code>// key传入的是一个对象
localStorage.setItem(&#123;&#125;, &quot;hello&quot;);
console.log(localStorage.getItem(&quot;[object Object]&quot;)); // hello
&gt;
// value传入的是一个对象
localStorage.setItem(&quot;skinTheme&quot;, &#123;
  &quot;font-size&quot;: &quot;12px&quot;,
  color: &quot;#666&quot;,
  &quot;background-color&quot;: &quot;skyblue&quot;,
&#125;);
console.log(localStorage);
// 打印结果 Storage &#123;skinTheme: &#39;[object Object]&#39;, [object Object]: &#39;hello&#39;, length: 2&#125;
</code></pre>
<h3 id="十一、localStorage-的封装"><a href="#十一、localStorage-的封装" class="headerlink" title="十一、localStorage 的封装"></a>十一、localStorage 的封装</h3><blockquote>
<ul>
<li>因为 localStorage 的键和值<strong>只能是字符串类型</strong>的</li>
<li>但很多时候我们希望保存的 value 值是一个<strong>对象</strong>，根据对应的 key 来取值时，也能取出对应的对象。<blockquote>
<p>这就需要我们人为的来封装一个类来实现。</p>
</blockquote>
</li>
</ul>
</blockquote>
<ol>
<li>封装 storage 对象<blockquote>
<p>新建<code>storage.js</code>文件，封装成一个模块 ，创建一个 storage 对象，添加三个方法，将 storage 对象做为默认接口导出</p>
<ul>
<li>set 方法，添加一项数据</li>
<li>get 方法，通过指定的 key 来获取数据</li>
<li>remove 方法，根据 key 来移除指定的数据项</li>
<li>has 方法，根据 key 来判断是否存在指定项</li>
<li>clear() 清除所有项</li>
</ul>
</blockquote>
</li>
</ol>
<pre><code>// storage.js模块 默认导出一个对象
export default &#123;
  // 根据key value 添加一项数据
  set(key, value) &#123;
    if (typeof value === &quot;object&quot;) &#123;
      value = JSON.stringify(value); // 将对象转成JSON字符串
    &#125;
    localStorage.setItem(key, value);
  &#125;,
  // 根据key来获取指定项
  get(key) &#123;
    const data = localStorage.getItem(key);
    try &#123;
      return JSON.parse(data); // 将字符串转换为对象
    &#125; catch (err) &#123;
      return data;
    &#125;
  &#125;,
  // 根据key来删除指定项
  remove(key) &#123;
    localStorage.removeItem(key);
  &#125;,
&gt;
  // 根据key来判断是否存在指定项
  has(key) &#123;
    const value = localStorage.getItem(key);
    return value ? true : false;
  &#125;,
&gt;
  // clear() 清除所有项
  clear() &#123;
    localStorage.clear();
  &#125;,
&#125;;
</code></pre>
<blockquote>
<ul>
<li>在<code>get(key)</code>时，需要将字符串转成对象，如果key&#x3D;undefined，就会报错，所以用<code>try...catch</code>捕获错误，直接返回value值</li>
</ul>
</blockquote>
<ul>
<li>新建<code>index.html</code>页面，添加如下代码，测试封装好的模块</li>
</ul>
<pre><code>&gt;&lt;script type=&quot;module&quot;&gt;
  import storage from &quot;./storage.js&quot;;
  // 添加
  storage.set(&quot;skinTheme&quot;, &#123;
    &quot;font-size&quot;: &quot;12px&quot;,
    color: &quot;#666&quot;,
    &quot;background-color&quot;: &quot;skyblue&quot;,
  &#125;);
  storage.set(&quot;history&quot;, [1, 2, 3, 4, 5]);
  storage.set(&quot;username&quot;, &quot;清心&quot;);
  storage.set(&quot;空&quot;, null);
&gt;
  // 获取
  console.log(storage.get(&quot;username&quot;)); // 清心
  console.log(storage.get(&quot;history&quot;)); // [1, 2, 3, 4, 5]
&gt;
  // 移除
  storage.remove(&quot;空&quot;);
  storage.remove(&quot;history&quot;);
&gt;
  // 判断是否存在
  console.log(storage.has(&quot;skinTheme&quot;)); // true
  console.log(storage.has(&quot;ab&quot;)); // false
&gt;&lt;/script&gt;
</code></pre>
<h3 id="十二、localStorage-在实际开发中的应用"><a href="#十二、localStorage-在实际开发中的应用" class="headerlink" title="十二、localStorage 在实际开发中的应用"></a>十二、localStorage 在实际开发中的应用</h3><h4 id="案例一：添加搜索历史记录"><a href="#案例一：添加搜索历史记录" class="headerlink" title="案例一：添加搜索历史记录"></a>案例一：添加搜索历史记录</h4><blockquote>
<p>当用户在搜索框搜索对应的关键字时，会把用户搜索过的关键字保存在搜索框下面，并且只限定能放 <code>6</code> 个，超过了就删除最早加入的，当然也可以手动删除不想要的。</p>
</blockquote>
<ol>
<li>HTML布局</li>
</ol>
<pre><code>&gt;&lt;style&gt;
  input,
  button &#123;
    box-sizing: border-box;
    outline: none;
  &#125;
  .search &#123;
    width: 600px;
    margin: 50px auto;
  &#125;
  .search-wrap &#123;
    display: flex;
    height: 70px;
  &#125;
  .search-input &#123;
    width: 680px;
    height: 50px;
    border: 1px solid #ddd;
    border-right: 0px;
    border-radius: 5px 0 0 5px;
  &#125;
  .search-input::placeholder &#123;
    font-size: 20px;
  &#125;
  .search-button &#123;
    width: 120px;
    height: 50px;
    background-color: orange;
    border: none;
    color: #fff;
    font-size: 24px;
    cursor: pointer;
  &#125;
&gt;
  .keywords-wrap span &#123;
    display: inline-block;
    background-color: #ddd;
    padding: 5px 10px;
    border-radius: 2px;
    margin: 5px;
    position: relative;
    cursor: pointer;
  &#125;
  .keywords-wrap span i &#123;
    display: block;
    width: 15px;
    height: 15px;
    position: absolute;
    right: -2px;
    top: -2px;
    background-color: orange;
    border-radius: 10px;
    font-size: 12px;
    text-align: center;
    line-height: 10px;
    color: #fff;
    display: none;
    cursor: pointer;
  &#125;
  .keywords-wrap span:hover i &#123;
    display: block;
  &#125;
&gt;&lt;/style&gt;
&gt;&lt;body&gt;
&gt;  &lt;div class=&quot;search&quot;&gt;
&gt;    &lt;div class=&quot;search-wrap&quot;&gt;
&gt;      &lt;input type=&quot;text&quot; placeholder=&quot;请输入搜索关键字&quot; class=&quot;search-input&quot; /&gt;
&gt;      &lt;button class=&quot;search-button&quot;&gt;搜索&lt;/button&gt;
&gt;    &lt;/div&gt;
&gt;
&gt;    &lt;div class=&quot;keywords-wrap&quot;&gt;
&gt;      &lt;!-- 
&gt;        &lt;span&gt;漂亮的包包&lt;i&gt;x&lt;/i&gt;&lt;/span&gt;          
&gt;        &lt;span&gt;衣服&lt;i&gt;x&lt;/i&gt;&lt;/span&gt;
&gt;        &lt;span&gt;女性化妆品 &lt;i&gt;x&lt;/i&gt;&lt;/span&gt;
&gt;        &lt;span&gt;洗面奶&lt;i&gt;x&lt;/i&gt;&lt;/span&gt;
&gt;        &lt;span&gt;小米手机 &lt;i&gt;x&lt;/i&gt;&lt;/span&gt;
&gt;        &lt;span&gt;图解HTTP&lt;i&gt;x&lt;/i&gt;&lt;/span&gt;
&gt;        &lt;span&gt;你不知道的Javascript&lt;i&gt;x&lt;/i&gt;&lt;/span&gt;
&gt;        &lt;span&gt;ES6标准入门&lt;i&gt;x&lt;/i&gt;&lt;/span&gt;
&gt;      --&gt;
&gt;    &lt;/div&gt;
&gt;  &lt;/div&gt;
&gt;&lt;/body&gt;
</code></pre>
<ol start="2">
<li>JS 代码实现逻辑</li>
</ol>
<ul>
<li>第一步：操作输入框中的关键词<blockquote>
<p>给搜索按钮添加点击事件，获取关键字，创建对象</p>
<ul>
<li>获取 DOM 元素：搜索框、搜索按扭、关键词容器</li>
<li>如果搜索框有内容，就创建一个对象，里面保存关键词的信息，<code>obj=&#123;id:id值,keyword:value&#125;</code></li>
<li>定义一个数组<code>let keywordsArr = []</code>，用来保存每次搜索的关键字对象</li>
<li>创建对象后，将对象添加进数组<ul>
<li>判断搜索框有内容：去掉前后空格</li>
<li><code>id</code>值通过时间戳创建唯一的id值</li>
</ul>
</li>
</ul>
<p>将关键词插入到页面</p>
<ul>
<li>新建<code>span</code>节点，将关键词、删除按钮添加到节点中</li>
<li>给<code>span</code>设置<strong>自定义属性</strong><code>data-id</code>，保存和关键词一样的id，便于删除<br>如果数据长度超出限制：</li>
<li>将关键词容器的第一个节点删除</li>
<li>将数组中的第一个元素删除</li>
</ul>
<p>将对象保存到<code>localStorage</code>中</p>
<ul>
<li>使用<code>storage</code>模块，将数组中对应数据存入<code>storage</code><blockquote>
<p>用户输入内容，点击搜索后，清空搜素框：在获取输入框的<code>value</code>值之后，将其设置为空内容</p>
</blockquote>
</li>
</ul>
</blockquote>
</li>
</ul>
<pre><code>//导入模块
import storage from &quot;./storage.js&quot;;
// 获取输入框和搜索按扭
const searchInput = document.querySelector(&quot;.search-input&quot;);
const searchButton = document.querySelector(&quot;.search-button&quot;);
// 获取（历史搜索）存放关键词容器
const keywords = document.querySelector(&quot;.keywords-wrap&quot;);
// 用来保存关键字的数组
let keywordsArr = [];
&gt;
// 点击搜索按扭
searchButton.addEventListener(&quot;click&quot;, () =&gt; &#123;
  let value = searchInput.value;
  searchInput.value = &quot;&quot;;//获取value后，清空搜索框
  // 如果内容去掉前后空格，还有内容，将内容添加到页面中
  if (value.trim()) &#123;
    // 创建一条数据
    const obj = &#123;
      id: new Date().getTime(),
      keyword: value,
    &#125;;
    // 创建span标签
    const span = document.createElement(&quot;span&quot;);
    span.dataset.id = obj.id; // 添加唯一标识
    span.innerHTML = `$&#123;value&#125;&lt;i&gt;x&lt;/i&gt;`;
    // span标签添加到页面
    keywords.appendChild(span);
    // 将内容添加到数组的尾部保存起来
&gt;
    keywordsArr.push(obj);
    // 因为记录的数据不能超过6条，所以要判断，如果超过，则删除第一条
    if (keywordsArr.length &gt; 6) &#123;
      // 数组中将第一个元素删除
      keywordsArr.shift();
      // DOM中也将第一个元素删除
      keywords.removeChild(keywords.children[0]);
    &#125;
    // 将数组中对应的数据存入到localStorage中
    storage.set(&quot;history&quot;, keywordsArr);
  &#125;
&#125;);
</code></pre>
<ul>
<li>第二步：读取<code>localStorage</code>中的数据，显示在页面中<blockquote>
<ul>
<li>当关闭页面后，再次打开，搜索框下的内容就消失了，所以需要每次打开页面时，把 <code>localStorage</code> 中存储的数据取出来插入到页面中<ul>
<li>通过<code>storage</code>模块的<code>get</code>方法将<code>history</code>拿出来<blockquote>
<p>虽然我们存进去的是一个数组，但取出来的是一个对象，模块里用<code>Json</code>做了处理</p>
</blockquote>
</li>
</ul>
</li>
<li>这里要考虑<strong>第一次打开页面</strong>时，localStorage 中还没有存任何数据，所以取出的 localStorage 数据可能为 <code>undefined</code>，所以需要判断数据是否存在<ul>
<li>如果存在，就遍历取出的数据，生成 DOM 插入到页面</li>
</ul>
</li>
</ul>
</blockquote>
</li>
</ul>
<pre><code>showKeyWords();
function showKeyWords() &#123;
  //获取history
  const storageDate = storage.get(&quot;history&quot;); //拿到的是一个对象
  //判断数据是否存在
  if (storage) &#123;
    //将数据存入数组
    keywordArr = storageDate;
    //for...of遍历对象 将其插入到页面中
    for (let &#123; id, keyword &#125; of storageDate) &#123;
      const span = document.createElement(&quot;span&quot;);
      //给span添加和id相同的唯一标识
      span.dataset.id = id;
      span.innerHTML = `$&#123;keyword&#125;&lt;i&gt;x&lt;/x&gt;`;
      //将内容生成DOM插入页面
      keywrap.appendChild(span);
    &#125;
  &#125;
&#125;
</code></pre>
<ul>
<li>第三步：点击关键字右侧顶部的删除按扭，<strong>删除对应关键字</strong><blockquote>
<p>利用事件代理，给<code>keywords-wrap</code>添加点击事件，如果点击的元素是<code>&lt;i&gt;</code>标签，就</p>
<ul>
<li>删除对应关键词的DOM标签<ul>
<li>通过i标签的父元素的父元素删除</li>
</ul>
</li>
<li><strong>更新</strong><code>localStorage</code>；为了下一次打开的时候不出现已删除关键词，就得把<code>storage</code>里面的数据更新；而<code>storage</code>里面的数据是通过数组存进来的，所以先更新数组，再用新数组更新<code>localStorage</code><ul>
<li>删除数组中的数据：获取i标签的父元素对应的id值；遍历数组，找到有相同id的对象，获取其下标，根据下标删除</li>
<li>重新给<code>localStorage</code>赋值</li>
</ul>
</li>
</ul>
</blockquote>
</li>
</ul>
<h4 id="案例2：更改网站皮肤"><a href="#案例2：更改网站皮肤" class="headerlink" title="案例2：更改网站皮肤"></a>案例2：更改网站皮肤</h4><blockquote>
<p>大家可以自己去实现，可以参考 MDN 官方网站给出的实例<code>https://mdn.github.io/dom-examples/web-storage/</code></p>
</blockquote>
<h3 id="面试题"><a href="#面试题" class="headerlink" title="面试题"></a>面试题</h3><ul>
<li>Cookie、localStorage、sessionStorage 的对比（面试题）<table>
<thead>
<tr>
<th>对比项</th>
<th>Cookie</th>
<th>LocalStorage</th>
<th>sessionStorage</th>
</tr>
</thead>
<tbody><tr>
<td>存储大小</td>
<td>4K</td>
<td>5M</td>
<td>5M</td>
</tr>
<tr>
<td>有效期</td>
<td>手动设置</td>
<td>无</td>
<td>浏览器窗口关闭</td>
</tr>
<tr>
<td>存储位置</td>
<td>浏览器</td>
<td>浏览器</td>
<td>浏览器</td>
</tr>
<tr>
<td>与请求一起发送</td>
<td>是</td>
<td>否</td>
<td>否</td>
</tr>
<tr>
<td>访问限止</td>
<td>子域可以访问自己和父域中的</td>
<td>Cookie	同域下都可以访问</td>
<td>只限当前窗口</td>
</tr>
</tbody></table>
</li>
</ul>

                
            </div>
            <hr/>

            

    <div class="reprint" id="reprint-statement">
        
            <div class="reprint__author">
                <span class="reprint-meta" style="font-weight: bold;">
                    <i class="fas fa-user">
                        文章作者:
                    </i>
                </span>
                <span class="reprint-info">
                    <a href="/about" rel="external nofollow noreferrer">hermia</a>
                </span>
            </div>
            <div class="reprint__type">
                <span class="reprint-meta" style="font-weight: bold;">
                    <i class="fas fa-link">
                        文章链接:
                    </i>
                </span>
                <span class="reprint-info">
                    <a href="https://hermiablog.com/2024/01/18/%E7%BD%91%E7%BB%9C%EF%BC%88%E4%B8%80%EF%BC%89/">https://hermiablog.com/2024/01/18/%E7%BD%91%E7%BB%9C%EF%BC%88%E4%B8%80%EF%BC%89/</a>
                </span>
            </div>
            <div class="reprint__notice">
                <span class="reprint-meta" style="font-weight: bold;">
                    <i class="fas fa-copyright">
                        版权声明:
                    </i>
                </span>
                <span class="reprint-info">
                    本博客所有文章除特別声明外，均采用
                    <a href="https://creativecommons.org/licenses/by/4.0/deed.zh" rel="external nofollow noreferrer" target="_blank">CC BY 4.0</a>
                    许可协议。转载请注明来源
                    <a href="/about" target="_blank">hermia</a>
                    !
                </span>
            </div>
        
    </div>

    <script async defer>
      document.addEventListener("copy", function (e) {
        let toastHTML = '<span>复制成功，请遵循本文的转载规则</span><button class="btn-flat toast-action" onclick="navToReprintStatement()" style="font-size: smaller">查看</a>';
        M.toast({html: toastHTML})
      });

      function navToReprintStatement() {
        $("html, body").animate({scrollTop: $("#reprint-statement").offset().top - 80}, 800);
      }
    </script>



            <div class="tag_share" style="display: block;">
                <div class="post-meta__tag-list" style="display: inline-block;">
                    
                        <div class="article-tag">
                            
                                <a href="/tags/%E7%BD%91%E7%BB%9C/">
                                    <span class="chip bg-color">网络</span>
                                </a>
                            
                        </div>
                    
                </div>
                <div class="post_share" style="zoom: 80%; width: fit-content; display: inline-block; float: right; margin: -0.15rem 0;">
                    <link rel="stylesheet" type="text/css" href="/libs/share/css/share.min.css">
<div id="article-share">

    
    <div class="social-share" data-sites="qq,qzone,wechat,weibo" data-wechat-qrcode-helper="<p>微信扫一扫即可分享！</p>"></div>
    <script src="/libs/share/js/social-share.min.js"></script>
    

    

</div>

                </div>
            </div>
            
                <style>
    #reward {
        margin: 40px 0;
        text-align: center;
    }

    #reward .reward-link {
        font-size: 1.4rem;
        line-height: 38px;
    }

    #reward .btn-floating:hover {
        box-shadow: 0 6px 12px rgba(0, 0, 0, 0.2), 0 5px 15px rgba(0, 0, 0, 0.2);
    }

    #rewardModal {
        width: 320px;
        height: 350px;
    }

    #rewardModal .reward-title {
        margin: 15px auto;
        padding-bottom: 5px;
    }

    #rewardModal .modal-content {
        padding: 10px;
    }

    #rewardModal .close {
        position: absolute;
        right: 15px;
        top: 15px;
        color: rgba(0, 0, 0, 0.5);
        font-size: 1.3rem;
        line-height: 20px;
        cursor: pointer;
    }

    #rewardModal .close:hover {
        color: #ef5350;
        transform: scale(1.3);
        -moz-transform:scale(1.3);
        -webkit-transform:scale(1.3);
        -o-transform:scale(1.3);
    }

    #rewardModal .reward-tabs {
        margin: 0 auto;
        width: 210px;
    }

    .reward-tabs .tabs {
        height: 38px;
        margin: 10px auto;
        padding-left: 0;
    }

    .reward-content ul {
        padding-left: 0 !important;
    }

    .reward-tabs .tabs .tab {
        height: 38px;
        line-height: 38px;
    }

    .reward-tabs .tab a {
        color: #fff;
        background-color: #ccc;
    }

    .reward-tabs .tab a:hover {
        background-color: #ccc;
        color: #fff;
    }

    .reward-tabs .wechat-tab .active {
        color: #fff !important;
        background-color: #22AB38 !important;
    }

    .reward-tabs .alipay-tab .active {
        color: #fff !important;
        background-color: #019FE8 !important;
    }

    .reward-tabs .reward-img {
        width: 210px;
        height: 210px;
    }
</style>

<div id="reward">
    <a href="#rewardModal" class="reward-link modal-trigger btn-floating btn-medium waves-effect waves-light red">赏</a>

    <!-- Modal Structure -->
    <div id="rewardModal" class="modal">
        <div class="modal-content">
            <a class="close modal-close"><i class="fas fa-times"></i></a>
            <h4 class="reward-title">你的赏识是我前进的动力</h4>
            <div class="reward-content">
                <div class="reward-tabs">
                    <ul class="tabs row">
                        <li class="tab col s6 alipay-tab waves-effect waves-light"><a href="#alipay">支付宝</a></li>
                        <li class="tab col s6 wechat-tab waves-effect waves-light"><a href="#wechat">微 信</a></li>
                    </ul>
                    <div id="alipay">
                        <img src="/medias/reward/alipay.jpg" class="reward-img" alt="支付宝打赏二维码">
                    </div>
                    <div id="wechat">
                        <img src="/medias/reward/wechat.png" class="reward-img" alt="微信打赏二维码">
                    </div>
                </div>
            </div>
        </div>
    </div>
</div>

<script>
    $(function () {
        $('.tabs').tabs();
    });
</script>

            
        </div>
    </div>

    

    

    

    

    

    

    

    

<article id="prenext-posts" class="prev-next articles">
    <div class="row article-row">
        
        <div class="article col s12 m6" data-aos="fade-up">
            <div class="article-badge left-badge text-color">
                <i class="fas fa-chevron-left"></i>&nbsp;上一篇</div>
            <div class="card">
                <a href="/2024/01/20/%E7%BD%91%E7%BB%9C%EF%BC%88%E4%BA%8C%EF%BC%89/">
                    <div class="card-image">
                        
                        <img src="/medias/featureimages/40.jpg" class="responsive-img" alt="网络（二）">
                        
                        <span class="card-title">网络（二）</span>
                    </div>
                </a>
                <div class="card-content article-content">
                    <div class="summary block-with-text">
                        
                            JSON、Ajax、跨域、XHR、Fetch
                        
                    </div>
                    <div class="publish-info">
                        <span class="publish-date">
                            <i class="far fa-clock fa-fw icon-date"></i>2024-01-20
                        </span>
                        <span class="publish-author">
                            
                            <i class="fas fa-bookmark fa-fw icon-category"></i>
                            
                            <a href="/categories/%E6%8A%80%E6%9C%AF/" class="post-category">
                                    技术
                                </a>
                            
                            
                        </span>
                    </div>
                </div>
                
                <div class="card-action article-tags">
                    
                    <a href="/tags/%E7%BD%91%E7%BB%9C/">
                        <span class="chip bg-color">网络</span>
                    </a>
                    
                </div>
                
            </div>
        </div>
        
        
        <div class="article col s12 m6" data-aos="fade-up">
            <div class="article-badge right-badge text-color">
                下一篇&nbsp;<i class="fas fa-chevron-right"></i>
            </div>
            <div class="card">
                <a href="/2024/01/11/%E5%89%8D%E7%AB%AF%E5%B7%A5%E7%A8%8B%E5%8C%96%EF%BC%88%E4%BA%8C%EF%BC%89/">
                    <div class="card-image">
                        
                        <img src="/medias/featureimages/38.jpg" class="responsive-img" alt="前端工程化（二）">
                        
                        <span class="card-title">前端工程化（二）</span>
                    </div>
                </a>
                <div class="card-content article-content">
                    <div class="summary block-with-text">
                        
                            Webpack5核心基础、预处理器、插件、兼容性处理、开发环境配置、生产环境优化
                        
                    </div>
                    <div class="publish-info">
                            <span class="publish-date">
                                <i class="far fa-clock fa-fw icon-date"></i>2024-01-11
                            </span>
                        <span class="publish-author">
                            
                            <i class="fas fa-bookmark fa-fw icon-category"></i>
                            
                            <a href="/categories/%E6%8A%80%E6%9C%AF/" class="post-category">
                                    技术
                                </a>
                            
                            
                        </span>
                    </div>
                </div>
                
                <div class="card-action article-tags">
                    
                    <a href="/tags/%E5%B7%A5%E7%A8%8B%E5%8C%96/">
                        <span class="chip bg-color">工程化</span>
                    </a>
                    
                </div>
                
            </div>
        </div>
        
    </div>
</article>

</div>



<!-- 代码块功能依赖 -->
<script type="text/javascript" src="/libs/codeBlock/codeBlockFuction.js"></script>

<!-- 代码语言 -->

<script type="text/javascript" src="/libs/codeBlock/codeLang.js"></script>


<!-- 代码块复制 -->

<script type="text/javascript" src="/libs/codeBlock/codeCopy.js"></script>


<!-- 代码块收缩 -->

<script type="text/javascript" src="/libs/codeBlock/codeShrink.js"></script>


  </div>
  <div id="toc-aside" class="expanded col l3 hide-on-med-and-down">
    <div class="toc-widget card" style="background-color: white">
      <div class="toc-title">
        <i class="far fa-list-alt"></i>&nbsp;&nbsp;目录
      </div>
      <div id="toc-content"></div>
    </div>
  </div>
</div>

<!-- TOC 悬浮按钮. -->

<div id="floating-toc-btn" class="hide-on-med-and-down">
  <a class="btn-floating btn-large bg-color">
    <i class="fas fa-list-ul"></i>
  </a>
</div>


<script src="/libs/tocbot/tocbot.min.js"></script>
<script>
  $(function () {
      tocbot.init({
          tocSelector: '#toc-content',
          contentSelector: '#articleContent',
          headingsOffset: -($(window).height() * 0.4 - 45),
          collapseDepth: Number('0'),
          headingSelector: 'h2, h3, h4'
      });

      // modify the toc link href to support Chinese.
      let i = 0;
      let tocHeading = 'toc-heading-';
      $('#toc-content a').each(function () {
          $(this).attr('href', '#' + tocHeading + (++i));
      });

      // modify the heading title id to support Chinese.
      i = 0;
      $('#articleContent').children('h2, h3, h4').each(function () {
          $(this).attr('id', tocHeading + (++i));
      });

      // Set scroll toc fixed.
      let tocHeight = parseInt($(window).height() * 0.4 - 64);
      let $tocWidget = $('.toc-widget');
      $(window).scroll(function () {
          let scroll = $(window).scrollTop();
          /* add post toc fixed. */
          if (scroll > tocHeight) {
              $tocWidget.addClass('toc-fixed');
          } else {
              $tocWidget.removeClass('toc-fixed');
          }
      });

      
      /* 修复文章卡片 div 的宽度. */
      let fixPostCardWidth = function (srcId, targetId) {
          let srcDiv = $('#' + srcId);
          if (srcDiv.length === 0) {
              return;
          }

          let w = srcDiv.width();
          if (w >= 450) {
              w = w + 21;
          } else if (w >= 350 && w < 450) {
              w = w + 18;
          } else if (w >= 300 && w < 350) {
              w = w + 16;
          } else {
              w = w + 14;
          }
          $('#' + targetId).width(w);
      };

      // 切换TOC目录展开收缩的相关操作.
      const expandedClass = 'expanded';
      let $tocAside = $('#toc-aside');
      let $mainContent = $('#main-content');
      $('#floating-toc-btn .btn-floating').click(function () {
          if ($tocAside.hasClass(expandedClass)) {
              $tocAside.removeClass(expandedClass).hide();
              $mainContent.removeClass('l9');
          } else {
              $tocAside.addClass(expandedClass).show();
              $mainContent.addClass('l9');
          }
          fixPostCardWidth('artDetail', 'prenext-posts');
      });
      
  });
</script>

    

</main>




    <footer class="page-footer bg-color">
   <link rel="stylesheet" href="/libs/aplayer/APlayer.min.css">
<style>
    .aplayer .aplayer-lrc p {
        
        font-size: 12px;
        font-weight: 700;
        line-height: 16px !important;
    }

    .aplayer .aplayer-lrc p.aplayer-lrc-current {
        
        font-size: 15px;
        color: #a3ddf0;
        /* color: #59cde9; */
    }

    
    .aplayer.aplayer-fixed.aplayer-narrow .aplayer-body {
        left: -66px !important;
    }

    .aplayer.aplayer-fixed.aplayer-narrow .aplayer-body:hover {
        left: 0px !important;
    }

    
</style>
<div class="">
    
    <div class="row">
        <meting-js class="col l8 offset-l2 m10 offset-m1 s12"
                   server="netease"
                   type="playlist"
                   id="2450546498"
                   fixed='true'
                   autoplay='false'
                   theme='#59cde9'
                   loop='all'
                   order='random'
                   preload='auto'
                   volume='0.7'
                   list-folded='true'
        >
        </meting-js>
    </div>
</div>

<script src="/libs/aplayer/APlayer.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/meting@2/dist/Meting.min.js"></script>
 
  <div
    class="container row center-align"
    style="margin-bottom: 15px !important;"
  >
    <div class="col s12 m8 l8 copy-right">
      Copyright&nbsp;&copy; 
      <span id="year"
        >2023-2024</span
      >
      
      <span id="year">2023</span>
      <a href="/about" target="_blank"
        >hermia</a
      >
      |&nbsp;Powered by&nbsp;<a href="https://hexo.io/" target="_blank">Hexo</a>
      |&nbsp;Theme&nbsp;<a
        href="https://github.com/blinkfox/hexo-theme-matery"
        target="_blank"
        >Matery</a
      >
      <br />
           
      <span id="busuanzi_container_site_pv">
        |&nbsp;<i class="far fa-eye"></i>&nbsp;总访问量:&nbsp;<span
          id="busuanzi_value_site_pv"
          class="white-color"
        ></span
        >&nbsp;次
      </span>
       
      <span id="busuanzi_container_site_uv">
        |&nbsp;<i class="fas fa-users"></i>&nbsp;总访问人数:&nbsp;<span
          id="busuanzi_value_site_uv"
          class="white-color"
        ></span
        >&nbsp;人
      </span>
      
      <br />
      
      <span id="sitetime">载入运行时间...</span>
      <script>
        function siteTime() {
          var seconds = 1000;
          var minutes = seconds * 60;
          var hours = minutes * 60;
          var days = hours * 24;
          var years = days * 365;
          var today = new Date();
          var startYear = "2023";
          var startMonth = "11";
          var startDate = "14";
          var startHour = "0";
          var startMinute = "0";
          var startSecond = "0";
          var todayYear = today.getFullYear();
          var todayMonth = today.getMonth() + 1;
          var todayDate = today.getDate();
          var todayHour = today.getHours();
          var todayMinute = today.getMinutes();
          var todaySecond = today.getSeconds();
          var t1 = Date.UTC(
            startYear,
            startMonth,
            startDate,
            startHour,
            startMinute,
            startSecond
          );
          var t2 = Date.UTC(
            todayYear,
            todayMonth,
            todayDate,
            todayHour,
            todayMinute,
            todaySecond
          );
          var diff = t2 - t1;
          var diffYears = Math.floor(diff / years);
          var diffDays = Math.floor(diff / days - diffYears * 365);
          var diffHours = Math.floor(
            (diff - (diffYears * 365 + diffDays) * days) / hours
          );
          var diffMinutes = Math.floor(
            (diff - (diffYears * 365 + diffDays) * days - diffHours * hours) /
              minutes
          );
          var diffSeconds = Math.floor(
            (diff -
              (diffYears * 365 + diffDays) * days -
              diffHours * hours -
              diffMinutes * minutes) /
              seconds
          );
          if (startYear == todayYear) {
            document.getElementById("year").innerHTML = todayYear;
            document.getElementById("sitetime").innerHTML =
              "本站已安全运行 " +
              diffDays +
              " 天 " +
              diffHours +
              " 小时 " +
              diffMinutes +
              " 分钟 " +
              diffSeconds +
              " 秒";
          } else {
            document.getElementById("year").innerHTML =
              startYear + " - " + todayYear;
            document.getElementById("sitetime").innerHTML =
              "本站已安全运行 " +
              diffYears +
              " 年 " +
              diffDays +
              " 天 " +
              diffHours +
              " 小时 " +
              diffMinutes +
              " 分钟 " +
              diffSeconds +
              " 秒";
          }
        }
        setInterval(siteTime, 1000);
      </script>
      
      <br />
      
    </div>
    <div class="col s12 m4 l4 social-link social-statis">
      
<a
  href="https://github.com/hermiablog/hermiablog.github.io"
  class="tooltipped"
  target="_blank"
  data-tooltip="访问我的GitHub"
  data-position="top"
  data-delay="50"
>
  <i class="fab fa-github"></i>
</a>
 
<a
  href="mailto:1587837237@qq.com"
  class="tooltipped"
  target="_blank"
  data-tooltip="邮件联系我"
  data-position="top"
  data-delay="50"
>
  <i class="fas fa-envelope-open"></i>
</a>
<!-- 
   
<a
  href="tencent://AddContact/?fromId=50&fromSubId=1&subcmd=all&uin=1587837237"
  class="tooltipped"
  target="_blank"
  data-tooltip="QQ联系我: 1587837237"
  data-position="top"
  data-delay="50"
>
  <i class="fab fa-qq"></i>
</a>
    -->

    </div>
  </div>
</footer>

<div class="progress-bar"></div>


    <!-- 搜索遮罩框 -->
<div id="searchModal" class="modal">
    <div class="modal-content">
        <div class="search-header">
            <span class="title"><i class="fas fa-search"></i>&nbsp;&nbsp;搜索</span>
            <input type="search" id="searchInput" name="s" placeholder="请输入搜索的关键字"
                   class="search-input">
        </div>
        <div id="searchResult"></div>
    </div>
</div>

<script type="text/javascript">
$(function () {
    var searchFunc = function (path, search_id, content_id) {
        'use strict';
        $.ajax({
            url: path,
            dataType: "xml",
            success: function (xmlResponse) {
                // get the contents from search data
                var datas = $("entry", xmlResponse).map(function () {
                    return {
                        title: $("title", this).text(),
                        content: $("content", this).text(),
                        url: $("url", this).text()
                    };
                }).get();
                var $input = document.getElementById(search_id);
                var $resultContent = document.getElementById(content_id);
                $input.addEventListener('input', function () {
                    var str = '<ul class=\"search-result-list\">';
                    var keywords = this.value.trim().toLowerCase().split(/[\s\-]+/);
                    $resultContent.innerHTML = "";
                    if (this.value.trim().length <= 0) {
                        return;
                    }
                    // perform local searching
                    datas.forEach(function (data) {
                        var isMatch = true;
                        var data_title = data.title.trim().toLowerCase();
                        var data_content = data.content.trim().replace(/<[^>]+>/g, "").toLowerCase();
                        var data_url = data.url;
                        data_url = data_url.indexOf('/') === 0 ? data.url : '/' + data_url;
                        var index_title = -1;
                        var index_content = -1;
                        var first_occur = -1;
                        // only match artiles with not empty titles and contents
                        if (data_title !== '' && data_content !== '') {
                            keywords.forEach(function (keyword, i) {
                                index_title = data_title.indexOf(keyword);
                                index_content = data_content.indexOf(keyword);
                                if (index_title < 0 && index_content < 0) {
                                    isMatch = false;
                                } else {
                                    if (index_content < 0) {
                                        index_content = 0;
                                    }
                                    if (i === 0) {
                                        first_occur = index_content;
                                    }
                                }
                            });
                        }
                        // show search results
                        if (isMatch) {
                            str += "<li><a href='" + data_url + "' class='search-result-title'>" + data_title + "</a>";
                            var content = data.content.trim().replace(/<[^>]+>/g, "");
                            if (first_occur >= 0) {
                                // cut out 100 characters
                                var start = first_occur - 20;
                                var end = first_occur + 80;
                                if (start < 0) {
                                    start = 0;
                                }
                                if (start === 0) {
                                    end = 100;
                                }
                                if (end > content.length) {
                                    end = content.length;
                                }
                                var match_content = content.substr(start, end);
                                // highlight all keywords
                                keywords.forEach(function (keyword) {
                                    var regS = new RegExp(keyword, "gi");
                                    match_content = match_content.replace(regS, "<em class=\"search-keyword\">" + keyword + "</em>");
                                });

                                str += "<p class=\"search-result\">" + match_content + "...</p>"
                            }
                            str += "</li>";
                        }
                    });
                    str += "</ul>";
                    $resultContent.innerHTML = str;
                });
            }
        });
    };

    searchFunc('/search.xml', 'searchInput', 'searchResult');
});
</script>

    <!-- 回到顶部按钮 -->
<div id="backTop" class="top-scroll">
    <a class="btn-floating btn-large waves-effect waves-light" href="#!">
        <i class="fas fa-arrow-up"></i>
    </a>
</div>


    <script src="/libs/materialize/materialize.min.js"></script>
    <script src="/libs/masonry/masonry.pkgd.min.js"></script>
    <script src="/libs/aos/aos.js"></script>
    <script src="/libs/scrollprogress/scrollProgress.min.js"></script>
    <script src="/libs/lightGallery/js/lightgallery-all.min.js"></script>
    <script src="/js/matery.js"></script>

    <!-- Baidu Analytics -->

    <!-- Baidu Push -->

<script>
    (function () {
        var bp = document.createElement('script');
        var curProtocol = window.location.protocol.split(':')[0];
        if (curProtocol === 'https') {
            bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';
        } else {
            bp.src = 'http://push.zhanzhang.baidu.com/push.js';
        }
        var s = document.getElementsByTagName("script")[0];
        s.parentNode.insertBefore(bp, s);
    })();
</script>

    
    <script src="/libs/others/clicklove.js" async="async"></script>
    
    
    <script async src="/libs/others/busuanzi.pure.mini.js"></script>
    

    

    

	
    

    

    

    
    <script src="/libs/instantpage/instantpage.js" type="module"></script>
    

</body>

</html>
