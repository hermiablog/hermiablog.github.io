<!DOCTYPE HTML>
<html lang="zh-CN">


<head>
    <meta charset="utf-8">
    <meta name="keywords" content="JS核心知识点（二十二）, 技术博客">
    <meta name="description" content="个人技术博客">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <meta name="renderer" content="webkit|ie-stand|ie-comp">
    <meta name="mobile-web-app-capable" content="yes">
    <meta name="format-detection" content="telephone=no">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <!-- Global site tag (gtag.js) - Google Analytics -->


    <title>JS核心知识点（二十二） | hermia&#39;s blog</title>
    <link rel="icon" type="image/png" href="/favicon.png">

    <link rel="stylesheet" type="text/css" href="/libs/awesome/css/all.css">
    <link rel="stylesheet" type="text/css" href="/libs/materialize/materialize.min.css">
    <link rel="stylesheet" type="text/css" href="/libs/aos/aos.css">
    <link rel="stylesheet" type="text/css" href="/libs/animate/animate.min.css">
    <link rel="stylesheet" type="text/css" href="/libs/lightGallery/css/lightgallery.min.css">
    <link rel="stylesheet" type="text/css" href="/css/matery.css">
    <link rel="stylesheet" type="text/css" href="/css/my.css">

    <script src="/libs/jquery/jquery.min.js"></script>

<meta name="generator" content="Hexo 6.3.0"><link rel="stylesheet" href="/css/prism-tomorrow.css" type="text/css"></head>



   <style>
    body{
       background-image: url(https://cdn.pixabay.com/photo/2012/04/14/16/37/sky-34536_1280.png);
       background-repeat:no-repeat;
       background-size:cover;
       background-attachment:fixed;
    }
</style>



<body>
    <header class="navbar-fixed">
    <nav id="headNav" class="bg-color nav-transparent">
        <div id="navContainer" class="nav-wrapper container">
            <div class="brand-logo">
                <a href="/" class="waves-effect waves-light">
                    
                    <img src="/medias/logo.png" class="logo-img" alt="LOGO">
                    
                    <span class="logo-span">hermia&#39;s blog</span>
                </a>
            </div>
            

<a href="#" data-target="mobile-nav" class="sidenav-trigger button-collapse"><i class="fas fa-bars"></i></a>
<ul class="right nav-menu">
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/" class="waves-effect waves-light">
      
      <i class="fas fa-home" style="zoom: 0.6;"></i>
      
      <span>首页</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/tags" class="waves-effect waves-light">
      
      <i class="fas fa-tags" style="zoom: 0.6;"></i>
      
      <span>标签</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/categories" class="waves-effect waves-light">
      
      <i class="fas fa-bookmark" style="zoom: 0.6;"></i>
      
      <span>分类</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/archives" class="waves-effect waves-light">
      
      <i class="fas fa-archive" style="zoom: 0.6;"></i>
      
      <span>归档</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/about" class="waves-effect waves-light">
      
      <i class="fas fa-user-circle" style="zoom: 0.6;"></i>
      
      <span>关于</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/friends" class="waves-effect waves-light">
      
      <i class="fas fa-address-book" style="zoom: 0.6;"></i>
      
      <span>友情链接</span>
    </a>
    
  </li>
  
  <li>
    <a href="#searchModal" class="modal-trigger waves-effect waves-light">
      <i id="searchIcon" class="fas fa-search" title="搜索" style="zoom: 0.85;"></i>
    </a>
  </li>
</ul>


<div id="mobile-nav" class="side-nav sidenav">

    <div class="mobile-head bg-color">
        
        <img src="/medias/logo.png" class="logo-img circle responsive-img">
        
        <div class="logo-name">hermia&#39;s blog</div>
        <div class="logo-desc">
            
            个人技术博客
            
        </div>
    </div>

    

    <ul class="menu-list mobile-menu-list">
        
        <li class="m-nav-item">
	  
		<a href="/" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-home"></i>
			
			首页
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/tags" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-tags"></i>
			
			标签
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/categories" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-bookmark"></i>
			
			分类
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/archives" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-archive"></i>
			
			归档
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/about" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-user-circle"></i>
			
			关于
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/friends" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-address-book"></i>
			
			友情链接
		</a>
          
        </li>
        
        
    </ul>
</div>


        </div>

        
    </nav>

</header>

    



<div class="bg-cover pd-header post-cover" style="background-image: url('/medias/featureimages/34.jpg')">
    <div class="container" style="right: 0px;left: 0px;">
        <div class="row">
            <div class="col s12 m12 l12">
                <div class="brand">
                    <h1 class="description center-align post-title">JS核心知识点（二十二）</h1>
                </div>
            </div>
        </div>
    </div>
</div>




<main class="post-container content">

    
    <link
  rel="stylesheet"
  href="/libs/tocbot/tocbot.css"
/>
<style>
  #articleContent h1::before,
  #articleContent h2::before,
  #articleContent h3::before,
  #articleContent h4::before,
  #articleContent h5::before,
  #articleContent h6::before {
    display: block;
    content: " ";
    height: 100px;
    margin-top: -100px;
    visibility: hidden;
  }

  #articleContent :focus {
    outline: none;
  }

  .toc-fixed {
    position: fixed;
    top: 64px;
  }

  /* .toc-widget {
        width: 345px;
        padding-left: 20px;
    } */
  .toc-widget {
    width: 345px;
    padding-left: 20px;
    background-color: rgb(255, 255, 255, 0.7);
    border-radius: 10px;
    box-shadow: 0 10px 35px 2px rgba(0, 0, 0, 0.15),
      0 5px 15px rgba(0, 0, 0, 0.07), 0 2px 5px -5px rgba(0, 0, 0, 0.1) !important;
  }

  .toc-widget .toc-title {
    padding: 35px 0 15px 17px;
    font-size: 1.5rem;
    font-weight: bold;
    line-height: 1.5rem;
  }

  .toc-widget ol {
    padding: 0;
    list-style: none;
  }

  #toc-content {
    padding-bottom: 30px;
    overflow: auto;
  }

  #toc-content ol {
    padding-left: 10px;
  }

  #toc-content ol li {
    padding-left: 10px;
  }

  #toc-content .toc-link:hover {
    color: #a3ddf0;
    font-weight: 700;
    text-decoration: underline;
  }

  #toc-content .toc-link::before {
    background-color: transparent;
    max-height: 25px;

    position: absolute;
    right: 23.5vw;
    display: block;
  }

  #toc-content .is-active-link {
    color: #a3ddf0;
  }

  #floating-toc-btn {
    position: fixed;
    right: 15px;
    bottom: 76px;
    padding-top: 15px;
    margin-bottom: 0;
    z-index: 998;
  }

  #floating-toc-btn .btn-floating {
    width: 48px;
    height: 48px;
  }

  #floating-toc-btn .btn-floating i {
    line-height: 48px;
    font-size: 1.4rem;
  }
</style>
<div class="row">
  <div id="main-content" class="col s12 m12 l9">
    <!-- 文章内容详情 -->
<div id="artDetail">
    <div class="card">
        <div class="card-content article-info">
            <div class="row tag-cate">
                <div class="col s7">
                    
                    <div class="article-tag">
                        
                            <a href="/tags/JS/">
                                <span class="chip bg-color">JS</span>
                            </a>
                        
                    </div>
                    
                </div>
                <div class="col s5 right-align">
                    
                    <div class="post-cate">
                        <i class="fas fa-bookmark fa-fw icon-category"></i>
                        
                            <a href="/categories/%E6%8A%80%E6%9C%AF/" class="post-category">
                                技术
                            </a>
                        
                    </div>
                    
                </div>
            </div>

            <div class="post-info">
                
                <div class="post-date info-break-policy">
                    <i class="far fa-calendar-minus fa-fw"></i>发布日期:&nbsp;&nbsp;
                    2023-12-12
                </div>
                

                
                <div class="post-date info-break-policy">
                    <i class="far fa-calendar-check fa-fw"></i>更新日期:&nbsp;&nbsp;
                    2023-12-12
                </div>
                

                
                <div class="info-break-policy">
                    <i class="far fa-file-word fa-fw"></i>文章字数:&nbsp;&nbsp;
                    18.7k
                </div>
                

                

                
            </div>
        </div>
        <hr class="clearfix">

        

        

        <div class="card-content article-card-content">
            <div id="articleContent">
                <span id="more"></span>
<h2 id="设计模式-迭代器模式和-Iterator-遍历器与-for…of-循环"><a href="#设计模式-迭代器模式和-Iterator-遍历器与-for…of-循环" class="headerlink" title="设计模式 - 迭代器模式和 Iterator 遍历器与 for…of 循环"></a>设计模式 - 迭代器模式和 Iterator 遍历器与 for…of 循环</h2><blockquote>
<p>在学习 Iterator 遍历器之前，我们先来学习下 JS 设计模式中的迭代器模式。</p>
</blockquote>
<h3 id="一、设计模式：迭代器模式"><a href="#一、设计模式：迭代器模式" class="headerlink" title="一、设计模式：迭代器模式"></a>一、设计模式：迭代器模式</h3><blockquote>
<p>设计模式（Design pattern）代表了最佳的实践，通常被有经验的面向对象的开发人员所采用。</p>
<ul>
<li>设计模式是开发人员在开发过程中面临的一般问题的解决方案。项目中合理地运用设计模式可以完美地解决很多问题，每种模式在现实中都有相应的原理来与之对应，每种模式都描述了一个在我们周围不断重复发生的问题，以及该问题的核心解决方案，这也是设计模式能被广泛应用的原因。</li>
</ul>
</blockquote>
<h4 id="什么是迭代器模式"><a href="#什么是迭代器模式" class="headerlink" title="什么是迭代器模式"></a>什么是迭代器模式</h4><blockquote>
<p>迭代器模式是指提供一种方法<strong>顺序</strong>访问一个聚合对象中的各个元素，而又<strong>不需要暴露该对象的内部结构</strong>。也就是说，即使不了解对象的内部结构，也可以按顺序访问其中的每个元素。</p>
<ul>
<li>比如我们想要有序的访问数组中的每个成员，我们可以选择用<code>for</code>循环或<code>forEach</code>来实现。<blockquote>
<p>注意： for 循环并不遵顺迭代器模式，而 forEach 是符合迭代器模式的，为什么呢 ？</p>
</blockquote>
</li>
<li>for 循环遍历数组中的每个成员，需要知道数组的长度，同时还需要知道以什么形式访问数组中的成员</li>
<li>forEach 遍历数组中的成员，并不需要知道数组的长度和访问数组中成员的形式（即不需要知道对象的内部结构）</li>
</ul>
<pre><code>const arr = [&quot;A&quot;, &quot;B&quot;, &quot;C&quot;];
// 需要知道数组长度 arr.length
for (let i = 0; i &lt; arr.length; i++) &#123;
  console.log(arr[i]); // 需要知道访问数组成员的形式
&#125;
</code></pre>
</blockquote>
<p>&#x2F;&#x2F; 并不需要知道数组的内部结构，也可以按顺序访问其中的每个成员<br>arr.forEach((value) &#x3D;&gt; {<br>  console.log(value);<br>});</p>
<blockquote>
<pre><code>
</code></pre>
</blockquote>
<blockquote>
<blockquote>
<p>迭代器模式必需要满足条件：<br>在<strong>不暴露对象的内部结构</strong>时，<strong>有序的</strong>访问对象中成员。所以 <code>for</code> 循环并遵顺迭代器模式，<code>forEach</code> 是符合的。</p>
</blockquote>
</blockquote>
<h4 id="区分：迭代器模式和迭代器"><a href="#区分：迭代器模式和迭代器" class="headerlink" title="区分：迭代器模式和迭代器"></a>区分：迭代器模式和迭代器</h4><blockquote>
<ul>
<li>迭代器模式：可以理解为在不需要了解对象的内部结构情况下，解决有序访问对象中成员的一种<strong>思想</strong>。</li>
<li>迭代器：可以理解为迭代器模式的一种具体方案的实现。 比如上面数组的<code>forEach</code>方法，可以看作是一个简易的迭代器。</li>
</ul>
</blockquote>
<h4 id="迭代器的分类"><a href="#迭代器的分类" class="headerlink" title="迭代器的分类"></a>迭代器的分类</h4><blockquote>
<p>迭代器可以分为<strong>内部</strong>迭代器和<strong>外部</strong>迭代器，它们分别有各自的适用场景</p>
</blockquote>
<blockquote>
<p><strong>内部迭代器：</strong></p>
<ul>
<li>内部迭代器通常被定义成一个方法，他是被动的，我们不需要关心内部迭代器的规则，只需要调用这个方法，就能有序的访问对象中的所有成员。</li>
<li>优点：使用非常简单</li>
<li>缺点：其灵活性相对较差。没有办法手动控制每一次迭代。其次不能与<code>break、continue、return</code>关键字配合使用，终止迭代器</li>
<li>上面的<code>forEach</code>函数就属于内部迭代器。</li>
</ul>
</blockquote>
<blockquote>
<p><strong>外部迭代器：</strong></p>
<ul>
<li>外部迭代器是主动的，我们必须知道他的内部实现，同时必须显示的请求迭代下一个元素。</li>
<li>优点：其灵活性相对较好，我们可以手动控制迭代的过程或顺序。可以与<code>break、continue、return</code>关键字配合使用，终止迭代器</li>
<li>缺点：使用起来相对比较麻烦</li>
<li>后面 ES6 中要学习到的数组的<code>[Symbol.iterator]</code>方法，就是一个外部迭代器</li>
</ul>
</blockquote>
<blockquote>
<p>因为外部迭代器使用其来很麻烦，而且需要了解其内部的实现。所以在实际开发中，我们通常是<strong>暴露一个内部迭代器对外使用</strong>。</p>
<ul>
<li>但由于内部迭代器不能与<code>break、continue、return</code>关键字配合使用。</li>
<li>所以在 ES6 中新增了<code>for...of</code>循环语句，<code>for...of</code>主要就是用来消费外部迭代器。（具体如何使用，后面学习）</li>
</ul>
</blockquote>
<h4 id="实现一个内部迭代器"><a href="#实现一个内部迭代器" class="headerlink" title="实现一个内部迭代器"></a>实现一个内部迭代器</h4><blockquote>
<p>数组的<code>forEach</code>方法可以看作是一个简易的迭代器，那我们来手动实现下数组的<code>forEach()</code>方法</p>
<pre><code>const arr = [&quot;A&quot;, &quot;B&quot;, &quot;C&quot;];
Array.prototype.forEach = function (callBack) &#123;
  for (let i = 0; i &lt; this.length; i++) &#123;
    callBack(this[i], i, this);
  &#125;
&#125;;
</code></pre>
</blockquote>
<p>arr.forEach((value, index, arr) &#x3D;&gt; {<br>  console.log(value, index, arr);<br>});</p>
<blockquote>
<pre><code>
</code></pre>
</blockquote>
<blockquote>
<p>不过内部迭代器也有自己的问题，就是<strong>灵活性相对较差</strong>。</p>
<ul>
<li>比如，我们想要同时迭代两个数组，然后比较两个数组是否完全相等。上面的<code>forEach()</code>方法就没有办法实现，只能人为的再定义一个方法，在这个方法内部结合<code>forEach()</code>方法来一起实现。</li>
</ul>
</blockquote>
<ul>
<li>比较两个数组中的元素是否完全相等<blockquote>
<pre><code>const arr = [&quot;A&quot;, &quot;B&quot;, &quot;C&quot;];
const arr2 = [&quot;A&quot;, &quot;B&quot;, &quot;C&quot;];
Array.prototype.compare = function (arr2) &#123;
if (this.length !== arr2.length) &#123;
  throw new Error(`两个数组不相等`);
&#125;
// 遍历来对比
this.forEach((value, index) =&gt; &#123;
  if (value !== arr2[index]) &#123;
    throw new Error(`两个数组不相等`);
  &#125;
&#125;);
// 上面没有抛错，说明下面则是相等的
console.log(&quot;两个数组相等&quot;);
&#125;;
</code></pre>
</blockquote>
arr.compare(arr2);<blockquote>
<pre><code>- 上面不完美之处在于，我们必须知道 `arr2` 数组的**内部结构**，才能与数组 arr 作比较。
</code></pre>
</blockquote>
</li>
</ul>
<h4 id="手动实现外部迭代器"><a href="#手动实现外部迭代器" class="headerlink" title="手动实现外部迭代器"></a>手动实现外部迭代器</h4><blockquote>
<p>外部迭代器是主动的，我们必须知道他的<strong>内部实现</strong>，同时必须<strong>显示的请求迭代下一个元素</strong>。其灵活性相对较好，我们可以手动控制迭代的过程或顺序。</p>
</blockquote>
<ul>
<li>手动实现一个外部迭代器，按顺序显示迭代数组中的每一个元素</li>
</ul>
<ol>
<li>基础版<blockquote>
<p><strong>实现思路：</strong></p>
<ul>
<li>在 Array 的原型上定义一个<code>getIterator</code>方法，当<code>数组.getIterator()</code>方法，返回一个<strong>对象</strong>（迭代器对象），<code>迭代器对象.next()</code>方法显示迭代数组的下一个元素。</li>
<li>当数组中元素全部迭代完成，返回值为<code>undefined</code></li>
</ul>
<pre><code>Array.prototype.getIterator = function () &#123;
  let index = 0; // 相当于指针，最开始指向数组中的第一个元素的下标
  let self = this; // 保存this
  return &#123;
 next() &#123;
   return self[index++];
 &#125;,
  &#125;;
&#125;;
const arr = [&quot;A&quot;, &quot;B&quot;, &quot;C&quot;];
let it = arr.getIterator(); // 返回迭代器对象
// it.next() 显示请示迭代下一个元素
console.log(it.next()); // A
console.log(it.next()); // B
console.log(it.next()); // C
console.log(it.next()); // undefined
</code></pre>
</blockquote>
</li>
</ol>
<blockquote>
<p>上面代码中</p>
<ul>
<li>需要有序访问数组中的成员，只能先通过<code>数组.getIterator()</code>方法返回迭代器对象，然后通过<code>迭代器对象.next()</code>方法手动的迭代数组中的下一个元素。<br><strong>缺陷：</strong></li>
<li>上面的迭代器<strong>没有办法结合while循</strong>环一次性有序的遍历出数组的所有成员，<strong>因为没有办法判断对象中的成员是否迭代完成</strong>，所以我们需要对上面的代码做相关的修改。</li>
</ul>
</blockquote>
<ol start="2">
<li>优化一：添加 <code>isDone</code> 和改进 <code>next</code> 方法<blockquote>
<ul>
<li>给迭代器对象添加一个<code>isDone</code>方法，用来判断当前对象中的成员是否全部迭代完成</li>
<li>同时修改<code>next()</code>方法体中的代码</li>
</ul>
<pre><code>Array.prototype.getIterator = function () &#123;
  let index = 0; // 相当于指针，最开始指向数组中的第一个元素的下标
  let self = this; // 保存this
  return &#123;
 isDone() &#123;
   // 返回值为true，表示对象中成员全部迭代完成，false表示没有迭代完成
   return index &gt; self.length - 1; // index &gt;= self.length
 &#125;,
 next() &#123;
   if (!this.isDone()) &#123;
     return self[index++];
   &#125;
 &#125;,
  &#125;;
&#125;;
const arr = [&quot;A&quot;, &quot;B&quot;, &quot;C&quot;];
const it = arr.getIterator();
console.log(it.next()); // A
console.log(it.next()); // B
console.log(it.next()); // C
console.log(it.next()); // undefined
</code></pre>
<ul>
<li>利用 <code>while</code> 循环，一次性有序的迭代出数组中的所有成员</li>
</ul>
<pre><code>const it = arr.getIterator();
while (!it.isDone()) &#123;
  console.log(it.next());
&#125;
</code></pre>
</blockquote>
</li>
</ol>
<blockquote>
<p><strong>缺陷：</strong></p>
<ul>
<li>如果我们想要在while循环中结合<code>break</code>,<code>continue</code>,<code>return</code>关键字终止迭代器（退出循环） 时，以上迭代器没有办法实现。</li>
</ul>
<pre><code>const arr = [&quot;A&quot;, &quot;B&quot;, &quot;C&quot;];
const it = arr.getIterator();
while (!it.isDone()) &#123;
  if (it.next() === &quot;B&quot;) &#123;
    break;
  &#125;
  console.log(it.next());
&#125;
// 输出结果 B undefined
</code></pre>
<p>以上代码输出结果 :<code>B undefined</code>并不是我们所期望的，我们期望的结果是 <code>A</code>。<br><strong>为什么呢</strong> ？</p>
<ul>
<li>while 循环第一次，<code>it.next()</code>的结果为 A，肯定不等于 B，所以执行 <code>console.log(it.next())</code>，这里的<code>it.next()</code>相当于迭代下一个元素，结果为 <code>B</code>。所以并没有得到我们想要的 A 。</li>
</ul>
</blockquote>
<ol start="3">
<li>优化二：next() 方法返回值为对象<blockquote>
<p>把<code>next()</code>方法的返回结果改成如下结构的对象</p>
<pre><code>&#123;
 value: &quot;数组成员&quot;, // 值表示数组成员
&#125;
</code></pre>
<ul>
<li>具体代码实现如下：</li>
</ul>
<pre><code>Array.prototype.getIterator = function () &#123;
  let index = 0; // 相当于指针，最开始指向数组中的第一个元素的下标
  let self = this; // 保存this
  return &#123;
 isDone() &#123;
   // 返回值为true，表示对象中成员全部迭代完成，false表示全部元素没有迭代
   return index &gt; self.length - 1; // index&gt;=self.length
 &#125;,
 next() &#123;
   if (!this.isDone()) &#123;
     return &#123;
       value: self[index++],
     &#125;;
   &#125;
 &#125;,
  &#125;;
&#125;;
const arr = [&quot;A&quot;, &quot;B&quot;, &quot;C&quot;];
let it = arr.getIterator(); // 返回迭代器对象
console.log(it.next()); // &#123;value: &#39;A&#39;&#125;
console.log(it.next()); // &#123;value: &#39;B&#39;&#125;
console.log(it.next()); // &#123;value: &#39;C&#39;&#125;
console.log(it.next()); // &#123;value: undefined&#125;
</code></pre>
</blockquote>
</li>
</ol>
<blockquote>
<ul>
<li>利用 <code>while</code> 循环，一次性有序的迭代出数组中的所有成员</li>
</ul>
<pre><code>const arr = [&quot;A&quot;, &quot;B&quot;, &quot;C&quot;];
// while循环，实现一次性有序的遍历出数组的所有成员
let it = arr.getIterator();
while (!it.isDone()) &#123;
  obj = it.next();
  console.log(obj.value);
&#125;
// 输出结果： A  B  C
</code></pre>
<ul>
<li><code>while</code> 循环与<code>break、continue、return</code>结合终止迭代器或退出 <code>while</code> 循环</li>
</ul>
<pre><code>const arr = [&quot;A&quot;, &quot;B&quot;, &quot;C&quot;];
// while循环，实现一次性有序的遍历出数组的所有成员
let it = arr.getIterator();
while (!it.isDone()) &#123;
  obj = it.next();
  if (obj.value === &quot;B&quot;) &#123;
    //   break;
    continue;
  &#125;
  console.log(obj.value);
&#125;
</code></pre>
</blockquote>
<p>&#x2F;&#x2F; 使用break关键字执行结果： A<br>&#x2F;&#x2F; 使用continue关键字执行结果： A C</p>
<blockquote>
<pre><code>
</code></pre>
</blockquote>
<blockquote>
<p><strong>缺陷</strong>：</p>
<ul>
<li>如果我手动调用迭代器的<code>next()</code>方法来迭代下一个元素时，如果<strong>数据结构中的成员值</strong>为<code>undefined</code>，则我们没有办法区分返回的值<code>undefined</code>是数据结构本身的元素，还是表示没有下一个元素可以迭代了。所以还可以再优化。</li>
</ul>
</blockquote>
<ol start="4">
<li>优化三：修改 next 方法返回结果<blockquote>
<p>把·方法的返回结果修改为以下结构的对象</p>
<pre><code>&#123;
 value: &quot;数组成员&quot;, // 值表示数组成员，当done为true时，其值为undefined
 done: false, // false 表示没有遍历完，true表示遍历完成
&#125;
</code></pre>
</blockquote>
</li>
</ol>
<blockquote>
<p><strong>具体代码实现如下：</strong></p>
<pre><code>Array.prototype.getIterator = function () &#123;
  let index = 0; // 相当于指针，最开始指向数组中的第一个元素的下标
  let self = this; // 保存this
  return &#123;
    isDone() &#123;
      // 返回值为true，表示对象中成员全部迭代完成，false表示没有
      return index &gt; self.length - 1; // index&gt;=self.length
    &#125;,
    next() &#123;
      let that = this;
      if (!this.isDone()) &#123;
        return &#123;
          value: self[index++],
          done: false,
        &#125;;
      &#125; else &#123;
        return &#123;
          value: undefined,
          done: true,
        &#125;;
      &#125;
    &#125;,
  &#125;;
&#125;;
</code></pre>
</blockquote>
<p>const arr &#x3D; [“A”, “B”, “C”];<br>let it &#x3D; arr.getIterator(); &#x2F;&#x2F; 返回迭代器对象<br>console.log(it.next());<br>console.log(it.next());<br>console.log(it.next());<br>console.log(it.next());</p>
<blockquote>
<pre><code>
</code></pre>
</blockquote>
<blockquote>
<ul>
<li>while 循环与break、continue、return结合终止迭代器或退出 while 循环</li>
</ul>
<pre><code>let it2 = arr.getIterator(); // 返回迭代器对象
while (!it2.isDone()) &#123;
  let obj = it2.next();
  if (obj.value === &quot;B&quot;) &#123;
    //   break;
    continue;
  &#125;
  console.log(obj.value);
&#125;
//  输出结果为：A C
</code></pre>
</blockquote>
<h4 id="迭代器实际应用场景"><a href="#迭代器实际应用场景" class="headerlink" title="迭代器实际应用场景"></a>迭代器实际应用场景</h4><blockquote>
<p>通过上面的学习，我们知道<strong>迭代器模式</strong>是一种解决在不需要知道对象的内部结构情况下，有序遍历出对象中成员的一种解决思想。</p>
<ul>
<li>而<strong>迭代器</strong>是实现这种思想的一种具体解决方案</li>
</ul>
</blockquote>
<blockquote>
<p><strong>实现一个迭代器的基本思路：</strong></p>
<ul>
<li>创建一个方法 —-&gt; 这个方法返回一个对象（迭代器对象）—-&gt; 调用迭代器对象身上的方法（通常有<code>next</code>或<code>isDone</code>）可以显示迭代下一个成员，或判断成员是否全部迭代完成。</li>
</ul>
</blockquote>
<blockquote>
<p><strong>备注：</strong></p>
<ul>
<li>如果迭代器对象还需要其它功能，可自己添加相关方法。</li>
</ul>
</blockquote>
<ol>
<li>创建 Stack 类，添加一个外部迭代器<blockquote>
<ul>
<li>外部迭代器在while循环中可以与<code>break、continue、return</code>关键字配合使用，功能更强大</li>
</ul>
<pre><code>class Stack &#123;
</code></pre>
</blockquote>
</li>
</ol>
<p>  #length; &#x2F;&#x2F; 私有属性<br>  #data &#x3D; []; &#x2F;&#x2F; 私有成员，存储入栈成员<br>  constructor(length) {<br>    this.#length &#x3D; length;<br>  }<br>  &#x2F;&#x2F; 返回#lenght属性，只能访问，不能修改<br>  get length() {<br>    return this.#length;<br>  }<br>  &#x2F;&#x2F; 判断栈是否空<br>  isEmpty() {<br>    return this.#data &#x3D;&#x3D;&#x3D; 0;<br>  }<br>  &#x2F;&#x2F; 栈满<br>  isFull() {<br>    return this.#data.length &#x3D;&#x3D;&#x3D; this.#length;<br>  }<br>  &#x2F;&#x2F; 入栈<br>  push(value) {<br>    if (this.isFull()) throw new Error(“栈满，不能再添加元素”);<br>    this.#data.push(value);<br>    return this; &#x2F;&#x2F; 支持链式调用<br>  }<br>  &#x2F;&#x2F; 出栈<br>  pop() {<br>    if (this.isEmpty()) throw new Error(“栈空，不能再添加元素”);<br>    return this.#data.pop();<br>  }<br>  &#x2F;&#x2F; 迭代器方法，用来生成迭代器对象<br>  getIterator() {<br>    let index &#x3D; 0;<br>    let self &#x3D; this;<br>    return {<br>      isDone() {<br>        return index &gt;&#x3D; self.#data.length;<br>      },<br>      next() {<br>        if (!this.isDone()) {<br>          return {<br>            value: self.#data[index++],<br>            done: false,<br>          };<br>        } else {<br>          return { value: undefined, done: true };<br>        }<br>      },<br>    };<br>  }<br>}</p>
<blockquote>
</blockquote>
<p>const stack &#x3D; new Stack(5);<br>const stack2 &#x3D; new Stack(3);<br>stack.push(1).push(2).push(3).push(4).push(5);<br>stack.pop();<br>stack.pop();<br>&#x2F;&#x2F; 访问栈容器长度<br>stack.length &#x3D; 999;<br>console.log(stack.length); &#x2F;&#x2F;  5<br>&#x2F;&#x2F; 生成迭代器对象 it<br>const it &#x3D; stack.getIterator();<br>console.log(it.next());<br>console.log(it.next());<br>console.log(it.next());<br>console.log(it.next());</p>
<blockquote>
</blockquote>
<p>&#x2F;&#x2F; while循环，一次性有序的迭代出对象的所有成员<br>const it2 &#x3D; stack.getIterator();<br>let obj &#x3D; it2.next();<br>while (!obj.done) {<br>  console.log(obj.value);<br>  obj &#x3D; it2.next();<br>}</p>
<blockquote>
<pre><code>
</code></pre>
</blockquote>
<ol start="2">
<li>为 Stack 类添加内部迭代器 forEach 方法<blockquote>
<p>外部迭代器相对于内部迭代器灵活性更高，但是使用起来相对麻烦。所以我们通常<strong>会暴露内部迭代器</strong>对外使用。</p>
<ul>
<li>接下来我们给<code>Stack</code>类添加内部迭代器<code>forEach</code>方法</li>
</ul>
<pre><code> // 内部迭代器
  forEach(callBack) &#123;
 for (var i = 0; i &lt; this.#data.length; i++) &#123;
   callBack(this.#data[i], i, this);
 &#125;
  &#125;
</code></pre>
</blockquote>
</li>
</ol>
<blockquote>
<ul>
<li>完整代码</li>
</ul>
<pre><code>class Stack &#123;
  #length; // 私有属性
  #data = []; // 私有成员，存储入栈成员
  constructor(length) &#123;
    this.#length = length;
  &#125;
  // 返回#lenght属性，只能访问，不能修改
  get length() &#123;
    return this.#length;
  &#125;
  // 判断栈是否空
  isEmpty() &#123;
    return this.#data === 0;
  &#125;
  // 栈满
  isFull() &#123;
    return this.#data.length === this.#length;
  &#125;
  // 入栈
  push(value) &#123;
    if (this.isFull()) throw new Error(&quot;栈满，不能再添加元素&quot;);
    this.#data.push(value);
    return this; // 支持链式调用
  &#125;
  // 出栈
  pop() &#123;
    if (this.isEmpty()) throw new Error(&quot;栈空，不能再添加元素&quot;);
    return this.#data.pop();
  &#125;
  // 迭代器方法，用来生成迭代器对象
  getIterator() &#123;
    let index = 0;
    let self = this;
    return &#123;
      isDone() &#123;
        return index &gt;= self.#data.length;
      &#125;,
      next() &#123;
        if (!this.isDone()) &#123;
          return &#123;
            value: self.#data[index++],
            done: false,
          &#125;;
        &#125; else &#123;
          return &#123; value: undefined, done: true &#125;;
        &#125;
      &#125;,
    &#125;;
  &#125;
  // 内部迭代器
  forEach(callBack) &#123;
    for (var i = 0; i &lt; this.#data.length; i++) &#123;
      callBack(this.#data[i], i, this);
    &#125;
  &#125;
&#125;
</code></pre>
</blockquote>
<p>const stack &#x3D; new Stack(5);<br>const stack2 &#x3D; new Stack(3);<br>stack.push(1).push(2).push(3).push(4).push(5);<br>stack.forEach((v) &#x3D;&gt; {<br>  console.log(v); &#x2F;&#x2F; 1 2 3 4 5<br>});</p>
<blockquote>
<pre><code>
</code></pre>
</blockquote>
<h4 id="将-class（数据类）与-迭代器类分离"><a href="#将-class（数据类）与-迭代器类分离" class="headerlink" title="将 class（数据类）与 迭代器类分离"></a>将 class（数据类）与 迭代器类分离</h4><blockquote>
<p>我们很多时候会有这样的需求，我可能有 10 个类，每个类都有一个自己的外部迭代器，这些迭代器的内部实现都是相同的。<br>如果我们把迭代器与某个类绑定死，那就意味着这个迭代器没有办法供 10 个类重用，只能为每个类单独写一个。</p>
<ul>
<li>所以我们可以将迭代器分类出去，单独定义成一个类，然后在其它类的内部来使用这个迭代器</li>
</ul>
<pre><code>// 迭代器类  创建迭代器对象
class DataIterator &#123;
  // 私有属性
  #data; // 接受传递过来用来遍历的数据对象
  #index = 0; // 下标
  constructor(data) &#123;
    this.#data = data;
  &#125;
  // 判断元素是否迭代完成
  isDone() &#123;
    return this.#index &gt;= this.#data.length;
  &#125;
  // 返回下一个元素
  next() &#123;
    return this.isDone()
      ? &#123; value: undefined, done: true &#125;
      : &#123; value: this.#data[this.#index++], done: false &#125;;
  &#125;
&#125;
</code></pre>
</blockquote>
<p>&#x2F;&#x2F; 数据类<br>class DataContainer {<br>  #data; &#x2F;&#x2F; 私有属性<br>  constructor(data &#x3D; []) {<br>    if (Array.isArray(data)) {<br>      this.#data &#x3D; data;<br>    } else {<br>      throw new Error(“传入的参数只能是一个数组”);<br>    }<br>  }<br>  &#x2F;&#x2F; 生成迭代器对象的方法<br>  getIterator() {<br>    return new DataIterator(this.#data);<br>  }<br>  &#x2F;&#x2F;….. 对象其它方法自行添加<br>}</p>
<blockquote>
</blockquote>
<p>&#x2F;&#x2F; 创建实例对象<br>const obj &#x3D; new DataContainer([“A”, “B”, “C”]);<br>&#x2F;&#x2F; 生成一个迭代器对象<br>const it &#x3D; obj.getIterator();<br>&#x2F;&#x2F; 调用next方法，手动遍历下一个元素<br>console.log(it.next());<br>console.log(it.next());<br>console.log(it.next());<br>console.log(it.next());</p>
<blockquote>
</blockquote>
<p>const it2 &#x3D; obj.getIterator();<br>&#x2F;&#x2F; while循环<br>while (!it2.isDone()) {<br>  const obj &#x3D; it2.next();<br>  console.log(obj.value);<br>}</p>
<blockquote>
<pre><code>
</code></pre>
</blockquote>
<blockquote>
<p><strong>解读：</strong><code>DataIterator</code> 类<br><code>DataIterator</code>类用来创建迭代器对象，有<code>#data</code>和<code>#index</code>两个私有属性，同时有<code>isDone()</code>和<code>next()</code>两个实例方法。</p>
<ul>
<li><code>#data</code>用来接受需要迭代的数据对象</li>
<li><code>#index</code>用来控制访问元素的下标，相当于一个指针。</li>
<li><code>isDone()</code>方法用来判断数据对象的成员是否迭代完成</li>
<li><code>next()</code>方法用来返回下一个数据对象的下一个成员</li>
</ul>
</blockquote>
<blockquote>
<p><strong>解读：</strong> <code>DataContainer</code>类<br><code>DataContainer</code>类用来模拟一个数据类，他有 <code>#data</code> 私有属性和<code>getIterator()</code>实例方法。</p>
<ul>
<li><code>#data</code>属性，用来保存 <code>DataContainer</code> 类实例化对象的数据，其类型必需是一个数组。</li>
<li><code>getIterator()</code> 方法用来生成一个迭代器对象，它的返回值为<code>new DataIterator(this.#data);</code>其中的<code>this.#data</code>参数为需要迭代的数据对象。</li>
</ul>
</blockquote>
<blockquote>
<p><strong>迭代器的应用</strong></p>
<ul>
<li>当我们创建一个类时，可以为这个类添加<strong>外部迭代器</strong>和<strong>内部迭代器</strong>，这样就可以在<strong>不暴露数据结构</strong>的内部结构情况下<strong>有序的</strong>访问其成员。</li>
<li>我们可以将数据容器类与外部迭代器类<strong>分离</strong>，这样就可以实现迭代器类的复用。</li>
</ul>
</blockquote>
<h3 id="二、Iterator-是什么-？"><a href="#二、Iterator-是什么-？" class="headerlink" title="二、Iterator 是什么 ？"></a>二、Iterator 是什么 ？</h3><blockquote>
<p><code>ES6</code>中的<code>Iterator</code>遍历器（迭代器）其实就是参考了<code>JS</code>设计模式中的迭代器模式。</p>
</blockquote>
<ol>
<li><p>寻找 Iterator</p>
<blockquote>
<p>查看数组原型链上继承的方法</p>
<ul>
<li>在控制台打印一个数组，查看原型</li>
<li>数组原型上的<code>[Symbol.iterator]</code>属性就是一个方法，也就是<code>JS</code>内置的一种外部迭代器，这个方法<strong>返回一个迭代器对象</strong>。</li>
</ul>
</blockquote>
</li>
<li><p>使用 <code>Itertaor</code></p>
<blockquote>
<p>数据结构的<code>[Symbol.iterator]</code>属性是一个函数，用来返回一个迭代器对象</p>
<ul>
<li>迭代器对象身上有一个<code>next</code>方法，调用迭代器对象的<code>next()</code>方法，返回一个<strong>对象</strong></li>
<li>对象有两个属性，分别为<code>value</code>和<code>done</code></li>
<li><code>value</code>属性值为<strong>当前成员的值</strong>，</li>
<li><code>done</code>属性是一个布尔值，<strong>表示遍历是否结束</strong>，false 表示未结束，true 表示结束。</li>
<li><code>Symbol.iterator</code>本身是一个表达式，返回<code>Symbol</code>对象的<code>iterator</code>属性，这是一个预定义好的特殊的<code>Symbol</code>类型的值。</li>
<li>所以作为对象的属性时，要写在<code>[]</code>方括号中</li>
</ul>
<pre><code>// 数组
let arr = [1, 2, 3];
const iterator = arr[Symbol.iterator](); // 生成可遍历对象
// 调用可遍历对象的 next方法,迭代出下一个成员
console.log(iterator.next());
console.log(iterator.next());
console.log(iterator.next());
console.log(iterator.next());
</code></pre>
</blockquote>
</li>
</ol>
<ul>
<li><code>while</code>循环配合迭代器，一次性有序的迭代出数组中的所有成员<blockquote>
<ul>
<li>注意：<code>[Symbol.iterator]</code>返回的迭代器对象，没有<code>isDone</code>方法，所以这里用<code>while</code>循环的方式和我们手写的外部迭代器不一样</li>
</ul>
<pre><code>const it = arr[Symbol.iterator]();
let obj = it.next();
while (!obj.done) &#123;
console.log(obj.value);
obj = it.next(); // 1  2  3
&#125;
</code></pre>
</blockquote>
</li>
</ul>
<ol start="3">
<li><p><code>Iterator</code> 是什么 ？</p>
<blockquote>
<p><code>Iterator</code>是一个遍历的过程，具体如下</p>
<ul>
<li>调用数据的<code>Symbol.iterator</code>（可遍历对象的生成方法）—-&gt; 生成<code>iterator</code>（迭代器对象）—-&gt; 调用<code>iterator.next()</code> —&gt; <code>iterator.next()</code> —-&gt; …. 直到<code>next</code>方法返回值对象的<code>done</code>属性值为<code>true</code>时，才停止遍历，这样的一个完整过程称之为<code>Iterator</code><blockquote>
<p>数组的<code>Symbol.iterator</code>方法，可以理解为可遍历对象的生成方法，生成迭代器对象</p>
</blockquote>
</li>
</ul>
</blockquote>
</li>
<li><p>手动实现数组的<code>Symbol.iterator</code>方法</p>
<blockquote>
<p>其内部实现原理与我们讲的设计模式中的迭代器模式完全相同</p>
<ul>
<li>只是代码上稍微有一些差异，因为数组的<code>Symbol.iterator</code>方法，生成的迭代器对象只有<code>next</code>方法，<strong>没有</strong><code>isDone</code>方法。</li>
</ul>
<pre><code>Array.prototype[Symbol.iterator] = function () &#123;
  let index = 0;
  let self = this;
  return &#123;
 next() &#123;
   return index &lt; self.length
     ? &#123;
         value: self[index++],
         done: false,
       &#125;
     : &#123; value: undefined, done: true &#125;;
 &#125;,
  &#125;;
&#125;;
</code></pre>
</blockquote>
<p>const arr &#x3D; [“a”, “b”, “c”, “d”];<br>const it &#x3D; arr<a href="">Symbol.iterator</a>;<br>console.log(it.next());<br>console.log(it.next());<br>console.log(it.next());<br>console.log(it.next());<br>console.log(it.next());</p>
<blockquote>
</blockquote>
<p>&#x2F;&#x2F; 一次性迭代出数组的所有成员<br>const it2 &#x3D; arr<a href="">Symbol.iterator</a>;<br>let obj &#x3D; it2.next();<br>while (!obj.done) {<br>  console.log(obj.value);<br>  obj &#x3D; it2.next();<br>}</p>
<blockquote>
<pre><code>
</code></pre>
</blockquote>
</li>
</ol>
<ul>
<li>用<code>while</code>循环，遍历出数组成员<blockquote>
<ul>
<li>特别注意，用<code>continue</code>的时候，避免进入死循环</li>
</ul>
<pre><code>//break
while (!obj.done) &#123;
if (obj.value === &quot;c&quot;) &#123;
  break;
&#125;
console.log(obj.value);
obj = it.next();
&#125;
//continue
while (!obj.done) &#123;
if (obj.value === &quot;c&quot;) &#123;
  obj = it.next();
  continue;
&#125;
console.log(obj.value);
obj = it.next();
&#125;
</code></pre>
</blockquote>
</li>
</ul>
<h3 id="三、for-of"><a href="#三、for-of" class="headerlink" title="三、for ... of"></a>三、<code>for ... of</code></h3><blockquote>
<p>通过上面的学习，我们知道，<code>Iterator</code>的使用特别的麻烦，难道以后，我们都需要那样来使用 <code>Iterator</code> 吗 ？那肯定是不用的，如果这么麻烦，那估计早就没人用了。</p>
<ul>
<li>官方也不推荐直接使用<code>Iterator</code>。所以 <code>ES6</code> 中提供了<code>for...of</code>循环来消费<code>Iterator</code>。</li>
</ul>
</blockquote>
<ol>
<li>for … of 遍历迭代器对象<blockquote>
<ul>
<li><code>for...of</code>用来遍历<strong>迭代器对象</strong>，比如数组的<code>[Symbol.iterator]</code>方法，调用这个方法，可以生成一个迭代器对象。</li>
</ul>
<pre><code>const arr = [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;];
const it = arr[Symbol.iterator]();
for (let v of it) &#123;
  console.log(v);
&#125;
</code></pre>
</blockquote>
</li>
</ol>
<blockquote>
<p><code>ES6</code> 中的<code>数组、Set、Map</code>都有<code>keys、values、entries</code>方法，这三个方法调用后，<strong>都返回一个迭代器对象</strong>，所以可以用<code>for...of</code>来遍历他们</p>
</blockquote>
<table>
<thead>
<tr>
<th>方法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>keys()</td>
<td>返回一个遍历器对象，用来遍历所有的键名</td>
</tr>
<tr>
<td>values()</td>
<td>返回一个遍历器对象，用来遍历所有的键值</td>
</tr>
<tr>
<td>entries()</td>
<td>返回一个遍历器对象，用来遍历 [键名，键值] 成的数组。</td>
</tr>
</tbody></table>
<blockquote>
<pre><code>const s = new Set();
console.log(s.keys());
</code></pre>
<img src="keys方法生成的的迭代器对象.png">
- 其他方法也类似
</blockquote>
<ul>
<li><p>数组</p>
<blockquote>
<ul>
<li>用<code>for...of</code>遍历数组的<code>keys()</code>方法可以遍历数组的下标</li>
<li></li>
</ul>
<pre><code>const arr = [1, 2, 3];
console.log(arr); //arr是一个可迭代对象
console.log(arr.keys()); //arr.keys()会返回一个迭代器对象
for (let k of arr.keys()) &#123;
console.log(k); //0 1 2
&#125;
for (let k of arr.values()) &#123;
console.log(k); //1 2 3
&#125;
for (let k of arr.entries()) &#123;
console.log(k); // [0, 1] [1, 2] [2, 3]
&#125;
</code></pre>
</blockquote>
</li>
<li><p>Set</p>
<blockquote>
<ul>
<li><code>Set</code>对象没有键名，所以返回成员值</li>
</ul>
<pre><code>const s = new Set([1, 2, 3]);
for (let k of s.keys()) &#123;
console.log(k); // 1 2 3
&#125;
for (let v of s.values()) &#123;
console.log(v); // 1 2 3
&#125;
for (let [k, v] of s.entries()) &#123;
console.log(k, v); // 1 1  2 2  3 3
&#125;
</code></pre>
</blockquote>
</li>
<li><p>Map</p>
<blockquote>
<pre><code>const m = new Map([
[&quot;数组&quot;, [&quot;a&quot;, &quot;b&quot;]],
[&quot;对象&quot;, &#123; a: 1, b: 2 &#125;],
[&quot;函数&quot;, function () &#123;&#125;],
]);
</code></pre>
</blockquote>
<p>for (let k of m.keys()) {<br>console.log(k);<br>}<br>for (let v of m.values()) {<br>console.log(v);<br>}<br>for (let [k, v] of m.entries()) {<br>console.log(<code>$&#123;k&#125;=&gt;$&#123;v&#125;</code>);<br>}</p>
<blockquote>
<pre><code>
</code></pre>
</blockquote>
</li>
</ul>
<blockquote>
<blockquote>
<p>注意：</p>
</blockquote>
<ul>
<li>迭代器对象遍历完，就不能再次使用了，因为<code>done</code>已经变成<code>true</code>了</li>
</ul>
</blockquote>
<ol start="2">
<li><p>for … of 遍历可迭代对象</p>
<blockquote>
<p>只要一个对象身上有<code>[Symbol.iterator]</code>属性，则就可以用<code>for...of</code>来遍历对象，我们把带有<code>[Symbol.iterator]</code>属性的对象称为<strong>可遍历（迭代）对象</strong></p>
<ul>
<li>也就是说，当用<code>for...of</code>来遍历某个对象时，内部会自动调用对象的<code>[Symbol.iterator]</code>方法来<strong>生成一个迭代器对象</strong>，然后按顺序迭代对象的成员。</li>
<li>数组原生自带<code>[Symbol.iterator]</code>属性，所以我们可以用<code>for...of</code>来遍历其成员</li>
</ul>
<pre><code>const arr = [1, 2, 3];
for (let v of arr) &#123;
  console.log(v); // 1 2 3
&#125;
</code></pre>
</blockquote>
</li>
<li><p>原生可遍历对象</p>
<blockquote>
<p>原生可遍历对象，是指<code>JS</code>中原生自带<code>[Symbol.iterator]</code>属性的对象。<br>JS 中具原生可遍历对象有：</p>
<ul>
<li>Array 数组</li>
<li>Set</li>
<li>Map</li>
<li>String 字符串</li>
<li>arguments 、NodeList 等 类数组对象<br>因为这些数据结构原生自带<code>[Symbol.iterator]</code>属性，所以都可以利用<code>for...of</code>来遍历。</li>
</ul>
</blockquote>
</li>
</ol>
<ul>
<li>Set<blockquote>
<pre><code>const set = new Set([1, 2, 3]);
const iterator = set[Symbol.iterator]();
console.log(iterator.next());//&#123;value: 1, done: false&#125;
console.log(iterator.next());//&#123;value: 2, done: false&#125;
console.log(iterator.next());//&#123;value: 3, done: false&#125;
console.log(iterator.next());//&#123;value: 4, done: false&#125;
</code></pre>
</blockquote>
</li>
<li>Map<blockquote>
<pre><code>const map = new Map([
[[1, 3, 3], &quot;数组&quot;],
[&#123; a: 1, b: 2 &#125;, &quot;对象&quot;],
]);
const iterator = map[Symbol.iterator]();
console.log(iterator.next());
console.log(iterator.next());
console.log(iterator.next());
</code></pre>
</blockquote>
</li>
<li>String<blockquote>
<pre><code>const str = &quot;hello&quot;;
for (let v of str) &#123;
console.log(v);
&#125;
// 结果: h e l l o
</code></pre>
</blockquote>
</li>
<li>类数组<blockquote>
<pre><code>function sum() &#123;
for (let v of arguments) &#123;
  console.log(v);
&#125;
&#125;
sum(1, 2, 3, 4);
// 结果 1 2 3 4
</code></pre>
</blockquote>
</li>
</ul>
<blockquote>
<blockquote>
<p>特别强调：</p>
</blockquote>
<ul>
<li>Object 对象，没有<code>[Symbol.iterator]</code>属性，则<strong>不能</strong>用<code>for...of</code>来遍历。</li>
</ul>
</blockquote>
<ol start="4">
<li><p>可迭代协议和迭代器协议</p>
<blockquote>
<p><strong>可迭代协议：</strong></p>
<ul>
<li>可以理解为一个对象如果想要用<code>for...of</code>来遍历，那他身上必需要有<code>[Symbol.itrerator]</code>属性，否则是不能用<code>for...of</code>来遍历的。<br><strong>迭代器协议：</strong> </li>
<li>是指<strong>迭代器对象</strong>必需要有<code>next()</code>方法，其方法的返回值必需为一个<strong>对象</strong>，对象有<code>value</code>和<code>done</code>两个属性，<code>value</code>表示每次迭代的成员，<code>done</code>用来标识成员是否迭代完成。</li>
</ul>
</blockquote>
</li>
<li><p>为对象添加迭代器接口</p>
<blockquote>
<p>如果对象要能用<code>for...of</code>来遍历，则需要遵顺<strong>可迭代协议</strong>和<strong>迭代器协议</strong>。</p>
<ul>
<li>即对象身上要有<code>[Symbol.iterator]</code>属性，其为一个函数，调用该函数会返回一个<strong>迭代器对象</strong>。</li>
<li>迭代器对象要遵顺<strong>迭代器协议</strong>，即迭代器对象有<code>next</code>方法，方法返回值为一个对象，对象有<code>value</code>和<code>done</code>两个属性等。</li>
</ul>
<pre><code>const obj = &#123;
  data: [1, 2, 3, 4],
  [Symbol.iterator]() &#123;
 let index = 0;
 self = this;
 return &#123;
   next() &#123;
     if (index &lt; self.data.length) &#123;
       return &#123;
         value: self.data[index++],
         done: false,
       &#125;;
     &#125; else &#123;
       return &#123;
         value: undefined,
         done: true,
       &#125;;
     &#125;
   &#125;,
 &#125;;
  &#125;,
&#125;;
</code></pre>
</blockquote>
<p>let it &#x3D; obj<a href="">Symbol.iterator</a>;<br>console.log(it.next());<br>console.log(it.next());<br>console.log(it.next());<br>console.log(it.next());<br>console.log(it.next());</p>
<blockquote>
</blockquote>
<p>&#x2F;&#x2F; 当用 for…of 来遍历obj对象时，其内部会自动调用obj的 [Symbol.iterator]方法来生成一个迭代器对象，来对其data数据中的成员遍历。<br>for (let v of obj) {<br>  console.log(v);<br>}</p>
<blockquote>
<pre><code>
</code></pre>
</blockquote>
</li>
</ol>
<blockquote>
<blockquote>
<p>注意：</p>
</blockquote>
<ul>
<li>自定义的<code>[Symbol.iterator]</code>方法，单独调用，<strong>其生成的迭代器对象</strong>，不能用<code>for...of</code>来遍历。</li>
</ul>
<pre><code>let it = obj[Symbol.iterator]();
for (let v of it) &#123;
  console.log(v);//报错
&#125;
</code></pre>
</blockquote>
<ol start="6">
<li>退出 for … of 循环<blockquote>
<p>在for…of循环语句中，可以使用</p>
<ul>
<li>break关键字退出整个循环</li>
<li>continue关键字来跳过当次循环</li>
<li>throw关键字抛出错误，同时退出循环</li>
<li>当在 <code>for ... of</code> 循环在一个<strong>函数体</strong>中时，可以在 <code>for ... of</code> 循环体中使用<code>return</code>关键字，返回函数的返回值</li>
</ul>
</blockquote>
</li>
</ol>
<ul>
<li>break 关键字<blockquote>
<pre><code>const arr = [1, 2, 3, 4, 5];
for (let v of arr) &#123;
if (v === 3) &#123;
  break;
&#125;
console.log(v);
&#125;
// 结果：  1  2
</code></pre>
</blockquote>
</li>
<li>continue 关键字<blockquote>
<pre><code>const arr = [1, 2, 3, 4, 5];
for (let v of arr) &#123;
if (v === 3) &#123;
  continue;
&#125;
console.log(v);
&#125;
// 结果  1  2  4  5
</code></pre>
</blockquote>
</li>
<li>throw 关键字<blockquote>
<pre><code>const arr = [1, 2, 3, 4, 5];
for (let v of arr) &#123;
if (v === 3) &#123;
  throw new Error(&quot;抛出错误，退出循环&quot;);
&#125;
console.log(v);
&#125;
// 结果  1  2  Uncaught Error: 抛出错误，退出循环
</code></pre>
</blockquote>
</li>
<li>return 关键字<blockquote>
<pre><code>function fn() &#123;
const arr = [1, 2, 3, 4, 5];
for (let v of arr) &#123;
  if (v === 3) &#123;
    return &quot;停止&quot;;
  &#125;
  console.log(v);
&#125;
&#125;
console.log(fn());
// 结果  1  2  停止
</code></pre>
</blockquote>
</li>
</ul>
<ol start="7">
<li>总结</li>
</ol>
<ul>
<li><p>可迭代对象与迭代器对象</p>
<blockquote>
<p><strong>可迭代对象</strong></p>
<ul>
<li>定义：带有<code>[Symbol.iterator]</code>属性的对象</li>
<li>与迭代器对象的关系：调用可迭代对象的<code>[Symbol.iterator]</code>方法会自动生成一个迭代器对象</li>
<li>原生可迭代对象包括：<code>Array</code> 数组、<code>Set</code>、<code>Map</code>、<code>String</code>字符串、<code>arguments</code> 、<code>NodeList</code>等类数组对象</li>
<li>可迭代协议：对象身上必需要有<code>[Symbol.itrerator]</code>属性</li>
</ul>
<p><strong>迭代器对象</strong></p>
<ul>
<li>定义：迭代器对象身上有一个<code>next</code>方法，调用这个方法，返回一个对象；对象有两个属性，分别为<code>value</code>和<code>done</code></li>
<li>迭代器对象包括：<ul>
<li>数组、<code>Set</code>、<code>Map</code>都有<code>keys、values、entries</code>方法，这三个方法调用后，都返回一个迭代器对象</li>
<li>调用可迭代对象的<code>[Symbol.iterator]</code>方法生成的迭代器对象</li>
</ul>
</li>
<li>迭代器协议：是指迭代器对象必需要有<code>next()</code>方法，其方法的返回值必需为一个对象，对象有<code>value</code>和<code>done</code>两个属性，<code>value</code>表示每次迭代的成员，<code>done</code>用来标识成员是否迭代完成。</li>
</ul>
<pre><code>//arr是Array的实例，自带[Symbol.iterator]方法，所以arr是可迭代对象
const arr = [1, 2, 3];
//调用[Symbol.iterator]方法的时候，会自动生成迭代器对象，也就是it
const it = arr[Symbol.iterator]();
</code></pre>
</blockquote>
</li>
<li><p><code>for...of</code>循环</p>
<blockquote>
<ul>
<li><code>for...of</code>既可以遍历<strong>迭代器对象</strong>，也可以遍历<strong>可迭代对象</strong></li>
<li>如果对象要能用<code>for...of</code>来遍历，则需要遵循可迭代协议和迭代器协议<blockquote>
<p>因此，为对象添中迭代器接口的方式，就是使他遵循可迭代协议和迭代器协议</p>
</blockquote>
</li>
</ul>
</blockquote>
</li>
</ul>
<blockquote>
<p><strong>遍历迭代器对象：有两种</strong></p>
<ul>
<li>遍历 调用<code>[Symbol.iterator]</code>方法的时候，生成的迭代器对象</li>
</ul>
<pre><code>const arr = [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;];
const it = arr[Symbol.iterator]();
for (let v of it) &#123;
  console.log(v);
&#125;
</code></pre>
<ul>
<li>遍历<code>keys、values、entries</code>方法调用后，返回的迭代器对象<ul>
<li>keys是键名，value是键值，entries是[键名，键值]的数组</li>
</ul>
</li>
</ul>
<pre><code>const s = new Set([1, 2, 3]);
for (let k of s.keys()) &#123;
  console.log(k); // 1 2 3
&#125;
</code></pre>
</blockquote>
<blockquote>
<p><strong>遍历可迭代对象</strong></p>
<ul>
<li>也就是原生的可迭代对象：<code>Array</code> 数组、<code>Set</code>、<code>Map</code>、<code>String</code>字符串、<code>arguments</code> 、<code>NodeList</code>等类数组对象</li>
</ul>
<pre><code>const arr = [1, 2, 3];
for (let v of arr) &#123;
  console.log(v); // 1 2 3
&#125;
</code></pre>
</blockquote>
<blockquote>
<ul>
<li>遍历<code>Array</code>的实例时，实际上是在遍历<code>valus()</code>生成的迭代器</li>
<li>遍历<code>Set</code>的实例时，实际上是在遍历<code>valus()</code>生成的迭代器</li>
<li>遍历<code>Map</code>的实例时，实际上是在遍历<code>entries()</code>生成的迭代器<blockquote>
<p>所以他们得到的值是一样的</p>
</blockquote>
</li>
</ul>
</blockquote>
<blockquote>
<blockquote>
<p>注意：</p>
</blockquote>
<ul>
<li>虽然可以手动为对象添中迭代器接口，也就是使他遵循可迭代协议和迭代器协议</li>
<li>但是调用自定义的<code>[Symbol.iterator]</code>方法，其生成的迭代器对象，不能用<code>for...of</code>来遍历。</li>
</ul>
</blockquote>
<blockquote>
<ul>
<li>退出<code>for ... of</code>循环的方式有<code>break</code>、<code>continue</code>、<code>throw</code>、<code>return</code></li>
</ul>
</blockquote>
<h3 id="四、有哪些场景使用了-Iterator-？"><a href="#四、有哪些场景使用了-Iterator-？" class="headerlink" title="四、有哪些场景使用了 Iterator ？"></a>四、有哪些场景使用了 Iterator ？</h3><blockquote>
<p>在<code>JS</code>这门语方中，有很多地方用到了<code>Iterator</code>，主要有</p>
<ul>
<li>for…of 循环</li>
<li>数组的展开运算符</li>
<li>数组解构赋值</li>
<li>Set 和 Map 构造函数的参数</li>
<li>Array.from()</li>
<li>Promise.all()</li>
<li>Promise.race()</li>
<li>yield*操作符，在生成器中使用</li>
</ul>
</blockquote>
<ol>
<li>验证方案<blockquote>
<p><strong>我们知道</strong></p>
<ul>
<li><strong>数组的解构赋值</strong>，等号的右边只要是一个可迭代对象就可以</li>
<li><strong>数组的扩展运算符</strong>后面只要是一个可迭代对象就可以<blockquote>
<p>其本质都是调用了对象身上的<code>[Symbol.iterator]</code>方法，生成迭代器对象，然后遍历取出对象中的成员。<br><strong>怎么验证？</strong></p>
</blockquote>
</li>
<li>修改对象身上的[Symbol.iterator]方法</li>
</ul>
</blockquote>
</li>
</ol>
<ul>
<li>修改前：<blockquote>
<pre><code>let str = &quot;hello&quot;;
const [a, b] = str; // 解构赋值
console.log(a, b); // h e
console.log(...str); //h e l l o
</code></pre>
</blockquote>
</li>
<li>修改后：<blockquote>
<pre><code>// 接下来我们修改字符串原型上的[Symbol.iterator]方法
String.prototype[Symbol.iterator] = function () &#123;
index = 0;
return &#123;
  next() &#123;
    if (index &lt; 3) &#123;
      return &#123;
        value: index++,
        done: false,
      &#125;;
    &#125; else &#123;
      return &#123;
        value: undefined,
        done: true,
      &#125;;
    &#125;
  &#125;,
&#125;;
&#125;;
</code></pre>
</blockquote>
let str &#x3D; “hello”;<br>const [x, y] &#x3D; str; &#x2F;&#x2F; 解构赋值<br>console.log(x, y); &#x2F;&#x2F; 0 1<blockquote>
</blockquote>
&#x2F;&#x2F; 解构赋值内部相当于执行了以下代码<br>&#x2F;&#x2F; const it &#x3D; str<a href="">Symbol.iterator</a>;<br>&#x2F;&#x2F; x &#x3D; it.next().value;<br>&#x2F;&#x2F; y &#x3D; it.next().value;<blockquote>
</blockquote>
&#x2F;&#x2F; 展开运算符<br>console.log(…str); &#x2F;&#x2F; 0 1 2<blockquote>
<pre><code>- 修改了`String.prototype[Symbol.iterator]`方法，所以在解构赋值时 其结果并不是输入`h e`，而是输出了`0 1`。
- 说明解构赋值时，其内部就是自动调用了`String.prototype[Symbol.iterator]`方法，然后迭代内部的成员来完成解构赋值的。
</code></pre>
</blockquote>
</li>
</ul>
<blockquote>
<p><strong>关于以下使用场景</strong></p>
<ul>
<li>Set 和 Map 构造函数的参数</li>
<li>Array.from()</li>
<li>Promise.all()</li>
<li>Promise.race()</li>
<li>yield*操作符，在生成器中使用<br>其原理和上面的数组的解构赋值原理是一样的，都是调用了对象身上的<code>[Symbol.iterator]</code>方法，生成了一个迭代器对象，然后<strong>迭代内部的成员</strong>来完成相关操作。</li>
</ul>
</blockquote>
<ol start="2">
<li>面试题<blockquote>
<p>编写相关代码，使下面代码成立，并且<code>a,b</code>成功赋值</p>
<pre><code>const [a, b] = &#123; a: 1, b: 2 &#125;;
</code></pre>
<p><strong>答案解析</strong></p>
<ul>
<li>数组的解构赋值 <code>=</code> 号右边只要是一个可迭代对象就可以，但<code>&#123;a:1, b:2&#125;</code>是一个<code>Object</code>类型的对象，他不是一个可迭代对象，也就是说他没有<code>[Symbol.iterator]</code>属性。</li>
<li>所以如果要使代码成立，并且 <code>a,b</code> 能成功赋值，则需要手动为<code>&#123;a:1, b:2&#125;</code>对象添加 <code>iterator</code> 接口。</li>
<li>迭代器是按顺序迭代成员，但对象是无序的；所以有两种方法</li>
</ul>
</blockquote>
</li>
</ol>
<ul>
<li><p>方法一：</p>
<blockquote>
<pre><code>Object.prototype[Symbol.iterator] = function () &#123;
let index = -1;
const self = this;
return &#123;
  next() &#123;
    index++;
    if (index === 0) &#123;
      return &#123; value: 1, done: false &#125;;
    &#125; else if (index === 1) &#123;
      return &#123; value: 2, done: false &#125;;
    &#125; else &#123;
      return &#123; value: undefined, done: true &#125;;
    &#125;
  &#125;,
&#125;;
&#125;;
const [a, b, c] = &#123; a: 1, b: 2 &#125;;
console.log(a, b, c); //1 2 undefined
</code></pre>
</blockquote>
</li>
<li><p>方式二：</p>
<blockquote>
<ul>
<li><code>Object.keys(obj)</code>：返回obj的属性名</li>
</ul>
<pre><code>Object.prototype[Symbol.iterator] = function () &#123;
let key = Object.keys(this);
let index = 0;
const self = this;
return &#123;
  next() &#123;
    if (index &lt; key.length) &#123;
      return &#123; value: self[key[index++]], done: false &#125;;
    &#125; else &#123;
      return &#123; value: undefined, done: true &#125;;
    &#125;
  &#125;,
&#125;;
&#125;;
const [a, b, c] = &#123; a: 1, b: 2 &#125;;
console.log(a, b, c); //1 2 undefined
</code></pre>
</blockquote>
</li>
</ul>
<h3 id="五、迭代器对象的-return-、throw-方法"><a href="#五、迭代器对象的-return-、throw-方法" class="headerlink" title="五、迭代器对象的 return 、throw 方法"></a>五、迭代器对象的 return 、throw 方法</h3><blockquote>
<p>迭代器对象除了具有<code>next()</code>方法，还可以具有<code>return</code>方法和<code>throw</code>方法。</p>
<ul>
<li>如果自己定义迭代器对象，则必需要有<code>next()</code>方法，但是 <code>return</code>和<code>throw</code>方法则是可选的。</li>
</ul>
</blockquote>
<ol>
<li><p><code>return</code>方法</p>
<blockquote>
<p>如果迭代器提前关闭时，则会<strong>自动调用</strong><code>return</code>方法。提前退出迭代器情况如下：</p>
<ul>
<li>遇到<code>break，throw，return</code>关键字时，会提前退出循环时<br>解构赋值时，未能消费所有值时<br><strong>注：</strong></li>
<li><code>return</code>方法的<strong>返回值，必需是一个对象</strong>，这是<code>Generator</code>规格决定的。</li>
<li><code>return</code>应用场景：如果一个对象在完成遍历前做某些操作，则可以为迭代器对象添加<code>return</code>方法。</li>
</ul>
<pre><code>class DataContainer &#123;
  data = [1, 2, 3, 4];
  [Symbol.iterator]() &#123;
 let index = 0;
 let data = this.data;
 return &#123;
   next() &#123;
     if (index &lt; data.length) &#123;
       return &#123;
         value: data[index++],
         done: false,
       &#125;;
     &#125; else &#123;
       return &#123;
         value: undefined,
         done: true,
       &#125;;
     &#125;
   &#125;,
   return() &#123;
     console.log(&quot;提前提出for...of,return方法被调用&quot;);
     return &#123; done: true &#125;;
   &#125;,
 &#125;;
  &#125;
&#125;
</code></pre>
</blockquote>
<p>for (let v of new DataContainer()) {<br>  if (v &#x3D;&#x3D;&#x3D; 2) {<br> break;<br>  }<br>  console.log(v);<br>}<br> &#x2F;&#x2F;1<br> &#x2F;&#x2F;  提前提出for…of,return方法被调用</p>
<blockquote>
<pre><code>
</code></pre>
</blockquote>
</li>
<li><p>不能关闭的迭代器</p>
<blockquote>
<p>因为 <code>return</code> 方法是可选的，所以数组、<code>Set</code>、<code>Map</code>、<code>String</code>，类数组的迭代器对象上<strong>都没有</strong><code>return</code>方法。<br>当<code>for...of</code>遍历时遇到<code>break、continue、return、throw</code>，<strong>都不会关闭迭代器</strong>。</p>
<blockquote>
<p>如果一个迭代器<strong>没关闭</strong>，则还可以<strong>继承</strong>从上次离开的地方继承迭代。</p>
</blockquote>
<pre><code>const arr = new Set([&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;]);
const it = arr[Symbol.iterator]();
for (let v of it) &#123;
  console.log(v); // a b
  if (v === &quot;b&quot;) &#123;
 break;
  &#125;
&#125;
</code></pre>
</blockquote>
<p>&#x2F;&#x2F; 上面的迭代器没有关闭，下面继承迭代<br>for (let v of it) {<br>  console.log(v); &#x2F;&#x2F; c d<br>}</p>
<blockquote>
<pre><code>
</code></pre>
</blockquote>
</li>
</ol>
<h3 id="六、为什么需要迭代器和-for-…-of"><a href="#六、为什么需要迭代器和-for-…-of" class="headerlink" title="六、为什么需要迭代器和 for … of"></a>六、为什么需要迭代器和 for … of</h3><blockquote>
<p>在 JS 中遍历的方法有<code>for、forEach、for...in</code>，为什么还有要<code>for...of</code>呢 ？ 也就是说，为什么需要迭代器呢 ？</p>
<ul>
<li>因为迭代器主要是供<code>for...of</code>来消费的。</li>
</ul>
</blockquote>
<ol>
<li><p>对比不同的遍历方式</p>
<blockquote>
<p>那接下来我们就通过对比来了解不同遍历方式之间的差异，从而就能知道为什么还需要迭代器和<code>for...of</code></p>
<table>
<thead>
<tr>
<th>遍历方法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>for</td>
<td>for 循环可以用来遍历数组或类数组对象，但是都需要了解其 length 属性和访问元素的方式。也就是都需要了解其内部结构。写起来也比较麻烦</td>
</tr>
<tr>
<td>forEach</td>
<td>forEach 可以用来遍历数组、Map、Set，其不需要暴露它们的内部结构，但是他只限于访问数组、Map、Set。其次 forEach 没有办法和 break、continue、return 关键字使用退出循环。</td>
</tr>
<tr>
<td>for…in</td>
<td>for…in主要是用来遍历 Object 类型的对象而用的，当然也可以用来遍历数组，但是其遍历得到的是数组的键名，而非数组的成员。其次还会遍历手动添加到数组身上的键，也会遍历原型上的键。</td>
</tr>
<tr>
<td>for…of</td>
<td>有for…in一样简洁的语法，但没有for…in的那些缺点；不同于 forEach 方法，可以与 break、continue、return 配合使用；不同于 for 循环，其遍历不需要暴露对象的内部结构；for…of提供了遍历所有数据的统一操作接口。</td>
</tr>
</tbody></table>
</blockquote>
</li>
<li><p>迭代器作用</p>
<blockquote>
<p>迭代器<strong>主要作用</strong>有以下 3 点：</p>
<ul>
<li>为各种不同的数据结构（对象）提供了统一的，简便的访问接口。</li>
<li>数据结构的成员以一定的顺序遍历出来</li>
<li><code>Iterator</code> 接口，主要供<code>for...of</code>消费，一个对象只要有<code>iterator</code>接口，就可以利用<code>for...of</code>来遍历</li>
<li>以后我们如果不想暴露对象的内部结构，而有希望能用<code>for...of</code>这种统一的方式来遍历数据成员，就可以为对象添加<code>iterator</code>接口。</li>
</ul>
</blockquote>
</li>
</ol>
<h2 id="ES6字符串、数组、对象的新增方法和常见应用"><a href="#ES6字符串、数组、对象的新增方法和常见应用" class="headerlink" title="ES6字符串、数组、对象的新增方法和常见应用"></a>ES6字符串、数组、对象的新增方法和常见应用</h2><h3 id="一、字符串的新增方法"><a href="#一、字符串的新增方法" class="headerlink" title="一、字符串的新增方法"></a>一、字符串的新增方法</h3><table>
<thead>
<tr>
<th>方法</th>
<th>说明</th>
<th>是否更改原数组</th>
</tr>
</thead>
<tbody><tr>
<td>padEnd</td>
<td>用一个字符串从当前字符串的末尾来填充当前字符串，使字符串达到指定长度。返回结果为填充后的新字符串。</td>
<td>否</td>
</tr>
<tr>
<td>padStart</td>
<td>用一个字符串从当前字符串的左侧来填充当前字符串，使字符串达到指定长度。</td>
<td>否</td>
</tr>
<tr>
<td>trimStart</td>
<td>方法会删除字符串开头的空白字符</td>
<td>否</td>
</tr>
<tr>
<td>trimEnd</td>
<td>方法会删除字符串末尾的空白字符</td>
<td>否</td>
</tr>
<tr>
<td>trim</td>
<td>方法从字符串的两端清除空格</td>
<td>否</td>
</tr>
<tr>
<td>startsWith</td>
<td>方法用来判断当前字符串是否以另外一个给定的子字符串开头</td>
<td>否</td>
</tr>
<tr>
<td>endsWith</td>
<td>方法用来判断当前字符串是否是以另外一个给定的子字符串“结尾”的</td>
<td>否</td>
</tr>
<tr>
<td>repeat</td>
<td>构造并返回一个新字符串，该字符串包含被连接在一起的指定数量的字符串的副本</td>
<td>否</td>
</tr>
</tbody></table>
<ol>
<li>padStart<blockquote>
<p>用一个字符串从当前字符串的<strong>左侧</strong>来填充当前字符串，使字符串达到指定长度。</p>
<ul>
<li>返回结果为填充后的新字符串</li>
</ul>
</blockquote>
</li>
</ol>
<ul>
<li>语法<blockquote>
<pre><code>padEnd(targetLength[, padString])
</code></pre>
<ul>
<li><code>targetLength</code>当前字符串需要填充到的目标长度</li>
<li><code>padString</code>填充字符串，如果需要的话，会反复多次来填充，默认值为空格<code> </code></li>
</ul>
</blockquote>
</li>
<li>基本用法<blockquote>
<pre><code>console.log(&quot;abcd&quot;.padStart(7, &quot;*&quot;)); // ***abcd
console.log(&quot;abcd&quot;.padStart(7, &quot;@#&quot;)); // @#@abcd
</code></pre>
</blockquote>
</li>
<li>注意事项<blockquote>
<ul>
<li>如果<code>targetLength</code>的值<code>&lt;=</code>当前字符串的长度，则返回当前字符串本身</li>
</ul>
<pre><code>console.log(&quot;abcd&quot;.padStart(4, &quot;*&quot;)); // abcd
</code></pre>
<ul>
<li>如果 padString 长度过长，只会保留最左侧部分，其他部分会被截断</li>
</ul>
<pre><code>console.log(&quot;abcd&quot;.padStart(8, &quot;01234&quot;)); // 0123abcd
</code></pre>
</blockquote>
</li>
</ul>
<ol start="2">
<li>padEnd<blockquote>
<p>用一个字符串从当前字符串的<strong>末尾</strong>来填充当前字符串，使字符串达到指定长度。</p>
<ul>
<li>返回结果为填充后的新字符串</li>
</ul>
</blockquote>
</li>
</ol>
<ul>
<li>语法<blockquote>
<pre><code>padEnd(targetLength[, padString])
</code></pre>
<ul>
<li><code>targetLength</code>当前字符串需要填充到的目标长度</li>
<li><code>padString</code>填充字符串，如果需要的话，会反复多次来填充</li>
</ul>
</blockquote>
</li>
<li>基本用法<blockquote>
<pre><code>let str = &quot;清心&quot;.padEnd(6, &quot;爱你&quot;);
console.log(str); // 清心爱你爱你
</code></pre>
</blockquote>
let str2 &#x3D; “清心”.padEnd(5, “52”);<br>console.log(str2); &#x2F;&#x2F; 清心525<blockquote>
<pre><code>
</code></pre>
</blockquote>
</li>
<li>注意事项<blockquote>
<ul>
<li>如果 targetLength 的值 &lt;&#x3D; 当前字符串的长度，则返回当前字符串本身</li>
</ul>
<pre><code>let str = &quot;清心&quot;.padEnd(2, &quot;爱你&quot;);
console.log(str); // 清心
</code></pre>
<ul>
<li>如果 padString 长度过长，只会保留最左侧部分，其他部分会被截断</li>
</ul>
<pre><code>str = &quot;清心&quot;.padEnd(5, &quot;520def&quot;);
console.log(str); // 清心520
</code></pre>
</blockquote>
</li>
<li>案例应用<blockquote>
<p>将以下 map 数据，在控制台以以下图形式显示出来</p>
<pre><code>const map = new Map([
[&quot;luobo&quot;, 5],
[&quot;baicai&quot;, 2.5],
[&quot;doujiao&quot;, 3],
[&quot;huacai&quot;, 5],
]);
</code></pre>
</blockquote>
</li>
</ul>
<blockquote>
<pre><code>for ([k, v] of map) &#123;
  console.log(k.padEnd(20, &quot;-&quot;) + v);
&#125;
</code></pre>
</blockquote>
<ol start="3">
<li><p>trimStart</p>
<blockquote>
<p><code>trimStart()</code>方法会删除<strong>字符串开头</strong>的空白字符。<code>trimLeft()</code>是此方法的别名</p>
<pre><code>let str = &quot;   love   &quot;;
console.log(str.length); // 10
str = str.trimStart(); // 去掉前面的空白字符
console.log(str); // &quot;love   &quot;
console.log(str.length); // 7
</code></pre>
</blockquote>
</li>
<li><p>trimEnd</p>
<blockquote>
<p><code>trimEnd()</code>方法会删除字符串<strong>末尾</strong>的空白字符。<code>trimRight()</code>是这个方法的别名。</p>
<pre><code>let str = &quot;   love   &quot;;
console.log(str.length); // 10
str = str.trimEnd(); // 去掉字符串后面的空白字符
console.log(str); // &quot;   love&quot;
console.log(str.length); // 7
</code></pre>
</blockquote>
</li>
<li><p>trim</p>
<blockquote>
<p><code>trim()</code>方法从字符串的<strong>两端</strong>清除空格，返回一个新的字符串，而不修改原始字符串</p>
<blockquote>
<p>这三个方法都是返回新字符串，不会改变原始字符串</p>
</blockquote>
<pre><code>let str = &quot;   love   &quot;;
console.log(str.length); // 10
str = str.trim();
console.log(str); // &quot;love&quot;
console.log(str.length); // 4
</code></pre>
</blockquote>
</li>
<li><p>startsWith</p>
<blockquote>
<p><code>startsWith()</code>方法用来判断当前字符串是否以另外一个给定的子字符串<strong>开头</strong>。如果是返回<code>true</code>，否则返回<code>false</code>。</p>
<ul>
<li>注意：此方法，严格区分大小写</li>
</ul>
</blockquote>
</li>
</ol>
<ul>
<li>语法<blockquote>
<pre><code>str.startsWith(searchString[, position])
</code></pre>
<ul>
<li><code>searchString</code> 要搜索的子字符串</li>
<li><code>position</code> 可选参数在<code>str</code>中搜索<code>searchString </code>的开始位置，默认值为<code>0</code></li>
</ul>
</blockquote>
</li>
<li>基本用法<blockquote>
<pre><code>console.log(&quot;data_iconfont&quot;.startsWith(&quot;data_&quot;)); // true
console.log(&quot;data_iconfont&quot;.startsWith(&quot;data-&quot;)); // false
console.log(&quot;data_iconfont&quot;.startsWith(&quot;icon&quot;, 4)); // false
console.log(&quot;data_iconfont&quot;.startsWith(&quot;icon&quot;, 5)); // true
</code></pre>
</blockquote>
</li>
</ul>
<ol start="7">
<li>endsWith<blockquote>
<p><code>endsWith()</code>方法用来判断当前字符串是否是以另外一个给定的子字符串<strong>“结尾”</strong>的。</p>
<ul>
<li>如果是，返回结果为true，否则为 false。</li>
<li>注意：此方法，严格区分大小写</li>
</ul>
</blockquote>
</li>
</ol>
<ul>
<li>语法<blockquote>
<pre><code>str.endsWith(searchString[, length])
searchString : 要搜索的子字符串
length ： 作为 str 的长度。默认值为 str.length
</code></pre>
</blockquote>
</li>
<li>基本用法<blockquote>
<pre><code>console.log(&quot;data_iconfont&quot;.endsWith(&quot;font&quot;)); // true
console.log(&quot;data_iconfont&quot;.endsWith(&quot;t&quot;)); // true
console.log(&quot;data_iconfont&quot;.endsWith(&quot;con&quot;, 9)); // true
console.log(&quot;data_iconfont&quot;.startsWith(&quot;con&quot;, 10)); // false
</code></pre>
</blockquote>
</li>
</ul>
<ol start="8">
<li>repeat 方法<blockquote>
<p>构造并返回一个新字符串，该字符串包含被连接在一起的<strong>指定数量</strong>的字符串的副本。</p>
</blockquote>
</li>
</ol>
<ul>
<li>语法<blockquote>
<pre><code>str.repeat(count);
</code></pre>
</blockquote>
</li>
</ul>
<blockquote>
<ul>
<li><code>count</code>是介于<code>0</code>和<code>+Infinity</code>之间的整数。表示在新构造的字符串中<strong>重复了多少遍</strong>原字符串。</li>
</ul>
<pre><code>// &quot;abc&quot;.repeat(-1); // 报错
console.log(&quot;abc&quot;.repeat()); // &quot;&quot;
console.log(&quot;abc&quot;.repeat(0)); // &quot;&quot;
console.log(&quot;abc&quot;.repeat(1)); // abc
console.log(&quot;abc&quot;.repeat(2)); // abcabc
console.log(&quot;abc&quot;.repeat(3)); // abcabcabc
</code></pre>
</blockquote>
<h3 id="二、数组新增方法"><a href="#二、数组新增方法" class="headerlink" title="二、数组新增方法"></a>二、数组新增方法</h3><ul>
<li>数组相关的实例方法<table>
<thead>
<tr>
<th>实例方法</th>
<th>说明</th>
<th>是否更改原数组</th>
</tr>
</thead>
<tbody><tr>
<td>map</td>
<td>创建一个新数组，这个新数组由原数组中的每个元素都调用一次提供的函数后的返回值组成。</td>
<td>否</td>
</tr>
<tr>
<td>some</td>
<td>方法测试数组中是不是至少有 1 个元素通过了被提供的函数测试</td>
<td>否</td>
</tr>
<tr>
<td>every</td>
<td>测试一个数组内的所有元素是否都能通过某个指定函数的测试</td>
<td>否</td>
</tr>
<tr>
<td>reduce</td>
<td>reducer 逐个遍历数组元素，每一步都将当前元素的值与上一步的计算结果做相关操作，直到没有更多元素相加</td>
<td>否</td>
</tr>
<tr>
<td>reduceRight</td>
<td>与 reduce 一样，只是他默认的从数组的尾元素开始，即从右向左</td>
<td></td>
</tr>
<tr>
<td>keys</td>
<td>返回一个遍历器对象，用来遍历所有的键名</td>
<td>否</td>
</tr>
<tr>
<td>values</td>
<td>返回一个遍历器对象，用来遍历所有的键值</td>
<td>否</td>
</tr>
<tr>
<td>entries</td>
<td>返回一个遍历器对象，用来遍历**[键名，键值]**组成的数组</td>
<td>否</td>
</tr>
<tr>
<td>fill</td>
<td>方法用一个固定值填充一个数组中从起始索引到终止索引内的全部元素。不包括终止索引。</td>
<td>是</td>
</tr>
<tr>
<td>copyWithin</td>
<td>访方法浅复制数组的一部分到同一数组中的另一个位置，会覆盖原数组成员，但不会改变原数组的长度。返回改变后的原数组</td>
<td>是</td>
</tr>
<tr>
<td>flat</td>
<td>flat 方法用于将数组按指定层级来扁平化（展开）。返回值为一个新的数组</td>
<td>否</td>
</tr>
<tr>
<td>flatMap</td>
<td>flatMap 方法相当于数组的 map 方法和 flat 方法的合并用法</td>
<td>否</td>
</tr>
<tr>
<td>at</td>
<td>返回数组指定索引的元素。索引值允许正数和负数。</td>
<td>否</td>
</tr>
</tbody></table>
</li>
</ul>
<blockquote>
<ul>
<li>关于数组的：includes、find、findIndex 方法，之前讲完，这里就不再重复</li>
</ul>
</blockquote>
<ul>
<li>数组的静态方法<table>
<thead>
<tr>
<th>静态方法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>Array.from</td>
<td>对一个类似数组或可迭代对象创建一个新的，浅拷贝的数组实例。</td>
</tr>
<tr>
<td>Array.of</td>
<td>通过可变数量的参数创建一个新的<code>Array</code>实例</td>
</tr>
</tbody></table>
</li>
</ul>
<ol>
<li>map 方法<blockquote>
<p><code>map()</code>方法创建一个新数组，这个新数组由原数组中的每个元素都调用一次提供的函数后的<strong>返回值</strong>组成。</p>
</blockquote>
</li>
</ol>
<ul>
<li><p>语法</p>
<blockquote>
<pre><code>map(function (element, index, array) &#123;
/* … */
&#125;, thisArg);
// 或
map((element, index, array) =&gt; &#123;&#125;);
</code></pre>
<ul>
<li>回调函数中的三个参数<ul>
<li>element 表示数组中正在处理的当前元素</li>
<li>index 数组中正在处理的当前元素的索引</li>
<li>array 调用 map 方法的数组</li>
</ul>
</li>
<li>thisArg 可选参数，用来更改回调函数中的 this 指向，如果回调函数为箭头函数，则 this 更改无效</li>
</ul>
</blockquote>
</li>
<li><p>基础应用</p>
<blockquote>
<ul>
<li>将数组中每个元素乘以 2</li>
</ul>
<pre><code>const arr = [1, 2, 3];
const newArr = arr.map((value) =&gt; value * 2);
console.log(newArr); // [2, 4, 6]
</code></pre>
</blockquote>
</li>
</ul>
<blockquote>
<ul>
<li>求数组中每个元素的平方<blockquote>
<p><code>Math.pow(value,n)</code>：求value的n次方</p>
</blockquote>
</li>
</ul>
<pre><code>const arr = [1, 2, 3];
const newArr = arr.map((value) =&gt; Math.pow(value, 2));
console.log(newArr); // [1, 4, 9]
</code></pre>
</blockquote>
<blockquote>
<ul>
<li>获取字符串中每个字符对应的<code>ASCII</code>码的映射关系<blockquote>
<p>让字符串使用数组的方法：调用数组的原型方法，改变<code>this</code>指向<br><code>charCodeAt(index)</code>方法获取<code>ASCII</code> 码</p>
</blockquote>
</li>
</ul>
<pre><code>const str = &quot;hello&quot;;
const charCods = Array.prototype.map.call(str, (value) =&gt; &#123;
  return &#123;
    [value]: value.charCodeAt(0),
  &#125;;
&#125;);
console.log(charCods);
</code></pre>
</blockquote>
<ul>
<li>回调函数中 this 指向<blockquote>
<pre><code>const arr = [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;];
const obj = &#123; a: 1, b: 2 &#125;;
arr.map(() =&gt; &#123;
console.log(this); // window
&#125;, obj);
</code></pre>
</blockquote>
arr.map(function () {<br>console.log(this); &#x2F;&#x2F; { a: 1, b: 2 }<br>}, obj);<blockquote>
<pre><code>
</code></pre>
</blockquote>
</li>
</ul>
<ol start="2">
<li>some 方法<blockquote>
<p><code>some()</code>方法测试数组中是不是<strong>至少有 1 个元素</strong>通过了被提供的函数测试。</p>
<ul>
<li>即：只要有一个通过测试，返回值就为 true，否则为 false</li>
</ul>
</blockquote>
</li>
</ol>
<ul>
<li><p>语法</p>
<blockquote>
<pre><code>some(function (element, index, array) &#123;
/* … */
&#125;, thisArg);
// 或
some((element, index, array) =&gt; &#123;
/* … */
&#125;);
</code></pre>
<ul>
<li>回调函数中的三个参数<ul>
<li>element 表示数组中正在处理的当前元素</li>
<li>index 数组中正在处理的当前元素的索引</li>
<li>array 调用some方法的数组</li>
</ul>
</li>
<li>thisArg 可选参数，用来更改回调函数中的 this 指向，如果回调函数为箭头函数，则 this 更改无效</li>
</ul>
</blockquote>
</li>
<li><p>基本用法</p>
<blockquote>
<ul>
<li>测试数组中是否存在偶数</li>
</ul>
<pre><code>const result = [1, 3, 5, 7, 9].some((value) =&gt; value % 2 === 0);
console.log(result); // false
</code></pre>
</blockquote>
<p>const result2 &#x3D; [1, 4, 5, 7, 9].some((value) &#x3D;&gt; value % 2 &#x3D;&#x3D;&#x3D; 0);<br>console.log(result2); &#x2F;&#x2F; true</p>
<blockquote>
<pre><code>
</code></pre>
</blockquote>
</li>
<li><p>检测以下数组中，蔬菜价格是否有大于 10 元的</p>
<blockquote>
<pre><code>const arr = [
&#123; name: &quot;白菜&quot;, price: 7 &#125;,
&#123; name: &quot;西蓝花&quot;, price: 11 &#125;,
&#123; name: &quot;豆角&quot;, price: 9 &#125;,
];
</code></pre>
</blockquote>
<p>const result &#x3D; arr.some((v) &#x3D;&gt; v.price &gt;&#x3D; 10);<br>console.log(result); &#x2F;&#x2F;true</p>
<blockquote>
<pre><code>
</code></pre>
</blockquote>
</li>
</ul>
<ol start="3">
<li>every 方法<blockquote>
<p><code>every()</code>方法测试一个数组内的<strong>所有元素</strong>是否都能通过某个指定函数的测试</p>
<ul>
<li>即：只有数组中所有元素通过测试，返回值才为 true，否则为 false</li>
</ul>
</blockquote>
</li>
</ol>
<ul>
<li>语法<blockquote>
<pre><code>every(function (element, index, array) &#123;
/* … */
&#125;, thisArg);
// 或
every((element, index, array) =&gt; &#123;
/* … */
&#125;);
</code></pre>
<ul>
<li>回调函数中的三个参数<ul>
<li>element 表示数组中正在处理的当前元素</li>
<li>index 数组中正在处理的当前元素的索引</li>
<li>array 调用every方法的数组</li>
</ul>
</li>
<li>thisArg 可选参数，用来更改回调函数中的 this 指向，如果回调函数为箭头函数，则 this 更改无效</li>
</ul>
</blockquote>
</li>
<li>基本用法<blockquote>
<ul>
<li>检测数组中是否所有元素都小于 100</li>
</ul>
<pre><code>const result1 = [20, 30, 40, 50, 120].every((v) =&gt; v &lt; 100);
console.log(result1); // false
</code></pre>
</blockquote>
const result2 &#x3D; [20, 30, 40, 50, 10].every((v) &#x3D;&gt; v &lt; 100);<br>console.log(result2); &#x2F;&#x2F; true<blockquote>
<pre><code>
</code></pre>
</blockquote>
</li>
</ul>
<ol start="4">
<li>reduce 方法<blockquote>
<p><code>reduce()</code>方法对数组中的每个元素<strong>按序执行</strong>一个由您提供的 <code>reducer</code> 函数，每一次运行 <code>reducer</code> 会将<strong>先前元素</strong>的计算结果作为参数传入，最后将其结果汇总为单个返回值。</p>
</blockquote>
</li>
</ol>
<blockquote>
<ul>
<li>第一次执行回调函数时，不存在“上一次的计算结果”。如果不需要回调函数从数组索引为<code>0</code>的元素开始执行，就传递初始值。</li>
<li>否则，数组索引为 <code>0</code> 的元素将被作为初始值 <code>initialValue</code>，迭代器将从第二个元素开始执行（索引为 1 而不是 0）</li>
</ul>
</blockquote>
<ul>
<li><p>语法</p>
<blockquote>
<pre><code>reduce(function (previousValue, currentValue, currentIndex, array) &#123;
/* … */
&#125;, initialValue);
</code></pre>
<ul>
<li><code>initialValue</code>可选参数，作为第一次调用<code>callback</code>函数时参数<code>previousValue</code>的值</li>
<li>回调函数中的 4 个参数，分别表示：<table>
<thead>
<tr>
<th>参数</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>previousValue</td>
<td>上一次调用 callbackFn 时的返回值。在第一次调用时，若指定了初始值 initialValue，其值则为 initialValue，否则为数组索引为 0 的元素 array[0]</td>
</tr>
<tr>
<td>currentValue</td>
<td>数组中正在处理的元素。在第一次调用时，若指定了初始值 initialValue，其值则为数组索引为 0 的元素 array[0]，否则为 array[1]</td>
</tr>
<tr>
<td>currentIndex</td>
<td>数组中正在处理的元素的索引。若指定了初始值 initialValue，则起始索引号为 0，否则从索引 1 起始</td>
</tr>
<tr>
<td>array</td>
<td>用于遍历的数组</td>
</tr>
</tbody></table>
</li>
</ul>
</blockquote>
</li>
<li><p>基本用法</p>
<blockquote>
<ul>
<li>没有传入<code>initialValue</code>参数时，第一次调用 <code>callBackFn</code>，即<code>previousValue = array[0]</code>、<code>currentValue = array[1]</code></li>
</ul>
<pre><code>const result = [1, 2, 3, 4].reduce(
(previousValue, currentValue, currentIndex, array) =&gt; &#123;
  console.log(previousValue, currentValue, currentIndex, array);
  return previousValue;
&#125;
);
</code></pre>
<table>
<thead>
<tr>
<th>回调函数调用</th>
<th>previousValue</th>
<th>currentValue</th>
<th>currentIndex</th>
<th>array</th>
<th>返回值</th>
</tr>
</thead>
<tbody><tr>
<td>第一次</td>
<td>1</td>
<td>2</td>
<td>1</td>
<td>[1, 2, 3, 4]</td>
<td>1</td>
</tr>
<tr>
<td>第二次</td>
<td>1</td>
<td>3</td>
<td>2</td>
<td>[1, 2, 3, 4]</td>
<td>1</td>
</tr>
<tr>
<td>第三次</td>
<td>1</td>
<td>4</td>
<td>3</td>
<td>[1, 2, 3, 4]</td>
<td>1</td>
</tr>
</tbody></table>
<blockquote>
<p>最终返回值为最后一次回调函数的返回值： 1</p>
</blockquote>
</blockquote>
</li>
<li><p>传入<code>initialValue</code>参数时，即<code>previousValue = initialValue、currentValue = array[0]</code></p>
<blockquote>
<pre><code>const result = [1, 2, 3, 4].reduce(
(previousValue, currentValue, currentIndex, array) =&gt; &#123;
  console.log(previousValue, currentValue, currentIndex, array);
  return previousValue;
&#125;,
10
);
console.log(result);
</code></pre>
<table>
<thead>
<tr>
<th>回调函数调用</th>
<th>previousValue</th>
<th>currentValue</th>
<th>currentIndex</th>
<th>array</th>
<th>返回值</th>
</tr>
</thead>
<tbody><tr>
<td>第一次</td>
<td>10</td>
<td>1</td>
<td>0</td>
<td>[1, 2, 3, 4]</td>
<td>10</td>
</tr>
<tr>
<td>第二次</td>
<td>10</td>
<td>2</td>
<td>1</td>
<td>[1, 2, 3, 4]</td>
<td>10</td>
</tr>
<tr>
<td>第三次</td>
<td>10</td>
<td>3</td>
<td>2</td>
<td>[1, 2, 3, 4]</td>
<td>10</td>
</tr>
<tr>
<td>第四次</td>
<td>10</td>
<td>4</td>
<td>3</td>
<td>[1, 2, 3, 4]</td>
<td>10</td>
</tr>
</tbody></table>
<blockquote>
<p>最终返回值为最后一次回调函数的返回值： 10</p>
</blockquote>
</blockquote>
</li>
<li><p>案例应用</p>
<blockquote>
<ul>
<li>求数组中所有元素之和</li>
</ul>
<pre><code>const result = [10, 20, 30, 40].reduce((previousValue, currentValue) =&gt; &#123;
return previousValue + currentValue;
&#125;);
console.log(result);
</code></pre>
</blockquote>
</li>
</ul>
<blockquote>
<ul>
<li>数组去重</li>
</ul>
<pre><code>const result = [1, 2, 2, 3, 3, 4, 5].reduce((prev, current) =&gt; &#123;
  if (!prev.includes(current)) &#123;
    prev.push(current);
  &#125;
  return prev;
&#125;, []);
console.log(result); // [1, 2, 3, 4, 5]
</code></pre>
</blockquote>
<blockquote>
<ul>
<li>求数组中最大值</li>
</ul>
<pre><code>const result = [1, 2, 10, 4, 5, 40].reduce((prev, current) =&gt; &#123;
  return Math.max(prev, current);
&#125;);
console.log(result); // 40
</code></pre>
</blockquote>
<blockquote>
<ul>
<li>计算数组中每个元素出现的次数</li>
</ul>
<pre><code>const result = [&quot;a&quot;, &quot;b&quot;, &quot;a&quot;, &quot;c&quot;, &quot;b&quot;, &quot;d&quot;].reduce((prev, current) =&gt; &#123;
  prev.set(current, (prev.get(current) || 0) + 1);
  return prev;
&#125;, new Map());
console.log(result); // Map(4) &#123;&#39;a&#39; =&gt; 2, &#39;b&#39; =&gt; 2, &#39;c&#39; =&gt; 1, &#39;d&#39; =&gt; 1&#125;
</code></pre>
</blockquote>
<ol start="5">
<li><p>keys、values、entries 方法</p>
<table>
<thead>
<tr>
<th>方法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>keys()</td>
<td>返回一个遍历器对象，用来遍历所有的键名</td>
</tr>
<tr>
<td>values()</td>
<td>返回一个遍历器对象，用来遍历所有的键值</td>
</tr>
<tr>
<td>entries()</td>
<td>返回一个遍历器对象，用来遍历 [键名，键值] 组成的数组。</td>
</tr>
</tbody></table>
<blockquote>
<pre><code>const arr = [&quot;a&quot;, &quot;b&quot;, &quot;a&quot;];
</code></pre>
</blockquote>
<p>&#x2F;&#x2F; 遍历数组的所有键名<br>for (let k of arr.keys()) {<br>  console.log(k); &#x2F;&#x2F; 0 1 2<br>}<br>&#x2F;&#x2F; 遍历数组的所有键值<br>for (let v of arr.values()) {<br>  console.log(v); &#x2F;&#x2F; a b a<br>}<br>&#x2F;&#x2F; 遍历由数组的 [键名，键值] 组成的数组，然后参于数组的解构赋值<br>for (let [k, v] of arr.entries()) {<br>  console.log(<code>$&#123;k&#125; =&gt; $&#123;v&#125;</code>);<br>  &#x2F;&#x2F; 结果<br>  &#x2F;&#x2F; 0 &#x3D;&gt; a    1 &#x3D;&gt; b   2 &#x3D;&gt; a<br>}</p>
<blockquote>
<pre><code>
</code></pre>
</blockquote>
</li>
<li><p>fill 方法</p>
<blockquote>
<p><code>fill()</code>方法用一个<strong>固定值</strong>填充一个数组中从起始索引到终止索引内的全部元素。不包括终止索引。</p>
<ul>
<li>返回结果：修改后的数组。</li>
</ul>
</blockquote>
</li>
</ol>
<ul>
<li><p>语法：</p>
<blockquote>
<pre><code>fill(value, start, end); // 参数 start 和 end为可选参数
</code></pre>
<ul>
<li>value：用来填充数组元素的值</li>
<li>start：可选参数，起始索引，默认值为 0 ，如果值为<strong>负数</strong>，则索引值会被自动计算为数组<code>length+start</code></li>
<li>end: 可选参数，终止索引，默认值为 <code>arr.length</code>, 如果值为<strong>负数</strong>，则索引值会被自动计算为数组<code>length+start</code></li>
</ul>
<pre><code>console.log([1, 2, 3].fill(&quot;a&quot;)); //  [&#39;a&#39;, &#39;a&#39;, &#39;a&#39;]
console.log([1, 2, 3].fill(&quot;a&quot;, 1)); // [1, &#39;a&#39;, &#39;a&#39;]
console.log([1, 2, 3, 4, 5].fill(&quot;a&quot;, 1, 4)); //  [1, &#39;a&#39;, &#39;a&#39;, &#39;a&#39;, 5]
console.log([1, 2, 3, 4, 5].fill(&quot;a&quot;, -4, -1)); // [1, &#39;a&#39;, &#39;a&#39;, &#39;a&#39;, 5]
console.log([1, 2, 3, 4, 5].fill(&quot;a&quot;, -1, -4)); //4&gt;1  [1, 2, 3, 4, 5]
</code></pre>
<blockquote>
<p>如果自动计算后，起始索引&gt;结束索引，那就返回原数组</p>
</blockquote>
</blockquote>
</li>
<li><p>注意事项</p>
<blockquote>
<ul>
<li><code>fill()</code>方法被设计为一个<strong>通用</strong>方法，其方法内部的 <code>this</code> 不一定非要是数组，可以利用 <code>call</code> 来修改，也就是说，<code>fill()</code>方法，可以用来操作<strong>类数组对象</strong></li>
<li>类数组对象：<blockquote>
<p>必须要有<code>length</code>属性</p>
</blockquote>
</li>
</ul>
<pre><code>console.log([].fill.call(&#123; a: 1, b: 2, c: 3, length: 3 &#125;, 8));
//&#123;0: 8, 1: 8, 2: 8, a: 1, b: 2, c: 3, length: 3&#125;
console.log([].fill.call(&#123; length: 3 &#125;, 8));
//&#123;0: 8, 1: 8, 2: 8, length: 3&#125;
</code></pre>
<ul>
<li>默认情况下，<code>value</code>按<code>length</code>属性的长度填充，键名为从0开始的数字，键值为<code>value</code></li>
<li>如果有起始&#x2F;结束索引，规则和上面一样，最长为<code>length</code>属性规定的长度</li>
</ul>
</blockquote>
</li>
<li><p><code>fill()</code>中用来填充的数据，如果是一个<strong>引用类型</strong>，会导致执行同一个引用</p>
<blockquote>
<pre><code>const arr = [1, 2, 3, 4];
arr.fill(&#123;&#125;, 1);
console.log(arr); // [1,&#123;&#125;,&#123;&#125;,&#123;&#125;]
console.log(arr[1] === arr[2]); //true
</code></pre>
</blockquote>
<p>arr[1].a &#x3D; 1;<br>console.log(arr); &#x2F;&#x2F; [1,{a:1},{a:1},{a:1}]</p>
<blockquote>
<pre><code>
</code></pre>
</blockquote>
</li>
</ul>
<ol start="7">
<li>copyWithin<blockquote>
<p><code>copyWithin()</code>方法<strong>浅复制</strong>数组的一部分到同一数组中的另一个位置，会覆盖原有成员。不会改变原数组的长度。</p>
<ul>
<li>返回结果为改变后的<strong>原数组</strong></li>
</ul>
</blockquote>
</li>
</ol>
<ul>
<li><p>语法</p>
<blockquote>
<pre><code>copyWithin(target, start, end);
</code></pre>
<ul>
<li>target 目标索引，从该位置开始替换数据<ul>
<li>如果为<strong>负数</strong>，其值相当于等于<code>arr.length + start</code></li>
<li>如果<strong>大于</strong><code>arr.length</code>，将不发生拷贝。</li>
<li>如果在<code>start</code>和<code>end</code>之后，复制的序列将被修改长度，超出部分去掉，以符合<code>arr.length</code></li>
</ul>
</li>
<li>start 可选，从该位置开始读取数据。默认值为 0 ，如果为<strong>负数</strong>，其值等于<code>arr.length + start</code></li>
<li>end 可选，到该位置停止读取数据。默认值为<code>arr.length</code>， 如果为<strong>负数</strong>，其值等于 <code>arr.length + end</code><blockquote>
<p>如果自动计算后，起始索引&gt;结束索引，那就返回原数组</p>
</blockquote>
</li>
</ul>
</blockquote>
</li>
<li><p>基本用法</p>
<blockquote>
<pre><code>[1, 2, 3, 4, 5].copyWithin(0, 2); //  [3, 4, 5, 4, 5]
[1, 2, 3, 4, 5, 6].copyWithin(2, 3, 5); // [1, 2, 4, 5, 5, 6]
[1, 2, 3, 4, 5, 6].copyWithin(4, 2, 5); // [1, 2, 3, 4, 3, 4];
[1, 2, 3, 4, 5, 6].copyWithin(1, -4, -2); // [1, 3, 4,4, 5, 6];
[1, 2, 3, 4, 5, 6].copyWithin(1, -2, -4); //  不变 [1, 2, 3, 4, 5, 6]
</code></pre>
</blockquote>
</li>
</ul>
<blockquote>
<ul>
<li><code>copyWithin</code>方法，利用<code>call</code>方法改变内部<code>this</code>，也可以用来操作类数组对象</li>
</ul>
<pre><code>let obj = &#123; 0: &quot;a&quot;, 1: &quot;b&quot;, 2: &quot;c&quot;, 3: &quot;d&quot;, 4: &quot;e&quot;, length: 5 &#125;;
obj = [].copyWithin.call(obj, 0, 1, 3);
console.log(obj); // &#123;0: &#39;b&#39;, 1: &#39;c&#39;, 2: &#39;c&#39;, 3: &#39;d&#39;, 4: &#39;e&#39;, length: 5&#125;
</code></pre>
<ul>
<li>只替换键值</li>
</ul>
</blockquote>
<ol start="8">
<li>flat 方法<blockquote>
<p><code>flat</code>方法用于将数组<strong>按指定层级</strong>来扁平化（展开）。</p>
<ul>
<li>返回值为一个新的数组</li>
</ul>
</blockquote>
</li>
</ol>
<ul>
<li>语法<blockquote>
<pre><code>flat(depth);
</code></pre>
<ul>
<li><code>depth</code>可选参数，默认值为1，用来指定数组的展开层级。如果值<code>&lt;= 0</code>，表示不展开</li>
<li><code>depth</code>是几，就表示去掉几个<code>[]</code></li>
</ul>
</blockquote>
</li>
<li>基本应用<blockquote>
<ul>
<li>扁平化嵌套数组<blockquote>
<p>使用<code>Infinity</code>，可以展开任意深度的嵌套</p>
</blockquote>
</li>
</ul>
<pre><code>const arr1 = [1, [2, [3, 4]], 5];
const arr2 = arr1.flat();
console.log(arr2);
console.log(arr1 === arr2); // false
</code></pre>
</blockquote>
console.log([1, [2, [3, 4]], 5].flat(2)); &#x2F;&#x2F;  [1, 2, 3, 4, 5]<blockquote>
</blockquote>
&#x2F;&#x2F; 使用 Infinity，可以展开任意深度的嵌套<br>const arr &#x3D; [1, [2, [3, 4, [5, [6], 7], 8], 9]];<br>console.log(arr.flat(Infinity)); &#x2F;&#x2F; [1, 2, 3, 4, 5, 6, 7, 8, 9]<blockquote>
<pre><code>
</code></pre>
</blockquote>
</li>
</ul>
<blockquote>
<ul>
<li>移除数组中的空项<blockquote>
<p>在最外层的空项才会被移除</p>
</blockquote>
</li>
</ul>
<pre><code>const arr = [1, [, , [, 2, 3, ,], 4], 5, 6];
console.log(arr.flat(0)); //[1, [, , [, 2, 3, ,], 4], 5, 6]
console.log(arr.flat(1)); // [1, [, 2, 3, ,], 4, 5, 6]
console.log(arr.flat(2)); //[1, 2, 3, 4, 5, 6]
</code></pre>
</blockquote>
<ol start="9">
<li>flatMap 方法<blockquote>
<p><code>flatMap</code> 方法相当于数组的 <code>map</code> 方法和 <code>flat</code> 方法的<strong>合并</strong>用法。<br>数组调用<code>flatMap</code>方法，相当于<strong>先</strong>调用数组的<code>map</code>，然后再将返回的结果数组<strong>再</strong>调用 <code>flat()</code> 方法展开，展开深度为 <code>1</code>。</p>
<ul>
<li>返回值为一个新的数组。</li>
</ul>
</blockquote>
</li>
</ol>
<ul>
<li>语法<blockquote>
<pre><code>flatMap(function (currentValue, index, array) &#123;
/* … */
&#125;, thisArg);
</code></pre>
<ul>
<li>callBack 回调函数的三个参数<ul>
<li>currentValue： 当前正在数组中处理的元素</li>
<li>index：可选的。数组中正在处理的当前元素的索引</li>
<li>array：可选的。被调用的 map 数组</li>
</ul>
</li>
<li>thisArg 可选的，用来更改 callBack 回调函数中的 this 指向</li>
</ul>
</blockquote>
</li>
<li>基本用法：<blockquote>
<pre><code>const arr = [1, 2, 3, 4];
const res = arr.flatMap((x) =&gt; [x * 2]);
console.log(res); // [2, 4, 6, 8]
</code></pre>
</blockquote>
&#x2F;&#x2F; 上面代码 arr.flatMap((x) &#x3D;&gt; [x * 2]) 的内部相当于执行了以下两步<br>const arr2 &#x3D; arr.map((x) &#x3D;&gt; [x * 2]);<br>const res2 &#x3D; arr2.flat();<br>console.log(res2);&#x2F;&#x2F; [2, 4, 6, 8]<blockquote>
<pre><code>
</code></pre>
</blockquote>
</li>
</ul>
<blockquote>
<ul>
<li>将几句话的数组拆份成单个词组成的新数组</li>
</ul>
<pre><code>const arr = [&quot;Happy New Year&quot;, &quot;May you be happy and prosperous&quot;];
const word = arr.flatMap((v) =&gt; v.split(&quot; &quot;));
console.log(word); // [&#39;Happy&#39;, &#39;New&#39;, &#39;Year&#39;, &#39;May&#39;, &#39;you&#39;, &#39;be&#39;, &#39;happy&#39;, &#39;and&#39;, &#39;prosperous&#39;]
</code></pre>
</blockquote>
<ol start="10">
<li>at 方法<blockquote>
<p>返回数组<strong>指定索引</strong>的元素。索引值允许正数和负数。<strong>负数</strong>表示从末尾开始。</p>
</blockquote>
</li>
</ol>
<ul>
<li>语法<blockquote>
<pre><code>at(index); // index为整数，正数负数都可以
</code></pre>
</blockquote>
</li>
<li>基本用法<blockquote>
<pre><code>[1, 2, 3].at(1); // 2
[1, 2, 3].at(-1); // 3
</code></pre>
</blockquote>
</li>
</ul>
<ol start="11">
<li>Array.from 方法<blockquote>
<p><code>Array.form()</code>方法对一个类似数组或可迭代对象创建一个新的，<strong>浅拷贝</strong>的<strong>数组实例</strong>。</p>
<ul>
<li>返回值：一个新的数组实例</li>
</ul>
</blockquote>
</li>
</ol>
<ul>
<li><p>语法</p>
<blockquote>
<pre><code>Array.from(
arrayLike,
function mapFn(element, index) &#123;
  /* … */
&#125;,
thisArg
);
</code></pre>
</blockquote>
</li>
<li><p>参数</p>
<blockquote>
<ul>
<li>arrayLike：想要转换成数组的伪数组对象或可迭代对象</li>
<li>mapFn：如果指定了该参数，新数组中的每个元素会执行该回调函数。相当于对新生成的数组实例，再调用 map 方法</li>
<li>thisArg：可选参数，执行回调函数 mapFn 时 this 对象。 默认 this 指向<code>window</code></li>
</ul>
</blockquote>
</li>
<li><p>基本应用</p>
<blockquote>
<ul>
<li>string 类型生成数组</li>
</ul>
<pre><code>Array.from(&quot;hello&quot;);
// [&#39;h&#39;, &#39;e&#39;, &#39;l&#39;, &#39;l&#39;, &#39;o&#39;]
</code></pre>
</blockquote>
</li>
</ul>
<blockquote>
<ul>
<li>Set 生成数组</li>
</ul>
<pre><code>const set = new Set([&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;]);
console.log(Array.from(set)); // [&#39;a&#39;, &#39;b&#39;, &#39;c&#39;, &#39;d&#39;]
</code></pre>
</blockquote>
<ul>
<li>Map 生成二维数组<blockquote>
<pre><code>const map = new Map([
[&quot;a&quot;, 1],
[&quot;b&quot;, 2],
[&quot;c&quot;, 3],
]);
console.log(Array.from(map)); // [[&quot;a&quot;, 1],[&quot;b&quot;, 2],[&quot;c&quot;, 3]]
</code></pre>
</blockquote>
&#x2F;&#x2F; 传入第二个参数<br>let res &#x3D; Array.from(map, (v) &#x3D;&gt; v[1]);<br>console.log(res); &#x2F;&#x2F; [1, 2, 3]<blockquote>
</blockquote>
&#x2F;&#x2F; 传入第三个参数，修改this指向<br>let res &#x3D; Array.from(map, (v, i) &#x3D;&gt; this[i], [“foo”, “bar”, “zoo”]);<br>console.log(res); &#x2F;&#x2F; [undefined, undefined, undefined]<blockquote>
</blockquote>
&#x2F;&#x2F; 修改this只能是普通函数<br>let res2 &#x3D; Array.from(<br>map,<br>function (v, i) {<br>  return this[i];<br>},<br>[“foo”, “bar”, “zoo”]<br>);<br>console.log(res2);<blockquote>
<pre><code>
</code></pre>
</blockquote>
</li>
</ul>
<ol start="12">
<li>Array.of 方法<blockquote>
<p><code>Array.of()</code>方法通过可变数量的参数创建一个新的<code>Array</code>实例，而不考虑参数的数量或类型。</p>
</blockquote>
</li>
</ol>
<ul>
<li>语法<blockquote>
<pre><code>Array.of(element0, element1, /* … ,*/ elementN);
</code></pre>
</blockquote>
</li>
<li>基本用法<blockquote>
<pre><code>Array.of(); // []
Array.of(1); // [1]
Array.of(1, 2, 3); // [1, 2, 3]
</code></pre>
</blockquote>
</li>
</ul>
<blockquote>
<blockquote>
<p>此方法主要目的是：</p>
</blockquote>
<ul>
<li>弥补数组构造函数 Array() 的不足</li>
<li><code>Array.of()</code>和<code>Array()</code>构造函数之间的<strong>区别</strong>在于对单个参数的处理：<ul>
<li>Array.of(7) 创建一个具有单个元素 7 的数组</li>
<li>而 Array(7) 创建一个 length 为 7 的空数组</li>
</ul>
</li>
<li>这意味着一个由7个空槽组成的数组，而不是具有实际 <code>undefined</code>值的槽</li>
</ul>
<pre><code>Array.of(7); // [7]
new Array(7); //  [empty × 7]
</code></pre>
</blockquote>
<ul>
<li>模拟 ArrayOf 方法<blockquote>
<pre><code>Array.of = function () &#123;
return [].slice.call(arguments);
&#125;;
</code></pre>
</blockquote>
</li>
</ul>
<h3 id="三、对象新增方法"><a href="#三、对象新增方法" class="headerlink" title="三、对象新增方法"></a>三、对象新增方法</h3><blockquote>
<p>对象的静态方法</p>
<table>
<thead>
<tr>
<th>静态方法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>Object.is()</code></td>
<td>方法判断两个值是否为同一个值</td>
</tr>
<tr>
<td><code>Object.assign()</code></td>
<td>方法用于将源(source)对象的所有可枚举的自有属性复制到目标 target 对象</td>
</tr>
<tr>
<td><code>Object.freeze</code></td>
<td>方法可以冻结一个对象</td>
</tr>
<tr>
<td><code>Object.keys()</code></td>
<td>返回一个由一个给定对象的自身可枚举属性组成的数组</td>
</tr>
<tr>
<td><code>Object.values()</code></td>
<td>返回一个给定对象自身的所有可枚举属性值的数组</td>
</tr>
<tr>
<td><code>Object.entrie()</code></td>
<td>返回一个给定对象自身可枚举属性的键值对数组</td>
</tr>
<tr>
<td><code>Object.getOwnPropertyDescriptor()</code></td>
<td>方法返回指定对象上一个自有属性对应的属性描述符</td>
</tr>
<tr>
<td><code>Object.getOwnPropertyDescriptors()</code></td>
<td>方法用来获取一个对象的所有自身属性的描述符</td>
</tr>
<tr>
<td><code>Object.getOwnPropertyNames()</code></td>
<td>返回一个由指定对象的所有自身属性的属性名（包括不可枚举属性但不包括 Symbol 值作为名称的属性）组成的数组</td>
</tr>
<tr>
<td><code>Object.getOwnPropertySymbols()</code></td>
<td>方法返回一个给定对象自身的所有 Symbol 属性的数组</td>
</tr>
<tr>
<td><code>Object.fromEntries()</code></td>
<td>方法把键值对列表转换为一个对象</td>
</tr>
<tr>
<td><code>Object.setPrototypeOf()</code></td>
<td>设置一个指定的对象的原型（即，内部<code>[[Prototype]]</code>属性）到另一个对象或 null</td>
</tr>
<tr>
<td><code>Object.getPrototypeOf()</code></td>
<td>方法返回指定对象的原型</td>
</tr>
</tbody></table>
</blockquote>
<ol>
<li><p>Object.is 方法</p>
<blockquote>
<p><code>Object.is()</code>方法判断两个值是否为同一个值。如果是同一个值，返回 <code>true</code>,否则返回 <code>false</code>。</p>
<ul>
<li>其判断标准与<code>===</code>相似，唯一的差别在于他两对<strong>零值</strong>和<code>NaN</code>的判断不同</li>
<li><code>===</code>中认为<code>0</code>,<code>-0</code>,<code>+0</code>是同一个值，<code>NaN</code>和<code>NaN</code> 是不同的值</li>
<li><code>Object.is()</code>中认为0,-0,+0 三者中<strong>只有0、+0是同值</strong>，<code>NaN</code>和<code>NaN</code> 是相同的值</li>
</ul>
<pre><code>console.log(Object.is(1, 1)); // true
console.log(Object.is(true, 1)); // false
console.log(Object.is([], [])); // false
</code></pre>
</blockquote>
<p>console.log(NaN &#x3D;&#x3D;&#x3D; NaN); &#x2F;&#x2F; false<br>console.log(0 &#x3D;&#x3D;&#x3D; -0); &#x2F;&#x2F; true<br>console.log(0 &#x3D;&#x3D;&#x3D; +0); &#x2F;&#x2F; true<br>console.log(-0 &#x3D;&#x3D;&#x3D; +0); &#x2F;&#x2F; true</p>
<blockquote>
</blockquote>
<p>console.log(Object.is(NaN, NaN)); &#x2F;&#x2F; true<br>console.log(Object.is(0, -0)); &#x2F;&#x2F; false<br>console.log(Object.is(0, +0)); &#x2F;&#x2F; true<br>console.log(Object.is(-0, +0)); &#x2F;&#x2F; false</p>
<blockquote>
<pre><code>
</code></pre>
</blockquote>
</li>
<li><p>Objec.assign 方法</p>
<blockquote>
<p><code>Object.assign()</code>方法用于将源（source）对象的所有<strong>可枚举的自有属性</strong>复制到目标<code>target</code>对象。</p>
<ul>
<li>返回值：为 target 目标对象</li>
</ul>
</blockquote>
</li>
</ol>
<ul>
<li><p>语法</p>
<blockquote>
<pre><code>Object.assign(target, sources1, sources1,...)
</code></pre>
<ul>
<li>target：目标对象，接收源对象属性的对象，也是修改后的返回值</li>
<li>sources1, sources1,…： 为源对象</li>
</ul>
</blockquote>
</li>
<li><p>基本用法</p>
<blockquote>
<pre><code>const obj1 = &#123; a: 1, b: 2 &#125;;
const obj2 = &#123; c: 3, d: 4 &#125;;
Object.assign(obj1, obj2);
console.log(obj1); // &#123;a: 1, b: 2, c: 3, d: 4&#125;
</code></pre>
</blockquote>
<p>&#x2F;&#x2F; 注意区分以下写法的不同<br>Object.assign(obj1, obj2); &#x2F;&#x2F; 将obj2合并到obj1<br>const obj &#x3D; { …obj1, …obj2 }; &#x2F;&#x2F; 将obj1和obj2合并到一个新对象，然后赋值给obj</p>
<blockquote>
</blockquote>
<p>&#x2F;&#x2F; 用Object.assign实现 const obj&#x3D; {…obj1,…obj2} 写法如下<br>const obj &#x3D; Object.assign({}, obj1, obj2);</p>
<blockquote>
<pre><code>
</code></pre>
</blockquote>
</li>
<li><p>如果<code>Object.assign</code>方法只有一个参数</p>
<blockquote>
<ul>
<li>该参数为一个对象，直接将该对象作为返回值返回。</li>
<li>如果该参数不是一个对象类型，会先转换为对象类型，然后将其作为返回值返回。</li>
<li>如果该参数是<code>null</code>或<code>undefined</code>，因为<code>null</code>和<code>undefined</code>不能转换为对象，所以会报错。</li>
</ul>
<pre><code>// 只有一个参数，且为对象类型，直接将该对象作为返回值返回
const obj1 = Object.assign(&#123; a: 1, b: 2 &#125;);
console.log(obj1); // &#123;a: 1, b: 2&#125;
</code></pre>
</blockquote>
<p>&#x2F;&#x2F;只有一个参数，且为基本数据类型，将其转换为对象然后作为返回值返回<br>const obj2 &#x3D; Object.assign(2);<br>console.log(obj2); &#x2F;&#x2F; Number {2}</p>
<blockquote>
</blockquote>
<p>&#x2F;&#x2F; 由于null和undefined不能转换为对象，报错<br>const obj3 &#x3D; Object.assign(null); &#x2F;&#x2F; 报错<br>const obj4 &#x3D; Object.assign(undefined); &#x2F;&#x2F; 报错</p>
<blockquote>
<pre><code>
</code></pre>
</blockquote>
</li>
<li><p><code>Object.assign</code>方法的<strong>源对象位置</strong>的参数</p>
<blockquote>
<ul>
<li>如果是非对象类型的参数，则会将其自动转换为对象</li>
<li>如果是<code>null</code>和<code>undefined</code>，则会直接忽略，并不会报错</li>
</ul>
<pre><code>const obj1 = &#123; a: 1, b: 2 &#125;;
Object.assign(obj1, 1, &quot;hello&quot;, null, undefined, true);
console.log(obj1); // &#123;0: &#39;h&#39;, 1: &#39;e&#39;, 2: &#39;l&#39;, 3: &#39;l&#39;, 4: &#39;o&#39;, a: 1, b: 2&#125;
</code></pre>
</blockquote>
</li>
</ul>
<ol start="3">
<li><code>Object.assign</code> 的注意事项</li>
</ol>
<ul>
<li><p>如果目标对象与源对象具有相同的属性，则目标对象中的属性将被源对象属性<strong>覆盖</strong></p>
<blockquote>
<pre><code>const obj1 = &#123;
color: [&quot;红色&quot;, &quot;黑色&quot;],
a: 1,
b: 2,
&#125;;
const obj2 = &#123;
color: [&quot;白色&quot;, &quot;蓝色&quot;],
b: 3,
c: 4,
&#125;;
</code></pre>
</blockquote>
<p>Object.assign(obj1, obj2);<br>console.log(obj1);</p>
<blockquote>
<pre><code>
</code></pre>
</blockquote>
</li>
<li><p>将源对象中的属性复制到目标对象，其本质是<strong>浅拷贝</strong></p>
<blockquote>
<pre><code>const obj1 = &#123;&#125;;
const obj2 = &#123;
arr: [1, 2],
&#125;;
Object.assign(obj1, obj2);
obj2.arr.push(3); // 修改obj2的arr属性，其相当于修改了obj1的arr属性
console.log(obj1.arr); //  [1, 2, 3]
</code></pre>
</blockquote>
</li>
<li><p><code>Object.assign</code>方法将只能将源对象上的<strong>自身可枚举属性</strong>复制到目标对象，只要是自身的可枚举属性，其属性名为 <code>Symbol</code>类型也会被复制</p>
<blockquote>
<pre><code>const obj = &#123; a: 1, b: 2 &#125;;
const obj2 = &#123; c: 3, [Symbol()]: &quot;Symbol&quot; &#125;;
// 为obj2添加两个自身属性
Object.defineProperties(obj2, &#123;
name: &#123;
  value: &quot;清心&quot;, // 属性值
  writable: true, // 可写
  configurable: false, // 不可重匹配
  enumerable: true, // 可枚举
&#125;,
age: &#123;
  value: 33,
  writable: true,
  configurable: false,
  enumerable: false, // 不可枚举
&#125;,
&#125;);
</code></pre>
</blockquote>
<p>console.log(obj2); &#x2F;&#x2F; {c: 3, name: ‘清心’, age: 33, Symbol(): ‘Symbol’}<br>Object.assign(obj, obj2);<br>console.log(obj); &#x2F;&#x2F; {a: 1, b: 2, c: 3, name: ‘清心’, Symbol(): ‘Symbol’}</p>
<blockquote>
<pre><code>- 不可枚举的`age`属性不会被复制到目标对象
</code></pre>
</blockquote>
</li>
<li><p>如果源对象上有 get 和 set 函数，其相当于<strong>新增一个属性</strong>合并到原型中，但没有 get 和 set 函数</p>
<blockquote>
<pre><code>const obj1 = &#123;
a: 1,
b: 2,
&#125;;
const obj2 = &#123;
_x: &quot;a&quot;,
get x() &#123;
  return this._x;
&#125;,
set x(value) &#123;
  if (x === 3) &#123;
    throw new Error(&quot;值不能为3&quot;);
  &#125; else &#123;
    this._x = value;
  &#125;
&#125;,
&#125;;
</code></pre>
</blockquote>
<p>Object.assign(obj1, obj2);<br>console.log(obj1); &#x2F;&#x2F; {a: 1, b: 2, _x: ‘a’, x: ‘a’}<br>obj1.x &#x3D; 3;&#x2F;&#x2F;不会报错，因为此时x已经等于”a”了<br>console.log(obj1.x);&#x2F;&#x2F;3</p>
<blockquote>
<pre><code>
</code></pre>
</blockquote>
</li>
</ul>
<ol start="4">
<li><p>Object.assign 的常见应用</p>
<blockquote>
<p>常用合并默认参数和用户参数</p>
<pre><code>// userOptions为用户参数
const userInfo = (userOptions) =&gt; &#123;
  // 默认参数
  const DEFAULTS = &#123;
 username: &quot;icoding&quot;,
 age: 0,
 sex: &quot;male&quot;,
  &#125;;
</code></pre>
</blockquote>
<p>  &#x2F;&#x2F; 合并默认参数和用户参数<br>  const options &#x3D; Object.assign({}, DEFAULTS, userOptions);<br>  console.log(options);<br>};</p>
<blockquote>
</blockquote>
<p>userInfo(); &#x2F;&#x2F; {username: ‘icoding’, age: 0, sex: ‘male’}<br>userInfo({}); &#x2F;&#x2F; {username: ‘icoding’, age: 0, sex: ‘male’}<br>userInfo({ username: “arry” }); &#x2F;&#x2F; {username: ‘arry’, age: 0, sex: ‘male’}<br>userInfo({ username: “清心”, age: 18, sex: “female” }); &#x2F;&#x2F; {username: ‘清心’, age: 18, sex: ‘female’}</p>
<blockquote>
<pre><code>
</code></pre>
</blockquote>
</li>
<li><p>keys、values、entries</p>
<table>
<thead>
<tr>
<th>方法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>keys</td>
<td>返回一个由一个给定对象的自身可枚举属性<strong>（不包括 Symbol类型）</strong>组成的数组，数组中属性名的排列顺序和正常循环遍历该对象时返回的顺序一致</td>
</tr>
<tr>
<td>values</td>
<td>方法返回一个给定对象自身的所有可枚举属性值的数组，值的顺序与使用 for…in 循环的顺序相同（区别在于 for-in 循环枚举原型链中的属性）</td>
</tr>
<tr>
<td>entries</td>
<td>方法返回一个给定对象自身可枚举属性的键值对数组，其排列与使用 for…in 循环遍历该对象时返回的顺序一致（区别在于 for-in 循环还会枚举原型链中的属性</td>
</tr>
</tbody></table>
<blockquote>
<pre><code>const obj = &#123;
  a: 1,
  b: 2,
  c: 3,
&#125;;
// 定义自身属性
Object.defineProperties(obj, &#123;
  name: &#123;
 value: &quot;清心&quot;,
 enumerable: true,
  &#125;,
  age: &#123;
 value: 33,
  &#125;,
&#125;);
</code></pre>
</blockquote>
<p>const keys &#x3D; Object.keys(obj);<br>console.log(keys); &#x2F;&#x2F; [‘a’, ‘b’, ‘c’, ‘name’]</p>
<blockquote>
</blockquote>
<p>const values &#x3D; Object.values(obj);<br>console.log(values); &#x2F;&#x2F; [1, 2, 3, ‘清心’]</p>
<blockquote>
</blockquote>
<p>const entries &#x3D; Object.entries(obj);<br>console.log(entries); &#x2F;&#x2F; [Array(2), Array(2), Array(2), Array(2)]</p>
<blockquote>
<pre><code>
</code></pre>
</blockquote>
</li>
</ol>
<ul>
<li>与 for…of 的结合应用<blockquote>
<ul>
<li>因为对象的<code>Object.keys()</code>、<code>Object.values()</code>、<code>Object.entries()</code>返回的是数组，数组是可迭代对象</li>
</ul>
<pre><code>const obj = &#123;
a: 1,
b: 2,
c: 3,
&#125;;
// 遍历对象的所有自身可枚举属性名
for (let key of Object.keys(obj)) &#123;
console.log(key);
&#125;
// 遍历对象的所有自身可枚举属性值
for (let values of Object.values(obj)) &#123;
console.log(values);
&#125;
// 遍历对象的属性名与对应的属性值
for (let [key, value] of Object.entries(obj)) &#123;
console.log(`$&#123;key&#125; =&gt; $&#123;value&#125;`);
&#125;
</code></pre>
</blockquote>
</li>
</ul>
<blockquote>
<blockquote>
<p>注意和数组、Set、Map 的<code>keys、values、entries</code>方法<strong>对比</strong><br>调用方式的不同</p>
</blockquote>
<ul>
<li>对象是构造函数的方法，将对象传入的方式<code>Object.keys(obj)</code></li>
<li>数组是实例的方法，通过实例对象就可以调用方法<code>[1, 2, 3].keys()</code>，而对象是没有的<br><strong>返回值的不同</strong></li>
<li>对象的<code>Object.keys()</code>、<code>Object.values()</code>、<code>Object.entries()</code>等方法是构造函数方法，返回的都是<strong>数组</strong></li>
<li>数组的<code>keys()</code>、<code>values()</code>、<code>entries()</code>等方法是实例方法，返回的统一都是数组的遍历对象<code>Iterator</code></li>
</ul>
<pre><code>console.log([1, 2, 3].keys()); // Array Iterator &#123;&#125;
console.log([1, 2, 3].values()); // Array Iterator &#123;&#125;
console.log([1, 2, 3].entries()); // Array Iterator &#123;&#125;
</code></pre>
</blockquote>
<ol start="7">
<li>Object.getOwnPropertyDescriptor<blockquote>
<p>方法返回指定对象上一个指定的自有属性对应的<strong>属性描述符</strong>，如果对象身上有这个属性，返回其属性描述符对象，否则返回<code>undefined</code></p>
</blockquote>
</li>
</ol>
<ul>
<li>语法<blockquote>
<pre><code>Object.getOwnPropertyDescriptor(obj, prop);
// obj 需要查找的目标对象
// prop 目标对象内属性名称
</code></pre>
</blockquote>
</li>
</ul>
<blockquote>
<pre><code>const obj = &#123;
  name: &quot;清心&quot;,
  get sex() &#123;
    return this._sex;
  &#125;,
  set sex(value) &#123;
    this._sex = value;
  &#125;,
&#125;;
Object.defineProperty(obj, &quot;age&quot;, &#123;
  value: 33,
  configurable: false,
  enumerable: true,
  writable: false,
&#125;);
</code></pre>
</blockquote>
<p>let desc1 &#x3D; Object.getOwnPropertyDescriptor(obj, “name”);<br>console.log(desc1);<br>let desc2 &#x3D; Object.getOwnPropertyDescriptor(obj, “sex”);<br>console.log(desc2);<br>let desc3 &#x3D; Object.getOwnPropertyDescriptor(obj, “age”);<br>console.log(desc3);</p>
<blockquote>
<pre><code>
</code></pre>
</blockquote>
<ol start="8">
<li>Object.getOwnPropertyDescriptors<blockquote>
<p>获取一个对象的所有自身属性的描述符。如果没有属性，则返回空对象</p>
</blockquote>
</li>
</ol>
<ul>
<li>语法<blockquote>
<pre><code>const obj = &#123;
name: &quot;清心&quot;,
get sex() &#123;
  return this._sex;
&#125;,
set sex(value) &#123;
  this._sex = value;
&#125;,
&#125;;
Object.defineProperty(obj, &quot;age&quot;, &#123;
value: 33,
configurable: false,
enumerable: true,
writable: false,
&#125;);
</code></pre>
</blockquote>
let descAll &#x3D; Object.getOwnPropertyDescriptors(obj);<br>console.log(descAll);<blockquote>
<pre><code>
</code></pre>
</blockquote>
</li>
</ul>
<blockquote>
<p>浅拷贝一个对象</p>
<ul>
<li><code>Object.assign()</code>方法只能拷贝源对象的可枚举的自身属性，同时拷贝时无法拷贝属性的特性们，而且访问器属性会被转换成数据属性，也无法拷贝源对象的原型。</li>
<li>而<code>Object.getOwnPropertyDescriptors</code>方法配合 <code>Object.create()</code>方法可以实现上面说的这些。</li>
</ul>
<pre><code>Object.create(
  Object.getPrototypeOf(obj),
  Object.getOwnPropertyDescriptors(obj)
);
</code></pre>
</blockquote>
<blockquote>
<pre><code>const obj = &#123;
  name: &quot;清心&quot;,
  get sex() &#123;
    return this._sex;
  &#125;,
  set sex(value) &#123;
    if (value &lt; 33) &#123;
      throw new Error(&quot;年龄不符&quot;);
    &#125; else &#123;
      this._sex = value;
    &#125;
  &#125;,
&#125;;
Object.defineProperty(obj, &quot;age&quot;, &#123;
  value: 33,
  configurable: false,
  enumerable: true,
  writable: false,
&#125;);
</code></pre>
</blockquote>
<p>const obj2 &#x3D; Object.create(<br>  Object.getPrototypeOf(obj),<br>  Object.getOwnPropertyDescriptors(obj)<br>);<br>console.log(obj2);&#x2F;&#x2F;{name: ‘清心’, age: 33}并带有get set方法<br>obj2.sex &#x3D; 22;&#x2F;&#x2F;报错：年龄不符</p>
<blockquote>
<pre><code>
</code></pre>
</blockquote>
<ol start="9">
<li>Object.getOwnPropertyNames<blockquote>
<p>返回一个由指定对象的所有自身属性的属性名（包括不可枚举属性但不包括 <code>Symbol</code> 值作为名称的属性）组成的数组。</p>
</blockquote>
</li>
</ol>
<table>
<thead>
<tr>
<th>方法</th>
<th>原型</th>
<th>自身</th>
<th>自身 Symbol</th>
<th>可枚举</th>
<th>不可枚举</th>
</tr>
</thead>
<tbody><tr>
<td>Object.getOwnPropertyNames</td>
<td></td>
<td>✔</td>
<td></td>
<td>✔</td>
<td>✔</td>
</tr>
</tbody></table>
<ul>
<li>语法<blockquote>
<pre><code>Object.getOwnPropertyNames(obj);
// 在 ES2015 中，非对象参数被强制转换为对象
</code></pre>
</blockquote>
</li>
</ul>
<blockquote>
<pre><code>const obj = &#123;
  [Symbol()]: &quot;Symbol&quot;,
  name: &quot;清心&quot;,//可枚举
&#125;;
Object.defineProperty(obj, &quot;sex&quot;, &#123;
  value: &quot;女&quot;,//不可枚举
&#125;);
</code></pre>
</blockquote>
<p>const desc &#x3D; Object.getOwnPropertyNames(obj);<br>console.log(desc); &#x2F;&#x2F; [‘name’, ‘sex’]</p>
<blockquote>
<pre><code>&gt;如果只想获取对象的自身可枚举属性，可以使用`Object.keys`方法。
</code></pre>
</blockquote>
<blockquote>
<ul>
<li>在 ES2015 中，非对象参数被强制转换为对象</li>
</ul>
<pre><code>Object.getOwnPropertyNames(1); // []
Object.getOwnPropertyNames(&quot;hello&quot;); //  [&#39;0&#39;, &#39;1&#39;, &#39;2&#39;, &#39;3&#39;, &#39;4&#39;, &#39;length&#39;]
</code></pre>
</blockquote>
<blockquote>
<blockquote>
<p>注意：</p>
</blockquote>
<ul>
<li>直接定义在对象身上的属性，以上属性特性的默认值分别为：<code>writable:true</code>、<code>value:undefined</code>、<code>configurable：true</code>、<code>enumerable:true</code></li>
<li>通过<code>Object.defineProperty</code>方式定义的属性，其属性特性的默认值分别为：<code>writable:false</code>、<code>value:undefined</code>、<code>configurable：false</code>、<code>enumerable:false</code></li>
</ul>
</blockquote>
<ol start="10">
<li>Object.getOwnPropertySymbols<blockquote>
<p>返回一个给定对象自身的所有<code>Symbol</code>属性的数组</p>
<table>
<thead>
<tr>
<th>方法</th>
<th>原型</th>
<th>自身</th>
<th>自身 Symbol</th>
<th>可枚举</th>
<th>不可枚举</th>
</tr>
</thead>
<tbody><tr>
<td>Object.getOwnPropertySymbols</td>
<td></td>
<td></td>
<td>✔</td>
<td>✔</td>
<td>✔</td>
</tr>
</tbody></table>
</blockquote>
</li>
</ol>
<ul>
<li>语法<blockquote>
<pre><code>Object.getOwnPropertySymbols(obj);
</code></pre>
</blockquote>
</li>
</ul>
<blockquote>
<pre><code>const obj = &#123;
  [Symbol()]: &quot;Symbol&quot;,
  name: &quot;清心&quot;,
&#125;;
Object.defineProperty(obj, &quot;sex&quot;, &#123;
  value: &quot;女&quot;,
&#125;);
</code></pre>
</blockquote>
<p>const desc &#x3D; Object.getOwnPropertySymbols(obj);<br>console.log(desc); &#x2F;&#x2F; [Symbol()]</p>
<blockquote>
<pre><code>
</code></pre>
</blockquote>
<ol start="11">
<li><p>四种获取对象属性方法的对比</p>
<table>
<thead>
<tr>
<th>方法</th>
<th>原型</th>
<th>自身</th>
<th>自身 Symbol</th>
<th>可枚举</th>
<th>不可枚举</th>
</tr>
</thead>
<tbody><tr>
<td>Object.keys()</td>
<td></td>
<td>✔</td>
<td></td>
<td>✔</td>
<td></td>
</tr>
<tr>
<td>for…in</td>
<td>✔</td>
<td>✔</td>
<td></td>
<td>✔</td>
<td></td>
</tr>
<tr>
<td>Object.getOwnPropertyNames</td>
<td></td>
<td>✔</td>
<td></td>
<td>✔</td>
<td>✔</td>
</tr>
<tr>
<td>Object.getOwnPropertySymbols</td>
<td></td>
<td></td>
<td>✔</td>
<td>✔</td>
<td>✔</td>
</tr>
</tbody></table>
</li>
<li><p>Object.freeze</p>
<blockquote>
<p><code>Object.freeze()</code>方法可以冻结一个对象。一个被冻结的对象<strong>再也不能被修改</strong>。</p>
<pre><code>const obj = &#123;
  a: 1,
  b: 2,
  arr: [1, 2, 3],
&#125;;
Object.freeze(obj); // 冻结对象
obj.a = 3; // 修改属性值无效
delete obj.b; // 不能删除属 性
obj.c = 4; // 不能添加属性
console.log(obj); // &#123;a: 1, b: 2, arr: [1, 2, 3]&#125;
</code></pre>
</blockquote>
</li>
</ol>
<ul>
<li><p><code>Object.freeze()</code>冻结对象，属于<strong>浅冻结</strong>。如果对象的属性是一个引用类型，修改属性值指向的对象的属性是可以。</p>
<blockquote>
<pre><code>const obj = &#123;
a: 1,
b: 2,
arr: [1, 2, 3],
&#125;;
Object.freeze(obj); // 冻结对象
obj.arr.push(&quot;abc&quot;);
console.log(obj.arr); // [1, 2, 3, &#39;abc&#39;]
</code></pre>
</blockquote>
</li>
<li><p>深度冻结</p>
<blockquote>
<ul>
<li>以下代码来自 MDN 官方文档</li>
</ul>
<pre><code>// 深冻结函数。
function deepFreeze(obj) &#123;
// 取回定义在 obj 上的属性名
var propNames = Object.getOwnPropertyNames(obj);
</code></pre>
</blockquote>
<p>&#x2F;&#x2F; 在冻结自身之前冻结属性<br>propNames.forEach(function (name) {<br>  var prop &#x3D; obj[name];</p>
<p>  &#x2F;&#x2F; 如果 prop 是个对象，冻结它<br>  if (typeof prop &#x3D;&#x3D; “object” &amp;&amp; prop !&#x3D;&#x3D; null) deepFreeze(prop);<br>});</p>
</li>
</ul>
<blockquote>
</blockquote>
<p>  &#x2F;&#x2F; 冻结自身 (no-op if already frozen)<br>  return Object.freeze(obj);<br>}</p>
<blockquote>
</blockquote>
<p>obj2 &#x3D; {<br>  internal: {},<br>};</p>
<blockquote>
</blockquote>
<p>deepFreeze(obj2);<br>obj2.internal.a &#x3D; “anotherValue”;<br>obj2.internal.a; &#x2F;&#x2F; undefined</p>
<blockquote>
<pre><code>
</code></pre>
</blockquote>
<ol start="13">
<li>Object.fromEntries<blockquote>
<p><code>Object.fromEntries()</code>方法把<strong>键值对列表</strong>转换为一个<strong>对象</strong>。其返回值为一个新的对象。</p>
</blockquote>
</li>
</ol>
<ul>
<li>语法<blockquote>
<pre><code>Object.fromEntries(iterable);
</code></pre>
<ul>
<li><code>iterable</code>可以理解为一个可迭代对象或一个迭代器对象。可迭代对象或迭代器对象的返回值<strong>必须是一个双元素数组</strong>。如:二维数组，<code>Map</code>，<code>Object.entries()</code>的返回值等</li>
</ul>
</blockquote>
</li>
<li>基本用法<blockquote>
<ul>
<li>二维数组转对象</li>
</ul>
<pre><code>const arr = [
[&quot;a&quot;, 1],
[&quot;b&quot;, 2],
[&quot;c&quot;, 3],
];
const obj = Object.fromEntries(arr);
console.log(obj); // &#123;a: 1, b: 2, c: 3&#125;
</code></pre>
</blockquote>
</li>
</ul>
<blockquote>
<ul>
<li>Map 转 Object</li>
</ul>
<pre><code>let map = new Map([
  [&quot;a&quot;, 1],
  [&quot;b&quot;, 2],
  [&quot;c&quot;, 3],
]);
const obj = Object.fromEntries(map);
console.log(obj); // &#123;a: 1, b: 2, c: 3&#125;
</code></pre>
</blockquote>
<blockquote>
<ul>
<li>迭代器对象转对象</li>
</ul>
<pre><code>function* gen() &#123;
  yield [&quot;a&quot;, 1];
  yield [&quot;b&quot;, 2];
  yield [&quot;c&quot;, 3];
&#125;
const obj = Object.fromEntries(gen());
console.log(obj);
</code></pre>
<blockquote>
<p>总结：</p>
</blockquote>
<ul>
<li><code>Object.fromEntries()</code>与<code>Object.entries</code>是<strong>互逆</strong>的操作</li>
</ul>
</blockquote>

                
            </div>
            <hr/>

            

    <div class="reprint" id="reprint-statement">
        
            <div class="reprint__author">
                <span class="reprint-meta" style="font-weight: bold;">
                    <i class="fas fa-user">
                        文章作者:
                    </i>
                </span>
                <span class="reprint-info">
                    <a href="/about" rel="external nofollow noreferrer">hermia</a>
                </span>
            </div>
            <div class="reprint__type">
                <span class="reprint-meta" style="font-weight: bold;">
                    <i class="fas fa-link">
                        文章链接:
                    </i>
                </span>
                <span class="reprint-info">
                    <a href="https://hermiablog.github.io/2023/12/12/JS%E6%A0%B8%E5%BF%83%E7%9F%A5%E8%AF%86%E7%82%B9%EF%BC%88%E4%BA%8C%E5%8D%81%E4%BA%8C%EF%BC%89/">https://hermiablog.github.io/2023/12/12/JS%E6%A0%B8%E5%BF%83%E7%9F%A5%E8%AF%86%E7%82%B9%EF%BC%88%E4%BA%8C%E5%8D%81%E4%BA%8C%EF%BC%89/</a>
                </span>
            </div>
            <div class="reprint__notice">
                <span class="reprint-meta" style="font-weight: bold;">
                    <i class="fas fa-copyright">
                        版权声明:
                    </i>
                </span>
                <span class="reprint-info">
                    本博客所有文章除特別声明外，均采用
                    <a href="https://creativecommons.org/licenses/by/4.0/deed.zh" rel="external nofollow noreferrer" target="_blank">CC BY 4.0</a>
                    许可协议。转载请注明来源
                    <a href="/about" target="_blank">hermia</a>
                    !
                </span>
            </div>
        
    </div>

    <script async defer>
      document.addEventListener("copy", function (e) {
        let toastHTML = '<span>复制成功，请遵循本文的转载规则</span><button class="btn-flat toast-action" onclick="navToReprintStatement()" style="font-size: smaller">查看</a>';
        M.toast({html: toastHTML})
      });

      function navToReprintStatement() {
        $("html, body").animate({scrollTop: $("#reprint-statement").offset().top - 80}, 800);
      }
    </script>



            <div class="tag_share" style="display: block;">
                <div class="post-meta__tag-list" style="display: inline-block;">
                    
                        <div class="article-tag">
                            
                                <a href="/tags/JS/">
                                    <span class="chip bg-color">JS</span>
                                </a>
                            
                        </div>
                    
                </div>
                <div class="post_share" style="zoom: 80%; width: fit-content; display: inline-block; float: right; margin: -0.15rem 0;">
                    <link rel="stylesheet" type="text/css" href="/libs/share/css/share.min.css">
<div id="article-share">

    
    <div class="social-share" data-sites="qq,qzone,wechat,weibo" data-wechat-qrcode-helper="<p>微信扫一扫即可分享！</p>"></div>
    <script src="/libs/share/js/social-share.min.js"></script>
    

    

</div>

                </div>
            </div>
            
                <style>
    #reward {
        margin: 40px 0;
        text-align: center;
    }

    #reward .reward-link {
        font-size: 1.4rem;
        line-height: 38px;
    }

    #reward .btn-floating:hover {
        box-shadow: 0 6px 12px rgba(0, 0, 0, 0.2), 0 5px 15px rgba(0, 0, 0, 0.2);
    }

    #rewardModal {
        width: 320px;
        height: 350px;
    }

    #rewardModal .reward-title {
        margin: 15px auto;
        padding-bottom: 5px;
    }

    #rewardModal .modal-content {
        padding: 10px;
    }

    #rewardModal .close {
        position: absolute;
        right: 15px;
        top: 15px;
        color: rgba(0, 0, 0, 0.5);
        font-size: 1.3rem;
        line-height: 20px;
        cursor: pointer;
    }

    #rewardModal .close:hover {
        color: #ef5350;
        transform: scale(1.3);
        -moz-transform:scale(1.3);
        -webkit-transform:scale(1.3);
        -o-transform:scale(1.3);
    }

    #rewardModal .reward-tabs {
        margin: 0 auto;
        width: 210px;
    }

    .reward-tabs .tabs {
        height: 38px;
        margin: 10px auto;
        padding-left: 0;
    }

    .reward-content ul {
        padding-left: 0 !important;
    }

    .reward-tabs .tabs .tab {
        height: 38px;
        line-height: 38px;
    }

    .reward-tabs .tab a {
        color: #fff;
        background-color: #ccc;
    }

    .reward-tabs .tab a:hover {
        background-color: #ccc;
        color: #fff;
    }

    .reward-tabs .wechat-tab .active {
        color: #fff !important;
        background-color: #22AB38 !important;
    }

    .reward-tabs .alipay-tab .active {
        color: #fff !important;
        background-color: #019FE8 !important;
    }

    .reward-tabs .reward-img {
        width: 210px;
        height: 210px;
    }
</style>

<div id="reward">
    <a href="#rewardModal" class="reward-link modal-trigger btn-floating btn-medium waves-effect waves-light red">赏</a>

    <!-- Modal Structure -->
    <div id="rewardModal" class="modal">
        <div class="modal-content">
            <a class="close modal-close"><i class="fas fa-times"></i></a>
            <h4 class="reward-title">你的赏识是我前进的动力</h4>
            <div class="reward-content">
                <div class="reward-tabs">
                    <ul class="tabs row">
                        <li class="tab col s6 alipay-tab waves-effect waves-light"><a href="#alipay">支付宝</a></li>
                        <li class="tab col s6 wechat-tab waves-effect waves-light"><a href="#wechat">微 信</a></li>
                    </ul>
                    <div id="alipay">
                        <img src="/medias/reward/alipay.jpg" class="reward-img" alt="支付宝打赏二维码">
                    </div>
                    <div id="wechat">
                        <img src="/medias/reward/wechat.png" class="reward-img" alt="微信打赏二维码">
                    </div>
                </div>
            </div>
        </div>
    </div>
</div>

<script>
    $(function () {
        $('.tabs').tabs();
    });
</script>

            
        </div>
    </div>

    

    

    

    

    

    

    

    

<article id="prenext-posts" class="prev-next articles">
    <div class="row article-row">
        
        <div class="article col s12 m6" data-aos="fade-up">
            <div class="article-badge left-badge text-color">
                <i class="fas fa-chevron-left"></i>&nbsp;上一篇</div>
            <div class="card">
                <a href="/2023/12/12/JS%E6%A0%B8%E5%BF%83%E7%9F%A5%E8%AF%86%E7%82%B9%EF%BC%88%E4%BA%8C%E5%8D%81%E4%B8%89%EF%BC%89/">
                    <div class="card-image">
                        
                        <img src="/medias/featureimages/35.jpg" class="responsive-img" alt="JS核心知识点（二十三）">
                        
                        <span class="card-title">JS核心知识点（二十三）</span>
                    </div>
                </a>
                <div class="card-content article-content">
                    <div class="summary block-with-text">
                        
                            Generator函数、Promise对象
                        
                    </div>
                    <div class="publish-info">
                        <span class="publish-date">
                            <i class="far fa-clock fa-fw icon-date"></i>2023-12-12
                        </span>
                        <span class="publish-author">
                            
                            <i class="fas fa-bookmark fa-fw icon-category"></i>
                            
                            <a href="/categories/%E6%8A%80%E6%9C%AF/" class="post-category">
                                    技术
                                </a>
                            
                            
                        </span>
                    </div>
                </div>
                
                <div class="card-action article-tags">
                    
                    <a href="/tags/JS/">
                        <span class="chip bg-color">JS</span>
                    </a>
                    
                </div>
                
            </div>
        </div>
        
        
        <div class="article col s12 m6" data-aos="fade-up">
            <div class="article-badge right-badge text-color">
                下一篇&nbsp;<i class="fas fa-chevron-right"></i>
            </div>
            <div class="card">
                <a href="/2023/12/11/JS%E6%A0%B8%E5%BF%83%E7%9F%A5%E8%AF%86%E7%82%B9%EF%BC%88%E4%BA%8C%E5%8D%81%E4%B8%80%EF%BC%89/">
                    <div class="card-image">
                        
                        <img src="/medias/featureimages/33.jpg" class="responsive-img" alt="JS核心知识点（二十一）">
                        
                        <span class="card-title">JS核心知识点（二十一）</span>
                    </div>
                </a>
                <div class="card-content article-content">
                    <div class="summary block-with-text">
                        
                            Class类的属性、方法、继承、构造函数
                        
                    </div>
                    <div class="publish-info">
                            <span class="publish-date">
                                <i class="far fa-clock fa-fw icon-date"></i>2023-12-11
                            </span>
                        <span class="publish-author">
                            
                            <i class="fas fa-bookmark fa-fw icon-category"></i>
                            
                            <a href="/categories/%E6%8A%80%E6%9C%AF/" class="post-category">
                                    技术
                                </a>
                            
                            
                        </span>
                    </div>
                </div>
                
                <div class="card-action article-tags">
                    
                    <a href="/tags/JS/">
                        <span class="chip bg-color">JS</span>
                    </a>
                    
                </div>
                
            </div>
        </div>
        
    </div>
</article>

</div>



<!-- 代码块功能依赖 -->
<script type="text/javascript" src="/libs/codeBlock/codeBlockFuction.js"></script>

<!-- 代码语言 -->

<script type="text/javascript" src="/libs/codeBlock/codeLang.js"></script>


<!-- 代码块复制 -->

<script type="text/javascript" src="/libs/codeBlock/codeCopy.js"></script>


<!-- 代码块收缩 -->

<script type="text/javascript" src="/libs/codeBlock/codeShrink.js"></script>


  </div>
  <div id="toc-aside" class="expanded col l3 hide-on-med-and-down">
    <div class="toc-widget card" style="background-color: white">
      <div class="toc-title">
        <i class="far fa-list-alt"></i>&nbsp;&nbsp;目录
      </div>
      <div id="toc-content"></div>
    </div>
  </div>
</div>

<!-- TOC 悬浮按钮. -->

<div id="floating-toc-btn" class="hide-on-med-and-down">
  <a class="btn-floating btn-large bg-color">
    <i class="fas fa-list-ul"></i>
  </a>
</div>


<script src="/libs/tocbot/tocbot.min.js"></script>
<script>
  $(function () {
      tocbot.init({
          tocSelector: '#toc-content',
          contentSelector: '#articleContent',
          headingsOffset: -($(window).height() * 0.4 - 45),
          collapseDepth: Number('0'),
          headingSelector: 'h2, h3, h4'
      });

      // modify the toc link href to support Chinese.
      let i = 0;
      let tocHeading = 'toc-heading-';
      $('#toc-content a').each(function () {
          $(this).attr('href', '#' + tocHeading + (++i));
      });

      // modify the heading title id to support Chinese.
      i = 0;
      $('#articleContent').children('h2, h3, h4').each(function () {
          $(this).attr('id', tocHeading + (++i));
      });

      // Set scroll toc fixed.
      let tocHeight = parseInt($(window).height() * 0.4 - 64);
      let $tocWidget = $('.toc-widget');
      $(window).scroll(function () {
          let scroll = $(window).scrollTop();
          /* add post toc fixed. */
          if (scroll > tocHeight) {
              $tocWidget.addClass('toc-fixed');
          } else {
              $tocWidget.removeClass('toc-fixed');
          }
      });

      
      /* 修复文章卡片 div 的宽度. */
      let fixPostCardWidth = function (srcId, targetId) {
          let srcDiv = $('#' + srcId);
          if (srcDiv.length === 0) {
              return;
          }

          let w = srcDiv.width();
          if (w >= 450) {
              w = w + 21;
          } else if (w >= 350 && w < 450) {
              w = w + 18;
          } else if (w >= 300 && w < 350) {
              w = w + 16;
          } else {
              w = w + 14;
          }
          $('#' + targetId).width(w);
      };

      // 切换TOC目录展开收缩的相关操作.
      const expandedClass = 'expanded';
      let $tocAside = $('#toc-aside');
      let $mainContent = $('#main-content');
      $('#floating-toc-btn .btn-floating').click(function () {
          if ($tocAside.hasClass(expandedClass)) {
              $tocAside.removeClass(expandedClass).hide();
              $mainContent.removeClass('l9');
          } else {
              $tocAside.addClass(expandedClass).show();
              $mainContent.addClass('l9');
          }
          fixPostCardWidth('artDetail', 'prenext-posts');
      });
      
  });
</script>

    

</main>




    <footer class="page-footer bg-color">
   <link rel="stylesheet" href="/libs/aplayer/APlayer.min.css">
<style>
    .aplayer .aplayer-lrc p {
        
        font-size: 12px;
        font-weight: 700;
        line-height: 16px !important;
    }

    .aplayer .aplayer-lrc p.aplayer-lrc-current {
        
        font-size: 15px;
        color: #a3ddf0;
        /* color: #59cde9; */
    }

    
    .aplayer.aplayer-fixed.aplayer-narrow .aplayer-body {
        left: -66px !important;
    }

    .aplayer.aplayer-fixed.aplayer-narrow .aplayer-body:hover {
        left: 0px !important;
    }

    
</style>
<div class="">
    
    <div class="row">
        <meting-js class="col l8 offset-l2 m10 offset-m1 s12"
                   server="netease"
                   type="playlist"
                   id="2450546498"
                   fixed='true'
                   autoplay='false'
                   theme='#59cde9'
                   loop='all'
                   order='random'
                   preload='auto'
                   volume='0.7'
                   list-folded='true'
        >
        </meting-js>
    </div>
</div>

<script src="/libs/aplayer/APlayer.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/meting@2/dist/Meting.min.js"></script>
 
  <div
    class="container row center-align"
    style="margin-bottom: 15px !important;"
  >
    <div class="col s12 m8 l8 copy-right">
      Copyright&nbsp;&copy; 
      <span id="year">2023</span>
      
      <span id="year">2023</span>
      <a href="/about" target="_blank"
        >hermia</a
      >
      |&nbsp;Powered by&nbsp;<a href="https://hexo.io/" target="_blank">Hexo</a>
      |&nbsp;Theme&nbsp;<a
        href="https://github.com/blinkfox/hexo-theme-matery"
        target="_blank"
        >Matery</a
      >
      <br />
           
      <span id="busuanzi_container_site_pv">
        |&nbsp;<i class="far fa-eye"></i>&nbsp;总访问量:&nbsp;<span
          id="busuanzi_value_site_pv"
          class="white-color"
        ></span
        >&nbsp;次
      </span>
       
      <span id="busuanzi_container_site_uv">
        |&nbsp;<i class="fas fa-users"></i>&nbsp;总访问人数:&nbsp;<span
          id="busuanzi_value_site_uv"
          class="white-color"
        ></span
        >&nbsp;人
      </span>
      
      <br />
      
      <span id="sitetime">载入运行时间...</span>
      <script>
        function siteTime() {
          var seconds = 1000;
          var minutes = seconds * 60;
          var hours = minutes * 60;
          var days = hours * 24;
          var years = days * 365;
          var today = new Date();
          var startYear = "2023";
          var startMonth = "11";
          var startDate = "14";
          var startHour = "0";
          var startMinute = "0";
          var startSecond = "0";
          var todayYear = today.getFullYear();
          var todayMonth = today.getMonth() + 1;
          var todayDate = today.getDate();
          var todayHour = today.getHours();
          var todayMinute = today.getMinutes();
          var todaySecond = today.getSeconds();
          var t1 = Date.UTC(
            startYear,
            startMonth,
            startDate,
            startHour,
            startMinute,
            startSecond
          );
          var t2 = Date.UTC(
            todayYear,
            todayMonth,
            todayDate,
            todayHour,
            todayMinute,
            todaySecond
          );
          var diff = t2 - t1;
          var diffYears = Math.floor(diff / years);
          var diffDays = Math.floor(diff / days - diffYears * 365);
          var diffHours = Math.floor(
            (diff - (diffYears * 365 + diffDays) * days) / hours
          );
          var diffMinutes = Math.floor(
            (diff - (diffYears * 365 + diffDays) * days - diffHours * hours) /
              minutes
          );
          var diffSeconds = Math.floor(
            (diff -
              (diffYears * 365 + diffDays) * days -
              diffHours * hours -
              diffMinutes * minutes) /
              seconds
          );
          if (startYear == todayYear) {
            document.getElementById("year").innerHTML = todayYear;
            document.getElementById("sitetime").innerHTML =
              "本站已安全运行 " +
              diffDays +
              " 天 " +
              diffHours +
              " 小时 " +
              diffMinutes +
              " 分钟 " +
              diffSeconds +
              " 秒";
          } else {
            document.getElementById("year").innerHTML =
              startYear + " - " + todayYear;
            document.getElementById("sitetime").innerHTML =
              "本站已安全运行 " +
              diffYears +
              " 年 " +
              diffDays +
              " 天 " +
              diffHours +
              " 小时 " +
              diffMinutes +
              " 分钟 " +
              diffSeconds +
              " 秒";
          }
        }
        setInterval(siteTime, 1000);
      </script>
      
      <br />
      
    </div>
    <div class="col s12 m4 l4 social-link social-statis">
      
<a
  href="https://github.com/hermiablog/hermiablog.github.io"
  class="tooltipped"
  target="_blank"
  data-tooltip="访问我的GitHub"
  data-position="top"
  data-delay="50"
>
  <i class="fab fa-github"></i>
</a>
 
<a
  href="mailto:1587837237@qq.com"
  class="tooltipped"
  target="_blank"
  data-tooltip="邮件联系我"
  data-position="top"
  data-delay="50"
>
  <i class="fas fa-envelope-open"></i>
</a>
<!-- 
   
<a
  href="tencent://AddContact/?fromId=50&fromSubId=1&subcmd=all&uin=1587837237"
  class="tooltipped"
  target="_blank"
  data-tooltip="QQ联系我: 1587837237"
  data-position="top"
  data-delay="50"
>
  <i class="fab fa-qq"></i>
</a>
    -->

    </div>
  </div>
</footer>

<div class="progress-bar"></div>


    <!-- 搜索遮罩框 -->
<div id="searchModal" class="modal">
    <div class="modal-content">
        <div class="search-header">
            <span class="title"><i class="fas fa-search"></i>&nbsp;&nbsp;搜索</span>
            <input type="search" id="searchInput" name="s" placeholder="请输入搜索的关键字"
                   class="search-input">
        </div>
        <div id="searchResult"></div>
    </div>
</div>

<script type="text/javascript">
$(function () {
    var searchFunc = function (path, search_id, content_id) {
        'use strict';
        $.ajax({
            url: path,
            dataType: "xml",
            success: function (xmlResponse) {
                // get the contents from search data
                var datas = $("entry", xmlResponse).map(function () {
                    return {
                        title: $("title", this).text(),
                        content: $("content", this).text(),
                        url: $("url", this).text()
                    };
                }).get();
                var $input = document.getElementById(search_id);
                var $resultContent = document.getElementById(content_id);
                $input.addEventListener('input', function () {
                    var str = '<ul class=\"search-result-list\">';
                    var keywords = this.value.trim().toLowerCase().split(/[\s\-]+/);
                    $resultContent.innerHTML = "";
                    if (this.value.trim().length <= 0) {
                        return;
                    }
                    // perform local searching
                    datas.forEach(function (data) {
                        var isMatch = true;
                        var data_title = data.title.trim().toLowerCase();
                        var data_content = data.content.trim().replace(/<[^>]+>/g, "").toLowerCase();
                        var data_url = data.url;
                        data_url = data_url.indexOf('/') === 0 ? data.url : '/' + data_url;
                        var index_title = -1;
                        var index_content = -1;
                        var first_occur = -1;
                        // only match artiles with not empty titles and contents
                        if (data_title !== '' && data_content !== '') {
                            keywords.forEach(function (keyword, i) {
                                index_title = data_title.indexOf(keyword);
                                index_content = data_content.indexOf(keyword);
                                if (index_title < 0 && index_content < 0) {
                                    isMatch = false;
                                } else {
                                    if (index_content < 0) {
                                        index_content = 0;
                                    }
                                    if (i === 0) {
                                        first_occur = index_content;
                                    }
                                }
                            });
                        }
                        // show search results
                        if (isMatch) {
                            str += "<li><a href='" + data_url + "' class='search-result-title'>" + data_title + "</a>";
                            var content = data.content.trim().replace(/<[^>]+>/g, "");
                            if (first_occur >= 0) {
                                // cut out 100 characters
                                var start = first_occur - 20;
                                var end = first_occur + 80;
                                if (start < 0) {
                                    start = 0;
                                }
                                if (start === 0) {
                                    end = 100;
                                }
                                if (end > content.length) {
                                    end = content.length;
                                }
                                var match_content = content.substr(start, end);
                                // highlight all keywords
                                keywords.forEach(function (keyword) {
                                    var regS = new RegExp(keyword, "gi");
                                    match_content = match_content.replace(regS, "<em class=\"search-keyword\">" + keyword + "</em>");
                                });

                                str += "<p class=\"search-result\">" + match_content + "...</p>"
                            }
                            str += "</li>";
                        }
                    });
                    str += "</ul>";
                    $resultContent.innerHTML = str;
                });
            }
        });
    };

    searchFunc('/search.xml', 'searchInput', 'searchResult');
});
</script>

    <!-- 回到顶部按钮 -->
<div id="backTop" class="top-scroll">
    <a class="btn-floating btn-large waves-effect waves-light" href="#!">
        <i class="fas fa-arrow-up"></i>
    </a>
</div>


    <script src="/libs/materialize/materialize.min.js"></script>
    <script src="/libs/masonry/masonry.pkgd.min.js"></script>
    <script src="/libs/aos/aos.js"></script>
    <script src="/libs/scrollprogress/scrollProgress.min.js"></script>
    <script src="/libs/lightGallery/js/lightgallery-all.min.js"></script>
    <script src="/js/matery.js"></script>

    <!-- Baidu Analytics -->

    <!-- Baidu Push -->

<script>
    (function () {
        var bp = document.createElement('script');
        var curProtocol = window.location.protocol.split(':')[0];
        if (curProtocol === 'https') {
            bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';
        } else {
            bp.src = 'http://push.zhanzhang.baidu.com/push.js';
        }
        var s = document.getElementsByTagName("script")[0];
        s.parentNode.insertBefore(bp, s);
    })();
</script>

    
    <script src="/libs/others/clicklove.js" async="async"></script>
    
    
    <script async src="/libs/others/busuanzi.pure.mini.js"></script>
    

    

    

	
    

    

    

    
    <script src="/libs/instantpage/instantpage.js" type="module"></script>
    

</body>

</html>
